import normalizeException from"normalize-exception";

import{setNonEnumProp}from"../utils/descriptors.js";
import{isSubclass}from"../utils/subclass.js";


























export const normalize=(ErrorClass,error,UnknownError=ErrorClass)=>{
if(!isSubclass(UnknownError,ErrorClass)){
throw new TypeError(
`${ErrorClass.name}.normalize()'s second argument should be a subclass of ${ErrorClass.name}, not: ${UnknownError}`);

}

return normalizeError({error,ErrorClass,UnknownError,parents:[]});
};

const normalizeError=({error,ErrorClass,UnknownError,parents})=>{
normalizeAggregateErrors({error,ErrorClass,UnknownError,parents});
return shouldKeepClass(error,ErrorClass,UnknownError)?
normalizeException(error,{shallow:true}):
new UnknownError("",{cause:error});
};




const normalizeAggregateErrors=({
error,
ErrorClass,
UnknownError,
parents
})=>{
if(!Array.isArray(error?.errors)){
return;
}

const parentsA=[...parents,error];
const errors=error.errors.
filter((aggregateError)=>!parentsA.includes(aggregateError)).
map((aggregateError)=>
normalizeError({
error:aggregateError,
ErrorClass,
UnknownError,
parents:parentsA
}));

setNonEnumProp(error,"errors",errors);
};

const shouldKeepClass=(error,ErrorClass,UnknownError)=>
error?.constructor===UnknownError||
error instanceof ErrorClass&&error.constructor!==ErrorClass;
//# sourceMappingURL=normalize.js.map