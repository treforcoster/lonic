import{excludeKeys,includeKeys}from"filter-obj";
import isPlainObj from"is-plain-obj";

import{instancesData}from"../subclass/map.js";

import{deepClone}from"./clone.js";
import{mergePluginsOpts,getPluginNames}from"./merge.js";


export const computePluginsOpts=(ErrorClass,plugins,opts={})=>{
validateOpts(ErrorClass,opts);
const{errors,...optsA}=opts;
const nativeOpts=excludeKeys(optsA,getPluginNames(plugins));
const pluginsOpts=includeKeys(optsA,getPluginNames(plugins));
const pluginsOptsA=wrapPluginsOpts(plugins,pluginsOpts,nativeOpts);
return{nativeOpts,errors,pluginsOpts:pluginsOptsA};
};













const validateOpts=(ErrorClass,opts)=>{
if(!isPlainObj(opts)){
throw new TypeError(
`Error options must be a plain object or undefined: ${opts}`);

}

if(opts.custom!==undefined){
throw new TypeError(
`Error option "custom" must be passed to "${ErrorClass.name}.subclass()", not to error constructors.`);

}
};





const wrapPluginsOpts=(plugins,pluginsOpts,{cause})=>{
if(!instancesData.has(cause)){
return pluginsOpts;
}

const causePluginsOpts=instancesData.get(cause).pluginsOpts;
const pluginsOptsA=mergePluginsOpts(causePluginsOpts,pluginsOpts,plugins);
return deepClone(pluginsOptsA);
};
//# sourceMappingURL=instance.js.map