import type * as methods from './methods/index.js';
import type { Module } from './module.js';
import type ConsoleBuffer from './services/console.js';
import type FS from './services/fs.js';
import type * as Options from './types/options/index.js';
import type Hooks from './types/services/hooks/index.js';
import type * as Services from './types/services/index.js';
import Value from './value.js';
/**
 * Bud core class
 */
export declare class Bud {
    /**
     * Context
     */
    context: Options.CommandContext | Options.CLIContext | Options.Context;
    /**
     * Implementation
     */
    implementation: new () => Bud;
    /**
     * Compilation mode
     *
     * @remarks
     * Either `production` or `development`.
     *
     * @readonly
     * @defaultValue `production`
     */
    get mode(): `development` | `production`;
    /**
     * Label
     * @readonly
     */
    get label(): string;
    /**
     * Parent {@link Bud} instance
     * @readonly
     */
    get root(): Bud;
    /**
     * True when {@link Bud.mode} is `production`
     * @readonly
     */
    get isProduction(): boolean;
    /**
     * True when {@link Bud.mode} is `development`
     * @readonly
     */
    get isDevelopment(): boolean;
    /**
     * True when current instance is the parent instance
     * @readonly
     */
    get isRoot(): boolean;
    /**
     * True when current instance is a child instance
     * @readonly
     */
    get isChild(): boolean;
    /**
     * True when current instance has context set by CLI
     */
    isCLI(): this is Bud & {
        context: Options.CommandContext;
    };
    /**
     * {@link Bud} instances
     */
    children?: Record<string, Bud> | undefined;
    /**
     * True when child compilers
     * @readonly
     */
    get hasChildren(): boolean;
    consoleBuffer: ConsoleBuffer;
    fs: FS;
    module: Module;
    services: Array<string>;
    api: Services.Api;
    build: Services.Build.Service;
    cache: Services.Cache.Service;
    compiler: Services.Compiler.Service;
    dashboard: Services.Dashboard.Service;
    env: Services.Env;
    extensions: Services.Extensions.Service;
    hooks: Hooks;
    notifier: Services.Notifier;
    project: Services.Project.Service;
    server: Services.Server.Service;
    after: methods.after;
    maybeCall: methods.maybeCall;
    close: methods.close;
    container: methods.container;
    get: methods.get;
    glob: methods.glob;
    globSync: methods.globSync;
    path: methods.path;
    pipe: methods.pipe;
    processConfigs: methods.processConfigs;
    publicPath: methods.publicPath;
    relPath: methods.relPath;
    run: methods.run;
    setPath: methods.setPath;
    setPublicPath: methods.setPublicPath;
    sequence: methods.sequence;
    sequenceSync: methods.sequenceSync;
    sh: methods.sh;
    tap: methods.tap;
    tapAsync: methods.tapAsync;
    when: methods.when;
    bindMethod: methods.bindMethod;
    /**
     * @deprecated Use {@link bud.fs.json | bud.fs.json}
     */
    json: FS['json'];
    /**
     * @deprecated Use {@link bud.fs.yml | bud.fs.yml}
     */
    yml: FS['yml'];
    /**
     * Value helper
     */
    value: typeof Value;
    /**
     * Creates a child with `bud.create` but returns the parent instance
     */
    make(request: Partial<Options.Context> | string, tap?: (app: Bud) => Promise<unknown>): Promise<Bud>;
    lifecycle(context: Options.Context): Promise<Bud>;
    /**
     * Log a message
     */
    log(...messages: any[]): this;
    /**
     * Log an `info` level message
     */
    info(...messages: any[]): this;
    /**
     * Log a `success` level message
     */
    success(...messages: any[]): this;
    /**
     * Log a `warning` level message
     */
    warn(...messages: any[]): this;
    /**
     * Log an error
     */
    error(...messages: Array<any>): Bud;
}
//# sourceMappingURL=bud.d.ts.map