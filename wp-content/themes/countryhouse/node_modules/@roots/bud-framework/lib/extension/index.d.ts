import type { Bud } from '../bud.js';
import type { Modules } from '../index.js';
import type { ApplyPluginConstructor } from './decorators/plugin.js';
export type Options<T = Record<string, any>> = {
    [K in keyof T as `${K & string}`]?: T[K];
};
export type OptionsMap<MappedOptions extends Options> = {
    [K in keyof MappedOptions as `${K & string}`]?: ((app: Bud) => MappedOptions[K]) | MappedOptions[K];
};
/**
 * Webpack plugin.
 */
export interface ApplyPlugin {
    /**
     * @see {@link https://webpack.js.org/contribute/writing-a-plugin/#basic-plugin-architecture}
     */
    apply: (...args: any[]) => unknown;
}
export interface Constructor {
    new (...args: any[]): Extension;
}
export interface PublicExtensionApi<E extends Extension = Extension> {
    app: Bud;
    /**
     * Set an option value
     */
    get: E[`getOption`];
    getOption: E[`getOption`];
    /**
     * Set an option value
     */
    set: <K extends string>(key: K, value: this[`options`][K] | ((value: this[`options`][K]) => this[`options`][K])) => this;
    /**
     * Set an option value
     */
    setOption: <K extends string>(key: K, value: this[`options`][K] | ((value: this[`options`][K]) => this[`options`][K])) => this;
    getOptions: E[`getOptions`];
    setOptions: E[`setOptions`];
    enabled: E['enabled'];
    enable: E['enable'];
    options: E['options'];
    label: E['label'];
}
export type ExtensionLiteral = Partial<Extension>;
/**
 * Bud extension
 */
export declare class Extension<ExtensionOptions extends Options = Options, Plugin extends ApplyPlugin = ApplyPlugin> {
    /**
     * Application
     */
    _app: () => Bud;
    /**
     * Application accessor
     */
    app: Bud;
    /**
     * {@link ApplyPlugin.apply}
     */
    apply?: ApplyPlugin[`apply`];
    enabled: boolean;
    /**
     * Extension options
     */
    optionsMap: OptionsMap<ExtensionOptions>;
    /**
     * Extension options
     *
     * @readonly
     */
    readonly options: ExtensionOptions;
    /**
     * Extension meta
     */
    meta: {
        register: boolean;
        boot: boolean;
        configAfter: boolean;
        buildBefore: boolean;
        buildAfter: boolean;
    };
    /**
     * The module name
     */
    label: keyof Modules & string;
    /**
     * Logger instance
     */
    get logger(): import("../index.js").Logger;
    /**
     * Depends on
     */
    dependsOn?: Set<keyof Modules & string>;
    /**
     * Depends on (optional)
     */
    dependsOnOptional?: Set<`${keyof Modules & string}`>;
    /**
     * Function returning a boolean indicating if the {@link Extension} should be utilized.
     *
     * @remarks
     * By default returns {@link Extension.enabled}
     */
    when(bud: Bud, options?: ExtensionOptions): boolean;
    /**
     * `init` callback
     */
    init?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * {@link Extension.register}
     */
    register?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `boot` callback
     *
     * @param options - Extension options
     * @param app - Bud instance
     */
    boot?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `configAfter` callback
     */
    configAfter?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `buildBefore` callback
     */
    buildBefore?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `buildAfter` callback
     */
    buildAfter?(app: Bud, options?: ExtensionOptions): Promise<unknown>;
    /**
     * `make` callback
     */
    make?(app: Bud, options?: ExtensionOptions): Promise<Plugin>;
    /**
     * Plugin constructor
     */
    plugin?: ApplyPluginConstructor;
    /**
     * Class constructor
     */
    constructor(app: Bud);
    /**
     * `register` callback handler
     */
    _register(): Promise<void>;
    /**
     * `boot` callback handler
     */
    _boot(): Promise<void>;
    /**
     * `buildBefore` callback handler
     */
    _buildBefore(): Promise<void>;
    /**
     * `buildAfter` callback handler
     */
    _buildAfter(): Promise<void>;
    /**
     * `configAfter` callback handler
     */
    _configAfter(): Promise<void>;
    /**
     * `make` callback handler
     */
    _make(): Promise<false | import("./decorators/plugin.js").ApplyPlugin | this>;
    /**
     * Get extension options
     */
    getOptions(): ExtensionOptions;
    /**
     * Set extension options
     */
    setOptions(value: ExtensionOptions | ((options: ExtensionOptions) => ExtensionOptions)): this;
    /**
     * Get extension option
     */
    getOption<K extends string>(key: K): ExtensionOptions[K];
    get: <K extends string>(key: K) => ExtensionOptions[K];
    /**
     * Set extension option
     */
    setOption<K extends string>(key: K, value: OptionsMap<ExtensionOptions>[K] | ((value: OptionsMap<ExtensionOptions>[K]) => OptionsMap<ExtensionOptions>[K])): this;
    set: <K extends string>(key: K, value: OptionsMap<ExtensionOptions>[K] | ((value: OptionsMap<ExtensionOptions>[K]) => OptionsMap<ExtensionOptions>[K])) => this;
    /**
     * Normalize options to functions
     */
    toOptionsMap<K extends keyof ExtensionOptions & string>(funcMap: OptionsMap<ExtensionOptions>, [key, value]: [K & string, ExtensionOptions[K & string]]): OptionsMap<ExtensionOptions>;
    /**
     * Get options from function map
     */
    fromOptionsMap<K extends keyof OptionsMap<ExtensionOptions>>(options: ExtensionOptions, [key, value]: [K, OptionsMap<ExtensionOptions>[K]]): ExtensionOptions;
    /**
     * Assign properties from an object
     */
    fromObject(extensionObject: ExtensionLiteral): this;
    /**
     * Returns true if extension property is set and is a function
     */
    isFunction<K extends `${keyof Extension}`>(key: K): boolean;
    /**
     * Resolve module using `import.meta.resolve` api
     */
    resolve(signifier: string, context?: string): Promise<string>;
    /**
     * Import ESM module
     */
    import<T = any>(signifier: string, context?: string): Promise<T | undefined>;
    /**
     * Disable extension
     * @deprecated pass `false` to {@link Extension.enable}
     */
    disable(): void;
    /**
     * Enable extension
     */
    enable(enabled?: boolean): this;
    /**
     * Is extension enabled?
     */
    isEnabled(): boolean;
}
//# sourceMappingURL=index.d.ts.map