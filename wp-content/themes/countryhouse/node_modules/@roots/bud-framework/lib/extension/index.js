var _a, _b, _c;
import { __decorate, __metadata } from "tslib";
import { bind } from '@roots/bud-support/decorators';
import { BudError, ImportError } from '@roots/bud-support/errors';
import get from '@roots/bud-support/lodash/get';
import isFunction from '@roots/bud-support/lodash/isFunction';
import isUndefined from '@roots/bud-support/lodash/isUndefined';
import set from '@roots/bud-support/lodash/set';
/**
 * Bud extension
 */
export class Extension {
    /**
     * Logger instance
     */
    get logger() {
        return this.app.context.logger.scope(...[this.app.label, this.label].filter(Boolean));
    }
    /**
     * Function returning a boolean indicating if the {@link Extension} should be utilized.
     *
     * @remarks
     * By default returns {@link Extension.enabled}
     */
    when(bud, options) {
        return this.enabled;
    }
    /**
     * Class constructor
     */
    constructor(app) {
        this.enabled = true;
        /**
         * Extension options
         */
        this.optionsMap = {};
        /**
         * Extension meta
         */
        this.meta = {
            register: false,
            boot: false,
            configAfter: false,
            buildBefore: false,
            buildAfter: false,
        };
        this.get = this.getOption;
        this.set = this.setOption;
        this._app = () => app;
        Object.defineProperty(this, `app`, {
            get: () => this._app(),
        });
        const opts = this.options ?? {};
        Object.defineProperty(this, `options`, {
            get: this.getOptions,
            set: this.setOptions,
        });
        this.setOptions(opts);
    }
    /**
     * `register` callback handler
     */
    async _register() {
        if (isUndefined(this.register))
            return;
        try {
            await this.register(this.app, this.options);
            this.meta[`register`] = true;
        }
        catch (error) {
            throw error;
        }
        this.logger.success(`registered`);
    }
    /**
     * `boot` callback handler
     */
    async _boot() {
        if (isUndefined(this.boot))
            return;
        if (!this.meta[`register`])
            await this._register();
        try {
            await this.boot(this.app, this.options);
            this.meta[`boot`] = true;
        }
        catch (error) {
            throw error;
        }
        this.logger.success(`booted`);
    }
    /**
     * `buildBefore` callback handler
     */
    async _buildBefore() {
        const enabled = await this.isEnabled();
        if (isUndefined(this.buildBefore) || enabled === false)
            return;
        this.logger.info(`buildBefore:`, this.label ?? this.constructor.name ?? `anonymous extension`);
        this.meta[`buildBefore`] = true;
        await this.buildBefore(this.app, this.options);
    }
    /**
     * `buildAfter` callback handler
     */
    async _buildAfter() {
        const enabled = await this.isEnabled();
        if (isUndefined(this.buildAfter) || enabled === false)
            return;
        this.logger.info(`buildAfter:`, this.label ?? this.constructor.name ?? `anonymous extension`);
        this.logger.log(`buildAfter`);
        this.meta[`buildAfter`] = true;
        await this.buildAfter(this.app, this.options);
    }
    /**
     * `configAfter` callback handler
     */
    async _configAfter() {
        const enabled = await this.isEnabled();
        if (isUndefined(this.configAfter) || enabled === false)
            return;
        this.logger.log(`configAfter`);
        this.meta[`configAfter`] = true;
        await this.configAfter(this.app, this.options);
    }
    /**
     * `make` callback handler
     */
    async _make() {
        if (isUndefined(this.make) && isUndefined(this.plugin)) {
            return false;
        }
        if (this.isEnabled() === false) {
            return false;
        }
        try {
            if (!isUndefined(this.apply)) {
                this.logger.info(`apply prop found. return extension instance`);
                return this;
            }
            if (!isUndefined(this.plugin)) {
                const plugin = new this.plugin(this.options);
                this.logger.success(`produced webpack plugin`);
                return plugin;
            }
            if (!isUndefined(this.make)) {
                const plugin = await this.make(this.app, this.options);
                this.logger.success(`produced webpack plugin`);
                return plugin;
            }
        }
        catch (error) {
            const ident = this.label ?? this.constructor?.name ?? `unknown_extension`;
            throw new BudError(`Error instantiating ${ident}`, {
                props: {
                    details: `Check options for ${ident}`,
                    thrownBy: this.constructor.name,
                    origin: BudError.normalize(error),
                    docs: new URL(`https://bud.js.org/docs/extensions`),
                    issues: new URL(`https://github.com/roots/bud/search?q=is:issue+${ident} in:title`),
                },
            });
        }
    }
    /**
     * Get extension options
     */
    getOptions() {
        return Object.entries(this.optionsMap ?? {}).reduce(this.fromOptionsMap, {});
    }
    /**
     * Set extension options
     */
    setOptions(value) {
        this.optionsMap = isFunction(value) ? value(this.options) : value;
        return this;
    }
    /**
     * Get extension option
     */
    getOption(key) {
        const raw = this.getOptions();
        return get(raw, key);
    }
    /**
     * Set extension option
     */
    setOption(key, value) {
        if (!this.optionsMap)
            this.optionsMap = {};
        set(this.optionsMap, key, isFunction(value) ? value(this.getOption(key)) : value);
        return this;
    }
    /**
     * Normalize options to functions
     */
    toOptionsMap(funcMap = {}, [key, value]) {
        return {
            ...funcMap,
            [key]: isFunction(value) ? value : () => value,
        };
    }
    /**
     * Get options from function map
     */
    fromOptionsMap(options, [key, value]) {
        return {
            ...(options ?? {}),
            [key]: isFunction(value) ? value(this.app) : value,
        };
    }
    /**
     * Assign properties from an object
     */
    fromObject(extensionObject) {
        extensionObject &&
            Object.entries(extensionObject).map(([k, v]) => {
                this[k] = v;
            });
        return this;
    }
    /**
     * Returns true if extension property is set and is a function
     */
    isFunction(key) {
        return key in this && isFunction(this[key]) ? true : false;
    }
    /**
     * Resolve module using `import.meta.resolve` api
     */
    async resolve(signifier, context) {
        let modulePath;
        try {
            modulePath = await this.app.module.resolve(signifier, context);
        }
        catch (error) {
            const cause = BudError.normalize(error);
            throw new ImportError(`could not resolve ${signifier}`, {
                props: {
                    thrownBy: this.label,
                    origin: cause,
                },
            });
        }
        return modulePath;
    }
    /**
     * Import ESM module
     */
    async import(signifier, context) {
        try {
            const result = await this.app.module.import(signifier, context);
            this.logger.success(`imported`, signifier);
            return result?.default ?? result ?? undefined;
        }
        catch (error) {
            throw new ImportError(`could not import ${signifier}`, {
                props: {
                    thrownBy: this.label,
                    origin: ImportError.normalize(error),
                },
            });
        }
    }
    /**
     * Disable extension
     * @deprecated pass `false` to {@link Extension.enable}
     */
    disable() {
        this.enabled = false;
    }
    /**
     * Enable extension
     */
    enable(enabled = true) {
        this.enabled = enabled;
        return this;
    }
    /**
     * Is extension enabled?
     */
    isEnabled() {
        return this.when(this.app, this.options);
    }
}
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_register", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_boot", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_buildBefore", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_buildAfter", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_configAfter", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_make", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], Extension.prototype, "getOptions", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Object)
], Extension.prototype, "setOptions", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_a = typeof K !== "undefined" && K) === "function" ? _a : Object]),
    __metadata("design:returntype", Object)
], Extension.prototype, "getOption", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof K !== "undefined" && K) === "function" ? _b : Object, Object]),
    __metadata("design:returntype", Object)
], Extension.prototype, "setOption", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Array]),
    __metadata("design:returntype", Object)
], Extension.prototype, "toOptionsMap", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Array]),
    __metadata("design:returntype", Object)
], Extension.prototype, "fromOptionsMap", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Object)
], Extension.prototype, "fromObject", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof K !== "undefined" && K) === "function" ? _c : Object]),
    __metadata("design:returntype", Boolean)
], Extension.prototype, "isFunction", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], Extension.prototype, "resolve", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], Extension.prototype, "import", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], Extension.prototype, "disable", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], Extension.prototype, "enable", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Boolean)
], Extension.prototype, "isEnabled", null);
//# sourceMappingURL=index.js.map