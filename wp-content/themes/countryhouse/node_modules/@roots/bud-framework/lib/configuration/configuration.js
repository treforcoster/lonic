import { __decorate, __metadata } from "tslib";
import { bind } from '@roots/bud-support/decorators';
import { BudError } from '@roots/bud-support/errors';
import get from '@roots/bud-support/lodash/get';
import isArray from '@roots/bud-support/lodash/isArray';
import isFunction from '@roots/bud-support/lodash/isFunction';
import isObject from '@roots/bud-support/lodash/isObject';
import isString from '@roots/bud-support/lodash/isString';
/**
 * User config parser
 */
class Configuration {
    /**
     * Class constructor
     */
    constructor(bud) {
        this.bud = bud;
    }
    /**
     * Process configuration
     */
    async run(description) {
        if (!description?.module) {
            throw new BudError(`No module found`, {
                props: {
                    details: `There should be a module here. This is like an error with bud.js`,
                    file: description,
                },
            });
        }
        return description.dynamic
            ? await this.dynamicConfig(description)
            : await this.staticConfig(description);
    }
    /**
     * Process dynamic configuration
     */
    async dynamicConfig(description) {
        this.bud.log(`processing as dynamic configuration:`, description.name);
        if (!description.module) {
            throw new Error(`There should be a module to load from ${description.name}, but it's missing.`);
        }
        const config = await description.module();
        if (!isFunction(config)) {
            this.bud.log(description.name, `does not export a function. maybe it is a script?`);
            return;
        }
        try {
            return await config(this.bud);
        }
        catch (cause) {
            throw cause;
        }
    }
    /**
     * Process static configuration
     */
    async staticConfig(description) {
        this.bud.log(`processing as static configuration:`, description.name);
        return await Promise.all(Object.entries(description.module).map(async ([key, value]) => {
            await this.handleConfigEntry(this.bud, [key, value]);
        }));
    }
    async handleConfigEntry(obj, [key, value]) {
        if (!(key in obj))
            return;
        const request = obj[key];
        const normalValue = isArray(value) ? value : [value];
        const parsedValue = normalValue.map(v => {
            if (isString(v) &&
                (v.startsWith(`_app.`) || v.startsWith(`_bud.`))) {
                return get(this.bud, v.replace(`_app.`, ``).replace(`_bud.`, ``).trim());
            }
            if (isString(v) &&
                (v.startsWith(`bud =>`) || v.startsWith(`app =>`))) {
                return eval(v.trim())(this.bud);
            }
            if (isString(v) && v.startsWith(`=>`)) {
                return eval(v.slice(3));
            }
            return v;
        });
        if (isFunction(request))
            await request(...parsedValue);
        if (isObject(request))
            await Promise.all(Object.entries(value).map(async ([key, value]) => {
                return await this.handleConfigEntry(request, [key, value]);
            }));
    }
}
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Configuration.prototype, "run", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Configuration.prototype, "dynamicConfig", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Configuration.prototype, "staticConfig", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Array]),
    __metadata("design:returntype", Promise)
], Configuration.prototype, "handleConfigEntry", null);
export default Configuration;
//# sourceMappingURL=configuration.js.map