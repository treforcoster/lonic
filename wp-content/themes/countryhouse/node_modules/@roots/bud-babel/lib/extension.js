import { __decorate, __metadata } from "tslib";
import { Extension } from '@roots/bud-framework/extension';
import { bind, expose, label, } from '@roots/bud-framework/extension/decorators';
import { InputError } from '@roots/bud-support/errors';
import isUndefined from '@roots/bud-support/lodash/isUndefined';
/**
 * Babel support for `@roots/bud`
 */
let BabelExtension = class BabelExtension extends Extension {
    constructor() {
        super(...arguments);
        /**
         * Babel env
         */
        this.env = {
            development: { compact: false },
        };
        /**
         * Plugins registry
         */
        this.plugins = {};
        /**
         * Presets registry
         */
        this.presets = {};
    }
    /**
     * Boolean representing if project has a babel config file
     */
    get overridenByProjectConfigFile() {
        if (!this.app.context.files)
            return false;
        return Object.values(this.app.context.files).some(file => file?.name?.startsWith(`.babelrc`) ||
            (file?.name?.includes(`babel.config`) && file?.module));
    }
    get configFile() {
        return Object.values(this.app.context.files).find(file => file?.name?.startsWith(`.babelrc`) ||
            (file?.name?.includes(`babel.config`) && file?.module));
    }
    /**
     * Cache directory
     */
    get cacheDirectory() {
        return this.app.cache.enabled
            ? this.app.path(this.app.cache.cacheDirectory, `babel`)
            : false;
    }
    getEnv() {
        return this.env;
    }
    setEnv(env) {
        this.env = env;
        return this;
    }
    /**
     * Root directory
     */
    get root() {
        return this.app.path();
    }
    /**
     * Loader options
     *
     * @readonly
     */
    get loaderOptions() {
        const baseOptions = {
            cacheIdentifier: `babel`,
            cacheDirectory: this.cacheDirectory,
            configFile: false,
        };
        return this.overridenByProjectConfigFile
            ? {
                ...baseOptions,
                ...this.configFileOptions,
            }
            : {
                presets: Object.values(this.presets),
                plugins: Object.values(this.plugins),
                env: this.env,
                root: this.root,
                targets: this.app.context.files[`package.json`].module.browserslist ??
                    `defaults`,
            };
    }
    /**
     * {@link Extension.register}
     */
    async register() {
        if (this.overridenByProjectConfigFile) {
            this.logger.log(`Babel configuration is being overridden by project configuration file.`);
            this.configFileOptions =
                this.configFile.module.default ?? this.configFile.module;
            return;
        }
        const presetEnv = await this.resolve(`@babel/preset-env`, import.meta.url);
        if (presetEnv)
            this.setPreset(`@babel/preset-env`, presetEnv);
        const transformRuntime = await this.resolve(`@babel/plugin-transform-runtime`, import.meta.url);
        if (transformRuntime)
            this.setPlugin(`@babel/plugin-transform-runtime`, [
                transformRuntime,
                { helpers: false },
            ]);
    }
    /**
     * {@link Extension.configAfter}
     */
    async configAfter(bud) {
        const loader = await this.resolve(`babel-loader`, import.meta.url);
        if (!loader)
            return this.logger.error(`Babel loader not found`);
        bud.build.setLoader(`babel`, loader).setItem(`babel`, {
            loader: `babel`,
            options: () => this.loaderOptions,
        });
        bud.build.rules.js.setUse((items = []) => [
            bud.build.items.babel,
            ...items,
        ]);
    }
    /**
     * Set a babel preset
     */
    setPreset(name, preset) {
        if (this.overridenByProjectConfigFile) {
            this.logger.warn(`Babel configuration is being overridden by project configuration file.\n`, `bud.babel.setPresets will not work as expected\n`, `tried to set`, name, `to`, preset);
        }
        if (!preset) {
            this.presets[name] = [name];
            return this;
        }
        this.presets[name] = Array.isArray(preset) ? preset : [preset];
        return this;
    }
    /**
     * Set babel presets
     */
    setPresets(presets) {
        if (this.overridenByProjectConfigFile) {
            this.logger.warn(`Babel configuration is being overridden by project configuration file.\n`, `bud.babel.setPresets will not work as expected\n`, `tried to set:`, presets);
        }
        this.presets = Object.entries(presets).reduce((presets, [name, preset]) => {
            if (Array.isArray(preset)) {
                presets[name] = preset;
                return presets;
            }
            presets[name] = [preset];
            return presets;
        }, {});
        return this;
    }
    /**
     * Remove a babel preset
     */
    unsetPreset(preset) {
        if (this.overridenByProjectConfigFile) {
            this.logger.warn(`Babel configuration is being overridden by project configuration file.\n`, `bud.babel.unsetPreset will not work as expected\n`, `tried to unset:`, preset);
        }
        if (!isUndefined(this.presets[preset]))
            this.presets[preset] = undefined;
        return this;
    }
    /**
     * Set options on a babel preset
     */
    setPresetOptions(preset, options) {
        if (this.overridenByProjectConfigFile) {
            this.logger.warn(`Babel configuration is being overridden by project configuration file.\n`, `bud.babel.setPresetOptions will not work as expected\n`, `tried to set options:`, options, `for`, preset);
        }
        this.presets[preset] = [this.presets[preset].shift(), options];
        return this;
    }
    /**
     * Set a babel plugin
     */
    setPlugin(name, plugin) {
        if (this.overridenByProjectConfigFile) {
            this.logger.warn(`Babel configuration is being overridden by project configuration file.\n`, `bud.babel.setPlugin will not work as expected\n`, `tried to set`, name, `to`, plugin);
        }
        if (!plugin && Array.isArray(name)) {
            this.plugins[name[0]] = name;
            return this;
        }
        if (!plugin && !Array.isArray(name)) {
            this.plugins[name] = [name];
            return this;
        }
        if (Array.isArray(name)) {
            throw new InputError(`When defined without options the babel plugin name must be a string.`, {
                props: {
                    thrownBy: `bud.babel.setPlugin`,
                    docs: new URL(`https://bud.js.org/extensions/bud-babel`),
                },
            });
        }
        this.plugins[name] = Array.isArray(plugin) ? plugin : [plugin];
        return this;
    }
    /**
     * Set babel presets
     */
    setPlugins(plugins) {
        if (this.overridenByProjectConfigFile) {
            this.logger.warn(`Babel configuration is being overridden by project configuration file.\n`, `bud.babel.setPresetOptions will not work as expected\n`, `tried to set plugins:`, plugins);
        }
        this.plugins = Object.entries(plugins).reduce((plugins, [name, plugin]) => {
            if (Array.isArray(plugin)) {
                plugins[name] = plugin;
                return plugins;
            }
            plugins[name] = [plugin];
            return plugins;
        }, {});
        return this;
    }
    /**
     * Remove a babel plugin
     */
    unsetPlugin(plugin) {
        if (this.overridenByProjectConfigFile) {
            this.logger.warn(`Babel configuration is being overridden by project configuration file.\n`, `bud.babel.setPresetOptions will not work as expected\n`, `tried to unset plugin:`, plugin);
        }
        if (!isUndefined(this.plugins[plugin]))
            this.plugins[plugin] = undefined;
        return this;
    }
    /**
     * Set options on a babel plugin
     */
    setPluginOptions(plugin, options) {
        if (this.overridenByProjectConfigFile) {
            this.logger.warn(`Babel configuration is being overridden by project configuration file.\n`, `bud.babel.setPresetOptions will not work as expected\n`, `tried to set options:`, options, `for`, plugin);
        }
        this.plugins[plugin] = [this.plugins[plugin].shift(), options];
        return this;
    }
};
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BabelExtension.prototype, "register", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function]),
    __metadata("design:returntype", Promise)
], BabelExtension.prototype, "configAfter", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Object)
], BabelExtension.prototype, "setPreset", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Object)
], BabelExtension.prototype, "setPresets", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], BabelExtension.prototype, "unsetPreset", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Object)
], BabelExtension.prototype, "setPresetOptions", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Object)
], BabelExtension.prototype, "setPlugin", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Object)
], BabelExtension.prototype, "setPlugins", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], BabelExtension.prototype, "unsetPlugin", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Object)
], BabelExtension.prototype, "setPluginOptions", null);
BabelExtension = __decorate([
    label(`@roots/bud-babel`),
    expose(`babel`)
], BabelExtension);
export default BabelExtension;
//# sourceMappingURL=extension.js.map