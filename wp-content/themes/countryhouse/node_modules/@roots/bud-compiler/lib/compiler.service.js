import { __decorate, __metadata } from "tslib";
import { jsx as _jsx } from "react/jsx-runtime";
import { pathToFileURL } from 'node:url';
import * as App from '@roots/bud-dashboard/app';
import { Service } from '@roots/bud-framework/service';
import { bind } from '@roots/bud-support/decorators';
import { BudError, CompilerError } from '@roots/bud-support/errors';
import { duration } from '@roots/bud-support/human-readable';
import stripAnsi from '@roots/bud-support/strip-ansi';
import * as Ink from 'ink';
/**
 * Wepback compilation controller class
 */
export class Compiler extends Service {
    constructor() {
        super(...arguments);
        /**
         * Configuration
         */
        this.config = [];
    }
    /**
     * Initiates compilation
     */
    async compile() {
        this.implementation = await this.app.module.import(`webpack`, import.meta.url);
        this.logger.log(`imported webpack`, this.implementation.version);
        this.config = !this.app.hasChildren
            ? [await this.app.build.make()]
            : await Promise.all(Object.values(this.app.children).map(async (child) => {
                try {
                    return await child.build.make();
                }
                catch (error) {
                    throw error;
                }
            }));
        await this.app.hooks.fire(`compiler.before`, this.app);
        if (this.app.isCLI() && this.app.context.args.dry) {
            this.logger.timeEnd(`initialize`);
            this.logger.log(`running in dry mode. exiting early.`);
            return;
        }
        this.logger.timeEnd(`initialize`);
        this.logger.await(`compilation`);
        this.instance = this.implementation(this.config);
        this.instance.hooks.done.tap(this.app.label, async (stats) => {
            await this.onStats(stats);
            await this.app.hooks.fire(`compiler.close`, this.app);
        });
        await this.app.hooks.fire(`compiler.after`, this.app);
        return this.instance;
    }
    /**
     * Stats handler
     */
    async onStats(stats) {
        const makeNoticeTitle = (child) => this.app.label !== child.name
            ? `${this.app.label} (${child.name})`
            : child.name;
        this.stats = stats.toJson(this.app.hooks.filter(`build.stats`));
        await this.app.hooks.fire(`compiler.stats`, stats);
        const statsUpdate = this.app.dashboard.update(stats);
        if (stats.hasErrors()) {
            process.exitCode = 1;
            this.stats.children = this.stats.children?.map(child => ({
                ...child,
                errors: this.sourceErrors(child.errors),
            }));
            this.stats.children
                ?.filter(child => child.errorsCount > 0)
                .forEach(child => {
                try {
                    const error = child.errors?.shift();
                    if (!error)
                        return;
                    this.app.notifier.notify({
                        title: makeNoticeTitle(child),
                        subtitle: error.file ? `Error in ${error.name}` : error.name,
                        message: stripAnsi(error.message),
                        open: error.file ? pathToFileURL(error.file) : ``,
                        group: `${this.app.label}-${child.name}`,
                    });
                    this.app.notifier.openEditor(error.file);
                }
                catch (error) {
                    this.logger.error(error);
                }
            });
        }
        this.stats.children
            ?.filter(child => child.errorsCount === 0)
            .forEach(child => {
            try {
                this.app.notifier.notify({
                    title: makeNoticeTitle(child),
                    subtitle: `Build successful`,
                    message: child.modules
                        ? `${child.modules.length} modules compiled in ${duration(child.time)}`
                        : `Compiled in ${duration(child.time)}`,
                    group: `${this.app.label}-${child.name}`,
                    open: this.app.server?.publicUrl.href,
                });
                this.app.notifier.openBrowser(this.app.server?.publicUrl.href);
            }
            catch (error) {
                this.logger.error(error);
            }
        });
        await statsUpdate;
    }
    /**
     * Compiler error event
     */
    async onError(error) {
        process.exitCode = 1;
        await this.app.hooks.fire(`compiler.error`, error);
        this.app.isDevelopment &&
            this.app.server.appliedMiddleware?.hot?.publish({ error });
        try {
            this.app.notifier.notify({
                subtitle: error.name,
                message: error.message,
                group: this.app.label,
            });
        }
        catch (error) {
            this.logger.error(error);
        }
        try {
            Ink.render(_jsx(App.Error, { error: new CompilerError(error.message, {
                    props: {
                        details: `This error was thrown by the webpack compiler itself. It is not the same as a syntax error. It is likely a missing or unresolvable build dependency.`,
                        stack: error.stack,
                        thrownBy: `webpack`,
                        docs: new URL(`https://bud.js.org/`),
                        issues: new URL(`https://github.com/roots/bud/search?q=is:issue+"compiler" in:title`),
                    },
                }) }));
        }
        catch (error) {
            throw BudError.normalize(error);
        }
    }
    /**
     * Parse errors from webpack stats
     */
    sourceErrors(errors) {
        if (!errors || !errors.length)
            return [];
        try {
            const parseError = (error) => {
                let file;
                const modules = this.stats.children.flatMap(child => child.modules);
                const moduleIdent = error.moduleId ?? error.moduleName;
                const module = modules.find(module => module?.id === moduleIdent || module?.name === moduleIdent);
                if (!module) {
                    return error;
                }
                if (module.nameForCondition) {
                    file = module.nameForCondition;
                }
                else if (module.name) {
                    file = this.app.path(`@src`, module.name);
                }
                if (!file) {
                    return error;
                }
                return { ...error, name: module.name ?? error.name, file };
            };
            return errors?.map(parseError).filter(Boolean);
        }
        catch (error) {
            this.app.warn(`error parsing errors`, error);
            return [];
        }
    }
}
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Compiler.prototype, "compile", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function]),
    __metadata("design:returntype", Promise)
], Compiler.prototype, "onStats", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Error]),
    __metadata("design:returntype", Promise)
], Compiler.prototype, "onError", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", Array)
], Compiler.prototype, "sourceErrors", null);
//# sourceMappingURL=compiler.service.js.map