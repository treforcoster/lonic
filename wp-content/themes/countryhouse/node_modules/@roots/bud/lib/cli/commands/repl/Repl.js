import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { highlight } from '@roots/bud-support/highlight';
import chunk from '@roots/bud-support/lodash/chunk';
import format from '@roots/bud-support/pretty-format';
import * as Ink from 'ink';
import TextInput from 'ink-text-input';
import { useEffect, useState } from 'react';
export const Repl = ({ app, indent, depth }) => {
    const [search, setSearch] = useState(``);
    const [result, setResult] = useState(``);
    const [paged, setPaged] = useState([]);
    const [page, setPage] = useState(0);
    const [action, setAction] = useState(``);
    const pageSize = 10;
    Ink.useInput((input, key) => {
        if (key.escape) {
            // eslint-disable-next-line
            process.exit(0);
        }
        if (key.upArrow) {
            setAction(`up`);
            page >= 1 ? setPage(page - 1) : setPage(paged.length - 1);
        }
        if (key.downArrow) {
            setAction(`down`);
            page < paged.length - 1 ? setPage(page + 1) : setPage(0);
        }
        if (key.tab) {
            setAction(`tab`);
            setSearch(``);
        }
        if (key.return) {
            setAction(`return`);
            setResult(``);
            setPaged([]);
            setPage(0);
        }
    });
    useEffect(() => {
        action !== `` &&
            setTimeout(() => {
                setAction(``);
            }, 500);
    }, [action]);
    useEffect(() => {
        if (result) {
            setPaged(chunk(result.split(`\n`), pageSize).map(page => page.join(`\n`)));
        }
    }, [result, pageSize]);
    useEffect(() => {
        if (page > paged.length) {
            setPage(paged.length - 1);
        }
    }, [page, paged]);
    const makeFn = (value) => eval(`async (bud) => ${value};`);
    const processResults = (raw) => {
        if (raw === undefined) {
            setResult(`undefined`);
            return;
        }
        try {
            const result = highlight(format(raw, {
                indent: parseInt(indent),
                maxDepth: parseInt(depth),
            }));
            setResult(result);
        }
        catch (e) {
            setResult(e.message);
        }
    };
    const onSubmit = (value) => {
        ;
        (async () => {
            try {
                const fn = makeFn(value);
                const results = await fn(app);
                processResults(results);
                await app.api.processQueue();
            }
            catch (err) {
                setResult(err.message);
            }
        })();
    };
    return (_jsxs(Ink.Box, { flexDirection: "column", children: [_jsxs(Ink.Box, { marginY: 1, flexDirection: "column", children: [_jsxs(Ink.Box, { flexDirection: "row", justifyContent: "space-between", children: [_jsx(Ink.Box, { flexDirection: "row", justifyContent: "flex-start", children: _jsx(TextInput, { placeholder: "bud.build.config.entry", value: search, onChange: setSearch, onSubmit: onSubmit }) }), paged.length > 0 ? (_jsxs(Ink.Box, { flexDirection: "row", justifyContent: "flex-start", marginTop: 1, children: [_jsxs(Ink.Text, { color: action === `up` || action === `down` ? `green` : `white`, children: ["page", ` `] }), _jsx(Ink.Text, { color: action === `up` || action === `down` ? `green` : `white`, children: page + 1 }), _jsx(Ink.Text, { children: "/" }), _jsx(Ink.Text, { color: action === `up` || action === `down` ? `green` : `white`, children: paged.length })] })) : null] }), paged[page] ? (_jsx(Ink.Box, { flexDirection: "column", justifyContent: "flex-start", children: _jsx(Ink.Text, { children: paged[page] }) })) : null] }), _jsxs(Ink.Box, { marginY: 1, flexDirection: "row", children: [_jsxs(Ink.Text, { children: [_jsx(Ink.Text, { backgroundColor: action === `esc` ? `green` : `white`, color: "black", children: "[esc]" }), ` `, "quit"] }), _jsx(Ink.Text, { children: `  ` }), _jsxs(Ink.Text, { children: [_jsx(Ink.Text, { backgroundColor: action === `tab` ? `green` : `white`, color: "black", children: "[tab]" }), ` `, "clear"] }), _jsx(Ink.Text, { children: `  ` }), _jsxs(Ink.Text, { children: [_jsx(Ink.Text, { backgroundColor: action === `down` ? `green` : `white`, color: "black", children: "[\u2193]" }), ` `, "next"] }), _jsx(Ink.Text, { children: `  ` }), _jsxs(Ink.Text, { children: [_jsx(Ink.Text, { backgroundColor: action === `up` ? `green` : `white`, color: "black", children: "[\u2191]" }), ` `, "prev"] }), _jsx(Ink.Text, { children: `  ` }), _jsxs(Ink.Text, { children: [_jsx(Ink.Text, { backgroundColor: action === `return` ? `green` : `white`, color: "black", children: "[return]" }), ` `, "eval"] })] })] }));
};
//# sourceMappingURL=Repl.js.map