import { __decorate, __metadata } from "tslib";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
/* eslint-disable react/no-unescaped-entities */
import BudCommand from '@roots/bud/cli/commands/bud';
import { Error } from '@roots/bud-dashboard/app';
import { Command } from '@roots/bud-support/clipanion';
import { bind } from '@roots/bud-support/decorators';
import { BudError, InputError } from '@roots/bud-support/errors';
import figures from '@roots/bud-support/figures';
import prettyFormat from '@roots/bud-support/pretty-format';
import webpack from '@roots/bud-support/webpack';
import * as Ink from 'ink';
import { WinError } from '../../components/WinError.js';
import { dry } from '../../decorators/command.dry.js';
import { isWindows } from '../../helpers/isWindows.js';
/**
 * bud doctor command
 */
let BudDoctorCommand = class BudDoctorCommand extends BudCommand {
    constructor() {
        super(...arguments);
        this.withArguments = async (args) => {
            return { ...args, cache: false, dry: true };
        };
        this.enabledExtensions = [];
        this.disabledExtensions = [];
        this.entrypoints = [];
        this.resolvedDependencies = {};
        this.makeTimer = () => {
            const start = process.hrtime();
            return () => {
                const end = process.hrtime(start);
                return this.seconds(end);
            };
        };
        this.timings = {};
    }
    seconds(hrTime) {
        return (hrTime[0] + hrTime[1] / 1e9).toFixed(2);
    }
    /**
     * Execute command
     */
    async execute() {
        const { Doctor } = await import(`./Doctor.js`);
        const buildTimer = this.makeTimer();
        await this.makeBud(this);
        await this.bud.run();
        this.timings.build = buildTimer();
        if (isWindows()) {
            this.renderStatic(_jsx(WinError, {}));
        }
        const name = this.bud.context.manifest.name
            ? this.bud.context.manifest.name
            : this.bud.path();
        this.renderStatic(_jsx(Doctor, { name: name, timings: this.timings }));
        if (await this.bud.fs.exists(this.bud.cache.cacheDirectory)) {
            this.renderStatic(_jsxs(Ink.Box, { flexDirection: "column", children: [_jsxs(Ink.Text, { color: "yellow", children: [figures.info, " Detected compilation cache"] }), _jsx(Ink.Spacer, {}), _jsxs(Ink.Text, { children: ["If you are experiencing issues with bud.js you should start by clearing the cache.", `\n`] }), _jsxs(Ink.Text, { children: [figures.triangleRightSmall, " To delete this directory with the CLI run", ` `, _jsx(Ink.Text, { color: "green", children: "`bud clean`" }), ", or;"] }), _jsxs(Ink.Text, { children: [figures.triangleRightSmall, " Use the", ` `, _jsx(Ink.Text, { color: "green", children: "`--force`" }), " flag on your next build"] })] }));
        }
        if (this.bud.hasChildren) {
            this.renderStatic(_jsxs(Ink.Box, { flexDirection: "column", children: [_jsxs(Ink.Text, { color: "blue", children: ["Child compilers", `\n`] }), Object.values(this.bud.children).map((child, i) => (_jsxs(Ink.Box, { flexDirection: "row", children: [_jsx(Ink.Text, { children: figures.triangleRightSmall }), _jsx(Ink.Text, { children: ` ` }), _jsx(Ink.Text, { children: child.label })] }, i))), _jsx(Ink.Text, { children: ` ` }), _jsx(Ink.Text, { children: "Note that not all `bud doctor` checks are not currently compatible with multi-compiler builds." })] }));
        }
        this.renderStatic(_jsxs(Ink.Box, { flexDirection: "column", children: [_jsx(Ink.Text, { color: "blue", children: "Project paths" }), _jsx(Ink.Text, { children: ` ` }), _jsxs(Ink.Text, { children: ["project: ", this.bud.path()] }), _jsxs(Ink.Text, { children: ["input:", ` `, this.bud.path(`@src`).replace(this.bud.path(), `@project`)] }), _jsxs(Ink.Text, { children: ["output:", ` `, this.bud.path(`@dist`).replace(this.bud.path(), `@project`)] }), _jsxs(Ink.Text, { children: ["cache:", ` `, this.bud.path(`@os-cache`)] }), _jsxs(Ink.Text, { children: ["storage:", ` `, this.bud.path(`@storage`).replace(this.bud.path(), `@project`)] })] }));
        this.renderStatic(_jsxs(Ink.Box, { flexDirection: "column", children: [_jsx(Ink.Text, { color: "blue", children: "Checking versions of core packages" }), _jsx(Ink.Text, { children: ` ` }), await this.packageCheck(`@roots/bud-api`), await this.packageCheck(`@roots/bud-build`), await this.packageCheck(`@roots/bud-cache`), await this.packageCheck(`@roots/bud-dashboard`), await this.packageCheck(`@roots/bud-extensions`), await this.packageCheck(`@roots/bud-framework`), await this.packageCheck(`@roots/bud-hooks`), await this.packageCheck(`@roots/bud-server`), await this.packageCheck(`@roots/bud-support`)] }));
        const check = (top = false) => async ([signifier, version]) => {
            if (!top) {
                this.resolvedDependencies[signifier] = version;
            }
            try {
                const path = await this.bud.module.getManifestPath(signifier);
                if (!path)
                    return;
                const manifest = await this.bud.fs.json.read(path);
                if (!manifest.dependencies)
                    return;
                Object.entries(manifest.dependencies).forEach(([signifier, version]) => {
                    this.resolvedDependencies[signifier] = version;
                });
                await Promise.all(Object.entries(manifest.dependencies)
                    .filter(([signifier]) => signifier.startsWith(`@roots`))
                    .flatMap(check()));
            }
            catch (e) { }
        };
        try {
            await Promise.all([
                ...(this.bud.context.manifest?.dependencies
                    ? Object.entries(this.bud.context.manifest.dependencies)
                    : []),
                ...(this.bud.context.manifest?.devDependencies
                    ? Object.entries(this.bud.context.manifest.devDependencies)
                    : []),
            ]
                .filter(Boolean)
                .filter(([signifier]) => signifier.startsWith(`@roots`))
                .map(check(true)));
        }
        catch (e) { }
        this.renderStatic(_jsxs(Ink.Box, { flexDirection: "column", children: [_jsxs(Ink.Text, { color: "blue", children: ["Checking installed package compatibility", `\n`] }), Object.entries(this.resolvedDependencies).map(this.formatDepCheck)] }));
        this.renderStatic(_jsxs(Ink.Box, { flexDirection: "column", children: [_jsx(Ink.Text, { color: "blue", children: "Mode" }), _jsx(Ink.Text, { children: this.bud.mode })] }));
        const configFiles = (this.bud.context.files ? Object.values(this.bud.context.files) : []).filter(({ bud }) => bud);
        if (configFiles.length) {
            this.renderStatic(_jsxs(Ink.Box, { flexDirection: "column", children: [_jsxs(Ink.Text, { color: "blue", children: ["Bud configuration files", `\n`] }), configFiles.map(({ name, path }, i) => (_jsxs(Ink.Box, { children: [_jsxs(Ink.Text, { children: [figures.triangleRightSmall, " ", name] }), _jsx(Ink.Text, { children: ` ` }), _jsx(Ink.Text, { dimColor: true, children: path.replace(this.bud.context.basedir, `.`) })] }, i)))] }));
        }
        else {
            this.renderStatic(_jsxs(Ink.Box, { flexDirection: "column", children: [_jsxs(Ink.Text, { color: "blue", children: ["Registered configurations", `\n`] }), _jsx(Ink.Text, { dimColor: true, children: "No configuration files found in project" })] }));
        }
        try {
            this.renderStatic(_jsxs(Ink.Box, { flexDirection: "column", children: [_jsxs(Ink.Text, { color: "blue", children: ["Config API calls", `\n`] }), _jsx(Ink.Text, {}), !this.bud.api.trace.length ? (_jsx(Ink.Text, { dimColor: true, children: "No config calls logged" })) : (this.bud.api.trace.map(([fn, args], i) => (_jsxs(Ink.Box, { flexDirection: "row", children: [_jsxs(Ink.Text, { children: [figures.triangleRightSmall, " ", fn] }), _jsx(Ink.Text, { children: ` ` }), _jsx(Ink.Text, { dimColor: true, children: args.map(this.bud.fs.json.stringify).join(`, `) })] }, i))))] }));
        }
        catch (error) {
            this.renderStatic(_jsx(Error, { error: BudError.normalize(error) }));
        }
        try {
            this.configuration = await this.bud.build.make();
            this.entrypoints = this.configuration.entry
                ? Object.entries(this.configuration.entry)
                : [];
            await Promise.all(Object.entries(this.bud.extensions.repository).map(async ([name, extension]) => {
                if (extension.isEnabled()) {
                    return this.enabledExtensions.push([name, extension]);
                }
                return this.disabledExtensions.push([name, extension]);
            }));
        }
        catch (error) {
            this.renderStatic(_jsx(Error, { error: BudError.normalize(error) }));
        }
        if (this.bud.env) {
            try {
                this.renderStatic(_jsxs(Ink.Box, { flexDirection: "column", children: [_jsxs(Ink.Text, { color: "blue", children: ["Environment", `\n`] }), this.bud.env.getEntries().map(([key, value]) => {
                            return (_jsxs(Ink.Box, { flexDirection: "row", children: [_jsx(Ink.Text, { children: figures.triangleRightSmall }), _jsx(Ink.Text, { children: ` ` }), _jsx(Ink.Text, { children: key }), _jsx(Ink.Text, { children: ` ` }), _jsx(Ink.Text, { dimColor: true, children: typeof value === `string` && value.length > 0
                                            ? `************`
                                            : typeof value })] }, key));
                        })] }));
            }
            catch (error) {
                this.renderStatic(_jsx(Error, { error: BudError.normalize(error) }));
            }
        }
        if (this.enabledExtensions) {
            try {
                this.renderStatic(_jsxs(Ink.Box, { flexDirection: "column", children: [_jsxs(Ink.Text, { color: "blue", children: ["Enabled extensions", `\n`] }), this.mapExtensions(this.enabledExtensions)] }));
                this.renderStatic(_jsxs(Ink.Box, { flexDirection: "column", children: [_jsxs(Ink.Text, { color: "blue", children: ["Disabled extensions", `\n`] }), this.mapExtensions(this.disabledExtensions)] }));
            }
            catch (error) {
                this.renderStatic(_jsx(Error, { error: BudError.normalize(error) }));
            }
        }
        if (!this.bud.hasChildren &&
            this.entrypoints.length === 1 &&
            this.entrypoints[0][0] === `main` &&
            this.entrypoints[0][1].import[0] === `index` &&
            !(await this.bud.fs.exists(this.bud.path(`@src/index.js`)))) {
            this.renderStatic(_jsx(Error, { error: new InputError(`No entrypoint specified`, {
                    props: {
                        details: `No entrypoint was specified and there is also no file resolvable at \`${this.bud.relPath(`@src/index.js`)}\`. Either specify an entrypoint or create a file at \`${this.bud.relPath(`@src/index.js`)}\`.`,
                    },
                }) }));
        }
        if (this.mode === `development`) {
            this.renderStatic(_jsxs(Ink.Box, { flexDirection: "column", children: [_jsx(Ink.Text, { color: "blue", children: "Development server" }), _jsxs(Ink.Box, { flexDirection: "row", children: [_jsx(Ink.Text, { children: "URL:" }), _jsx(Ink.Text, { children: this.bud.hooks
                                    .filter(`dev.url`, new URL(`http://0.0.0.0:3000`))
                                    .toString() })] }), this.bud.hooks
                        .filter(`dev.middleware.enabled`)
                        .includes(`proxy`) ? (_jsxs(Ink.Box, { flexDirection: "row", children: [_jsx(Ink.Text, { children: "Proxy:" }), _jsx(Ink.Text, { children: this.bud.hooks
                                    .filter(`dev.middleware.proxy.options.target`, new URL(`http://0.0.0.0:8000`))
                                    .toString() })] })) : null, _jsxs(Ink.Box, { flexDirection: "column", children: [_jsx(Ink.Text, { children: "Client scripts:" }), [...this.bud.hooks.filter(`dev.client.scripts`, new Set([]))]
                                .map(fn => fn(this.bud))
                                .map((script, key) => {
                                return (_jsxs(Ink.Text, { children: [figures.triangleRightSmall, " ", script] }, key));
                            })] })] }));
        }
        try {
            webpack.validate(this.configuration);
            this.renderStatic(_jsx(Ink.Box, { children: _jsxs(Ink.Text, { color: "green", children: [figures.tick, " webpack validated configuration"] }) }));
        }
        catch (error) {
            this.renderStatic(_jsx(Ink.Box, { children: _jsxs(Ink.Text, { color: "red", children: ["\u274C ", error?.message ?? error] }) }));
        }
    }
    mapExtensions(extensions) {
        return extensions.map(([name, extension]) => (_jsx(Ink.Box, { flexDirection: "column", children: _jsxs(Ink.Text, { color: "white", children: [figures.triangleRightSmall, " ", name] }) }, `extension-${name}`)));
    }
    mapEntrypoints(entrypoints) {
        return entrypoints.map(([name, entry]) => {
            return (_jsxs(Ink.Box, { flexDirection: "column", children: [_jsx(Ink.Text, { children: name }), _jsx(Ink.Text, { dimColor: true, children: prettyFormat(entry, {
                            printBasicPrototype: false,
                        }) })] }, `${name}-entry`));
        });
    }
    async ls(path) {
        const formatFilesArray = (files) => {
            return files.map((file, id) => {
                return (_jsxs(Ink.Box, { flexDirection: file.children ? `column` : `row`, children: [_jsxs(Ink.Text, { children: [_jsx(Ink.Text, { dimColor: true, children: file.children ? figures.ellipsis : figures.pointerSmall }), ` `, file.name] }), file.children ? (_jsx(Ink.Box, { paddingLeft: 2, flexDirection: "column", children: formatFilesArray(file.children) })) : null] }, `${file.name}-file`));
            });
        };
        const files = await this.bud.fs.inspectTree(path);
        return files.children ? formatFilesArray(files.children) : null;
    }
    async packageCheck(signifier) {
        const manifest = await this.bud.module.getManifestPath(signifier);
        const { version: packageVersion } = await this.bud.fs.read(manifest);
        if (packageVersion !== this.bud.context.bud.version) {
            return (_jsx(Error, { error: BudError.normalize(`${signifier} is not installed at the same version as @roots/bud (required: ${this.bud.context.bud.version}, installed: ${packageVersion}).
          Your installation may be corrupted or your package manager may have cached an outdated module; consider reinstalling with the \`--force\` flag.`) }));
        }
        else {
            return (_jsxs(Ink.Text, { children: [_jsxs(Ink.Text, { color: "green", children: [figures.tick, " ", signifier, " meets requirements"] }), ` `, "(required:", ` `, this.bud.context.bud.version, ", installed: ", packageVersion, ")"] }));
        }
    }
    formatDepCheck([dependency, requestedVersion], key) {
        if (dependency.startsWith(`@roots`))
            return null;
        const renderMessage = (type) => (_jsxs(Ink.Text, { children: [_jsxs(Ink.Text, { color: "yellow", children: [figures.warning, `  `, dependency] }), ` `, "is overridden in your project `", type, "`. If you do not require a custom version of", ` `, dependency, " you should remove it."] }, key));
        if (this.bud.context.manifest.devDependencies &&
            Object.keys(this.bud.context.manifest.devDependencies).includes(dependency)) {
            return renderMessage(`devDependencies`);
        }
        if (this.bud.context.manifest.dependencies &&
            Object.keys(this.bud.context.manifest.dependencies).includes(dependency)) {
            return renderMessage(`dependencies`);
        }
        return (_jsxs(Ink.Text, { children: [_jsxs(Ink.Text, { color: "green", children: [figures.tick, " ", dependency] }), ` `, "is managed by bud.js (", requestedVersion, ")"] }, key));
    }
};
BudDoctorCommand.paths = [[`doctor`]];
BudDoctorCommand.usage = Command.Usage({
    description: `Check project for common errors`,
    details: `\
The \`bud doctor\` command will:

1. validate the \`production\` configuration with \`webpack\`

\`webpack\` exports a \`validate\` function which is used by this command to verify that
the configuration matches the \`webpack\` configuration schema.

2. check the \`dependencies\` and \`devDependencies\` in the \`package.json\` file.

In general, \`bud.js\` dependencies should be kept at the same version. This script doesn't account
for a lot of edge cases so it might return a false positive.
`,
    examples: [
        [`Check compiled configuration against webpack`, `$0 doctor`],
    ],
});
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", void 0)
], BudDoctorCommand.prototype, "formatDepCheck", null);
BudDoctorCommand = __decorate([
    dry
], BudDoctorCommand);
export default BudDoctorCommand;
//# sourceMappingURL=index.js.map