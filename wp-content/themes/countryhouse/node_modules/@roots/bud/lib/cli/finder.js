import { __decorate, __metadata } from "tslib";
/* eslint-disable no-console */
import { dirname, join } from 'node:path/posix';
import { fileURLToPath } from 'node:url';
import { bind } from '@roots/bud-support/decorators';
import globby from '@roots/bud-support/globby';
import { resolve } from '@roots/bud-support/import-meta-resolve';
import isString from '@roots/bud-support/lodash/isString';
/**
 * Command finder class
 */
export class Commands {
    /**
     */
    constructor(context, application) {
        this.context = context;
        this.application = application;
    }
    /**
     * @public
     * @static
     */
    static get(application, context) {
        if (Commands.instance)
            return Commands.instance;
        else {
            Commands.instance = new Commands(context, application);
            return Commands.instance;
        }
    }
    /**
     */
    async getCommands() {
        const resolvedExtensionPaths = await this.getRegistrationModulePaths();
        return resolvedExtensionPaths.filter(Boolean);
    }
    /**
     */
    async getRegistrationModulePaths() {
        return await this.resolveExtensionCommandPaths(this.getProjectDependencySignifiers()).then(this.findExtensionCommandPaths);
    }
    /**
     * Get array of project dependency and devDependency signifiers
     */
    getProjectDependencySignifiers() {
        return Object.keys({
            ...(this.context.manifest?.dependencies ?? {}),
            ...(this.context.manifest?.devDependencies ?? {}),
        }).filter(signifier => !signifier.startsWith(`@types`));
    }
    /**
     * Find commands shipped with a given extension
     */
    async findExtensionCommandPaths(paths) {
        return await Promise.all(paths
            .map(dirname)
            .map(async (path) => await globby(join(path, join(`bud`, `commands`, `index.js`))))).then(results => results.flat());
    }
    async resolveExtensionCommandPaths(paths) {
        return await Promise.all(paths.map(async (path) => {
            try {
                return await resolve(path, import.meta.url);
            }
            catch (error) { }
        })).then(paths => paths.filter(isString).map(fileURLToPath));
    }
    /**
     * Import and register commands with the clipanion app
     */
    async registerExtensionCommandPaths(registerCallback) {
        try {
            await registerCallback(this.application);
        }
        catch (error) { }
    }
    static async importCommandsFromPaths(paths) {
        try {
            return await Promise.all(paths.map(async (path) => {
                try {
                    return await import(path).then(({ default: register }) => register);
                }
                catch (error) { }
            }));
        }
        catch (error) { }
    }
}
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Commands.prototype, "getCommands", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Commands.prototype, "getRegistrationModulePaths", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Array)
], Commands.prototype, "getProjectDependencySignifiers", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", Promise)
], Commands.prototype, "findExtensionCommandPaths", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Commands.prototype, "registerExtensionCommandPaths", null);
//# sourceMappingURL=finder.js.map