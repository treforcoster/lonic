import { __decorate, __metadata } from "tslib";
import { jsxs as _jsxs, jsx as _jsx } from "react/jsx-runtime";
import BudCommand from '@roots/bud/cli/commands/bud';
import { dry } from '@roots/bud/cli/decorators/command.dry';
import { Command, Option } from '@roots/bud-support/clipanion';
import { bind } from '@roots/bud-support/decorators';
import * as Ink from 'ink';
/**
 * `bud clean`
 */
let BudCleanCommand = class BudCleanCommand extends BudCommand {
    constructor() {
        super(...arguments);
        this.storage = Option.String(`--storage`, undefined, {
            description: `Storage directory (relative to project)`,
            env: `APP_PATH_STORAGE`,
        });
        this.storageArg = Option.Boolean(`@storage,storage`, false, {
            description: `empty @storage`,
        });
        this.outputArg = Option.Boolean(`@dist,dist,output`, false, {
            description: `empty @dist`,
        });
        this.cacheArg = Option.Boolean(`@cache,cache`, false, {
            description: `empty @cache`,
        });
    }
    /**
     * Execute command
     */
    async execute() {
        await this.makeBud(this);
        await this.healthcheck(this);
        const cleanAll = !this.outputArg && !this.storageArg && !this.cacheArg;
        if (this.storageArg || cleanAll) {
            await this.cleanStorage();
        }
        if (this.outputArg || cleanAll) {
            await this.cleanOutput();
        }
        if (this.cacheArg || cleanAll) {
            await this.cleanCache();
        }
    }
    filterCompiler(child) {
        return !this.filter || this.filter.includes(child.label);
    }
    async cleanOutput() {
        if (this.bud.hasChildren) {
            return await Promise.all(Object.values(this.bud.children)
                .filter(this.filterCompiler)
                .map(async (child) => {
                await this.bud.fs.remove(child.path(`@dist`));
                await this.renderStatic(_jsx(Ink.Box, { children: _jsxs(Ink.Text, { color: "green", children: ["\u2714 emptied ", child.path(`@dist`)] }) }));
            }));
        }
        await this.bud.fs.remove(this.bud.path(`@dist`));
        await this.renderStatic(_jsx(Ink.Box, { children: _jsxs(Ink.Text, { color: "green", children: ["\u2714 emptied ", this.bud.path(`@dist`)] }) }));
    }
    async cleanCache() {
        if (this.bud.hasChildren) {
            return await Promise.all(Object.values(this.bud.children)
                .filter(this.filterCompiler)
                .map(async (child) => {
                await this.bud.fs.remove(child.cache.cacheDirectory);
                await this.renderStatic(_jsx(Ink.Box, { children: _jsxs(Ink.Text, { color: "green", children: ["\u2714 emptied ", child.cache.cacheDirectory] }) }));
            }));
        }
        await this.bud.fs.remove(this.bud.path(`@os-cache`));
        await this.renderStatic(_jsx(Ink.Box, { children: _jsxs(Ink.Text, { color: "green", children: ["\u2714 emptied ", this.bud.cache.cacheDirectory] }) }));
        await this.bud.fs.remove(this.bud.path(`@storage`, `conf`));
        await this.renderStatic(_jsx(Ink.Box, { children: _jsxs(Ink.Text, { color: "green", children: ["\u2714 emptied ", this.bud.path(`@storage`, `conf`)] }) }));
    }
    async cleanStorage() {
        if (this.bud.hasChildren) {
            return await Promise.all(Object.values(this.bud.children)
                .filter(this.filterCompiler)
                .map(async (child) => {
                await this.bud.fs.remove(child.path(`@storage`));
                await this.renderStatic(_jsx(Ink.Box, { children: _jsxs(Ink.Text, { color: "green", children: ["\u2714 emptied ", child.path(`@storage`)] }) }));
            }));
        }
        await this.bud.fs.remove(this.bud.path(`@storage`));
        await this.bud.fs.remove(this.bud.path(`@os-cache`));
        await this.renderStatic(_jsx(Ink.Box, { children: _jsxs(Ink.Text, { color: "green", children: ["\u2714 emptied ", this.bud.path(`@storage`)] }) }));
    }
};
BudCleanCommand.paths = [[`clean`]];
BudCleanCommand.usage = Command.Usage({
    category: `tasks`,
    description: `Clean project artifacts and caches`,
    details: `
      \`bud clean\` empties the \`@dist\` and \`@storage\` directories.
      \`bud clean @dist\` empties the \`@dist\` directory.
      \`bud clean @storage\` empties the \`@storage\` directory.
      \`bud clean cache\` empties the \`@storage/cache\` directory.
`,
    examples: [
        [`Clean artifacts/caches`, `$0 clean`],
        [`Clean dist`, `$0 clean @dist`],
        [`Clean storage`, `$0 clean @storage`],
    ],
});
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function]),
    __metadata("design:returntype", Boolean)
], BudCleanCommand.prototype, "filterCompiler", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BudCleanCommand.prototype, "cleanOutput", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BudCleanCommand.prototype, "cleanCache", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BudCleanCommand.prototype, "cleanStorage", null);
BudCleanCommand = __decorate([
    dry
], BudCleanCommand);
export default BudCleanCommand;
//# sourceMappingURL=bud.clean.js.map