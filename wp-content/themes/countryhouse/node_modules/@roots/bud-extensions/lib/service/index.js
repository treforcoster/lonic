var _a, _b, _c;
import { __decorate, __metadata } from "tslib";
import { randomUUID } from 'node:crypto';
import { Extension } from '@roots/bud-framework/extension';
import { Service } from '@roots/bud-framework/service';
import { bind } from '@roots/bud-support/decorators';
import isUndefined from '@roots/bud-support/lodash/isUndefined';
import Container from '@roots/container';
import { handleManifestSchemaWarning } from './util/handleManifestSchemaWarning.js';
import { isConstructor } from './util/isConstructor.js';
/**
 * Extensions Service
 */
export default class Extensions extends Service {
    constructor(bud) {
        super(bud);
        /**
         * Registered extensions
         */
        // @ts-ignore
        this.repository = {};
        /**
      -   * Modules on which an import attempt was made and failed
      -   *
      -   * @remarks
      -   * This doesn't mean an error, per se. This should only
      -   * be used in the context of trying to import `optionalDependencies`
      -   * of a given extension module.
      -   *
      -   * @public
      -   */
        this.unresolvable = new Set();
        this.options = new Container({
            allowlist: [],
            denylist: [],
            discover: true,
        });
    }
    /**
     * `register` callback
     *
     * @todo
     * All this is doing is helping transition people to using `bud.extensions` key for
     * `allowList` and `denyList`. It can be removed in a future release. (2022-10-18)
     */
    async register(bud) {
        handleManifestSchemaWarning.bind(this)(bud);
    }
    /**
     * `booted` callback
     */
    async booted(bud) {
        const { extensions, manifest } = bud.context;
        if (manifest?.bud?.extensions) {
            const { discover: _discover, discovery: _discovery, allowlist, denylist, } = manifest.bud.extensions;
            const discover = _discover ?? _discovery;
            if (!isUndefined(discover))
                this.options.set(`discover`, discover);
            if (!isUndefined(allowlist))
                this.options.merge(`allowlist`, allowlist);
            if (!isUndefined(denylist))
                this.options.merge(`denylist`, denylist);
        }
        if (manifest?.[this.app.label]?.extensions) {
            const { discover, allowlist, denylist } = manifest[this.app.label].extensions;
            if (!isUndefined(discover))
                this.options.set(`discover`, discover);
            if (!isUndefined(allowlist))
                this.options.merge(`allowlist`, allowlist);
            if (!isUndefined(denylist))
                this.options.merge(`denylist`, denylist);
        }
        if (!isUndefined(extensions.builtIn) &&
            Array.isArray(extensions.builtIn))
            await Promise.all(extensions.builtIn.filter(Boolean).map(this.import));
        if (bud.isCLI() && !isUndefined(bud.context.args.discover)) {
            this.options.set(`discover`, bud.context.args.discover);
        }
        if (this.options.is(`discover`, true) &&
            this.options.isEmpty(`allowlist`) &&
            !isUndefined(extensions.discovered) &&
            Array.isArray(extensions.discovered))
            await Promise.all(extensions.discovered
                .filter(Boolean)
                .filter(this.isAllowed)
                .map(this.import));
        else if (this.options.isNotEmpty(`allowlist`))
            await Promise.all(this.options
                .get(`allowlist`)
                .filter(Boolean)
                .filter(this.isAllowed)
                .map(this.import));
        await this.runAll(`register`);
        await this.runAll(`boot`);
    }
    /**
     * `configAfter` callback
     */
    async configAfter() {
        await this.runAll(`configAfter`);
    }
    /**
     * {@link Extension.buildBefore}
     */
    async buildBefore() {
        await this.runAll(`buildBefore`);
    }
    /**
     * {@link Extension.buildBefore}
     */
    async buildAfter() {
        await this.runAll(`buildAfter`);
    }
    /**
     * Has extension
     */
    has(key) {
        return this.repository[key] ? true : false;
    }
    /**
     * Get extension
     */
    get(key) {
        return this.repository[key];
    }
    /**
     * Remove extension
     */
    remove(key) {
        delete this.repository[key];
        return this;
    }
    /**
     * Set extension
     */
    set(value) {
        const key = value.label ?? randomUUID();
        this.repository[key] = value;
        this.logger.success(`set`, key);
        return this;
    }
    /**
     * Instantiate a Framework extension class or object
     */
    async instantiate(source) {
        if (source instanceof Extension)
            return source;
        if (typeof source === `function`) {
            if (isConstructor(source)) {
                return new source(this.app);
            }
            return source(this.app);
        }
        if (typeof source.apply === `function`) {
            return source;
        }
        if (!isConstructor(source)) {
            return new Extension(this.app).fromObject(source);
        }
        return new source();
    }
    isAllowed(signifier) {
        return ((this.options.isEmpty(`denylist`) ||
            !this.options.get(`denylist`).includes(signifier)) &&
            (this.options.isEmpty(`allowlist`) ||
                this.options.get(`allowlist`).includes(signifier)));
    }
    /**
     * Import an extension
     */
    async import(signifier, fatalOnError = true) {
        if (fatalOnError && this.unresolvable.has(signifier))
            throw new Error(`Extension ${signifier} is not importable`);
        this.logger.info(`importing`, signifier);
        if (signifier.startsWith(`.`)) {
            signifier = this.app.path(signifier);
            this.logger.info(`path resolved to`, signifier);
        }
        if (this.has(signifier)) {
            this.logger.info(signifier, `extension already imported`);
            return;
        }
        const extensionClass = fatalOnError
            ? await this.app.module.import(signifier, import.meta.url)
            : await this.app.module.tryImport(signifier, import.meta.url);
        if (!extensionClass)
            return;
        const instance = await this.instantiate(extensionClass);
        if (instance.dependsOn)
            await Promise.all(Array.from(instance.dependsOn)
                .filter(dependency => !this.has(dependency))
                .map(async (dependency) => await this.import(dependency)));
        if (this.options.is(`discover`, true) && instance.dependsOnOptional)
            await Promise.all(Array.from(instance.dependsOnOptional)
                .filter(this.isAllowed)
                .filter(optionalDependency => !this.unresolvable.has(optionalDependency))
                .filter(optionalDependency => !this.has(optionalDependency))
                .map(async (optionalDependency) => {
                await this.import(optionalDependency, false);
                if (!this.has(optionalDependency))
                    this.unresolvable.add(optionalDependency);
            }));
        this.set(instance);
        return instance;
    }
    /**
     * Add a {@link Extension} to the extensions repository
     */
    async add(extension) {
        const arrayed = Array.isArray(extension) ? extension : [extension];
        await arrayed.reduce(async (promised, item) => {
            await promised;
            const moduleObject = typeof item === `string`
                ? await import(item).then(pkg => pkg.default ?? pkg)
                : item;
            const extension = await this.instantiate(moduleObject);
            this.set(extension);
            await this.run(extension, `register`);
            await this.run(extension, `boot`);
        }, Promise.resolve());
    }
    /**
     * Run an extension lifecycle method
     *
     * @remarks
     * - `_register`
     * - `_boot`
     * - `_buildBefore`
     * - `_make`
     */
    async run(extension, methodName) {
        if (isUndefined(extension?.meta?.[methodName]) ||
            extension.meta?.[methodName] === true)
            return this;
        extension.meta[methodName] = true;
        try {
            await this.runDependencies(extension, methodName);
            const method = extension[`_${methodName}`];
            if (method)
                await method();
            await this.app.api.processQueue();
            return this;
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * Execute a extension lifecycle method on all registered extensions
     */
    async runAll(methodName) {
        return await Object.values(this.repository).reduce(async (promised, extension) => {
            await promised;
            await this.run(extension, methodName);
        }, Promise.resolve());
    }
    /**
     * Run a lifecycle method for an extension's dependencies
     *
     * @remarks
     * Called from {@link Extension.run}. Ensures a method is run for an
     * extension's dependencies before it is run for the extension itself.
     */
    async runDependencies(extension, methodName) {
        extension =
            typeof extension === `string` ? this.get(extension) : extension;
        if (extension.dependsOn) {
            await Array.from(extension.dependsOn)
                .filter(this.isAllowed)
                .filter((signifier) => !this.unresolvable.has(signifier))
                .reduce(async (promised, signifier) => {
                await promised;
                if (!this.has(signifier))
                    await this.import(signifier);
                if (this.get(signifier) &&
                    !this.get(signifier).meta?.[methodName])
                    await this.run(this.get(signifier), methodName);
            }, Promise.resolve());
        }
        if (this.options.is(`discover`, true) && extension.dependsOnOptional)
            await Array.from(extension.dependsOnOptional)
                .filter(this.isAllowed)
                .filter((signifier) => !this.unresolvable.has(signifier))
                .reduce(async (promised, signifier) => {
                await promised;
                if (!this.has(signifier))
                    await this.import(signifier, false);
                if (!this.has(signifier)) {
                    this.unresolvable.add(signifier);
                    return;
                }
                if (this.get(signifier) &&
                    !this.get(signifier).meta?.[methodName])
                    await this.run(this.get(signifier), methodName);
            }, Promise.resolve());
    }
    /**
     * Returns an array of plugin instances which have been registered to the
     * container and are set to be used in the compilation
     *
     * @returns An array of plugin instances
     */
    async make() {
        return await Promise.all(Object.values(this.repository).map(async (extension) => extension.apply ? extension : await extension._make())).then((result) => result.filter(Boolean));
    }
}
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function]),
    __metadata("design:returntype", Promise)
], Extensions.prototype, "register", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function]),
    __metadata("design:returntype", Promise)
], Extensions.prototype, "booted", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extensions.prototype, "configAfter", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extensions.prototype, "buildBefore", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extensions.prototype, "buildAfter", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Boolean)
], Extensions.prototype, "has", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_a = typeof K !== "undefined" && K) === "function" ? _a : Object]),
    __metadata("design:returntype", Object)
], Extensions.prototype, "get", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof K !== "undefined" && K) === "function" ? _b : Object]),
    __metadata("design:returntype", Object)
], Extensions.prototype, "remove", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Extension]),
    __metadata("design:returntype", Object)
], Extensions.prototype, "set", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Extensions.prototype, "instantiate", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Boolean)
], Extensions.prototype, "isAllowed", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], Extensions.prototype, "import", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Extensions.prototype, "add", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Extension, String]),
    __metadata("design:returntype", Promise)
], Extensions.prototype, "run", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Extensions.prototype, "runAll", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", Promise)
], Extensions.prototype, "runDependencies", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extensions.prototype, "make", null);
//# sourceMappingURL=index.js.map