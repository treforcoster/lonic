/* eslint-disable no-console */
/* global __resourceQuery */
/* global __webpack_hash__ */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as components from './components/index.js';
import { injectEvents } from './events.js';
import { makeLogger } from './log.js';
import * as clientOptions from './options.js';
/**
 * Initializes bud.js HMR handling
 */
export const client = (queryString, webpackHot) => __awaiter(void 0, void 0, void 0, function* () {
    /* Guard: EventSource browser support */
    if (typeof (window === null || window === void 0 ? void 0 : window.EventSource) === `undefined`) {
        console.error(`[bud] hot module reload requires EventSource to work. https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events#Tools`);
        return false;
    }
    /* Guard: webpackHot api availability */
    if (!webpackHot) {
        console.error(`[bud] hot module reload requires the webpack hot api to be available`);
        return false;
    }
    /* Set client options from URL params */
    const options = clientOptions.setFromParameters(queryString);
    /* Setup logger */
    const logger = makeLogger(options);
    if (typeof window.bud === `undefined`) {
        window.bud = {
            current: {},
            hmr: {},
            controllers: [],
            listeners: {},
        };
    }
    if (!window.bud.current[options.name]) {
        window.bud.current[options.name] = null;
    }
    const isStale = (hash) => {
        if (hash)
            window.bud.current[options.name] = hash;
        return __webpack_hash__ === window.bud.current[options.name];
    };
    /**
     * Webpack HMR check handler
     */
    const check = () => __awaiter(void 0, void 0, void 0, function* () {
        if (webpackHot.status() === `idle`) {
            yield webpackHot.check(false);
            requestAnimationFrame(function whenReady() {
                return __awaiter(this, void 0, void 0, function* () {
                    if (webpackHot.status() === `ready`) {
                        yield update();
                    }
                    else {
                        requestAnimationFrame(whenReady);
                    }
                });
            });
        }
    });
    /**
     * Webpack HMR unaccepted module handler
     */
    const onUnacceptedOrDeclined = (info) => {
        console.warn(`[${options.name}] ${info.type}`, info);
        options.reload && window.location.reload();
    };
    /**
     * Webpack HMR error handler
     */
    const onErrored = (error) => {
        window.bud.controllers.map(controller => controller === null || controller === void 0 ? void 0 : controller.update({
            errors: [error],
        }));
    };
    /**
     * Webpack HMR update handler
     */
    const update = () => __awaiter(void 0, void 0, void 0, function* () {
        try {
            yield webpackHot.apply({
                ignoreUnaccepted: true,
                ignoreDeclined: true,
                ignoreErrored: true,
                onErrored,
                onUnaccepted: onUnacceptedOrDeclined,
                onDeclined: onUnacceptedOrDeclined,
            });
            if (!isStale())
                yield check();
        }
        catch (error) {
            logger.error(error);
        }
    });
    /* Instantiate indicator, overlay */
    yield components.make(options);
    /* Instantiate eventSource */
    const events = injectEvents(EventSource).make(options);
    if (!window.bud.listeners[options.name]) {
        window.bud.listeners[options.name] = (payload) => __awaiter(void 0, void 0, void 0, function* () {
            var _a;
            if (!payload)
                return;
            if (options.reload && payload.action === `reload`)
                return window.location.reload();
            if (payload.name !== options.name)
                return;
            window.bud.controllers.map(controller => controller === null || controller === void 0 ? void 0 : controller.update(payload));
            if (((_a = payload.errors) === null || _a === void 0 ? void 0 : _a.length) > 0)
                return;
            if (payload.action === `built` || payload.action === `sync`) {
                if (isStale(payload.hash))
                    return;
                if (payload.action === `built`) {
                    logger.log(`built in ${payload.time}ms`);
                }
                yield check();
            }
        });
        /*
         * Instantiate HMR event source
         * and register client listeners
         */
        events.addListener(window.bud.listeners[options.name]);
    }
});
