var _a, _b;
import { __decorate, __metadata } from "tslib";
import { bind } from '@roots/bud-support/decorators';
import { Hooks } from '../base/base.js';
/**
 * Synchronous hooks registry
 *
 * @remarks
 * Supports sync values
 */
export class EventHooks extends Hooks {
    set(id, ...input) {
        if (!(id in this.store))
            this.store[id] = [];
        input.map((value, iteration) => {
            this.app.hooks.logger.info(`registered event callback for`, id, `(${iteration + 1}/${input.length})`);
            this.store[id].push(value);
        });
        return this.app;
    }
    async get(id, value) {
        if (!(id in this.store) || !this.store[id].length)
            return this.app;
        this.app.hooks.logger.time(id);
        const actions = [...this.store[id]];
        await Promise.all(actions.map(async (action, iteration) => {
            try {
                this.app.hooks.logger.await(`executing callback ${iteration + 1}/${actions.length}`);
                await action(value);
                this.app.hooks.logger.success(`executing callback ${iteration + 1}/${actions.length}`);
            }
            catch (e) {
                this.catch(e, id, iteration);
            }
        }));
        this.app.hooks.logger.timeEnd(id);
        return this.app;
    }
}
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_a = typeof T !== "undefined" && T) === "function" ? _a : Object, Function]),
    __metadata("design:returntype", Function)
], EventHooks.prototype, "set", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof T !== "undefined" && T) === "function" ? _b : Object, Object]),
    __metadata("design:returntype", Promise)
], EventHooks.prototype, "get", null);
//# sourceMappingURL=event.js.map