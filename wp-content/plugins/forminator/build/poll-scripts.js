/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 641);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = React;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.randNumber = randNumber;
exports.generateWrapperId = generateWrapperId;
exports.getWrapper = getWrapper;
exports.getDefaultValue = getDefaultValue;
exports.getThemePrefix = getThemePrefix;
exports.restrictedGroupFields = restrictedGroupFields;
exports.lonerFields = lonerFields;
exports.getSubmissionBehaviors = getSubmissionBehaviors;
exports.countFieldsByType = countFieldsByType;
exports.getMaxIDByType = getMaxIDByType;
exports.getMaxID = getMaxID;
exports.generateValue = generateValue;
exports.hasFieldType = hasFieldType;
exports.getFieldsByType = getFieldsByType;
exports.mapFieldsByType = mapFieldsByType;
exports.getFieldLabel = getFieldLabel;
exports.fieldExist = fieldExist;
exports.buildFieldObject = buildFieldObject;
exports.buildFieldObjectFromSlug = buildFieldObjectFromSlug;
exports.getFieldType = getFieldType;
exports.getForminatorField = getForminatorField;
exports.insertInPosition = insertInPosition;
exports.replaceInPosition = replaceInPosition;
exports.translate = translate;
exports.getFontVariants = getFontVariants;
exports.ucfirst = ucfirst;
exports.getConditionLabel = getConditionLabel;
exports.convertTimestamp = convertTimestamp;
exports.getFields = getFields;
exports.getDateFields = getDateFields;
exports.getNameFields = getNameFields;
exports.getRangeSliderFields = getRangeSliderFields;
exports.fieldHasNumber = fieldHasNumber;
exports.fieldHasCalcs = fieldHasCalcs;
exports.fieldFormula = fieldFormula;
exports.fieldHasOptions = fieldHasOptions;
exports.getFieldValues = getFieldValues;
exports.getAddressFields = getAddressFields;
exports.getTimeFields = getTimeFields;
exports.getFieldAutofillProviders = getFieldAutofillProviders;
exports.getRuleLabel = getRuleLabel;
exports.isEmailWp = isEmailWp;
exports.suiDelegateEvents = suiDelegateEvents;
exports.getChartType = getChartType;
exports.getCalculationFields = getCalculationFields;
exports.select2Tags = select2Tags;
exports.isFieldRequired = isFieldRequired;
exports.hasFieldWithAttribute = hasFieldWithAttribute;
exports.hasPostdataFieldWithMultiselect = hasPostdataFieldWithMultiselect;
exports.getPersonalityQuestions = getPersonalityQuestions;
exports.getPlanValidation = getPlanValidation;
exports.isTrue = isTrue;
exports.parseQueryString = parseQueryString;
exports.goToLink = goToLink;

var _i18nWpPlugin = __webpack_require__(52);

var _i18nWpPlugin2 = _interopRequireDefault(_i18nWpPlugin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Returns unique 4 digit number
 *
 * @return {number}
 **/
function randNumber() {
	//return Math.floor( Math.random() * 9999 );
	var min = Math.ceil(1000);
	var max = Math.floor(9999);
	return Math.floor(Math.random() * (max - min) + min);
}

/**
 * Returns wrapper uniq ID
 *
 * @return {string}
 **/
function generateWrapperId() {
	return 'wrapper-' + randNumber() + '-' + randNumber();
}

/**
 * Returns wrapper object by wrapper ID
 *
 * @param {string} wrapperID ID of the wrapper
 * @param {array} wrappers current wrappers
 *
 * @return {string}
 **/
function getWrapper(wrapperID, wrappers) {
	var wrapperObject = void 0;

	wrappers.map(function (wrapper) {
		if (wrapper.wrapper_id === wrapperID) {
			wrapperObject = wrapper;
		}
	});

	return wrapperObject;
}

/**
 * Return passed default value or empty if it's Basic theme
 *
 * @param {String} getDefaultValue Default value
 * @param {String} formDesign Property
 * @return {String}
 */
function getDefaultValue(props, getDefaultValue) {
	return getThemeName(props) !== 'basic' ? getDefaultValue : '';
}

/**
 * Get prefix for properties if it's Basic theme
 *
 * @param {type} formDesign Property
 * @return {String}
 */
function getThemePrefix(props) {
	return getThemeName(props) === 'basic' ? 'basic-' : '';
}

/**
 * Get design theme name
 *
 * @param {type} propsProperties
 * @return {String}
 */
function getThemeName(props) {
	if ("undefined" !== typeof props.formDesign) {
		return props.formDesign;
	}

	if ("undefined" !== typeof props.settings && "undefined" !== typeof props.settings['forminator-poll-design']) return props.settings['forminator-poll-design'];

	if ("undefined" !== typeof props.quizDesign) return props.quizDesign;

	return '';
}

/**
 * Returns all field types disabled inside Group Fields
 *
 * @return {array}
 */
function restrictedGroupFields() {
	return ['page-break', 'paypal', 'stripe', 'signature', 'captcha', 'postdata', 'group'];
}

/**
 * Returns all field types that should only occupy a single row. ;(
 * Field can only be added for new/unreleased field types.
 *
 * @return {array}
 */
function lonerFields() {
	return ['pdf-page-break', 'all-form-data'];
}

/**
 * Returns all behavior types
 *
 * @return {object}
 */
function getSubmissionBehaviors() {
	return {
		'behaviour-thankyou': translate('Inline Message'),
		'behaviour-redirect': translate('Redirect user to a URL'),
		'behaviour-hide': translate('Hide form')
	};
}

/**
 * Returns count of existing fields by type
 *
 * @param {string} type type of field
 * @param {array} wrappers current wrappers
 *
 * @return {number}
 **/
function countFieldsByType(type, wrappers) {
	var counter = 0;

	wrappers.map(function (wrapper) {
		wrapper.fields.map(function (field) {
			if (field.type === type) {
				counter++;
			}
		});
	});

	return counter;
}

/**
 * Returns max ID number by type
 *
 * @param {string} type type of field
 * @param {array} wrappers current wrappers
 *
 * @return {number}
 **/
function getMaxIDByType(type, wrappers) {
	var fieldIDs = [];

	wrappers.map(function (wrapper) {
		wrapper.fields.map(function (field) {
			if (field.type === type) {
				var fieldId = field.element_id;
				var fieldIdArray = fieldId.split('-');
				switch (field.type) {
					case 'page-break':
					case 'rich-text':
						fieldIDs.push(parseInt(fieldIdArray[2]));
						break;
					case 'all-form-data':
					case 'pdf-page-break':
						fieldIDs.push(parseInt(fieldIdArray[3]));
						break;
					default:
						fieldIDs.push(parseInt(fieldIdArray[1]));
						break;
				}
			}
		});
	});

	var maxValue = 0;

	if (!_.isEmpty(fieldIDs)) {
		maxValue = _.max(fieldIDs);
	}

	return parseInt(maxValue) + 1;
}

function getMaxID(type, values) {
	var ids = [];

	_.map(values, function (value) {
		var fieldId = value.element_id;
		var fieldIdArray = fieldId.split('-');

		ids.push(parseInt(fieldIdArray[1]));
	});

	var maxValue = 0;

	if (!_.isEmpty(ids)) {
		maxValue = _.max(ids);
	}

	return parseInt(maxValue) + 1;
}

/**
 * Returns Label converted to value
 *
 * @param {string} value entered label
 *
 * @return {string}
 **/
function generateValue(value) {
	value = value.trim().replace(/\s+|\//g, '-');

	return value;
}

/**
 * Return true if it's Global Appearance Preset
 *
 * @param {array} wrappers current wrappers
 * @return {Boolean}
 */
function isGlobalPreset(wrappers) {
	return null === wrappers;
}

/**
 * Returns true if field exist
 *
 * @param {string} type type of field
 * @param {array} wrappers current wrappers
 *
 * @return {bool}
 **/
function hasFieldType(type, wrappers) {
	var counter = 0;

	if (isGlobalPreset(wrappers)) {
		return true;
	}

	wrappers.map(function (wrapper) {
		wrapper.fields.map(function (field) {
			if (field.type === type) {
				counter++;
			}
		});
	});

	return counter > 0;
}

/**
 * Returns array of fields by type
 *
 * @param {string} type type of field
 * @param {array} wrappers current wrappers
 *
 * @return {array}
 **/
function getFieldsByType(type, wrappers) {
	var fields = [];

	wrappers.map(function (wrapper) {
		wrapper.fields.map(function (field) {
			if (field.type === type) {
				fields.push(field);
			}
		});
	});

	return fields;
}

/**
 * Returns array of fields by type mapped for select field
 *
 * @param {string} type type of field
 * @param {array} wrappers current wrappers
 *
 * @return {array}
 **/
function mapFieldsByType(type, wrappers) {
	var fields = [];
	var fieldsByType = getFieldsByType(type, wrappers);
	fieldsByType.map(function (field) {
		var label = field.field_label;

		if (type === 'address') {
			label = field.element_id;
		}

		fields.push({
			value: field.element_id,
			label: label,
			element_id: field.element_id
		});
	});

	return fields;
}

/**
 * Returns field label by ID
 *
 * @param {string} id field ID
 * @param {array} wrappers current wrappers
 *
 * @return {string}
 **/
function getFieldLabel(id, wrappers) {
	var label = '';
	wrappers.map(function (wrapper) {
		wrapper.fields.map(function (field) {
			if (field.element_id === id) {
				label = field.field_label;
			}
		});
	});

	return label;
}
/**
 * Returns true or false if field exist
 *
 * @param {string} id field ID
 * @param {array} wrappers current wrappers
 *
 * @return {bool}
 **/
function fieldExist(id, wrappers) {
	var exist = 0;

	wrappers.map(function (wrapper) {
		wrapper.fields.map(function (field) {
			if (field.element_id === id) {
				exist++;
			}
		});
	});

	return exist > 0;
}

/**
 * Returns field object with defaults from slug
 *
 * @param {object} field field
 * @param {string} wrapperID wrapper id
 * @param {number} cols columns
 * @param {array} wrappers wrappers
 * @param {array} tempNewFields New Siblings Fields that aren't included in wrappers yet
 *
 * @return {object}
 **/
function buildFieldObject(field, wrapperID, cols, wrappers, tempNewFields) {
	tempNewFields = tempNewFields || [];
	var wraps = [].concat(_toConsumableArray(wrappers), [{ fields: tempNewFields }]);
	var fieldNumber = getMaxIDByType(field.type, wraps);

	return _.extend(field, {
		element_id: field.type + '-' + fieldNumber,
		formID: wrapperID,
		cols: cols
	});
}

/**
 * Returns field object with defaults from slug
 *
 * @param {string} slug field slug
 * @param {array} wrappers wrappers
 * @param {string} wrapepr ID
 *
 * @return {object}
 **/
function buildFieldObjectFromSlug(slug, wrappers, wrapperID) {
	var field = forminatorData.fields.find(function (fieldData) {
		return fieldData.slug === slug;
	});

	var fieldNumber = getMaxIDByType(field.type, wrappers);

	var props = {
		element_id: field.type + '-' + fieldNumber,
		type: field.type,
		options: field.options,
		cols: 12,
		conditions: {},
		wrapper_id: wrapperID
	};

	if (_.contains(['calculation', 'number', 'slider', 'radio', 'currency', 'select', 'checkbox'], field.type)) {
		props['hidden_behavior'] = 'zero';
	}

	return _.extend(props, JSON.parse(JSON.stringify(field.defaults)));
}

/**
 * Returns field type by field object
 *
 * @param {object} field field
 *
 * @return {string}
 **/
function getFieldType(field) {
	var type = field.type;


	return type;
}

/**
 * Returns forminatorData.fields(PHP) from field object from builder
 *
 * Comparing `type`
 *
 * @param {object} field field
 *
 * @return {object}
 **/
function getForminatorField(field) {
	return forminatorData.fields.find(function (forminatorField) {
		return forminatorField.type === field.type;
	});
}

/**
 * Insert item into array in specific position
 *
 * @param {array} array array
 * @param {number} position position
 * @param {any} replacement replacement
 *
 * @return {array} array
 */
function insertInPosition(array, position, replacement) {
	return [].concat(_toConsumableArray(array.slice(0, position)), [replacement], _toConsumableArray(array.slice(position)));
}

/**
 * Replace item in array in specific position
 *
 * @param {array} array array
 * @param {number} position position
 * @param {any} replacement replacement
 *
 * @return {array} array
 */
function replaceInPosition(array, position, replacement) {
	return [].concat(_toConsumableArray(array.slice(0, position)), [replacement], _toConsumableArray(array.slice(position + 1)));
}

/**
 * Translate string
 *
 * @see i18n.translate
 *
 * @return {string} translated string
 */
function translate() {
	return _i18nWpPlugin2.default.translate.apply(null, arguments);
}

/**
 * Returns variants for selected font
 *
 * @param {string} value font
 * @param {array} fonts fonts

 * @return {array}
 **/
function getFontVariants(value, fonts) {
	var fontObject = _.filter(fonts, function (font) {
		return font.family === value;
	});

	if (!_.isUndefined(fontObject[0]) && !_.isUndefined(fontObject[0].variants)) {
		return fontObject[0].variants;
	}

	return [translate('None')];
}

/**
 * Capitalize string
 *
 * @param {string} value value
 * @returns {string}
 **/
function ucfirst(value) {
	return value.charAt(0).toUpperCase() + value.slice(1);
}

/**
 * Get condition label
 *
 * @returns {string}
 */
function getConditionLabel(field, condition) {
	var value = condition.value;
	var valueLabel = void 0;

	// If option field and have values, we need the option updateValue
	// Else return the field value
	if (field.hasOptions && field.values.length > 0) {
		var label = void 0;

		// Check in values
		label = _.where(field.values, { value: value })[0];

		// If label is not set, check in labels
		if (!label) {
			label = _.where(field.values, { label: value })[0];
		}

		// If label is still not found, return
		if (!label) {
			return;
		}

		valueLabel = label.label;
	} else if ('date' === field.field_type && ['is_before', 'is_after'].includes(condition.rule)) {
		// Get formatted date string
		valueLabel = convertTimestamp(value);
	} else {
		valueLabel = value;
	}

	// If label empty, return null
	if (_.isEmpty(valueLabel)) {
		return translate('null');
	}

	return valueLabel;
}

/*
 * Convert date from timestamp
 */
function convertTimestamp(value) {
	if (!isNaN(Number(value))) {
		// Convert timestamp to Date object
		var date = new Date(value * 1);

		// Options for formatting the date
		var options = { day: 'numeric', month: 'numeric', year: 'numeric' };

		// Get the formatted date string
		value = date.toLocaleDateString('en-US', options);
	}

	return value;
}

/*
 * Returns builder fields from wrappers
 */
function getFields(wrappers, disabledFields, extra, includedFields, excludeSubFields) {
	var fieldsArray = [];

	if (_.isUndefined(disabledFields)) {
		disabledFields = ['page-break', 'postdata', 'total', 'product', 'captcha'];
	}
	if (Array.isArray(disabledFields) && !isTrue(excludeSubFields)) {
		disabledFields.push('group');
	}
	var main_date_field = false;

	if (!_.isUndefined(extra) && !_.isUndefined(extra.main_date_field) && extra.main_date_field === true) {
		main_date_field = true;
	}

	// Loop all wrappers we have
	wrappers.map(function (wrapper) {
		var fields = wrapper.fields,
		    parentGroup = wrapper.parent_group;
		fields.map(function (field) {
			// Check if field is included
			if (!_.isUndefined(includedFields)) {
				if (!_.contains(includedFields, field.type)) {
					return;
				}
			} else if (_.contains(disabledFields, field.type)) {
				// Check if field is disabled
				return;
			}

			var label = void 0;

			// Get field label
			if (!_.isUndefined(field.field_label) && !_.isEmpty(field.field_label)) {
				label = field.field_label;
			} else {
				label = field.type;
				label = ucfirst(label);
			}

			// If field is name, get all existing sub fields
			if (field.type === 'name' && !isTrue(excludeSubFields)) {
				fieldsArray = fieldsArray.concat(getNameFields(field, label, parentGroup));
			} else if (field.type === 'address' && !isTrue(excludeSubFields)) {
				fieldsArray = fieldsArray.concat(getAddressFields(field, label, parentGroup));
			} else if (field.type === 'slider' && field.slider_type === 'range') {
				fieldsArray = fieldsArray.concat(getRangeSliderFields(field, label, parentGroup));
			} else if (field.type === 'time' && !isTrue(excludeSubFields)) {
				fieldsArray = fieldsArray.concat(getTimeFields(field, label, parentGroup));
			} else if (field.type === 'date' && field.field_type !== 'picker' && main_date_field === false) {
				//skip now
			} else {
				fieldsArray.push({
					element_id: field.element_id,
					parent_group: parentGroup,
					required: field.required,
					field_type: field.type,
					field_slug: field.type,
					label: label,
					values: getFieldValues(field),
					hasOptions: fieldHasOptions(field),
					hasCalcs: fieldHasCalcs(field),
					formula: fieldFormula(field),
					isNumber: fieldHasNumber(field),
					fieldData: field
				});
			}
			if (field.type === 'date' && field.field_type !== 'picker' && !isTrue(excludeSubFields)) {
				fieldsArray = fieldsArray.concat(getDateFields(field, label, parentGroup));
			}
		});
	});
	return fieldsArray;
}
/**
 * Get name_fields (support dropdown & input date fields)
 * @param {object} field field to parse
 * @param {string} fieldLabel parent label
 * @returns {Array}
 **/
function getDateFields(field, fieldLabel, parentGroup) {
	var fieldsArray = [];

	var day_label = void 0;
	if (!_.isUndefined(field.day_label) && !_.isEmpty(field.day_label)) {
		day_label = fieldLabel + ' - ' + field.day_label;
	} else {
		day_label = fieldLabel + ' - ' + translate('Day');
	}

	var month_label = void 0;
	if (!_.isUndefined(field.month_label) && !_.isEmpty(field.month_label)) {
		month_label = fieldLabel + ' - ' + field.month_label;
	} else {
		month_label = fieldLabel + ' - ' + translate('Month');
	}

	var year_label = void 0;
	if (!_.isUndefined(field.year_label) && !_.isEmpty(field.year_label)) {
		year_label = fieldLabel + ' - ' + field.year_label;
	} else {
		year_label = fieldLabel + ' - ' + translate('Year');
	}
	if (field.field_type === 'input') {
		fieldsArray.push({
			element_id: field.element_id + '-day',
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type + '-day',
			label: day_label,
			values: false,
			hasOptions: false,
			isNumber: true
		}, {
			element_id: field.element_id + '-month',
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type + '-month',
			label: month_label,
			values: false,
			hasOptions: false,
			isNumber: true
		}, {
			element_id: field.element_id + '-year',
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type + '-year',
			label: year_label,
			values: false,
			hasOptions: false,
			isNumber: true
		});
	} else {
		fieldsArray.push({
			element_id: field.element_id + '-day',
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type + '-day',
			label: day_label,
			values: getFieldValues(field),
			hasOptions: fieldHasOptions(field),
			isNumber: fieldHasNumber(field)
		}, {
			element_id: field.element_id + '-month',
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type + '-month',
			label: month_label,
			values: getFieldValues(field),
			hasOptions: fieldHasOptions(field),
			isNumber: fieldHasNumber(field)
		}, {
			element_id: field.element_id + '-year',
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type + '-year',
			label: year_label,
			values: getFieldValues(field),
			hasOptions: fieldHasOptions(field),
			isNumber: fieldHasNumber(field)
		});
	}

	return fieldsArray;
}

/**
 * Get name_fields (support multiple name fields)
 * @param {object} field field to parse
 * @param {string} fieldLabel parent label
 * @returns {Array}
 **/
function getNameFields(field, fieldLabel, parentGroup) {
	var fieldsArray = [];
	//handle multiple name
	if (field.multiple_name === 'true' || true === field.multiple_name) {
		[{
			attr: 'prefix',
			label: 'prefix_label',
			element_suffix: 'prefix',
			hasOptions: true,
			values: [{ label: 'Mr.', value: 'Mr' }, { label: 'Mrs.', value: 'Mrs' }, { label: 'Ms.', value: 'Ms' }, { label: 'Mx.', value: 'Mx' }, { label: 'Miss', value: 'Miss' }, { label: 'Dr.', value: 'Dr' }, { label: 'Prof.', value: 'Prof' }],
			isNumber: false
		}, {
			attr: 'fname',
			label: 'fname_label',
			element_suffix: 'first-name',
			hasOptions: false,
			values: false,
			isNumber: false
		}, {
			attr: 'mname',
			label: 'mname_label',
			element_suffix: 'middle-name',
			hasOptions: false,
			values: false,
			isNumber: false
		}, {
			attr: 'lname',
			label: 'lname_label',
			element_suffix: 'last-name',
			hasOptions: false,
			values: false,
			isNumber: false
		}].map(function (attribute) {
			if (field[attribute.attr] === 'true' || field[attribute.attr] === true) {
				var label = void 0;
				if (!_.isUndefined(field[attribute.label]) && !_.isEmpty(field[attribute.label])) {
					label = fieldLabel + ' - ' + field[attribute.label];
				} else {
					label = fieldLabel + ' - ';
				}

				fieldsArray.push({
					element_id: field.element_id + '-' + attribute.element_suffix,
					parent_group: parentGroup,
					required: field.required,
					field_type: field.type,
					field_slug: field.type + '-' + attribute.element_suffix,
					label: label,
					values: attribute.values,
					hasOptions: attribute.hasOptions,
					isNumber: attribute.isNumber
				});
			}
		});
	} else {
		fieldsArray.push({
			element_id: field.element_id,
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type,
			label: fieldLabel,
			values: getFieldValues(field),
			hasOptions: fieldHasOptions(field),
			isNumber: fieldHasNumber(field)
		});
	}

	return fieldsArray;
}

/**
 * Get Range Slider fields
 * @param {object} field field to parse
 * @param {string} fieldLabel parent label
 * @returns {Array}
 **/
function getRangeSliderFields(field, fieldLabel, parentGroup) {
	var fieldsArray = [];
	[{
		suffix: 'min'
	}, {
		suffix: 'max'
	}].map(function (attribute) {
		fieldsArray.push({
			element_id: field.element_id + '-' + attribute.suffix,
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type + '-' + attribute.suffix,
			label: fieldLabel + ' - ' + attribute.suffix,
			isNumber: true,
			hasCalcs: fieldHasCalcs(field)
		});
	});

	return fieldsArray;
}

/*
 * Returns if field has number
 */
function fieldHasNumber(field) {
	if (_.contains(['calculation', 'number', 'slider', 'phone', 'currency'], field.type)) {
		return true;
	}

	return false;
}

/*
 * Returns if field has calculations enabled
 */
function fieldHasCalcs(field) {
	if (field.calculations === 'true' || field.calculations === true) {
		return true;
	}

	return false;
}

function fieldFormula(field) {
	if (field.formula) {
		return field.formula;
	}

	return false;
}

/*
 * Returns if field has options
 */
function fieldHasOptions(field) {
	if (field.type === 'select' || field.type === 'checkbox' || field.type === 'radio') {
		return true;
	}

	return false;
}

/*
 * Returns field values
 */
function getFieldValues(field) {
	var type = field.type;

	if (type === 'select' || type === 'checkbox' || type === 'radio') {
		return field.options;
	}

	return false;
}

/**
 * Get address_fields (support multi sub fields)
 * @param {object} field field
 * @param {string} fieldLabel lbel
 * @returns {array}
 **/
function getAddressFields(field, fieldLabel, parentGroup) {
	var fieldsArray = [];

	[{
		attr: 'street_address',
		label: 'street_address_label',
		element_suffix: 'street_address',
		hasOptions: false,
		values: false,
		isNumber: false
	}, {
		attr: 'address_line',
		label: 'address_line_label',
		element_suffix: 'address_line',
		hasOptions: false,
		values: false,
		isNumber: false
	}, {
		attr: 'address_city',
		label: 'address_city_label',
		element_suffix: 'city',
		hasOptions: false,
		values: false,
		isNumber: false
	}, {
		attr: 'address_state',
		label: 'address_state_label',
		element_suffix: 'state',
		hasOptions: false,
		values: false,
		isNumber: false
	}, {
		attr: 'address_zip',
		label: 'address_zip_label',
		element_suffix: 'zip',
		hasOptions: false,
		values: false,
		isNumber: false
	}, {
		attr: 'address_country',
		label: 'address_country_label',
		element_suffix: 'country',
		hasOptions: false,
		values: false,
		isNumber: false
	}].map(function (attribute) {
		if (isTrue(field[attribute.attr])) {
			var label = void 0;
			if (!_.isUndefined(field[attribute.label]) && !_.isEmpty(field[attribute.label])) {
				label = fieldLabel + ' - ' + field[attribute.label];
			} else {
				label = fieldLabel + ' - ';
			}

			fieldsArray.push({
				element_id: field.element_id + '-' + attribute.element_suffix,
				parent_group: parentGroup,
				required: field.required,
				field_type: field.type,
				field_slug: field.type + '-' + attribute.element_suffix,
				label: label,
				values: attribute.values,
				hasOptions: attribute.hasOptions,
				isNumber: attribute.isNumber
			});
		}
	});

	return fieldsArray;
}

/**
 * Get time_fields (support multi sub fields)
 * @param {object} field field
 * @param {string} fieldLabel label
 * @returns {array}
 **/
function getTimeFields(field, fieldLabel, parentGroup) {
	var fieldsArray = [];

	var hh_label = void 0;
	if (!_.isUndefined(field.hh_label) && !_.isEmpty(field.hh_label)) {
		hh_label = fieldLabel + ' - ' + field.hh_label;
	} else {
		hh_label = fieldLabel + ' - ' + translate('Hour');
	}

	var mm_label = void 0;
	if (!_.isUndefined(field.mm_label) && !_.isEmpty(field.mm_label)) {
		mm_label = fieldLabel + ' - ' + field.mm_label;
	} else {
		mm_label = fieldLabel + ' - ' + translate('Minute');
	}

	fieldsArray.push({
		element_id: field.element_id + '-hours',
		parent_group: parentGroup,
		required: field.required,
		field_type: field.type,
		field_slug: field.type + '-hours',
		label: hh_label,
		values: false,
		hasOptions: false,
		isNumber: true
	}, {
		element_id: field.element_id + '-minutes',
		parent_group: parentGroup,
		required: field.required,
		field_type: field.type,
		field_slug: field.type + '-minutes',
		label: mm_label,
		values: false,
		hasOptions: false,
		isNumber: true
	});

	if (field.time_type === 'twelve') {
		fieldsArray.push({
			element_id: field.element_id + '-ampm',
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type + '-ampm',
			label: fieldLabel + '-AM/PM',
			values: [{ label: 'AM', value: 'am' }, { label: 'PM', value: 'pm' }],
			hasOptions: true,
			isNumber: false
		});
	}

	return fieldsArray;
}

/**
 *
 * @param {string} fieldType fieldType
 * @returns {array}
 **/
function getFieldAutofillProviders(fieldType) {
	var autofillProviders = [];
	var fieldSettings = forminatorData.fields.filter(function (field) {
		return field.type === fieldType;
	});

	if (fieldSettings.length < 1) {
		return [];
	}

	fieldSettings = fieldSettings[0];
	if (!_.isUndefined(fieldSettings.autofill_settings)) {
		autofillProviders = fieldSettings.autofill_settings;
	}

	return autofillProviders;
}

/**
 * Returns label by rule value
 *
 * @param {string} rule rule
 * @param {string} type type
 * @param {mix} type value ( optional )
 * @returns {string}
 **/
function getRuleLabel(rule, type, value) {
	var val = !_.isUndefined(value) ? value : '';
	switch (rule) {
		case 'is':
			return translate('is');
		case 'is_not':
			return translate('is not');
		case 'day_is':
			return translate('day is');
		case 'day_is_not':
			return translate('day is not');
		case 'month_is_not':
			return translate('month is not');
		case 'month_is':
			return translate('month is');
		case 'is_before':
			return translate('is before');
		case 'is_after':
			return translate('is after');
		case 'is_before_n_or_more_days':
			return translate('is before %s or more days from current date').replace('%s', val);
		case 'is_before_less_than_n_days':
			return translate('is before less than %s days from current date').replace('%s', val);
		case 'is_after_n_or_more_days':
			return translate('is after %s or more days from current date').replace('%s', val);
		case 'is_after_less_than_n_days':
			return translate('is after less than %s days from current date').replace('%s', val);
		case 'is_great':
			return translate('is greater than');
		case 'is_less':
			return translate('is less than');
		case 'contains':
			return translate('contains');
		case 'starts':
			return translate('starts with');
		case 'ends':
			return translate('ends with');
		case 'is_correct':
			return translate('is correct');
		case 'is_incorrect':
			return translate('is incorrect');
		// Personality quiz rules.
		case 'is_final_result':
			return translate('is final result');
		case 'is_not_final_result':
			return translate('is not final result');
		default:
			return '-';
	}
}

/**
 * Return if value is valid email wp
 *
 * @param {string} value value to check
 * @returns {bool}
 **/
function isEmailWp(value) {
	if (value.length < 6) {
		return false;
	}

	// Test for an @ character after the first position
	if (value.indexOf('@', 1) < 0) {
		return false;
	}

	// Split out the local and domain parts
	var parts = value.split('@', 2);

	// LOCAL PART
	// Test for invalid characters
	if (!parts[0].match(/^[a-zA-Z0-9!#$%&'*+\/=?^_`{|}~\.-]+$/)) {
		return false;
	}

	// DOMAIN PART
	// Test for sequences of periods
	if (parts[1].match(/\.{2,}/)) {
		return false;
	}

	var domain = parts[1];
	// Split the domain into subs
	var subs = domain.split('.');
	if (subs.length < 2) {
		return false;
	}

	var subsLen = subs.length;
	for (var i = 0; i < subsLen; i++) {
		// Test for invalid characters
		if (!subs[i].match(/^[a-z0-9-]+$/i)) {
			return false;
		}
	}
	return true;
}

/**
 * Display SUI JS Elements
 **/
function suiDelegateEvents() {
	if ('object' !== _typeof(window.SUI)) {
		return;
	}

	// Time it out
	setTimeout(function () {
		// Rebind Accordion scripts
		SUI.suiAccordion(jQuery('.sui-accordion'));

		// Rebind Tabs scripts
		SUI.suiTabs(jQuery('.sui-tabs'));

		// Rebind Select2 scripts.
		jQuery('select.sui-select[data-theme="icon"]').each(function () {
			SUI.select.initIcon(jQuery(this));
		});

		jQuery('select.sui-select[data-theme="color"]').each(function () {
			SUI.select.initColor(jQuery(this));
		});

		jQuery('select.sui-select[data-theme="search"]').each(function () {
			SUI.select.initSearch(jQuery(this));
		});

		jQuery('select.sui-select:not([data-theme]):not(.custom-select2):not(.fui-multi-select)').each(function () {
			SUI.select.init(jQuery(this));
		});

		// Rebind Variables scripts.
		jQuery('select.sui-variables').each(function () {
			SUI.select.initVars(jQuery(this));
		});

		// Rebind Circle scripts
		SUI.loadCircleScore(jQuery('.sui-circle-score'));

		// Rebind Password scripts
		SUI.showHidePassword();
	}, 50);
}

/**
 * Returns chart type from settings
 *
 * @param {array} settings Settings array
 *
 * @return {string} Chart type
 */
function getChartType(settings) {
	var type = 'none';

	if (_typeof(settings['results-behav']) && _typeof(settings['results-style'])) {
		if (settings['results-behav'] === 'link_on' || settings['results-behav'] === 'show_after') {
			type = settings['results-style'];
		}
	}

	return type;
}

/**
 * Returns array of calculation fields
 *
 * @param {array} wrappers current wrappers
 *
 * @return {array}
 **/
function getCalculationFields(wrappers) {
	var disabled = [];

	// Push disabled fields
	_.each(forminatorData.fields, function (field) {
		if (field.type !== 'calculation') {
			disabled.push(field.type);
		}
	});

	return getFields(wrappers, disabled);
}

/**
 * Display Select2 with multiple tags
 *
 * @param {jQuery} $el jQuery wrapper el to find
 * @param {object} options Select2 options
 **/
function select2Tags($el, options) {
	options = _.defaults(options, {
		allowClear: true,
		dropdownCssClass: 'sui-select-dropdown'
	});

	// SELECT2 forminator-ui-tags
	$el.find('select.sui-select.fui-multi-select').each(function () {
		// reorder-support, it will preserve order based on user tags added
		if (jQuery(this).attr('data-reorder')) {
			jQuery(this).on('select2:select', function (e) {
				var elm = e.params.data.element,
				    $elm = jQuery(elm),
				    $t = jQuery(this);
				$t.append($elm);
				$t.trigger('change.select2');
			});
		}
		jQuery(this).SUIselect2(options);
	});
}

/**
 * Returns if field is required
 *
 * @param {object} field field
 *
 * @return {bool}
 **/
function isFieldRequired(field) {
	// Handle name field sub fields
	if (field.type === 'name') {
		if (field.multiple_name === 'true' || field.multiple_name === true) {
			// We have multi field

			if (field['prefix_required'] || field['fname_required'] || field['mname_required'] || field['lname_required']) {
				return true;
			} else {
				return false;
			}
		}
	}

	// Handle name field sub fields
	if (field.type === 'address') {
		if (field['street_address_required'] || field['address_line_required'] || field['address_city_required'] || field['address_state_required'] || field['address_zip_required'] || field['address_country_required']) {
			return true;
		} else {
			return false;
		}
	}

	// Fallback to default required prop
	return field.required;
}

/*
 * Returns if form has a field with requested attribute and the requested value
 */
function hasFieldWithAttribute(wrappers, type, attribute, value) {
	var counter = 0;

	if (isGlobalPreset(wrappers)) {
		return true;
	}

	wrappers.map(function (wrapper) {
		wrapper.fields.map(function (field) {
			if (type === field.type && value === field[attribute]) {
				counter++;
			}
		});
	});

	return counter > 0;
}

/*
 * Returns if form has a field with multiple category
 */
function hasPostdataFieldWithMultiselect(wrappers) {
	var counter = 0;

	if (isGlobalPreset(wrappers)) {
		return true;
	}

	wrappers.map(function (wrapper) {
		wrapper.fields.map(function (field) {
			var post_category = forminatorData.postCategories[field.post_type];
			if (typeof post_category !== 'undefined') {
				post_category.map(function (category) {
					var category_key = category.value + '_multiple';
					if (1 === parseInt(field[category_key])) {
						counter++;
					}
				});
			}
		});
	});

	return counter > 0;
}

/**
 * Returns array of personality questions
 *
 * @param {array}
 *
 * @return {array}
 **/
function getPersonalityQuestions(currentPersonality, questions) {
	var personalitySlug = currentPersonality.slug;
	var questionsArray = [];

	if (!_.isEmpty(questions)) {
		_.each(questions, function (question, keyQuestion) {
			if (!_.isEmpty(question.answers)) {
				_.each(question.answers, function (answer, keyAnswer) {
					if (answer.result === personalitySlug) {
						questionsArray.push({
							title: question.title,
							slug: question.slug,
							question: question
						});
					}
				});
			}
		});
		questionsArray = _.uniq(questionsArray, 'slug');
	}

	return questionsArray;
}

/**
 * Get payment plan validation
 *
 * @param {array} validation
 * @param {array} payments
 *
 * @return {array}
 */
function getPlanValidation(validation, payments) {

	var paymentIndex = [];

	_.each(payments, function (payment, index) {
		if (!payment.amount_type || !payment.plan_name) {
			validation.error = translate('Please fix the error(s) in the SETTINGS tab.');
			validation.isValid = false;
			paymentIndex.push(index);
		}

		if ('single' === payment.payment_method && ('fixed' === payment.amount_type && _.isEmpty(payment.amount) || 'variable' === payment.amount_type && _.isEmpty(payment.variable))) {
			validation.error = translate('Please fix the error(s) in the SETTINGS tab.');
			validation.isValid = false;
			paymentIndex.push(index);
		} else if ('subscription' === payment.payment_method) {
			var subscriptionAmount = !_.isUndefined(payment.subscription_amount_type) ? payment.subscription_amount_type : 'fixed';
			var subscriptionQuantity = !_.isUndefined(payment.quantity_type) ? payment.quantity_type : 'fixed';
			var Quantity = !_.isUndefined(payment.quantity) ? payment.quantity : 1;
			var BillInput = !_.isUndefined(payment.bill_input) ? payment.bill_input : 1;
			if ('fixed' === subscriptionAmount && _.isEmpty(payment.subscription_amount) || 'variable' === subscriptionAmount && _.isEmpty(payment.subscription_variable)) {
				validation.error = translate('Please fix the error(s) in the SETTINGS tab.');
				validation.isValid = false;
				paymentIndex.push(index);
			}
			if ('fixed' === subscriptionQuantity && !Quantity || 'variable' === subscriptionQuantity && _.isEmpty(payment.variable_quantity)) {
				validation.error = translate('Please fix the error(s) in the SETTINGS tab.');
				validation.isValid = false;
				paymentIndex.push(index);
			}
			if (!BillInput) {
				validation.error = translate('Please fix the error(s) in the SETTINGS tab.');
				validation.isValid = false;
				paymentIndex.push(index);
			} else if (BillInput <= 0) {
				validation.error = translate('Billing frequency should be greater than or equal to 1');
				validation.isValid = false;
				paymentIndex.push(index);
			}
		}
	});

	if (paymentIndex.length > 0) {
		validation.paymentKey = paymentIndex;
	}

	return validation;
}

/**
 * Check if value evaluates to true
 *
 * @param {string} value
 *
 * @return {bool}
 */
function isTrue(value) {
	if ('undefined' === typeof value) {
		return false;
	}
	if ('string' === typeof value) {
		value = value.trim().toLowerCase();
	}

	switch (value) {
		case true:
		case "true":
		case 1:
		case "1":
		case "on":
		case "yes":
			return true;
		default:
			return false;
	}
}

/**
 * Parse query string
 * *
 * @return {string}
 */
function parseQueryString() {
	var parsedParameters = {},
	    uriParameters = location.search.substring(1).split('&');

	for (var i = 0; i < uriParameters.length; i++) {
		var parameter = uriParameters[i].split('=');
		parsedParameters[parameter[0]] = decodeURIComponent(parameter[1]);
	}

	return parsedParameters;
}

/** Go to link
 *
 * @param {string} value
 *
 */
function goToLink(link) {
	var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '_blank';

	window.open(link, target);
}

/***/ }),
/* 2 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Input = function (_Component) {
	_inherits(Input, _Component);

	function Input(props) {
		_classCallCheck(this, Input);

		var _this = _possibleConstructorReturn(this, (Input.__proto__ || Object.getPrototypeOf(Input)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		return _this;
	}

	_createClass(Input, [{
		key: 'updateValue',
		value: function updateValue(value) {
			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'isValid',
		value: function isValid(value) {
			if (this.props.isRequired) {
				return this.props.isRequired && !_.isEmpty(value);
			} else if (!_.isUndefined(this.props.isPositive)) {
				return _.isEmpty(value) || value >= 0;
			}

			return true;
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) ? this.props.defaultValue : this.props.settings[this.props.property];

			var type = !_.isUndefined(this.props.type) ? this.props.type : 'text';

			var requiredError = !_.isUndefined(this.props.requiredError) ? this.props.requiredError : (0, _utils.translate)('This field is required!');

			var hasErrorClass = !this.isValid(value) ? 'sui-form-field-error' : '';

			var fieldClass = !_.isUndefined(this.props.fieldClass) ? 'sui-form-field ' + this.props.fieldClass : 'sui-form-field';

			var inputClass = 'sui-form-control';

			if (!_.isUndefined(this.props.inputClass) && '' !== this.props.inputClass) {
				inputClass += ' ' + this.props.inputClass;
			}

			if (!_.isUndefined(this.props.prefix) && '' !== this.props.prefix) {
				inputClass += ' sui-field-has-prefix';
			}

			if (!_.isUndefined(this.props.suffix) && '' !== this.props.suffix) {
				inputClass += ' sui-field-has-suffix';
			}

			var inputId = !_.isUndefined(this.props.inputId) ? this.props.inputId : this.props.property;

			var inputLabel = void 0;

			if (this.props.label) {
				inputLabel = _react2.default.createElement(
					'label',
					{
						htmlFor: 'forminator-field-' + inputId,
						className: this.props.darkLabel ? 'sui-settings-label sui-dark' : 'sui-label'
					},
					this.props.label,
					this.props.isRequired && _react2.default.createElement(
						_react2.default.Fragment,
						null,
						'\xA0',
						_react2.default.createElement(
							'span',
							{ className: 'sui-error' },
							'*'
						)
					),
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						this.props.note
					)
				);
			}

			var inputField = _react2.default.createElement('input', _extends({ type: type,
				placeholder: this.props.placeholder,
				value: value || '',
				id: 'forminator-field-' + inputId,
				className: inputClass
			}, this.props.notWritable && { readonly: '' }, this.props.minValue && { min: this.props.minValue }, this.props.maxValue && { max: this.props.maxValue }, this.props.step && { step: this.props.step }, this.props.maxLength && { maxLength: this.props.maxLength }, this.props.inputStyles && { style: this.props.inputStyles }, {
				disabled: this.props.disabled ? true : false,
				onChange: function onChange(e) {
					_this2.updateValue(e.target.value);
				}
			}));

			var getFields = _react2.default.createElement(
				'div',
				{ className: fieldClass + ' ' + hasErrorClass },
				inputLabel,
				!_.isUndefined(this.props.prefix) && '' !== this.props.prefix && _react2.default.createElement(
					'span',
					{ className: 'sui-field-prefix' },
					this.props.prefix
				),
				!this.props.canTrash ? inputField : _react2.default.createElement(
					'div',
					{ className: 'sui-with-button sui-with-button-icon' },
					inputField,
					_react2.default.createElement(
						'button',
						{ className: 'sui-button-icon sui-tooltip sui-tooltip-top-right',
							'data-tooltip': (0, _utils.translate)('Delete') },
						_react2.default.createElement('i', { className: 'sui-icon-trash', 'aria-hidden': 'true' })
					)
				),
				this.props.suffix && _react2.default.createElement(
					'span',
					{ className: 'sui-field-suffix' },
					this.props.suffix
				),
				this.props.isRequired && !this.isValid(value) && _react2.default.createElement(
					'span',
					{ className: 'sui-error-message' },
					requiredError
				),
				!_.isUndefined(this.props.isPositive) && !this.isValid(value) && _react2.default.createElement(
					'span',
					{ className: 'sui-error-message' },
					(0, _utils.translate)('Please enter valid number.')
				),
				this.props.description && _react2.default.createElement(
					'span',
					{ className: 'sui-description' },
					this.props.description
				)
			);

			if (this.props.simple) {
				return inputField;
			}

			return getFields;
		}
	}]);

	return Input;
}(_react.Component);

exports.default = Input;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Container = function (_Component) {
	_inherits(Container, _Component);

	function Container(props) {
		_classCallCheck(this, Container);

		return _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).call(this, props));
	}

	_createClass(Container, [{
		key: 'render',
		value: function render() {
			var children = _react2.default.Children.map(this.props.children, function (child) {
				return child;
			});

			return _react2.default.createElement(
				'div',
				null,
				children
			);
		}
	}]);

	return Container;
}(_react.Component);

exports.default = Container;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Col = function (_Component) {
	_inherits(Col, _Component);

	function Col(props) {
		_classCallCheck(this, Col);

		return _possibleConstructorReturn(this, (Col.__proto__ || Object.getPrototypeOf(Col)).call(this, props));
	}

	_createClass(Col, [{
		key: 'render',
		value: function render() {
			var children = _react2.default.Children.map(this.props.children, function (children) {
				return children;
			});

			var customClass = this.props.customClass ? this.props.customClass : '';

			return _react2.default.createElement(
				'div',
				{ className: 'sui-col-md-' + this.props.cols + ' ' + customClass },
				children
			);
		}
	}]);

	return Col;
}(_react.Component);

exports.default = Col;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ColorPicker = function (_Component) {
	_inherits(ColorPicker, _Component);

	function ColorPicker(props) {
		_classCallCheck(this, ColorPicker);

		var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		return _this;
	}

	_createClass(ColorPicker, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.$el = jQuery(this.el);
			this.$el.wpColorPicker({
				change: function change(event, ui) {
					var $this = jQuery(this);
					$this.val(ui.color.toCSS()).trigger('change');
				},
				palettes: ['#333333', '#FFFFFF', '#17A8E3', '#E1F6FF', '#666666', '#AAAAAA', '#E6E6E6']
			});

			var $suiPickerInput = this.$el,
			    $suiPicker = $suiPickerInput.closest('.sui-colorpicker-wrap'),
			    $suiPickerColor = $suiPicker.find('.sui-colorpicker-value span[role=button]'),
			    $suiPickerValue = $suiPicker.find('.sui-colorpicker-value'),
			    $suiPickerClear = $suiPickerValue.find('button');

			var $wpPicker = $suiPickerInput.closest('.wp-picker-container'),
			    $wpPickerButton = $wpPicker.find('.wp-color-result'),
			    $wpPickerAlpha = $wpPickerButton.find('.color-alpha'),
			    $wpPickerClear = $wpPicker.find('.wp-picker-clear');

			var $pickerBackground = $wpPickerAlpha;

			// Check if alpha exists
			if ($suiPickerInput.data('alpha') === true) {
				$pickerBackground = $wpPickerAlpha;
			} else {
				$pickerBackground = $wpPickerButton;
			}

			// Listen to color change
			$suiPickerInput.bind('change', function () {
				// Change color preview
				$suiPickerColor.find('span').css({
					'background-color': $pickerBackground.css('background-color')
				});

				// Change color value
				$suiPickerValue.find('input').val($suiPickerInput.val());
			});

			// Open iris picker
			$suiPicker.find('.sui-button, span[role=button]').on('click', function (e) {
				e.preventDefault();
				e.stopPropagation();
				$wpPickerButton.click();
			});

			// Clear color value
			$suiPickerClear.on('click', function (e) {
				e.preventDefault();
				e.stopPropagation();

				$wpPickerClear.click();
				$suiPickerValue.find('input').val('');
				$suiPickerColor.find('span').css({
					'background-color': ''
				});
			});

			this.updateValue = this.updateValue.bind(this);
			this.$el.on('change', this.updateValue);
		}
	}, {
		key: 'updateValue',
		value: function updateValue(e) {
			var value = e.target.value;

			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.$el.off('change', this.updateValue);
			this.$el.unbind().removeData();
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) || this.props.settings[this.props.property] === null ? this.props.defaultValue : this.props.settings[this.props.property];

			var fieldLabel = '';

			if (this.props.label) {
				fieldLabel = _react2.default.createElement(
					'label',
					{ className: 'sui-label',
						htmlFor: 'forminator-color-' + this.props.property },
					this.props.label,
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						' ',
						this.props.note
					)
				);
			}

			return _react2.default.createElement(
				'div',
				{ className: 'sui-form-field' },
				fieldLabel,
				_react2.default.createElement(
					'div',
					{ className: 'sui-colorpicker-wrap' },
					_react2.default.createElement(
						'div',
						{
							className: 'sui-colorpicker sui-colorpicker-' + (this.props.isAlpha ? 'rgba' : 'hex'),
							'aria-hidden': 'true' },
						_react2.default.createElement(
							'div',
							{ className: 'sui-colorpicker-value' },
							_react2.default.createElement(
								'span',
								{ role: 'button' },
								_react2.default.createElement('span', { style: { backgroundColor: value } })
							),
							_react2.default.createElement('input', { type: 'text', defaultValue: value,
								readOnly: 'readonly' }),
							_react2.default.createElement(
								'button',
								null,
								_react2.default.createElement('i', { className: 'sui-icon-close', 'aria-hidden': 'true' })
							)
						),
						_react2.default.createElement(
							'button',
							{ className: 'sui-button' },
							(0, _utils.translate)('Select')
						)
					),
					_react2.default.createElement('input', { ref: function ref(el) {
							return _this2.el = el;
						},
						defaultValue: value,
						id: 'forminator-color-' + this.props.property,
						className: 'sui-colorpicker-input',
						'data-alpha': this.props.isAlpha ? 'true' : 'false'
					})
				),
				this.props.description && '' !== this.props.description && _react2.default.createElement(
					'span',
					{ className: 'sui-description' },
					this.props.description
				)
			);
		}
	}]);

	return ColorPicker;
}(_react.Component);

exports.default = ColorPicker;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RadioTabs = function (_Component) {
	_inherits(RadioTabs, _Component);

	function RadioTabs(props) {
		_classCallCheck(this, RadioTabs);

		return _possibleConstructorReturn(this, (RadioTabs.__proto__ || Object.getPrototypeOf(RadioTabs)).call(this, props));
	}

	_createClass(RadioTabs, [{
		key: 'toggleValue',
		value: function toggleValue(value) {
			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'getDefaultValue',
		value: function getDefaultValue() {
			var defaultValue = this.props.default ? this.props.default : '';

			var value = _.isUndefined(this.props.settings[this.props.property]) ? defaultValue : this.props.settings[this.props.property];

			return value;
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = this.getDefaultValue();

			var tabTitles = _react2.default.Children.map(this.props.children, function (tab) {
				if (!tab) {
					return _react2.default.createElement(_react2.default.Fragment, null);
				}

				var label = !_.isUndefined(tab.props.label) ? tab.props.label : tab.props.children;

				if (_this2.props.disabled) {
					return _react2.default.createElement(
						'div',
						{ className: 'sui-tab-item' + (tab.props.value === value ? ' active' : ''),
							style: {
								opacity: 0.5,
								cursor: 'not-allowed'
							}
						},
						label
					);
				}

				if (!_this2.props.disabled) {
					return _react2.default.createElement(
						'div',
						{ className: 'sui-tab-item' + (tab.props.value === value ? ' active' : ''),
							onClick: _this2.toggleValue.bind(_this2, tab.props.value)
						},
						label
					);
				}
			});

			var contentClass = !_.isUndefined(this.props.divClass) ? 'sui-tabs-content ' + this.props.divClass : 'sui-tabs-content';

			var tabContents = _react2.default.Children.map(this.props.children, function (tab) {
				if (!tab) {
					return _react2.default.createElement(_react2.default.Fragment, null);
				}

				var boxClass = !_.isUndefined(tab.props.boxClass) ? tab.props.boxClass : '';

				if (tab.type.name !== 'Empty') {
					return _react2.default.createElement(
						'div',
						{ className: boxClass + ' sui-tab-content' + (tab.props.value === value ? ' active' : '') },
						tab.props.value === value && tab
					);
				}

				return _react2.default.createElement(_react2.default.Fragment, null);
			});

			var tabsLabel = '';

			if (this.props.label && '' !== this.props.label) {
				tabsLabel = _react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-field-' + this.props.property,
						className: 'sui-label' },
					this.props.label,
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						' ',
						this.props.note
					)
				);
			}

			var settingsLabel = '';

			if (this.props.settingsLabel && '' !== this.props.settingsLabel) {
				var labelClass = this.props.labelClass ? this.props.labelClass : 'sui-settings-label';
				settingsLabel = _react2.default.createElement(
					'label',
					{ className: labelClass },
					this.props.settingsLabel
				);
			}

			var description = '';

			if (this.props.description && '' !== this.props.description) {
				description = _react2.default.createElement(
					'span',
					{
						className: 'sui-description',
						style: { marginBottom: 10 }
					},
					this.props.description
				);
			}

			var wrapperClass = !_.isUndefined(this.props.wrapperClass) ? this.props.wrapperClass : '';

			wrapperClass = this.props.basicTabs ? 'sui-tabs sui-tabs-overflow ' + wrapperClass : 'sui-side-tabs ' + wrapperClass;

			var tabsMarkup = _react2.default.createElement(
				'div',
				{ className: wrapperClass },
				_react2.default.createElement(
					'div',
					{ className: 'sui-tabs-menu' },
					tabTitles
				),
				_react2.default.createElement(
					'div',
					{ className: contentClass },
					tabContents
				)
			);

			if (!this.props.simple) {
				tabsMarkup = _react2.default.createElement(
					'div',
					{ className: 'sui-form-field' },
					settingsLabel,
					tabsLabel,
					description,
					_react2.default.createElement(
						'div',
						{ className: wrapperClass },
						_react2.default.createElement(
							'div',
							{ className: 'sui-tabs-menu' },
							tabTitles
						),
						_react2.default.createElement(
							'div',
							{ className: contentClass },
							tabContents
						)
					)
				);
			}

			return tabsMarkup;
		}
	}]);

	return RadioTabs;
}(_react.Component);

exports.default = RadioTabs;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Row = function (_Component) {
	_inherits(Row, _Component);

	function Row(props) {
		_classCallCheck(this, Row);

		return _possibleConstructorReturn(this, (Row.__proto__ || Object.getPrototypeOf(Row)).call(this, props));
	}

	_createClass(Row, [{
		key: 'render',
		value: function render() {
			var columns = _react2.default.Children.map(this.props.children, function (children) {
				return children;
			});

			return _react2.default.createElement(
				'div',
				{ className: 'sui-row' + (!_.isUndefined(this.props.class) ? ' ' + this.props.class : '') },
				columns
			);
		}
	}]);

	return Row;
}(_react.Component);

exports.default = Row;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(116)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(118)();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tabs = function (_Component) {
	_inherits(Tabs, _Component);

	function Tabs(props) {
		_classCallCheck(this, Tabs);

		var _this = _possibleConstructorReturn(this, (Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call(this, props));

		_this.state = {
			active: _this.props.default ? _this.props.default : ''
		};
		return _this;
	}

	_createClass(Tabs, [{
		key: 'toggleValue',
		value: function toggleValue(value) {
			this.setState({
				active: value
			});
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var defaultValue = this.props.default ? this.props.default : '';

			var type = this.props.type ? this.props.type : 'side-tabs';

			var extraClass = this.props.extraClass ? this.props.extraClass : '';

			var tabTitles = _react2.default.Children.map(this.props.children, function (tab) {
				if (_.isUndefined(tab) || _.isNull(tab)) {
					return;
				}

				return _react2.default.createElement(
					'div',
					{
						className: 'forminator-toggle sui-tab-item' + (tab.props.value === _this2.state.active ? ' active' : ''),
						onClick: _this2.toggleValue.bind(_this2, tab.props.value)
					},
					tab.props.label,
					' ',
					tab.props.required && _react2.default.createElement(
						'span',
						{ className: 'sui-error' },
						'*'
					)
				);
			});

			var tabContents = _react2.default.Children.map(this.props.children, function (tab) {
				if (_.isUndefined(tab) || _.isNull(tab)) {
					return;
				}

				var boxClassValue = !_.isUndefined(tab.props.boxClass) ? tab.props.boxClass : 'sui-tab-content';

				return _react2.default.createElement(
					'div',
					{ className: boxClassValue + (tab.props.value === _this2.state.active ? ' active' : '') },
					tab.props.value === _this2.state.active && tab
				);
			});

			return _react2.default.createElement(
				'div',
				{ className: 'sui-' + type + ' ' + extraClass },
				_react2.default.createElement(
					'div',
					{ className: 'sui-tabs-menu' },
					tabTitles
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-tabs-content' },
					tabContents
				)
			);
		}
	}]);

	return Tabs;
}(_react.Component);

exports.default = Tabs;

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStore", function() { return createStore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineReducers", function() { return combineReducers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindActionCreators", function() { return bindActionCreators; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyMiddleware", function() { return applyMiddleware; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return compose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__DO_NOT_USE__ActionTypes", function() { return ActionTypes; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_symbol_observable__ = __webpack_require__(123);


/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = {
  INIT: '@@redux/INIT' + Math.random().toString(36).substring(7).split('').join('.'),
  REPLACE: '@@redux/REPLACE' + Math.random().toString(36).substring(7).split('').join('.')
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) return false;

  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    if (isDispatching) {
      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
    }

    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected the listener to be a function.');
    }

    if (isDispatching) {
      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.REPLACE });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if ((typeof observer === 'undefined' ? 'undefined' : _typeof(observer)) !== 'object' || observer === null) {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[__WEBPACK_IMPORTED_MODULE_0_symbol_observable__["a" /* default */]] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[__WEBPACK_IMPORTED_MODULE_0_symbol_observable__["a" /* default */]] = observable, _ref2;
}

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty
}

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionDescription = actionType && 'action "' + String(actionType) + '"' || 'an action';

  return 'Given ' + actionDescription + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });

  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });

  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, { type: ActionTypes.INIT });

    if (typeof initialState === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
    }

    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    if (typeof reducer(undefined, { type: type }) === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
    }
  });
}

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (process.env.NODE_ENV !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        warning('No reducer provided for key "' + key + '"');
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);

  var unexpectedKeyCache = void 0;
  if (process.env.NODE_ENV !== 'production') {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError = void 0;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var action = arguments[1];

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (process.env.NODE_ENV !== 'production') {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        warning(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(this, arguments));
  };
}

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if ((typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) !== 'object' || actionCreators === null) {
    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(undefined, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var store = createStore.apply(undefined, args);
      var _dispatch = function dispatch() {
        throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(undefined, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(undefined, chain)(store.dispatch);

      return _extends({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */
function isCrushed() {}

if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  warning("You are currently using minified code outside of NODE_ENV === 'production'. " + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}



/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = Empty;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Empty() {
	return '';
}

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Provider__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_connectAdvanced__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__connect_connect__ = __webpack_require__(120);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Provider", function() { return __WEBPACK_IMPORTED_MODULE_0__components_Provider__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "createProvider", function() { return __WEBPACK_IMPORTED_MODULE_0__components_Provider__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "connectAdvanced", function() { return __WEBPACK_IMPORTED_MODULE_1__components_connectAdvanced__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "connect", function() { return __WEBPACK_IMPORTED_MODULE_2__connect_connect__["a"]; });






/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(80);
var isBuffer = __webpack_require__(163);

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SettingsRow = function (_Component) {
	_inherits(SettingsRow, _Component);

	function SettingsRow(props) {
		_classCallCheck(this, SettingsRow);

		return _possibleConstructorReturn(this, (SettingsRow.__proto__ || Object.getPrototypeOf(SettingsRow)).call(this, props));
	}

	_createClass(SettingsRow, [{
		key: 'render',
		value: function render() {
			var content = _react2.default.Children.map(this.props.children, function (children) {
				return children;
			});

			var label = '';

			if (this.props.label && '' !== this.props.label) {
				label = _react2.default.createElement(
					'span',
					{ className: 'sui-settings-label' + ('' + (this.props.labelDark === true ? ' sui-dark' : '')) },
					this.props.label
				);
			}

			var description = '';
			var descriptionSpacing = 10;

			if (!_.isUndefined(this.props.descriptionSpacing) && '' !== this.props.descriptionSpacing) {
				descriptionSpacing = this.props.descriptionSpacing;
			}

			if (!_.isUndefined(this.props.description) && '' !== this.props.description) {
				if (this.props.sidebar === false) {
					description = _react2.default.createElement(
						'span',
						{
							className: 'sui-description',
							style: { marginBottom: descriptionSpacing + 'px' }
						},
						this.props.description
					);
				} else {
					description = _react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						this.props.description
					);
				}
			}

			var sidebar = '';

			if (this.props.label && '' !== this.props.label || this.props.description && '' !== this.props.description) {
				sidebar = _react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					label,
					description
				);
			}

			var conditionalStyles = this.props.lastChild ? { marginBottom: 0, borderBottom: 'unset' } : {};

			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row', style: conditionalStyles },
				(_.isUndefined(this.props.sidebar) || this.props.sidebar !== false) && sidebar,
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					!_.isUndefined(this.props.sidebar) && this.props.sidebar === false && label,
					!_.isUndefined(this.props.sidebar) && this.props.sidebar === false && description,
					content
				)
			);
		}
	}]);

	return SettingsRow;
}(_react.Component);

exports.default = SettingsRow;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SuiSelect2 = function (_Component) {
	_inherits(SuiSelect2, _Component);

	function SuiSelect2(props) {
		_classCallCheck(this, SuiSelect2);

		var _this = _possibleConstructorReturn(this, (SuiSelect2.__proto__ || Object.getPrototypeOf(SuiSelect2)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		_this.afterSave = _this.afterSave.bind(_this);
		return _this;
	}

	_createClass(SuiSelect2, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.$el = jQuery(this.el);

			var parent = this.$el.closest('.sui-modal-content');
			var parentId = parent.attr('id');
			var hasSearch = this.props.hasSearch ? 0 : -1;

			var options = Object.assign({
				dropdownParent: parent.length ? jQuery('#' + parentId) : jQuery('body[class*="sui-"]'),
				minimumResultsForSearch: hasSearch,
				dropdownCssClass: this.$el.hasClass('sui-select-sm') ? 'sui-select-dropdown-sm' : '',
				width: '100%'
			}, this.props.options);

			if (typeof this.$el.SUIselect2 === 'function') {
				this.$el.SUIselect2(options);
			} else if (typeof this.$el.FUIselect2 === 'function') {
				this.$el.FUIselect2(options);
			} else {
				throw Error('SUI Select2 not initiated');
			}

			this.updateValue = this.updateValue.bind(this);
			this.$el.on('change', this.updateValue);

			if (this.props.triggerChange) {
				this.$el.trigger('change');
			}
		}
	}, {
		key: 'updateValue',
		value: function updateValue(e) {
			var value = jQuery(e.target).val();

			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}

			this.afterSave(value);
		}
	}, {
		key: 'afterSave',
		value: function afterSave() {
			return false;
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.$el.off('change', this.updateValue);
			this.$el.unbind().removeData();
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) ? this.props.defaultValue : this.props.settings[this.props.property];

			var divClass = !_.isUndefined(this.props.fieldClass) ? 'sui-form-field ' + this.props.fieldClass : 'sui-form-field';

			var selectId = !_.isUndefined(this.props.elementId) ? this.props.elementId : this.props.property;

			var inputLabel = void 0;

			if (this.props.label) {
				inputLabel = _react2.default.createElement(
					'label',
					{
						htmlFor: 'forminator-field-' + this.props.property,
						className: 'sui-label'
					},
					this.props.label,
					'\xA0',
					this.props.required && _react2.default.createElement(
						'span',
						{ className: 'sui-error' },
						' *'
					),
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						this.props.note
					)
				);
			}

			var multiple = this.props.multiple;

			var _props = this.props,
			    formType = _props.formType,
			    updateProperty = _props.updateProperty,
			    noWrapper = _props.noWrapper,
			    fieldClass = _props.fieldClass,
			    staticContext = _props.staticContext,
			    formDesign = _props.formDesign,
			    fieldSize = _props.fieldSize,
			    selectProps = _objectWithoutProperties(_props, ['formType', 'updateProperty', 'noWrapper', 'fieldClass', 'staticContext', 'formDesign', 'fieldSize']);

			var getSelect = _react2.default.createElement(
				'select',
				_extends({
					id: 'forminator-field-' + selectId,
					className: 'sui-select',
					ref: function ref(el) {
						return _this2.el = el;
					},
					defaultValue: value,
					multiple: multiple
				}, selectProps),
				this.props.children
			);

			var getElement = _react2.default.createElement(
				'select',
				{
					id: 'forminator-field-' + selectId,
					className: 'sui-select',
					ref: function ref(el) {
						return _this2.el = el;
					},
					defaultValue: value,
					multiple: multiple
				},
				this.props.children
			);

			if ('md' === this.props.fieldsize || 'medium' === this.props.fieldsize) {
				getElement = _react2.default.createElement(
					'div',
					{ className: 'sui-form-field sui-input-md' },
					getSelect
				);
			} else if ('sm' === this.props.fieldsize || 'small' === this.props.fieldsize) {
				getElement = _react2.default.createElement(
					'div',
					{ className: 'sui-form-field sui-input-sm' },
					getSelect
				);
			} else if (!_.isUndefined(this.props.fieldsize) && '' !== this.props.fieldsize) {
				getElement = _react2.default.createElement(
					'div',
					{ style: { width: '100%', maxWidth: this.props.fieldsize + 'px' } },
					getSelect
				);
			}

			if (this.props.noWrapper) {
				return getSelect;
			}

			return _react2.default.createElement(
				'div',
				{ className: divClass },
				inputLabel,
				getElement,
				this.props.description && _react2.default.createElement(
					'span',
					{
						className: 'sui-description',
						style: { marginTop: '10px' }
					},
					this.props.description
				)
			);
		}
	}]);

	return SuiSelect2;
}(_react.Component);

exports.default = SuiSelect2;

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["escapeAmpersand"] = escapeAmpersand;
/* harmony export (immutable) */ __webpack_exports__["escapeQuotationMark"] = escapeQuotationMark;
/* harmony export (immutable) */ __webpack_exports__["escapeLessThan"] = escapeLessThan;
/* harmony export (immutable) */ __webpack_exports__["escapeAttribute"] = escapeAttribute;
/* harmony export (immutable) */ __webpack_exports__["escapeHTML"] = escapeHTML;
/* harmony export (immutable) */ __webpack_exports__["escapeEditableHTML"] = escapeEditableHTML;
/* harmony export (immutable) */ __webpack_exports__["isValidAttributeName"] = isValidAttributeName;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__escape_greater__ = __webpack_require__(189);
/**
 * Internal dependencies
 */

/**
 * Regular expression matching invalid attribute names.
 *
 * "Attribute names must consist of one or more characters other than controls,
 * U+0020 SPACE, U+0022 ("), U+0027 ('), U+003E (>), U+002F (/), U+003D (=),
 * and noncharacters."
 *
 * @see https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
 *
 * @type {RegExp}
 */

const REGEXP_INVALID_ATTRIBUTE_NAME = /[\u007F-\u009F "'>/="\uFDD0-\uFDEF]/;
/**
 * Returns a string with ampersands escaped. Note that this is an imperfect
 * implementation, where only ampersands which do not appear as a pattern of
 * named, decimal, or hexadecimal character references are escaped. Invalid
 * named references (i.e. ambiguous ampersand) are are still permitted.
 *
 * @see https://w3c.github.io/html/syntax.html#character-references
 * @see https://w3c.github.io/html/syntax.html#ambiguous-ampersand
 * @see https://w3c.github.io/html/syntax.html#named-character-references
 *
 * @param {string} value Original string.
 *
 * @return {string} Escaped string.
 */

function escapeAmpersand(value) {
  return value.replace(/&(?!([a-z0-9]+|#[0-9]+|#x[a-f0-9]+);)/gi, '&amp;');
}
/**
 * Returns a string with quotation marks replaced.
 *
 * @param {string} value Original string.
 *
 * @return {string} Escaped string.
 */

function escapeQuotationMark(value) {
  return value.replace(/"/g, '&quot;');
}
/**
 * Returns a string with less-than sign replaced.
 *
 * @param {string} value Original string.
 *
 * @return {string} Escaped string.
 */

function escapeLessThan(value) {
  return value.replace(/</g, '&lt;');
}
/**
 * Returns an escaped attribute value.
 *
 * @see https://w3c.github.io/html/syntax.html#elements-attributes
 *
 * "[...] the text cannot contain an ambiguous ampersand [...] must not contain
 * any literal U+0022 QUOTATION MARK characters (")"
 *
 * Note we also escape the greater than symbol, as this is used by wptexturize to
 * split HTML strings. This is a WordPress specific fix
 *
 * Note that if a resolution for Trac#45387 comes to fruition, it is no longer
 * necessary for `__unstableEscapeGreaterThan` to be used.
 *
 * See: https://core.trac.wordpress.org/ticket/45387
 *
 * @param {string} value Attribute value.
 *
 * @return {string} Escaped attribute value.
 */

function escapeAttribute(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__escape_greater__["a" /* default */])(escapeQuotationMark(escapeAmpersand(value)));
}
/**
 * Returns an escaped HTML element value.
 *
 * @see https://w3c.github.io/html/syntax.html#writing-html-documents-elements
 *
 * "the text must not contain the character U+003C LESS-THAN SIGN (<) or an
 * ambiguous ampersand."
 *
 * @param {string} value Element value.
 *
 * @return {string} Escaped HTML element value.
 */

function escapeHTML(value) {
  return escapeLessThan(escapeAmpersand(value));
}
/**
 * Returns an escaped Editable HTML element value. This is different from
 * `escapeHTML`, because for editable HTML, ALL ampersands must be escaped in
 * order to render the content correctly on the page.
 *
 * @param {string} value Element value.
 *
 * @return {string} Escaped HTML element value.
 */

function escapeEditableHTML(value) {
  return escapeLessThan(value.replace(/&/g, '&amp;'));
}
/**
 * Returns true if the given attribute name is valid, or false otherwise.
 *
 * @param {string} name Attribute name to test.
 *
 * @return {boolean} Whether attribute is valid.
 */

function isValidAttributeName(name) {
  return !REGEXP_INVALID_ATTRIBUTE_NAME.test(name);
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @providesModule warning
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var __DEV__ = process.env.NODE_ENV !== 'production';

var warning = function() {};

if (__DEV__) {
  var printWarning = function printWarning(format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    var argIndex = 0;
    var message = 'Warning: ' +
      format.replace(/%s/g, function() {
        return args[argIndex++];
      });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  }

  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
          '`warning(condition, format, ...args)` requires a warning ' +
          'message argument'
      );
    }
    if (!condition) {
      printWarning.apply(null, [format].concat(args));
    }
  };
}

module.exports = warning;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SuiSelect = function (_Component) {
	_inherits(SuiSelect, _Component);

	function SuiSelect(props) {
		_classCallCheck(this, SuiSelect);

		var _this = _possibleConstructorReturn(this, (SuiSelect.__proto__ || Object.getPrototypeOf(SuiSelect)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		return _this;
	}

	_createClass(SuiSelect, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.$el = jQuery(this.el);
			// SUI.select.init( this.$el );

			this.updateValue = this.updateValue.bind(this);
			this.$el.on('change', this.updateValue);
		}
	}, {
		key: 'updateValue',
		value: function updateValue(e) {
			var value = e.target.value;

			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.$el.off('change', this.updateValue);
			this.$el.unbind().removeData();
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) ? this.props.defaultValue : this.props.settings[this.props.property];

			var fieldClass = !_.isUndefined(this.props.fieldClass) ? 'sui-form-field ' + this.props.fieldClass : 'sui-form-field';

			var selectClass = !_.isUndefined(this.props.elementClass) ? this.props.elementClass : '';

			var selectId = !_.isUndefined(this.props.elementId) ? this.props.elementId : this.props.property;

			var selectLabel = '';

			if (this.props.label) {
				selectLabel = _react2.default.createElement(
					'label',
					{
						htmlFor: 'forminator-field-' + this.props.property,
						id: 'forminator-field-' + this.props.property + '-label',
						className: 'sui-label'
					},
					this.props.label,
					'\xA0',
					this.props.required && _react2.default.createElement(
						'span',
						{ className: 'sui-error' },
						' *'
					),
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						this.props.note
					)
				);
			}

			// For backwards compatibility.
			if (!_.isUndefined(value) && ('phone_national_country' === this.props.property || 'phone_international_country' === this.props.property)) {
				value = value.toLowerCase();
			}

			var selectField = _react2.default.createElement(
				'select',
				{
					defaultValue: value,
					id: 'forminator-field-' + selectId,
					className: selectClass,
					'aria-labelledby': 'forminator-field-' + selectId + '-label',
					ref: function ref(el) {
						return _this2.el = el;
					},
					style: { maxWidth: 'none' }
				},
				this.props.children
			);

			var getElement = selectField;

			if ('md' === this.props.fieldsize || 'medium' === this.props.fieldsize) {
				getElement = _react2.default.createElement(
					'div',
					{ className: 'sui-form-field sui-input-md' },
					selectField
				);
			} else if ('sm' === this.props.fieldsize || 'small' === this.props.fieldsize) {
				getElement = _react2.default.createElement(
					'div',
					{ className: 'sui-form-field sui-input-sm' },
					selectField
				);
			} else if ('' !== this.props.fieldsize) {
				getElement = _react2.default.createElement(
					'div',
					{ style: { width: '100%', maxWidth: this.props.fieldsize + 'px' } },
					selectField
				);
			}

			var getField = getElement;

			if (!this.props.simple) {
				getField = _react2.default.createElement(
					'div',
					{ className: fieldClass },
					selectLabel,
					getElement,
					this.props.description && _react2.default.createElement(
						'span',
						{
							className: 'sui-description',
							style: { marginTop: '10px' }
						},
						this.props.description
					)
				);
			}

			return getField;
		}
	}]);

	return SuiSelect;
}(_react.Component);

exports.default = SuiSelect;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Radio = function (_Component) {
	_inherits(Radio, _Component);

	function Radio(props) {
		_classCallCheck(this, Radio);

		var _this = _possibleConstructorReturn(this, (Radio.__proto__ || Object.getPrototypeOf(Radio)).call(this, props));

		_this.radioContainer = _react2.default.createRef();
		return _this;
	}

	_createClass(Radio, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var self = this;
			this.$radioContainer = jQuery(this.radioContainer);

			if (this.$radioContainer.hasClass('time_type')) {
				this.$radioContainer.on('click', '.forminator-toggle:not(.active)', function (e) {
					self.props.timeType(jQuery(e.currentTarget).data('val'));
				});
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.$radioContainer.off('click', this.updateValue).removeData();
		}
	}, {
		key: 'updateValue',
		value: function updateValue(value) {
			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);

				// Used to clear options on value change
				if (this.props.clearOptions === 'true') {
					if (value === 'single') {
						var options = [];
						_.each(this.props.state.options, function (option) {
							option.default = false;
							options.push(option);
						});

						this.props.updateProperty('options', options);
					}
				}
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) ? this.props.defaultValue : this.props.settings[this.props.property];

			var tabTitles = _react2.default.Children.map(this.props.children, function (tab) {
				return _react2.default.createElement(
					'button',
					_extends({
						id: 'tab-option-' + tab.props.value,
						role: 'tab',
						className: 'forminator-toggle sui-tab-item ' + (tab.props.value === value ? 'active' : ''),
						'aria-selected': tab.props.value === value ? 'true' : 'false'
					}, tab.props.value !== value && { tabIndex: '-1' }, {
						'data-val': tab.props.value,
						onClick: _this2.updateValue.bind(_this2, tab.props.value)
					}),
					tab.props.children
				);
			});

			var fieldLabel = '';

			if (this.props.label && '' !== this.props.label) {
				fieldLabel = _react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-field-' + this.props.property,
						className: 'sui-label' },
					this.props.label,
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						this.props.note
					)
				);
			}

			var fieldDescription = '';

			if (this.props.description && '' !== this.props.description) {
				fieldDescription = _react2.default.createElement(
					'span',
					{ className: 'sui-description' },
					this.props.description
				);
			}

			var settingsLabel = '';

			if (!this.props.label && this.props.settingsLabel) {
				settingsLabel = _react2.default.createElement(
					'label',
					{ className: 'sui-settings-label' },
					this.props.settingsLabel
				);
			}

			var settingsDescription = '';

			if (!this.props.label && this.props.settingsDesc) {
				settingsDescription = _react2.default.createElement(
					'span',
					{ className: 'sui-description',
						style: { marginBottom: '10px' } },
					this.props.settingsDesc
				);
			}

			var fieldContent = _react2.default.createElement(
				'div',
				{
					className: 'sui-side-tabs ' + this.props.property,
					style: this.props.description && { marginBottom: '5px' },
					ref: function ref(radioContainer) {
						return _this2.radioContainer = radioContainer;
					}
				},
				_react2.default.createElement(
					'div',
					{ className: 'sui-tabs-menu', role: 'tablist' },
					tabTitles
				)
			);

			var tabsContent = _react2.default.createElement(
				_react2.default.Fragment,
				null,
				fieldLabel,
				fieldContent
			);

			if (!this.props.noWrapper) {
				tabsContent = _react2.default.createElement(
					'div',
					{ className: 'sui-form-field' },
					fieldLabel,
					settingsLabel,
					settingsDescription,
					fieldContent,
					fieldDescription
				);
			}

			return tabsContent;
		}
	}]);

	return Radio;
}(_react.Component);

exports.default = Radio;

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ButtonIcon", function() { return ButtonIcon; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);


function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var ButtonIcon = function ButtonIcon(_ref) {
  var label = _ref.label,
      icon = _ref.icon,
      iconSize = _ref.iconSize,
      _ref$design = _ref.design,
      design = _ref$design === void 0 ? "solid" : _ref$design,
      color = _ref.color,
      className = _ref.className,
      loading = _ref.loading,
      props = _objectWithoutProperties(_ref, ["label", "icon", "iconSize", "design", "color", "className", "loading"]);

  var loader = /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("span", {
    className: "sui-icon-loader sui-loading",
    style: {
      position: "relative"
    },
    "aria-hidden": "true"
  });
  var content = /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Fragment, null, /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("span", {
    className: "sui-icon-".concat(icon).concat(iconSize ? ' sui-' + iconSize : ''),
    "aria-hidden": "true"
  }), /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("span", {
    className: "sui-screen-reader-text"
  }, label));
  className = "sui-button-icon ".concat(className || ''); // Set button color.

  switch (color) {
    case "blue":
    case "green":
    case "red":
    case "orange":
    case "purple":
    case "yellow":
    case "white":
      className += " sui-button-" + color;
      break;

    case "gray":
    default:
      className += "";
      break;
  } // Set button style.


  switch (design) {
    case "ghost":
    case "outlined":
      className += " sui-button-" + design;
      break;

    case "solid":
    default:
      className += "";
      break;
  } // Set loading class.


  if (loading) {
    className += " sui-button-onload";
  }

  var htmlTag = props.href ? 'a' : 'button';
  return /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(htmlTag, _objectSpread2({
    className: className,
    disabled: props.disabled || loading
  }, props), loading ? loader : content);
};




/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = ReactDOM;

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__createBrowserHistory__ = __webpack_require__(140);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__createBrowserHistory__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__createHashHistory__ = __webpack_require__(143);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__createHashHistory__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__createMemoryHistory__ = __webpack_require__(144);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_2__createMemoryHistory__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__LocationUtils__ = __webpack_require__(34);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_3__LocationUtils__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_3__LocationUtils__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__PathUtils__ = __webpack_require__(28);
/* unused harmony reexport parsePath */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_4__PathUtils__["b"]; });










/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Toggle = function (_Component) {
	_inherits(Toggle, _Component);

	function Toggle(props) {
		_classCallCheck(this, Toggle);

		var _this = _possibleConstructorReturn(this, (Toggle.__proto__ || Object.getPrototypeOf(Toggle)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		return _this;
	}

	_createClass(Toggle, [{
		key: 'updateValue',
		value: function updateValue(value) {
			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) ? '' : this.props.settings[this.props.property];

			var customClass = !_.isUndefined(this.props.customClass) ? this.props.customClass : 'sui-form-control';

			var disabled = !_.isUndefined(this.props.disabled) && this.props.disabled;
			var checked = value && !disabled;

			var toggleContent = _react2.default.createElement(
				'label',
				{ htmlFor: 'forminator-field-' + this.props.property,
					className: 'sui-toggle'
				},
				_react2.default.createElement('input', { type: 'checkbox',
					value: 'true',
					id: 'forminator-field-' + this.props.property,
					className: customClass,
					disabled: disabled ? 'disabled' : '',
					checked: checked ? 'checked' : '',
					onChange: function onChange(e) {
						_this2.updateValue(e.target.checked);
					}
				}),
				_react2.default.createElement('span', { className: 'sui-toggle-slider' }),
				this.props.label && _react2.default.createElement(
					_react2.default.Fragment,
					null,
					_react2.default.createElement(
						'span',
						{ className: 'sui-screen-reader-text' },
						(0, _utils.translate)('Enable'),
						' ',
						this.props.label
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-toggle-label' },
						this.props.label
					)
				),
				this.props.description && _react2.default.createElement(
					'span',
					{ className: 'sui-description sui-toggle-description' },
					this.props.description
				)
			);

			var subToggle = '';

			if (this.props.children && this.props.settings[this.props.property]) {
				subToggle = _react2.default.createElement(
					_react2.default.Fragment,
					null,
					_react2.default.createElement(
						'div',
						{
							tabIndex: '0',
							className: 'sui-toggle-content sui-border-frame',
							'aria-label': this.props.label
						},
						this.props.children
					)
				);
			}

			if (this.props.unWrap) {
				return _react2.default.createElement(
					_react2.default.Fragment,
					null,
					toggleContent,
					subToggle
				);
			}

			if (!this.props.unWrap) {
				return _react2.default.createElement(
					'div',
					{ className: 'sui-form-field' },
					toggleContent,
					subToggle
				);
			}
		}
	}]);

	return Toggle;
}(_react.Component);

exports.default = Toggle;

/***/ }),
/* 26 */,
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BrowserRouter__ = __webpack_require__(139);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "BrowserRouter", function() { return __WEBPACK_IMPORTED_MODULE_0__BrowserRouter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__HashRouter__ = __webpack_require__(145);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "HashRouter", function() { return __WEBPACK_IMPORTED_MODULE_1__HashRouter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Link__ = __webpack_require__(75);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Link", function() { return __WEBPACK_IMPORTED_MODULE_2__Link__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__MemoryRouter__ = __webpack_require__(146);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MemoryRouter", function() { return __WEBPACK_IMPORTED_MODULE_3__MemoryRouter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__NavLink__ = __webpack_require__(148);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "NavLink", function() { return __WEBPACK_IMPORTED_MODULE_4__NavLink__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Prompt__ = __webpack_require__(150);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Prompt", function() { return __WEBPACK_IMPORTED_MODULE_5__Prompt__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Redirect__ = __webpack_require__(152);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Redirect", function() { return __WEBPACK_IMPORTED_MODULE_6__Redirect__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Route__ = __webpack_require__(76);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Route", function() { return __WEBPACK_IMPORTED_MODULE_7__Route__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Router__ = __webpack_require__(47);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Router", function() { return __WEBPACK_IMPORTED_MODULE_8__Router__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__StaticRouter__ = __webpack_require__(154);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "StaticRouter", function() { return __WEBPACK_IMPORTED_MODULE_9__StaticRouter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__Switch__ = __webpack_require__(156);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Switch", function() { return __WEBPACK_IMPORTED_MODULE_10__Switch__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__generatePath__ = __webpack_require__(158);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "generatePath", function() { return __WEBPACK_IMPORTED_MODULE_11__generatePath__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__matchPath__ = __webpack_require__(159);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "matchPath", function() { return __WEBPACK_IMPORTED_MODULE_12__matchPath__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__withRouter__ = __webpack_require__(160);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "withRouter", function() { return __WEBPACK_IMPORTED_MODULE_13__withRouter__["a"]; });





























/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addLeadingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return stripLeadingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return hasBasename; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return stripBasename; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return stripTrailingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return parsePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createPath; });
var addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;


  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),
/* 29 */,
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Notification = function (_Component) {
	_inherits(Notification, _Component);

	function Notification(props) {
		_classCallCheck(this, Notification);

		return _possibleConstructorReturn(this, (Notification.__proto__ || Object.getPrototypeOf(Notification)).call(this, props));
	}

	_createClass(Notification, [{
		key: 'initialize',
		value: function initialize() {
			if (!jQuery('.sui-floating-notices').length) {
				jQuery('main.sui-wrap').prepend('<div class="sui-floating-notices"></div>');
			}

			if (!jQuery('#forminator-notification').length) {
				jQuery('.sui-floating-notices').append('<div role="alert" id="forminator-notification" class="sui-notice" aria-live="assertive"></div>');
			} else {
				jQuery('#forminator-notification').remove();
				this.initialize();
			}

			this.$notification = jQuery('#forminator-notification');
		}
	}, {
		key: 'open',
		value: function open() {
			this.initialize();

			var noticeId = 'forminator-notification';
			var noticeMessage = '<p>' + this.props.text + '</p>';
			var noticeOptions = {
				type: this.props.type || 'default',
				autoclose: {
					timeout: this.props.time || 5000
				},
				dismiss: {
					show: this.props.dismiss || false
				}
			};

			SUI.openNotice(noticeId, noticeMessage, noticeOptions);
		}
	}, {
		key: 'close',
		value: function close() {
			var noticeId = 'forminator-notification';
			SUI.closeNotice(noticeId);
		}
	}]);

	return Notification;
}(_react.Component);

exports.default = Notification;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _escapeHtml = __webpack_require__(18);

var _dompurify = __webpack_require__(191);

var _dompurify2 = _interopRequireDefault(_dompurify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WpEditor = function (_Component) {
	_inherits(WpEditor, _Component);

	function WpEditor(props) {
		_classCallCheck(this, WpEditor);

		var _this = _possibleConstructorReturn(this, (WpEditor.__proto__ || Object.getPrototypeOf(WpEditor)).call(this, props));

		_this.textEditor = _react2.default.createRef();
		_this.updateValue = _this.updateValue.bind(_this);
		_this.updateEditor = _this.updateEditor.bind(_this);
		_this.toggleOptions = _this.toggleOptions.bind(_this);
		_this.state = {
			editorOptionsOpen: false
		};
		return _this;
	}

	_createClass(WpEditor, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var _this2 = this;

			this.$el = jQuery(this.el);

			// update field if default value is present.
			if (!_.isUndefined(this.props.defaultValue)) {
				this.updateValue(this.props.defaultValue);
			}

			setTimeout(function () {
				_this2.initEditor();
			}, 50);
		}
	}, {
		key: 'initEditor',
		value: function initEditor() {
			var _this3 = this;

			if (_.isUndefined(wp.editor) || typeof tinyMCE === 'undefined') {
				setTimeout(function () {
					_this3.initEditor();
				}, 50);

				return;
			}
			var tinymceProps = {};
			if (!_.isUndefined(this.props.allowButtonOnclick)) {
				// Add onclick attribute.
				tinymceProps.extended_valid_elements = 'button[onclick|accesskey|class|dir<ltr?rtl|disabled<disabled|id|lang|name|style|tabindex|title|type|value]';
			}
			if (!_.isUndefined(this.props.cutomTinymce)) {
				tinymceProps.toolbar1 = this.props.cutomTinymce;
			}
			if (_.isEmpty(tinymceProps)) {
				tinymceProps = true;
			}

			// Initialize editor
			wp.editor.initialize('forminator-field-' + (this.props.property + !_.isUndefined(this.props.extraId) ? this.props.extraId : ''), {
				tinymce: tinymceProps,
				quicktags: true
			});

			this.bindEvents();
		}
	}, {
		key: 'bindEvents',
		value: function bindEvents() {
			var _this4 = this;

			this.editor = tinyMCE.get('forminator-field-' + (this.props.property + !_.isUndefined(this.props.extraId) ? this.props.extraId : ''));

			if (this.editor === null) {
				setTimeout(function () {
					_this4.bindEvents();
				}, 50);

				return;
			}

			this.editor.on('keyup', this.updateEditor);
			this.editor.on('change', this.updateEditor);
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.$el.off('change', this.updateEditor);
			wp.editor.remove('forminator-field-' + (this.props.property + !_.isUndefined(this.props.extraId) ? this.props.extraId : ''));
			this.$el.unbind().removeData();
		}
	}, {
		key: 'updateEditor',
		value: function updateEditor() {
			// use editor content as value
			var value = this.editor.getContent();

			this.updateValue(value);
		}
	}, {
		key: 'updateValue',
		value: function updateValue(value) {
			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, _dompurify2.default.sanitize(value, { ADD_ATTR: ['target'] }));
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, _dompurify2.default.sanitize(value, { ADD_ATTR: ['target'] }));
			}
		}
	}, {
		key: 'toggleOptions',
		value: function toggleOptions() {
			if (this.state.editorOptionsOpen) {
				this.setState({ editorOptionsOpen: false });
			} else {
				this.setState({ editorOptionsOpen: true });
			}
		}
	}, {
		key: 'insertContent',
		value: function insertContent(content) {
			// If tinyMce editor is hidden, we are on Text mode
			if (this.editor.hidden) {
				var textEditor = jQuery(this.textEditor);
				var startPos = textEditor.prop('selectionStart');
				var endPos = textEditor.prop('selectionEnd');
				var textEditorVal = textEditor.val();

				textEditor.val(textEditorVal.substring(0, startPos) + '{' + content + '}' + textEditorVal.substring(endPos, textEditorVal.length));

				textEditor.trigger('change');
			} else {
				this.editor.insertContent('{' + content + '}');
			}

			// close option
			this.toggleOptions();
		}
	}, {
		key: 'getDisabledFields',
		value: function getDisabledFields() {
			var disabledFields = ['captcha', 'product', 'hidden', 'page-break', 'postdata', 'total', 'upload', 'stripe', 'paypal', 'password'];

			if (!_.isUndefined(this.props.enablePostData) && this.props.enablePostData && !_.isUndefined(this.props.enableUpload) && this.props.enableUpload) {
				disabledFields = ['captcha', 'product', 'hidden', 'page-break', 'total', 'stripe', 'paypal', 'password'];
			}

			return disabledFields;
		}
	}, {
		key: 'getFields',
		value: function getFields() {
			var disabledFields = this.getDisabledFields();
			var excludeSubFields = !_.isUndefined(this.props.excludeSubFields) ? this.props.excludeSubFields : false;
			var form_wrappers = this.props.wrappers;

			if (!_.isUndefined(this.props.enableParentForm) && !_.isUndefined(forminatorData.parentFormFields)) {
				form_wrappers = forminatorData.parentFormFields;
			}

			return (0, _utils.getFields)(form_wrappers, disabledFields, undefined, undefined, excludeSubFields);
		}
	}, {
		key: 'getFormData',
		value: function getFormData() {
			var _this5 = this;

			var fields = this.getFields();
			var allowRepeater = !_.isUndefined(this.props.allowRepeater) ? this.props.allowRepeater : true;

			var requiredFields = _.map(fields, function (field, index) {
				if (field.required) {
					if (allowRepeater || !allowRepeater && _.isEmpty(field.parent_group)) {
						return _react2.default.createElement(
							'li',
							{ className: 'wpmudev-dropdown--option', key: index },
							_react2.default.createElement(
								'a',
								{
									className: 'wpmudev-insert-content',
									onClick: _this5.insertContent.bind(_this5, field.element_id)
								},
								(0, _escapeHtml.escapeHTML)(field.label)
							)
						);
					}
				}
			});

			var currentType = !_.isUndefined(this.props.settings.type) ? this.props.settings.type : '';
			var nonrequiredFields = _.map(fields, function (field, index) {
				if (!field.required && currentType !== field.field_type) {
					if (allowRepeater || !allowRepeater && _.isEmpty(field.parent_group)) {
						return _react2.default.createElement(
							'li',
							{ className: 'wpmudev-dropdown--option', key: index },
							_react2.default.createElement(
								'a',
								{
									className: 'wpmudev-insert-content',
									onClick: _this5.insertContent.bind(_this5, field.element_id)
								},
								(0, _escapeHtml.escapeHTML)(field.label)
							)
						);
					}
				}
			});

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				requiredFields && requiredFields.some(function (item) {
					return "undefined" !== typeof item;
				}) && _react2.default.createElement(
					_react2.default.Fragment,
					null,
					_react2.default.createElement(
						'li',
						{ className: 'wpmudev-dropdown--option' },
						_react2.default.createElement(
							'strong',
							null,
							(0, _utils.translate)('Required Fields')
						)
					),
					_react2.default.createElement(
						_react2.default.Fragment,
						null,
						requiredFields
					)
				),
				nonrequiredFields && nonrequiredFields.some(function (item) {
					return "undefined" !== typeof item;
				}) && _react2.default.createElement(
					_react2.default.Fragment,
					null,
					_react2.default.createElement(
						'li',
						{ className: 'wpmudev-dropdown--option' },
						_react2.default.createElement(
							'strong',
							null,
							(0, _utils.translate)('Optional Fields')
						)
					),
					_react2.default.createElement(
						_react2.default.Fragment,
						null,
						nonrequiredFields
					)
				)
			);
		}
	}, {
		key: 'getMiscData',
		value: function getMiscData() {
			var _this6 = this;

			var editorOptions = !_.isEmpty(this.props.editorOptions) ? this.props.editorOptions : [];

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'li',
					{ className: 'wpmudev-dropdown--option' },
					_react2.default.createElement(
						'strong',
						null,
						(0, _utils.translate)('Misc Data')
					)
				),
				_.map(editorOptions, function (label, key) {
					return _react2.default.createElement(
						'li',
						{ className: 'wpmudev-dropdown--option', key: key },
						_react2.default.createElement(
							'a',
							{
								className: 'wpmudev-insert-content',
								onClick: _this6.insertContent.bind(_this6, key)
							},
							label
						)
					);
				})
			);
		}
	}, {
		key: 'getPaymentData',
		value: function getPaymentData() {
			var _this7 = this;

			var formWrappers = this.props.wrappers;
			if (!_.isUndefined(this.props.enableParentForm) && !_.isUndefined(forminatorData.parentFormFields)) {
				formWrappers = forminatorData.parentFormFields;
			}
			var paypalFields = (0, _utils.getFieldsByType)('paypal', formWrappers);
			var stripeFields = (0, _utils.getFieldsByType)('stripe', formWrappers);
			var paymentOptions = !_.isEmpty(this.props.paymentOptions) ? this.props.paymentOptions : [];
			if (!_.isEmpty(paypalFields) || !_.isEmpty(stripeFields)) {
				return _react2.default.createElement(
					_react2.default.Fragment,
					null,
					this.props.paymentOptions && _react2.default.createElement(
						'li',
						{ className: 'wpmudev-dropdown--option' },
						_react2.default.createElement(
							'strong',
							null,
							(0, _utils.translate)('Payment Data')
						)
					),
					_.map(paymentOptions, function (label, key) {
						return _react2.default.createElement(
							'li',
							{ className: 'wpmudev-dropdown--option', key: key },
							_react2.default.createElement(
								'a',
								{
									className: 'wpmudev-insert-content',
									onClick: _this7.insertContent.bind(_this7, key)
								},
								label
							)
						);
					})
				);
			}
		}
	}, {
		key: 'getEditorOptions',
		value: function getEditorOptions() {
			var _this8 = this;

			if (this.props.hideEditorOptions) {
				return '';
			}

			var miscMarkup = this.props.disableMiscData ? '' : this.getMiscData();
			var paymentMarkup = this.props.enableFormData ? this.getPaymentData() : '';
			var fieldsMarkup = this.props.enableFormData ? this.getFormData() : '';
			var mainOptions = this.props.mainOptions ? this.props.mainOptions : { form_name: (0, _utils.translate)('Form Name') };

			return _react2.default.createElement(
				'ul',
				{ className: this.state.editorOptionsOpen ? 'sui-active' : '' },
				this.props.enableAllFormFields && _react2.default.createElement(
					'li',
					{ className: 'wpmudev-dropdown--option' },
					_react2.default.createElement(
						'a',
						{
							className: 'wpmudev-insert-content',
							onClick: this.insertContent.bind(this, 'all_fields')
						},
						(0, _utils.translate)('All Form Fields')
					)
				),
				this.props.enableAllNonFormFields && _react2.default.createElement(
					'li',
					{ className: 'wpmudev-dropdown--option' },
					_react2.default.createElement(
						'a',
						{
							className: 'wpmudev-insert-content',
							onClick: this.insertContent.bind(this, 'all_non_empty_fields')
						},
						(0, _utils.translate)('All Non Empty Fields')
					)
				),
				fieldsMarkup,
				_react2.default.createElement(
					_react2.default.Fragment,
					null,
					this.props.mainOptionsLabel && _react2.default.createElement(
						'li',
						{ className: 'wpmudev-dropdown--option' },
						_react2.default.createElement(
							'strong',
							null,
							this.props.mainOptionsLabel
						)
					),
					_.map(mainOptions, function (label, key) {
						return _react2.default.createElement(
							'li',
							{ className: 'wpmudev-dropdown--option', key: key },
							_react2.default.createElement(
								'a',
								{
									className: 'wpmudev-insert-content',
									onClick: _this8.insertContent.bind(_this8, key)
								},
								label
							)
						);
					})
				),
				miscMarkup,
				paymentMarkup
			);
		}
	}, {
		key: 'isValid',
		value: function isValid(value) {
			if (this.props.isRequired) {
				return this.props.isRequired && !_.isEmpty(value);
			} else if (!_.isUndefined(this.props.isPositive)) {
				return _.isEmpty(value) || value >= 0;
			}

			return true;
		}
	}, {
		key: 'render',
		value: function render() {
			var _this9 = this;

			var value = this.props.settings[this.props.property] || this.props.defaultValue || '';

			var editorOptions = this.getEditorOptions();

			var requiredError = !_.isUndefined(this.props.requiredError) ? this.props.requiredError : (0, _utils.translate)('This field is required!');

			var hasErrorClass = !this.isValid(value) ? 'sui-form-field-error' : '';

			var editorOptionsMarkup = void 0;

			if (!_.isEmpty(editorOptions)) {
				editorOptionsMarkup = _react2.default.createElement(
					'div',
					{ className: 'sui-editor-options' },
					_react2.default.createElement(
						'button',
						{
							className: this.state.editorOptionsOpen ? 'sui-tooltip sui-active' : 'sui-tooltip',
							'data-tooltip': !_.isUndefined(this.props.tooltipLabel) ? this.props.tooltipLabel : (0, _utils.translate)('Add form data'),
							onClick: this.toggleOptions
						},
						_react2.default.createElement('i', { className: 'sui-icon-plus sui-sm', 'aria-hidden': 'true' }),
						!_.isUndefined(this.props.selectLabel) ? this.props.selectLabel : (0, _utils.translate)('Insert form fields')
					),
					editorOptions
				);
			}

			var wpEditorLabel = '';

			if (this.props.label) {
				wpEditorLabel = _react2.default.createElement(
					'label',
					{
						htmlFor: 'forminator-field-' + (this.props.property + !_.isUndefined(this.props.extraId) ? this.props.extraId : ''),
						className: 'sui-label'
					},
					this.props.label,
					'\xA0',
					this.props.isRequired && _react2.default.createElement(
						'span',
						{ className: 'sui-error' },
						' *'
					),
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						this.props.note
					)
				);
			}

			return _react2.default.createElement(
				'div',
				{ className: 'sui-form-field ' + hasErrorClass },
				wpEditorLabel,
				this.props.descriptionTop && _react2.default.createElement(
					'span',
					{ className: 'sui-description', style: { marginBottom: '20px' } },
					this.props.descriptionTop
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-editor' + (_.isEmpty(editorOptions) ? '' : ' sui-editor-with-options') },
					editorOptionsMarkup,
					_react2.default.createElement('textarea', {
						id: 'forminator-field-' + (this.props.property + !_.isUndefined(this.props.extraId) ? this.props.extraId : ''),
						placeholder: this.props.placeholder,
						defaultValue: value,
						onChange: function onChange(e) {
							_this9.updateValue(e.target.value);
						},
						ref: function ref(textEditor) {
							return _this9.textEditor = textEditor;
						}
					})
				),
				this.props.isRequired && !this.isValid(value) && _react2.default.createElement(
					'span',
					{ className: 'sui-error-message' },
					requiredError
				),
				this.props.description && _react2.default.createElement(
					'span',
					{ className: 'sui-description' },
					this.props.description
				)
			);
		}
	}]);

	return WpEditor;
}(_react.Component);

exports.default = WpEditor;

/***/ }),
/* 32 */,
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return locationsAreEqual; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_resolve_pathname__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_value_equal__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__PathUtils__ = __webpack_require__(28);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };





var createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = Object(__WEBPACK_IMPORTED_MODULE_2__PathUtils__["d" /* parsePath */])(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = Object(__WEBPACK_IMPORTED_MODULE_0_resolve_pathname__["a" /* default */])(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && Object(__WEBPACK_IMPORTED_MODULE_1_value_equal__["a" /* default */])(a.state, b.state);
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Accordion = function (_Component) {
	_inherits(Accordion, _Component);

	function Accordion(props) {
		_classCallCheck(this, Accordion);

		var _this = _possibleConstructorReturn(this, (Accordion.__proto__ || Object.getPrototypeOf(Accordion)).call(this, props));

		_this.state = {
			open: props.expanded || false
		};

		_this.toggleState = _this.toggleState.bind(_this);
		return _this;
	}

	_createClass(Accordion, [{
		key: 'toggleState',
		value: function toggleState() {
			this.setState({
				open: !this.state.open
			});
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var label = this.props.label;
			var open = this.state.open;

			var divClass = '';

			if (open) {
				divClass = 'sui-accordion-item--open';
			}

			// eslint-disable-next-line max-len
			var boxedContent = !_.isUndefined(this.props.boxedContent) && '' !== this.props.boxedContent ? this.props.boxedContent : true;

			var defaultContentRender = !_.isUndefined(this.props.defaultContentRender) ? this.props.defaultContentRender : false;

			var accordionContents = _react2.default.Children.map(this.props.children, function (tab) {
				return tab;
			});

			// It's intentionally we use span here to avoid unwanted handlers from SUI on div.sui-accordion-item-header.
			return _react2.default.createElement(
				'div',
				{ className: 'sui-accordion-item ' + divClass },
				_react2.default.createElement(
					'span',
					{ className: 'sui-accordion-item-header', onClick: function onClick() {
							return _this2.toggleState();
						} },
					_react2.default.createElement(
						'div',
						{ className: 'sui-accordion-item-title' },
						_react2.default.createElement(
							'span',
							null,
							label
						),
						_react2.default.createElement(
							'button',
							{
								className: 'sui-button-icon sui-accordion-open-indicator',
								onClick: function onClick() {
									return _this2.toggleState();
								}
							},
							_react2.default.createElement('i', { className: 'sui-icon-chevron-down', 'aria-hidden': 'true' }),
							_react2.default.createElement(
								'span',
								{ className: 'sui-screen-reader-text' },
								false === this.state.open ? 'Open' : 'Close'
							)
						)
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-accordion-item-body' },
					false === boxedContent ? (defaultContentRender || open) && accordionContents : _react2.default.createElement(
						'div',
						{ className: 'sui-box' },
						_react2.default.createElement(
							'div',
							{ className: 'sui-box-body' },
							(defaultContentRender || open) && accordionContents
						),
						boxedContent
					)
				)
			);
		}
	}]);

	return Accordion;
}(_react.Component);

exports.default = Accordion;

/***/ }),
/* 36 */,
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(54);
var inherits = __webpack_require__(55);

exports.inherits = inherits;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),
/* 38 */,
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(162);

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stringify = __webpack_require__(180);
var parse = __webpack_require__(181);
var formats = __webpack_require__(86);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Checkbox = function (_Component) {
	_inherits(Checkbox, _Component);

	function Checkbox(props) {
		_classCallCheck(this, Checkbox);

		var _this = _possibleConstructorReturn(this, (Checkbox.__proto__ || Object.getPrototypeOf(Checkbox)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		return _this;
	}

	_createClass(Checkbox, [{
		key: 'updateValue',
		value: function updateValue(value) {
			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) ? this.props.defaultValue : this.props.settings[this.props.property];

			var fieldId = _.isUndefined(this.props.fieldId) ? this.props.property : this.props.fieldId;

			var disabled = !_.isUndefined(this.props.disabled) && this.props.disabled ? true : false;

			var extraClass = '';

			if (this.props.itemClass && '' !== this.props.itemClass) {
				extraClass = ' ' + this.props.itemClass;
			}

			return _react2.default.createElement(
				'label',
				{
					htmlFor: 'forminator-field-' + fieldId,
					className: 'sui-checkbox' + extraClass
				},
				_react2.default.createElement('input', {
					type: 'checkbox',
					id: 'forminator-field-' + fieldId,
					value: 'true',
					checked: value ? 'checked' : '',
					disabled: disabled,
					onChange: function onChange(e) {
						_this2.updateValue(e.target.checked);
					}
				}),
				_react2.default.createElement('span', { 'aria-hidden': 'true' }),
				this.props.label && _react2.default.createElement(
					'span',
					null,
					this.props.label,
					!_.isUndefined(this.props.tooltip) && '' !== this.props.tooltip && _react2.default.createElement(
						'span',
						{
							className: 'sui-tooltip sui-tooltip-constrained',
							style: {
								marginLeft: 10,
								verticalAlign: 'middle',
								'--tooltip-width': '165px'
							},
							'data-tooltip': this.props.tooltip
						},
						_react2.default.createElement('span', {
							className: 'sui-icon-info',
							'aria-hidden': 'true',
							style: { pointerEvents: 'none' }
						})
					)
				)
			);
		}
	}]);

	return Checkbox;
}(_react.Component);

exports.default = Checkbox;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 43 */,
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}

/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);


var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          __WEBPACK_IMPORTED_MODULE_0_warning___default()(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

/* harmony default export */ __webpack_exports__["a"] = (createTransitionManager);

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Router__ = __webpack_require__(48);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Router__["a" /* default */]);

/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_prop_types__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * The public API for putting history on context.
 */

var Router = function (_React$Component) {
  _inherits(Router, _React$Component);

  function Router() {
    var _temp, _this, _ret;

    _classCallCheck(this, Router);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props.history.location.pathname)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Router.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        history: this.props.history,
        route: {
          location: this.props.history.location,
          match: this.state.match
        }
      })
    };
  };

  Router.prototype.computeMatch = function computeMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };

  Router.prototype.componentWillMount = function componentWillMount() {
    var _this2 = this;

    var _props = this.props,
        children = _props.children,
        history = _props.history;


    __WEBPACK_IMPORTED_MODULE_1_invariant___default()(children == null || __WEBPACK_IMPORTED_MODULE_2_react___default.a.Children.count(children) === 1, "A <Router> may have only one child element");

    // Do this here so we can setState when a <Redirect> changes the
    // location in componentWillMount. This happens e.g. when doing
    // server rendering using a <StaticRouter>.
    this.unlisten = history.listen(function () {
      _this2.setState({
        match: _this2.computeMatch(history.location.pathname)
      });
    });
  };

  Router.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(this.props.history === nextProps.history, "You cannot change <Router history>");
  };

  Router.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unlisten();
  };

  Router.prototype.render = function render() {
    var children = this.props.children;

    return children ? __WEBPACK_IMPORTED_MODULE_2_react___default.a.Children.only(children) : null;
  };

  return Router;
}(__WEBPACK_IMPORTED_MODULE_2_react___default.a.Component);

Router.propTypes = {
  history: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired,
  children: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.node
};
Router.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object
};
Router.childContextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Router);

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path_to_regexp__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path_to_regexp___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_path_to_regexp__);


var patternCache = {};
var cacheLimit = 10000;
var cacheCount = 0;

var compilePath = function compilePath(pattern, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});

  if (cache[pattern]) return cache[pattern];

  var keys = [];
  var re = __WEBPACK_IMPORTED_MODULE_0_path_to_regexp___default()(pattern, keys, options);
  var compiledPattern = { re: re, keys: keys };

  if (cacheCount < cacheLimit) {
    cache[pattern] = compiledPattern;
    cacheCount++;
  }

  return compiledPattern;
};

/**
 * Public API for matching a URL pathname to a path pattern.
 */
var matchPath = function matchPath(pathname) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var parent = arguments[2];

  if (typeof options === "string") options = { path: options };

  var _options = options,
      path = _options.path,
      _options$exact = _options.exact,
      exact = _options$exact === undefined ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === undefined ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === undefined ? false : _options$sensitive;


  if (path == null) return parent;

  var _compilePath = compilePath(path, { end: exact, strict: strict, sensitive: sensitive }),
      re = _compilePath.re,
      keys = _compilePath.keys;

  var match = re.exec(pathname);

  if (!match) return null;

  var url = match[0],
      values = match.slice(1);

  var isExact = pathname === url;

  if (exact && !isExact) return null;

  return {
    path: path, // the path pattern used to match
    url: path === "/" && url === "" ? "/" : url, // the matched portion of the URL
    isExact: isExact, // whether or not we matched exactly
    params: keys.reduce(function (memo, key, index) {
      memo[key.name] = values[index];
      return memo;
    }, {})
  };
};

/* harmony default export */ __webpack_exports__["a"] = (matchPath);

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(14);
var normalizeHeaderName = __webpack_require__(165);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(81);
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(81);
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Button", function() { return Button; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);


function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var Button = function Button(_ref) {
  var label = _ref.label,
      icon = _ref.icon,
      _ref$design = _ref.design,
      design = _ref$design === void 0 ? "solid" : _ref$design,
      color = _ref.color,
      className = _ref.className,
      loading = _ref.loading,
      props = _objectWithoutProperties(_ref, ["label", "icon", "design", "color", "className", "loading"]);

  var loader = /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("span", {
    className: "sui-icon-loader sui-loading",
    style: {
      position: "relative"
    },
    "aria-hidden": "true"
  });
  var content = /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Fragment, null, icon && "" !== icon && /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("span", {
    className: "sui-icon-" + icon,
    "aria-hidden": "true"
  }), label);
  className = "sui-button".concat(className ? ' ' + className : ''); // Set button color.

  switch (color) {
    case "blue":
    case "green":
    case "red":
    case "orange":
    case "purple":
    case "yellow":
    case "white":
      className += " sui-button-" + color;
      break;

    case "gray":
    default:
      className += "";
      break;
  } // Set button style.


  switch (design) {
    case "ghost":
    case "outlined":
      className += " sui-button-" + design;
      break;

    case "solid":
    default:
      className += "";
      break;
  } // Set loading class.


  if (loading) {
    className += " sui-button-onload";
  }

  var htmlTag = 'button';

  if (props.href) {
    htmlTag = 'a';
  } else if (props.htmlFor) {
    htmlTag = 'label';
  }

  return /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(htmlTag, _objectSpread2({
    className: className,
    disabled: props.disabled || loading
  }, props), loading ? loader : content);
};




/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Internal dependencies
 */
var I18N = __webpack_require__( 92 ),
	i18n = new I18N();

module.exports = {
	numberFormat: i18n.numberFormat.bind( i18n ),
	translate: i18n.translate.bind( i18n ),
	configure: i18n.configure.bind( i18n ),
	setLocale: i18n.setLocale.bind( i18n ),
	getLocale: i18n.getLocale.bind( i18n ),
	getLocaleSlug: i18n.getLocaleSlug.bind( i18n ),
	addTranslations: i18n.addTranslations.bind( i18n ),
	reRenderTranslations: i18n.reRenderTranslations.bind( i18n ),
	registerComponentUpdateHook: i18n.registerComponentUpdateHook.bind( i18n ),
	registerTranslateHook: i18n.registerTranslateHook.bind( i18n ),
	state: i18n.state,
	stateObserver: i18n.stateObserver,
	on: i18n.stateObserver.on.bind(i18n.stateObserver),
	off: i18n.stateObserver.removeListener.bind(i18n.stateObserver),
	emit: i18n.stateObserver.emit.bind(i18n.stateObserver),
	localize: __webpack_require__( 105 )( i18n ),
	$this: i18n,
	I18N: I18N
};



/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SuiTags = function (_Component) {
	_inherits(SuiTags, _Component);

	function SuiTags(props) {
		_classCallCheck(this, SuiTags);

		var _this = _possibleConstructorReturn(this, (SuiTags.__proto__ || Object.getPrototypeOf(SuiTags)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		_this.clearValue = _this.clearValue.bind(_this);

		var defaultValue = _.isUndefined(_this.props.defaultValue) ? '' : _this.props.defaultValue;

		var value = _.isUndefined(_this.props.settings[_this.props.property]) ? defaultValue : _this.props.settings[_this.props.property];

		_this.state = {
			value: value
		};
		return _this;
	}

	_createClass(SuiTags, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var _this2 = this;

			this.$el = jQuery(this.el);
			SUI.select.initVars(this.$el);

			this.updateValue = this.updateValue.bind(this);

			var isRedirectUrl = this.$el.closest('.sui-form-field').hasClass('redirect-url');
			this.$el.on('change', function (e) {
				var value = _this2.state.value + (isRedirectUrl ? '' : ' ') + e.target.value;
				_this2.updateValue(value.trim());
			});

			this.clearValue(this.$el);

			this.$el.closest('.sui-form-field').hasClass('sui-variables-select-text') && this.insertFormFields();
		}
	}, {
		key: 'updateValue',
		value: function updateValue(value) {
			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
			if (typeof this.props.updateValue === 'function') {
				this.props.updateValue(this.props.counter, value);
			}
			this.setState({ value: value });
		}
	}, {
		key: 'clearValue',
		value: function clearValue(element) {
			element.val(null).trigger('change');
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.$el.off('change', this.updateValue);
			this.$el.unbind().removeData();
		}
	}, {
		key: 'isValid',
		value: function isValid(value) {
			if (this.props.isRequired) {
				return this.props.isRequired && !_.isEmpty(value);
			} else if (!_.isUndefined(this.props.isPositive)) {
				return _.isEmpty(value) || value >= 0;
			}

			return true;
		}
	}, {
		key: 'insertFormFields',
		value: function insertFormFields() {
			this.$el.next('.select2-container').find('.select2-selection').html((0, _utils.translate)('+ Insert form fields'));
		}
	}, {
		key: 'render',
		value: function render() {
			var _this3 = this;

			var defaultValue = _.isUndefined(this.props.defaultValue) ? '' : this.props.defaultValue;
			var value = _.isUndefined(this.props.settings[this.props.property]) ? defaultValue : this.props.settings[this.props.property];
			var requiredError = !_.isUndefined(this.props.requiredError) ? this.props.requiredError : (0, _utils.translate)('This field is required!');

			var hasErrorClass = !this.isValid(value) ? ' sui-form-field-error' : '';
			var hasCustomClass = !_.isUndefined(this.props.customClass) ? ' ' + this.props.customClass : '';

			var fieldLabel = '';
			var type = 'input';
			var textareaClass = '';

			if (this.props.type === 'textarea') {
				type = 'textarea';
				textareaClass = 'textarea-type';
			}

			if (this.props.label) {
				fieldLabel = _react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-field-' + this.props.property, className: 'sui-label' },
					this.props.label,
					'\xA0',
					(this.props.isRequired || this.props.required) && _react2.default.createElement(
						'span',
						{ className: 'sui-error' },
						' *'
					),
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						this.props.note
					)
				);
			}

			var fieldControl = _react2.default.createElement(
				_react2.default.Fragment,
				null,
				type === 'input' && _react2.default.createElement('input', {
					type: 'text',
					value: this.state.value,
					placeholder: this.props.placeholder,
					className: 'sui-form-control',
					onChange: function onChange(e) {
						_this3.updateValue(e.target.value);
					}
				}),
				type === 'textarea' && _react2.default.createElement('textarea', {
					value: this.state.value,
					placeholder: this.props.placeholder,
					className: 'sui-form-control',
					onChange: function onChange(e) {
						_this3.updateValue(e.target.value);
					},
					rows: this.props.rows
				})
			);

			return _react2.default.createElement(
				'div',
				{ className: 'sui-form-field' + hasCustomClass + hasErrorClass },
				fieldLabel,
				_react2.default.createElement(
					'div',
					{ className: 'sui-insert-variables ' + textareaClass },
					fieldControl,
					_react2.default.createElement(
						'select',
						{ className: 'sui-variables', ref: function ref(el) {
								return _this3.el = el;
							} },
						this.props.children.length <= 0 && _react2.default.createElement('optgroup', { label: (0, _utils.translate)('No available options') }),
						this.props.children
					),
					this.props.isRequired && !this.isValid(value) && _react2.default.createElement(
						'span',
						{ className: 'sui-error-message' },
						requiredError
					),
					this.props.description && _react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						this.props.description
					)
				)
			);
		}
	}]);

	return SuiTags;
}(_react.Component);

exports.default = SuiTags;

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),
/* 55 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 56 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(57);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 60 */
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object),
    nativeMax = Math.max;

/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign = createAssigner(function(object, source) {
  if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = assign;


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box", function() { return Box; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxBody", function() { return BoxBody; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxFooter", function() { return BoxFooter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxHeader", function() { return BoxHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxSection", function() { return BoxSection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxTitle", function() { return BoxTitle; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_styled_components__ = __webpack_require__(199);



function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n.sui-wrap && {\n\tdisplay: ", ";\n\t", "\n\t", "\n\tmargin: 0;\n\tpadding-top: ", "px;\n\tpadding-right: ", "px;\n\tpadding-bottom: ", "px;\n\tpadding-left: ", "px;\n\tborder: 0 solid #E6E6E6;\n\tborder-top-width: ", "px;\n\t", "\n\n\t", "\n\t", "\n\n\t@media ", " {\n\t\tpadding-top: ", "px;\n\t\tpadding-right: ", "px;\n\t\tpadding-bottom: ", "px;\n\t\tpadding-left: ", "px;\n\t}\n}\n"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n.sui-wrap && {\n\tmargin: 0;\n\tpadding-top: ", "px;\n\tpadding-right: ", "px;\n\tpadding-bottom: ", "px;\n\tpadding-left: ", "px;\n\tborder: 0 solid #E6E6E6;\n\tborder-top-width: ", "px;\n\tborder-bottom-width: ", "px;\n\ttext-align: ", ";\n\n\t@media ", " {\n\t\tpadding-top: ", "px;\n\t\tpadding-right: ", "px;\n\t\tpadding-bottom: ", "px;\n\t\tpadding-left: ", "px;\n\t}\n}\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n.sui-wrap && {\n\tdisplay: ", ";\n\t", "\n\t", "\n\tmargin: 0;\n\tpadding-top: ", "px;\n\tpadding-right: ", "px;\n\tpadding-bottom: ", "px;\n\tpadding-left: ", "px;\n\tborder: 0 solid #E6E6E6;\n\tborder-bottom-width: ", "px;\n\t", "\n\n\t", "\n\t", "\n\n\t@media ", " {\n\t\tpadding-top: ", "px;\n\t\tpadding-right: ", "px;\n\t\tpadding-bottom: ", "px;\n\t\tpadding-left: ", "px;\n\t}\n}\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

var utils = {
  gutter: 30,
  gutter_md: 20
};
var screen = {
  mobile: 480,
  tablet: 783,
  laptop: 1200,
  desktop: 1500
};
var device = {
  mobile: "(min-width: ".concat(screen.mobile, "px)"),
  tablet: "(min-width: ".concat(screen.tablet, "px)"),
  laptop: "(min-width: ".concat(screen.laptop, "px)"),
  desktop: "(min-width: ".concat(screen.desktop, "px)")
};
var Box = function Box(_ref) {
  var children = _ref.children,
      className = _ref.className,
      props = _objectWithoutProperties(_ref, ["children", "className"]);

  return /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("div", _extends({
    className: 'undefined' !== typeof className && '' !== className ? "sui-box ".concat(className) : 'sui-box'
  }, props), children);
};
var BoxTitle = function BoxTitle(_ref2) {
  var icon = _ref2.icon,
      tagLabel = _ref2.tagLabel,
      tagColor = _ref2.tagColor,
      tagSize = _ref2.tagSize,
      tagDesign = _ref2.tagDesign,
      className = _ref2.className,
      children = _ref2.children,
      props = _objectWithoutProperties(_ref2, ["icon", "tagLabel", "tagColor", "tagSize", "tagDesign", "className", "children"]);

  var tagClass = 'sui-tag';

  switch (tagColor) {
    case 'red':
    case 'yellow':
    case 'green':
    case 'blue':
    case 'purple':
      tagClass += ' sui-tag-' + tagColor;
      break;
  }

  switch (tagSize) {
    case 'sm':
    case 'small':
      tagClass += ' sui-tag-sm';
      break;
  }

  switch (tagDesign) {
    case 'outlined':
      tagClass += ' sui-tag-ghost';
      break;
  }

  return /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("h3", _extends({
    className: 'undefined' !== typeof className && '' !== className ? "sui-box-title ".concat(className) : 'sui-box-title'
  }, props), icon && "" !== icon && /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("span", {
    className: "sui-icon-".concat(icon, " sui-md"),
    "aria-hidden": "true"
  }), children, tagLabel && '' !== tagLabel && /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("span", {
    className: tagClass,
    style: {
      marginLeft: 10
    }
  }, tagLabel));
};
var Header = __WEBPACK_IMPORTED_MODULE_1_styled_components__["b" /* default */].div.attrs(function (props) {
  return {
    props: props
  };
})(_templateObject(), function (props) {
  return 'block' !== props.display ? 'flex' : 'block';
}, function (props) {
  return 'block' !== props.display && 'flex-flow: row wrap;';
}, function (props) {
  return 'block' !== props.display && ('left' === props.alignment || 'right' === props.alignment || 'center' === props.alignment) ? 'left' === props.alignment ? 'justify-content: flex-start;' : 'right' === props.alignment ? 'justify-content: flex-end;' : 'justify-content: center;' : 'justify-content: space-between;';
}, function (props) {
  return props.paddingTop || 0 === props.paddingTop ? props.paddingTop > 29 ? props.paddingTop - 10 : props.paddingTop : utils.gutter_md / 2;
}, function (props) {
  return props.paddingRight || 0 === props.paddingRight ? props.paddingRight > 29 ? props.paddingRight - 10 : props.paddingRight : utils.gutter_md;
}, function (props) {
  return props.paddingBottom || 0 === props.paddingBottom ? props.paddingBottom > 29 ? props.paddingBottom - 10 : props.paddingBottom : utils.gutter_md / 2;
}, function (props) {
  return props.paddingLeft || 0 === props.paddingLeft ? props.paddingLeft > 29 ? props.paddingLeft - 10 : props.paddingLeft : utils.gutter_md;
}, function (props) {
  return props.border || 0 === props.border ? props.border : 1;
}, function (props) {
  return 'block' === props.display && ('right' === props.alignment || 'center' === props.alignment) && 'text-align: ' + props.alignment + ';';
}, function (props) {
  return 'block' !== props.display && '> * { max-width: 100%; flex: 0 0 auto; }';
}, function (props) {
  return 'block' !== props.display && '> * + * { margin-left: 10px; }';
}, device.tablet, function (props) {
  return props.paddingTop || 0 === props.paddingTop ? props.paddingTop : utils.gutter / 2;
}, function (props) {
  return props.paddingRight || 0 === props.paddingRight ? props.paddingRight : utils.gutter;
}, function (props) {
  return props.paddingBottom || 0 === props.paddingBottom ? props.paddingBottom : utils.gutter / 2;
}, function (props) {
  return props.paddingLeft || 0 === props.paddingLeft ? props.paddingLeft : utils.gutter;
});
var BoxHeader = function BoxHeader(_ref3) {
  var title = _ref3.title,
      titleIcon = _ref3.titleIcon,
      tagLabel = _ref3.tagLabel,
      tagColor = _ref3.tagColor,
      tagSize = _ref3.tagSize,
      tagDesign = _ref3.tagDesign,
      className = _ref3.className,
      children = _ref3.children,
      props = _objectWithoutProperties(_ref3, ["title", "titleIcon", "tagLabel", "tagColor", "tagSize", "tagDesign", "className", "children"]);

  return /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Header, props, title && '' !== title && /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(BoxTitle, {
    icon: titleIcon,
    tagLabel: tagLabel,
    tagColor: tagColor,
    tagSize: tagSize,
    tagDesign: tagDesign
  }, title), children);
};
var Body = __WEBPACK_IMPORTED_MODULE_1_styled_components__["b" /* default */].div.attrs(function (props) {
  return {
    props: props
  };
})(_templateObject2(), function (props) {
  return props.paddingTop || 0 === props.paddingTop ? props.paddingTop > 29 ? props.paddingTop - 10 : props.paddingTop : utils.gutter_md;
}, function (props) {
  return props.paddingRight || 0 === props.paddingRight ? props.paddingRight > 29 ? props.paddingRight - 10 : props.paddingRight : utils.gutter_md;
}, function (props) {
  return props.paddingBottom || 0 === props.paddingBottom ? props.paddingBottom > 29 ? props.paddingBottom - 10 : props.paddingBottom : utils.gutter_md;
}, function (props) {
  return props.paddingLeft || 0 === props.paddingLeft ? props.paddingLeft > 29 ? props.paddingLeft - 10 : props.paddingLeft : utils.gutter_md;
}, function (props) {
  return props.borderTop || 0 === props.borderTop ? props.borderTop : 0;
}, function (props) {
  return props.borderBottom || 0 === props.borderBottom ? props.borderBottom : 0;
}, function (props) {
  return props.alignment || 'left';
}, device.tablet, function (props) {
  return props.paddingTop || 0 === props.paddingTop ? props.paddingTop : utils.gutter;
}, function (props) {
  return props.paddingRight || 0 === props.paddingRight ? props.paddingRight : utils.gutter;
}, function (props) {
  return props.paddingBottom || 0 === props.paddingBottom ? props.paddingBottom : utils.gutter;
}, function (props) {
  return props.paddingLeft || 0 === props.paddingLeft ? props.paddingLeft : utils.gutter;
});
var BoxBody = function BoxBody(_ref4) {
  var className = _ref4.className,
      children = _ref4.children,
      props = _objectWithoutProperties(_ref4, ["className", "children"]);

  return /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Body, _extends({
    className: className
  }, props), children);
};
var Footer = __WEBPACK_IMPORTED_MODULE_1_styled_components__["b" /* default */].div.attrs(function (props) {
  return {
    props: props
  };
})(_templateObject3(), function (props) {
  return 'block' !== props.display ? 'flex' : 'block';
}, function (props) {
  return 'block' !== props.display && 'flex-flow: row wrap;';
}, function (props) {
  return 'block' !== props.display && ('left' === props.alignment || 'right' === props.alignment || 'center' === props.alignment) ? 'left' === props.alignment ? 'justify-content: flex-start;' : 'right' === props.alignment ? 'justify-content: flex-end;' : 'justify-content: center;' : 'justify-content: space-between;';
}, function (props) {
  return props.paddingTop || 0 === props.paddingTop ? props.paddingTop > 29 ? props.paddingTop - 10 : props.paddingTop : utils.gutter_md;
}, function (props) {
  return props.paddingRight || 0 === props.paddingRight ? props.paddingRight > 29 ? props.paddingRight - 10 : props.paddingRight : utils.gutter_md;
}, function (props) {
  return props.paddingBottom || 0 === props.paddingBottom ? props.paddingBottom > 29 ? props.paddingBottom - 10 : props.paddingBottom : utils.gutter_md;
}, function (props) {
  return props.paddingLeft || 0 === props.paddingLeft ? props.paddingLeft > 29 ? props.paddingLeft - 10 : props.paddingLeft : utils.gutter_md;
}, function (props) {
  return props.border || 0 === props.border || '' === props.border ? props.border : 1;
}, function (props) {
  return 'block' === props.display && ('right' === props.alignment || 'center' === props.alignment) && 'text-align: ' + props.alignment + ';';
}, function (props) {
  return 'block' !== props.display && '> * { max-width: 100%; flex: 0 0 auto; }';
}, function (props) {
  return 'block' !== props.display && '> * + * { margin-left: 10px; }';
}, device.tablet, function (props) {
  return props.paddingTop || 0 === props.paddingTop ? props.paddingTop : utils.gutter;
}, function (props) {
  return props.paddingRight || 0 === props.paddingRight ? props.paddingRight : utils.gutter;
}, function (props) {
  return props.paddingBottom || 0 === props.paddingBottom ? props.paddingBottom : utils.gutter;
}, function (props) {
  return props.paddingLeft || 0 === props.paddingLeft ? props.paddingLeft : utils.gutter;
});
var BoxFooter = function BoxFooter(_ref5) {
  var className = _ref5.className,
      children = _ref5.children,
      props = _objectWithoutProperties(_ref5, ["className", "children"]);

  return /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Footer, _extends({
    className: className
  }, props), children);
};
var BoxSection = function BoxSection(_ref6) {
  var title = _ref6.title,
      description = _ref6.description,
      className = _ref6.className,
      children = _ref6.children,
      props = _objectWithoutProperties(_ref6, ["title", "description", "className", "children"]);

  return /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("div", _extends({
    className: 'undefined' !== typeof className && '' !== className ? "sui-box-settings-row ".concat(className) : 'sui-box-settings-row'
  }, props), (title && "" !== title || description && "" !== description) && /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("div", {
    className: "sui-box-settings-col-1"
  }, "" !== title && /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("h4", {
    className: "sui-settings-label"
  }, title), "" !== description && /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("p", {
    className: "sui-description"
  }, description)), /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("div", {
    className: "sui-box-settings-col-2"
  }, children));
};




/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Uploads = function (_Component) {
	_inherits(Uploads, _Component);

	function Uploads(props) {
		_classCallCheck(this, Uploads);

		return _possibleConstructorReturn(this, (Uploads.__proto__ || Object.getPrototypeOf(Uploads)).call(this, props));
	}

	_createClass(Uploads, [{
		key: 'clearImage',
		value: function clearImage() {
			// Check if we're on field settings
			if ('answer_image' === this.props.property) {
				var answer = Object.assign({}, this.props.answer);
				var property = this.props.property;

				answer[property] = '';
				answer[property + '_filename'] = '';
				answer[property + '_alt'] = '';

				this.props.actions.builderActions.updateAnswer(answer);
			} else if (typeof this.props.updateProperty === 'function') {
				this.props.updateProperty(this.props.property, '');
				this.props.updateProperty(this.props.property + '_filename', '');
				this.props.updateProperty(this.props.property + '_alt', '');
			} else {
				// Clear image
				this.props.actions.settingsActions.updateSetting(this.props.property, '');
				this.props.actions.settingsActions.updateSetting(this.props.property + '_filename', '');
				this.props.actions.settingsActions.updateSetting(this.props.property + '_alt', '');
			}
		}
	}, {
		key: 'openMedia',
		value: function openMedia() {
			var self = this;

			var media = wp.media({
				title: (0, _utils.translate)('Select image'),
				button: {
					text: (0, _utils.translate)('Select')
				},
				multiple: false
			}).on('select', function () {
				var imageUrl = void 0;
				var result = media.state().get('selection').first().toJSON();

				// We can have 3 types of image size: thumbnail, medium, large, else full image will be used
				if (!_.isUndefined(self.props.imageSize)) {
					if (self.props.imageSize === 'thumbnail') {
						imageUrl = result.sizes.thumbnail.url;
					} else if (self.props.imageSize === 'medium') {
						if (_.isUndefined(result.sizes.medium)) {
							imageUrl = result.sizes.full.url;
						} else {
							imageUrl = result.sizes.medium.url;
						}
					} else if (self.props.imageSize === 'large') {
						if (_.isUndefined(result.sizes.large)) {
							imageUrl = result.sizes.full.url;
						} else {
							imageUrl = result.sizes.large.url;
						}
					} else {
						imageUrl = result.sizes.full.url;
					}
				} else {
					// Fallback to full image
					imageUrl = result.url;
				}

				// Check if we're on field settings
				if (typeof self.props.updateProperty === 'function') {
					self.props.updateProperty(self.props.property, imageUrl);
					self.props.updateProperty(self.props.property + '_filename', result.filename);
					self.props.updateProperty(self.props.property + '_alt', result.alt);
				} else {
					self.props.actions.settingsActions.updateSetting(self.props.property, imageUrl);
					self.props.actions.settingsActions.updateSetting(self.props.property + '_filename', result.filename);
					self.props.actions.settingsActions.updateSetting(self.props.property + '_alt', result.alt);
				}
			});

			media.open();
		}
	}, {
		key: 'render',
		value: function render() {
			var value = _.isUndefined(this.props.settings[this.props.property]) ? this.props.defaultValue : this.props.settings[this.props.property];

			var hasValueClass = !_.isEmpty(value) ? 'sui-has_file' : '';

			var filename = _.isUndefined(this.props.settings[this.props.property + '_filename']) ? value : _.isEmpty(this.props.settings[this.props.property + '_filename']) && !_.isNull(value) ? value.replace(/^.*[\\\/]/, '') : this.props.settings[this.props.property + '_filename'];

			var fieldLabel = '';

			if (this.props.label) {
				fieldLabel = _react2.default.createElement(
					'label',
					{ className: 'sui-label' },
					this.props.label
				);
			}

			var fieldDescription = '';

			if (this.props.description) {
				fieldDescription = _react2.default.createElement(
					'span',
					{ className: 'sui-description' },
					this.props.description
				);
			}

			var preview = '';

			if ('image' === this.props.type) {
				var bgImage = '';

				if (value) {
					bgImage = 'url(' + value + ')';
				}

				preview = _react2.default.createElement(
					'div',
					{ className: 'sui-upload-image',
						'aria-hidden': 'true' },
					_react2.default.createElement('div', { className: 'sui-image-mask' }),
					_react2.default.createElement('div', { role: 'button', onClick: this.openMedia.bind(this),
						className: 'sui-image-preview',
						style: { backgroundImage: bgImage } })
				);
			}

			var fieldClass = this.props.fieldClass ? ' ' + this.props.fieldClass : '';

			return _react2.default.createElement(
				'div',
				{ className: 'sui-form-field' + fieldClass },
				fieldLabel,
				_react2.default.createElement(
					'div',
					{ className: 'sui-upload ' + hasValueClass },
					_react2.default.createElement('input', { type: 'file',
						value: '',
						readOnly: 'readonly' }),
					preview,
					_react2.default.createElement(
						'button',
						{ className: 'sui-upload-button', onClick: this.openMedia.bind(this) },
						_react2.default.createElement('i', { className: 'sui-icon-upload-cloud', 'aria-hidden': 'true' }),
						'image' === this.props.type ? '' + (0, _utils.translate)('Upload image') : '' + (0, _utils.translate)('Upload file')
					),
					_react2.default.createElement(
						'div',
						{ className: 'sui-upload-file' },
						_react2.default.createElement(
							'span',
							{ title: filename },
							filename
						),
						_react2.default.createElement(
							'button',
							{ className: 'sui-upload-button--remove', onClick: this.clearImage.bind(this) },
							_react2.default.createElement('i', { className: 'sui-icon-close', 'aria-hidden': 'true' }),
							_react2.default.createElement(
								'span',
								{ className: 'sui-screen-reader-text' },
								'image' === this.props.type ? '' + (0, _utils.translate)('Remove uploaded image') : '' + (0, _utils.translate)('Remove uploaded file')
							)
						)
					)
				),
				fieldDescription
			);
		}
	}]);

	return Uploads;
}(_react.Component);

exports.default = Uploads;

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return subscriptionShape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return storeShape; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_prop_types__);


var subscriptionShape = __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.shape({
  trySubscribe: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  tryUnsubscribe: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  notifyNestedSubs: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  isSubscribed: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired
});

var storeShape = __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.shape({
  subscribe: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  dispatch: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  getState: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired
});

/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (immutable) */ __webpack_exports__["a"] = connectAdvanced;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_hoist_non_react_statics__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_hoist_non_react_statics___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_hoist_non_react_statics__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_Subscription__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_PropTypes__ = __webpack_require__(68);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }








var hotReloadingVersion = 0;
var dummyState = {};
function noop() {}
function makeSelectorStateful(sourceSelector, store) {
  // wrap the selector in an object that tracks its results between runs.
  var selector = {
    run: function runComponentSelector(props) {
      try {
        var nextProps = sourceSelector(store.getState(), props);
        if (nextProps !== selector.props || selector.error) {
          selector.shouldComponentUpdate = true;
          selector.props = nextProps;
          selector.error = null;
        }
      } catch (error) {
        selector.shouldComponentUpdate = true;
        selector.error = error;
      }
    }
  };

  return selector;
}

function connectAdvanced(
/*
  selectorFactory is a func that is responsible for returning the selector function used to
  compute new props from state, props, and dispatch. For example:
     export default connectAdvanced((dispatch, options) => (state, props) => ({
      thing: state.things[props.thingId],
      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
    }))(YourComponent)
   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
  outside of their selector as an optimization. Options passed to connectAdvanced are passed to
  the selectorFactory, along with displayName and WrappedComponent, as the second argument.
   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
  props. Do not use connectAdvanced directly without memoizing results between calls to your
  selector, otherwise the Connect component will re-render on every state or props change.
*/
selectorFactory) {
  var _contextTypes, _childContextTypes;

  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$getDisplayName = _ref.getDisplayName,
      getDisplayName = _ref$getDisplayName === undefined ? function (name) {
    return 'ConnectAdvanced(' + name + ')';
  } : _ref$getDisplayName,
      _ref$methodName = _ref.methodName,
      methodName = _ref$methodName === undefined ? 'connectAdvanced' : _ref$methodName,
      _ref$renderCountProp = _ref.renderCountProp,
      renderCountProp = _ref$renderCountProp === undefined ? undefined : _ref$renderCountProp,
      _ref$shouldHandleStat = _ref.shouldHandleStateChanges,
      shouldHandleStateChanges = _ref$shouldHandleStat === undefined ? true : _ref$shouldHandleStat,
      _ref$storeKey = _ref.storeKey,
      storeKey = _ref$storeKey === undefined ? 'store' : _ref$storeKey,
      _ref$withRef = _ref.withRef,
      withRef = _ref$withRef === undefined ? false : _ref$withRef,
      connectOptions = _objectWithoutProperties(_ref, ['getDisplayName', 'methodName', 'renderCountProp', 'shouldHandleStateChanges', 'storeKey', 'withRef']);

  var subscriptionKey = storeKey + 'Subscription';
  var version = hotReloadingVersion++;

  var contextTypes = (_contextTypes = {}, _contextTypes[storeKey] = __WEBPACK_IMPORTED_MODULE_4__utils_PropTypes__["a" /* storeShape */], _contextTypes[subscriptionKey] = __WEBPACK_IMPORTED_MODULE_4__utils_PropTypes__["b" /* subscriptionShape */], _contextTypes);
  var childContextTypes = (_childContextTypes = {}, _childContextTypes[subscriptionKey] = __WEBPACK_IMPORTED_MODULE_4__utils_PropTypes__["b" /* subscriptionShape */], _childContextTypes);

  return function wrapWithConnect(WrappedComponent) {
    __WEBPACK_IMPORTED_MODULE_1_invariant___default()(typeof WrappedComponent == 'function', 'You must pass a component to the function returned by ' + (methodName + '. Instead received ' + JSON.stringify(WrappedComponent)));

    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';

    var displayName = getDisplayName(wrappedComponentName);

    var selectorFactoryOptions = _extends({}, connectOptions, {
      getDisplayName: getDisplayName,
      methodName: methodName,
      renderCountProp: renderCountProp,
      shouldHandleStateChanges: shouldHandleStateChanges,
      storeKey: storeKey,
      withRef: withRef,
      displayName: displayName,
      wrappedComponentName: wrappedComponentName,
      WrappedComponent: WrappedComponent
    });

    var Connect = function (_Component) {
      _inherits(Connect, _Component);

      function Connect(props, context) {
        _classCallCheck(this, Connect);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

        _this.version = version;
        _this.state = {};
        _this.renderCount = 0;
        _this.store = props[storeKey] || context[storeKey];
        _this.propsMode = Boolean(props[storeKey]);
        _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);

        __WEBPACK_IMPORTED_MODULE_1_invariant___default()(_this.store, 'Could not find "' + storeKey + '" in either the context or props of ' + ('"' + displayName + '". Either wrap the root component in a <Provider>, ') + ('or explicitly pass "' + storeKey + '" as a prop to "' + displayName + '".'));

        _this.initSelector();
        _this.initSubscription();
        return _this;
      }

      Connect.prototype.getChildContext = function getChildContext() {
        var _ref2;

        // If this component received store from props, its subscription should be transparent
        // to any descendants receiving store+subscription from context; it passes along
        // subscription passed to it. Otherwise, it shadows the parent subscription, which allows
        // Connect to control ordering of notifications to flow top-down.
        var subscription = this.propsMode ? null : this.subscription;
        return _ref2 = {}, _ref2[subscriptionKey] = subscription || this.context[subscriptionKey], _ref2;
      };

      Connect.prototype.componentDidMount = function componentDidMount() {
        if (!shouldHandleStateChanges) return;

        // componentWillMount fires during server side rendering, but componentDidMount and
        // componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.
        // Otherwise, unsubscription would never take place during SSR, causing a memory leak.
        // To handle the case where a child component may have triggered a state change by
        // dispatching an action in its componentWillMount, we have to re-run the select and maybe
        // re-render.
        this.subscription.trySubscribe();
        this.selector.run(this.props);
        if (this.selector.shouldComponentUpdate) this.forceUpdate();
      };

      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        this.selector.run(nextProps);
      };

      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
        return this.selector.shouldComponentUpdate;
      };

      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.subscription) this.subscription.tryUnsubscribe();
        this.subscription = null;
        this.notifyNestedSubs = noop;
        this.store = null;
        this.selector.run = noop;
        this.selector.shouldComponentUpdate = false;
      };

      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
        __WEBPACK_IMPORTED_MODULE_1_invariant___default()(withRef, 'To access the wrapped instance, you need to specify ' + ('{ withRef: true } in the options argument of the ' + methodName + '() call.'));
        return this.wrappedInstance;
      };

      Connect.prototype.setWrappedInstance = function setWrappedInstance(ref) {
        this.wrappedInstance = ref;
      };

      Connect.prototype.initSelector = function initSelector() {
        var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);
        this.selector = makeSelectorStateful(sourceSelector, this.store);
        this.selector.run(this.props);
      };

      Connect.prototype.initSubscription = function initSubscription() {
        if (!shouldHandleStateChanges) return;

        // parentSub's source should match where store came from: props vs. context. A component
        // connected to the store via props shouldn't use subscription from context, or vice versa.
        var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];
        this.subscription = new __WEBPACK_IMPORTED_MODULE_3__utils_Subscription__["a" /* default */](this.store, parentSub, this.onStateChange.bind(this));

        // `notifyNestedSubs` is duplicated to handle the case where the component is  unmounted in
        // the middle of the notification loop, where `this.subscription` will then be null. An
        // extra null check every change can be avoided by copying the method onto `this` and then
        // replacing it with a no-op on unmount. This can probably be avoided if Subscription's
        // listeners logic is changed to not call listeners that have been unsubscribed in the
        // middle of the notification loop.
        this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);
      };

      Connect.prototype.onStateChange = function onStateChange() {
        this.selector.run(this.props);

        if (!this.selector.shouldComponentUpdate) {
          this.notifyNestedSubs();
        } else {
          this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;
          this.setState(dummyState);
        }
      };

      Connect.prototype.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate() {
        // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it
        // needs to notify nested subs. Once called, it unimplements itself until further state
        // changes occur. Doing it this way vs having a permanent `componentDidUpdate` that does
        // a boolean check every time avoids an extra method call most of the time, resulting
        // in some perf boost.
        this.componentDidUpdate = undefined;
        this.notifyNestedSubs();
      };

      Connect.prototype.isSubscribed = function isSubscribed() {
        return Boolean(this.subscription) && this.subscription.isSubscribed();
      };

      Connect.prototype.addExtraProps = function addExtraProps(props) {
        if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props;
        // make a shallow copy so that fields added don't leak to the original selector.
        // this is especially important for 'ref' since that's a reference back to the component
        // instance. a singleton memoized selector would then be holding a reference to the
        // instance, preventing the instance from being garbage collected, and that would be bad
        var withExtras = _extends({}, props);
        if (withRef) withExtras.ref = this.setWrappedInstance;
        if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;
        if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription;
        return withExtras;
      };

      Connect.prototype.render = function render() {
        var selector = this.selector;
        selector.shouldComponentUpdate = false;

        if (selector.error) {
          throw selector.error;
        } else {
          return Object(__WEBPACK_IMPORTED_MODULE_2_react__["createElement"])(WrappedComponent, this.addExtraProps(selector.props));
        }
      };

      return Connect;
    }(__WEBPACK_IMPORTED_MODULE_2_react__["Component"]);

    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = displayName;
    Connect.childContextTypes = childContextTypes;
    Connect.contextTypes = contextTypes;
    Connect.propTypes = contextTypes;

    if (process.env.NODE_ENV !== 'production') {
      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
        var _this2 = this;

        // We are hot reloading!
        if (this.version !== version) {
          this.version = version;
          this.initSelector();

          // If any connected descendants don't hot reload (and resubscribe in the process), their
          // listeners will be lost when we unsubscribe. Unfortunately, by copying over all
          // listeners, this does mean that the old versions of connected descendants will still be
          // notified of state changes; however, their onStateChange function is a no-op so this
          // isn't a huge deal.
          var oldListeners = [];

          if (this.subscription) {
            oldListeners = this.subscription.listeners.get();
            this.subscription.tryUnsubscribe();
          }
          this.initSubscription();
          if (shouldHandleStateChanges) {
            this.subscription.trySubscribe();
            oldListeners.forEach(function (listener) {
              return _this2.subscription.listeners.subscribe(listener);
            });
          }
        }
      };
    }

    return __WEBPACK_IMPORTED_MODULE_0_hoist_non_react_statics___default()(Connect, WrappedComponent);
  };
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)))

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try { // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
}

module.exports = hoistNonReactStatics;


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (immutable) */ __webpack_exports__["a"] = wrapMapToPropsConstant;
/* unused harmony export getDependsOnOwnProps */
/* harmony export (immutable) */ __webpack_exports__["b"] = wrapMapToPropsFunc;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_verifyPlainObject__ = __webpack_require__(72);


function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant = getConstant(dispatch, options);

    function constantSelector() {
      return constant;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}

// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
// whether mapToProps needs to be invoked when props have changed.
// 
// A length of one signals that mapToProps does not depend on props from the parent component.
// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
// therefore not reporting its length accurately..
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}

// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
// this function wraps mapToProps in a proxy function which does several things:
// 
//  * Detects whether the mapToProps function being called depends on props, which
//    is used by selectorFactory to decide if it should reinvoke on props changes.
//    
//  * On first call, handles mapToProps if returns another function, and treats that
//    new function as the true mapToProps for subsequent calls.
//    
//  * On first call, verifies the first result is a plain object, in order to warn
//    the developer that their mapToProps function is not returning a valid result.
//    
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref) {
    var displayName = _ref.displayName;

    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    };

    // allow detectFactoryAndVerify to get ownProps
    proxy.dependsOnOwnProps = true;

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);

      if (typeof props === 'function') {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }

      if (process.env.NODE_ENV !== 'production') Object(__WEBPACK_IMPORTED_MODULE_0__utils_verifyPlainObject__["a" /* default */])(props, displayName, methodName);

      return props;
    };

    return proxy;
  };
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)))

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = verifyPlainObject;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__warning__ = __webpack_require__(45);



function verifyPlainObject(value, displayName, methodName) {
  if (!Object(__WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__["a" /* default */])(value)) {
    Object(__WEBPACK_IMPORTED_MODULE_1__warning__["a" /* default */])(methodName + '() in ' + displayName + ' must return a plain object. Instead received ' + value + '.');
  }
}

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(128);


/** Built-in value references. */
var Symbol = __WEBPACK_IMPORTED_MODULE_0__root_js__["a" /* default */].Symbol;

/* harmony default export */ __webpack_exports__["a"] = (Symbol);


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return canUseDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return removeEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getConfirmation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return supportsHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return supportsPopStateOnHashChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return supportsGoWithoutReloadUsingHash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isExtraneousPopstateEvent; });
var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history__ = __webpack_require__(24);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var isModifiedEvent = function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
};

/**
 * The public API for rendering a history-aware <a>.
 */

var Link = function (_React$Component) {
  _inherits(Link, _React$Component);

  function Link() {
    var _temp, _this, _ret;

    _classCallCheck(this, Link);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {
      if (_this.props.onClick) _this.props.onClick(event);

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && // ignore everything but left clicks
      !_this.props.target && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();

          var history = _this.context.router.history;
          var _this$props = _this.props,
              replace = _this$props.replace,
              to = _this$props.to;


          if (replace) {
            history.replace(to);
          } else {
            history.push(to);
          }
        }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Link.prototype.render = function render() {
    var _props = this.props,
        replace = _props.replace,
        to = _props.to,
        innerRef = _props.innerRef,
        props = _objectWithoutProperties(_props, ["replace", "to", "innerRef"]); // eslint-disable-line no-unused-vars

    __WEBPACK_IMPORTED_MODULE_2_invariant___default()(this.context.router, "You should not use <Link> outside a <Router>");

    __WEBPACK_IMPORTED_MODULE_2_invariant___default()(to !== undefined, 'You must specify the "to" property');

    var history = this.context.router.history;

    var location = typeof to === "string" ? Object(__WEBPACK_IMPORTED_MODULE_3_history__["c" /* createLocation */])(to, null, null, history.location) : to;

    var href = history.createHref(location);
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("a", _extends({}, props, { onClick: this.handleClick, href: href, ref: innerRef }));
  };

  return Link;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Link.propTypes = {
  onClick: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  target: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  replace: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  to: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object]).isRequired,
  innerRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func])
};
Link.defaultProps = {
  replace: false
};
Link.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    history: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
      push: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
      replace: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
      createHref: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired
    }).isRequired
  }).isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Link);

/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Route__ = __webpack_require__(77);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Route__["a" /* default */]);

/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__matchPath__ = __webpack_require__(49);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var isEmptyChildren = function isEmptyChildren(children) {
  return __WEBPACK_IMPORTED_MODULE_2_react___default.a.Children.count(children) === 0;
};

/**
 * The public API for matching a single path and rendering.
 */

var Route = function (_React$Component) {
  _inherits(Route, _React$Component);

  function Route() {
    var _temp, _this, _ret;

    _classCallCheck(this, Route);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props, _this.context.router)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Route.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        route: {
          location: this.props.location || this.context.router.route.location,
          match: this.state.match
        }
      })
    };
  };

  Route.prototype.computeMatch = function computeMatch(_ref, router) {
    var computedMatch = _ref.computedMatch,
        location = _ref.location,
        path = _ref.path,
        strict = _ref.strict,
        exact = _ref.exact,
        sensitive = _ref.sensitive;

    if (computedMatch) return computedMatch; // <Switch> already computed the match for us

    __WEBPACK_IMPORTED_MODULE_1_invariant___default()(router, "You should not use <Route> or withRouter() outside a <Router>");

    var route = router.route;

    var pathname = (location || route.location).pathname;

    return Object(__WEBPACK_IMPORTED_MODULE_4__matchPath__["a" /* default */])(pathname, { path: path, strict: strict, exact: exact, sensitive: sensitive }, route.match);
  };

  Route.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(this.props.component && this.props.render), "You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored");

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(this.props.component && this.props.children && !isEmptyChildren(this.props.children)), "You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored");

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(this.props.render && this.props.children && !isEmptyChildren(this.props.children)), "You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored");
  };

  Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');

    this.setState({
      match: this.computeMatch(nextProps, nextContext.router)
    });
  };

  Route.prototype.render = function render() {
    var match = this.state.match;
    var _props = this.props,
        children = _props.children,
        component = _props.component,
        render = _props.render;
    var _context$router = this.context.router,
        history = _context$router.history,
        route = _context$router.route,
        staticContext = _context$router.staticContext;

    var location = this.props.location || route.location;
    var props = { match: match, location: location, history: history, staticContext: staticContext };

    if (component) return match ? __WEBPACK_IMPORTED_MODULE_2_react___default.a.createElement(component, props) : null;

    if (render) return match ? render(props) : null;

    if (typeof children === "function") return children(props);

    if (children && !isEmptyChildren(children)) return __WEBPACK_IMPORTED_MODULE_2_react___default.a.Children.only(children);

    return null;
  };

  return Route;
}(__WEBPACK_IMPORTED_MODULE_2_react___default.a.Component);

Route.propTypes = {
  computedMatch: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object, // private, from <Switch>
  path: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.string,
  exact: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool,
  strict: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool,
  sensitive: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool,
  component: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.func,
  render: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.func,
  children: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.func, __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.node]),
  location: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object
};
Route.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.shape({
    history: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired,
    route: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired,
    staticContext: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object
  })
};
Route.childContextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Route);

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var isarray = __webpack_require__(149)

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = options && options.delimiter || '/'
  var res

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      continue
    }

    var next = str[index]
    var prefix = res[2]
    var name = res[3]
    var capture = res[4]
    var group = res[5]
    var modifier = res[6]
    var asterisk = res[7]

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
    }

    var partial = prefix != null && next != null && next !== prefix
    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var delimiter = res[2] || defaultDelimiter
    var pattern = capture || group

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    })
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index)
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path)
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')
    }
  }

  return function (obj, opts) {
    var path = ''
    var data = obj || {}
    var options = opts || {}
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token

        continue
      }

      var value = data[token.name]
      var segment

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j])

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      })
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var route = ''

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
    } else {
      var prefix = escapeString(token.prefix)
      var capture = '(?:' + token.pattern + ')'

      keys.push(token)

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*'
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?'
        } else {
          capture = prefix + '(' + capture + ')?'
        }
      } else {
        capture = prefix + '(' + capture + ')'
      }

      route += capture
    }
  }

  var delimiter = escapeString(options.delimiter || '/')
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
  }

  if (end) {
    route += '$'
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}


/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path_to_regexp__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path_to_regexp___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_path_to_regexp__);


var patternCache = {};
var cacheLimit = 10000;
var cacheCount = 0;

var compileGenerator = function compileGenerator(pattern) {
  var cacheKey = pattern;
  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});

  if (cache[pattern]) return cache[pattern];

  var compiledGenerator = __WEBPACK_IMPORTED_MODULE_0_path_to_regexp___default.a.compile(pattern);

  if (cacheCount < cacheLimit) {
    cache[pattern] = compiledGenerator;
    cacheCount++;
  }

  return compiledGenerator;
};

/**
 * Public API for generating a URL pathname from a pattern and parameters.
 */
var generatePath = function generatePath() {
  var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "/";
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (pattern === "/") {
    return pattern;
  }
  var generator = compileGenerator(pattern);
  return generator(params, { pretty: true });
};

/* harmony default export */ __webpack_exports__["a"] = (generatePath);

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(14);
var settle = __webpack_require__(166);
var buildURL = __webpack_require__(168);
var parseHeaders = __webpack_require__(169);
var isURLSameOrigin = __webpack_require__(170);
var createError = __webpack_require__(82);
var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(171);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if (process.env.NODE_ENV !== 'test' &&
        typeof window !== 'undefined' &&
        window.XDomainRequest && !('withCredentials' in request) &&
        !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || (request.readyState !== 4 && !xDomain)) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(172);

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(167);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    var obj;

    while (queue.length) {
        var item = queue.pop();
        obj = item.obj[item.prop];

        if (Array.isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }

    return obj;
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (typeof target === 'object') {
            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                if (target[i] && typeof target[i] === 'object') {
                    target[i] = merge(target[i], item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};

var encode = function encode(str) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    return compactQueue(queue);
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (obj === null || typeof obj === 'undefined') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};


/***/ }),
/* 87 */,
/* 88 */,
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.renderBlock = renderBlock;

var _reactDom = __webpack_require__(23);

var _client = __webpack_require__(90);

var _semver = __webpack_require__(91);

var _semver2 = _interopRequireDefault(_semver);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * render Block
 **/
function renderBlock(containerId, element) {
	var container = document.getElementById(containerId);

	// If container is hidden in PHP.
	if (_.isNull(container)) {
		return;
	}

	if (_semver2.default.gte(_reactDom.version, '18.0.0')) {
		// React 18 or higher.
		var root = (0, _client.createRoot)(container);
		root.render(element);
	} else {
		(0, _reactDom.render)(element, container);
	}
}

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var m = __webpack_require__(23);
if (process.env.NODE_ENV === 'production') {
  exports.createRoot = m.createRoot;
  exports.hydrateRoot = m.hydrateRoot;
} else {
  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  exports.createRoot = function(c, o) {
    i.usingClientEntryPoint = true;
    try {
      return m.createRoot(c, o);
    } finally {
      i.usingClientEntryPoint = false;
    }
  };
  exports.hydrateRoot = function(c, h, o) {
    i.usingClientEntryPoint = true;
    try {
      return m.hydrateRoot(c, h, o);
    } finally {
      i.usingClientEntryPoint = false;
    }
  };
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = SemVer;

// The debug function is excluded entirely from the minified version.
/* nomin */ var debug;
/* nomin */ if (typeof process === 'object' &&
    /* nomin */ process.env &&
    /* nomin */ process.env.NODE_DEBUG &&
    /* nomin */ /\bsemver\b/i.test(process.env.NODE_DEBUG))
  /* nomin */ debug = function() {
    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);
    /* nomin */ args.unshift('SEMVER');
    /* nomin */ console.log.apply(console, args);
    /* nomin */ };
/* nomin */ else
  /* nomin */ debug = function() {};

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0';

var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16;

// The actual regexps go on exports.re
var re = exports.re = [];
var src = exports.src = [];
var R = 0;

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';


// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';


// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')';

var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')';

var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')';


// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';


// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?';

src[FULL] = '^' + FULLPLAIN + '$';

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?';

var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';

var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)';

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?';

var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?';

var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++;
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])';

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';

var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';

var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++;
src[LONECARET] = '(?:\\^)';

var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';

var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';


// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3';


// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$';

var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$';

// Star ranges basically just allow anything at all.
var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*';

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i]);
  if (!re[i])
    re[i] = new RegExp(src[i]);
}

exports.parse = parse;
function parse(version, loose) {
  if (version instanceof SemVer)
    return version;

  if (typeof version !== 'string')
    return null;

  if (version.length > MAX_LENGTH)
    return null;

  var r = loose ? re[LOOSE] : re[FULL];
  if (!r.test(version))
    return null;

  try {
    return new SemVer(version, loose);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;
function valid(version, loose) {
  var v = parse(version, loose);
  return v ? v.version : null;
}


exports.clean = clean;
function clean(version, loose) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, loose) {
  if (version instanceof SemVer) {
    if (version.loose === loose)
      return version;
    else
      version = version.version;
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH)
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')

  if (!(this instanceof SemVer))
    return new SemVer(version, loose);

  debug('SemVer', version, loose);
  this.loose = loose;
  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);

  if (!m)
    throw new TypeError('Invalid Version: ' + version);

  this.raw = version;

  // these are actually numbers
  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0)
    throw new TypeError('Invalid major version')

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
    throw new TypeError('Invalid minor version')

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
    throw new TypeError('Invalid patch version')

  // numberify any prerelease numeric ids
  if (!m[4])
    this.prerelease = [];
  else
    this.prerelease = m[4].split('.').map(function(id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;
        if (num >= 0 && num < MAX_SAFE_INTEGER)
          return num;
      }
      return id;
    });

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function() {
  this.version = this.major + '.' + this.minor + '.' + this.patch;
  if (this.prerelease.length)
    this.version += '-' + this.prerelease.join('.');
  return this.version;
};

SemVer.prototype.toString = function() {
  return this.version;
};

SemVer.prototype.compare = function(other) {
  debug('SemVer.compare', this.version, this.loose, other);
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length)
    return -1;
  else if (!this.prerelease.length && other.prerelease.length)
    return 1;
  else if (!this.prerelease.length && !other.prerelease.length)
    return 0;

  var i = 0;
  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);
    if (a === undefined && b === undefined)
      return 0;
    else if (b === undefined)
      return 1;
    else if (a === undefined)
      return -1;
    else if (a === b)
      continue;
    else
      return compareIdentifiers(a, b);
  } while (++i);
};

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function(release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;
    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0)
        this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
        this.major++;
      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0)
        this.minor++;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0)
        this.patch++;
      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0)
        this.prerelease = [0];
      else {
        var i = this.prerelease.length;
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }
        if (i === -1) // didn't increment anything
          this.prerelease.push(0);
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1]))
            this.prerelease = [identifier, 0];
        } else
          this.prerelease = [identifier, 0];
      }
      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }
  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;
function inc(version, release, loose, identifier) {
  if (typeof(loose) === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;
function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    if (v1.prerelease.length || v2.prerelease.length) {
      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return 'pre'+key;
          }
        }
      }
      return 'prerelease';
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return key;
        }
      }
    }
  }
}

exports.compareIdentifiers = compareIdentifiers;

var numeric = /^[0-9]+$/;
function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return (anum && !bnum) ? -1 :
         (bnum && !anum) ? 1 :
         a < b ? -1 :
         a > b ? 1 :
         0;
}

exports.rcompareIdentifiers = rcompareIdentifiers;
function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;
function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;
function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;
function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;
function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;
function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;
function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;
function sort(list, loose) {
  return list.sort(function(a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;
function rsort(list, loose) {
  return list.sort(function(a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;
function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;
function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;
function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;
function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;
function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;
function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;
function cmp(a, op, b, loose) {
  var ret;
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a === b;
      break;
    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a !== b;
      break;
    case '': case '=': case '==': ret = eq(a, b, loose); break;
    case '!=': ret = neq(a, b, loose); break;
    case '>': ret = gt(a, b, loose); break;
    case '>=': ret = gte(a, b, loose); break;
    case '<': ret = lt(a, b, loose); break;
    case '<=': ret = lte(a, b, loose); break;
    default: throw new TypeError('Invalid operator: ' + op);
  }
  return ret;
}

exports.Comparator = Comparator;
function Comparator(comp, loose) {
  if (comp instanceof Comparator) {
    if (comp.loose === loose)
      return comp;
    else
      comp = comp.value;
  }

  if (!(this instanceof Comparator))
    return new Comparator(comp, loose);

  debug('comparator', comp, loose);
  this.loose = loose;
  this.parse(comp);

  if (this.semver === ANY)
    this.value = '';
  else
    this.value = this.operator + this.semver.version;

  debug('comp', this);
}

var ANY = {};
Comparator.prototype.parse = function(comp) {
  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m)
    throw new TypeError('Invalid comparator: ' + comp);

  this.operator = m[1];
  if (this.operator === '=')
    this.operator = '';

  // if it literally is just '>' or '' then allow anything.
  if (!m[2])
    this.semver = ANY;
  else
    this.semver = new SemVer(m[2], this.loose);
};

Comparator.prototype.toString = function() {
  return this.value;
};

Comparator.prototype.test = function(version) {
  debug('Comparator.test', version, this.loose);

  if (this.semver === ANY)
    return true;

  if (typeof version === 'string')
    version = new SemVer(version, this.loose);

  return cmp(version, this.operator, this.semver, this.loose);
};

Comparator.prototype.intersects = function(comp, loose) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  var rangeTmp;

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, loose);
    return satisfies(this.value, rangeTmp, loose);
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, loose);
    return satisfies(comp.semver, rangeTmp, loose);
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, loose) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'));
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, loose) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'));

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};


exports.Range = Range;
function Range(range, loose) {
  if (range instanceof Range) {
    if (range.loose === loose) {
      return range;
    } else {
      return new Range(range.raw, loose);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, loose);
  }

  if (!(this instanceof Range))
    return new Range(range, loose);

  this.loose = loose;

  // First, split based on boolean or ||
  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function(range) {
    return this.parseRange(range.trim());
  }, this).filter(function(c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function() {
  this.range = this.set.map(function(comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function() {
  return this.range;
};

Range.prototype.parseRange = function(range) {
  var loose = this.loose;
  range = range.trim();
  debug('range', range, loose);
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range);
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[COMPARATORTRIM]);

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace);

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace);

  // normalize spaces
  range = range.split(/\s+/).join(' ');

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function(comp) {
    return parseComparator(comp, loose);
  }).join(' ').split(/\s+/);
  if (this.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function(comp) {
      return !!comp.match(compRe);
    });
  }
  set = set.map(function(comp) {
    return new Comparator(comp, loose);
  });

  return set;
};

Range.prototype.intersects = function(range, loose) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function(thisComparators) {
    return thisComparators.every(function(thisComparator) {
      return range.set.some(function(rangeComparators) {
        return rangeComparators.every(function(rangeComparator) {
          return thisComparator.intersects(rangeComparator, loose);
        });
      });
    });
  });
};

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators;
function toComparators(range, loose) {
  return new Range(range, loose).set.map(function(comp) {
    return comp.map(function(c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator(comp, loose) {
  debug('comp', comp);
  comp = replaceCarets(comp, loose);
  debug('caret', comp);
  comp = replaceTildes(comp, loose);
  debug('tildes', comp);
  comp = replaceXRanges(comp, loose);
  debug('xrange', comp);
  comp = replaceStars(comp, loose);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes(comp, loose) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceTilde(comp, loose);
  }).join(' ');
}

function replaceTilde(comp, loose) {
  var r = loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p))
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    else if (pr) {
      debug('replaceTilde pr', pr);
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      ret = '>=' + M + '.' + m + '.' + p + pr +
            ' <' + M + '.' + (+m + 1) + '.0';
    } else
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0';

    debug('tilde return', ret);
    return ret;
  });
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets(comp, loose) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceCaret(comp, loose);
  }).join(' ');
}

function replaceCaret(comp, loose) {
  debug('caret', comp, loose);
  var r = loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p)) {
      if (M === '0')
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      else
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
    } else if (pr) {
      debug('replaceCaret pr', pr);
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p + pr +
              ' <' + (+M + 1) + '.0.0';
    } else {
      debug('no pr');
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0';
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, loose) {
  debug('replaceXRanges', comp, loose);
  return comp.split(/\s+/).map(function(comp) {
    return replaceXRange(comp, loose);
  }).join(' ');
}

function replaceXRange(comp, loose) {
  comp = comp.trim();
  var r = loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX)
      gtlt = '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // replace X with 0
      if (xm)
        m = 0;
      if (xp)
        p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else if (xp) {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';
        if (xm)
          M = +M + 1;
        else
          m = +m + 1;
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    debug('xRange return', ret);

    return ret;
  });
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars(comp, loose) {
  debug('replaceStars', comp, loose);
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '');
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace($0,
                       from, fM, fm, fp, fpr, fb,
                       to, tM, tm, tp, tpr, tb) {

  if (isX(fM))
    from = '';
  else if (isX(fm))
    from = '>=' + fM + '.0.0';
  else if (isX(fp))
    from = '>=' + fM + '.' + fm + '.0';
  else
    from = '>=' + from;

  if (isX(tM))
    to = '';
  else if (isX(tm))
    to = '<' + (+tM + 1) + '.0.0';
  else if (isX(tp))
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  else if (tpr)
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  else
    to = '<=' + to;

  return (from + ' ' + to).trim();
}


// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function(version) {
  if (!version)
    return false;

  if (typeof version === 'string')
    version = new SemVer(version, this.loose);

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version))
      return true;
  }
  return false;
};

function testSet(set, version) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version))
      return false;
  }

  if (version.prerelease.length) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (var i = 0; i < set.length; i++) {
      debug(set[i].semver);
      if (set[i].semver === ANY)
        continue;

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch)
          return true;
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false;
  }

  return true;
}

exports.satisfies = satisfies;
function satisfies(version, range, loose) {
  try {
    range = new Range(range, loose);
  } catch (er) {
    return false;
  }
  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;
function maxSatisfying(versions, range, loose) {
  var max = null;
  var maxSV = null;
  try {
    var rangeObj = new Range(range, loose);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) { // satisfies(v, range, loose)
      if (!max || maxSV.compare(v) === -1) { // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, loose);
      }
    }
  })
  return max;
}

exports.minSatisfying = minSatisfying;
function minSatisfying(versions, range, loose) {
  var min = null;
  var minSV = null;
  try {
    var rangeObj = new Range(range, loose);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) { // satisfies(v, range, loose)
      if (!min || minSV.compare(v) === 1) { // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, loose);
      }
    }
  })
  return min;
}

exports.validRange = validRange;
function validRange(range, loose) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, loose).range || '*';
  } catch (er) {
    return null;
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr;
function ltr(version, range, loose) {
  return outside(version, range, '<', loose);
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr;
function gtr(version, range, loose) {
  return outside(version, range, '>', loose);
}

exports.outside = outside;
function outside(version, range, hilo, loose) {
  version = new SemVer(version, loose);
  range = new Range(range, loose);

  var gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, loose)) {
    return false;
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];

    var high = null;
    var low = null;

    comparators.forEach(function(comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, loose)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, loose)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
}

exports.prerelease = prerelease;
function prerelease(version, loose) {
  var parsed = parse(version, loose);
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;
}

exports.intersects = intersects;
function intersects(r1, r2, loose) {
  r1 = new Range(r1, loose)
  r2 = new Range(r2, loose)
  return r1.intersects(r2)
}

exports.coerce = coerce;
function coerce(version) {
  if (version instanceof SemVer)
    return version;

  if (typeof version !== 'string')
    return null;

  var match = version.match(re[COERCE]);

  if (match == null)
    return null;

  return parse((match[1] || '0') + '.' + (match[2] || '0') + '.' + (match[3] || '0')); 
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * External dependencies
 */
var debug = __webpack_require__( 93 )( 'i18n-wp-plugin' ),
	Jed = __webpack_require__( 96 ),
	sha1 = __webpack_require__( 97 ),
	EventEmitter = __webpack_require__( 56 ).EventEmitter,
	interpolateComponents = __webpack_require__( 100 ).default,
	LRU = __webpack_require__( 103 ),
	assign = __webpack_require__( 60 );

/**
 * Internal dependencies
 */
var numberFormatPHPJS = __webpack_require__( 104 );

/**
 * Constants
 */
var decimal_point_translation_key = 'number_format_decimals',
	thousands_sep_translation_key = 'number_format_thousands_sep';

var translationLookup = [
	// By default don't modify the options when looking up translations.
	function( options ) {
		return options;
	}
];

var hashCache = {};

// raise a console warning
function warn() {
	if ( ! I18N.throwErrors ) {
		return;
	}
	if ( 'undefined' !== typeof window && window.console && window.console.warn ) {
		window.console.warn.apply( window.console, arguments );
	}
}

// turns Function.arguments into an array
function simpleArguments( args ) {
	return Array.prototype.slice.call( args );
}

/**
 * Coerce the possible arguments and normalize to a single object
 * @param  {arguments} args - arguments passed in from `translate()`
 * @return {object}         - a single object describing translation needs
 */
function normalizeTranslateArguments( args ) {
	var original = args[ 0 ],
		options = {},
		i;

	// warn about older deprecated syntax
	if ( typeof original !== 'string' || args.length > 3 || ( args.length > 2 && typeof args[ 1 ] === 'object' && typeof args[ 2 ] === 'object' ) ) {
		warn( 'Deprecated Invocation: `translate()` accepts ( string, [string], [object] ). These arguments passed:', simpleArguments( args ), '. See https://github.com/pentatonicfunk/i18n-wp-plugin#translate-method' );
	}
	if ( args.length === 2 && typeof original === 'string' && typeof args[ 1 ] === 'string' ) {
		warn( 'Invalid Invocation: `translate()` requires an options object for plural translations, but passed:', simpleArguments( args ) );
	}

	// options could be in position 0, 1, or 2
	// sending options as the first object is deprecated and will raise a warning
	for ( i = 0; i < args.length; i++ ) {
		if ( typeof args[ i ] === 'object' ) {
			options = args[ i ];
		}
	}

	// `original` can be passed as first parameter or as part of the options object
	// though passing original as part of the options is a deprecated approach and will be removed
	if ( typeof original === 'string' ) {
		options.original = original;
	} else if ( typeof options.original === 'object' ) {
		options.plural = options.original.plural;
		options.count = options.original.count;
		options.original = options.original.single;
	}
	if ( typeof args[ 1 ] === 'string' ) {
		options.plural = args[ 1 ];
	}

	if ( typeof options.original === 'undefined' ) {
		throw new Error( 'Translate called without a `string` value as first argument.' );
	}

	return options;
}

/**
 * Pull the right set of arguments for the Jed method
 * @param  {string} jedMethod Name of jed gettext-style method. [See docs](http://slexaxton.github.io/Jed/)
 * @param  {[object]} props     properties passed into `translate()` method
 * @return {[array]}           array of properties to pass into gettext-style method
 */
function getJedArgs( jedMethod, props ) {
	switch ( jedMethod ) {
		case 'gettext':
			return [ props.original ];
		case 'ngettext':
			return [ props.original, props.plural, props.count ];
		case 'npgettext':
			return [ props.context, props.original, props.plural, props.count ];
		case 'pgettext':
			return [ props.context, props.original ];
	}

	return [];
}

/**
 * Takes translate options object and coerces to a Jed request to retrieve translation
 * @param  {object} jed     - jed data object
 * @param  {object} options - object describing translation
 * @return {string}         - the returned translation from Jed
 */
function getTranslationFromJed( jed, options ) {
	var jedMethod = 'gettext',
		jedArgs;

	if ( options.context ) {
		jedMethod = 'p' + jedMethod;
	}

	if ( typeof options.original === 'string' && typeof options.plural === 'string' ) {
		jedMethod = 'n' + jedMethod;
	}

	jedArgs = getJedArgs( jedMethod, options );

	return jed[ jedMethod ].apply( jed, jedArgs );
}

function getTranslation( i18n, options ) {
	var i, lookup;

	for ( i = translationLookup.length - 1; i >= 0; i-- ) {
		lookup = translationLookup[ i ]( assign( {}, options ) );
		// Only get the translation from jed if it exists.
		if ( i18n.state.locale[ lookup.original ] ) {
			return getTranslationFromJed( i18n.state.jed, lookup );
		}
	}

	return null;
}


function I18N() {
	if( ! ( this instanceof I18N ) ) {
		return new I18N();
	}
	this.defaultLocaleSlug = 'en';
	this.state = {
		numberFormatSettings: {},
		jed: undefined,
		locale: undefined,
		localeSlug: undefined,
		translations: LRU( { max: 100 } )
	};
	this.componentUpdateHooks = [];
	this.translateHooks = [];
	this.stateObserver = new EventEmitter();
	// Because the higher-order component can wrap a ton of React components,
	// we need to bump the number of listeners to infinity and beyond
	// FIXME: still valid?
	this.stateObserver.setMaxListeners( 0 );
	// default configuration
	this.configure();
}

I18N.throwErrors = false;

/**
 * Formats numbers using locale settings and/or passed options
 * @param  {String|Number|Int}  number to format (required)
 * @param  {Int|object} options  Number of decimal places or options object (optional)
 * @return {string}         Formatted number as string
 */
I18N.prototype.numberFormat = function( number ) {
	var options = arguments[ 1 ] || {},
		decimals = ( typeof options === 'number' ) ? options : options.decimals || 0,
		decPoint = options.decPoint || this.state.numberFormatSettings.decimal_point || '.',
		thousandsSep = options.thousandsSep || this.state.numberFormatSettings.thousands_sep || ',';

	return numberFormatPHPJS( number, decimals, decPoint, thousandsSep );
};

I18N.prototype.configure = function( options ) {
	assign( this, options || {} );
	this.setLocale();
};

I18N.prototype.setLocale = function( localeData ) {
	if ( localeData && localeData[ '' ] && localeData[ '' ][ 'key-hash' ] ) {
		var hashLength, minHashLength, maxHashLength, keyHash = localeData[ '' ][ 'key-hash' ];

		var transform = function( string, hashLength ) {
			const lookupPrefix = hashLength === false ? '' : String( hashLength );
			if ( typeof hashCache[ lookupPrefix + string ] !== 'undefined' ) {
				return hashCache[ lookupPrefix + string ];
			}
			var hash = sha1().update( string ).digest('hex');

			if ( hashLength ) {
				return hashCache[ lookupPrefix + string ] = hash.substr( 0, hashLength );
			}

			return hashCache[ lookupPrefix + string ] = hash;
		};

		var generateLookup = function( hashLength ) {
			return function( options ) {
				if ( options.context ) {
					options.original = transform( options.context + String.fromCharCode( 4 ) + options.original, hashLength );
					delete options.context;
				} else {
					options.original = transform( options.original, hashLength );
				}

				return options;
			};
		}

		if ( keyHash.substr( 0, 4 ) === 'sha1' ) {
			if ( keyHash.length === 4 ) {
				translationLookup.push( generateLookup( false ) );
			} else {
				var variableHashLengthPos = keyHash.substr( 5 ).indexOf( '-' );
				if ( variableHashLengthPos < 0 ) {
					hashLength = Number( keyHash.substr( 5 ) );
					translationLookup.push( generateLookup( hashLength ) );
				} else {
					minHashLength = Number( keyHash.substr( 5, variableHashLengthPos ) );
					maxHashLength = Number( keyHash.substr( 6 + variableHashLengthPos ) );

					for ( hashLength = minHashLength; hashLength <= maxHashLength; hashLength++ ) {
						translationLookup.push( generateLookup( hashLength ) );
					}
				}
			}
		}
	}

	// if localeData is not given, assumes default locale and reset
	if ( ! localeData || ! localeData[ '' ].localeSlug ) {
		this.state.locale = { '': { localeSlug: this.defaultLocaleSlug } };
	} else if ( localeData[ '' ].localeSlug === this.state.localeSlug ) {
		// Exit if same data as current (comparing references only)
		if ( localeData === this.state.locale ) {
			return;
		}

		// merge new data into existing one
		assign( this.state.locale, localeData );
	} else {
		this.state.locale = assign( {}, localeData );
	}

	this.state.localeSlug = this.state.locale[ '' ].localeSlug;

	this.state.jed = new Jed( {
		locale_data: {
			messages: this.state.locale
		}
	} );


	// Updates numberFormat preferences with settings from translations
	this.state.numberFormatSettings.decimal_point = getTranslationFromJed(
		this.state.jed,
		normalizeTranslateArguments( [ decimal_point_translation_key ] )
	);
	this.state.numberFormatSettings.thousands_sep = getTranslationFromJed(
		this.state.jed,
		normalizeTranslateArguments( [ thousands_sep_translation_key ] )
	);

	// If translation isn't set, define defaults.
	if ( this.state.numberFormatSettings.decimal_point === decimal_point_translation_key ) {
		this.state.numberFormatSettings.decimal_point = '.';
	}

	if ( this.state.numberFormatSettings.thousands_sep === thousands_sep_translation_key ) {
		this.state.numberFormatSettings.thousands_sep = ',';
	}

	this.state.translations.clear();
	this.stateObserver.emit( 'change' );
};

I18N.prototype.getLocale = function() {
	return this.state.locale;
};

/**
 * Get the current locale slug.
 * @returns {string} The string representing the currently loaded locale
 **/
I18N.prototype.getLocaleSlug = function() {
	return this.state.localeSlug;
};


/**
 * Adds new translations to the locale data, overwriting any existing translations with a matching key
 **/
I18N.prototype.addTranslations = function( localeData ) {
	for ( var prop in localeData ) {
		if ( prop !== '' ) {
			this.state.jed.options.locale_data.messages[prop] = localeData[prop];
		}
	}

	this.state.translations.clear();
	this.stateObserver.emit( 'change' );
};


/**
 * Checks whether the given original has a translation. Parameters are the same as for translate().
 *
 * @param  {string} original  the string to translate
 * @param  {string} plural    the plural string to translate (if applicable), original used as singular
 * @param  {object} options   properties describing translation requirements for given text
 * @return {boolean} whether a translation exists
 */
I18N.prototype.hasTranslation = function() {
	return !! getTranslation( this, normalizeTranslateArguments( arguments ) );
}

/**
 * Exposes single translation method, which is converted into its respective Jed method.
 * See sibling README
 * @param  {string} original  the string to translate
 * @param  {string} plural    the plural string to translate (if applicable), original used as singular
 * @param  {object} options   properties describing translation requirements for given text
 * @return {string|React-components} translated text or an object containing React children that can be inserted into a parent component
 */
I18N.prototype.translate = function() {
	var options, translation, sprintfArgs, errorMethod, optionsString, cacheable;

	options = normalizeTranslateArguments( arguments );

	cacheable = ! options.components;
	if ( cacheable ) {
		// Safe JSON stringification here to catch Circular JSON error
		// caused by passing a React component into args where only scalars are allowed
		try {
			optionsString = JSON.stringify( options );
		} catch ( e ) {
			cacheable = false;
		}

		if ( optionsString ) {
			translation = this.state.translations.get( optionsString );
			// Return the cached translation.
			if ( translation ) {
				return translation;
			}
		}
	}

	translation = getTranslation( this, options );
	if ( ! translation ) {
		// This purposefully calls jed for a case where there is no translation,
		// so that jed gives us the expected object with English text.
		translation = getTranslationFromJed( this.state.jed, options );
	}

	// handle any string substitution
	if ( options.args ) {
		sprintfArgs = ( Array.isArray( options.args ) ) ? options.args.slice( 0 ) : [ options.args ];
		sprintfArgs.unshift( translation );
		try {
			translation = Jed.sprintf.apply( Jed, sprintfArgs );
		} catch ( error ) {
			if ( ! window || ! window.console ) {
				return;
			}
			errorMethod = this.throwErrors ? 'error' : 'warn';
			if ( typeof error !== 'string' ) {
				window.console[ errorMethod ]( error );
			} else {
				window.console[ errorMethod ]( 'i18n sprintf error:', sprintfArgs );
			}
		}
	}

	// interpolate any components
	if ( options.components ) {
		translation = interpolateComponents( {
			mixedString: translation,
			components: options.components,
			throwErrors: this.throwErrors
		} );
	}

	// run any necessary hooks
	this.translateHooks.forEach( function( hook ) {
		translation = hook( translation, options );
	} );

	if ( cacheable ) {
		this.state.translations.set( optionsString, translation );
	}

	return translation;
};

/**
 * Causes i18n to re-render all translations.
 *
 * This can be necessary if an extension makes changes that i18n is unaware of
 * and needs those changes manifested immediately (e.g. adding an important
 * translation hook, or modifying the behaviour of an existing hook).
 *
 * If at all possible, react components should try to use the more local
 * updateTranslation() function inherited from the mixin.
 */
I18N.prototype.reRenderTranslations = function() {
	debug( 'Re-rendering all translations due to external request' );
	this.state.translations.clear();
	this.stateObserver.emit( 'change' );
};

I18N.prototype.registerComponentUpdateHook = function( callback ) {
	this.componentUpdateHooks.push( callback );
};

I18N.prototype.registerTranslateHook = function( callback ) {
	this.translateHooks.push( callback );
};

module.exports = I18N;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(94);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(95);

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),
/* 95 */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @preserve jed.js v0.5.0beta https://github.com/SlexAxton/Jed
 */
/*
-----------
A gettext compatible i18n library for modern JavaScript Applications

by Alex Sexton - AlexSexton [at] gmail - @SlexAxton
WTFPL license for use
Dojo CLA for contributions

Jed offers the entire applicable GNU gettext spec'd set of
functions, but also offers some nicer wrappers around them.
The api for gettext was written for a language with no function
overloading, so Jed allows a little more of that.

Many thanks to Joshua I. Miller - unrtst@cpan.org - who wrote
gettext.js back in 2008. I was able to vet a lot of my ideas
against his. I also made sure Jed passed against his tests
in order to offer easy upgrades -- jsgettext.berlios.de
*/
(function (root, undef) {

  // Set up some underscore-style functions, if you already have
  // underscore, feel free to delete this section, and use it
  // directly, however, the amount of functions used doesn't
  // warrant having underscore as a full dependency.
  // Underscore 1.3.0 was used to port and is licensed
  // under the MIT License by Jeremy Ashkenas.
  var ArrayProto    = Array.prototype,
      ObjProto      = Object.prototype,
      slice         = ArrayProto.slice,
      hasOwnProp    = ObjProto.hasOwnProperty,
      nativeForEach = ArrayProto.forEach,
      breaker       = {};

  // We're not using the OOP style _ so we don't need the
  // extra level of indirection. This still means that you
  // sub out for real `_` though.
  var _ = {
    forEach : function( obj, iterator, context ) {
      var i, l, key;
      if ( obj === null ) {
        return;
      }

      if ( nativeForEach && obj.forEach === nativeForEach ) {
        obj.forEach( iterator, context );
      }
      else if ( obj.length === +obj.length ) {
        for ( i = 0, l = obj.length; i < l; i++ ) {
          if ( i in obj && iterator.call( context, obj[i], i, obj ) === breaker ) {
            return;
          }
        }
      }
      else {
        for ( key in obj) {
          if ( hasOwnProp.call( obj, key ) ) {
            if ( iterator.call (context, obj[key], key, obj ) === breaker ) {
              return;
            }
          }
        }
      }
    },
    extend : function( obj ) {
      this.forEach( slice.call( arguments, 1 ), function ( source ) {
        for ( var prop in source ) {
          obj[prop] = source[prop];
        }
      });
      return obj;
    }
  };
  // END Miniature underscore impl

  // Jed is a constructor function
  var Jed = function ( options ) {
    // Some minimal defaults
    this.defaults = {
      "locale_data" : {
        "messages" : {
          "" : {
            "domain"       : "messages",
            "lang"         : "en",
            "plural_forms" : "nplurals=2; plural=(n != 1);"
          }
          // There are no default keys, though
        }
      },
      // The default domain if one is missing
      "domain" : "messages",
      // enable debug mode to log untranslated strings to the console
      "debug" : false
    };

    // Mix in the sent options with the default options
    this.options = _.extend( {}, this.defaults, options );
    this.textdomain( this.options.domain );

    if ( options.domain && ! this.options.locale_data[ this.options.domain ] ) {
      throw new Error('Text domain set to non-existent domain: `' + options.domain + '`');
    }
  };

  // The gettext spec sets this character as the default
  // delimiter for context lookups.
  // e.g.: context\u0004key
  // If your translation company uses something different,
  // just change this at any time and it will use that instead.
  Jed.context_delimiter = String.fromCharCode( 4 );

  function getPluralFormFunc ( plural_form_string ) {
    return Jed.PF.compile( plural_form_string || "nplurals=2; plural=(n != 1);");
  }

  function Chain( key, i18n ){
    this._key = key;
    this._i18n = i18n;
  }

  // Create a chainable api for adding args prettily
  _.extend( Chain.prototype, {
    onDomain : function ( domain ) {
      this._domain = domain;
      return this;
    },
    withContext : function ( context ) {
      this._context = context;
      return this;
    },
    ifPlural : function ( num, pkey ) {
      this._val = num;
      this._pkey = pkey;
      return this;
    },
    fetch : function ( sArr ) {
      if ( {}.toString.call( sArr ) != '[object Array]' ) {
        sArr = [].slice.call(arguments, 0);
      }
      return ( sArr && sArr.length ? Jed.sprintf : function(x){ return x; } )(
        this._i18n.dcnpgettext(this._domain, this._context, this._key, this._pkey, this._val),
        sArr
      );
    }
  });

  // Add functions to the Jed prototype.
  // These will be the functions on the object that's returned
  // from creating a `new Jed()`
  // These seem redundant, but they gzip pretty well.
  _.extend( Jed.prototype, {
    // The sexier api start point
    translate : function ( key ) {
      return new Chain( key, this );
    },

    textdomain : function ( domain ) {
      if ( ! domain ) {
        return this._textdomain;
      }
      this._textdomain = domain;
    },

    gettext : function ( key ) {
      return this.dcnpgettext.call( this, undef, undef, key );
    },

    dgettext : function ( domain, key ) {
     return this.dcnpgettext.call( this, domain, undef, key );
    },

    dcgettext : function ( domain , key /*, category */ ) {
      // Ignores the category anyways
      return this.dcnpgettext.call( this, domain, undef, key );
    },

    ngettext : function ( skey, pkey, val ) {
      return this.dcnpgettext.call( this, undef, undef, skey, pkey, val );
    },

    dngettext : function ( domain, skey, pkey, val ) {
      return this.dcnpgettext.call( this, domain, undef, skey, pkey, val );
    },

    dcngettext : function ( domain, skey, pkey, val/*, category */) {
      return this.dcnpgettext.call( this, domain, undef, skey, pkey, val );
    },

    pgettext : function ( context, key ) {
      return this.dcnpgettext.call( this, undef, context, key );
    },

    dpgettext : function ( domain, context, key ) {
      return this.dcnpgettext.call( this, domain, context, key );
    },

    dcpgettext : function ( domain, context, key/*, category */) {
      return this.dcnpgettext.call( this, domain, context, key );
    },

    npgettext : function ( context, skey, pkey, val ) {
      return this.dcnpgettext.call( this, undef, context, skey, pkey, val );
    },

    dnpgettext : function ( domain, context, skey, pkey, val ) {
      return this.dcnpgettext.call( this, domain, context, skey, pkey, val );
    },

    // The most fully qualified gettext function. It has every option.
    // Since it has every option, we can use it from every other method.
    // This is the bread and butter.
    // Technically there should be one more argument in this function for 'Category',
    // but since we never use it, we might as well not waste the bytes to define it.
    dcnpgettext : function ( domain, context, singular_key, plural_key, val ) {
      // Set some defaults

      plural_key = plural_key || singular_key;

      // Use the global domain default if one
      // isn't explicitly passed in
      domain = domain || this._textdomain;

      var fallback;

      // Handle special cases

      // No options found
      if ( ! this.options ) {
        // There's likely something wrong, but we'll return the correct key for english
        // We do this by instantiating a brand new Jed instance with the default set
        // for everything that could be broken.
        fallback = new Jed();
        return fallback.dcnpgettext.call( fallback, undefined, undefined, singular_key, plural_key, val );
      }

      // No translation data provided
      if ( ! this.options.locale_data ) {
        throw new Error('No locale data provided.');
      }

      if ( ! this.options.locale_data[ domain ] ) {
        throw new Error('Domain `' + domain + '` was not found.');
      }

      if ( ! this.options.locale_data[ domain ][ "" ] ) {
        throw new Error('No locale meta information provided.');
      }

      // Make sure we have a truthy key. Otherwise we might start looking
      // into the empty string key, which is the options for the locale
      // data.
      if ( ! singular_key ) {
        throw new Error('No translation key found.');
      }

      var key  = context ? context + Jed.context_delimiter + singular_key : singular_key,
          locale_data = this.options.locale_data,
          dict = locale_data[ domain ],
          defaultConf = (locale_data.messages || this.defaults.locale_data.messages)[""],
          pluralForms = dict[""].plural_forms || dict[""]["Plural-Forms"] || dict[""]["plural-forms"] || defaultConf.plural_forms || defaultConf["Plural-Forms"] || defaultConf["plural-forms"],
          val_list,
          res;

      var val_idx;
      if (val === undefined) {
        // No value passed in; assume singular key lookup.
        val_idx = 1;

      } else {
        // Value has been passed in; use plural-forms calculations.

        // Handle invalid numbers, but try casting strings for good measure
        if ( typeof val != 'number' ) {
          val = parseInt( val, 10 );

          if ( isNaN( val ) ) {
            throw new Error('The number that was passed in is not a number.');
          }
        }

        val_idx = getPluralFormFunc(pluralForms)(val) + 1;
      }

      // Throw an error if a domain isn't found
      if ( ! dict ) {
        throw new Error('No domain named `' + domain + '` could be found.');
      }

      val_list = dict[ key ];

      // If there is no match, then revert back to
      // english style singular/plural with the keys passed in.
      if ( ! val_list || val_idx >= val_list.length ) {
        if (this.options.missing_key_callback) {
          this.options.missing_key_callback(key, domain);
        }
        res = [ null, singular_key, plural_key ];

        // collect untranslated strings
        if (this.options.debug===true) {
          console.log(res[ getPluralFormFunc(pluralForms)( val ) + 1 ]);
        }
        return res[ getPluralFormFunc()( val ) + 1 ];
      }

      res = val_list[ val_idx ];

      // This includes empty strings on purpose
      if ( ! res  ) {
        res = [ null, singular_key, plural_key ];
        return res[ getPluralFormFunc()( val ) + 1 ];
      }
      return res;
    }
  });


  // We add in sprintf capabilities for post translation value interolation
  // This is not internally used, so you can remove it if you have this
  // available somewhere else, or want to use a different system.

  // We _slightly_ modify the normal sprintf behavior to more gracefully handle
  // undefined values.

  /**
   sprintf() for JavaScript 0.7-beta1
   http://www.diveintojavascript.com/projects/javascript-sprintf

   Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:
       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
         documentation and/or other materials provided with the distribution.
       * Neither the name of sprintf() for JavaScript nor the
         names of its contributors may be used to endorse or promote products
         derived from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   DISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY
   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
  var sprintf = (function() {
    function get_type(variable) {
      return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
    }
    function str_repeat(input, multiplier) {
      for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
      return output.join('');
    }

    var str_format = function() {
      if (!str_format.cache.hasOwnProperty(arguments[0])) {
        str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
      }
      return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
    };

    str_format.format = function(parse_tree, argv) {
      var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
      for (i = 0; i < tree_length; i++) {
        node_type = get_type(parse_tree[i]);
        if (node_type === 'string') {
          output.push(parse_tree[i]);
        }
        else if (node_type === 'array') {
          match = parse_tree[i]; // convenience purposes only
          if (match[2]) { // keyword argument
            arg = argv[cursor];
            for (k = 0; k < match[2].length; k++) {
              if (!arg.hasOwnProperty(match[2][k])) {
                throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
              }
              arg = arg[match[2][k]];
            }
          }
          else if (match[1]) { // positional argument (explicit)
            arg = argv[match[1]];
          }
          else { // positional argument (implicit)
            arg = argv[cursor++];
          }

          if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
            throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
          }

          // Jed EDIT
          if ( typeof arg == 'undefined' || arg === null ) {
            arg = '';
          }
          // Jed EDIT

          switch (match[8]) {
            case 'b': arg = arg.toString(2); break;
            case 'c': arg = String.fromCharCode(arg); break;
            case 'd': arg = parseInt(arg, 10); break;
            case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
            case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
            case 'o': arg = arg.toString(8); break;
            case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
            case 'u': arg = Math.abs(arg); break;
            case 'x': arg = arg.toString(16); break;
            case 'X': arg = arg.toString(16).toUpperCase(); break;
          }
          arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
          pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
          pad_length = match[6] - String(arg).length;
          pad = match[6] ? str_repeat(pad_character, pad_length) : '';
          output.push(match[5] ? arg + pad : pad + arg);
        }
      }
      return output.join('');
    };

    str_format.cache = {};

    str_format.parse = function(fmt) {
      var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
      while (_fmt) {
        if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
          parse_tree.push(match[0]);
        }
        else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
          parse_tree.push('%');
        }
        else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
          if (match[2]) {
            arg_names |= 1;
            var field_list = [], replacement_field = match[2], field_match = [];
            if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
              field_list.push(field_match[1]);
              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                }
                else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                }
                else {
                  throw('[sprintf] huh?');
                }
              }
            }
            else {
              throw('[sprintf] huh?');
            }
            match[2] = field_list;
          }
          else {
            arg_names |= 2;
          }
          if (arg_names === 3) {
            throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
          }
          parse_tree.push(match);
        }
        else {
          throw('[sprintf] huh?');
        }
        _fmt = _fmt.substring(match[0].length);
      }
      return parse_tree;
    };

    return str_format;
  })();

  var vsprintf = function(fmt, argv) {
    argv.unshift(fmt);
    return sprintf.apply(null, argv);
  };

  Jed.parse_plural = function ( plural_forms, n ) {
    plural_forms = plural_forms.replace(/n/g, n);
    return Jed.parse_expression(plural_forms);
  };

  Jed.sprintf = function ( fmt, args ) {
    if ( {}.toString.call( args ) == '[object Array]' ) {
      return vsprintf( fmt, [].slice.call(args) );
    }
    return sprintf.apply(this, [].slice.call(arguments) );
  };

  Jed.prototype.sprintf = function () {
    return Jed.sprintf.apply(this, arguments);
  };
  // END sprintf Implementation

  // Start the Plural forms section
  // This is a full plural form expression parser. It is used to avoid
  // running 'eval' or 'new Function' directly against the plural
  // forms.
  //
  // This can be important if you get translations done through a 3rd
  // party vendor. I encourage you to use this instead, however, I
  // also will provide a 'precompiler' that you can use at build time
  // to output valid/safe function representations of the plural form
  // expressions. This means you can build this code out for the most
  // part.
  Jed.PF = {};

  Jed.PF.parse = function ( p ) {
    var plural_str = Jed.PF.extractPluralExpr( p );
    return Jed.PF.parser.parse.call(Jed.PF.parser, plural_str);
  };

  Jed.PF.compile = function ( p ) {
    // Handle trues and falses as 0 and 1
    function imply( val ) {
      return (val === true ? 1 : val ? val : 0);
    }

    var ast = Jed.PF.parse( p );
    return function ( n ) {
      return imply( Jed.PF.interpreter( ast )( n ) );
    };
  };

  Jed.PF.interpreter = function ( ast ) {
    return function ( n ) {
      var res;
      switch ( ast.type ) {
        case 'GROUP':
          return Jed.PF.interpreter( ast.expr )( n );
        case 'TERNARY':
          if ( Jed.PF.interpreter( ast.expr )( n ) ) {
            return Jed.PF.interpreter( ast.truthy )( n );
          }
          return Jed.PF.interpreter( ast.falsey )( n );
        case 'OR':
          return Jed.PF.interpreter( ast.left )( n ) || Jed.PF.interpreter( ast.right )( n );
        case 'AND':
          return Jed.PF.interpreter( ast.left )( n ) && Jed.PF.interpreter( ast.right )( n );
        case 'LT':
          return Jed.PF.interpreter( ast.left )( n ) < Jed.PF.interpreter( ast.right )( n );
        case 'GT':
          return Jed.PF.interpreter( ast.left )( n ) > Jed.PF.interpreter( ast.right )( n );
        case 'LTE':
          return Jed.PF.interpreter( ast.left )( n ) <= Jed.PF.interpreter( ast.right )( n );
        case 'GTE':
          return Jed.PF.interpreter( ast.left )( n ) >= Jed.PF.interpreter( ast.right )( n );
        case 'EQ':
          return Jed.PF.interpreter( ast.left )( n ) == Jed.PF.interpreter( ast.right )( n );
        case 'NEQ':
          return Jed.PF.interpreter( ast.left )( n ) != Jed.PF.interpreter( ast.right )( n );
        case 'MOD':
          return Jed.PF.interpreter( ast.left )( n ) % Jed.PF.interpreter( ast.right )( n );
        case 'VAR':
          return n;
        case 'NUM':
          return ast.val;
        default:
          throw new Error("Invalid Token found.");
      }
    };
  };

  Jed.PF.extractPluralExpr = function ( p ) {
    // trim first
    p = p.replace(/^\s\s*/, '').replace(/\s\s*$/, '');

    if (! /;\s*$/.test(p)) {
      p = p.concat(';');
    }

    var nplurals_re = /nplurals\=(\d+);/,
        plural_re = /plural\=(.*);/,
        nplurals_matches = p.match( nplurals_re ),
        res = {},
        plural_matches;

    // Find the nplurals number
    if ( nplurals_matches.length > 1 ) {
      res.nplurals = nplurals_matches[1];
    }
    else {
      throw new Error('nplurals not found in plural_forms string: ' + p );
    }

    // remove that data to get to the formula
    p = p.replace( nplurals_re, "" );
    plural_matches = p.match( plural_re );

    if (!( plural_matches && plural_matches.length > 1 ) ) {
      throw new Error('`plural` expression not found: ' + p);
    }
    return plural_matches[ 1 ];
  };

  /* Jison generated parser */
  Jed.PF.parser = (function(){

var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"expressions":3,"e":4,"EOF":5,"?":6,":":7,"||":8,"&&":9,"<":10,"<=":11,">":12,">=":13,"!=":14,"==":15,"%":16,"(":17,")":18,"n":19,"NUMBER":20,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",6:"?",7:":",8:"||",9:"&&",10:"<",11:"<=",12:">",13:">=",14:"!=",15:"==",16:"%",17:"(",18:")",19:"n",20:"NUMBER"},
productions_: [0,[3,2],[4,5],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,1],[4,1]],
performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {

var $0 = $$.length - 1;
switch (yystate) {
case 1: return { type : 'GROUP', expr: $$[$0-1] };
break;
case 2:this.$ = { type: 'TERNARY', expr: $$[$0-4], truthy : $$[$0-2], falsey: $$[$0] };
break;
case 3:this.$ = { type: "OR", left: $$[$0-2], right: $$[$0] };
break;
case 4:this.$ = { type: "AND", left: $$[$0-2], right: $$[$0] };
break;
case 5:this.$ = { type: 'LT', left: $$[$0-2], right: $$[$0] };
break;
case 6:this.$ = { type: 'LTE', left: $$[$0-2], right: $$[$0] };
break;
case 7:this.$ = { type: 'GT', left: $$[$0-2], right: $$[$0] };
break;
case 8:this.$ = { type: 'GTE', left: $$[$0-2], right: $$[$0] };
break;
case 9:this.$ = { type: 'NEQ', left: $$[$0-2], right: $$[$0] };
break;
case 10:this.$ = { type: 'EQ', left: $$[$0-2], right: $$[$0] };
break;
case 11:this.$ = { type: 'MOD', left: $$[$0-2], right: $$[$0] };
break;
case 12:this.$ = { type: 'GROUP', expr: $$[$0-1] };
break;
case 13:this.$ = { type: 'VAR' };
break;
case 14:this.$ = { type: 'NUM', val: Number(yytext) };
break;
}
},
table: [{3:1,4:2,17:[1,3],19:[1,4],20:[1,5]},{1:[3]},{5:[1,6],6:[1,7],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16]},{4:17,17:[1,3],19:[1,4],20:[1,5]},{5:[2,13],6:[2,13],7:[2,13],8:[2,13],9:[2,13],10:[2,13],11:[2,13],12:[2,13],13:[2,13],14:[2,13],15:[2,13],16:[2,13],18:[2,13]},{5:[2,14],6:[2,14],7:[2,14],8:[2,14],9:[2,14],10:[2,14],11:[2,14],12:[2,14],13:[2,14],14:[2,14],15:[2,14],16:[2,14],18:[2,14]},{1:[2,1]},{4:18,17:[1,3],19:[1,4],20:[1,5]},{4:19,17:[1,3],19:[1,4],20:[1,5]},{4:20,17:[1,3],19:[1,4],20:[1,5]},{4:21,17:[1,3],19:[1,4],20:[1,5]},{4:22,17:[1,3],19:[1,4],20:[1,5]},{4:23,17:[1,3],19:[1,4],20:[1,5]},{4:24,17:[1,3],19:[1,4],20:[1,5]},{4:25,17:[1,3],19:[1,4],20:[1,5]},{4:26,17:[1,3],19:[1,4],20:[1,5]},{4:27,17:[1,3],19:[1,4],20:[1,5]},{6:[1,7],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[1,28]},{6:[1,7],7:[1,29],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16]},{5:[2,3],6:[2,3],7:[2,3],8:[2,3],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,3]},{5:[2,4],6:[2,4],7:[2,4],8:[2,4],9:[2,4],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,4]},{5:[2,5],6:[2,5],7:[2,5],8:[2,5],9:[2,5],10:[2,5],11:[2,5],12:[2,5],13:[2,5],14:[2,5],15:[2,5],16:[1,16],18:[2,5]},{5:[2,6],6:[2,6],7:[2,6],8:[2,6],9:[2,6],10:[2,6],11:[2,6],12:[2,6],13:[2,6],14:[2,6],15:[2,6],16:[1,16],18:[2,6]},{5:[2,7],6:[2,7],7:[2,7],8:[2,7],9:[2,7],10:[2,7],11:[2,7],12:[2,7],13:[2,7],14:[2,7],15:[2,7],16:[1,16],18:[2,7]},{5:[2,8],6:[2,8],7:[2,8],8:[2,8],9:[2,8],10:[2,8],11:[2,8],12:[2,8],13:[2,8],14:[2,8],15:[2,8],16:[1,16],18:[2,8]},{5:[2,9],6:[2,9],7:[2,9],8:[2,9],9:[2,9],10:[2,9],11:[2,9],12:[2,9],13:[2,9],14:[2,9],15:[2,9],16:[1,16],18:[2,9]},{5:[2,10],6:[2,10],7:[2,10],8:[2,10],9:[2,10],10:[2,10],11:[2,10],12:[2,10],13:[2,10],14:[2,10],15:[2,10],16:[1,16],18:[2,10]},{5:[2,11],6:[2,11],7:[2,11],8:[2,11],9:[2,11],10:[2,11],11:[2,11],12:[2,11],13:[2,11],14:[2,11],15:[2,11],16:[2,11],18:[2,11]},{5:[2,12],6:[2,12],7:[2,12],8:[2,12],9:[2,12],10:[2,12],11:[2,12],12:[2,12],13:[2,12],14:[2,12],15:[2,12],16:[2,12],18:[2,12]},{4:30,17:[1,3],19:[1,4],20:[1,5]},{5:[2,2],6:[1,7],7:[2,2],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,2]}],
defaultActions: {6:[2,1]},
parseError: function parseError(str, hash) {
    throw new Error(str);
},
parse: function parse(input) {
    var self = this,
        stack = [0],
        vstack = [null], // semantic value stack
        lstack = [], // location stack
        table = this.table,
        yytext = '',
        yylineno = 0,
        yyleng = 0,
        recovering = 0,
        TERROR = 2,
        EOF = 1;

    //this.reductionCount = this.shiftCount = 0;

    this.lexer.setInput(input);
    this.lexer.yy = this.yy;
    this.yy.lexer = this.lexer;
    if (typeof this.lexer.yylloc == 'undefined')
        this.lexer.yylloc = {};
    var yyloc = this.lexer.yylloc;
    lstack.push(yyloc);

    if (typeof this.yy.parseError === 'function')
        this.parseError = this.yy.parseError;

    function popStack (n) {
        stack.length = stack.length - 2*n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }

    function lex() {
        var token;
        token = self.lexer.lex() || 1; // $end = 1
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }
        return token;
    }

    var symbol, preErrorSymbol, state, action, a, r, yyval={},p,len,newState, expected;
    while (true) {
        // retreive state number from top of stack
        state = stack[stack.length-1];

        // use default actions if available
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol == null)
                symbol = lex();
            // read action for current state and first input
            action = table[state] && table[state][symbol];
        }

        // handle parse error
        _handle_error:
        if (typeof action === 'undefined' || !action.length || !action[0]) {

            if (!recovering) {
                // Report error
                expected = [];
                for (p in table[state]) if (this.terminals_[p] && p > 2) {
                    expected.push("'"+this.terminals_[p]+"'");
                }
                var errStr = '';
                if (this.lexer.showPosition) {
                    errStr = 'Parse error on line '+(yylineno+1)+":\n"+this.lexer.showPosition()+"\nExpecting "+expected.join(', ') + ", got '" + this.terminals_[symbol]+ "'";
                } else {
                    errStr = 'Parse error on line '+(yylineno+1)+": Unexpected " +
                                  (symbol == 1 /*EOF*/ ? "end of input" :
                                              ("'"+(this.terminals_[symbol] || symbol)+"'"));
                }
                this.parseError(errStr,
                    {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
            }

            // just recovered from another error
            if (recovering == 3) {
                if (symbol == EOF) {
                    throw new Error(errStr || 'Parsing halted.');
                }

                // discard current lookahead and grab another
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                symbol = lex();
            }

            // try to recover from error
            while (1) {
                // check for error recovery rule in this state
                if ((TERROR.toString()) in table[state]) {
                    break;
                }
                if (state == 0) {
                    throw new Error(errStr || 'Parsing halted.');
                }
                popStack(1);
                state = stack[stack.length-1];
            }

            preErrorSymbol = symbol; // save the lookahead token
            symbol = TERROR;         // insert generic error symbol as new lookahead
            state = stack[stack.length-1];
            action = table[state] && table[state][TERROR];
            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
        }

        // this shouldn't happen, unless resolve defaults are off
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);
        }

        switch (action[0]) {

            case 1: // shift
                //this.shiftCount++;

                stack.push(symbol);
                vstack.push(this.lexer.yytext);
                lstack.push(this.lexer.yylloc);
                stack.push(action[1]); // push state
                symbol = null;
                if (!preErrorSymbol) { // normal execution/no error
                    yyleng = this.lexer.yyleng;
                    yytext = this.lexer.yytext;
                    yylineno = this.lexer.yylineno;
                    yyloc = this.lexer.yylloc;
                    if (recovering > 0)
                        recovering--;
                } else { // error just occurred, resume old lookahead f/ before error
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                }
                break;

            case 2: // reduce
                //this.reductionCount++;

                len = this.productions_[action[1]][1];

                // perform semantic action
                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1
                // default location, uses first token for firsts, last for lasts
                yyval._$ = {
                    first_line: lstack[lstack.length-(len||1)].first_line,
                    last_line: lstack[lstack.length-1].last_line,
                    first_column: lstack[lstack.length-(len||1)].first_column,
                    last_column: lstack[lstack.length-1].last_column
                };
                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);

                if (typeof r !== 'undefined') {
                    return r;
                }

                // pop off stack
                if (len) {
                    stack = stack.slice(0,-1*len*2);
                    vstack = vstack.slice(0, -1*len);
                    lstack = lstack.slice(0, -1*len);
                }

                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                // goto new state = table[STATE][NONTERMINAL]
                newState = table[stack[stack.length-2]][stack[stack.length-1]];
                stack.push(newState);
                break;

            case 3: // accept
                return true;
        }

    }

    return true;
}};/* Jison generated lexer */
var lexer = (function(){

var lexer = ({EOF:1,
parseError:function parseError(str, hash) {
        if (this.yy.parseError) {
            this.yy.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },
setInput:function (input) {
        this._input = input;
        this._more = this._less = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
        return this;
    },
input:function () {
        var ch = this._input[0];
        this.yytext+=ch;
        this.yyleng++;
        this.match+=ch;
        this.matched+=ch;
        var lines = ch.match(/\n/);
        if (lines) this.yylineno++;
        this._input = this._input.slice(1);
        return ch;
    },
unput:function (ch) {
        this._input = ch + this._input;
        return this;
    },
more:function () {
        this._more = true;
        return this;
    },
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
    },
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c+"^";
    },
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) this.done = true;

        var token,
            match,
            col,
            lines;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i=0;i < rules.length; i++) {
            match = this._input.match(this.rules[rules[i]]);
            if (match) {
                lines = match[0].match(/\n.*/g);
                if (lines) this.yylineno += lines.length;
                this.yylloc = {first_line: this.yylloc.last_line,
                               last_line: this.yylineno+1,
                               first_column: this.yylloc.last_column,
                               last_column: lines ? lines[lines.length-1].length-1 : this.yylloc.last_column + match[0].length}
                this.yytext += match[0];
                this.match += match[0];
                this.matches = match;
                this.yyleng = this.yytext.length;
                this._more = false;
                this._input = this._input.slice(match[0].length);
                this.matched += match[0];
                token = this.performAction.call(this, this.yy, this, rules[i],this.conditionStack[this.conditionStack.length-1]);
                if (token) return token;
                else return;
            }
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(),
                    {text: "", token: null, line: this.yylineno});
        }
    },
lex:function lex() {
        var r = this.next();
        if (typeof r !== 'undefined') {
            return r;
        } else {
            return this.lex();
        }
    },
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },
popState:function popState() {
        return this.conditionStack.pop();
    },
_currentRules:function _currentRules() {
        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
    },
topState:function () {
        return this.conditionStack[this.conditionStack.length-2];
    },
pushState:function begin(condition) {
        this.begin(condition);
    }});
lexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {

var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:/* skip whitespace */
break;
case 1:return 20
break;
case 2:return 19
break;
case 3:return 8
break;
case 4:return 9
break;
case 5:return 6
break;
case 6:return 7
break;
case 7:return 11
break;
case 8:return 13
break;
case 9:return 10
break;
case 10:return 12
break;
case 11:return 14
break;
case 12:return 15
break;
case 13:return 16
break;
case 14:return 17
break;
case 15:return 18
break;
case 16:return 5
break;
case 17:return 'INVALID'
break;
}
};
lexer.rules = [/^\s+/,/^[0-9]+(\.[0-9]+)?\b/,/^n\b/,/^\|\|/,/^&&/,/^\?/,/^:/,/^<=/,/^>=/,/^</,/^>/,/^!=/,/^==/,/^%/,/^\(/,/^\)/,/^$/,/^./];
lexer.conditions = {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17],"inclusive":true}};return lexer;})()
parser.lexer = lexer;
return parser;
})();
// End parser

  // Handle node, amd, and global systems
  if (true) {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Jed;
    }
    exports.Jed = Jed;
  }
  else {
    if (typeof define === 'function' && define.amd) {
      define('jed', function() {
        return Jed;
      });
    }
    // Leak a global regardless of module system
    root['Jed'] = Jed;
  }

})(this);


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(37);
var common = __webpack_require__(98);
var shaCommon = __webpack_require__(99);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(37);
var assert = __webpack_require__(54);

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(37);
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * External Dependencies
                                                                                                                                                                                                                                                                               */


/**
 * Internal Dependencies
 */


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactAddonsCreateFragment = __webpack_require__(101);

var _reactAddonsCreateFragment2 = _interopRequireDefault(_reactAddonsCreateFragment);

var _tokenize = __webpack_require__(102);

var _tokenize2 = _interopRequireDefault(_tokenize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var currentMixedString = void 0;

function getCloseIndex(openIndex, tokens) {
	var openToken = tokens[openIndex],
	    nestLevel = 0,
	    token,
	    i;
	for (i = openIndex + 1; i < tokens.length; i++) {
		token = tokens[i];
		if (token.value === openToken.value) {
			if (token.type === 'componentOpen') {
				nestLevel++;
				continue;
			}
			if (token.type === 'componentClose') {
				if (nestLevel === 0) {
					return i;
				}
				nestLevel--;
			}
		}
	}
	// if we get this far, there was no matching close token
	throw new Error('Missing closing component token `' + openToken.value + '`');
}

function buildChildren(tokens, components) {
	var children = [],
	    childrenObject = {},
	    openComponent,
	    clonedOpenComponent,
	    openIndex,
	    closeIndex,
	    token,
	    i,
	    grandChildTokens,
	    grandChildren,
	    siblingTokens,
	    siblings;

	for (i = 0; i < tokens.length; i++) {
		token = tokens[i];
		if (token.type === 'string') {
			children.push(token.value);
			continue;
		}
		// component node should at least be set
		if (!components.hasOwnProperty(token.value) || typeof components[token.value] === 'undefined') {
			throw new Error('Invalid interpolation, missing component node: `' + token.value + '`');
		}
		// should be either ReactElement or null (both type "object"), all other types deprecated
		if (_typeof(components[token.value]) !== 'object') {
			throw new Error('Invalid interpolation, component node must be a ReactElement or null: `' + token.value + '`', '\n> ' + currentMixedString);
		}
		// we should never see a componentClose token in this loop
		if (token.type === 'componentClose') {
			throw new Error('Missing opening component token: `' + token.value + '`');
		}
		if (token.type === 'componentOpen') {
			openComponent = components[token.value];
			openIndex = i;
			break;
		}
		// componentSelfClosing token
		children.push(components[token.value]);
		continue;
	}

	if (openComponent) {
		closeIndex = getCloseIndex(openIndex, tokens);
		grandChildTokens = tokens.slice(openIndex + 1, closeIndex);
		grandChildren = buildChildren(grandChildTokens, components);
		clonedOpenComponent = _react2.default.cloneElement(openComponent, {}, grandChildren);
		children.push(clonedOpenComponent);

		if (closeIndex < tokens.length - 1) {
			siblingTokens = tokens.slice(closeIndex + 1);
			siblings = buildChildren(siblingTokens, components);
			children = children.concat(siblings);
		}
	}

	if (children.length === 1) {
		return children[0];
	}

	children.forEach(function (child, index) {
		if (child) {
			childrenObject['interpolation-child-' + index] = child;
		}
	});

	return (0, _reactAddonsCreateFragment2.default)(childrenObject);
}

function interpolate(options) {
	var mixedString = options.mixedString,
	    components = options.components,
	    throwErrors = options.throwErrors;


	currentMixedString = mixedString;

	if (!components) {
		return mixedString;
	}

	if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) !== 'object') {
		if (throwErrors) {
			throw new Error('Interpolation Error: unable to process `' + mixedString + '` because components is not an object');
		}

		return mixedString;
	}

	var tokens = (0, _tokenize2.default)(mixedString);

	try {
		return buildChildren(tokens, components);
	} catch (error) {
		if (throwErrors) {
			throw new Error('Interpolation Error: unable to process `' + mixedString + '` because of error `' + error.message + '`');
		}

		return mixedString;
	}
};

exports.default = interpolate;
//# sourceMappingURL=index.js.map

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var React = __webpack_require__(0);

var REACT_ELEMENT_TYPE =
  (typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element')) ||
  0xeac7;

var emptyFunction = __webpack_require__(57);
var invariant = __webpack_require__(58);
var warning = __webpack_require__(59);

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

var didWarnAboutMaps = false;

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

function getIteratorFn(maybeIterable) {
  var iteratorFn =
    maybeIterable &&
    ((ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL]) ||
      maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function(match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

function traverseAllChildrenImpl(
  children,
  nameSoFar,
  callback,
  traverseContext
) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (
    children === null ||
    type === 'string' ||
    type === 'number' ||
    // The following is inlined from ReactElement. This means we can optimize
    // some checks. React Fiber also inlines this logic for similar purposes.
    (type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE)
  ) {
    callback(
      traverseContext,
      children,
      // If it's the only child, treat the name as if it was wrapped in an array
      // so that it's consistent if the number of children grows.
      nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar
    );
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(
        child,
        nextName,
        callback,
        traverseContext
      );
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      if (process.env.NODE_ENV !== 'production') {
        // Warn about using Maps as children
        if (iteratorFn === children.entries) {
          warning(
            didWarnAboutMaps,
            'Using Maps as children is unsupported and will likely yield ' +
              'unexpected results. Convert it to a sequence/iterable of keyed ' +
              'ReactElements instead.'
          );
          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(children);
      var step;
      var ii = 0;
      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getComponentKey(child, ii++);
        subtreeCount += traverseAllChildrenImpl(
          child,
          nextName,
          callback,
          traverseContext
        );
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum =
          ' If you meant to render a collection of children, use an array ' +
          'instead or wrap the object using createFragment(object) from the ' +
          'React add-ons.';
      }
      var childrenString = '' + children;
      invariant(
        false,
        'Objects are not valid as a React child (found: %s).%s',
        childrenString === '[object Object]'
          ? 'object with keys {' + Object.keys(children).join(', ') + '}'
          : childrenString,
        addendum
      );
    }
  }

  return subtreeCount;
}

function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

function cloneAndReplaceKey(oldElement, newKey) {
  return React.cloneElement(
    oldElement,
    {key: newKey},
    oldElement.props !== undefined ? oldElement.props.children : undefined
  );
}

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

var oneArgumentPooler = function(copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var standardReleaser = function standardReleaser(instance) {
  var Klass = this;
  invariant(
    instance instanceof Klass,
    'Trying to release an instance into a pool of a different type.'
  );
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function() {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result;
  var keyPrefix = bookKeeping.keyPrefix;
  var func = bookKeeping.func;
  var context = bookKeeping.context;

  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(
      mappedChild,
      result,
      childKey,
      emptyFunction.thatReturnsArgument
    );
  } else if (mappedChild != null) {
    if (React.isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(
        mappedChild,
        // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        keyPrefix +
          (mappedChild.key && (!child || child.key !== mappedChild.key)
            ? escapeUserProvidedKey(mappedChild.key) + '/'
            : '') +
          childKey
      );
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(
    array,
    escapedPrefix,
    func,
    context
  );
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

var numericPropertyRegex = /^\d+$/;

var warnedAboutNumeric = false;

function createReactFragment(object) {
  if (typeof object !== 'object' || !object || Array.isArray(object)) {
    warning(
      false,
      'React.addons.createFragment only accepts a single object. Got: %s',
      object
    );
    return object;
  }
  if (React.isValidElement(object)) {
    warning(
      false,
      'React.addons.createFragment does not accept a ReactElement ' +
        'without a wrapper object.'
    );
    return object;
  }

  invariant(
    object.nodeType !== 1,
    'React.addons.createFragment(...): Encountered an invalid child; DOM ' +
      'elements are not valid children of React components.'
  );

  var result = [];

  for (var key in object) {
    if (process.env.NODE_ENV !== 'production') {
      if (!warnedAboutNumeric && numericPropertyRegex.test(key)) {
        warning(
          false,
          'React.addons.createFragment(...): Child objects should have ' +
            'non-numeric keys so ordering is preserved.'
        );
        warnedAboutNumeric = true;
      }
    }
    mapIntoWithKeyPrefixInternal(
      object[key],
      result,
      key,
      emptyFunction.thatReturnsArgument
    );
  }

  return result;
}

module.exports = createReactFragment;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function identifyToken(item) {
	// {{/example}}
	if (item.match(/^\{\{\//)) {
		return {
			type: 'componentClose',
			value: item.replace(/\W/g, '')
		};
	}
	// {{example /}}
	if (item.match(/\/\}\}$/)) {
		return {
			type: 'componentSelfClosing',
			value: item.replace(/\W/g, '')
		};
	}
	// {{example}}
	if (item.match(/^\{\{/)) {
		return {
			type: 'componentOpen',
			value: item.replace(/\W/g, '')
		};
	}
	return {
		type: 'string',
		value: item
	};
}

module.exports = function (mixedString) {
	var tokenStrings = mixedString.split(/(\{\{\/?\s*\w+\s*\/?\}\})/g); // split to components and strings
	return tokenStrings.map(identifyToken);
};
//# sourceMappingURL=tokenize.js.map

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var events = __webpack_require__(56)
var inherits = __webpack_require__(55)

module.exports = LRU

function LRU (opts) {
  if (!(this instanceof LRU)) return new LRU(opts)
  if (typeof opts === 'number') opts = {max: opts}
  if (!opts) opts = {}
  events.EventEmitter.call(this)
  this.cache = {}
  this.head = this.tail = null
  this.length = 0
  this.max = opts.max || 1000
  this.maxAge = opts.maxAge || 0
}

inherits(LRU, events.EventEmitter)

Object.defineProperty(LRU.prototype, 'keys', {
  get: function () { return Object.keys(this.cache) }
})

LRU.prototype.clear = function () {
  this.cache = {}
  this.head = this.tail = null
  this.length = 0
}

LRU.prototype.remove = function (key) {
  if (typeof key !== 'string') key = '' + key
  if (!this.cache.hasOwnProperty(key)) return

  var element = this.cache[key]
  delete this.cache[key]
  this._unlink(key, element.prev, element.next)
  return element.value
}

LRU.prototype._unlink = function (key, prev, next) {
  this.length--

  if (this.length === 0) {
    this.head = this.tail = null
  } else {
    if (this.head === key) {
      this.head = prev
      this.cache[this.head].next = null
    } else if (this.tail === key) {
      this.tail = next
      this.cache[this.tail].prev = null
    } else {
      this.cache[prev].next = next
      this.cache[next].prev = prev
    }
  }
}

LRU.prototype.peek = function (key) {
  if (!this.cache.hasOwnProperty(key)) return

  var element = this.cache[key]

  if (!this._checkAge(key, element)) return
  return element.value
}

LRU.prototype.set = function (key, value) {
  if (typeof key !== 'string') key = '' + key

  var element

  if (this.cache.hasOwnProperty(key)) {
    element = this.cache[key]
    element.value = value
    if (this.maxAge) element.modified = Date.now()

    // If it's already the head, there's nothing more to do:
    if (key === this.head) return value
    this._unlink(key, element.prev, element.next)
  } else {
    element = {value: value, modified: 0, next: null, prev: null}
    if (this.maxAge) element.modified = Date.now()
    this.cache[key] = element

    // Eviction is only possible if the key didn't already exist:
    if (this.length === this.max) this.evict()
  }

  this.length++
  element.next = null
  element.prev = this.head

  if (this.head) this.cache[this.head].next = key
  this.head = key

  if (!this.tail) this.tail = key
  return value
}

LRU.prototype._checkAge = function (key, element) {
  if (this.maxAge && (Date.now() - element.modified) > this.maxAge) {
    this.remove(key)
    this.emit('evict', {key: key, value: element.value})
    return false
  }
  return true
}

LRU.prototype.get = function (key) {
  if (typeof key !== 'string') key = '' + key
  if (!this.cache.hasOwnProperty(key)) return

  var element = this.cache[key]

  if (!this._checkAge(key, element)) return

  if (this.head !== key) {
    if (key === this.tail) {
      this.tail = element.next
      this.cache[this.tail].prev = null
    } else {
      // Set prev.next -> element.next:
      this.cache[element.prev].next = element.next
    }

    // Set element.next.prev -> element.prev:
    this.cache[element.next].prev = element.prev

    // Element is the new head
    this.cache[this.head].next = key
    element.prev = this.head
    element.next = null
    this.head = key
  }

  return element.value
}

LRU.prototype.evict = function () {
  if (!this.tail) return
  var key = this.tail
  var value = this.remove(this.tail)
  this.emit('evict', {key: key, value: value})
}


/***/ }),
/* 104 */
/***/ (function(module, exports) {

/**
 * Exposes number format capability
 *
 * @copyright Copyright (c) 2013 Kevin van Zonneveld (http://kvz.io) and Contributors (http://phpjs.org/authors).
 * @license See CREDITS.md
 * @see https://github.com/kvz/phpjs/blob/ffe1356af23a6f2512c84c954dd4e828e92579fa/functions/strings/number_format.js
 */
function number_format( number, decimals, dec_point, thousands_sep ) {
  number = ( number + '' )
    .replace( /[^0-9+\-Ee.]/g, '' );
  var n = ! isFinite( +number ) ? 0 : +number,
    prec = ! isFinite( +decimals ) ? 0 : Math.abs( decimals ),
    sep = ( typeof thousands_sep === 'undefined' ) ? ',' : thousands_sep,
    dec = ( typeof dec_point === 'undefined' ) ? '.' : dec_point,
    s = '',
    toFixedFix = function( n, prec ) {
      var k = Math.pow( 10, prec );
      return '' + ( Math.round( n * k ) / k )
          .toFixed( prec );
    };
  // Fix for IE parseFloat(0.55).toFixed(0) = 0;
  s = ( prec ? toFixedFix( n, prec ) : '' + Math.round( n ) )
    .split( '.' );
  if ( s[ 0 ].length > 3 ) {
    s[ 0 ] = s[ 0 ].replace( /\B(?=(?:\d{3})+(?!\d))/g, sep );
  }
  if ( ( s[ 1 ] || '' )
        .length < prec ) {
    s[ 1 ] = s[ 1 ] || '';
    s[ 1 ] += new Array( prec - s[ 1 ].length + 1 )
      .join( '0' );
  }
  return s.join( dec );
}

module.exports = number_format;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var React = __webpack_require__( 0 ),
	assign = __webpack_require__( 60 ),
	createClass = __webpack_require__( 106 );

/**
 * Localize a React component
 * @param ComposedComponent
 * @returns A new Localized React Component
 */
module.exports = function( i18n ) {
	var i18nProps = {
		numberFormat: i18n.numberFormat.bind( i18n ),
		translate: i18n.translate.bind( i18n )
	};

	return function( ComposedComponent ) {
		var componentName = ComposedComponent.displayName || ComposedComponent.name || '';

		var component = createClass({
			displayName: 'Localized(' + componentName + ')',

			componentDidMount: function() {
				this.boundForceUpdate = this.forceUpdate.bind( this );
				i18n.stateObserver.addListener( 'change', this.boundForceUpdate );
			},

			componentWillUnmount: function() {
				// in some cases, componentWillUnmount is called before componentDidMount
				// Supposedly fixed in React 15.1.0: https://github.com/facebook/react/issues/2410
				if ( this.boundForceUpdate ) {
					i18n.stateObserver.removeListener( 'change', this.boundForceUpdate );
				}
			},

			render: function() {
				var props = assign( {}, this.props, i18nProps );
				return React.createElement( ComposedComponent, props );
			}
		} );
		component._composedComponent = ComposedComponent;
		return component;
	};
};


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var React = __webpack_require__(0);
var factory = __webpack_require__(107);

if (typeof React === 'undefined') {
  throw Error(
    'create-react-class could not find the React object. If you are using script tags, ' +
      'make sure that React is being loaded before create-react-class.'
  );
}

// Hack to grab NoopUpdateQueue from isomorphic React
var ReactNoopUpdateQueue = new React.Component().updater;

module.exports = factory(
  React.Component,
  React.isValidElement,
  ReactNoopUpdateQueue
);


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var _assign = __webpack_require__(62);

var emptyObject = __webpack_require__(108);
var _invariant = __webpack_require__(58);

if (process.env.NODE_ENV !== 'production') {
  var warning = __webpack_require__(59);
}

var MIXINS_KEY = 'mixins';

// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

var ReactPropTypeLocationNames;
if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
} else {
  ReactPropTypeLocationNames = {};
}

function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
  /**
   * Policies that describe methods in `ReactClassInterface`.
   */

  var injectedMixins = [];

  /**
   * Composite components are higher-level components that compose other composite
   * or host components.
   *
   * To create a new type of `ReactClass`, pass a specification of
   * your new class to `React.createClass`. The only requirement of your class
   * specification is that you implement a `render` method.
   *
   *   var MyComponent = React.createClass({
   *     render: function() {
   *       return <div>Hello World</div>;
   *     }
   *   });
   *
   * The class specification supports a specific protocol of methods that have
   * special meaning (e.g. `render`). See `ReactClassInterface` for
   * more the comprehensive protocol. Any other properties and methods in the
   * class specification will be available on the prototype.
   *
   * @interface ReactClassInterface
   * @internal
   */
  var ReactClassInterface = {
    /**
     * An array of Mixin objects to include when defining your component.
     *
     * @type {array}
     * @optional
     */
    mixins: 'DEFINE_MANY',

    /**
     * An object containing properties and methods that should be defined on
     * the component's constructor instead of its prototype (static methods).
     *
     * @type {object}
     * @optional
     */
    statics: 'DEFINE_MANY',

    /**
     * Definition of prop types for this component.
     *
     * @type {object}
     * @optional
     */
    propTypes: 'DEFINE_MANY',

    /**
     * Definition of context types for this component.
     *
     * @type {object}
     * @optional
     */
    contextTypes: 'DEFINE_MANY',

    /**
     * Definition of context types this component sets for its children.
     *
     * @type {object}
     * @optional
     */
    childContextTypes: 'DEFINE_MANY',

    // ==== Definition methods ====

    /**
     * Invoked when the component is mounted. Values in the mapping will be set on
     * `this.props` if that prop is not specified (i.e. using an `in` check).
     *
     * This method is invoked before `getInitialState` and therefore cannot rely
     * on `this.state` or use `this.setState`.
     *
     * @return {object}
     * @optional
     */
    getDefaultProps: 'DEFINE_MANY_MERGED',

    /**
     * Invoked once before the component is mounted. The return value will be used
     * as the initial value of `this.state`.
     *
     *   getInitialState: function() {
     *     return {
     *       isOn: false,
     *       fooBaz: new BazFoo()
     *     }
     *   }
     *
     * @return {object}
     * @optional
     */
    getInitialState: 'DEFINE_MANY_MERGED',

    /**
     * @return {object}
     * @optional
     */
    getChildContext: 'DEFINE_MANY_MERGED',

    /**
     * Uses props from `this.props` and state from `this.state` to render the
     * structure of the component.
     *
     * No guarantees are made about when or how often this method is invoked, so
     * it must not have side effects.
     *
     *   render: function() {
     *     var name = this.props.name;
     *     return <div>Hello, {name}!</div>;
     *   }
     *
     * @return {ReactComponent}
     * @required
     */
    render: 'DEFINE_ONCE',

    // ==== Delegate methods ====

    /**
     * Invoked when the component is initially created and about to be mounted.
     * This may have side effects, but any external subscriptions or data created
     * by this method must be cleaned up in `componentWillUnmount`.
     *
     * @optional
     */
    componentWillMount: 'DEFINE_MANY',

    /**
     * Invoked when the component has been mounted and has a DOM representation.
     * However, there is no guarantee that the DOM node is in the document.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been mounted (initialized and rendered) for the first time.
     *
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidMount: 'DEFINE_MANY',

    /**
     * Invoked before the component receives new props.
     *
     * Use this as an opportunity to react to a prop transition by updating the
     * state using `this.setState`. Current props are accessed via `this.props`.
     *
     *   componentWillReceiveProps: function(nextProps, nextContext) {
     *     this.setState({
     *       likesIncreasing: nextProps.likeCount > this.props.likeCount
     *     });
     *   }
     *
     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
     * transition may cause a state change, but the opposite is not true. If you
     * need it, you are probably looking for `componentWillUpdate`.
     *
     * @param {object} nextProps
     * @optional
     */
    componentWillReceiveProps: 'DEFINE_MANY',

    /**
     * Invoked while deciding if the component should be updated as a result of
     * receiving new props, state and/or context.
     *
     * Use this as an opportunity to `return false` when you're certain that the
     * transition to the new props/state/context will not require a component
     * update.
     *
     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
     *     return !equal(nextProps, this.props) ||
     *       !equal(nextState, this.state) ||
     *       !equal(nextContext, this.context);
     *   }
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @return {boolean} True if the component should update.
     * @optional
     */
    shouldComponentUpdate: 'DEFINE_ONCE',

    /**
     * Invoked when the component is about to update due to a transition from
     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
     * and `nextContext`.
     *
     * Use this as an opportunity to perform preparation before an update occurs.
     *
     * NOTE: You **cannot** use `this.setState()` in this method.
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @param {ReactReconcileTransaction} transaction
     * @optional
     */
    componentWillUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component's DOM representation has been updated.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been updated.
     *
     * @param {object} prevProps
     * @param {?object} prevState
     * @param {?object} prevContext
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component is about to be removed from its parent and have
     * its DOM representation destroyed.
     *
     * Use this as an opportunity to deallocate any external resources.
     *
     * NOTE: There is no `componentDidUnmount` since your component will have been
     * destroyed by that point.
     *
     * @optional
     */
    componentWillUnmount: 'DEFINE_MANY',

    /**
     * Replacement for (deprecated) `componentWillMount`.
     *
     * @optional
     */
    UNSAFE_componentWillMount: 'DEFINE_MANY',

    /**
     * Replacement for (deprecated) `componentWillReceiveProps`.
     *
     * @optional
     */
    UNSAFE_componentWillReceiveProps: 'DEFINE_MANY',

    /**
     * Replacement for (deprecated) `componentWillUpdate`.
     *
     * @optional
     */
    UNSAFE_componentWillUpdate: 'DEFINE_MANY',

    // ==== Advanced methods ====

    /**
     * Updates the component's currently mounted DOM representation.
     *
     * By default, this implements React's rendering and reconciliation algorithm.
     * Sophisticated clients may wish to override this.
     *
     * @param {ReactReconcileTransaction} transaction
     * @internal
     * @overridable
     */
    updateComponent: 'OVERRIDE_BASE'
  };

  /**
   * Similar to ReactClassInterface but for static methods.
   */
  var ReactClassStaticInterface = {
    /**
     * This method is invoked after a component is instantiated and when it
     * receives new props. Return an object to update state in response to
     * prop changes. Return null to indicate no change to state.
     *
     * If an object is returned, its keys will be merged into the existing state.
     *
     * @return {object || null}
     * @optional
     */
    getDerivedStateFromProps: 'DEFINE_MANY_MERGED'
  };

  /**
   * Mapping from class specification keys to special processing functions.
   *
   * Although these are declared like instance properties in the specification
   * when defining classes using `React.createClass`, they are actually static
   * and are accessible on the constructor instead of the prototype. Despite
   * being static, they must be defined outside of the "statics" key under
   * which all other static methods are defined.
   */
  var RESERVED_SPEC_KEYS = {
    displayName: function(Constructor, displayName) {
      Constructor.displayName = displayName;
    },
    mixins: function(Constructor, mixins) {
      if (mixins) {
        for (var i = 0; i < mixins.length; i++) {
          mixSpecIntoComponent(Constructor, mixins[i]);
        }
      }
    },
    childContextTypes: function(Constructor, childContextTypes) {
      if (process.env.NODE_ENV !== 'production') {
        validateTypeDef(Constructor, childContextTypes, 'childContext');
      }
      Constructor.childContextTypes = _assign(
        {},
        Constructor.childContextTypes,
        childContextTypes
      );
    },
    contextTypes: function(Constructor, contextTypes) {
      if (process.env.NODE_ENV !== 'production') {
        validateTypeDef(Constructor, contextTypes, 'context');
      }
      Constructor.contextTypes = _assign(
        {},
        Constructor.contextTypes,
        contextTypes
      );
    },
    /**
     * Special case getDefaultProps which should move into statics but requires
     * automatic merging.
     */
    getDefaultProps: function(Constructor, getDefaultProps) {
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps = createMergedResultFunction(
          Constructor.getDefaultProps,
          getDefaultProps
        );
      } else {
        Constructor.getDefaultProps = getDefaultProps;
      }
    },
    propTypes: function(Constructor, propTypes) {
      if (process.env.NODE_ENV !== 'production') {
        validateTypeDef(Constructor, propTypes, 'prop');
      }
      Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
    },
    statics: function(Constructor, statics) {
      mixStaticSpecIntoComponent(Constructor, statics);
    },
    autobind: function() {}
  };

  function validateTypeDef(Constructor, typeDef, location) {
    for (var propName in typeDef) {
      if (typeDef.hasOwnProperty(propName)) {
        // use a warning instead of an _invariant so components
        // don't show up in prod but only in __DEV__
        if (process.env.NODE_ENV !== 'production') {
          warning(
            typeof typeDef[propName] === 'function',
            '%s: %s type `%s` is invalid; it must be a function, usually from ' +
              'React.PropTypes.',
            Constructor.displayName || 'ReactClass',
            ReactPropTypeLocationNames[location],
            propName
          );
        }
      }
    }
  }

  function validateMethodOverride(isAlreadyDefined, name) {
    var specPolicy = ReactClassInterface.hasOwnProperty(name)
      ? ReactClassInterface[name]
      : null;

    // Disallow overriding of base class methods unless explicitly allowed.
    if (ReactClassMixin.hasOwnProperty(name)) {
      _invariant(
        specPolicy === 'OVERRIDE_BASE',
        'ReactClassInterface: You are attempting to override ' +
          '`%s` from your class specification. Ensure that your method names ' +
          'do not overlap with React methods.',
        name
      );
    }

    // Disallow defining methods more than once unless explicitly allowed.
    if (isAlreadyDefined) {
      _invariant(
        specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED',
        'ReactClassInterface: You are attempting to define ' +
          '`%s` on your component more than once. This conflict may be due ' +
          'to a mixin.',
        name
      );
    }
  }

  /**
   * Mixin helper which handles policy validation and reserved
   * specification keys when building React classes.
   */
  function mixSpecIntoComponent(Constructor, spec) {
    if (!spec) {
      if (process.env.NODE_ENV !== 'production') {
        var typeofSpec = typeof spec;
        var isMixinValid = typeofSpec === 'object' && spec !== null;

        if (process.env.NODE_ENV !== 'production') {
          warning(
            isMixinValid,
            "%s: You're attempting to include a mixin that is either null " +
              'or not an object. Check the mixins included by the component, ' +
              'as well as any mixins they include themselves. ' +
              'Expected object but got %s.',
            Constructor.displayName || 'ReactClass',
            spec === null ? null : typeofSpec
          );
        }
      }

      return;
    }

    _invariant(
      typeof spec !== 'function',
      "ReactClass: You're attempting to " +
        'use a component class or function as a mixin. Instead, just use a ' +
        'regular object.'
    );
    _invariant(
      !isValidElement(spec),
      "ReactClass: You're attempting to " +
        'use a component as a mixin. Instead, just use a regular object.'
    );

    var proto = Constructor.prototype;
    var autoBindPairs = proto.__reactAutoBindPairs;

    // By handling mixins before any other properties, we ensure the same
    // chaining order is applied to methods with DEFINE_MANY policy, whether
    // mixins are listed before or after these methods in the spec.
    if (spec.hasOwnProperty(MIXINS_KEY)) {
      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
    }

    for (var name in spec) {
      if (!spec.hasOwnProperty(name)) {
        continue;
      }

      if (name === MIXINS_KEY) {
        // We have already handled mixins in a special case above.
        continue;
      }

      var property = spec[name];
      var isAlreadyDefined = proto.hasOwnProperty(name);
      validateMethodOverride(isAlreadyDefined, name);

      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
        RESERVED_SPEC_KEYS[name](Constructor, property);
      } else {
        // Setup methods on prototype:
        // The following member methods should not be automatically bound:
        // 1. Expected ReactClass methods (in the "interface").
        // 2. Overridden methods (that were mixed in).
        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
        var isFunction = typeof property === 'function';
        var shouldAutoBind =
          isFunction &&
          !isReactClassMethod &&
          !isAlreadyDefined &&
          spec.autobind !== false;

        if (shouldAutoBind) {
          autoBindPairs.push(name, property);
          proto[name] = property;
        } else {
          if (isAlreadyDefined) {
            var specPolicy = ReactClassInterface[name];

            // These cases should already be caught by validateMethodOverride.
            _invariant(
              isReactClassMethod &&
                (specPolicy === 'DEFINE_MANY_MERGED' ||
                  specPolicy === 'DEFINE_MANY'),
              'ReactClass: Unexpected spec policy %s for key %s ' +
                'when mixing in component specs.',
              specPolicy,
              name
            );

            // For methods which are defined more than once, call the existing
            // methods before calling the new property, merging if appropriate.
            if (specPolicy === 'DEFINE_MANY_MERGED') {
              proto[name] = createMergedResultFunction(proto[name], property);
            } else if (specPolicy === 'DEFINE_MANY') {
              proto[name] = createChainedFunction(proto[name], property);
            }
          } else {
            proto[name] = property;
            if (process.env.NODE_ENV !== 'production') {
              // Add verbose displayName to the function, which helps when looking
              // at profiling tools.
              if (typeof property === 'function' && spec.displayName) {
                proto[name].displayName = spec.displayName + '_' + name;
              }
            }
          }
        }
      }
    }
  }

  function mixStaticSpecIntoComponent(Constructor, statics) {
    if (!statics) {
      return;
    }

    for (var name in statics) {
      var property = statics[name];
      if (!statics.hasOwnProperty(name)) {
        continue;
      }

      var isReserved = name in RESERVED_SPEC_KEYS;
      _invariant(
        !isReserved,
        'ReactClass: You are attempting to define a reserved ' +
          'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' +
          'as an instance property instead; it will still be accessible on the ' +
          'constructor.',
        name
      );

      var isAlreadyDefined = name in Constructor;
      if (isAlreadyDefined) {
        var specPolicy = ReactClassStaticInterface.hasOwnProperty(name)
          ? ReactClassStaticInterface[name]
          : null;

        _invariant(
          specPolicy === 'DEFINE_MANY_MERGED',
          'ReactClass: You are attempting to define ' +
            '`%s` on your component more than once. This conflict may be ' +
            'due to a mixin.',
          name
        );

        Constructor[name] = createMergedResultFunction(Constructor[name], property);

        return;
      }

      Constructor[name] = property;
    }
  }

  /**
   * Merge two objects, but throw if both contain the same key.
   *
   * @param {object} one The first object, which is mutated.
   * @param {object} two The second object
   * @return {object} one after it has been mutated to contain everything in two.
   */
  function mergeIntoWithNoDuplicateKeys(one, two) {
    _invariant(
      one && two && typeof one === 'object' && typeof two === 'object',
      'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'
    );

    for (var key in two) {
      if (two.hasOwnProperty(key)) {
        _invariant(
          one[key] === undefined,
          'mergeIntoWithNoDuplicateKeys(): ' +
            'Tried to merge two objects with the same key: `%s`. This conflict ' +
            'may be due to a mixin; in particular, this may be caused by two ' +
            'getInitialState() or getDefaultProps() methods returning objects ' +
            'with clashing keys.',
          key
        );
        one[key] = two[key];
      }
    }
    return one;
  }

  /**
   * Creates a function that invokes two functions and merges their return values.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createMergedResultFunction(one, two) {
    return function mergedResult() {
      var a = one.apply(this, arguments);
      var b = two.apply(this, arguments);
      if (a == null) {
        return b;
      } else if (b == null) {
        return a;
      }
      var c = {};
      mergeIntoWithNoDuplicateKeys(c, a);
      mergeIntoWithNoDuplicateKeys(c, b);
      return c;
    };
  }

  /**
   * Creates a function that invokes two functions and ignores their return vales.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createChainedFunction(one, two) {
    return function chainedFunction() {
      one.apply(this, arguments);
      two.apply(this, arguments);
    };
  }

  /**
   * Binds a method to the component.
   *
   * @param {object} component Component whose method is going to be bound.
   * @param {function} method Method to be bound.
   * @return {function} The bound method.
   */
  function bindAutoBindMethod(component, method) {
    var boundMethod = method.bind(component);
    if (process.env.NODE_ENV !== 'production') {
      boundMethod.__reactBoundContext = component;
      boundMethod.__reactBoundMethod = method;
      boundMethod.__reactBoundArguments = null;
      var componentName = component.constructor.displayName;
      var _bind = boundMethod.bind;
      boundMethod.bind = function(newThis) {
        for (
          var _len = arguments.length,
            args = Array(_len > 1 ? _len - 1 : 0),
            _key = 1;
          _key < _len;
          _key++
        ) {
          args[_key - 1] = arguments[_key];
        }

        // User is trying to bind() an autobound method; we effectively will
        // ignore the value of "this" that the user is trying to use, so
        // let's warn.
        if (newThis !== component && newThis !== null) {
          if (process.env.NODE_ENV !== 'production') {
            warning(
              false,
              'bind(): React component methods may only be bound to the ' +
                'component instance. See %s',
              componentName
            );
          }
        } else if (!args.length) {
          if (process.env.NODE_ENV !== 'production') {
            warning(
              false,
              'bind(): You are binding a component method to the component. ' +
                'React does this for you automatically in a high-performance ' +
                'way, so you can safely remove this call. See %s',
              componentName
            );
          }
          return boundMethod;
        }
        var reboundMethod = _bind.apply(boundMethod, arguments);
        reboundMethod.__reactBoundContext = component;
        reboundMethod.__reactBoundMethod = method;
        reboundMethod.__reactBoundArguments = args;
        return reboundMethod;
      };
    }
    return boundMethod;
  }

  /**
   * Binds all auto-bound methods in a component.
   *
   * @param {object} component Component whose method is going to be bound.
   */
  function bindAutoBindMethods(component) {
    var pairs = component.__reactAutoBindPairs;
    for (var i = 0; i < pairs.length; i += 2) {
      var autoBindKey = pairs[i];
      var method = pairs[i + 1];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }

  var IsMountedPreMixin = {
    componentDidMount: function() {
      this.__isMounted = true;
    }
  };

  var IsMountedPostMixin = {
    componentWillUnmount: function() {
      this.__isMounted = false;
    }
  };

  /**
   * Add more to the ReactClass base class. These are all legacy features and
   * therefore not already part of the modern ReactComponent.
   */
  var ReactClassMixin = {
    /**
     * TODO: This will be deprecated because state should always keep a consistent
     * type signature and the only use case for this, is to avoid that.
     */
    replaceState: function(newState, callback) {
      this.updater.enqueueReplaceState(this, newState, callback);
    },

    /**
     * Checks whether or not this composite component is mounted.
     * @return {boolean} True if mounted, false otherwise.
     * @protected
     * @final
     */
    isMounted: function() {
      if (process.env.NODE_ENV !== 'production') {
        warning(
          this.__didWarnIsMounted,
          '%s: isMounted is deprecated. Instead, make sure to clean up ' +
            'subscriptions and pending requests in componentWillUnmount to ' +
            'prevent memory leaks.',
          (this.constructor && this.constructor.displayName) ||
            this.name ||
            'Component'
        );
        this.__didWarnIsMounted = true;
      }
      return !!this.__isMounted;
    }
  };

  var ReactClassComponent = function() {};
  _assign(
    ReactClassComponent.prototype,
    ReactComponent.prototype,
    ReactClassMixin
  );

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  function createClass(spec) {
    // To keep our warnings more understandable, we'll use a little hack here to
    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
    // unnecessarily identify a class without displayName as 'Constructor'.
    var Constructor = identity(function(props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if (process.env.NODE_ENV !== 'production') {
        warning(
          this instanceof Constructor,
          'Something is calling a React component directly. Use a factory or ' +
            'JSX instead. See: https://fb.me/react-legacyfactory'
        );
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (process.env.NODE_ENV !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (
          initialState === undefined &&
          this.getInitialState._isMockFunction
        ) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      _invariant(
        typeof initialState === 'object' && !Array.isArray(initialState),
        '%s.getInitialState(): must return an object or null',
        Constructor.displayName || 'ReactCompositeComponent'
      );

      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, IsMountedPreMixin);
    mixSpecIntoComponent(Constructor, spec);
    mixSpecIntoComponent(Constructor, IsMountedPostMixin);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if (process.env.NODE_ENV !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    _invariant(
      Constructor.prototype.render,
      'createClass(...): Class specification must implement a `render` method.'
    );

    if (process.env.NODE_ENV !== 'production') {
      warning(
        !Constructor.prototype.componentShouldUpdate,
        '%s has a method called ' +
          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +
          'The name is phrased as a question because the function is ' +
          'expected to return a value.',
        spec.displayName || 'A component'
      );
      warning(
        !Constructor.prototype.componentWillRecieveProps,
        '%s has a method called ' +
          'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
        spec.displayName || 'A component'
      );
      warning(
        !Constructor.prototype.UNSAFE_componentWillRecieveProps,
        '%s has a method called UNSAFE_componentWillRecieveProps(). ' +
          'Did you mean UNSAFE_componentWillReceiveProps()?',
        spec.displayName || 'A component'
      );
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  }

  return createClass;
}

module.exports = factory;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 109 */,
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DatePicker = function (_Component) {
	_inherits(DatePicker, _Component);

	function DatePicker(props) {
		_classCallCheck(this, DatePicker);

		var _this = _possibleConstructorReturn(this, (DatePicker.__proto__ || Object.getPrototypeOf(DatePicker)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		// Propery to set if dateFormat has words in it like month names
		_this.hasWordFormat = _.isUndefined(_this.props.hasWordFormat) ? false : _this.props.hasWordFormat;
		return _this;
	}

	_createClass(DatePicker, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var _this2 = this;

			this.$el = jQuery(this.el);

			var value = _.isUndefined(this.props.settings[this.props.property]) ? this.props.defaultValue : this.props.settings[this.props.property];
			var dateFormat = this.props.dateFormat ? this.props.dateFormat : 'd MM yy';
			var inputId = _.isUndefined(this.props.id) ? 'forminator-field-' + this.props.property : 'forminator-field-' + this.props.id;

			if (!this.hasWordFormat) {
				this.$el.val(value);
			}

			this.$el.datepicker({
				beforeShow: function beforeShow(input, inst) {
					jQuery('#ui-datepicker-div').addClass('sui-calendar');
					if ('forminator-field-date' === _this2.$el.attr('id')) {
						if ('disable' === _this2.props.state.past_dates) {
							_this2.$el.datepicker('option', 'minDate', _this2.$el.datepicker('getDate'));
						} else if ('enable' === _this2.props.state.past_dates) {
							_this2.$el.datepicker('option', 'minDate', null);
						}
					}
				},
				dateFormat: dateFormat,
				dayNamesMin: forminatorl10n.calendar.day_names_min,
				monthNames: forminatorl10n.calendar.month_names,
				onSelect: function onSelect(date) {
					_this2.updateValue(date);
				}
			});

			if (this.hasWordFormat) {
				this.$el.datepicker('option', 'altField', '#' + inputId + '-altfield');
				this.$el.datepicker('option', 'altFormat', '@');

				if (!_.isUndefined(value)) {
					if (isNaN(value)) {
						value = new Date(value).getTime();
					}

					jQuery('#' + inputId + '-altfield').val(value);
					this.$el.datepicker('setDate', new Date(parseInt(value)));
				}
			}

			this.updateValue = this.updateValue.bind(this);
		}
	}, {
		key: 'updateValue',
		value: function updateValue(value) {

			if (this.hasWordFormat) {
				value = jQuery(this.$el.datepicker("option", "altField")).val();
			}

			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.$el.datepicker('destroy');
			this.$el.unbind().removeData();
		}
	}, {
		key: 'render',
		value: function render() {
			var _this3 = this;

			var customClass = !_.isUndefined(this.props.customClass) ? this.props.customClass : 'sui-form-control';

			var calendarIcon = !_.isUndefined(this.props.calendarIcon) ? this.props.calendarIcon : 'right';

			var fieldClass = 'sui-form-field';
			if (!_.isUndefined(this.props.fieldClass)) {
				fieldClass += ' ' + this.props.fieldClass;
			}
			if (this.props.mediumSize) {
				fieldClass += ' sui-input-md';
			}

			var fieldLabel = void 0;
			var iconButton = void 0;

			if (this.props.label) {
				fieldLabel = _react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-field-' + this.props.property, className: 'sui-label' },
					this.props.label,
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						this.props.note
					)
				);
			}

			if (this.props.canTrash) {
				iconButton = _react2.default.createElement(
					'button',
					{ className: 'sui-button-icon' },
					_react2.default.createElement('i', { className: 'sui-icon-trash', 'aria-hidden': 'true' }),
					_react2.default.createElement(
						'span',
						{ className: 'sui-screen-reader-text' },
						(0, _utils.translate)('Remove this date range')
					)
				);
			}

			if (this.props.canAdd) {
				iconButton = _react2.default.createElement(
					'button',
					{ className: 'sui-button-icon' },
					_react2.default.createElement('i', { className: 'sui-icon-plus', 'aria-hidden': 'true' }),
					_react2.default.createElement(
						'span',
						{ className: 'sui-screen-reader-text' },
						(0, _utils.translate)('Add selected date')
					)
				);
			}
			var inputId = _.isUndefined(this.props.id) ? 'forminator-field-' + this.props.property : 'forminator-field-' + this.props.id;

			var dateInput = _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement('input', _extends({
					ref: function ref(el) {
						return _this3.el = el;
					},
					id: inputId,
					className: customClass,
					placeholder: this.props.placeholder,
					type: 'text',
					autoComplete: 'off'
				}, this.props.onlyRead && { 'readonly="readonly"': '' })),
				this.hasWordFormat && _react2.default.createElement('input', {
					id: inputId + '-altfield',
					style: { display: 'none' }
				})
			);

			var dateField = _react2.default.createElement(
				'div',
				{ className: fieldClass },
				fieldLabel,
				this.props.noCalendar ? dateInput : _react2.default.createElement(
					'div',
					{ className: 'sui-date' },
					'left' === calendarIcon && _react2.default.createElement('i', { className: 'sui-icon-calendar', 'aria-hidden': 'true' }),
					dateInput,
					'right' === calendarIcon && _react2.default.createElement('i', { className: 'sui-icon-calendar', 'aria-hidden': 'true' })
				),
				_react2.default.createElement('div', { id: inputId + '-calendar', className: 'sui-date-calendar' }),
				this.props.description && _react2.default.createElement(
					'span',
					{ className: 'sui-description' },
					this.props.description
				)
			);

			if (this.props.multiDate) {
				dateField = _react2.default.createElement(
					'div',
					{ className: 'sui-multi-date' },
					_react2.default.createElement(
						'div',
						{ className: fieldClass },
						fieldLabel,
						this.props.noCalendar ? dateInput : _react2.default.createElement(
							'div',
							{ className: 'sui-date' },
							dateInput,
							_react2.default.createElement('i', { className: 'sui-icon-calendar', 'aria-hidden': 'true' })
						),
						this.props.description && _react2.default.createElement(
							'span',
							{ className: 'sui-description' },
							this.props.description
						)
					),
					iconButton
				);
			}

			return dateField;
		}
	}]);

	return DatePicker;
}(_react.Component);

exports.default = DatePicker;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(200);
} else {
  module.exports = __webpack_require__(201);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
function createThunkMiddleware(extraArgument) {
  return function (_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (action) {
        if (typeof action === 'function') {
          return action(dispatch, getState, extraArgument);
        }

        return next(action);
      };
    };
  };
}

var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

/* harmony default export */ __webpack_exports__["default"] = (thunk);

/***/ }),
/* 113 */,
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RadioOptions = function (_Component) {
	_inherits(RadioOptions, _Component);

	function RadioOptions(props) {
		_classCallCheck(this, RadioOptions);

		return _possibleConstructorReturn(this, (RadioOptions.__proto__ || Object.getPrototypeOf(RadioOptions)).call(this, props));
	}

	_createClass(RadioOptions, [{
		key: 'updateValue',
		value: function updateValue(value) {
			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var radioClass = !_.isUndefined(this.props.radioClass) ? 'sui-radio ' + this.props.radioClass : 'sui-radio';

			var value = _.isUndefined(this.props.settings[this.props.property]) ? this.props.defaultValue : this.props.settings[this.props.property];

			var radioOptions = _react2.default.Children.map(this.props.children, function (tab) {
				var optionImage = '';
				var optionLabel = !_.isUndefined(tab.props.label) ? tab.props.label : tab.props.children;

				if (tab.props.image1x && tab.props.image2x) {
					optionImage = _react2.default.createElement('img', { src: forminatorData.imagesUrl + '/' + tab.props.image1x,
						srcSet: forminatorData.imagesUrl + '/' + tab.props.image1x + ' 1x,\n\t\t\t\t\t\t\t' + forminatorData.imagesUrl + '/' + tab.props.image2x + ' 2x',
						'aria-hidden': 'true' });
				}

				if (tab.props.image1x && !tab.props.image2x) {
					optionImage = _react2.default.createElement('img', { src: forminatorData.imagesUrl + '/' + tab.props.image1x,
						'aria-hidden': 'true' });
				}

				if (tab.props.image2x && !tab.props.image1x) {
					optionImage = _react2.default.createElement('img', { src: forminatorData.imagesUrl + '/' + tab.props.image2x,
						srcSet: forminatorData.imagesUrl + '/' + tab.props.image2x + ' 2x',
						'aria-hidden': 'true' });
				}

				if (tab.props.hasImage) {
					return _react2.default.createElement(
						'label',
						{ htmlFor: 'forminator-field-' + tab.props.value,
							className: 'sui-radio-image' },
						optionImage,
						_react2.default.createElement(
							'span',
							{ className: radioClass },
							_react2.default.createElement('input', { type: 'radio',
								name: 'forminator-' + _this2.props.property,
								value: tab.props.value,
								id: 'forminator-field-' + tab.props.value,
								checked: value === tab.props.value,
								onChange: _this2.updateValue.bind(_this2, tab.props.value)
							}),
							_react2.default.createElement('span', { 'aria-hidden': 'true' }),
							_react2.default.createElement(
								'span',
								null,
								optionLabel
							)
						)
					);
				}

				if (!tab.props.hasImage) {
					return _react2.default.createElement(
						'label',
						{ htmlFor: 'forminator-field-' + tab.props.value,
							className: radioClass },
						_react2.default.createElement('input', { type: 'radio',
							name: 'forminator-' + _this2.props.property,
							id: 'forminator-field-' + tab.props.value,
							value: tab.props.value,
							checked: value === tab.props.value,
							onChange: _this2.updateValue.bind(_this2, tab.props.value)
						}),
						_react2.default.createElement('span', { 'aria-hidden': 'true' }),
						_react2.default.createElement(
							'span',
							null,
							optionLabel
						)
					);
				}
			});

			var radioContent = _react2.default.Children.map(this.props.children, function (tab) {
				if ('true' === _this2.props.radioContent && !_.isUndefined(tab.props.children)) {
					return _react2.default.createElement(
						'div',
						{
							className: 'sui-border-frame' + (tab.props.value === value ? '' : ' sui-hidden'),
							style: { marginLeft: '0' }
						},
						tab.props.value === value && tab
					);
				}

				return _react2.default.createElement(_react2.default.Fragment, null);
			});

			var label = '';

			if (this.props.label && '' !== this.props.label) {
				label = _react2.default.createElement(
					'label',
					{ className: 'sui-label' },
					this.props.label,
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						this.props.note
					)
				);
			}

			var description = '';

			if (this.props.description && '' !== this.props.description) {
				description = _react2.default.createElement(
					'span',
					{
						className: 'sui-description',
						style: { marginBottom: '10px' }
					},
					this.props.description
				);
			}

			var settingsLabel = '';

			if (this.props.settingsLabel && '' !== this.props.settingsLabel) {
				settingsLabel = _react2.default.createElement(
					'label',
					{ className: 'sui-settings-label' },
					this.props.settingsLabel
				);
			}

			var settingsDescription = '';

			if (this.props.settingsDesc && '' !== this.props.settingsDesc) {
				settingsDescription = _react2.default.createElement(
					'span',
					{
						className: 'sui-description',
						style: { marginBottom: '10px' }
					},
					this.props.settingsDesc
				);
			}

			if (!this.props.noWrapper) {
				return _react2.default.createElement(
					_react2.default.Fragment,
					null,
					_react2.default.createElement(
						'div',
						{ role: 'radiogroup', className: 'sui-form-field' },
						label,
						settingsLabel,
						description,
						settingsDescription,
						radioOptions,
						radioContent
					)
				);
			}

			return radioOptions;
		}
	}]);

	return RadioOptions;
}(_react.Component);

exports.default = RadioOptions;

/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (immutable) */ __webpack_exports__["a"] = createProvider;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_PropTypes__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_warning__ = __webpack_require__(45);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var didWarnAboutReceivingStore = false;
function warnAboutReceivingStore() {
  if (didWarnAboutReceivingStore) {
    return;
  }
  didWarnAboutReceivingStore = true;

  Object(__WEBPACK_IMPORTED_MODULE_3__utils_warning__["a" /* default */])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
}

function createProvider() {
  var _Provider$childContex;

  var storeKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'store';
  var subKey = arguments[1];

  var subscriptionKey = subKey || storeKey + 'Subscription';

  var Provider = function (_Component) {
    _inherits(Provider, _Component);

    Provider.prototype.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[storeKey] = this[storeKey], _ref[subscriptionKey] = null, _ref;
    };

    function Provider(props, context) {
      _classCallCheck(this, Provider);

      var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

      _this[storeKey] = props.store;
      return _this;
    }

    Provider.prototype.render = function render() {
      return __WEBPACK_IMPORTED_MODULE_0_react__["Children"].only(this.props.children);
    };

    return Provider;
  }(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]);

  if (process.env.NODE_ENV !== 'production') {
    Provider.prototype.componentWillReceiveProps = function (nextProps) {
      if (this[storeKey] !== nextProps.store) {
        warnAboutReceivingStore();
      }
    };
  }

  Provider.propTypes = {
    store: __WEBPACK_IMPORTED_MODULE_2__utils_PropTypes__["a" /* storeShape */].isRequired,
    children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element.isRequired
  };
  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[storeKey] = __WEBPACK_IMPORTED_MODULE_2__utils_PropTypes__["a" /* storeShape */].isRequired, _Provider$childContex[subscriptionKey] = __WEBPACK_IMPORTED_MODULE_2__utils_PropTypes__["b" /* subscriptionShape */], _Provider$childContex);

  return Provider;
}

/* harmony default export */ __webpack_exports__["b"] = (createProvider());
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)))

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var assign = __webpack_require__(62);

var ReactPropTypesSecret = __webpack_require__(44);
var checkPropTypes = __webpack_require__(117);

var printWarning = function() {};

if (process.env.NODE_ENV !== 'production') {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (process.env.NODE_ENV !== 'production') {
  var ReactPropTypesSecret = __webpack_require__(44);
  var loggedTypeFailures = {};

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          )

        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

module.exports = checkPropTypes;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(44);

function emptyFunction() {}

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Subscription; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// encapsulates the subscription logic for connecting a component to the redux store, as
// well as nesting subscriptions of descendant components, so that we can ensure the
// ancestor components re-render before descendants

var CLEARED = null;
var nullListeners = {
  notify: function notify() {}
};

function createListenerCollection() {
  // the current/next pattern is copied from redux's createStore code.
  // TODO: refactor+expose that code to be reusable here?
  var current = [];
  var next = [];

  return {
    clear: function clear() {
      next = CLEARED;
      current = CLEARED;
    },
    notify: function notify() {
      var listeners = current = next;
      for (var i = 0; i < listeners.length; i++) {
        listeners[i]();
      }
    },
    get: function get() {
      return next;
    },
    subscribe: function subscribe(listener) {
      var isSubscribed = true;
      if (next === current) next = current.slice();
      next.push(listener);

      return function unsubscribe() {
        if (!isSubscribed || current === CLEARED) return;
        isSubscribed = false;

        if (next === current) next = current.slice();
        next.splice(next.indexOf(listener), 1);
      };
    }
  };
}

var Subscription = function () {
  function Subscription(store, parentSub, onStateChange) {
    _classCallCheck(this, Subscription);

    this.store = store;
    this.parentSub = parentSub;
    this.onStateChange = onStateChange;
    this.unsubscribe = null;
    this.listeners = nullListeners;
  }

  Subscription.prototype.addNestedSub = function addNestedSub(listener) {
    this.trySubscribe();
    return this.listeners.subscribe(listener);
  };

  Subscription.prototype.notifyNestedSubs = function notifyNestedSubs() {
    this.listeners.notify();
  };

  Subscription.prototype.isSubscribed = function isSubscribed() {
    return Boolean(this.unsubscribe);
  };

  Subscription.prototype.trySubscribe = function trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);

      this.listeners = createListenerCollection();
    }
  };

  Subscription.prototype.tryUnsubscribe = function tryUnsubscribe() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
      this.listeners.clear();
      this.listeners = nullListeners;
    }
  };

  return Subscription;
}();



/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export createConnect */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_connectAdvanced__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_shallowEqual__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mapDispatchToProps__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mapStateToProps__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__mergeProps__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__selectorFactory__ = __webpack_require__(137);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }








/*
  connect is a facade over connectAdvanced. It turns its args into a compatible
  selectorFactory, which has the signature:

    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
  
  connect passes its args to connectAdvanced as options, which will in turn pass them to
  selectorFactory each time a Connect component instance is instantiated or hot reloaded.

  selectorFactory returns a final props selector from its mapStateToProps,
  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
  mergePropsFactories, and pure args.

  The resulting final props selector is called by the Connect component instance whenever
  it receives new props or store state.
 */

function match(arg, factories, name) {
  for (var i = factories.length - 1; i >= 0; i--) {
    var result = factories[i](arg);
    if (result) return result;
  }

  return function (dispatch, options) {
    throw new Error('Invalid value of type ' + typeof arg + ' for ' + name + ' argument when connecting component ' + options.wrappedComponentName + '.');
  };
}

function strictEqual(a, b) {
  return a === b;
}

// createConnect with default args builds the 'official' connect behavior. Calling it with
// different options opens up some testing and extensibility scenarios
function createConnect() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$connectHOC = _ref.connectHOC,
      connectHOC = _ref$connectHOC === undefined ? __WEBPACK_IMPORTED_MODULE_0__components_connectAdvanced__["a" /* default */] : _ref$connectHOC,
      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
      mapStateToPropsFactories = _ref$mapStateToPropsF === undefined ? __WEBPACK_IMPORTED_MODULE_3__mapStateToProps__["a" /* default */] : _ref$mapStateToPropsF,
      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
      mapDispatchToPropsFactories = _ref$mapDispatchToPro === undefined ? __WEBPACK_IMPORTED_MODULE_2__mapDispatchToProps__["a" /* default */] : _ref$mapDispatchToPro,
      _ref$mergePropsFactor = _ref.mergePropsFactories,
      mergePropsFactories = _ref$mergePropsFactor === undefined ? __WEBPACK_IMPORTED_MODULE_4__mergeProps__["a" /* default */] : _ref$mergePropsFactor,
      _ref$selectorFactory = _ref.selectorFactory,
      selectorFactory = _ref$selectorFactory === undefined ? __WEBPACK_IMPORTED_MODULE_5__selectorFactory__["a" /* default */] : _ref$selectorFactory;

  return function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
    var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref2$pure = _ref2.pure,
        pure = _ref2$pure === undefined ? true : _ref2$pure,
        _ref2$areStatesEqual = _ref2.areStatesEqual,
        areStatesEqual = _ref2$areStatesEqual === undefined ? strictEqual : _ref2$areStatesEqual,
        _ref2$areOwnPropsEqua = _ref2.areOwnPropsEqual,
        areOwnPropsEqual = _ref2$areOwnPropsEqua === undefined ? __WEBPACK_IMPORTED_MODULE_1__utils_shallowEqual__["a" /* default */] : _ref2$areOwnPropsEqua,
        _ref2$areStatePropsEq = _ref2.areStatePropsEqual,
        areStatePropsEqual = _ref2$areStatePropsEq === undefined ? __WEBPACK_IMPORTED_MODULE_1__utils_shallowEqual__["a" /* default */] : _ref2$areStatePropsEq,
        _ref2$areMergedPropsE = _ref2.areMergedPropsEqual,
        areMergedPropsEqual = _ref2$areMergedPropsE === undefined ? __WEBPACK_IMPORTED_MODULE_1__utils_shallowEqual__["a" /* default */] : _ref2$areMergedPropsE,
        extraOptions = _objectWithoutProperties(_ref2, ['pure', 'areStatesEqual', 'areOwnPropsEqual', 'areStatePropsEqual', 'areMergedPropsEqual']);

    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');

    return connectHOC(selectorFactory, _extends({
      // used in error messages
      methodName: 'connect',

      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function getDisplayName(name) {
        return 'Connect(' + name + ')';
      },

      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),

      // passed through to selectorFactory
      initMapStateToProps: initMapStateToProps,
      initMapDispatchToProps: initMapDispatchToProps,
      initMergeProps: initMergeProps,
      pure: pure,
      areStatesEqual: areStatesEqual,
      areOwnPropsEqual: areOwnPropsEqual,
      areStatePropsEqual: areStatePropsEqual,
      areMergedPropsEqual: areMergedPropsEqual

    }, extraOptions));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (createConnect());

/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = shallowEqual;
var hasOwn = Object.prototype.hasOwnProperty;

function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) return false;

  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export whenMapDispatchToPropsIsFunction */
/* unused harmony export whenMapDispatchToPropsIsMissing */
/* unused harmony export whenMapDispatchToPropsIsObject */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_redux__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__wrapMapToProps__ = __webpack_require__(71);



function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return typeof mapDispatchToProps === 'function' ? Object(__WEBPACK_IMPORTED_MODULE_1__wrapMapToProps__["b" /* wrapMapToPropsFunc */])(mapDispatchToProps, 'mapDispatchToProps') : undefined;
}

function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return !mapDispatchToProps ? Object(__WEBPACK_IMPORTED_MODULE_1__wrapMapToProps__["a" /* wrapMapToPropsConstant */])(function (dispatch) {
    return { dispatch: dispatch };
  }) : undefined;
}

function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? Object(__WEBPACK_IMPORTED_MODULE_1__wrapMapToProps__["a" /* wrapMapToPropsConstant */])(function (dispatch) {
    return Object(__WEBPACK_IMPORTED_MODULE_0_redux__["bindActionCreators"])(mapDispatchToProps, dispatch);
  }) : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = ([whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject]);

/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ponyfill_js__ = __webpack_require__(125);
/* global window */


var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {
  root = Function('return this')();
}

var result = Object(__WEBPACK_IMPORTED_MODULE_0__ponyfill_js__["a" /* default */])(root);
/* harmony default export */ __webpack_exports__["a"] = (result);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(42), __webpack_require__(124)(module)))

/***/ }),
/* 124 */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if(!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true,
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};


/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getPrototype_js__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__ = __webpack_require__(134);




/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!Object(__WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__["a" /* default */])(value) || Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a" /* default */])(value) != objectTag) {
    return false;
  }
  var proto = Object(__WEBPACK_IMPORTED_MODULE_1__getPrototype_js__["a" /* default */])(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/* harmony default export */ __webpack_exports__["a"] = (isPlainObject);


/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getRawTag_js__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__objectToString_js__ = __webpack_require__(131);




/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */].toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? Object(__WEBPACK_IMPORTED_MODULE_1__getRawTag_js__["a" /* default */])(value)
    : Object(__WEBPACK_IMPORTED_MODULE_2__objectToString_js__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (baseGetTag);


/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__ = __webpack_require__(129);


/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__["a" /* default */] || freeSelf || Function('return this')();

/* harmony default export */ __webpack_exports__["a"] = (root);


/***/ }),
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/* harmony default export */ __webpack_exports__["a"] = (freeGlobal);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(42)))

/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(73);


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */].toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (getRawTag);


/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/* harmony default export */ __webpack_exports__["a"] = (objectToString);


/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__overArg_js__ = __webpack_require__(133);


/** Built-in value references. */
var getPrototype = Object(__WEBPACK_IMPORTED_MODULE_0__overArg_js__["a" /* default */])(Object.getPrototypeOf, Object);

/* harmony default export */ __webpack_exports__["a"] = (getPrototype);


/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (overArg);


/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ __webpack_exports__["a"] = (isObjectLike);


/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export whenMapStateToPropsIsFunction */
/* unused harmony export whenMapStateToPropsIsMissing */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__wrapMapToProps__ = __webpack_require__(71);


function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === 'function' ? Object(__WEBPACK_IMPORTED_MODULE_0__wrapMapToProps__["b" /* wrapMapToPropsFunc */])(mapStateToProps, 'mapStateToProps') : undefined;
}

function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? Object(__WEBPACK_IMPORTED_MODULE_0__wrapMapToProps__["a" /* wrapMapToPropsConstant */])(function () {
    return {};
  }) : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = ([whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]);

/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export defaultMergeProps */
/* unused harmony export wrapMergePropsFunc */
/* unused harmony export whenMergePropsIsFunction */
/* unused harmony export whenMergePropsIsOmitted */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_verifyPlainObject__ = __webpack_require__(72);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return _extends({}, ownProps, stateProps, dispatchProps);
}

function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, _ref) {
    var displayName = _ref.displayName,
        pure = _ref.pure,
        areMergedPropsEqual = _ref.areMergedPropsEqual;

    var hasRunOnce = false;
    var mergedProps = void 0;

    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;

        if (process.env.NODE_ENV !== 'production') Object(__WEBPACK_IMPORTED_MODULE_0__utils_verifyPlainObject__["a" /* default */])(mergedProps, displayName, 'mergeProps');
      }

      return mergedProps;
    };
  };
}

function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
}

function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? function () {
    return defaultMergeProps;
  } : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = ([whenMergePropsIsFunction, whenMergePropsIsOmitted]);
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)))

/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export impureFinalPropsSelectorFactory */
/* unused harmony export pureFinalPropsSelectorFactory */
/* harmony export (immutable) */ __webpack_exports__["a"] = finalPropsSelectorFactory;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__verifySubselectors__ = __webpack_require__(138);
function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }



function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
  };
}

function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
  var areStatesEqual = _ref.areStatesEqual,
      areOwnPropsEqual = _ref.areOwnPropsEqual,
      areStatePropsEqual = _ref.areStatePropsEqual;

  var hasRunAtLeastOnce = false;
  var state = void 0;
  var ownProps = void 0;
  var stateProps = void 0;
  var dispatchProps = void 0;
  var mergedProps = void 0;

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;

    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);

    return mergedProps;
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state);
    state = nextState;
    ownProps = nextOwnProps;

    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}

// TODO: Add more comments

// If pure is true, the selector returned by selectorFactory will memoize its results,
// allowing connectAdvanced's shouldComponentUpdate to return false if final
// props have not changed. If false, the selector will always return a new
// object and shouldComponentUpdate will always return true.

function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps,
      initMapDispatchToProps = _ref2.initMapDispatchToProps,
      initMergeProps = _ref2.initMergeProps,
      options = _objectWithoutProperties(_ref2, ['initMapStateToProps', 'initMapDispatchToProps', 'initMergeProps']);

  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  var mergeProps = initMergeProps(dispatch, options);

  if (process.env.NODE_ENV !== 'production') {
    Object(__WEBPACK_IMPORTED_MODULE_0__verifySubselectors__["a" /* default */])(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName);
  }

  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;

  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)))

/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = verifySubselectors;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_warning__ = __webpack_require__(45);


function verify(selector, methodName, displayName) {
  if (!selector) {
    throw new Error('Unexpected value for ' + methodName + ' in ' + displayName + '.');
  } else if (methodName === 'mapStateToProps' || methodName === 'mapDispatchToProps') {
    if (!selector.hasOwnProperty('dependsOnOwnProps')) {
      Object(__WEBPACK_IMPORTED_MODULE_0__utils_warning__["a" /* default */])('The selector for ' + methodName + ' of ' + displayName + ' did not specify a value for dependsOnOwnProps.');
    }
  }
}

function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
  verify(mapStateToProps, 'mapStateToProps', displayName);
  verify(mapDispatchToProps, 'mapDispatchToProps', displayName);
  verify(mergeProps, 'mergeProps', displayName);
}

/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Router__ = __webpack_require__(47);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter = function (_React$Component) {
  _inherits(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, BrowserRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = Object(__WEBPACK_IMPORTED_MODULE_3_history__["a" /* createBrowserHistory */])(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  BrowserRouter.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!this.props.history, "<BrowserRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { BrowserRouter as Router }`.");
  };

  BrowserRouter.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__Router__["a" /* default */], { history: this.history, children: this.props.children });
  };

  return BrowserRouter;
}(__WEBPACK_IMPORTED_MODULE_1_react___default.a.Component);

BrowserRouter.propTypes = {
  basename: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.string,
  forceRefresh: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.bool,
  getUserConfirmation: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.func,
  keyLength: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.number,
  children: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.node
};


/* harmony default export */ __webpack_exports__["a"] = (BrowserRouter);

/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LocationUtils__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__PathUtils__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__createTransitionManager__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__DOMUtils__ = __webpack_require__(74);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  __WEBPACK_IMPORTED_MODULE_1_invariant___default()(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["b" /* canUseDOM */], 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["g" /* supportsHistory */])();
  var needsHashChangeListener = !Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["h" /* supportsPopStateOnHashChange */])();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? __WEBPACK_IMPORTED_MODULE_5__DOMUtils__["c" /* getConfirmation */] : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["g" /* stripTrailingSlash */])(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */])(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;


    var path = pathname + search + hash;

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!basename || Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["c" /* hasBasename */])(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["e" /* stripBasename */])(path, basename);

    return Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = Object(__WEBPACK_IMPORTED_MODULE_4__createTransitionManager__["a" /* default */])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if (Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["d" /* isExtraneousPopstateEvent */])(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location);
  };

  var push = function push(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        __WEBPACK_IMPORTED_MODULE_0_warning___default()(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        __WEBPACK_IMPORTED_MODULE_0_warning___default()(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["a" /* addEventListener */])(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["a" /* addEventListener */])(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["e" /* removeEventListener */])(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["e" /* removeEventListener */])(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ __webpack_exports__["a"] = (createBrowserHistory);

/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to) {
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var toParts = to && to.split('/') || [];
  var fromParts = from && from.split('/') || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash = void 0;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) {
    fromParts.unshift('..');
  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (resolvePathname);

/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function valueEqual(a, b) {
  if (a === b) return true;

  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return valueEqual(item, b[index]);
    });
  }

  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (aType !== bType) return false;

  if (aType === 'object') {
    var aValue = a.valueOf();
    var bValue = b.valueOf();

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) return false;

    return aKeys.every(function (key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
}

/* harmony default export */ __webpack_exports__["a"] = (valueEqual);

/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LocationUtils__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__PathUtils__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__createTransitionManager__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__DOMUtils__ = __webpack_require__(74);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["f" /* stripLeadingSlash */])(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: __WEBPACK_IMPORTED_MODULE_3__PathUtils__["f" /* stripLeadingSlash */],
    decodePath: __WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */]
  },
  slash: {
    encodePath: __WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */],
    decodePath: __WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */]
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  __WEBPACK_IMPORTED_MODULE_1_invariant___default()(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["b" /* canUseDOM */], 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["f" /* supportsGoWithoutReloadUsingHash */])();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? __WEBPACK_IMPORTED_MODULE_5__DOMUtils__["c" /* getConfirmation */] : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["g" /* stripTrailingSlash */])(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */])(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;


  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!basename || Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["c" /* hasBasename */])(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["e" /* stripBasename */])(path, basename);

    return Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path);
  };

  var transitionManager = Object(__WEBPACK_IMPORTED_MODULE_4__createTransitionManager__["a" /* default */])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["b" /* locationsAreEqual */])(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location));
  };

  var push = function push(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        __WEBPACK_IMPORTED_MODULE_0_warning___default()(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["a" /* addEventListener */])(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["e" /* removeEventListener */])(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ __webpack_exports__["a"] = (createHashHistory);

/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__PathUtils__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LocationUtils__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__createTransitionManager__ = __webpack_require__(46);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };






var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


  var transitionManager = Object(__WEBPACK_IMPORTED_MODULE_3__createTransitionManager__["a" /* default */])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(entry, undefined, createKey()) : Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = __WEBPACK_IMPORTED_MODULE_1__PathUtils__["b" /* createPath */];

  var push = function push(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ __webpack_exports__["a"] = (createMemoryHistory);

/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Router__ = __webpack_require__(47);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter = function (_React$Component) {
  _inherits(HashRouter, _React$Component);

  function HashRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, HashRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = Object(__WEBPACK_IMPORTED_MODULE_3_history__["b" /* createHashHistory */])(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  HashRouter.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!this.props.history, "<HashRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { HashRouter as Router }`.");
  };

  HashRouter.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__Router__["a" /* default */], { history: this.history, children: this.props.children });
  };

  return HashRouter;
}(__WEBPACK_IMPORTED_MODULE_1_react___default.a.Component);

HashRouter.propTypes = {
  basename: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.string,
  getUserConfirmation: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.func,
  hashType: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.oneOf(["hashbang", "noslash", "slash"]),
  children: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.node
};


/* harmony default export */ __webpack_exports__["a"] = (HashRouter);

/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_MemoryRouter__ = __webpack_require__(147);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_MemoryRouter__["a" /* default */]);

/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Router__ = __webpack_require__(48);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter = function (_React$Component) {
  _inherits(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, MemoryRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = Object(__WEBPACK_IMPORTED_MODULE_3_history__["d" /* createMemoryHistory */])(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  MemoryRouter.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!this.props.history, "<MemoryRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { MemoryRouter as Router }`.");
  };

  MemoryRouter.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__Router__["a" /* default */], { history: this.history, children: this.props.children });
  };

  return MemoryRouter;
}(__WEBPACK_IMPORTED_MODULE_1_react___default.a.Component);

MemoryRouter.propTypes = {
  initialEntries: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.array,
  initialIndex: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.number,
  getUserConfirmation: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.func,
  keyLength: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.number,
  children: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.node
};


/* harmony default export */ __webpack_exports__["a"] = (MemoryRouter);

/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Route__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Link__ = __webpack_require__(75);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






/**
 * A <Link> wrapper that knows if it's "active" or not.
 */
var NavLink = function NavLink(_ref) {
  var to = _ref.to,
      exact = _ref.exact,
      strict = _ref.strict,
      location = _ref.location,
      activeClassName = _ref.activeClassName,
      className = _ref.className,
      activeStyle = _ref.activeStyle,
      style = _ref.style,
      getIsActive = _ref.isActive,
      ariaCurrent = _ref["aria-current"],
      rest = _objectWithoutProperties(_ref, ["to", "exact", "strict", "location", "activeClassName", "className", "activeStyle", "style", "isActive", "aria-current"]);

  var path = (typeof to === "undefined" ? "undefined" : _typeof(to)) === "object" ? to.pathname : to;

  // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202
  var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__Route__["a" /* default */], {
    path: escapedPath,
    exact: exact,
    strict: strict,
    location: location,
    children: function children(_ref2) {
      var location = _ref2.location,
          match = _ref2.match;

      var isActive = !!(getIsActive ? getIsActive(match, location) : match);

      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__Link__["a" /* default */], _extends({
        to: to,
        className: isActive ? [className, activeClassName].filter(function (i) {
          return i;
        }).join(" ") : className,
        style: isActive ? _extends({}, style, activeStyle) : style,
        "aria-current": isActive && ariaCurrent || null
      }, rest));
    }
  });
};

NavLink.propTypes = {
  to: __WEBPACK_IMPORTED_MODULE_3__Link__["a" /* default */].propTypes.to,
  exact: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  strict: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  location: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  activeClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  className: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  activeStyle: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  style: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  isActive: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  "aria-current": __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(["page", "step", "location", "date", "time", "true"])
};

NavLink.defaultProps = {
  activeClassName: "active",
  "aria-current": "page"
};

/* harmony default export */ __webpack_exports__["a"] = (NavLink);

/***/ }),
/* 149 */
/***/ (function(module, exports) {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Prompt__ = __webpack_require__(151);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Prompt__["a" /* default */]);

/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_invariant__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * The public API for prompting the user before navigating away
 * from a screen with a component.
 */

var Prompt = function (_React$Component) {
  _inherits(Prompt, _React$Component);

  function Prompt() {
    _classCallCheck(this, Prompt);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Prompt.prototype.enable = function enable(message) {
    if (this.unblock) this.unblock();

    this.unblock = this.context.router.history.block(message);
  };

  Prompt.prototype.disable = function disable() {
    if (this.unblock) {
      this.unblock();
      this.unblock = null;
    }
  };

  Prompt.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_2_invariant___default()(this.context.router, "You should not use <Prompt> outside a <Router>");

    if (this.props.when) this.enable(this.props.message);
  };

  Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.when) {
      if (!this.props.when || this.props.message !== nextProps.message) this.enable(nextProps.message);
    } else {
      this.disable();
    }
  };

  Prompt.prototype.componentWillUnmount = function componentWillUnmount() {
    this.disable();
  };

  Prompt.prototype.render = function render() {
    return null;
  };

  return Prompt;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Prompt.propTypes = {
  when: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  message: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string]).isRequired
};
Prompt.defaultProps = {
  when: true
};
Prompt.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    history: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
      block: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired
    }).isRequired
  }).isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Prompt);

/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Redirect__ = __webpack_require__(153);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Redirect__["a" /* default */]);

/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_warning__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_history__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__generatePath__ = __webpack_require__(79);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








/**
 * The public API for updating the location programmatically
 * with a component.
 */

var Redirect = function (_React$Component) {
  _inherits(Redirect, _React$Component);

  function Redirect() {
    _classCallCheck(this, Redirect);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Redirect.prototype.isStatic = function isStatic() {
    return this.context.router && this.context.router.staticContext;
  };

  Redirect.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_3_invariant___default()(this.context.router, "You should not use <Redirect> outside a <Router>");

    if (this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidMount = function componentDidMount() {
    if (!this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var prevTo = Object(__WEBPACK_IMPORTED_MODULE_4_history__["c" /* createLocation */])(prevProps.to);
    var nextTo = Object(__WEBPACK_IMPORTED_MODULE_4_history__["c" /* createLocation */])(this.props.to);

    if (Object(__WEBPACK_IMPORTED_MODULE_4_history__["f" /* locationsAreEqual */])(prevTo, nextTo)) {
      __WEBPACK_IMPORTED_MODULE_2_warning___default()(false, "You tried to redirect to the same route you're currently on: " + ("\"" + nextTo.pathname + nextTo.search + "\""));
      return;
    }

    this.perform();
  };

  Redirect.prototype.computeTo = function computeTo(_ref) {
    var computedMatch = _ref.computedMatch,
        to = _ref.to;

    if (computedMatch) {
      if (typeof to === "string") {
        return Object(__WEBPACK_IMPORTED_MODULE_5__generatePath__["a" /* default */])(to, computedMatch.params);
      } else {
        return _extends({}, to, {
          pathname: Object(__WEBPACK_IMPORTED_MODULE_5__generatePath__["a" /* default */])(to.pathname, computedMatch.params)
        });
      }
    }

    return to;
  };

  Redirect.prototype.perform = function perform() {
    var history = this.context.router.history;
    var push = this.props.push;

    var to = this.computeTo(this.props);

    if (push) {
      history.push(to);
    } else {
      history.replace(to);
    }
  };

  Redirect.prototype.render = function render() {
    return null;
  };

  return Redirect;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Redirect.propTypes = {
  computedMatch: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object, // private, from <Switch>
  push: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  from: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  to: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object]).isRequired
};
Redirect.defaultProps = {
  push: false
};
Redirect.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    history: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
      push: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
      replace: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired
    }).isRequired,
    staticContext: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object
  }).isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Redirect);

/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_StaticRouter__ = __webpack_require__(155);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_StaticRouter__["a" /* default */]);

/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_history__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Router__ = __webpack_require__(48);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
};

var addBasename = function addBasename(basename, location) {
  if (!basename) return location;

  return _extends({}, location, {
    pathname: addLeadingSlash(basename) + location.pathname
  });
};

var stripBasename = function stripBasename(basename, location) {
  if (!basename) return location;

  var base = addLeadingSlash(basename);

  if (location.pathname.indexOf(base) !== 0) return location;

  return _extends({}, location, {
    pathname: location.pathname.substr(base.length)
  });
};

var createURL = function createURL(location) {
  return typeof location === "string" ? location : Object(__WEBPACK_IMPORTED_MODULE_4_history__["e" /* createPath */])(location);
};

var staticHandler = function staticHandler(methodName) {
  return function () {
    __WEBPACK_IMPORTED_MODULE_1_invariant___default()(false, "You cannot %s with <StaticRouter>", methodName);
  };
};

var noop = function noop() {};

/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */

var StaticRouter = function (_React$Component) {
  _inherits(StaticRouter, _React$Component);

  function StaticRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, StaticRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.createHref = function (path) {
      return addLeadingSlash(_this.props.basename + createURL(path));
    }, _this.handlePush = function (location) {
      var _this$props = _this.props,
          basename = _this$props.basename,
          context = _this$props.context;

      context.action = "PUSH";
      context.location = addBasename(basename, Object(__WEBPACK_IMPORTED_MODULE_4_history__["c" /* createLocation */])(location));
      context.url = createURL(context.location);
    }, _this.handleReplace = function (location) {
      var _this$props2 = _this.props,
          basename = _this$props2.basename,
          context = _this$props2.context;

      context.action = "REPLACE";
      context.location = addBasename(basename, Object(__WEBPACK_IMPORTED_MODULE_4_history__["c" /* createLocation */])(location));
      context.url = createURL(context.location);
    }, _this.handleListen = function () {
      return noop;
    }, _this.handleBlock = function () {
      return noop;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  StaticRouter.prototype.getChildContext = function getChildContext() {
    return {
      router: {
        staticContext: this.props.context
      }
    };
  };

  StaticRouter.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!this.props.history, "<StaticRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { StaticRouter as Router }`.");
  };

  StaticRouter.prototype.render = function render() {
    var _props = this.props,
        basename = _props.basename,
        context = _props.context,
        location = _props.location,
        props = _objectWithoutProperties(_props, ["basename", "context", "location"]);

    var history = {
      createHref: this.createHref,
      action: "POP",
      location: stripBasename(basename, Object(__WEBPACK_IMPORTED_MODULE_4_history__["c" /* createLocation */])(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler("go"),
      goBack: staticHandler("goBack"),
      goForward: staticHandler("goForward"),
      listen: this.handleListen,
      block: this.handleBlock
    };

    return __WEBPACK_IMPORTED_MODULE_2_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5__Router__["a" /* default */], _extends({}, props, { history: history }));
  };

  return StaticRouter;
}(__WEBPACK_IMPORTED_MODULE_2_react___default.a.Component);

StaticRouter.propTypes = {
  basename: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.string,
  context: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired,
  location: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object])
};
StaticRouter.defaultProps = {
  basename: "",
  location: "/"
};
StaticRouter.childContextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (StaticRouter);

/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Switch__ = __webpack_require__(157);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Switch__["a" /* default */]);

/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_warning__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__matchPath__ = __webpack_require__(49);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch = function (_React$Component) {
  _inherits(Switch, _React$Component);

  function Switch() {
    _classCallCheck(this, Switch);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Switch.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_3_invariant___default()(this.context.router, "You should not use <Switch> outside a <Router>");
  };

  Switch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    __WEBPACK_IMPORTED_MODULE_2_warning___default()(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    __WEBPACK_IMPORTED_MODULE_2_warning___default()(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');
  };

  Switch.prototype.render = function render() {
    var route = this.context.router.route;
    var children = this.props.children;

    var location = this.props.location || route.location;

    var match = void 0,
        child = void 0;
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.Children.forEach(children, function (element) {
      if (match == null && __WEBPACK_IMPORTED_MODULE_0_react___default.a.isValidElement(element)) {
        var _element$props = element.props,
            pathProp = _element$props.path,
            exact = _element$props.exact,
            strict = _element$props.strict,
            sensitive = _element$props.sensitive,
            from = _element$props.from;

        var path = pathProp || from;

        child = element;
        match = Object(__WEBPACK_IMPORTED_MODULE_4__matchPath__["a" /* default */])(location.pathname, { path: path, exact: exact, strict: strict, sensitive: sensitive }, route.match);
      }
    });

    return match ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.cloneElement(child, { location: location, computedMatch: match }) : null;
  };

  return Switch;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Switch.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    route: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired
  }).isRequired
};
Switch.propTypes = {
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node,
  location: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object
};


/* harmony default export */ __webpack_exports__["a"] = (Switch);

/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_generatePath__ = __webpack_require__(79);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_generatePath__["a" /* default */]);

/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_matchPath__ = __webpack_require__(49);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_matchPath__["a" /* default */]);

/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_withRouter__ = __webpack_require__(161);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_withRouter__["a" /* default */]);

/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_hoist_non_react_statics__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_hoist_non_react_statics___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_hoist_non_react_statics__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Route__ = __webpack_require__(77);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






/**
 * A public higher-order component to access the imperative API
 */
var withRouter = function withRouter(Component) {
  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = _objectWithoutProperties(props, ["wrappedComponentRef"]);

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__Route__["a" /* default */], {
      children: function children(routeComponentProps) {
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Component, _extends({}, remainingProps, routeComponentProps, {
          ref: wrappedComponentRef
        }));
      }
    });
  };

  C.displayName = "withRouter(" + (Component.displayName || Component.name) + ")";
  C.WrappedComponent = Component;
  C.propTypes = {
    wrappedComponentRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func
  };

  return __WEBPACK_IMPORTED_MODULE_2_hoist_non_react_statics___default()(C, Component);
};

/* harmony default export */ __webpack_exports__["a"] = (withRouter);

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);
var bind = __webpack_require__(80);
var Axios = __webpack_require__(164);
var defaults = __webpack_require__(50);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(84);
axios.CancelToken = __webpack_require__(178);
axios.isCancel = __webpack_require__(83);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(179);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),
/* 163 */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(50);
var utils = __webpack_require__(14);
var InterceptorManager = __webpack_require__(173);
var dispatchRequest = __webpack_require__(174);

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(82);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error;
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);
var transformData = __webpack_require__(175);
var isCancel = __webpack_require__(83);
var defaults = __webpack_require__(50);
var isAbsoluteURL = __webpack_require__(176);
var combineURLs = __webpack_require__(177);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(84);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(85);
var formats = __webpack_require__(86);

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var toISO = Date.prototype.toISOString;

var defaults = {
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (Array.isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (Array.isArray(obj)) {
            values = values.concat(stringify(
                obj[key],
                generateArrayPrefix(prefix, key),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        } else {
            values = values.concat(stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        }
    }

    return values;
};

module.exports = function (object, opts) {
    var obj = object;
    var options = opts ? utils.assign({}, opts) : {};

    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === 'undefined') {
        options.format = formats['default'];
    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError('Unknown format option provided.');
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
        arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (sort) {
        objKeys.sort(sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        keys = keys.concat(stringify(
            obj[key],
            key,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encode ? encoder : null,
            filter,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly
        ));
    }

    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(85);

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    parameterLimit: 1000,
    plainObjects: false,
    strictNullHandling: false
};

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);

    for (var i = 0; i < parts.length; ++i) {
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder);
            val = options.decoder(part.slice(pos + 1), defaults.decoder);
        }
        if (has.call(obj, key)) {
            obj[key] = [].concat(obj[key]).concat(val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]') {
            obj = [];
            obj = obj.concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys
        // that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

module.exports = function (str, opts) {
    var options = opts ? utils.assign({}, opts) : {};

    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = __webpack_require__(0);
var ReactDOM = __webpack_require__(23);

// React 16+ supports Portals.
var canUsePortals = !!ReactDOM.createPortal;

function displace(WrappedComponent, options) {
  if (!global.document) {
    return function (_React$Component) {
      _inherits(EmptyDisplace, _React$Component);

      function EmptyDisplace() {
        _classCallCheck(this, EmptyDisplace);

        return _possibleConstructorReturn(this, (EmptyDisplace.__proto__ || Object.getPrototypeOf(EmptyDisplace)).apply(this, arguments));
      }

      _createClass(EmptyDisplace, [{
        key: 'render',
        value: function render() {
          return false;
        }
      }]);

      return EmptyDisplace;
    }(React.Component);
  }

  options = options || {};

  var Displaced = function (_React$Component2) {
    _inherits(Displaced, _React$Component2);

    function Displaced() {
      var _ref;

      var _temp, _this2, _ret;

      _classCallCheck(this, Displaced);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this2 = _possibleConstructorReturn(this, (_ref = Displaced.__proto__ || Object.getPrototypeOf(Displaced)).call.apply(_ref, [this].concat(args))), _this2), _this2.renderDisplaced = function () {
        ReactDOM.unstable_renderSubtreeIntoContainer(_this2, React.createElement(WrappedComponent, _this2.props, _this2.props.children), _this2.container);
      }, _this2.removeDisplaced = function () {
        ReactDOM.unmountComponentAtNode(_this2.container);
      }, _temp), _possibleConstructorReturn(_this2, _ret);
    }

    _createClass(Displaced, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        this.container = function () {
          if (!options.renderTo) {
            var result = document.createElement('div');
            document.body.appendChild(result);
            return result;
          } else if (typeof options.renderTo === 'string') {
            return document.querySelector(options.renderTo);
          } else {
            return options.renderTo;
          }
        }();
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        if (canUsePortals) return;
        if (this.props.mounted) {
          this.renderDisplaced();
        }
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps) {
        if (canUsePortals) return;
        if (prevProps.mounted && !this.props.mounted) {
          ReactDOM.unmountComponentAtNode(this.container);
        } else if (this.props.mounted) {
          this.renderDisplaced();
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (!canUsePortals) {
          ReactDOM.unmountComponentAtNode(this.container);
        }
        if (!options.renderTo) {
          this.container.parentNode.removeChild(this.container);
        }
      }
    }, {
      key: 'render',
      value: function render() {
        if (!canUsePortals || this.props.mounted === false) {
          return null;
        }
        return ReactDOM.createPortal(React.createElement(WrappedComponent, this.props, this.props.children), this.container);
      }
    }]);

    return Displaced;
  }(React.Component);

  Displaced.defaultProps = {
    mounted: true
  };
  Displaced.WrappedComponent = WrappedComponent;


  return Displaced;
}

module.exports = displace;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AceEditor = function (_Component) {
	_inherits(AceEditor, _Component);

	function AceEditor(props) {
		_classCallCheck(this, AceEditor);

		var _this = _possibleConstructorReturn(this, (AceEditor.__proto__ || Object.getPrototypeOf(AceEditor)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		_this.insertSelector = _this.insertSelector.bind(_this);
		return _this;
	}

	_createClass(AceEditor, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			// eslint-disable-next-line no-undef
			this.editor = ace.edit('forminator-field-' + this.props.property);

			this.session = this.editor.getSession();
			this.session.setUseWorker(false);
			this.editor.setShowPrintMargin(false);

			this.session.setMode('ace/mode/css');
			this.editor.setTheme('ace/theme/sui');
			this.editor.renderer.setShowGutter(true);
			this.editor.setHighlightActiveLine(true);
			this.editor.focus();

			this.editor.on('change', this.updateValue);
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.editor.destroy();
			this.editor = null;
		}
	}, {
		key: 'insertSelector',
		value: function insertSelector(selector) {
			var selectClass = selector + '{}';

			this.editor.navigateFileEnd();
			this.editor.insert(selectClass);
			this.editor.navigateLeft(1);
			this.editor.focus();
		}
	}, {
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate() {
			return false;
		}
	}, {
		key: 'updateValue',
		value: function updateValue() {
			this.props.actions.settingsActions.updateSetting(this.props.property, this.editor.getValue());
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) ? '' : this.props.settings[this.props.property];

			var type = !_.isUndefined(this.props.type) ? this.props.type : 'form';

			if ('pdf-form' === this.props.formType) {
				type = this.props.formType;
			}

			var basicSelectors = _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'label',
					{ className: 'sui-label' },
					(0, _utils.translate)('Basic selectors')
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-ace-selectors' },
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' ');
							}
						},
						(0, _utils.translate)('Form')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-title ');
							}
						},
						(0, _utils.translate)('Section Title')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-subtitle ');
							}
						},
						(0, _utils.translate)('Section Subtitle')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-label ');
							}
						},
						(0, _utils.translate)('Field Label')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-description ');
							}
						},
						(0, _utils.translate)('Field Description')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-input ');
							}
						},
						(0, _utils.translate)('Input')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-textarea ');
							}
						},
						(0, _utils.translate)('Textarea')
					)
				)
			);

			var pollSelectors = _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'label',
					{ className: 'sui-label' },
					(0, _utils.translate)('Basic selectors')
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-ace-selectors' },
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' ');
							}
						},
						(0, _utils.translate)('Poll')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-poll--question ');
							}
						},
						(0, _utils.translate)('Question')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-radio .forminator-radio-bullet ');
							}
						},
						(0, _utils.translate)('Answer Input')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-radio .forminator-radio-label ');
							}
						},
						(0, _utils.translate)('Answer Label')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-button ');
							}
						},
						(0, _utils.translate)('Submit Button')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-poll-footer a.forminator-link, ' + '.forminator-poll-footer a.forminator-link:visited ');
							}
						},
						(0, _utils.translate)('View Results Link')
					)
				)
			);

			var quizSelectors = _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'label',
					{ className: 'sui-label' },
					(0, _utils.translate)('Basic selectors')
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-ace-selectors' },
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' ');
							}
						},
						(0, _utils.translate)('Quiz')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-quiz--title ');
							}
						},
						(0, _utils.translate)('Title')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-quiz--description p ');
							}
						},
						(0, _utils.translate)('Description')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-question .forminator-legend ');
							}
						},
						(0, _utils.translate)('Question')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-answer .forminator-answer--design ');
							}
						},
						(0, _utils.translate)('Answer Container')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-answer .forminator-answer--name ');
							}
						},
						(0, _utils.translate)('Answer Text')
					)
				)
			);

			var pdfSelectors = _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'label',
					{ className: 'sui-label' },
					(0, _utils.translate)('PDF selectors')
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-ace-selectors' },
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('body');
							}
						},
						(0, _utils.translate)('Body')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-pdf-header');
							}
						},
						(0, _utils.translate)('PDF Header')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.pdf-logo');
							}
						},
						(0, _utils.translate)('Logo')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.pdf-title');
							}
						},
						(0, _utils.translate)('Title')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-row-heading td');
							}
						},
						(0, _utils.translate)('Field Label')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-row-content td');
							}
						},
						(0, _utils.translate)('Field Value')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-pdf-footer-text td');
							}
						},
						(0, _utils.translate)('Footer')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-pdf-pagination td');
							}
						},
						(0, _utils.translate)('Pagination')
					)
				)
			);

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				type === 'form' && basicSelectors,
				type === 'poll' && pollSelectors,
				type === 'quiz' && quizSelectors,
				type === 'pdf-form' && pdfSelectors,
				_react2.default.createElement(
					'div',
					{ id: 'forminator-field-' + this.props.property,
						'data-value': value,
						style: { height: '210px' }
					},
					value
				)
			);
		}
	}]);

	return AceEditor;
}(_react.Component);

exports.default = AceEditor;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var showModal = exports.showModal = function showModal(modalProps, modalType) {
	return function (dispatch) {
		dispatch({
			type: 'SHOW_MODAL',
			modalProps: modalProps,
			modalType: modalType
		});
	};
};

var hideModal = exports.hideModal = function hideModal() {
	return function (dispatch) {
		dispatch({
			type: 'HIDE_MODAL'
		});
	};
};

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var updateSetting = exports.updateSetting = function updateSetting(setting, value) {
	return function (dispatch) {
		// Update global variable with Changes
		window.forminatorChanges.settings = true;

		dispatch({
			type: 'UPDATE_SETTING',
			setting: setting,
			value: value
		});
	};
};

var updateSettings = exports.updateSettings = function updateSettings(settings) {
	return function (dispatch) {
		// Update global variable with Changes
		window.forminatorChanges.settings = true;

		dispatch({
			type: 'UPDATE_SETTINGS',
			settings: settings
		});
	};
};

var saveBuilder = exports.saveBuilder = function saveBuilder(setting, value) {
	return function (dispatch) {
		// Empty global changed variable
		window.forminatorChanges = {
			answers: [],
			settings: false,
			saved: true
		};

		dispatch({
			type: 'UPDATE_SETTING',
			setting: setting,
			value: value
		});
	};
};

/***/ }),
/* 186 */,
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _notifications = __webpack_require__(30);

var _notifications2 = _interopRequireDefault(_notifications);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MetaDropdown = function (_Component) {
	_inherits(MetaDropdown, _Component);

	function MetaDropdown(props) {
		_classCallCheck(this, MetaDropdown);

		var _this = _possibleConstructorReturn(this, (MetaDropdown.__proto__ || Object.getPrototypeOf(MetaDropdown)).call(this, props));

		var MetaData = {
			form: {
				shortcode: 'forminator_form',
				type: 'form',
				processAction: forminatorData.adminUrl + 'admin.php?page=forminator-cform',
				processNonce: forminatorData.formProcessNonce,
				exportNonce: forminatorData.formExportNonce,
				submissions: forminatorData.adminUrl + 'admin.php?page=forminator-entries&form_type=forminator_forms&form_id=' + _this.props.id,
				dropdownLabel: (0, _utils.translate)('Open form options')
			},
			poll: {
				shortcode: 'forminator_poll',
				type: 'poll',
				processAction: forminatorData.adminUrl + 'admin.php?page=forminator-poll',
				processNonce: forminatorData.pollProcessNonce,
				exportNonce: forminatorData.pollExportNonce,
				submissions: forminatorData.adminUrl + 'admin.php?page=forminator-entries&form_type=forminator_polls&form_id=' + _this.props.id,
				dropdownLabel: (0, _utils.translate)('Open poll options')
			},
			quiz: {
				shortcode: 'forminator_quiz',
				type: 'quiz',
				processAction: forminatorData.adminUrl + 'admin.php?page=forminator-quiz',
				processNonce: forminatorData.quizProcessNonce,
				exportNonce: forminatorData.quizExportNonce,
				submissions: forminatorData.adminUrl + 'admin.php?page=forminator-entries&form_type=forminator_quizzes&form_id=' + _this.props.id,
				dropdownLabel: (0, _utils.translate)('Open quiz options')
			}
		};

		_this.copyToClipboard = _this.copyToClipboard.bind(_this);
		_this.resetTrackingData = _this.resetTrackingData.bind(_this);
		_this.data = MetaData[_this.props.type];
		return _this;
	}

	_createClass(MetaDropdown, [{
		key: 'copyToClipboard',
		value: function copyToClipboard() {
			this.input.select();

			document.execCommand('copy');

			var custom = new _notifications2.default({
				type: 'success',
				text: (0, _utils.translate)('Shortcode has been copied successfully.'),
				time: 4000
			});
			custom.open();
		}
	}, {
		key: 'resetTrackingData',
		value: function resetTrackingData() {
			var data = {
				action: 'forminator_reset_tracking_data',
				_ajax_nonce: forminatorData.resetTrackingDataNonce,
				id: this.props.id

			};

			this.ajax = jQuery.post({
				url: forminatorData.ajaxUrl,
				type: 'post',
				data: data
			}).done(function (result) {
				if (result) {
					var type = result.success ? 'success' : 'error',
					    text = result.data || (0, _utils.translate)('Something went wrong.');

					var custom = new _notifications2.default({
						type: type,
						text: text,
						time: 4000
					});
					custom.open();
				}
			});
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var exportUrl = this.data.processAction + '&export=true&module_id=' + this.props.id + '&exportnonce=' + this.data.exportNonce + '&module_type=' + this.data.type;

			var deleteUrl = this.data.processAction + '&delete=true&module_id=' + this.props.id + '&nonce=' + this.data.processNonce + '&module_type=' + this.data.type;

			var tooltip = (0, _utils.translate)('Create New Form');

			if (this.props.type === 'poll') {
				tooltip = (0, _utils.translate)('Create New Poll');
			}

			if (this.props.type === 'quiz') {
				tooltip = (0, _utils.translate)('Create New Quiz');
			}

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement('input', {
					type: 'text',
					defaultValue: '[' + this.data.shortcode + ' id="' + this.props.id + '"]',
					id: 'forminator-form-shortcode',
					style: { position: 'absolute', top: '-1500px' },
					'aria-hidden': 'true',
					ref: function ref(input) {
						return _this2.input = input;
					}
				}),
				_react2.default.createElement(
					'div',
					{
						className: this.props.hasLead ? 'sui-dropdown fui-dropdown-soon' : 'sui-dropdown'
					},
					_react2.default.createElement(
						'button',
						{ className: 'sui-button-icon sui-dropdown-anchor', 'aria-label': 'Dropdown' },
						_react2.default.createElement('span', {
							className: 'sui-icon-widget-settings-config sui-md',
							'aria-hidden': 'true'
						}),
						_react2.default.createElement(
							'span',
							{ className: 'sui-screen-reader-text' },
							this.data.dropdownLabel
						)
					),
					_react2.default.createElement(
						'ul',
						null,
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'button',
								{
									className: 'forminator-field-edit',
									onClick: this.copyToClipboard
								},
								_react2.default.createElement('span', { className: 'sui-icon-code', 'aria-hidden': 'true' }),
								(0, _utils.translate)('Copy Shortcode')
							)
						),
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'a',
								{
									className: 'forminator-field-edit',
									href: this.data.submissions
								},
								_react2.default.createElement('span', {
									className: 'sui-icon-community-people',
									'aria-hidden': 'true'
								}),
								(0, _utils.translate)('View Submissions')
							)
						),
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'form',
								{ method: 'post', action: this.data.processAction },
								_react2.default.createElement('input', { type: 'hidden', name: 'forminator_action', value: 'clone' }),
								_react2.default.createElement('input', { type: 'hidden', name: 'id', value: this.props.id }),
								_react2.default.createElement('input', { type: 'hidden', id: 'forminatorNonce',
									name: 'forminatorNonce',
									value: forminatorData.cloneNonce
								}),
								_react2.default.createElement('input', { type: 'hidden', name: 'forminatorRedirect', value: 'false' }),
								this.props.hasLead && _react2.default.createElement(
									'button',
									{
										type: 'submit',
										disabled: 'disabled',
										className: 'fui-button-with-tag sui-tooltip sui-tooltip-left sui-constrained',
										'data-tooltip': (0, _utils.translate)("Duplicate isn't supported at the moment " + 'for the quizzes with lead capturing enabled.')
									},
									_react2.default.createElement('span', {
										className: 'sui-icon-page-multiple',
										'aria-hidden': 'true'
									}),
									_react2.default.createElement(
										'span',
										{ className: 'fui-button-label' },
										(0, _utils.translate)('Duplicate')
									),
									_react2.default.createElement(
										'span',
										{ className: 'sui-tag sui-tag-blue sui-tag-sm' },
										(0, _utils.translate)('Coming soon')
									)
								),
								!this.props.hasLead && _react2.default.createElement(
									'button',
									{ type: 'submit' },
									_react2.default.createElement('span', {
										className: 'sui-icon-page-multiple',
										'aria-hidden': 'true'
									}),
									(0, _utils.translate)('Duplicate')
								)
							)
						),
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'a',
								{ className: 'forminator-field-edit',
									onClick: this.resetTrackingData },
								_react2.default.createElement('span', { className: 'sui-icon-update', 'aria-hidden': 'true' }),
								(0, _utils.translate)('Reset Tracking Data')
							)
						),
						_react2.default.createElement(
							'li',
							null,
							this.props.hasLead && _react2.default.createElement(
								'a',
								{
									href: '#',
									className: 'fui-button-with-tag sui-tooltip sui-tooltip-left',
									'data-tooltip': (0, _utils.translate)("Export isn't supported at the moment for " + 'the quizzes with lead capturing enabled.')
								},
								_react2.default.createElement('span', { className: 'sui-icon-cloud-migration', 'aria-hidden': 'true' }),
								_react2.default.createElement(
									'span',
									{ className: 'fui-button-label' },
									(0, _utils.translate)('Export')
								),
								_react2.default.createElement(
									'span',
									{ className: 'sui-tag sui-tag-blue sui-tag-sm' },
									(0, _utils.translate)('Coming soon')
								)
							),
							!this.props.hasLead && _react2.default.createElement(
								'a',
								{
									className: 'forminator-field-edit',
									href: exportUrl
								},
								_react2.default.createElement('span', {
									className: 'sui-icon-cloud-migration',
									'aria-hidden': 'true'
								}),
								(0, _utils.translate)('Export')
							)
						),
						_react2.default.createElement(
							'li',
							null,
							_react2.default.createElement(
								'a',
								{
									className: 'forminator-field-edit sui-option-red',
									href: deleteUrl
								},
								_react2.default.createElement('span', { className: 'sui-icon-trash', 'aria-hidden': 'true' }),
								(0, _utils.translate)('Delete')
							)
						)
					)
				),
				_react2.default.createElement(
					'a',
					{
						href: forminatorData.dashboardUrl + '&createnew=' + this.props.type,
						className: 'sui-button-icon sui-tooltip sui-tooltip-bottom',
						'data-tooltip': tooltip
					},
					_react2.default.createElement('span', { className: 'sui-icon-plus sui-md', 'aria-hidden': 'true' })
				)
			);
		}
	}]);

	return MetaDropdown;
}(_react.Component);

exports.default = MetaDropdown;

/***/ }),
/* 188 */,
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = __unstableEscapeGreaterThan;
/**
 * Returns a string with greater-than sign replaced.
 *
 * Note that if a resolution for Trac#45387 comes to fruition, it is no longer
 * necessary for `__unstableEscapeGreaterThan` to exist.
 *
 * See: https://core.trac.wordpress.org/ticket/45387
 *
 * @param {string} value Original string.
 *
 * @return {string} Escaped string.
 */
function __unstableEscapeGreaterThan(value) {
  return value.replace(/>/g, '&gt;');
}
//# sourceMappingURL=escape-greater.js.map

/***/ }),
/* 190 */,
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

/*! @license DOMPurify 3.0.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.1/LICENSE */

(function (global, factory) {
   true ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.DOMPurify = factory());
})(this, (function () { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var entries = Object.entries,
      setPrototypeOf = Object.setPrototypeOf,
      isFrozen = Object.isFrozen,
      getPrototypeOf = Object.getPrototypeOf,
      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var freeze = Object.freeze,
      seal = Object.seal,
      create = Object.create; // eslint-disable-line import/no-mutable-exports

  var _ref = typeof Reflect !== 'undefined' && Reflect,
      apply = _ref.apply,
      construct = _ref.construct;

  if (!apply) {
    apply = function apply(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }

  if (!freeze) {
    freeze = function freeze(x) {
      return x;
    };
  }

  if (!seal) {
    seal = function seal(x) {
      return x;
    };
  }

  if (!construct) {
    construct = function construct(Func, args) {
      return _construct(Func, _toConsumableArray(args));
    };
  }

  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);
  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringToString = unapply(String.prototype.toString);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);
  var regExpTest = unapply(RegExp.prototype.test);
  var typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function (thisArg) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return apply(func, thisArg, args);
    };
  }
  function unconstruct(func) {
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return construct(func, args);
    };
  }
  /* Add properties to a lookup table */

  function addToSet(set, array, transformCaseFunc) {
    transformCaseFunc = transformCaseFunc ? transformCaseFunc : stringToLowerCase;

    if (setPrototypeOf) {
      // Make 'in' and truthy checks like Boolean(set.constructor)
      // independent of any properties defined on Object.prototype.
      // Prevent prototype setters from intercepting set as a this value.
      setPrototypeOf(set, null);
    }

    var l = array.length;

    while (l--) {
      var element = array[l];

      if (typeof element === 'string') {
        var lcElement = transformCaseFunc(element);

        if (lcElement !== element) {
          // Config presets (e.g. tags.js, attrs.js) are immutable.
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }

          element = lcElement;
        }
      }

      set[element] = true;
    }

    return set;
  }
  /* Shallow clone an object */

  function clone(object) {
    var newObject = create(null);

    var _iterator = _createForOfIteratorHelper(entries(object)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
            property = _step$value[0],
            value = _step$value[1];

        newObject[property] = value;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return newObject;
  }
  /* This method automatically checks if the prop is function
   * or getter and behaves accordingly. */

  function lookupGetter(object, prop) {
    while (object !== null) {
      var desc = getOwnPropertyDescriptor(object, prop);

      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }

        if (typeof desc.value === 'function') {
          return unapply(desc.value);
        }
      }

      object = getPrototypeOf(object);
    }

    function fallbackValue(element) {
      console.warn('fallback value for', element);
      return null;
    }

    return fallbackValue;
  }

  var html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG

  var svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.
  // We still need to know them so that we can do namespace
  // checks properly in case one wants to add them to
  // allow-list.

  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
  var mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']); // Similarly to SVG, we want to know all MathML elements,
  // even those that we disallow by default.

  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
  var text = freeze(['#text']);

  var html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);
  var svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
  var mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

  var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode

  var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape

  var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape

  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
  );
  var DOCTYPE_NAME = seal(/^html$/i);

  var getGlobal = function getGlobal() {
    return typeof window === 'undefined' ? null : window;
  };
  /**
   * Creates a no-op policy for internal use only.
   * Don't export this function outside this module!
   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
   * @param {Document} document The document object (to determine policy name suffix)
   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
   * are not supported).
   */


  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
    if (_typeof(trustedTypes) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
      return null;
    } // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.


    var suffix = null;
    var ATTR_NAME = 'data-tt-policy-suffix';

    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
      suffix = document.currentScript.getAttribute(ATTR_NAME);
    }

    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html) {
          return html;
        },
        createScriptURL: function createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch (_) {
      // Policy creation failed (most likely another DOMPurify script has
      // already run). Skip creating the policy, as this will only cause errors
      // if TT are enforced.
      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
      return null;
    }
  };

  function createDOMPurify() {
    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

    var DOMPurify = function DOMPurify(root) {
      return createDOMPurify(root);
    };
    /**
     * Version label, exposed for easier checks
     * if DOMPurify is up to date or not
     */


    DOMPurify.version = '3.0.1';
    /**
     * Array of elements that DOMPurify removed during sanitation.
     * Empty if nothing was removed.
     */

    DOMPurify.removed = [];

    if (!window || !window.document || window.document.nodeType !== 9) {
      // Not running in a browser, provide a factory function
      // so that you can pass your own Window
      DOMPurify.isSupported = false;
      return DOMPurify;
    }

    var originalDocument = window.document;
    var document = window.document;
    var DocumentFragment = window.DocumentFragment,
        HTMLTemplateElement = window.HTMLTemplateElement,
        Node = window.Node,
        Element = window.Element,
        NodeFilter = window.NodeFilter,
        _window$NamedNodeMap = window.NamedNodeMap,
        NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
        HTMLFormElement = window.HTMLFormElement,
        DOMParser = window.DOMParser,
        trustedTypes = window.trustedTypes;
    var ElementPrototype = Element.prototype;
    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
    var getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.

    if (typeof HTMLTemplateElement === 'function') {
      var template = document.createElement('template');

      if (template.content && template.content.ownerDocument) {
        document = template.content.ownerDocument;
      }
    }

    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);

    var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
    var _document = document,
        implementation = _document.implementation,
        createNodeIterator = _document.createNodeIterator,
        createDocumentFragment = _document.createDocumentFragment,
        getElementsByTagName = _document.getElementsByTagName;
    var importNode = originalDocument.importNode;
    var hooks = {};
    /**
     * Expose whether this browser supports running the full DOMPurify.
     */

    DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined';
    var MUSTACHE_EXPR$1 = MUSTACHE_EXPR,
        ERB_EXPR$1 = ERB_EXPR,
        TMPLIT_EXPR$1 = TMPLIT_EXPR,
        DATA_ATTR$1 = DATA_ATTR,
        ARIA_ATTR$1 = ARIA_ATTR,
        IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
    var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */

    /* allowed element names */

    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
    /* Allowed attribute names */

    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
    /*
     * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
     */

    var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */

    var FORBID_TAGS = null;
    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */

    var FORBID_ATTR = null;
    /* Decide if ARIA attributes are okay */

    var ALLOW_ARIA_ATTR = true;
    /* Decide if custom data attributes are okay */

    var ALLOW_DATA_ATTR = true;
    /* Decide if unknown protocols are okay */

    var ALLOW_UNKNOWN_PROTOCOLS = false;
    /* Decide if self-closing tags in attributes are allowed.
     * Usually removed due to a mXSS issue in jQuery 3.0 */

    var ALLOW_SELF_CLOSE_IN_ATTR = true;
    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */

    var SAFE_FOR_TEMPLATES = false;
    /* Decide if document with <html>... should be returned */

    var WHOLE_DOCUMENT = false;
    /* Track whether config is already set on this instance of DOMPurify. */

    var SET_CONFIG = false;
    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */

    var FORCE_BODY = false;
    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
     * string (or a TrustedHTML object if Trusted Types are supported).
     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
     */

    var RETURN_DOM = false;
    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
     * string  (or a TrustedHTML object if Trusted Types are supported) */

    var RETURN_DOM_FRAGMENT = false;
    /* Try to return a Trusted Type object instead of a string, return a string in
     * case Trusted Types are not supported  */

    var RETURN_TRUSTED_TYPE = false;
    /* Output should be free from DOM clobbering attacks?
     * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
     */

    var SANITIZE_DOM = true;
    /* Achieve full DOM Clobbering protection by isolating the namespace of named
     * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
     *
     * HTML/DOM spec rules that enable DOM Clobbering:
     *   - Named Access on Window (7.3.3)
     *   - DOM Tree Accessors (3.1.5)
     *   - Form Element Parent-Child Relations (4.10.3)
     *   - Iframe srcdoc / Nested WindowProxies (4.8.5)
     *   - HTMLCollection (4.2.10.2)
     *
     * Namespace isolation is implemented by prefixing `id` and `name` attributes
     * with a constant string, i.e., `user-content-`
     */

    var SANITIZE_NAMED_PROPS = false;
    var SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
    /* Keep element content when removing element? */

    var KEEP_CONTENT = true;
    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
     * of importing it into a new Document and returning a sanitized copy */

    var IN_PLACE = false;
    /* Allow usage of profiles like html, svg and mathMl */

    var USE_PROFILES = {};
    /* Tags to ignore content of when KEEP_CONTENT is true */

    var FORBID_CONTENTS = null;
    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
    /* Tags that are safe for data: URIs */

    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
    /* Attributes safe for values like "javascript:" */

    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    /* Document namespace */

    var NAMESPACE = HTML_NAMESPACE;
    var IS_EMPTY_INPUT = false;
    /* Allowed XHTML+XML namespaces */

    var ALLOWED_NAMESPACES = null;
    var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
    /* Parsing of strict XHTML documents */

    var PARSER_MEDIA_TYPE;
    var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
    var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
    var transformCaseFunc;
    /* Keep a reference to config to pass to hooks */

    var CONFIG = null;
    /* Ideally, do not touch anything below this line */

    /* ______________________________________________ */

    var formElement = document.createElement('form');

    var isRegexOrFunction = function isRegexOrFunction(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    /**
     * _parseConfig
     *
     * @param  {Object} cfg optional config literal
     */
    // eslint-disable-next-line complexity


    var _parseConfig = function _parseConfig(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      /* Shield configuration object from tampering */


      if (!cfg || _typeof(cfg) !== 'object') {
        cfg = {};
      }
      /* Shield configuration object from prototype pollution */


      cfg = clone(cfg);
      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.

      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
      /* Set configuration parameters */

      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent
      cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent
      transformCaseFunc // eslint-disable-line indent
      ) // eslint-disable-line indent
      : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent
      cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent
      transformCaseFunc // eslint-disable-line indent
      ) // eslint-disable-line indent
      : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true

      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true

      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false

      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true

      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false

      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false

      RETURN_DOM = cfg.RETURN_DOM || false; // Default false

      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false

      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false

      FORCE_BODY = cfg.FORCE_BODY || false; // Default false

      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true

      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false

      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true

      IN_PLACE = cfg.IN_PLACE || false; // Default false

      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};

      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }

      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }

      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }

      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }

      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      /* Parse profile info */


      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
        ALLOWED_ATTR = [];

        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }

        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      /* Merge configuration parameters */


      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }

        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }

      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }

        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }

      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }

      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }

        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      /* Add #text in case KEEP_CONTENT is set to true */


      if (KEEP_CONTENT) {
        ALLOWED_TAGS['#text'] = true;
      }
      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */


      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
      }
      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */


      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ['tbody']);
        delete FORBID_TAGS.tbody;
      } // Prevent further manipulation of configuration.
      // Not available in IE8, Safari 5, etc.


      if (freeze) {
        freeze(cfg);
      }

      CONFIG = cfg;
    };

    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']); // Certain elements are allowed in both SVG and HTML
    // namespace. We need to specify them explicitly
    // so that they don't get erroneously deleted from
    // HTML namespace.

    var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
    /* Keep track of all possible SVG and MathML tags
     * so that we can perform the namespace checks
     * correctly. */

    var ALL_SVG_TAGS = addToSet({}, svg$1);
    addToSet(ALL_SVG_TAGS, svgFilters);
    addToSet(ALL_SVG_TAGS, svgDisallowed);
    var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
    /**
     *
     *
     * @param  {Element} element a DOM element whose namespace is being checked
     * @returns {boolean} Return false if the element has a
     *  namespace that a spec-compliant parser would never
     *  return. Return true otherwise.
     */

    var _checkValidNamespace = function _checkValidNamespace(element) {
      var parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode
      // can be null. We just simulate parent in this case.

      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: NAMESPACE,
          tagName: 'template'
        };
      }

      var tagName = stringToLowerCase(element.tagName);
      var parentTagName = stringToLowerCase(parent.tagName);

      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
        return false;
      }

      if (element.namespaceURI === SVG_NAMESPACE) {
        // The only way to switch from HTML namespace to SVG
        // is via <svg>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'svg';
        } // The only way to switch from MathML to SVG is via`
        // svg if parent is either <annotation-xml> or MathML
        // text integration points.


        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        } // We only allow elements that are defined in SVG
        // spec. All others are disallowed in SVG namespace.


        return Boolean(ALL_SVG_TAGS[tagName]);
      }

      if (element.namespaceURI === MATHML_NAMESPACE) {
        // The only way to switch from HTML namespace to MathML
        // is via <math>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'math';
        } // The only way to switch from SVG to MathML is via
        // <math> and HTML integration points


        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
        } // We only allow elements that are defined in MathML
        // spec. All others are disallowed in MathML namespace.


        return Boolean(ALL_MATHML_TAGS[tagName]);
      }

      if (element.namespaceURI === HTML_NAMESPACE) {
        // The only way to switch from SVG to HTML is via
        // HTML integration points, and from MathML to HTML
        // is via MathML text integration points
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        } // We disallow tags that are specific for MathML
        // or SVG and should never appear in HTML namespace


        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      } // For XHTML and XML documents that support custom namespaces


      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
        return true;
      } // The code should never reach this place (this means
      // that the element somehow got namespace that is not
      // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
      // Return false just in case.


      return false;
    };
    /**
     * _forceRemove
     *
     * @param  {Node} node a DOM node
     */


    var _forceRemove = function _forceRemove(node) {
      arrayPush(DOMPurify.removed, {
        element: node
      });

      try {
        // eslint-disable-next-line unicorn/prefer-dom-node-remove
        node.parentNode.removeChild(node);
      } catch (_) {
        node.remove();
      }
    };
    /**
     * _removeAttribute
     *
     * @param  {String} name an Attribute name
     * @param  {Node} node a DOM node
     */


    var _removeAttribute = function _removeAttribute(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }

      node.removeAttribute(name); // We void attribute values for unremovable "is"" attributes

      if (name === 'is' && !ALLOWED_ATTR[name]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(node);
          } catch (_) {}
        } else {
          try {
            node.setAttribute(name, '');
          } catch (_) {}
        }
      }
    };
    /**
     * _initDocument
     *
     * @param  {String} dirty a string of dirty markup
     * @return {Document} a DOM, filled with the dirty markup
     */


    var _initDocument = function _initDocument(dirty) {
      /* Create a HTML document */
      var doc;
      var leadingWhitespace;

      if (FORCE_BODY) {
        dirty = '<remove></remove>' + dirty;
      } else {
        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
        var matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }

      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
      }

      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      /*
       * Use the DOMParser API by default, fallback later if needs be
       * DOMParser not work for svg when has multiple root element.
       */

      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_) {}
      }
      /* Use createHTMLDocument in case DOMParser is not available */


      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, 'template', null);

        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
        } catch (_) {// Syntax error if dirtyPayload is invalid xml
        }
      }

      var body = doc.body || doc.documentElement;

      if (dirty && leadingWhitespace) {
        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      /* Work on whole document or just its body */


      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
      }

      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };
    /**
     * _createIterator
     *
     * @param  {Document} root document/fragment to create iterator for
     * @return {Iterator} iterator instance
     */


    var _createIterator = function _createIterator(root) {
      return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
    };
    /**
     * _isClobbered
     *
     * @param  {Node} elm element to check for clobbering attacks
     * @return {Boolean} true if clobbered, false if safe
     */


    var _isClobbered = function _isClobbered(elm) {
      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');
    };
    /**
     * _isNode
     *
     * @param  {Node} obj object to check whether it's a DOM node
     * @return {Boolean} true is object is a DOM node
     */


    var _isNode = function _isNode(object) {
      return _typeof(Node) === 'object' ? object instanceof Node : object && _typeof(object) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
    };
    /**
     * _executeHook
     * Execute user configurable hooks
     *
     * @param  {String} entryPoint  Name of the hook's entry point
     * @param  {Node} currentNode node to work on with the hook
     * @param  {Object} data additional hook parameters
     */


    var _executeHook = function _executeHook(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return;
      }

      arrayForEach(hooks[entryPoint], function (hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    };
    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     *
     * @param   {Node} currentNode to check for permission to exist
     * @return  {Boolean} true if node was killed, false if left alive
     */


    var _sanitizeElements = function _sanitizeElements(currentNode) {
      var content;
      /* Execute a hook if present */

      _executeHook('beforeSanitizeElements', currentNode, null);
      /* Check if element is clobbered or can clobber */


      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Now let's check the element's type and name */


      var tagName = transformCaseFunc(currentNode.nodeName);
      /* Execute a hook if present */

      _executeHook('uponSanitizeElement', currentNode, {
        tagName: tagName,
        allowedTags: ALLOWED_TAGS
      });
      /* Detect mXSS attempts abusing namespace confusion */


      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Remove element if anything forbids its presence */


      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        /* Check if we have a custom element to handle */
        if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
        }
        /* Keep content except for bad-listed elements */


        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          var parentNode = getParentNode(currentNode) || currentNode.parentNode;
          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

          if (childNodes && parentNode) {
            var childCount = childNodes.length;

            for (var i = childCount - 1; i >= 0; --i) {
              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
            }
          }
        }

        _forceRemove(currentNode);

        return true;
      }
      /* Check whether element has a valid namespace */


      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Make sure that older browsers don't get noscript mXSS */


      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Sanitize element content to be template-safe */


      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        /* Get the element's text content */
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR$1, ' ');
        content = stringReplace(content, ERB_EXPR$1, ' ');
        content = stringReplace(content, TMPLIT_EXPR$1, ' ');

        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content;
        }
      }
      /* Execute a hook if present */


      _executeHook('afterSanitizeElements', currentNode, null);

      return false;
    };
    /**
     * _isValidAttribute
     *
     * @param  {string} lcTag Lowercase tag name of containing element.
     * @param  {string} lcName Lowercase attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid, otherwise false.
     */
    // eslint-disable-next-line complexity


    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
      /* Make sure attribute cannot clobber */
      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
        return false;
      }
      /* Allow valid data-* attributes: At least one character after "-"
          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
          We don't need to check the value; it's always URI safe. */


      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if ( // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
          return false;
        }
        /* Check value is safe. First, is attr inert? If so, is safe */

      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if (!value) ; else {
        return false;
      }

      return true;
    };
    /**
     * _basicCustomElementCheck
     * checks if at least one dash is included in tagName, and it's not the first char
     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
     * @param {string} tagName name of the tag of the node to sanitize
     */


    var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
      return tagName.indexOf('-') > 0;
    };
    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param  {Node} currentNode to sanitize
     */


    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
      var attr;
      var value;
      var lcName;
      var l;
      /* Execute a hook if present */

      _executeHook('beforeSanitizeAttributes', currentNode, null);

      var attributes = currentNode.attributes;
      /* Check if we have attributes; if not we might have a text node */

      if (!attributes) {
        return;
      }

      var hookEvent = {
        attrName: '',
        attrValue: '',
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      l = attributes.length;
      /* Go backwards over all attributes; safely remove bad ones */

      while (l--) {
        attr = attributes[l];
        var _attr = attr,
            name = _attr.name,
            namespaceURI = _attr.namespaceURI;
        value = name === 'value' ? attr.value : stringTrim(attr.value);
        lcName = transformCaseFunc(name);
        /* Execute a hook if present */

        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set

        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);

        value = hookEvent.attrValue;
        /* Did the hooks approve of the attribute? */

        if (hookEvent.forceKeepAttr) {
          continue;
        }
        /* Remove attribute */


        _removeAttribute(name, currentNode);
        /* Did the hooks approve of the attribute? */


        if (!hookEvent.keepAttr) {
          continue;
        }
        /* Work around a security issue in jQuery 3.0 */


        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);

          continue;
        }
        /* Sanitize attribute content to be template-safe */


        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR$1, ' ');
          value = stringReplace(value, ERB_EXPR$1, ' ');
          value = stringReplace(value, TMPLIT_EXPR$1, ' ');
        }
        /* Is `value` valid for this attribute? */


        var lcTag = transformCaseFunc(currentNode.nodeName);

        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }
        /* Full DOM Clobbering protection via namespace isolation,
         * Prefix id and name attributes with `user-content-`
         */


        if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
          // Remove the attribute with this value
          _removeAttribute(name, currentNode); // Prefix the value and later re-create the attribute with the sanitized value


          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        /* Handle attributes that require Trusted Types */


        if (trustedTypesPolicy && _typeof(trustedTypes) === 'object' && typeof trustedTypes.getAttributeType === 'function') {
          if (namespaceURI) ; else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case 'TrustedHTML':
                value = trustedTypesPolicy.createHTML(value);
                break;

              case 'TrustedScriptURL':
                value = trustedTypesPolicy.createScriptURL(value);
                break;
            }
          }
        }
        /* Handle invalid data-* attribute set by try-catching it */


        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value);
          }

          arrayPop(DOMPurify.removed);
        } catch (_) {}
      }
      /* Execute a hook if present */


      _executeHook('afterSanitizeAttributes', currentNode, null);
    };
    /**
     * _sanitizeShadowDOM
     *
     * @param  {DocumentFragment} fragment to iterate over recursively
     */


    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
      var shadowNode;

      var shadowIterator = _createIterator(fragment);
      /* Execute a hook if present */


      _executeHook('beforeSanitizeShadowDOM', fragment, null);

      while (shadowNode = shadowIterator.nextNode()) {
        /* Execute a hook if present */
        _executeHook('uponSanitizeShadowNode', shadowNode, null);
        /* Sanitize tags and elements */


        if (_sanitizeElements(shadowNode)) {
          continue;
        }
        /* Deep shadow DOM detected */


        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(shadowNode.content);
        }
        /* Check attributes, sanitize if necessary */


        _sanitizeAttributes(shadowNode);
      }
      /* Execute a hook if present */


      _executeHook('afterSanitizeShadowDOM', fragment, null);
    };
    /**
     * Sanitize
     * Public method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     */
    // eslint-disable-next-line complexity


    DOMPurify.sanitize = function (dirty) {
      var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var body;
      var importedNode;
      var currentNode;
      var returnNode;
      /* Make sure we have a string to sanitize.
        DO NOT return early, as this will return the wrong type if
        the user has requested a DOM object rather than a string */

      IS_EMPTY_INPUT = !dirty;

      if (IS_EMPTY_INPUT) {
        dirty = '<!-->';
      }
      /* Stringify, in case dirty is an object */


      if (typeof dirty !== 'string' && !_isNode(dirty)) {
        // eslint-disable-next-line no-negated-condition
        if (typeof dirty.toString !== 'function') {
          throw typeErrorCreate('toString is not a function');
        } else {
          dirty = dirty.toString();

          if (typeof dirty !== 'string') {
            throw typeErrorCreate('dirty is not a string, aborting');
          }
        }
      }
      /* Return dirty HTML if DOMPurify cannot run */


      if (!DOMPurify.isSupported) {
        return dirty;
      }
      /* Assign config vars */


      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      /* Clean up removed elements */


      DOMPurify.removed = [];
      /* Check if dirty is correctly typed for IN_PLACE */

      if (typeof dirty === 'string') {
        IN_PLACE = false;
      }

      if (IN_PLACE) {
        /* Do some early pre-sanitization to avoid unsafe root nodes */
        if (dirty.nodeName) {
          var tagName = transformCaseFunc(dirty.nodeName);

          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
          }
        }
      } else if (dirty instanceof Node) {
        /* If dirty is a DOM element, append to an empty document to avoid
           elements being stripped by the parser */
        body = _initDocument('<!---->');
        importedNode = body.ownerDocument.importNode(dirty, true);

        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
          /* Node is already a body, use as is */
          body = importedNode;
        } else if (importedNode.nodeName === 'HTML') {
          body = importedNode;
        } else {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          body.appendChild(importedNode);
        }
      } else {
        /* Exit directly if we have nothing to do */
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf('<') === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        /* Initialize the document to work on */


        body = _initDocument(dirty);
        /* Check we have a DOM node from the data */

        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
        }
      }
      /* Remove first element node (ours) if FORCE_BODY is set */


      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      /* Get node iterator */


      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
      /* Now start iterating over the created document */


      while (currentNode = nodeIterator.nextNode()) {
        /* Sanitize tags and elements */
        if (_sanitizeElements(currentNode)) {
          continue;
        }
        /* Shadow DOM detected, sanitize it */


        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
        /* Check attributes, sanitize if necessary */


        _sanitizeAttributes(currentNode);
      }
      /* If we sanitized `dirty` in-place, return it. */


      if (IN_PLACE) {
        return dirty;
      }
      /* Return sanitized string or DOM */


      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);

          while (body.firstChild) {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }

        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
          /*
            AdoptNode() is not used because internal state is not reset
            (e.g. the past names map of a HTMLFormElement), this is safe
            in theory but we would rather not risk another attack vector.
            The state that is cloned by importNode() is explicitly defined
            by the specs.
          */
          returnNode = importNode.call(originalDocument, returnNode, true);
        }

        return returnNode;
      }

      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      /* Serialize doctype if allowed */

      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
      }
      /* Sanitize final string template-safe */


      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, ' ');
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, ' ');
        serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR$1, ' ');
      }

      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    /**
     * Public method to set the configuration once
     * setConfig
     *
     * @param {Object} cfg configuration object
     */


    DOMPurify.setConfig = function (cfg) {
      _parseConfig(cfg);

      SET_CONFIG = true;
    };
    /**
     * Public method to remove the configuration
     * clearConfig
     *
     */


    DOMPurify.clearConfig = function () {
      CONFIG = null;
      SET_CONFIG = false;
    };
    /**
     * Public method to check if an attribute value is valid.
     * Uses last set config, if any. Otherwise, uses config defaults.
     * isValidAttribute
     *
     * @param  {string} tag Tag name of containing element.
     * @param  {string} attr Attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
     */


    DOMPurify.isValidAttribute = function (tag, attr, value) {
      /* Initialize shared config vars if necessary. */
      if (!CONFIG) {
        _parseConfig({});
      }

      var lcTag = transformCaseFunc(tag);
      var lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    /**
     * AddHook
     * Public method to add DOMPurify hooks
     *
     * @param {String} entryPoint entry point for the hook to add
     * @param {Function} hookFunction function to execute
     */


    DOMPurify.addHook = function (entryPoint, hookFunction) {
      if (typeof hookFunction !== 'function') {
        return;
      }

      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };
    /**
     * RemoveHook
     * Public method to remove a DOMPurify hook at a given entryPoint
     * (pops it from the stack of hooks if more are present)
     *
     * @param {String} entryPoint entry point for the hook to remove
     * @return {Function} removed(popped) hook
     */


    DOMPurify.removeHook = function (entryPoint) {
      if (hooks[entryPoint]) {
        return arrayPop(hooks[entryPoint]);
      }
    };
    /**
     * RemoveHooks
     * Public method to remove all DOMPurify hooks at a given entryPoint
     *
     * @param  {String} entryPoint entry point for the hooks to remove
     */


    DOMPurify.removeHooks = function (entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };
    /**
     * RemoveAllHooks
     * Public method to remove all DOMPurify hooks
     *
     */


    DOMPurify.removeAllHooks = function () {
      hooks = {};
    };

    return DOMPurify;
  }

  var purify = createDOMPurify();

  return purify;

}));
//# sourceMappingURL=purify.js.map


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(23);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _focusTrap = __webpack_require__(193);

var _focusTrap2 = _interopRequireDefault(_focusTrap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // focus-trap-react by davidtheclark, URL: https://github.com/davidtheclark/focus-trap-react

var FocusTrap = function (_React$Component) {
	_inherits(FocusTrap, _React$Component);

	function FocusTrap(props) {
		_classCallCheck(this, FocusTrap);

		var _this = _possibleConstructorReturn(this, (FocusTrap.__proto__ || Object.getPrototypeOf(FocusTrap)).call(this, props));

		if (typeof document !== 'undefined') {
			_this.previouslyFocusedElement = document.activeElement;
		}
		return _this;
	}

	_createClass(FocusTrap, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			// We need to hijack the returnFocusOnDeactivate option,
			// because React can move focus into the element before we arrived at
			// this lifecycle hook (e.g. with autoFocus inputs). So the component
			// captures the previouslyFocusedElement in componentWillMount,
			// then (optionally) returns focus to it in componentWillUnmount.
			var specifiedFocusTrapOptions = this.props.focusTrapOptions;

			var tailoredFocusTrapOptions = {
				returnFocusOnDeactivate: false,
				fallbackFocus: 'body'
			};

			for (var optionName in specifiedFocusTrapOptions) {
				if (!specifiedFocusTrapOptions.hasOwnProperty(optionName)) continue;

				if (optionName === 'returnFocusOnDeactivate') continue;

				tailoredFocusTrapOptions[optionName] = specifiedFocusTrapOptions[optionName];
			}

			var focusTrapElementDOMNode = _reactDom2.default.findDOMNode(this.focusTrapElement);

			this.focusTrap = this.props._createFocusTrap(focusTrapElementDOMNode, tailoredFocusTrapOptions);

			if (this.props.active) {
				this.focusTrap.activate();
			}

			if (this.props.paused) {
				this.focusTrap.pause();
			}
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps) {
			if (prevProps.active && !this.props.active) {
				var returnFocusOnDeactivate = this.props.focusTrapOptions.returnFocusOnDeactivate;

				var returnFocus = returnFocusOnDeactivate || false;
				var config = { returnFocus: returnFocus };
				this.focusTrap.deactivate(config);
			} else if (!prevProps.active && this.props.active) {
				this.focusTrap.activate();
			}

			if (prevProps.paused && !this.props.paused) {
				this.focusTrap.unpause();
			} else if (!prevProps.paused && this.props.paused) {
				this.focusTrap.pause();
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.focusTrap.deactivate();
			if (this.props.focusTrapOptions.returnFocusOnDeactivate !== false && this.previouslyFocusedElement && this.previouslyFocusedElement.focus) {
				this.previouslyFocusedElement.focus();
			}
		}
	}, {
		key: 'setFocusTrapElement',
		value: function setFocusTrapElement(element) {
			this.focusTrapElement = element;
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var child = _react2.default.Children.only(this.props.children);

			var composedRefCallback = function composedRefCallback(element) {
				_this2.setFocusTrapElement(element);

				if (typeof child.ref === 'function') {
					child.ref(element);
				}
			};

			var childWithRef = _react2.default.cloneElement(child, { ref: composedRefCallback });

			return childWithRef;
		}
	}]);

	return FocusTrap;
}(_react2.default.Component);

FocusTrap.defaultProps = {
	active: true,
	paused: false,
	focusTrapOptions: {},
	_createFocusTrap: _focusTrap2.default
};

module.exports = FocusTrap;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var tabbable = __webpack_require__(194);
var xtend = __webpack_require__(195);

var activeFocusDelay;

var activeFocusTraps = (function() {
  var trapQueue = [];
  return {
    activateTrap: function(trap) {
      if (trapQueue.length > 0) {
        var activeTrap = trapQueue[trapQueue.length - 1];
        if (activeTrap !== trap) {
          activeTrap.pause();
        }
      }

      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex === -1) {
        trapQueue.push(trap);
      } else {
        // move this existing trap to the front of the queue
        trapQueue.splice(trapIndex, 1);
        trapQueue.push(trap);
      }
    },

    deactivateTrap: function(trap) {
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex !== -1) {
        trapQueue.splice(trapIndex, 1);
      }

      if (trapQueue.length > 0) {
        trapQueue[trapQueue.length - 1].unpause();
      }
    }
  };
})();

function focusTrap(element, userOptions) {
  var doc = document;
  var container =
    typeof element === 'string' ? doc.querySelector(element) : element;

  var config = xtend(
    {
      returnFocusOnDeactivate: true,
      escapeDeactivates: true
    },
    userOptions
  );

  var state = {
    firstTabbableNode: null,
    lastTabbableNode: null,
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false
  };

  var trap = {
    activate: activate,
    deactivate: deactivate,
    pause: pause,
    unpause: unpause
  };

  return trap;

  function activate(activateOptions) {
    if (state.active) return;

    updateTabbableNodes();

    state.active = true;
    state.paused = false;
    state.nodeFocusedBeforeActivation = doc.activeElement;

    var onActivate =
      activateOptions && activateOptions.onActivate
        ? activateOptions.onActivate
        : config.onActivate;
    if (onActivate) {
      onActivate();
    }

    addListeners();
    return trap;
  }

  function deactivate(deactivateOptions) {
    if (!state.active) return;

    clearTimeout(activeFocusDelay);

    removeListeners();
    state.active = false;
    state.paused = false;

    activeFocusTraps.deactivateTrap(trap);

    var onDeactivate =
      deactivateOptions && deactivateOptions.onDeactivate !== undefined
        ? deactivateOptions.onDeactivate
        : config.onDeactivate;
    if (onDeactivate) {
      onDeactivate();
    }

    var returnFocus =
      deactivateOptions && deactivateOptions.returnFocus !== undefined
        ? deactivateOptions.returnFocus
        : config.returnFocusOnDeactivate;
    if (returnFocus) {
      delay(function() {
        tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
      });
    }

    return trap;
  }

  function pause() {
    if (state.paused || !state.active) return;
    state.paused = true;
    removeListeners();
  }

  function unpause() {
    if (!state.paused || !state.active) return;
    state.paused = false;
    updateTabbableNodes();
    addListeners();
  }

  function addListeners() {
    if (!state.active) return;

    // There can be only one listening focus trap at a time
    activeFocusTraps.activateTrap(trap);

    // Delay ensures that the focused element doesn't capture the event
    // that caused the focus trap activation.
    activeFocusDelay = delay(function() {
      tryFocus(getInitialFocusNode());
    });

    doc.addEventListener('focusin', checkFocusIn, true);
    doc.addEventListener('mousedown', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('touchstart', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('click', checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener('keydown', checkKey, {
      capture: true,
      passive: false
    });

    return trap;
  }

  function removeListeners() {
    if (!state.active) return;

    doc.removeEventListener('focusin', checkFocusIn, true);
    doc.removeEventListener('mousedown', checkPointerDown, true);
    doc.removeEventListener('touchstart', checkPointerDown, true);
    doc.removeEventListener('click', checkClick, true);
    doc.removeEventListener('keydown', checkKey, true);

    return trap;
  }

  function getNodeForOption(optionName) {
    var optionValue = config[optionName];
    var node = optionValue;
    if (!optionValue) {
      return null;
    }
    if (typeof optionValue === 'string') {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error('`' + optionName + '` refers to no known node');
      }
    }
    if (typeof optionValue === 'function') {
      node = optionValue();
      if (!node) {
        throw new Error('`' + optionName + '` did not return a node');
      }
    }
    return node;
  }

  function getInitialFocusNode() {
    var node;
    if (getNodeForOption('initialFocus') !== null) {
      node = getNodeForOption('initialFocus');
    } else if (container.contains(doc.activeElement)) {
      node = doc.activeElement;
    } else {
      node = state.firstTabbableNode || getNodeForOption('fallbackFocus');
    }

    if (!node) {
      throw new Error(
        'Your focus-trap needs to have at least one focusable element'
      );
    }

    return node;
  }

  function getReturnFocusNode(previousActiveElement) {
    var node = getNodeForOption('setReturnFocus');
    return node ? node : previousActiveElement;
  }

  // This needs to be done on mousedown and touchstart instead of click
  // so that it precedes the focus event.
  function checkPointerDown(e) {
    if (container.contains(e.target)) return;
    if (config.clickOutsideDeactivates) {
      deactivate({
        returnFocus: !tabbable.isFocusable(e.target)
      });
      return;
    }
    // This is needed for mobile devices.
    // (If we'll only let `click` events through,
    // then on mobile they will be blocked anyways if `touchstart` is blocked.)
    if (config.allowOutsideClick && config.allowOutsideClick(e)) {
      return;
    }
    e.preventDefault();
  }

  // In case focus escapes the trap for some strange reason, pull it back in.
  function checkFocusIn(e) {
    // In Firefox when you Tab out of an iframe the Document is briefly focused.
    if (container.contains(e.target) || e.target instanceof Document) {
      return;
    }
    e.stopImmediatePropagation();
    tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
  }

  function checkKey(e) {
    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
      e.preventDefault();
      deactivate();
      return;
    }
    if (isTabEvent(e)) {
      checkTab(e);
      return;
    }
  }

  // Hijack Tab events on the first and last focusable nodes of the trap,
  // in order to prevent focus from escaping. If it escapes for even a
  // moment it can end up scrolling the page and causing confusion so we
  // kind of need to capture the action at the keydown phase.
  function checkTab(e) {
    updateTabbableNodes();
    if (e.shiftKey && e.target === state.firstTabbableNode) {
      e.preventDefault();
      tryFocus(state.lastTabbableNode);
      return;
    }
    if (!e.shiftKey && e.target === state.lastTabbableNode) {
      e.preventDefault();
      tryFocus(state.firstTabbableNode);
      return;
    }
  }

  function checkClick(e) {
    if (config.clickOutsideDeactivates) return;
    if (container.contains(e.target)) return;
    if (config.allowOutsideClick && config.allowOutsideClick(e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  }

  function updateTabbableNodes() {
    var tabbableNodes = tabbable(container);
    state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();
    state.lastTabbableNode =
      tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();
  }

  function tryFocus(node) {
    if (node === doc.activeElement) return;
    if (!node || !node.focus) {
      tryFocus(getInitialFocusNode());
      return;
    }
    node.focus();
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  }
}

function isSelectableInput(node) {
  return (
    node.tagName &&
    node.tagName.toLowerCase() === 'input' &&
    typeof node.select === 'function'
  );
}

function isEscapeEvent(e) {
  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
}

function isTabEvent(e) {
  return e.key === 'Tab' || e.keyCode === 9;
}

function delay(fn) {
  return setTimeout(fn, 0);
}

module.exports = focusTrap;


/***/ }),
/* 194 */
/***/ (function(module, exports) {

var candidateSelectors = [
  'input',
  'select',
  'textarea',
  'a[href]',
  'button',
  '[tabindex]',
  'audio[controls]',
  'video[controls]',
  '[contenteditable]:not([contenteditable="false"])',
];
var candidateSelector = candidateSelectors.join(',');

var matches = typeof Element === 'undefined'
  ? function () {}
  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

function tabbable(el, options) {
  options = options || {};

  var regularTabbables = [];
  var orderedTabbables = [];

  var candidates = el.querySelectorAll(candidateSelector);

  if (options.includeContainer) {
    if (matches.call(el, candidateSelector)) {
      candidates = Array.prototype.slice.apply(candidates);
      candidates.unshift(el);
    }
  }

  var i, candidate, candidateTabindex;
  for (i = 0; i < candidates.length; i++) {
    candidate = candidates[i];

    if (!isNodeMatchingSelectorTabbable(candidate)) continue;

    candidateTabindex = getTabindex(candidate);
    if (candidateTabindex === 0) {
      regularTabbables.push(candidate);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        node: candidate,
      });
    }
  }

  var tabbableNodes = orderedTabbables
    .sort(sortOrderedTabbables)
    .map(function(a) { return a.node })
    .concat(regularTabbables);

  return tabbableNodes;
}

tabbable.isTabbable = isTabbable;
tabbable.isFocusable = isFocusable;

function isNodeMatchingSelectorTabbable(node) {
  if (
    !isNodeMatchingSelectorFocusable(node)
    || isNonTabbableRadio(node)
    || getTabindex(node) < 0
  ) {
    return false;
  }
  return true;
}

function isTabbable(node) {
  if (!node) throw new Error('No node provided');
  if (matches.call(node, candidateSelector) === false) return false;
  return isNodeMatchingSelectorTabbable(node);
}

function isNodeMatchingSelectorFocusable(node) {
  if (
    node.disabled
    || isHiddenInput(node)
    || isHidden(node)
  ) {
    return false;
  }
  return true;
}

var focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');
function isFocusable(node) {
  if (!node) throw new Error('No node provided');
  if (matches.call(node, focusableCandidateSelector) === false) return false;
  return isNodeMatchingSelectorFocusable(node);
}

function getTabindex(node) {
  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);
  if (!isNaN(tabindexAttr)) return tabindexAttr;
  // Browsers do not return `tabIndex` correctly for contentEditable nodes;
  // so if they don't have a tabindex attribute specifically set, assume it's 0.
  if (isContentEditable(node)) return 0;
  return node.tabIndex;
}

function sortOrderedTabbables(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
}

function isContentEditable(node) {
  return node.contentEditable === 'true';
}

function isInput(node) {
  return node.tagName === 'INPUT';
}

function isHiddenInput(node) {
  return isInput(node) && node.type === 'hidden';
}

function isRadio(node) {
  return isInput(node) && node.type === 'radio';
}

function isNonTabbableRadio(node) {
  return isRadio(node) && !isTabbableRadio(node);
}

function getCheckedRadio(nodes) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked) {
      return nodes[i];
    }
  }
}

function isTabbableRadio(node) {
  if (!node.name) return true;
  // This won't account for the edge case where you have radio groups with the same
  // in separate forms on the same page.
  var radioSet = node.ownerDocument.querySelectorAll('input[type="radio"][name="' + node.name + '"]');
  var checked = getCheckedRadio(radioSet);
  return !checked || checked === node;
}

function isHidden(node) {
  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,
  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.
  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';
}

module.exports = tabbable;


/***/ }),
/* 195 */
/***/ (function(module, exports) {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _integrations = __webpack_require__(197);

var _integrations2 = _interopRequireDefault(_integrations);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// noinspection JSUnusedLocalSymbols

// the semi-colon before function invocation is a safety net against concatenated
// scripts and/or other plugins which may not be closed properly.
(function ($, window, document, undefined) {
	// Create the defaults once
	var pluginName = 'ForminatorIntegrationsModal';
	var defaults = {
		type: 'form'
	};

	function ForminatorIntegrationsModal(addons, options) {
		this.$popup = {};
		this._deferred = {};
		this.el = addons;
		this.$el = jQuery(this.el);
		this.options = _.extend(defaults, options);
		this.init();
	}

	// Avoid Plugin.prototype conflicts
	jQuery.extend(ForminatorIntegrationsModal.prototype, {
		init: function init() {
			var me = this;

			this.$el.find('.connect-integration').on('click', function (e) {
				me.open(e);
			});
		},

		open: function open(e) {
			var self = this;

			// Remove popup
			jQuery('#forminator-integration-popup').remove();

			var $target = jQuery(e.target);

			if (!$target.hasClass('connect-integration')) {
				$target = $target.closest('.connect-integration');
			}

			var closeClick = function closeClick() {
				self.close();
				return false;
			};

			var nonce = $target.data('nonce'),
			    slug = $target.data('slug'),
			    global_id = $target.data('multi-global-id'),
			    title = $target.data('title'),
			    image = $target.data('image'),
			    image2x = $target.data('imagex2'),
			    action = $target.data('action'),
			    form_id = $target.data('form-id'),
			    multi_id = $target.data('multi-id'),
			    poll_id = $target.data('poll-id'),
			    quiz_id = $target.data('quiz-id');

			var tpl = _.template('<div class="sui-modal sui-modal-lg">' +
			// Modal content.
			'<div role="dialog" id="forminator-integration-popup" class="sui-modal-content" aria-modal="true" aria-labelledby="forminator-integration-popup__title" aria-describedby="forminator-integration-popup__description">' +
			// Box.
			'<div class="sui-box" style="margin-bottom: 0;">' +
			// Box Header.
			'<div class="sui-box-header sui-flatten sui-content-center sui-spacing-top--60">' +
			// Button "Close".
			'<button class="sui-button-icon sui-button-float--right forminator-popup-close">' + '<span class="sui-icon-close sui-md" aria-hidden="true"></span>' + '<span class="sui-screen-reader-text">Close</span>' + '</button>' +
			// Button "Back".
			'<button class="sui-button-icon sui-button-float--left forminator-addon-back">' + '<span class="sui-icon-chevron-left sui-md" aria-hidden="true"></span>' + '<span class="sui-screen-reader-text">Back</span>' + '</button>' +
			// Logo.
			'<figure class="sui-box-logo" aria-hidden="true">' + '<img src="<%= image %>" srcset="<%= image %> 1x, <%= image2x %> 2x" alt="<%= title %>" />' + '</figure>' +
			// Header content.
			'<div class="forminator-integration-popup__header"></div>' + '</div>' +
			// Box Body.
			'<div class="sui-box-body"></div>' +
			// Box Footer.
			'<div class="sui-box-footer sui-flatten sui-content-center"></div>' + '</div>' + '</div>' + '</div>');

			jQuery('main.sui-wrap').append(tpl({
				image: image,
				image2x: image2x,
				title: title
			}));

			this.$popup = jQuery('#forminator-integration-popup');

			var viewOptions = {
				slug: slug,
				nonce: nonce,
				action: action,
				multi_id: multi_id,
				global_id: global_id,
				el: this.$popup,
				type: self.options.type
			};

			if (self.options.type === 'form') {
				viewOptions.form_id = form_id;
			} else if (self.options.type === 'poll') {
				viewOptions.poll_id = poll_id;
			} else if (self.options.type === 'quiz') {
				viewOptions.quiz_id = quiz_id;
			}

			var view = new _integrations2.default(viewOptions);

			view.on('modal:closed', function () {
				self.close();
			});

			this.$popup.find('.forminator-popup-action').remove();

			// Add closing event
			this.$popup.find('.forminator-popup-close').on('click', closeClick);
			this.$popup.on('click', '.forminator-popup-cancel', closeClick);

			// open
			SUI.openModal('forminator-integration-popup', 'forminator-form-appearance', undefined, true, true);

			this._deferred = new jQuery.Deferred();
			return this._deferred.promise();
		},

		close: function close(result) {
			SUI.closeModal();
			this.$el.trigger('reload');
			this._deferred.resolve(this.$popup, result);
		}
	});

	// A really lightweight plugin wrapper around the constructor,
	// preventing against multiple instantiations
	jQuery.fn[pluginName] = function (options) {
		return this.each(function () {
			// eslint-disable-next-line no-new
			new ForminatorIntegrationsModal(this, options);
		});
	};
})(jQuery, window, document); /* eslint-disable max-len */

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _notifications = __webpack_require__(30);

var _notifications2 = _interopRequireDefault(_notifications);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ForminatorIntegrations = function (_Backbone$View) {
	_inherits(ForminatorIntegrations, _Backbone$View);

	function ForminatorIntegrations(options) {
		var _ret;

		_classCallCheck(this, ForminatorIntegrations);

		var _this = _possibleConstructorReturn(this, (ForminatorIntegrations.__proto__ || Object.getPrototypeOf(ForminatorIntegrations)).call(this, {
			el: options.el,

			tagName: 'div',

			events: {
				'click .forminator-addon-connect': 'connectAddon',
				'click .forminator-addon-disconnect': 'disconnectAddon',
				'click .forminator-addon-form-disconnect': 'formDisconnectAddon',
				'click .forminator-addon-next': 'submitNextStep',
				'click .forminator-addon-back': 'goPrevStep',
				'click .forminator-addon-finish': 'finishSteps',
				'click .forminator-refresh-email-lists': 'refreshLists',
				'change select#group': 'showInterests'
			}
		}));

		_this.slug = options.slug;
		_this.nonce = options.nonce;
		_this.action = options.action;
		_this.multi_id = options.multi_id;
		_this.global_id = options.global_id;
		_this.type = options.type;
		_this.step = 0;
		_this.next_step = false;
		_this.prev_step = false;
		_this.scrollbar_width = _this.getScrollbarWidth();

		if (_this.type === 'form') {
			_this.module_id = options.form_id;
		} else if (_this.type === 'poll') {
			_this.module_id = options.poll_id;
		} else if (_this.type === 'quiz') {
			_this.module_id = options.quiz_id;
		}

		return _ret = _this.render(), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(ForminatorIntegrations, [{
		key: 'render',
		value: function render() {
			var data = {};

			data.action = this.action;
			data._ajax_nonce = this.nonce;
			data.data = {};
			data.data.slug = this.slug;
			data.data.step = this.step;
			data.data.current_step = this.step;
			data.data.global_id = this.global_id;
			data.data = this.getAjaxModuleData(data.data, true);

			this.request(data, false, true);
		}
	}, {
		key: 'applyLoader',
		value: function applyLoader($element) {
			$element.find('.sui-button:not(.disable-loader)').addClass('sui-button-onload');
		}
	}, {
		key: 'resetLoader',
		value: function resetLoader($element) {
			$element.find('.sui-button').removeClass('sui-button-onload');
		}
	}, {
		key: 'request',
		value: function request(data, close, loader) {
			var self = this,
			    function_params = {
				data: data,
				close: close,
				loader: loader
			};

			if (loader) {
				this.$el.find('.sui-box-body').html('<p class="fui-loading-dialog" style="text-align: center;" aria-label="Loading content">' + '<span class="sui-icon-loader sui-md sui-loading" aria-hidden="true"></span>' + '</p>');
				this.$el.find('.sui-box-footer').html('');
				this.$el.find('.forminator-integration-popup__header').html('');
			}

			self.applyLoader(self.$el);

			this.ajax = jQuery.post({
				url: forminatorData.ajaxUrl,
				type: 'post',
				data: data
			}).done(function (result) {
				if (result && result.success) {
					// Render popup body
					self.renderBody(result);

					// Render popup footer
					self.renderFooter(result);

					// Shorten result data
					var resultData = result.data.data;

					self.onRender(resultData);

					self.resetLoader(self.$el);

					// Handle close modal
					if (close || !_.isUndefined(resultData.is_close) && resultData.is_close) {
						self.close(self);
					}

					// Add closing event
					self.$el.find('.forminator-addon-close').on('click', function () {
						self.close(self);
					});

					// Handle notifications
					if (!_.isUndefined(resultData.notification) && !_.isUndefined(resultData.notification.type) && !_.isUndefined(resultData.notification.text)) {
						var custom = new _notifications2.default({
							type: resultData.notification.type,
							text: resultData.notification.text,
							time: 4000
						});
						custom.open();
					}

					// Handle back button
					if (!_.isUndefined(resultData.has_back)) {
						if (resultData.has_back) {
							self.$el.find('.forminator-addon-back').show();
						} else {
							self.$el.find('.forminator-addon-back').hide();
						}
					} else {
						self.$el.find('.forminator-addon-back').hide();
					}

					// Handle modal size
					if (!_.isUndefined(resultData.size)) {
						var $popup = jQuery('#forminator-integration-popup');

						// Remove all sizes
						if (resultData.size === 'normal') {
							$popup.removeClass('sui-modal-sm sui-modal-lg');
						}

						if (resultData.size === 'small') {
							$popup.addClass('sui-modal-sm');
							$popup.removeClass('sui-modal-lg sui-modal-reduced');
						}

						if (resultData.size === 'reduced') {
							$popup.addClass('sui-modal-sm');
							$popup.removeClass('sui-modal-lg sui-modal-md');
						}

						if (resultData.size === 'large') {
							$popup.addClass('sui-modal-lg');
							$popup.removeClass('sui-modal-sm sui-modal-md');
						}
					}

					if (resultData.is_poll) {
						setTimeout(self.request(function_params.data, function_params.close, function_params.loader), 5000);
					}

					setTimeout(function () {
						// Rebind Accordion scripts
						SUI.suiAccordion(jQuery('.sui-accordion'));

						// Rebind Tabs scripts
						SUI.suiTabs(jQuery('.sui-tabs'));

						// Rebind Select2 scripts.
						jQuery('select.sui-select[data-theme="icon"]').each(function () {
							SUI.select.initIcon(jQuery(this));
						});

						jQuery('select.sui-select[data-theme="color"]').each(function () {
							SUI.select.initColor(jQuery(this));
						});

						jQuery('select.sui-select[data-theme="search"]').each(function () {
							SUI.select.initSearch(jQuery(this));
						});

						jQuery('select.sui-select:not([data-theme]):not(.custom-select2):not(.fui-multi-select)').each(function () {
							SUI.select.init(jQuery(this));
						});

						// Rebind Variables scripts.
						jQuery('select.sui-variables').each(function () {
							SUI.select.initVars(jQuery(this));
						});

						// Rebind Circle scripts
						SUI.loadCircleScore(jQuery('.sui-circle-score'));

						// Rebind Password scripts
						SUI.showHidePassword();
					}, 10);

					//check the height
					var $popupBox = jQuery('#forminator-integration-popup .sui-box'),
					    $popupBoxHeight = $popupBox.height(),
					    $windowHeight = jQuery(window).height();

					// scrollbar appear
					if ($popupBoxHeight > $windowHeight) {
						// make scrollbar clickable
						jQuery('#forminator-integration-popup .sui-modal-overlay').css('right', self.scrollbar_width + 'px');
					} else {
						jQuery('#forminator-integration-popup .sui-modal-overlay').css('right', 0);
					}
				}
				// Show Mailchimp interests is Group is already choosen.
				if ('mailchimp' === self.slug) {
					var group = self.$el.find('#group');
					if (group.length) {
						group.trigger('change');
					}
				}
			});

			//remove the preloader
			this.ajax.always(function () {
				self.$el.find('.fui-loading-dialog').remove();
			});
		}
	}, {
		key: 'renderBody',
		value: function renderBody(result) {
			this.$el.find('.sui-box-body').html(result.data.data.html);
			// append header to integration-header
			var integrationHeader = this.$el.find('.sui-box-body .forminator-integration-popup__header').remove();
			if (integrationHeader.length > 0) {
				this.$el.find('.forminator-integration-popup__header').html(integrationHeader.html());
			}
		}
	}, {
		key: 'renderFooter',
		value: function renderFooter(result) {
			var self = this,
			    buttons = result.data.data.buttons;

			// Clear footer from previous buttons
			self.$el.find('.sui-box-footer').html('');

			// Append buttons
			_.each(buttons, function (button) {
				self.$el.find('.sui-box-footer').append(button.markup);
			});
		}
	}, {
		key: 'onRender',
		value: function onRender(result) {
			// this.delegateEvents();

			// Delegate SUI events
			(0, _utils.suiDelegateEvents)();
			// multi select (Tags)
			(0, _utils.select2Tags)(this.$el, {});

			// Update current step
			if (!_.isUndefined(result.forminator_addon_current_step)) {
				this.step = +result.forminator_addon_current_step;
			}

			// Update has next step
			if (!_.isUndefined(result.forminator_addon_has_next_step)) {
				this.next_step = result.forminator_addon_has_next_step;
			}

			// Update has prev step
			if (!_.isUndefined(result.forminator_addon_has_prev_step)) {
				this.prev_step = result.forminator_addon_has_prev_step;
			}
		}
	}, {
		key: 'close',
		value: function close(self) {
			// Kill AJAX hearbeat
			self.ajax.abort();

			// Remove the view
			self.remove();

			this.trigger('modal:closed');
		}
	}, {
		key: 'refreshLists',
		value: function refreshLists(e) {
			e.preventDefault();
			e.stopPropagation();

			var self = this,
			    $this = jQuery(e.currentTarget),
			    slug = this.slug,
			    global_id = this.global_id,
			    nonce = this.nonce,
			    params = {
				slug: slug,
				global_id: global_id
			};

			$this.addClass('sui-button-onload');

			jQuery.ajax({
				url: ajaxurl,
				type: 'POST',
				data: {
					action: 'forminator_refresh_email_lists',
					data: params,
					_ajax_nonce: nonce // eslint-disable-line camelcase
				}
			}).done(function (result) {
				if (result.success) {
					if ('undefined' !== typeof result.data.options) {
						var $select = $this.siblings('.sui-select'),
						    getParent = $select.closest('.sui-modal-content'),
						    getParentId = getParent.attr('id'),
						    selectParent = getParent.length ? jQuery('#' + getParentId) : jQuery('body'),
						    hasSearch = 'true' === $select.attr('data-search') ? 0 : -1,
						    isSmall = $select.hasClass('sui-select-sm') ? 'sui-select-dropdown-sm' : '';

						$select.html(result.data.options);
						$select.SUIselect2({
							dropdownParent: selectParent,
							minimumResultsForSearch: hasSearch,
							dropdownCssClass: isSmall
						});
					}
				}
			}).fail(function () {
				// TODO: handle errors
			}).always(function () {
				$this.removeClass('sui-button-onload');
			});
		}

		// Show interests for mailchimp.

	}, {
		key: 'showInterests',
		value: function showInterests(e) {
			var self = this,
			    $this = jQuery(e.currentTarget),
			    nonce = $this.data('nonce'),
			    data = {},
			    form = self.$el.find('form'),
			    params = {
				slug: self.slug,
				global_id: this.global_id,
				module_id: this.module_id,
				module_type: this.type
			};

			var formData = form.serialize();

			formData = formData + '&' + jQuery.param(params);
			data.action = 'forminator_mailchimp_get_group_interests';
			// eslint-disable-next-line camelcase
			data._ajax_nonce = nonce;
			data.data = formData;

			self.applyLoader(self.$el);

			jQuery.ajax({
				url: ajaxurl,
				type: 'POST',
				data: data
			}).done(function (result) {
				if (result.success) {
					form.find('.sui-form-field').slice(1).remove();
					form.find('.sui-form-field:first-child').after(result.data);
					form.find('.sui-form-field').slice(1).find('select').each(function () {
						SUI.select.init(jQuery(this));
					});
				}
			}).fail(function () {
				// TODO: handle errors
			}).always(function () {
				self.resetLoader(self.$el);
			});
		}
	}, {
		key: 'submitNextStep',
		value: function submitNextStep(e) {
			var data = {},
			    form = this.$el.find('form');
			var params = {
				slug: this.slug,
				step: this.getStep(),
				global_id: this.global_id,
				current_step: this.step
			};
			var formData = form.serialize();

			params = this.getAjaxModuleData(params, false);

			formData = formData + '&' + jQuery.param(params);
			data.action = this.action;
			data._ajax_nonce = this.nonce;
			data.data = formData;

			this.request(data, false, false);
		}
	}, {
		key: 'goPrevStep',
		value: function goPrevStep(e) {
			var data = {};
			var params = {
				slug: this.slug,
				step: this.getPrevStep(),
				global_id: this.global_id,
				current_step: this.step
			};

			params = this.getAjaxModuleData(params, true);

			data.action = this.action;
			data._ajax_nonce = this.nonce;
			data.data = params;

			this.request(data, false, false);
		}
	}, {
		key: 'finishSteps',
		value: function finishSteps(e) {
			var data = {},
			    form = this.$el.find('form');
			var params = {
				slug: this.slug,
				step: this.getStep(),
				global_id: this.global_id,
				current_step: this.step
			};

			var formData = form.serialize();

			params = this.getAjaxModuleData(params, true);

			formData = formData + '&' + jQuery.param(params);
			data.action = this.action;
			data._ajax_nonce = this.nonce;
			data.data = formData;

			this.request(data, false, false);
		}
	}, {
		key: 'getStep',
		value: function getStep() {
			if (this.next_step) {
				return this.step + 1;
			}

			return this.step;
		}
	}, {
		key: 'getPrevStep',
		value: function getPrevStep() {
			if (this.prev_step) {
				return this.step - 1;
			}

			return this.step;
		}
	}, {
		key: 'connectAddon',
		value: function connectAddon() {
			var data = {},
			    form = this.$el.find('form');
			var params = {
				slug: this.slug,
				step: this.getStep(),
				global_id: this.global_id,
				current_step: this.step
			};

			var formData = form.serialize();

			params = this.getAjaxModuleData(params, true);

			formData = formData + '&' + jQuery.param(params);
			data.action = this.action;
			data._ajax_nonce = this.nonce;
			data.data = formData;

			this.request(data, false, false);
		}
	}, {
		key: 'disconnectAddon',
		value: function disconnectAddon() {
			var data = {};
			data.action = 'forminator_addon_deactivate';
			data._ajax_nonce = this.nonce;
			data.data = {};
			data.data.slug = this.slug;
			data.data.global_id = this.global_id;

			this.request(data, true, false);
		}
	}, {
		key: 'formDisconnectAddon',
		value: function formDisconnectAddon() {
			var data = {};
			data.action = this.getAjaxModuleAction('deactivate');
			data._ajax_nonce = this.nonce;
			data.data = {};
			data.data.slug = this.slug;

			data.data = this.getAjaxModuleData(data.data, true);

			this.request(data, true, false);
		}
	}, {
		key: 'getScrollbarWidth',
		value: function getScrollbarWidth() {
			//https://github.com/brandonaaron/jquery-getscrollbarwidth/
			var scrollbarWidth = 0;
			if (navigator.userAgent.match("MSIE")) {
				var $textarea1 = jQuery('<textarea cols="10" rows="2"></textarea>').css({ position: 'absolute', top: -1000, left: -1000 }).appendTo('body'),
				    $textarea2 = jQuery('<textarea cols="10" rows="2" style="overflow: hidden;"></textarea>').css({ position: 'absolute', top: -1000, left: -1000 }).appendTo('body');
				scrollbarWidth = $textarea1.width() - $textarea2.width();
				$textarea1.add($textarea2).remove();
			} else {
				var $div = jQuery('<div />').css({
					width: 100,
					height: 100,
					overflow: 'auto',
					position: 'absolute',
					top: -1000,
					left: -1000
				}).prependTo('body').append('<div />').find('div').css({ width: '100%', height: 200 });
				scrollbarWidth = 100 - $div.width();
				$div.parent().remove();
			}

			return scrollbarWidth;
		}
	}, {
		key: 'getAjaxModuleData',
		value: function getAjaxModuleData(data, with_multi_id) {
			if (this.module_id) {
				data.module_id = this.module_id;
				data.module_type = this.type;
				data.global_id = this.global_id;
			}

			if (with_multi_id) {
				if (this.multi_id) {
					data.multi_id = this.multi_id;
				}
			}

			return data;
		}
	}, {
		key: 'getAjaxModuleAction',
		value: function getAjaxModuleAction(action) {
			switch (action) {
				case 'deactivate':
					action = 'forminator_addon_deactivate_for_module';
					break;
			}

			return action;
		}
	}]);

	return ForminatorIntegrations;
}(Backbone.View);

exports.default = ForminatorIntegrations;

/***/ }),
/* 198 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["Headers"] = Headers;
/* harmony export (immutable) */ __webpack_exports__["Request"] = Request;
/* harmony export (immutable) */ __webpack_exports__["Response"] = Response;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOMException", function() { return DOMException; });
/* harmony export (immutable) */ __webpack_exports__["fetch"] = fetch;
var support = {
  searchParams: 'URLSearchParams' in self,
  iterable: 'Symbol' in self && 'iterator' in Symbol,
  blob:
    'FileReader' in self &&
    'Blob' in self &&
    (function() {
      try {
        new Blob()
        return true
      } catch (e) {
        return false
      }
    })(),
  formData: 'FormData' in self,
  arrayBuffer: 'ArrayBuffer' in self
}

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ]

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name)
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
    throw new TypeError('Invalid character in header field name')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value)
  }
  return value
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift()
      return {done: value === undefined, value: value}
    }
  }

  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator
    }
  }

  return iterator
}

function Headers(headers) {
  this.map = {}

  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value)
    }, this)
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      this.append(header[0], header[1])
    }, this)
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name])
    }, this)
  }
}

Headers.prototype.append = function(name, value) {
  name = normalizeName(name)
  value = normalizeValue(value)
  var oldValue = this.map[name]
  this.map[name] = oldValue ? oldValue + ', ' + value : value
}

Headers.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)]
}

Headers.prototype.get = function(name) {
  name = normalizeName(name)
  return this.has(name) ? this.map[name] : null
}

Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
}

Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value)
}

Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this)
    }
  }
}

Headers.prototype.keys = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push(name)
  })
  return iteratorFor(items)
}

Headers.prototype.values = function() {
  var items = []
  this.forEach(function(value) {
    items.push(value)
  })
  return iteratorFor(items)
}

Headers.prototype.entries = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push([name, value])
  })
  return iteratorFor(items)
}

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true
}

function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result)
    }
    reader.onerror = function() {
      reject(reader.error)
    }
  })
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsArrayBuffer(blob)
  return promise
}

function readBlobAsText(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsText(blob)
  return promise
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf)
  var chars = new Array(view.length)

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i])
  }
  return chars.join('')
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0)
  } else {
    var view = new Uint8Array(buf.byteLength)
    view.set(new Uint8Array(buf))
    return view.buffer
  }
}

function Body() {
  this.bodyUsed = false

  this._initBody = function(body) {
    this._bodyInit = body
    if (!body) {
      this._bodyText = ''
    } else if (typeof body === 'string') {
      this._bodyText = body
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString()
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer)
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer])
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body)
    } else {
      this._bodyText = body = Object.prototype.toString.call(body)
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8')
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type)
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
      }
    }
  }

  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob')
      } else {
        return Promise.resolve(new Blob([this._bodyText]))
      }
    }

    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
      } else {
        return this.blob().then(readBlobAsArrayBuffer)
      }
    }
  }

  this.text = function() {
    var rejected = consumed(this)
    if (rejected) {
      return rejected
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text')
    } else {
      return Promise.resolve(this._bodyText)
    }
  }

  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode)
    }
  }

  this.json = function() {
    return this.text().then(JSON.parse)
  }

  return this
}

// HTTP methods whose capitalization should be normalized
var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

function normalizeMethod(method) {
  var upcased = method.toUpperCase()
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request(input, options) {
  options = options || {}
  var body = options.body

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read')
    }
    this.url = input.url
    this.credentials = input.credentials
    if (!options.headers) {
      this.headers = new Headers(input.headers)
    }
    this.method = input.method
    this.mode = input.mode
    this.signal = input.signal
    if (!body && input._bodyInit != null) {
      body = input._bodyInit
      input.bodyUsed = true
    }
  } else {
    this.url = String(input)
  }

  this.credentials = options.credentials || this.credentials || 'same-origin'
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers)
  }
  this.method = normalizeMethod(options.method || this.method || 'GET')
  this.mode = options.mode || this.mode || null
  this.signal = options.signal || this.signal
  this.referrer = null

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body)
}

Request.prototype.clone = function() {
  return new Request(this, {body: this._bodyInit})
}

function decode(body) {
  var form = new FormData()
  body
    .trim()
    .split('&')
    .forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
  return form
}

function parseHeaders(rawHeaders) {
  var headers = new Headers()
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
  preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
    var parts = line.split(':')
    var key = parts.shift().trim()
    if (key) {
      var value = parts.join(':').trim()
      headers.append(key, value)
    }
  })
  return headers
}

Body.call(Request.prototype)

function Response(bodyInit, options) {
  if (!options) {
    options = {}
  }

  this.type = 'default'
  this.status = options.status === undefined ? 200 : options.status
  this.ok = this.status >= 200 && this.status < 300
  this.statusText = 'statusText' in options ? options.statusText : 'OK'
  this.headers = new Headers(options.headers)
  this.url = options.url || ''
  this._initBody(bodyInit)
}

Body.call(Response.prototype)

Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  })
}

Response.error = function() {
  var response = new Response(null, {status: 0, statusText: ''})
  response.type = 'error'
  return response
}

var redirectStatuses = [301, 302, 303, 307, 308]

Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response(null, {status: status, headers: {location: url}})
}

var DOMException = self.DOMException
try {
  new DOMException()
} catch (err) {
  DOMException = function(message, name) {
    this.message = message
    this.name = name
    var error = Error(message)
    this.stack = error.stack
  }
  DOMException.prototype = Object.create(Error.prototype)
  DOMException.prototype.constructor = DOMException
}

function fetch(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init)

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'))
    }

    var xhr = new XMLHttpRequest()

    function abortXhr() {
      xhr.abort()
    }

    xhr.onload = function() {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      }
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
      var body = 'response' in xhr ? xhr.response : xhr.responseText
      resolve(new Response(body, options))
    }

    xhr.onerror = function() {
      reject(new TypeError('Network request failed'))
    }

    xhr.ontimeout = function() {
      reject(new TypeError('Network request failed'))
    }

    xhr.onabort = function() {
      reject(new DOMException('Aborted', 'AbortError'))
    }

    xhr.open(request.method, request.url, true)

    if (request.credentials === 'include') {
      xhr.withCredentials = true
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false
    }

    if ('responseType' in xhr && support.blob) {
      xhr.responseType = 'blob'
    }

    request.headers.forEach(function(value, name) {
      xhr.setRequestHeader(name, value)
    })

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr)

      xhr.onreadystatechange = function() {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr)
        }
      }
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
  })
}

fetch.polyfill = true

if (!self.fetch) {
  self.fetch = fetch
  self.Headers = Headers
  self.Request = Request
  self.Response = Response
}


/***/ }),
/* 199 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export ServerStyleSheet */
/* unused harmony export StyleSheetConsumer */
/* unused harmony export StyleSheetContext */
/* unused harmony export StyleSheetManager */
/* unused harmony export ThemeConsumer */
/* unused harmony export ThemeContext */
/* unused harmony export ThemeProvider */
/* unused harmony export __PRIVATE__ */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return We; });
/* unused harmony export css */
/* unused harmony export isStyledComponent */
/* unused harmony export keyframes */
/* unused harmony export useTheme */
/* unused harmony export version */
/* unused harmony export withTheme */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_is__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_is___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react_is__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_shallowequal__ = __webpack_require__(202);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_shallowequal___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_shallowequal__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__emotion_stylis__ = __webpack_require__(203);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__emotion_unitless__ = __webpack_require__(204);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__emotion_is_prop_valid__ = __webpack_require__(205);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_hoist_non_react_statics__ = __webpack_require__(207);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_hoist_non_react_statics___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_hoist_non_react_statics__);
function v(){return(v=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var g=function(e,t){for(var n=[e[0]],r=0,o=t.length;r<o;r+=1)n.push(t[r],e[r+1]);return n},S=function(t){return null!==t&&"object"==typeof t&&"[object Object]"===(t.toString?t.toString():Object.prototype.toString.call(t))&&!Object(__WEBPACK_IMPORTED_MODULE_0_react_is__["typeOf"])(t)},w=Object.freeze([]),E=Object.freeze({});function b(e){return"function"==typeof e}function _(e){return"production"!==process.env.NODE_ENV&&"string"==typeof e&&e||e.displayName||e.name||"Component"}function N(e){return e&&"string"==typeof e.styledComponentId}var A="undefined"!=typeof process&&(process.env.REACT_APP_SC_ATTR||process.env.SC_ATTR)||"data-styled",C="5.3.3",I="undefined"!=typeof window&&"HTMLElement"in window,P=Boolean("boolean"==typeof SC_DISABLE_SPEEDY?SC_DISABLE_SPEEDY:"undefined"!=typeof process&&void 0!==process.env.REACT_APP_SC_DISABLE_SPEEDY&&""!==process.env.REACT_APP_SC_DISABLE_SPEEDY?"false"!==process.env.REACT_APP_SC_DISABLE_SPEEDY&&process.env.REACT_APP_SC_DISABLE_SPEEDY:"undefined"!=typeof process&&void 0!==process.env.SC_DISABLE_SPEEDY&&""!==process.env.SC_DISABLE_SPEEDY?"false"!==process.env.SC_DISABLE_SPEEDY&&process.env.SC_DISABLE_SPEEDY:"production"!==process.env.NODE_ENV),O={},R="production"!==process.env.NODE_ENV?{1:"Cannot create styled-component for component: %s.\n\n",2:"Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n",3:"Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n",4:"The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n",5:"The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n",6:"Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n",7:'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n',8:'ThemeProvider: Please make your "theme" prop an object.\n\n',9:"Missing document `<head>`\n\n",10:"Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n",11:"_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n",12:"It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n",13:"%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n",14:'ThemeProvider: "theme" prop is required.\n\n',15:"A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n",16:"Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n",17:"CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n"}:{};function D(){for(var e=arguments.length<=0?void 0:arguments[0],t=[],n=1,r=arguments.length;n<r;n+=1)t.push(n<0||arguments.length<=n?void 0:arguments[n]);return t.forEach((function(t){e=e.replace(/%[a-z]/,t)})),e}function j(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];throw"production"===process.env.NODE_ENV?new Error("An error occurred. See https://git.io/JUIaE#"+e+" for more information."+(n.length>0?" Args: "+n.join(", "):"")):new Error(D.apply(void 0,[R[e]].concat(n)).trim())}var T=function(){function e(e){this.groupSizes=new Uint32Array(512),this.length=512,this.tag=e}var t=e.prototype;return t.indexOfGroup=function(e){for(var t=0,n=0;n<e;n++)t+=this.groupSizes[n];return t},t.insertRules=function(e,t){if(e>=this.groupSizes.length){for(var n=this.groupSizes,r=n.length,o=r;e>=o;)(o<<=1)<0&&j(16,""+e);this.groupSizes=new Uint32Array(o),this.groupSizes.set(n),this.length=o;for(var s=r;s<o;s++)this.groupSizes[s]=0}for(var i=this.indexOfGroup(e+1),a=0,c=t.length;a<c;a++)this.tag.insertRule(i,t[a])&&(this.groupSizes[e]++,i++)},t.clearGroup=function(e){if(e<this.length){var t=this.groupSizes[e],n=this.indexOfGroup(e),r=n+t;this.groupSizes[e]=0;for(var o=n;o<r;o++)this.tag.deleteRule(n)}},t.getGroup=function(e){var t="";if(e>=this.length||0===this.groupSizes[e])return t;for(var n=this.groupSizes[e],r=this.indexOfGroup(e),o=r+n,s=r;s<o;s++)t+=this.tag.getRule(s)+"/*!sc*/\n";return t},e}(),x=new Map,k=new Map,V=1,B=function(e){if(x.has(e))return x.get(e);for(;k.has(V);)V++;var t=V++;return"production"!==process.env.NODE_ENV&&((0|t)<0||t>1<<30)&&j(16,""+t),x.set(e,t),k.set(t,e),t},z=function(e){return k.get(e)},M=function(e,t){t>=V&&(V=t+1),x.set(e,t),k.set(t,e)},G="style["+A+'][data-styled-version="5.3.3"]',L=new RegExp("^"+A+'\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'),F=function(e,t,n){for(var r,o=n.split(","),s=0,i=o.length;s<i;s++)(r=o[s])&&e.registerName(t,r)},Y=function(e,t){for(var n=(t.textContent||"").split("/*!sc*/\n"),r=[],o=0,s=n.length;o<s;o++){var i=n[o].trim();if(i){var a=i.match(L);if(a){var c=0|parseInt(a[1],10),u=a[2];0!==c&&(M(u,c),F(e,u,a[3]),e.getTag().insertRules(c,r)),r.length=0}else r.push(i)}}},q=function(){return"undefined"!=typeof window&&void 0!==window.__webpack_nonce__?window.__webpack_nonce__:null},H=function(e){var t=document.head,n=e||t,r=document.createElement("style"),o=function(e){for(var t=e.childNodes,n=t.length;n>=0;n--){var r=t[n];if(r&&1===r.nodeType&&r.hasAttribute(A))return r}}(n),s=void 0!==o?o.nextSibling:null;r.setAttribute(A,"active"),r.setAttribute("data-styled-version","5.3.3");var i=q();return i&&r.setAttribute("nonce",i),n.insertBefore(r,s),r},$=function(){function e(e){var t=this.element=H(e);t.appendChild(document.createTextNode("")),this.sheet=function(e){if(e.sheet)return e.sheet;for(var t=document.styleSheets,n=0,r=t.length;n<r;n++){var o=t[n];if(o.ownerNode===e)return o}j(17)}(t),this.length=0}var t=e.prototype;return t.insertRule=function(e,t){try{return this.sheet.insertRule(t,e),this.length++,!0}catch(e){return!1}},t.deleteRule=function(e){this.sheet.deleteRule(e),this.length--},t.getRule=function(e){var t=this.sheet.cssRules[e];return void 0!==t&&"string"==typeof t.cssText?t.cssText:""},e}(),W=function(){function e(e){var t=this.element=H(e);this.nodes=t.childNodes,this.length=0}var t=e.prototype;return t.insertRule=function(e,t){if(e<=this.length&&e>=0){var n=document.createTextNode(t),r=this.nodes[e];return this.element.insertBefore(n,r||null),this.length++,!0}return!1},t.deleteRule=function(e){this.element.removeChild(this.nodes[e]),this.length--},t.getRule=function(e){return e<this.length?this.nodes[e].textContent:""},e}(),U=function(){function e(e){this.rules=[],this.length=0}var t=e.prototype;return t.insertRule=function(e,t){return e<=this.length&&(this.rules.splice(e,0,t),this.length++,!0)},t.deleteRule=function(e){this.rules.splice(e,1),this.length--},t.getRule=function(e){return e<this.length?this.rules[e]:""},e}(),J=I,X={isServer:!I,useCSSOMInjection:!P},Z=function(){function e(e,t,n){void 0===e&&(e=E),void 0===t&&(t={}),this.options=v({},X,{},e),this.gs=t,this.names=new Map(n),this.server=!!e.isServer,!this.server&&I&&J&&(J=!1,function(e){for(var t=document.querySelectorAll(G),n=0,r=t.length;n<r;n++){var o=t[n];o&&"active"!==o.getAttribute(A)&&(Y(e,o),o.parentNode&&o.parentNode.removeChild(o))}}(this))}e.registerId=function(e){return B(e)};var t=e.prototype;return t.reconstructWithOptions=function(t,n){return void 0===n&&(n=!0),new e(v({},this.options,{},t),this.gs,n&&this.names||void 0)},t.allocateGSInstance=function(e){return this.gs[e]=(this.gs[e]||0)+1},t.getTag=function(){return this.tag||(this.tag=(n=(t=this.options).isServer,r=t.useCSSOMInjection,o=t.target,e=n?new U(o):r?new $(o):new W(o),new T(e)));var e,t,n,r,o},t.hasNameForId=function(e,t){return this.names.has(e)&&this.names.get(e).has(t)},t.registerName=function(e,t){if(B(e),this.names.has(e))this.names.get(e).add(t);else{var n=new Set;n.add(t),this.names.set(e,n)}},t.insertRules=function(e,t,n){this.registerName(e,t),this.getTag().insertRules(B(e),n)},t.clearNames=function(e){this.names.has(e)&&this.names.get(e).clear()},t.clearRules=function(e){this.getTag().clearGroup(B(e)),this.clearNames(e)},t.clearTag=function(){this.tag=void 0},t.toString=function(){return function(e){for(var t=e.getTag(),n=t.length,r="",o=0;o<n;o++){var s=z(o);if(void 0!==s){var i=e.names.get(s),a=t.getGroup(o);if(i&&a&&i.size){var c=A+".g"+o+'[id="'+s+'"]',u="";void 0!==i&&i.forEach((function(e){e.length>0&&(u+=e+",")})),r+=""+a+c+'{content:"'+u+'"}/*!sc*/\n'}}}return r}(this)},e}(),K=/(a)(d)/gi,Q=function(e){return String.fromCharCode(e+(e>25?39:97))};function ee(e){var t,n="";for(t=Math.abs(e);t>52;t=t/52|0)n=Q(t%52)+n;return(Q(t%52)+n).replace(K,"$1-$2")}var te=function(e,t){for(var n=t.length;n;)e=33*e^t.charCodeAt(--n);return e},ne=function(e){return te(5381,e)};function re(e){for(var t=0;t<e.length;t+=1){var n=e[t];if(b(n)&&!N(n))return!1}return!0}var oe=ne("5.3.3"),se=function(){function e(e,t,n){this.rules=e,this.staticRulesId="",this.isStatic="production"===process.env.NODE_ENV&&(void 0===n||n.isStatic)&&re(e),this.componentId=t,this.baseHash=te(oe,t),this.baseStyle=n,Z.registerId(t)}return e.prototype.generateAndInjectStyles=function(e,t,n){var r=this.componentId,o=[];if(this.baseStyle&&o.push(this.baseStyle.generateAndInjectStyles(e,t,n)),this.isStatic&&!n.hash)if(this.staticRulesId&&t.hasNameForId(r,this.staticRulesId))o.push(this.staticRulesId);else{var s=Ne(this.rules,e,t,n).join(""),i=ee(te(this.baseHash,s)>>>0);if(!t.hasNameForId(r,i)){var a=n(s,"."+i,void 0,r);t.insertRules(r,i,a)}o.push(i),this.staticRulesId=i}else{for(var c=this.rules.length,u=te(this.baseHash,n.hash),l="",d=0;d<c;d++){var h=this.rules[d];if("string"==typeof h)l+=h,"production"!==process.env.NODE_ENV&&(u=te(u,h+d));else if(h){var p=Ne(h,e,t,n),f=Array.isArray(p)?p.join(""):p;u=te(u,f+d),l+=f}}if(l){var m=ee(u>>>0);if(!t.hasNameForId(r,m)){var y=n(l,"."+m,void 0,r);t.insertRules(r,m,y)}o.push(m)}}return o.join(" ")},e}(),ie=/^\s*\/\/.*$/gm,ae=[":","[",".","#"];function ce(e){var t,n,r,o,s=void 0===e?E:e,i=s.options,a=void 0===i?E:i,c=s.plugins,u=void 0===c?w:c,l=new __WEBPACK_IMPORTED_MODULE_3__emotion_stylis__["a" /* default */](a),d=[],h=function(e){function t(t){if(t)try{e(t+"}")}catch(e){}}return function(n,r,o,s,i,a,c,u,l,d){switch(n){case 1:if(0===l&&64===r.charCodeAt(0))return e(r+";"),"";break;case 2:if(0===u)return r+"/*|*/";break;case 3:switch(u){case 102:case 112:return e(o[0]+r),"";default:return r+(0===d?"/*|*/":"")}case-2:r.split("/*|*/}").forEach(t)}}}((function(e){d.push(e)})),f=function(e,r,s){return 0===r&&-1!==ae.indexOf(s[n.length])||s.match(o)?e:"."+t};function m(e,s,i,a){void 0===a&&(a="&");var c=e.replace(ie,""),u=s&&i?i+" "+s+" { "+c+" }":c;return t=a,n=s,r=new RegExp("\\"+n+"\\b","g"),o=new RegExp("(\\"+n+"\\b){2,}"),l(i||!s?"":s,u)}return l.use([].concat(u,[function(e,t,o){2===e&&o.length&&o[0].lastIndexOf(n)>0&&(o[0]=o[0].replace(r,f))},h,function(e){if(-2===e){var t=d;return d=[],t}}])),m.hash=u.length?u.reduce((function(e,t){return t.name||j(15),te(e,t.name)}),5381).toString():"",m}var ue=__WEBPACK_IMPORTED_MODULE_1_react___default.a.createContext(),le=ue.Consumer,de=__WEBPACK_IMPORTED_MODULE_1_react___default.a.createContext(),he=(de.Consumer,new Z),pe=ce();function fe(){return Object(__WEBPACK_IMPORTED_MODULE_1_react__["useContext"])(ue)||he}function me(){return Object(__WEBPACK_IMPORTED_MODULE_1_react__["useContext"])(de)||pe}function ye(e){var t=Object(__WEBPACK_IMPORTED_MODULE_1_react__["useState"])(e.stylisPlugins),n=t[0],s=t[1],c=fe(),u=Object(__WEBPACK_IMPORTED_MODULE_1_react__["useMemo"])((function(){var t=c;return e.sheet?t=e.sheet:e.target&&(t=t.reconstructWithOptions({target:e.target},!1)),e.disableCSSOMInjection&&(t=t.reconstructWithOptions({useCSSOMInjection:!1})),t}),[e.disableCSSOMInjection,e.sheet,e.target]),l=Object(__WEBPACK_IMPORTED_MODULE_1_react__["useMemo"])((function(){return ce({options:{prefix:!e.disableVendorPrefixes},plugins:n})}),[e.disableVendorPrefixes,n]);return Object(__WEBPACK_IMPORTED_MODULE_1_react__["useEffect"])((function(){__WEBPACK_IMPORTED_MODULE_2_shallowequal___default()(n,e.stylisPlugins)||s(e.stylisPlugins)}),[e.stylisPlugins]),__WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(ue.Provider,{value:u},__WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(de.Provider,{value:l},"production"!==process.env.NODE_ENV?__WEBPACK_IMPORTED_MODULE_1_react___default.a.Children.only(e.children):e.children))}var ve=function(){function e(e,t){var n=this;this.inject=function(e,t){void 0===t&&(t=pe);var r=n.name+t.hash;e.hasNameForId(n.id,r)||e.insertRules(n.id,r,t(n.rules,r,"@keyframes"))},this.toString=function(){return j(12,String(n.name))},this.name=e,this.id="sc-keyframes-"+e,this.rules=t}return e.prototype.getName=function(e){return void 0===e&&(e=pe),this.name+e.hash},e}(),ge=/([A-Z])/,Se=/([A-Z])/g,we=/^ms-/,Ee=function(e){return"-"+e.toLowerCase()};function be(e){return ge.test(e)?e.replace(Se,Ee).replace(we,"-ms-"):e}var _e=function(e){return null==e||!1===e||""===e};function Ne(e,n,r,o){if(Array.isArray(e)){for(var s,i=[],a=0,c=e.length;a<c;a+=1)""!==(s=Ne(e[a],n,r,o))&&(Array.isArray(s)?i.push.apply(i,s):i.push(s));return i}if(_e(e))return"";if(N(e))return"."+e.styledComponentId;if(b(e)){if("function"!=typeof(l=e)||l.prototype&&l.prototype.isReactComponent||!n)return e;var u=e(n);return"production"!==process.env.NODE_ENV&&Object(__WEBPACK_IMPORTED_MODULE_0_react_is__["isElement"])(u)&&console.warn(_(e)+" is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."),Ne(u,n,r,o)}var l;return e instanceof ve?r?(e.inject(r,o),e.getName(o)):e:S(e)?function e(t,n){var r,o,s=[];for(var i in t)t.hasOwnProperty(i)&&!_e(t[i])&&(Array.isArray(t[i])&&t[i].isCss||b(t[i])?s.push(be(i)+":",t[i],";"):S(t[i])?s.push.apply(s,e(t[i],i)):s.push(be(i)+": "+(r=i,null==(o=t[i])||"boolean"==typeof o||""===o?"":"number"!=typeof o||0===o||r in __WEBPACK_IMPORTED_MODULE_4__emotion_unitless__["a" /* default */]?String(o).trim():o+"px")+";"));return n?[n+" {"].concat(s,["}"]):s}(e):e.toString()}var Ae=function(e){return Array.isArray(e)&&(e.isCss=!0),e};function Ce(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return b(e)||S(e)?Ae(Ne(g(w,[e].concat(n)))):0===n.length&&1===e.length&&"string"==typeof e[0]?e:Ae(Ne(g(e,n)))}var Ie=/invalid hook call/i,Pe=new Set,Oe=function(e,t){if("production"!==process.env.NODE_ENV){var n="The component "+e+(t?' with the id of "'+t+'"':"")+" has been created dynamically.\nYou may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.",r=console.error;try{var o=!0;console.error=function(e){if(Ie.test(e))o=!1,Pe.delete(n);else{for(var t=arguments.length,s=new Array(t>1?t-1:0),i=1;i<t;i++)s[i-1]=arguments[i];r.apply(void 0,[e].concat(s))}},Object(__WEBPACK_IMPORTED_MODULE_1_react__["useRef"])(),o&&!Pe.has(n)&&(console.warn(n),Pe.add(n))}catch(e){Ie.test(e.message)&&Pe.delete(n)}finally{console.error=r}}},Re=function(e,t,n){return void 0===n&&(n=E),e.theme!==n.theme&&e.theme||t||n.theme},De=/[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,je=/(^-|-$)/g;function Te(e){return e.replace(De,"-").replace(je,"")}var xe=function(e){return ee(ne(e)>>>0)};function ke(e){return"string"==typeof e&&("production"===process.env.NODE_ENV||e.charAt(0)===e.charAt(0).toLowerCase())}var Ve=function(e){return"function"==typeof e||"object"==typeof e&&null!==e&&!Array.isArray(e)},Be=function(e){return"__proto__"!==e&&"constructor"!==e&&"prototype"!==e};function ze(e,t,n){var r=e[n];Ve(t)&&Ve(r)?Me(r,t):e[n]=t}function Me(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];for(var o=0,s=n;o<s.length;o++){var i=s[o];if(Ve(i))for(var a in i)Be(a)&&ze(e,i[a],a)}return e}var Ge=__WEBPACK_IMPORTED_MODULE_1_react___default.a.createContext(),Le=Ge.Consumer;function Fe(e){var t=Object(__WEBPACK_IMPORTED_MODULE_1_react__["useContext"])(Ge),n=Object(__WEBPACK_IMPORTED_MODULE_1_react__["useMemo"])((function(){return function(e,t){if(!e)return j(14);if(b(e)){var n=e(t);return"production"===process.env.NODE_ENV||null!==n&&!Array.isArray(n)&&"object"==typeof n?n:j(7)}return Array.isArray(e)||"object"!=typeof e?j(8):t?v({},t,{},e):e}(e.theme,t)}),[e.theme,t]);return e.children?__WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(Ge.Provider,{value:n},e.children):null}var Ye={};function qe(e,t,n){var o=N(e),i=!ke(e),a=t.attrs,c=void 0===a?w:a,d=t.componentId,h=void 0===d?function(e,t){var n="string"!=typeof e?"sc":Te(e);Ye[n]=(Ye[n]||0)+1;var r=n+"-"+xe("5.3.3"+n+Ye[n]);return t?t+"-"+r:r}(t.displayName,t.parentComponentId):d,p=t.displayName,f=void 0===p?function(e){return ke(e)?"styled."+e:"Styled("+_(e)+")"}(e):p,g=t.displayName&&t.componentId?Te(t.displayName)+"-"+t.componentId:t.componentId||h,S=o&&e.attrs?Array.prototype.concat(e.attrs,c).filter(Boolean):c,A=t.shouldForwardProp;o&&e.shouldForwardProp&&(A=t.shouldForwardProp?function(n,r,o){return e.shouldForwardProp(n,r,o)&&t.shouldForwardProp(n,r,o)}:e.shouldForwardProp);var C,I=new se(n,g,o?e.componentStyle:void 0),P=I.isStatic&&0===c.length,O=function(e,t){return function(e,t,n,r){var o=e.attrs,i=e.componentStyle,a=e.defaultProps,c=e.foldedComponentIds,d=e.shouldForwardProp,h=e.styledComponentId,p=e.target;"production"!==process.env.NODE_ENV&&Object(__WEBPACK_IMPORTED_MODULE_1_react__["useDebugValue"])(h);var f=function(e,t,n){void 0===e&&(e=E);var r=v({},t,{theme:e}),o={};return n.forEach((function(e){var t,n,s,i=e;for(t in b(i)&&(i=i(r)),i)r[t]=o[t]="className"===t?(n=o[t],s=i[t],n&&s?n+" "+s:n||s):i[t]})),[r,o]}(Re(t,Object(__WEBPACK_IMPORTED_MODULE_1_react__["useContext"])(Ge),a)||E,t,o),y=f[0],g=f[1],S=function(e,t,n,r){var o=fe(),s=me(),i=t?e.generateAndInjectStyles(E,o,s):e.generateAndInjectStyles(n,o,s);return"production"!==process.env.NODE_ENV&&Object(__WEBPACK_IMPORTED_MODULE_1_react__["useDebugValue"])(i),"production"!==process.env.NODE_ENV&&!t&&r&&r(i),i}(i,r,y,"production"!==process.env.NODE_ENV?e.warnTooManyClasses:void 0),w=n,_=g.$as||t.$as||g.as||t.as||p,N=ke(_),A=g!==t?v({},t,{},g):t,C={};for(var I in A)"$"!==I[0]&&"as"!==I&&("forwardedAs"===I?C.as=A[I]:(d?d(I,__WEBPACK_IMPORTED_MODULE_5__emotion_is_prop_valid__["a" /* default */],_):!N||Object(__WEBPACK_IMPORTED_MODULE_5__emotion_is_prop_valid__["a" /* default */])(I))&&(C[I]=A[I]));return t.style&&g.style!==t.style&&(C.style=v({},t.style,{},g.style)),C.className=Array.prototype.concat(c,h,S!==h?S:null,t.className,g.className).filter(Boolean).join(" "),C.ref=w,Object(__WEBPACK_IMPORTED_MODULE_1_react__["createElement"])(_,C)}(C,e,t,P)};return O.displayName=f,(C=__WEBPACK_IMPORTED_MODULE_1_react___default.a.forwardRef(O)).attrs=S,C.componentStyle=I,C.displayName=f,C.shouldForwardProp=A,C.foldedComponentIds=o?Array.prototype.concat(e.foldedComponentIds,e.styledComponentId):w,C.styledComponentId=g,C.target=o?e.target:e,C.withComponent=function(e){var r=t.componentId,o=function(e,t){if(null==e)return{};var n,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(t,["componentId"]),s=r&&r+"-"+(ke(e)?e:Te(_(e)));return qe(e,v({},o,{attrs:S,componentId:s}),n)},Object.defineProperty(C,"defaultProps",{get:function(){return this._foldedDefaultProps},set:function(t){this._foldedDefaultProps=o?Me({},e.defaultProps,t):t}}),"production"!==process.env.NODE_ENV&&(Oe(f,g),C.warnTooManyClasses=function(e,t){var n={},r=!1;return function(o){if(!r&&(n[o]=!0,Object.keys(n).length>=200)){var s=t?' with the id of "'+t+'"':"";console.warn("Over 200 classes were generated for component "+e+s+".\nConsider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"),r=!0,n={}}}}(f,g)),C.toString=function(){return"."+C.styledComponentId},i&&__WEBPACK_IMPORTED_MODULE_6_hoist_non_react_statics___default()(C,e,{attrs:!0,componentStyle:!0,displayName:!0,foldedComponentIds:!0,shouldForwardProp:!0,styledComponentId:!0,target:!0,withComponent:!0}),C}var He=function(e){return function e(t,r,o){if(void 0===o&&(o=E),!Object(__WEBPACK_IMPORTED_MODULE_0_react_is__["isValidElementType"])(r))return j(1,String(r));var s=function(){return t(r,o,Ce.apply(void 0,arguments))};return s.withConfig=function(n){return e(t,r,v({},o,{},n))},s.attrs=function(n){return e(t,r,v({},o,{attrs:Array.prototype.concat(o.attrs,n).filter(Boolean)}))},s}(qe,e)};["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","marquee","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","marker","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","textPath","tspan"].forEach((function(e){He[e]=He(e)}));var $e=function(){function e(e,t){this.rules=e,this.componentId=t,this.isStatic=re(e),Z.registerId(this.componentId+1)}var t=e.prototype;return t.createStyles=function(e,t,n,r){var o=r(Ne(this.rules,t,n,r).join(""),""),s=this.componentId+e;n.insertRules(s,s,o)},t.removeStyles=function(e,t){t.clearRules(this.componentId+e)},t.renderStyles=function(e,t,n,r){e>2&&Z.registerId(this.componentId+e),this.removeStyles(e,n),this.createStyles(e,t,n,r)},e}();function We(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),o=1;o<t;o++)n[o-1]=arguments[o];var i=Ce.apply(void 0,[e].concat(n)),a="sc-global-"+xe(JSON.stringify(i)),u=new $e(i,a);function l(e){var t=fe(),n=me(),o=Object(__WEBPACK_IMPORTED_MODULE_1_react__["useContext"])(Ge),l=Object(__WEBPACK_IMPORTED_MODULE_1_react__["useRef"])(t.allocateGSInstance(a)).current;return"production"!==process.env.NODE_ENV&&__WEBPACK_IMPORTED_MODULE_1_react___default.a.Children.count(e.children)&&console.warn("The global style component "+a+" was given child JSX. createGlobalStyle does not render children."),"production"!==process.env.NODE_ENV&&i.some((function(e){return"string"==typeof e&&-1!==e.indexOf("@import")}))&&console.warn("Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app."),t.server&&h(l,e,t,o,n),Object(__WEBPACK_IMPORTED_MODULE_1_react__["useLayoutEffect"])((function(){if(!t.server)return h(l,e,t,o,n),function(){return u.removeStyles(l,t)}}),[l,e,t,o,n]),null}function h(e,t,n,r,o){if(u.isStatic)u.renderStyles(e,O,n,o);else{var s=v({},t,{theme:Re(t,r,l.defaultProps)});u.renderStyles(e,s,n,o)}}return"production"!==process.env.NODE_ENV&&Oe(a),__WEBPACK_IMPORTED_MODULE_1_react___default.a.memo(l)}function Ue(e){"production"!==process.env.NODE_ENV&&"undefined"!=typeof navigator&&"ReactNative"===navigator.product&&console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];var o=Ce.apply(void 0,[e].concat(n)).join(""),s=xe(o);return new ve(s,o)}var Je=function(){function e(){var e=this;this._emitSheetCSS=function(){var t=e.instance.toString();if(!t)return"";var n=q();return"<style "+[n&&'nonce="'+n+'"',A+'="true"','data-styled-version="5.3.3"'].filter(Boolean).join(" ")+">"+t+"</style>"},this.getStyleTags=function(){return e.sealed?j(2):e._emitSheetCSS()},this.getStyleElement=function(){var t;if(e.sealed)return j(2);var n=((t={})[A]="",t["data-styled-version"]="5.3.3",t.dangerouslySetInnerHTML={__html:e.instance.toString()},t),o=q();return o&&(n.nonce=o),[__WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement("style",v({},n,{key:"sc-0-0"}))]},this.seal=function(){e.sealed=!0},this.instance=new Z({isServer:!0}),this.sealed=!1}var t=e.prototype;return t.collectStyles=function(e){return this.sealed?j(2):__WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(ye,{sheet:this.instance},e)},t.interleaveWithNodeStream=function(e){return j(3)},e}(),Xe=function(e){var t=__WEBPACK_IMPORTED_MODULE_1_react___default.a.forwardRef((function(t,n){var o=Object(__WEBPACK_IMPORTED_MODULE_1_react__["useContext"])(Ge),i=e.defaultProps,a=Re(t,o,i);return"production"!==process.env.NODE_ENV&&void 0===a&&console.warn('[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class "'+_(e)+'"'),__WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(e,v({},t,{theme:a,ref:n}))}));return __WEBPACK_IMPORTED_MODULE_6_hoist_non_react_statics___default()(t,e),t.displayName="WithTheme("+_(e)+")",t},Ze=function(){return Object(__WEBPACK_IMPORTED_MODULE_1_react__["useContext"])(Ge)},Ke={StyleSheet:Z,masterSheet:he};"production"!==process.env.NODE_ENV&&"undefined"!=typeof navigator&&"ReactNative"===navigator.product&&console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native"),"production"!==process.env.NODE_ENV&&"test"!==process.env.NODE_ENV&&"undefined"!=typeof window&&(window["__styled-components-init__"]=window["__styled-components-init__"]||0,1===window["__styled-components-init__"]&&console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."),window["__styled-components-init__"]+=1);/* harmony default export */ __webpack_exports__["b"] = (He);
//# sourceMappingURL=styled-components.browser.esm.js.map

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)))

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;
exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};
exports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};
exports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 202 */
/***/ (function(module, exports) {

//

module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

  // Test for A's keys different from B.
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || (ret === void 0 && valueA !== valueB)) {
      return false;
    }
  }

  return true;
};


/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function stylis_min (W) {
  function M(d, c, e, h, a) {
    for (var m = 0, b = 0, v = 0, n = 0, q, g, x = 0, K = 0, k, u = k = q = 0, l = 0, r = 0, I = 0, t = 0, B = e.length, J = B - 1, y, f = '', p = '', F = '', G = '', C; l < B;) {
      g = e.charCodeAt(l);
      l === J && 0 !== b + n + v + m && (0 !== b && (g = 47 === b ? 10 : 47), n = v = m = 0, B++, J++);

      if (0 === b + n + v + m) {
        if (l === J && (0 < r && (f = f.replace(N, '')), 0 < f.trim().length)) {
          switch (g) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;

            default:
              f += e.charAt(l);
          }

          g = 59;
        }

        switch (g) {
          case 123:
            f = f.trim();
            q = f.charCodeAt(0);
            k = 1;

            for (t = ++l; l < B;) {
              switch (g = e.charCodeAt(l)) {
                case 123:
                  k++;
                  break;

                case 125:
                  k--;
                  break;

                case 47:
                  switch (g = e.charCodeAt(l + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u = l + 1; u < J; ++u) {
                          switch (e.charCodeAt(u)) {
                            case 47:
                              if (42 === g && 42 === e.charCodeAt(u - 1) && l + 2 !== u) {
                                l = u + 1;
                                break a;
                              }

                              break;

                            case 10:
                              if (47 === g) {
                                l = u + 1;
                                break a;
                              }

                          }
                        }

                        l = u;
                      }

                  }

                  break;

                case 91:
                  g++;

                case 40:
                  g++;

                case 34:
                case 39:
                  for (; l++ < J && e.charCodeAt(l) !== g;) {
                  }

              }

              if (0 === k) break;
              l++;
            }

            k = e.substring(t, l);
            0 === q && (q = (f = f.replace(ca, '').trim()).charCodeAt(0));

            switch (q) {
              case 64:
                0 < r && (f = f.replace(N, ''));
                g = f.charCodeAt(1);

                switch (g) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r = c;
                    break;

                  default:
                    r = O;
                }

                k = M(c, r, k, g, a + 1);
                t = k.length;
                0 < A && (r = X(O, f, I), C = H(3, k, r, c, D, z, t, g, a, h), f = r.join(''), void 0 !== C && 0 === (t = (k = C.trim()).length) && (g = 0, k = ''));
                if (0 < t) switch (g) {
                  case 115:
                    f = f.replace(da, ea);

                  case 100:
                  case 109:
                  case 45:
                    k = f + '{' + k + '}';
                    break;

                  case 107:
                    f = f.replace(fa, '$1 $2');
                    k = f + '{' + k + '}';
                    k = 1 === w || 2 === w && L('@' + k, 3) ? '@-webkit-' + k + '@' + k : '@' + k;
                    break;

                  default:
                    k = f + k, 112 === h && (k = (p += k, ''));
                } else k = '';
                break;

              default:
                k = M(c, X(c, f, I), k, h, a + 1);
            }

            F += k;
            k = I = r = u = q = 0;
            f = '';
            g = e.charCodeAt(++l);
            break;

          case 125:
          case 59:
            f = (0 < r ? f.replace(N, '') : f).trim();
            if (1 < (t = f.length)) switch (0 === u && (q = f.charCodeAt(0), 45 === q || 96 < q && 123 > q) && (t = (f = f.replace(' ', ':')).length), 0 < A && void 0 !== (C = H(1, f, c, d, D, z, p.length, h, a, h)) && 0 === (t = (f = C.trim()).length) && (f = '\x00\x00'), q = f.charCodeAt(0), g = f.charCodeAt(1), q) {
              case 0:
                break;

              case 64:
                if (105 === g || 99 === g) {
                  G += f + e.charAt(l);
                  break;
                }

              default:
                58 !== f.charCodeAt(t - 1) && (p += P(f, q, g, f.charCodeAt(2)));
            }
            I = r = u = q = 0;
            f = '';
            g = e.charCodeAt(++l);
        }
      }

      switch (g) {
        case 13:
        case 10:
          47 === b ? b = 0 : 0 === 1 + q && 107 !== h && 0 < f.length && (r = 1, f += '\x00');
          0 < A * Y && H(0, f, c, d, D, z, p.length, h, a, h);
          z = 1;
          D++;
          break;

        case 59:
        case 125:
          if (0 === b + n + v + m) {
            z++;
            break;
          }

        default:
          z++;
          y = e.charAt(l);

          switch (g) {
            case 9:
            case 32:
              if (0 === n + m + b) switch (x) {
                case 44:
                case 58:
                case 9:
                case 32:
                  y = '';
                  break;

                default:
                  32 !== g && (y = ' ');
              }
              break;

            case 0:
              y = '\\0';
              break;

            case 12:
              y = '\\f';
              break;

            case 11:
              y = '\\v';
              break;

            case 38:
              0 === n + b + m && (r = I = 1, y = '\f' + y);
              break;

            case 108:
              if (0 === n + b + m + E && 0 < u) switch (l - u) {
                case 2:
                  112 === x && 58 === e.charCodeAt(l - 3) && (E = x);

                case 8:
                  111 === K && (E = K);
              }
              break;

            case 58:
              0 === n + b + m && (u = l);
              break;

            case 44:
              0 === b + v + n + m && (r = 1, y += '\r');
              break;

            case 34:
            case 39:
              0 === b && (n = n === g ? 0 : 0 === n ? g : n);
              break;

            case 91:
              0 === n + b + v && m++;
              break;

            case 93:
              0 === n + b + v && m--;
              break;

            case 41:
              0 === n + b + m && v--;
              break;

            case 40:
              if (0 === n + b + m) {
                if (0 === q) switch (2 * x + 3 * K) {
                  case 533:
                    break;

                  default:
                    q = 1;
                }
                v++;
              }

              break;

            case 64:
              0 === b + v + n + m + u + k && (k = 1);
              break;

            case 42:
            case 47:
              if (!(0 < n + m + v)) switch (b) {
                case 0:
                  switch (2 * g + 3 * e.charCodeAt(l + 1)) {
                    case 235:
                      b = 47;
                      break;

                    case 220:
                      t = l, b = 42;
                  }

                  break;

                case 42:
                  47 === g && 42 === x && t + 2 !== l && (33 === e.charCodeAt(t + 2) && (p += e.substring(t, l + 1)), y = '', b = 0);
              }
          }

          0 === b && (f += y);
      }

      K = x;
      x = g;
      l++;
    }

    t = p.length;

    if (0 < t) {
      r = c;
      if (0 < A && (C = H(2, p, r, d, D, z, t, h, a, h), void 0 !== C && 0 === (p = C).length)) return G + p + F;
      p = r.join(',') + '{' + p + '}';

      if (0 !== w * E) {
        2 !== w || L(p, 2) || (E = 0);

        switch (E) {
          case 111:
            p = p.replace(ha, ':-moz-$1') + p;
            break;

          case 112:
            p = p.replace(Q, '::-webkit-input-$1') + p.replace(Q, '::-moz-$1') + p.replace(Q, ':-ms-input-$1') + p;
        }

        E = 0;
      }
    }

    return G + p + F;
  }

  function X(d, c, e) {
    var h = c.trim().split(ia);
    c = h;
    var a = h.length,
        m = d.length;

    switch (m) {
      case 0:
      case 1:
        var b = 0;

        for (d = 0 === m ? '' : d[0] + ' '; b < a; ++b) {
          c[b] = Z(d, c[b], e).trim();
        }

        break;

      default:
        var v = b = 0;

        for (c = []; b < a; ++b) {
          for (var n = 0; n < m; ++n) {
            c[v++] = Z(d[n] + ' ', h[b], e).trim();
          }
        }

    }

    return c;
  }

  function Z(d, c, e) {
    var h = c.charCodeAt(0);
    33 > h && (h = (c = c.trim()).charCodeAt(0));

    switch (h) {
      case 38:
        return c.replace(F, '$1' + d.trim());

      case 58:
        return d.trim() + c.replace(F, '$1' + d.trim());

      default:
        if (0 < 1 * e && 0 < c.indexOf('\f')) return c.replace(F, (58 === d.charCodeAt(0) ? '' : '$1') + d.trim());
    }

    return d + c;
  }

  function P(d, c, e, h) {
    var a = d + ';',
        m = 2 * c + 3 * e + 4 * h;

    if (944 === m) {
      d = a.indexOf(':', 9) + 1;
      var b = a.substring(d, a.length - 1).trim();
      b = a.substring(0, d).trim() + b + ';';
      return 1 === w || 2 === w && L(b, 1) ? '-webkit-' + b + b : b;
    }

    if (0 === w || 2 === w && !L(a, 1)) return a;

    switch (m) {
      case 1015:
        return 97 === a.charCodeAt(10) ? '-webkit-' + a + a : a;

      case 951:
        return 116 === a.charCodeAt(3) ? '-webkit-' + a + a : a;

      case 963:
        return 110 === a.charCodeAt(5) ? '-webkit-' + a + a : a;

      case 1009:
        if (100 !== a.charCodeAt(4)) break;

      case 969:
      case 942:
        return '-webkit-' + a + a;

      case 978:
        return '-webkit-' + a + '-moz-' + a + a;

      case 1019:
      case 983:
        return '-webkit-' + a + '-moz-' + a + '-ms-' + a + a;

      case 883:
        if (45 === a.charCodeAt(8)) return '-webkit-' + a + a;
        if (0 < a.indexOf('image-set(', 11)) return a.replace(ja, '$1-webkit-$2') + a;
        break;

      case 932:
        if (45 === a.charCodeAt(4)) switch (a.charCodeAt(5)) {
          case 103:
            return '-webkit-box-' + a.replace('-grow', '') + '-webkit-' + a + '-ms-' + a.replace('grow', 'positive') + a;

          case 115:
            return '-webkit-' + a + '-ms-' + a.replace('shrink', 'negative') + a;

          case 98:
            return '-webkit-' + a + '-ms-' + a.replace('basis', 'preferred-size') + a;
        }
        return '-webkit-' + a + '-ms-' + a + a;

      case 964:
        return '-webkit-' + a + '-ms-flex-' + a + a;

      case 1023:
        if (99 !== a.charCodeAt(8)) break;
        b = a.substring(a.indexOf(':', 15)).replace('flex-', '').replace('space-between', 'justify');
        return '-webkit-box-pack' + b + '-webkit-' + a + '-ms-flex-pack' + b + a;

      case 1005:
        return ka.test(a) ? a.replace(aa, ':-webkit-') + a.replace(aa, ':-moz-') + a : a;

      case 1e3:
        b = a.substring(13).trim();
        c = b.indexOf('-') + 1;

        switch (b.charCodeAt(0) + b.charCodeAt(c)) {
          case 226:
            b = a.replace(G, 'tb');
            break;

          case 232:
            b = a.replace(G, 'tb-rl');
            break;

          case 220:
            b = a.replace(G, 'lr');
            break;

          default:
            return a;
        }

        return '-webkit-' + a + '-ms-' + b + a;

      case 1017:
        if (-1 === a.indexOf('sticky', 9)) break;

      case 975:
        c = (a = d).length - 10;
        b = (33 === a.charCodeAt(c) ? a.substring(0, c) : a).substring(d.indexOf(':', 7) + 1).trim();

        switch (m = b.charCodeAt(0) + (b.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b.charCodeAt(8)) break;

          case 115:
            a = a.replace(b, '-webkit-' + b) + ';' + a;
            break;

          case 207:
          case 102:
            a = a.replace(b, '-webkit-' + (102 < m ? 'inline-' : '') + 'box') + ';' + a.replace(b, '-webkit-' + b) + ';' + a.replace(b, '-ms-' + b + 'box') + ';' + a;
        }

        return a + ';';

      case 938:
        if (45 === a.charCodeAt(5)) switch (a.charCodeAt(6)) {
          case 105:
            return b = a.replace('-items', ''), '-webkit-' + a + '-webkit-box-' + b + '-ms-flex-' + b + a;

          case 115:
            return '-webkit-' + a + '-ms-flex-item-' + a.replace(ba, '') + a;

          default:
            return '-webkit-' + a + '-ms-flex-line-pack' + a.replace('align-content', '').replace(ba, '') + a;
        }
        break;

      case 973:
      case 989:
        if (45 !== a.charCodeAt(3) || 122 === a.charCodeAt(4)) break;

      case 931:
      case 953:
        if (!0 === la.test(d)) return 115 === (b = d.substring(d.indexOf(':') + 1)).charCodeAt(0) ? P(d.replace('stretch', 'fill-available'), c, e, h).replace(':fill-available', ':stretch') : a.replace(b, '-webkit-' + b) + a.replace(b, '-moz-' + b.replace('fill-', '')) + a;
        break;

      case 962:
        if (a = '-webkit-' + a + (102 === a.charCodeAt(5) ? '-ms-' + a : '') + a, 211 === e + h && 105 === a.charCodeAt(13) && 0 < a.indexOf('transform', 10)) return a.substring(0, a.indexOf(';', 27) + 1).replace(ma, '$1-webkit-$2') + a;
    }

    return a;
  }

  function L(d, c) {
    var e = d.indexOf(1 === c ? ':' : '{'),
        h = d.substring(0, 3 !== c ? e : 10);
    e = d.substring(e + 1, d.length - 1);
    return R(2 !== c ? h : h.replace(na, '$1'), e, c);
  }

  function ea(d, c) {
    var e = P(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));
    return e !== c + ';' ? e.replace(oa, ' or ($1)').substring(4) : '(' + c + ')';
  }

  function H(d, c, e, h, a, m, b, v, n, q) {
    for (var g = 0, x = c, w; g < A; ++g) {
      switch (w = S[g].call(B, d, x, e, h, a, m, b, v, n, q)) {
        case void 0:
        case !1:
        case !0:
        case null:
          break;

        default:
          x = w;
      }
    }

    if (x !== c) return x;
  }

  function T(d) {
    switch (d) {
      case void 0:
      case null:
        A = S.length = 0;
        break;

      default:
        if ('function' === typeof d) S[A++] = d;else if ('object' === typeof d) for (var c = 0, e = d.length; c < e; ++c) {
          T(d[c]);
        } else Y = !!d | 0;
    }

    return T;
  }

  function U(d) {
    d = d.prefix;
    void 0 !== d && (R = null, d ? 'function' !== typeof d ? w = 1 : (w = 2, R = d) : w = 0);
    return U;
  }

  function B(d, c) {
    var e = d;
    33 > e.charCodeAt(0) && (e = e.trim());
    V = e;
    e = [V];

    if (0 < A) {
      var h = H(-1, c, e, e, D, z, 0, 0, 0, 0);
      void 0 !== h && 'string' === typeof h && (c = h);
    }

    var a = M(O, e, c, 0, 0);
    0 < A && (h = H(-2, a, e, e, D, z, a.length, 0, 0, 0), void 0 !== h && (a = h));
    V = '';
    E = 0;
    z = D = 1;
    return a;
  }

  var ca = /^\0+/g,
      N = /[\0\r\f]/g,
      aa = /: */g,
      ka = /zoo|gra/,
      ma = /([,: ])(transform)/g,
      ia = /,\r+?/g,
      F = /([\t\r\n ])*\f?&/g,
      fa = /@(k\w+)\s*(\S*)\s*/,
      Q = /::(place)/g,
      ha = /:(read-only)/g,
      G = /[svh]\w+-[tblr]{2}/,
      da = /\(\s*(.*)\s*\)/g,
      oa = /([\s\S]*?);/g,
      ba = /-self|flex-/g,
      na = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
      la = /stretch|:\s*\w+\-(?:conte|avail)/,
      ja = /([^-])(image-set\()/,
      z = 1,
      D = 1,
      E = 0,
      w = 1,
      O = [],
      S = [],
      A = 0,
      R = null,
      Y = 0,
      V = '';
  B.use = T;
  B.set = U;
  void 0 !== W && U(W);
  return B;
}

/* harmony default export */ __webpack_exports__["a"] = (stylis_min);


/***/ }),
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

/* harmony default export */ __webpack_exports__["a"] = (unitlessKeys);


/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__emotion_memoize__ = __webpack_require__(206);


var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var index = Object(__WEBPACK_IMPORTED_MODULE_0__emotion_memoize__["a" /* default */])(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */
  && prop.charCodeAt(1) === 110
  /* n */
  && prop.charCodeAt(2) < 91;
}
/* Z+1 */
);

/* harmony default export */ __webpack_exports__["a"] = (index);


/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function memoize(fn) {
  var cache = {};
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

/* harmony default export */ __webpack_exports__["a"] = (memoize);


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var reactIs = __webpack_require__(111);

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;


/***/ }),
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _toggle = __webpack_require__(25);

var _toggle2 = _interopRequireDefault(_toggle);

var _radioTabs = __webpack_require__(7);

var _radioTabs2 = _interopRequireDefault(_radioTabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _input = __webpack_require__(3);

var _input2 = _interopRequireDefault(_input);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SecurityBehaviour = function (_Component) {
	_inherits(SecurityBehaviour, _Component);

	function SecurityBehaviour() {
		_classCallCheck(this, SecurityBehaviour);

		return _possibleConstructorReturn(this, (SecurityBehaviour.__proto__ || Object.getPrototypeOf(SecurityBehaviour)).apply(this, arguments));
	}

	_createClass(SecurityBehaviour, [{
		key: 'render',
		value: function render() {
			var formType = forminatorData.currentForm.settings['form-type'] || 'default';
			var specialFormTypes = ['login', 'registration', 'leads'];
			var isDisableForm = specialFormTypes.includes(formType);

			if (_.isUndefined(this.props.settings['akismet-protection'])) {
				this.props.settings['akismet-protection'] = 1;
			}
			if (!forminatorData.akismetEnabled) {
				this.props.settings['akismet-protection'] = 0;
			}

			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Security')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)('Added layers of security to prevent spam submissions.')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					'form' === this.props.moduleSlug && _react2.default.createElement(_toggle2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Enable Honeypot protection'),
						property: 'honeypot',
						description: (0, _utils.translate)('Enabling this feature tricks spam bots by giving them a hidden ' + 'challenge only bots will see. If the bot tries the challenge we ' + "know it's not a human and prevent the form being submitted.")
					})),
					_react2.default.createElement(
						_toggle2.default,
						_extends({}, this.props, {
							label: (0, _utils.translate)('Enable Akismet spam protection'),
							property: 'akismet-protection',
							disabled: !forminatorData.akismetEnabled,
							description: (0, _utils.translate)('If you have installed the {{link}}Akismet anti-spam plugin{{/link}}, ' + 'you can enable this option to tell Forminator how to handle submissions ' + 'that Akismet flags as spam.', {
								components: {
									link: _react2.default.createElement('a', { target: '_blank', href: 'https://wordpress.org/plugins/akismet/' })
								}
							})
						}),
						_react2.default.createElement(
							_radioTabs2.default,
							_extends({}, this.props, {
								property: 'akismet-protection-behavior',
								'default': 'fail',
								label: (0, _utils.translate)('How should Forminator handle spam submissions?')
							}),
							_react2.default.createElement(
								_container2.default,
								{
									value: 'fail',
									boxClass: 'sui-tab-boxed',
									label: (0, _utils.translate)('Fail Submission')
								},
								_react2.default.createElement(_input2.default, _extends({}, this.props, {
									label: (0, _utils.translate)('Custom error message'),
									placeholder: (0, _utils.translate)('Something went wrong.'),
									property: 'spam-fail-message',
									description: (0, _utils.translate)('Enter a custom error message to let your visitors know why the submission failed.')
								}))
							),
							_react2.default.createElement(
								_container2.default,
								{
									value: 'mark_spam',
									label: (0, _utils.translate)('Mark as Spam')
								},
								_react2.default.createElement(
									'div',
									{
										role: 'alert',
										className: 'sui-notice sui-active',
										style: { display: 'block' },
										'aria-live': 'assertive'
									},
									_react2.default.createElement(
										'div',
										{ className: 'sui-notice-content' },
										_react2.default.createElement(
											'div',
											{ className: 'sui-notice-message' },
											_react2.default.createElement('span', { className: 'sui-notice-icon sui-icon-info', 'aria-hidden': 'true' }),
											_react2.default.createElement(
												'p',
												null,
												(0, _utils.translate)('Entries marked as spam will be captured in the ' + 'database, but not shown in Submissions. ' + 'Additionally, Payments, Notification emails, ' + 'and other automatic processes will be blocked.')
											)
										)
									)
								)
							)
						)
					),
					'form' === this.props.moduleSlug && !isDisableForm && _react2.default.createElement(
						_toggle2.default,
						_extends({}, this.props, {
							label: (0, _utils.translate)('Enable logged in submission only'),
							property: 'logged-users',
							description: (0, _utils.translate)('Lock down your form submissions to registered users only.')
						}),
						_react2.default.createElement(
							'div',
							null,
							_react2.default.createElement(_input2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Submissions limit per logged in user'),
								description: (0, _utils.translate)('Enter the number of times a logged in user can submit this form. Leave blank or enter 0 for no limit.'),
								type: 'number',
								placeholder: '0',
								property: 'limit-per-user'
							}))
						),
						_react2.default.createElement(
							'div',
							{ style: { marginTop: '20px' } },
							_react2.default.createElement(_input2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Message when user has already reached submissions limit'),
								placeholder: (0, _utils.translate)('Youve already reached submissions limit.'),
								property: 'limit-per-user-error'
							}))
						)
					)
				)
			);
		}
	}]);

	return SecurityBehaviour;
}(_react.Component);

exports.default = SecurityBehaviour;

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var updateAnswers = exports.updateAnswers = function updateAnswers(answers) {
	return function (dispatch) {
		// Update global variable with Changes
		window.forminatorChanges.settings = true;

		dispatch({
			type: 'UPDATE_ANSWERS',
			answers: answers
		});
	};
};

var updateAnswer = exports.updateAnswer = function updateAnswer(answer) {
	return function (dispatch) {
		// Update global variable with Changes
		window.forminatorChanges.settings = true;

		dispatch({
			type: 'UPDATE_ANSWER',
			answer: answer
		});
	};
};

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SuiTags = function (_Component) {
	_inherits(SuiTags, _Component);

	function SuiTags(props) {
		_classCallCheck(this, SuiTags);

		var _this = _possibleConstructorReturn(this, (SuiTags.__proto__ || Object.getPrototypeOf(SuiTags)).call(this, props));

		_this.handleChange = _this.handleChange.bind(_this);
		return _this;
	}

	_createClass(SuiTags, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var self = this;
			var value = _.isUndefined(this.props.settings[this.props.property]) ? [] : this.props.settings[this.props.property];

			this.$el = jQuery(this.el);
			var options = Object.assign({ allowClear: true, dropdownCssClass: 'sui-select-dropdown' }, this.props.options);

			if (typeof this.$el.SUIselect2 === 'function') {
				this.$el.SUIselect2(options);
			} else if (typeof this.$el.FUIselect2 === 'function') {
				this.$el.FUIselect2(options);
			} else {
				console.log('select2 not intiated');
			}

			this.$el.on('change.select2', this.handleChange);

			if (!_.isUndefined(this.props.settings.permission_type) && ('specific' === this.props.settings.permission_type || !_.isUndefined(this.props.settings.user_info))) {
				var userInfos = this.props.settings.user_info;

				// initial values append
				_.each(value, function (option) {
					if (!_.isUndefined(userInfos[option])) {
						self.$el.append(jQuery('<option value="' + option + '">' + userInfos[option].email + '</option>'));
					}
				});
			} else {

				// initial values append
				_.each(value, function (option) {
					self.$el.append(jQuery('<option value="' + option + '">' + option + '</option>'));
				});
			}

			// initial values on mount
			this.$el.val(value).trigger('change.select2');
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps, prevState) {
			if (!_.isUndefined(this.props.settings.user_role) && prevProps.settings.user_role !== this.props.settings.user_role) {
				this.$el.val([]).trigger('change.select2');
			}
		}
	}, {
		key: 'handleChange',
		value: function handleChange(e) {
			var value = jQuery(e.target).val();

			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.$el.off('change', this.handleChange);
			this.$el.unbind().removeData();
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) ? [] : this.props.settings[this.props.property];

			var fieldLabel = '';

			if (this.props.label) {
				fieldLabel = _react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-field-' + this.props.property, className: 'sui-label' },
					this.props.label,
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						this.props.note
					)
				);
			}

			return _react2.default.createElement(
				'div',
				{ className: 'sui-form-field', style: this.props.style },
				fieldLabel,
				_react2.default.createElement(
					'select',
					{
						ref: function ref(el) {
							return _this2.el = el;
						},
						className: 'sui-select',
						defaultValue: value,
						multiple: 'multiple'
					},
					this.props.children
				)
			);
		}
	}]);

	return SuiTags;
}(_react.Component);

exports.default = SuiTags;

/***/ }),
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */,
/* 389 */,
/* 390 */,
/* 391 */,
/* 392 */,
/* 393 */,
/* 394 */,
/* 395 */,
/* 396 */,
/* 397 */,
/* 398 */,
/* 399 */,
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.updateTitle = updateTitle;
var UPDATE_TITLE = exports.UPDATE_TITLE = 'UPDATE_TITLE';

function updateTitle(title) {
	// Update global variable with Changes
	window.forminatorChanges.settings = true;

	return { type: UPDATE_TITLE, title: title };
}

/***/ }),
/* 401 */,
/* 402 */,
/* 403 */,
/* 404 */,
/* 405 */,
/* 406 */,
/* 407 */,
/* 408 */,
/* 409 */,
/* 410 */,
/* 411 */,
/* 412 */,
/* 413 */,
/* 414 */,
/* 415 */,
/* 416 */,
/* 417 */,
/* 418 */,
/* 419 */,
/* 420 */,
/* 421 */,
/* 422 */,
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */,
/* 428 */,
/* 429 */,
/* 430 */,
/* 431 */,
/* 432 */,
/* 433 */,
/* 434 */,
/* 435 */,
/* 436 */,
/* 437 */,
/* 438 */,
/* 439 */,
/* 440 */,
/* 441 */,
/* 442 */,
/* 443 */,
/* 444 */,
/* 445 */,
/* 446 */,
/* 447 */,
/* 448 */,
/* 449 */,
/* 450 */,
/* 451 */,
/* 452 */,
/* 453 */,
/* 454 */,
/* 455 */,
/* 456 */,
/* 457 */,
/* 458 */,
/* 459 */,
/* 460 */,
/* 461 */,
/* 462 */,
/* 463 */,
/* 464 */,
/* 465 */,
/* 466 */,
/* 467 */,
/* 468 */,
/* 469 */,
/* 470 */,
/* 471 */,
/* 472 */,
/* 473 */,
/* 474 */,
/* 475 */,
/* 476 */,
/* 477 */,
/* 478 */,
/* 479 */,
/* 480 */,
/* 481 */,
/* 482 */,
/* 483 */,
/* 484 */,
/* 485 */,
/* 486 */,
/* 487 */,
/* 488 */,
/* 489 */,
/* 490 */,
/* 491 */,
/* 492 */,
/* 493 */,
/* 494 */,
/* 495 */,
/* 496 */,
/* 497 */,
/* 498 */,
/* 499 */,
/* 500 */,
/* 501 */,
/* 502 */,
/* 503 */,
/* 504 */,
/* 505 */,
/* 506 */,
/* 507 */,
/* 508 */,
/* 509 */,
/* 510 */,
/* 511 */,
/* 512 */,
/* 513 */,
/* 514 */,
/* 515 */,
/* 516 */,
/* 517 */,
/* 518 */,
/* 519 */,
/* 520 */,
/* 521 */,
/* 522 */,
/* 523 */,
/* 524 */,
/* 525 */,
/* 526 */,
/* 527 */,
/* 528 */,
/* 529 */,
/* 530 */,
/* 531 */,
/* 532 */,
/* 533 */,
/* 534 */,
/* 535 */,
/* 536 */,
/* 537 */,
/* 538 */,
/* 539 */,
/* 540 */,
/* 541 */,
/* 542 */,
/* 543 */,
/* 544 */,
/* 545 */,
/* 546 */,
/* 547 */,
/* 548 */,
/* 549 */,
/* 550 */,
/* 551 */,
/* 552 */,
/* 553 */,
/* 554 */,
/* 555 */,
/* 556 */,
/* 557 */,
/* 558 */,
/* 559 */,
/* 560 */,
/* 561 */,
/* 562 */,
/* 563 */,
/* 564 */,
/* 565 */,
/* 566 */,
/* 567 */,
/* 568 */,
/* 569 */,
/* 570 */,
/* 571 */,
/* 572 */,
/* 573 */,
/* 574 */,
/* 575 */,
/* 576 */,
/* 577 */,
/* 578 */,
/* 579 */,
/* 580 */,
/* 581 */,
/* 582 */,
/* 583 */,
/* 584 */,
/* 585 */,
/* 586 */,
/* 587 */,
/* 588 */,
/* 589 */,
/* 590 */,
/* 591 */,
/* 592 */,
/* 593 */,
/* 594 */,
/* 595 */,
/* 596 */,
/* 597 */,
/* 598 */,
/* 599 */,
/* 600 */,
/* 601 */,
/* 602 */,
/* 603 */,
/* 604 */,
/* 605 */,
/* 606 */,
/* 607 */,
/* 608 */,
/* 609 */,
/* 610 */,
/* 611 */,
/* 612 */,
/* 613 */,
/* 614 */,
/* 615 */,
/* 616 */,
/* 617 */,
/* 618 */,
/* 619 */,
/* 620 */,
/* 621 */,
/* 622 */,
/* 623 */,
/* 624 */,
/* 625 */,
/* 626 */,
/* 627 */,
/* 628 */,
/* 629 */,
/* 630 */,
/* 631 */,
/* 632 */,
/* 633 */,
/* 634 */,
/* 635 */,
/* 636 */,
/* 637 */,
/* 638 */,
/* 639 */,
/* 640 */,
/* 641 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _renderBlock = __webpack_require__(89);

var _reactRedux = __webpack_require__(13);

var _reactRouterDom = __webpack_require__(27);

var _configureStore = __webpack_require__(642);

var _configureStore2 = _interopRequireDefault(_configureStore);

var _i18nWpPlugin = __webpack_require__(52);

var _i18nWpPlugin2 = _interopRequireDefault(_i18nWpPlugin);

var _main = __webpack_require__(647);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var store = (0, _configureStore2.default)(forminatorData.currentForm); /* jshint esversion: 6 */


_i18nWpPlugin2.default.setLocale(forminatorl10n.locale);

window.forminatorChanges = {
	answers: [],
	settings: false
};

(0, _renderBlock.renderBlock)('forminator-poll-builder', _react2.default.createElement(
	_reactRedux.Provider,
	{ store: store },
	_react2.default.createElement(
		_reactRouterDom.MemoryRouter,
		null,
		_react2.default.createElement(_reactRouterDom.Route, { component: _main2.default })
	)
));

/***/ }),
/* 642 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = configureStore;

var _redux = __webpack_require__(11);

var _reduxThunk = __webpack_require__(112);

var _reduxThunk2 = _interopRequireDefault(_reduxThunk);

var _reducers = __webpack_require__(643);

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var newCreateStore = (0, _redux.compose)((0, _redux.applyMiddleware)(_reduxThunk2.default))(_redux.createStore);

function configureStore(initialState) {
	return newCreateStore(_reducers2.default, initialState);
}

/***/ }),
/* 643 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _redux = __webpack_require__(11);

var _answers = __webpack_require__(644);

var _answers2 = _interopRequireDefault(_answers);

var _settings = __webpack_require__(645);

var _settings2 = _interopRequireDefault(_settings);

var _modal = __webpack_require__(646);

var _modal2 = _interopRequireDefault(_modal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var appReducers = (0, _redux.combineReducers)({
	// List reducers
	answers: _answers2.default,
	settings: _settings2.default,
	modal: _modal2.default
});

// Import reducers
exports.default = appReducers;

/***/ }),
/* 644 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = answers;

var _utils = __webpack_require__(1);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function updateAnswer(state, action) {
	var answer = action.answer;

	var answerIndex = state.findIndex(function (answerObj) {
		return answerObj.element_id === answer.element_id;
	});

	state = (0, _utils.replaceInPosition)(state, answerIndex, answer);

	return state;
}

function answers() {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	var action = arguments[1];

	switch (action.type) {
		case 'UPDATE_ANSWERS':
			return action.answers;
		case 'UPDATE_ANSWER':
			return updateAnswer([].concat(_toConsumableArray(state)), action);
		default:
			return state;
	}
}

/***/ }),
/* 645 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = settings;
function updateSetting(state, action) {
	var setting = action.setting,
	    value = action.value;

	// Update value

	state[setting] = value;

	return state;
}

function updateSettings(state, action) {
	var settings = action.settings;


	return _extends({}, state, settings);
}

function updateTitle(state, action) {
	var title = action.title;

	// Update value

	state.formName = title;

	return state;
}

function settings() {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	var action = arguments[1];

	var newState = Object.assign({}, state);

	switch (action.type) {
		case 'UPDATE_SETTINGS':
			return updateSettings(newState, action);
		case 'UPDATE_SETTING':
			return updateSetting(newState, action);
		case 'UPDATE_TITLE':
			return updateTitle(newState, action);
		default:
			return state;
	}
}

/***/ }),
/* 646 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var initialState = {
	modalType: null,
	modalProps: {}
};

exports.default = function () {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	var action = arguments[1];

	switch (action.type) {
		case 'SHOW_MODAL':
			return {
				modalProps: action.modalProps,
				modalType: action.modalType,
				type: action.type
			};
		case 'HIDE_MODAL':
			return initialState;
		default:
			return state;
	}
};

/***/ }),
/* 647 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(23);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactRouterDom = __webpack_require__(27);

var _reactRedux = __webpack_require__(13);

var _utils = __webpack_require__(1);

var _header = __webpack_require__(648);

var _header2 = _interopRequireDefault(_header);

var _modal = __webpack_require__(652);

var _modal2 = _interopRequireDefault(_modal);

var _meta = __webpack_require__(659);

var _meta2 = _interopRequireDefault(_meta);

var _navigation = __webpack_require__(664);

var _navigation2 = _interopRequireDefault(_navigation);

var _builder = __webpack_require__(668);

var _builder2 = _interopRequireDefault(_builder);

var _appearance = __webpack_require__(673);

var _appearance2 = _interopRequireDefault(_appearance);

var _behaviour = __webpack_require__(701);

var _behaviour2 = _interopRequireDefault(_behaviour);

var _notifications = __webpack_require__(710);

var _notifications2 = _interopRequireDefault(_notifications);

var _integrations = __webpack_require__(713);

var _integrations2 = _interopRequireDefault(_integrations);

var _settings = __webpack_require__(715);

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Main = function (_Component) {
	_inherits(Main, _Component);

	function Main(props) {
		_classCallCheck(this, Main);

		return _possibleConstructorReturn(this, (Main.__proto__ || Object.getPrototypeOf(Main)).call(this, props));
	}

	_createClass(Main, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			window.addEventListener('beforeunload', this.handleBeforeunload);

			window.addEventListener('scroll', this.applySticky.bind(this));
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			window.removeEventListener('beforeunload', this.handleBeforeunload);
		}
	}, {
		key: 'applySticky',
		value: function applySticky() {
			var node = this.refs.StickyHeader;
			var currentOffset = node.getBoundingClientRect().top;
			var stickyOffset = parseInt(window.getComputedStyle(node).top.replace('px', ''));
			var isStuck = currentOffset <= stickyOffset;

			if (isStuck) {
				node.classList.add('sui-is-sticky');
			} else {
				node.classList.remove('sui-is-sticky');
			}
		}
	}, {
		key: 'handleBeforeunload',
		value: function handleBeforeunload(e) {
			if (window.forminatorChanges.length > 0 || window.forminatorChanges.settings === true) {
				e.preventDefault();
				e.returnValue = (0, _utils.translate)('You have unsaved changes, are you sure want to leave this page');
				return (0, _utils.translate)('You have unsaved changes, are you sure want to leave this page');
			}
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				null,
				_react2.default.createElement(_header2.default, null),
				_react2.default.createElement(
					'div',
					{ className: 'sui-row-with-sidenav' },
					_react2.default.createElement(_navigation2.default, this.props),
					_react2.default.createElement(
						'div',
						null,
						_react2.default.createElement(
							'div',
							{
								id: 'forminator-builder-status',
								className: 'sui-box sui-box-sticky',
								ref: 'StickyHeader'
							},
							_react2.default.createElement(_meta2.default, null)
						),
						_react2.default.createElement(_reactRouterDom.Route, { exact: true, path: '/', render: function render() {
								return _react2.default.createElement(_reactRouterDom.Redirect, { to: '/builder' });
							} }),
						_react2.default.createElement(_reactRouterDom.Route, { path: '/builder', component: _builder2.default }),
						_react2.default.createElement(_reactRouterDom.Route, { path: '/appearance', component: _appearance2.default }),
						_react2.default.createElement(_reactRouterDom.Route, { path: '/behaviour', component: _behaviour2.default }),
						_react2.default.createElement(_reactRouterDom.Route, { path: '/notifications', component: _notifications2.default }),
						_react2.default.createElement(_reactRouterDom.Route, { path: '/integrations', component: _integrations2.default }),
						_react2.default.createElement(_reactRouterDom.Route, { path: '/settings', component: _settings2.default })
					)
				),
				_react2.default.createElement(_modal2.default, this.props)
			);
		}
	}]);

	return Main;
}(_react.Component);

exports.default = Main;

/***/ }),
/* 648 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(13);

var _redux = __webpack_require__(11);

var _settings = __webpack_require__(185);

var settingsActions = _interopRequireWildcard(_settings);

var _modal = __webpack_require__(184);

var modalActions = _interopRequireWildcard(_modal);

var _navigation = __webpack_require__(400);

var navigationActions = _interopRequireWildcard(_navigation);

var _header = __webpack_require__(649);

var _header2 = _interopRequireDefault(_header);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function mapStateToProps(state) {
	return {
		id: state.settings.form_id,
		title: state.settings.formName || ''
	};
}

function mapDispatchToProps(dispatch) {
	return {
		actions: {
			navigationActions: (0, _redux.bindActionCreators)(navigationActions, dispatch),
			modalActions: (0, _redux.bindActionCreators)(modalActions, dispatch),
			settingsActions: (0, _redux.bindActionCreators)(settingsActions, dispatch)
		}
	};
}

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(_header2.default);

/***/ }),
/* 649 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = Header;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _documentation = __webpack_require__(650);

var _documentation2 = _interopRequireDefault(_documentation);

var _title = __webpack_require__(651);

var _title2 = _interopRequireDefault(_title);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Header(props) {
	return _react2.default.createElement(
		'div',
		{ className: 'sui-header fui-header-with-settings' },
		_react2.default.createElement(
			'div',
			{ className: 'fui-header-title' },
			_react2.default.createElement(
				'h1',
				{ className: 'sui-header-title' },
				(0, _utils.translate)('Edit Poll')
			),
			_react2.default.createElement(
				'div',
				{ className: 'sui-actions-right' },
				_react2.default.createElement(_documentation2.default, props)
			)
		),
		_react2.default.createElement(
			'div',
			{ className: 'fui-header-settings' },
			_react2.default.createElement(
				'div',
				{ className: 'sui-actions-left' },
				_react2.default.createElement(_title2.default, props)
			),
			_react2.default.createElement(
				'div',
				{ className: 'sui-actions-right' },
				_react2.default.createElement(_documentation2.default, props)
			)
		)
	);
}

/***/ }),
/* 650 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = Documentation;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Documentation(props) {
	if (!forminatorData.showDocLink) {
		return '';
	}
	return _react2.default.createElement(
		'a',
		{
			href: 'https://wpmudev.com/docs/wpmu-dev-plugins/forminator/#polls',
			target: '_blank',
			className: 'sui-button sui-button-ghost'
		},
		_react2.default.createElement('span', { className: 'sui-icon-academy' }),
		' ',
		(0, _utils.translate)('View Documentation')
	);
}

/***/ }),
/* 651 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _metaDropdown = __webpack_require__(187);

var _metaDropdown2 = _interopRequireDefault(_metaDropdown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Title = function (_Component) {
	_inherits(Title, _Component);

	function Title(props) {
		_classCallCheck(this, Title);

		return _possibleConstructorReturn(this, (Title.__proto__ || Object.getPrototypeOf(Title)).call(this, props));
	}

	_createClass(Title, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var $moduleName = jQuery('.sui-sidenav .sui-with-floating-input'),
			    $pageHeader = jQuery('.sui-header'),
			    $pageTitle = $pageHeader.find('.sui-header-title'),
			    $titleWidth = $pageTitle.width(),
			    $navWidth = $pageHeader.next().find('.sui-sidenav').width();

			if ($titleWidth > $navWidth) {
				$moduleName.css({
					left: $titleWidth + 20 + 'px'
				});
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var title = this.props.title;

			var emptyTitle = _.isEmpty(title.trim());
			var customClass = emptyTitle ? 'sui-form-field-error' : '';

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'div',
					{ className: 'sui-form-field ' + customClass },
					_react2.default.createElement(
						'label',
						{
							htmlFor: 'forminator-set-title',
							id: 'forminator-set-title-label',
							className: 'sui-screen-reader-text'
						},
						(0, _utils.translate)('Name your poll')
					),
					_react2.default.createElement('input', {
						type: 'text',
						value: title,
						placeholder: (0, _utils.translate)('Give your poll a name'),
						id: 'forminator-set-title',
						className: 'sui-form-control',
						'aria-labelledby': 'forminator-set-title-label',
						'aria-describedby': 'forminator-set-title-message',
						'aria-required': 'true',
						accessKey: 't',
						onChange: function onChange(e) {
							return _this2.props.actions.navigationActions.updateTitle(e.target.value);
						}
					}),
					_react2.default.createElement(
						'p',
						{
							role: 'alert',
							id: 'forminator-set-title-message',
							className: 'sui-error-message',
							style: {
								display: emptyTitle ? 'block' : 'none',
								marginBottom: 0
							}
						},
						emptyTitle && (0, _utils.translate)('Please, enter a valid name.')
					)
				),
				_react2.default.createElement(_metaDropdown2.default, _extends({}, this.props, {
					type: 'poll'
				}))
			);
		}
	}]);

	return Title;
}(_react.Component);

exports.default = Title;

/***/ }),
/* 652 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(13);

var _redux = __webpack_require__(11);

var _modal = __webpack_require__(653);

var _modal2 = _interopRequireDefault(_modal);

var _builder = __webpack_require__(299);

var builderActions = _interopRequireWildcard(_builder);

var _settings = __webpack_require__(185);

var settingsActions = _interopRequireWildcard(_settings);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function mapStateToProps(state) {
	return {
		modal: state.modal,
		answers: state.answers,
		settings: state.settings,
		id: state.settings.form_id
	};
}

function mapDispatchToProps(dispatch) {
	return {
		actions: {
			builderActions: (0, _redux.bindActionCreators)(builderActions, dispatch),
			settingsActions: (0, _redux.bindActionCreators)(settingsActions, dispatch)
		}
	};
}

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(_modal2.default);

/***/ }),
/* 653 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(23);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _modals = __webpack_require__(654);

var _modals2 = _interopRequireDefault(_modals);

var _focusTrap = __webpack_require__(192);

var _focusTrap2 = _interopRequireDefault(_focusTrap);

var _reactDisplace = __webpack_require__(182);

var _reactDisplace2 = _interopRequireDefault(_reactDisplace);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MODAL_TYPES = {
	preview: _modals2.default.previewModal,
	publish: _modals2.default.publishModal,
	shortcode: _modals2.default.shortcodeModal,
	delete: _modals2.default.deleteModal
};

/* global setTimeout,clearTimeout */

var Modal = function (_Component) {
	_inherits(Modal, _Component);

	function Modal(props) {
		_classCallCheck(this, Modal);

		return _possibleConstructorReturn(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).call(this, props));
	}

	_createClass(Modal, [{
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps) {
			var _this2 = this;

			this.$el = jQuery(this.el);
			var self = this;

			if (prevProps.modal.modalProps.open !== this.props.modal.modalProps.open) {
				var modalElement = _reactDom2.default.findDOMNode(this);

				if (this.props.modal.modalProps.open) {
					this.focusAfterClosed = this.props.modal.modalProps.activeElement;

					var focusFirst = this.props.modal.modalProps.focusFirst;

					setTimeout(function () {
						if ('string' === typeof focusFirst) {
							self.focusFirst = self.$el.find(focusFirst);
						} else if ('object' === (typeof focusFirst === 'undefined' ? 'undefined' : _typeof(focusFirst))) {
							self.focusFirst = focusFirst;
						} else {
							self.focusFirst = null;
						}

						if (self.focusFirst && self.focusFirst.length) {
							self.setFocus(self.focusFirst.first());
						}
					}, 320);

					jQuery('#wpwrap').attr('aria-hidden', 'true');
				}

				if (!this.props.modal.modalProps.open) {
					jQuery('#wpwrap').attr('aria-hidden', 'false');

					setTimeout(function () {
						self.setFocus(self.focusAfterClosed);
					}, 320);

					this.hideModalTimeout = setTimeout(function () {
						modalElement.setAttribute('aria-hidden', 'true');
						// cleanup
						_this2.props.modal.modalType = null;
						_this2.forceUpdate();
					}, 300);
				} else {
					modalElement.removeAttribute('aria-hidden');
				}
			}
		}
	}, {
		key: 'setFocus',
		value: function setFocus(element) {
			var focusInterval = 10; // ms, time between function calls
			var focusTotalRepetitions = 10; // number of repetitions

			if (typeof element === 'undefined') {
				return;
			}

			element.attr('tabindex', '0');
			element.blur();

			var focusRepetitions = 0;
			var interval = window.setInterval(function () {
				element.focus();
				focusRepetitions++;

				if (focusRepetitions >= focusTotalRepetitions) {
					window.clearInterval(interval);
				}
			}, focusInterval);
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			clearTimeout(this.hideModalTimeout);
		}
	}, {
		key: 'render',
		value: function render() {
			var _this3 = this;

			if (!this.props.modal.modalType) {
				return null;
			}

			var modalClass = 'sui-modal-lg';
			var overlayClass = ['sui-modal-content', 'sui-content-fade-in'];
			if (!this.props.modal.modalProps.open) {
				overlayClass = ['sui-modal-content', 'sui-content-fade-out'];
			}

			var SpecifiedModal = MODAL_TYPES[this.props.modal.modalType];

			if (this.props.modal.modalType === 'publish') {
				modalClass = 'sui-modal-sm fui-dialog-publish';
			}

			if (this.props.modal.modalType === 'shortcode') {
				modalClass = 'sui-modal-sm fui-dialog-publish';
			}

			if (this.props.modal.modalType === 'delete') {
				modalClass = 'sui-modal-sm';
			}

			var classes = jQuery('.sui-color-accessible').length ? 'sui-wrap sui-color-accessible' : 'sui-wrap';

			return _react2.default.createElement(
				'div',
				{ className: classes },
				_react2.default.createElement(
					'div',
					{ id: 'forminator-modal', className: 'sui-modal sui-active ' + modalClass },
					_react2.default.createElement(
						'div',
						_extends({
							role: 'dialog',
							id: 'modal-' + this.props.modal.modalProps.id,
							className: '' + overlayClass.join(' '),
							'aria-modal': 'true',
							'aria-live': 'polite'
						}, this.props.modal.modalProps.labelledBy && { 'aria-labelledby': this.props.modal.modalProps.labelledBy }, this.props.modal.modalProps.describedBy && { 'aria-describedby': this.props.modal.modalProps.describedBy }, {
							ref: function ref(el) {
								return _this3.el = el;
							}
						}),
						_react2.default.createElement(
							'div',
							{ className: 'sui-box' },
							_react2.default.createElement(SpecifiedModal, this.props)
						)
					)
				)
			);
		}
	}]);

	return Modal;
}(_react.Component);

var DisplacedModal = (0, _reactDisplace2.default)(Modal);

DisplacedModal.renderTo = function (input) {
	return (0, _reactDisplace2.default)(Modal, { renderTo: input });
};

module.exports = DisplacedModal;

/***/ }),
/* 654 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _preview = __webpack_require__(655);

var _preview2 = _interopRequireDefault(_preview);

var _publish = __webpack_require__(656);

var _publish2 = _interopRequireDefault(_publish);

var _shortcode = __webpack_require__(657);

var _shortcode2 = _interopRequireDefault(_shortcode);

var _delete = __webpack_require__(658);

var _delete2 = _interopRequireDefault(_delete);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var modalTypes = {
	previewModal: _preview2.default,
	publishModal: _publish2.default,
	shortcodeModal: _shortcode2.default,
	deleteModal: _delete2.default
};

exports.default = modalTypes;

/***/ }),
/* 655 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _reactBox = __webpack_require__(61);

var _reactButtonIcon = __webpack_require__(22);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var previewModal = function (_Component) {
	_inherits(previewModal, _Component);

	function previewModal(props) {
		_classCallCheck(this, previewModal);

		var _this = _possibleConstructorReturn(this, (previewModal.__proto__ || Object.getPrototypeOf(previewModal)).call(this, props));

		_this.closeModal = _this.props.modal.modalProps.closeModal.bind(_this);
		_this.previewLoaded = _this.previewLoaded.bind(_this);
		return _this;
	}

	_createClass(previewModal, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.$el = jQuery(this.el);
			this.$body = jQuery(this.body);
			this.mounted = true;

			this.load();

			jQuery(document).off('after.load.forminator');
			jQuery(document).on('after.load.forminator', this.previewLoaded);
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.mounted = false;
		}
	}, {
		key: 'previewLoaded',
		value: function previewLoaded() {
			this.$body.find('.sui-notice-loading').remove();
		}
	}, {
		key: 'load',
		value: function load() {
			var state = {
				answers: this.props.answers,
				settings: this.props.settings
			};

			var config = {
				id: this.props.id,
				action: 'forminator_load_poll',
				type: 'forminator_polls',
				nonce: forminatorData.previewNonce,
				render_id: 0,
				is_preview: 1,
				preview_data: state,
				last_submit_data: {}
			};
			this.$el.forminatorLoader(config);
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					_reactBox.BoxHeader,
					{
						title: (0, _utils.translate)('Preview')
					},
					_react2.default.createElement(_reactButtonIcon.ButtonIcon, {
						icon: 'close',
						iconSize: 'md',
						label: (0, _utils.translate)('Close this dialog window'),
						onClick: this.closeModal
					})
				),
				_react2.default.createElement(
					'div',
					{
						className: 'sui-box-body',
						ref: function ref(body) {
							return _this2.body = body;
						}
					},
					_react2.default.createElement(
						'div',
						{ className: 'sui-notice sui-notice-loading sui-active', style: { display: 'block' } },
						_react2.default.createElement(
							'div',
							{ className: 'sui-notice-content' },
							_react2.default.createElement(
								'div',
								{ className: 'sui-notice-message' },
								_react2.default.createElement('span', { className: 'sui-notice-icon sui-icon-loader sui-loading' }),
								_react2.default.createElement(
									'p',
									null,
									(0, _utils.translate)('Loading preview')
								)
							)
						)
					),
					_react2.default.createElement('form', {
						ref: function ref(el) {
							return _this2.el = el;
						},
						id: 'forminator-module-' + this.props.id,
						'data-forminator-render': '0',
						className: 'sui-hidden'
					})
				)
			);
		}
	}]);

	return previewModal;
}(_react.Component);

exports.default = previewModal;

/***/ }),
/* 656 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var publishModal = function (_Component) {
	_inherits(publishModal, _Component);

	function publishModal(props) {
		_classCallCheck(this, publishModal);

		var _this = _possibleConstructorReturn(this, (publishModal.__proto__ || Object.getPrototypeOf(publishModal)).call(this, props));

		_this.closeModal = _this.props.modal.modalProps.closeModal.bind(_this);
		return _this;
	}

	_createClass(publishModal, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'div',
					{
						className: 'sui-box-header ' + 'sui-flatten ' + 'sui-content-center ' + 'sui-spacing-top--60' + ('' + (forminatorData.showBranding ? ' sui-spacing-bottom--30' : ' sui-spacing-bottom--60'))
					},
					_react2.default.createElement('span', { className: 'sui-icon-loader sui-loading', 'aria-hidden': 'true' }),
					_react2.default.createElement(
						'h3',
						{ className: 'sui-box-title sui-lg', id: 'dialogTitle' },
						(0, _utils.translate)('Publishing poll')
					),
					_react2.default.createElement(
						'p',
						{ className: 'sui-description' },
						(0, _utils.translate)('Great work! Please hold tight a few moments while we publish your form to the world.')
					)
				)
			);
		}
	}]);

	return publishModal;
}(_react.Component);

exports.default = publishModal;

/***/ }),
/* 657 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _notifications = __webpack_require__(30);

var _notifications2 = _interopRequireDefault(_notifications);

var _reactButtonIcon = __webpack_require__(22);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var shortcodeModal = function (_Component) {
	_inherits(shortcodeModal, _Component);

	function shortcodeModal(props) {
		_classCallCheck(this, shortcodeModal);

		var _this = _possibleConstructorReturn(this, (shortcodeModal.__proto__ || Object.getPrototypeOf(shortcodeModal)).call(this, props));

		_this.closeModal = _this.props.modal.modalProps.closeModal.bind(_this);
		_this.copyToClipboard = _this.copyToClipboard.bind(_this);
		return _this;
	}

	_createClass(shortcodeModal, [{
		key: 'copyToClipboard',
		value: function copyToClipboard() {
			this.input.select();
			document.execCommand('copy');

			var custom = new _notifications2.default({
				type: 'success',
				text: (0, _utils.translate)('Shortcode has been copied successfully.'),
				time: 4000
			});
			custom.open();
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-header sui-flatten sui-content-center sui-spacing-top--60' },
					_react2.default.createElement(_reactButtonIcon.ButtonIcon, {
						icon: 'close',
						iconSize: 'md',
						label: (0, _utils.translate)('Close this dialog window'),
						className: 'sui-button-float--right forminator-cancel-create-form',
						onClick: this.closeModal
					}),
					_react2.default.createElement('span', { className: 'sui-icon-check sui-lg', 'aria-hidden': 'true' }),
					_react2.default.createElement(
						'h3',
						{
							id: 'dialogTitle',
							className: 'sui-box-title sui-lg'
						},
						(0, _utils.translate)('Ready to go!')
					),
					_react2.default.createElement(
						'p',
						{ className: 'sui-description' },
						(0, _utils.translate)('Your poll is now ready to be embedded into a page or template ' + 'of your choice. Simply copy and paste the shortcode below to ' + 'display it!')
					)
				),
				_react2.default.createElement(
					'div',
					{
						className: 'sui-box-body' + (forminatorData.showBranding ? '' : ' sui-spacing-bottom--60')
					},
					_react2.default.createElement(
						'div',
						{ id: 'forminator-form-name-input', className: 'sui-form-field' },
						_react2.default.createElement(
							'label',
							{ htmlFor: 'forminator-form-name', className: 'sui-label' },
							(0, _utils.translate)('Shortcode')
						),
						_react2.default.createElement(
							'div',
							{ className: 'sui-with-button sui-with-button-icon' },
							_react2.default.createElement('input', {
								type: 'text',
								id: 'forminator-form-shortcode',
								ref: function ref(input) {
									return _this2.input = input;
								},
								className: 'sui-form-control',
								defaultValue: '[forminator_poll id="' + this.props.id + '"]'
							}),
							_react2.default.createElement(_reactButtonIcon.ButtonIcon, {
								icon: 'copy',
								iconSize: 'md',
								label: (0, _utils.translate)('Copy Shortcode'),
								onClick: this.copyToClipboard
							})
						)
					)
				)
			);
		}
	}]);

	return shortcodeModal;
}(_react.Component);

exports.default = shortcodeModal;

/***/ }),
/* 658 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(27);

var _utils = __webpack_require__(1);

var _reactButton = __webpack_require__(51);

var _reactButtonIcon = __webpack_require__(22);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var deleteModal = function (_Component) {
	_inherits(deleteModal, _Component);

	function deleteModal(props) {
		_classCallCheck(this, deleteModal);

		var _this = _possibleConstructorReturn(this, (deleteModal.__proto__ || Object.getPrototypeOf(deleteModal)).call(this, props));

		_this.closeModal = _this.props.modal.modalProps.closeModal.bind(_this);
		_this.trashField = _this.trashField.bind(_this);
		return _this;
	}

	_createClass(deleteModal, [{
		key: 'trashField',
		value: function trashField() {
			// Delete field
			this.props.modal.modalProps.trashField();

			// Close modal
			this.closeModal();
		}
	}, {
		key: 'render',
		value: function render() {
			var fieldLabel = this.props.modal.modalProps.answer.title;

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'div',
					{
						className: 'sui-box-header sui-flatten sui-content-center sui-spacing-top--60'
					},
					_react2.default.createElement(_reactButtonIcon.ButtonIcon, {
						icon: 'close',
						iconSize: 'md',
						label: (0, _utils.translate)('Close this dialog window'),
						className: 'sui-button-float--right',
						onClick: this.closeModal
					}),
					_react2.default.createElement(
						'h3',
						{
							id: 'dialogTitle',
							className: 'sui-box-title sui-lg'
						},
						(0, _utils.translate)('Delete Answer')
					),
					_react2.default.createElement(
						'p',
						{ className: 'sui-description' },
						(0, _utils.translate)('Deleting this answer will remove its value from the existing submissions as well.')
					)
				),
				_react2.default.createElement(
					'div',
					{
						className: 'sui-box-footer sui-flatten sui-content-center'
					},
					_react2.default.createElement(_reactButton.Button, {
						design: 'ghost',
						className: 'forminator-discard-field-settings',
						label: (0, _utils.translate)('Cancel'),
						onClick: this.closeModal
					}),
					_react2.default.createElement(_reactButton.Button, {
						color: 'red',
						design: 'ghost',
						icon: 'trash',
						label: (0, _utils.translate)('Delete'),
						onClick: this.trashField
					})
				)
			);
		}
	}]);

	return deleteModal;
}(_react.Component);

exports.default = deleteModal;

/***/ }),
/* 659 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(13);

var _redux = __webpack_require__(11);

var _settings = __webpack_require__(185);

var settingsActions = _interopRequireWildcard(_settings);

var _modal = __webpack_require__(184);

var modalActions = _interopRequireWildcard(_modal);

var _meta = __webpack_require__(660);

var _meta2 = _interopRequireDefault(_meta);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function mapStateToProps(state) {
	return {
		id: state.settings.form_id,
		status: state.settings.form_status,
		state: state,
		title: state.settings.formName || '',
		changed: window.forminatorChanges
	};
}

function mapDispatchToProps(dispatch) {
	return {
		actions: {
			settingsActions: (0, _redux.bindActionCreators)(settingsActions, dispatch),
			modalActions: (0, _redux.bindActionCreators)(modalActions, dispatch)
		}
	};
}

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(_meta2.default);

/***/ }),
/* 660 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _axios = __webpack_require__(39);

var _axios2 = _interopRequireDefault(_axios);

var _qs = __webpack_require__(40);

var _qs2 = _interopRequireDefault(_qs);

var _notifications = __webpack_require__(30);

var _notifications2 = _interopRequireDefault(_notifications);

var _status = __webpack_require__(661);

var _status2 = _interopRequireDefault(_status);

var _buttons = __webpack_require__(662);

var _buttons2 = _interopRequireDefault(_buttons);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Meta = function (_Component) {
	_inherits(Meta, _Component);

	function Meta(props) {
		_classCallCheck(this, Meta);

		var _this = _possibleConstructorReturn(this, (Meta.__proto__ || Object.getPrototypeOf(Meta)).call(this, props));

		_this.state = {
			publishLoading: false,
			draftLoading: false
		};

		_this.publish = _this.publish.bind(_this);
		_this.draft = _this.draft.bind(_this);
		return _this;
	}

	_createClass(Meta, [{
		key: 'publish',
		value: function publish() {
			var _this2 = this;

			var state = this.props.state;
			var _state$settings = state.settings,
			    form_id = _state$settings.form_id,
			    formName = _state$settings.formName;


			var formNameValue = !_.isUndefined(formName) ? formName : '';
			var formId = !_.isUndefined(form_id) ? form_id : -1;

			this.setState({
				publishLoading: true
			});

			var data = {
				action: 'forminator_save_poll',
				_wpnonce: forminatorData.formNonce,
				formName: formNameValue,
				form_id: formId,
				status: 'publish',
				version: forminatorData.version,
				data: JSON.stringify(state)
			};

			// Delay ajax a bit to imitate saving
			setTimeout(function () {
				_this2.save(data, 'publish');
			}, 1500);
		}
	}, {
		key: 'draft',
		value: function draft() {
			var _this3 = this;

			var state = this.props.state;
			var _state$settings2 = state.settings,
			    form_id = _state$settings2.form_id,
			    formName = _state$settings2.formName;


			var formNameValue = !_.isUndefined(formName) ? formName : '';
			var formId = !_.isUndefined(form_id) ? form_id : -1;

			this.setState({
				draftLoading: true
			});

			var data = {
				action: 'forminator_save_poll',
				_wpnonce: forminatorData.formNonce,
				formName: formNameValue,
				form_id: formId,
				status: 'draft',
				version: forminatorData.version,
				data: JSON.stringify(state)
			};

			// Delay ajax a bit to imitate saving
			setTimeout(function () {
				_this3.save(data, 'draft');
			}, 1500);
		}
	}, {
		key: 'isValid',
		value: function isValid() {
			var answers = this.props.state.answers;

			if (answers.length === 0) {
				return false;
			}

			var hasEmpty = _.some(answers, function (answer) {
				return _.isEmpty(answer.title);
			});

			return !hasEmpty;
		}
	}, {
		key: 'save',
		value: function save(object, newStatus) {
			var _this4 = this;

			var self = this;
			var status = this.props.status;

			var isPublish = status === 'draft' && newStatus === 'publish' || _.isUndefined(status) && newStatus === 'publish';
			var vote_limit_input = this.props.state.settings.vote_limit_input;


			if (!this.isValid()) {
				var custom = new _notifications2.default({
					type: 'error',
					text: (0, _utils.translate)('Poll answers can not be empty.'),
					time: 4000
				});

				custom.open();

				this.closePopup(isPublish);

				return false;
			}
			if (!_.isUndefined(vote_limit_input) && vote_limit_input < 0) {
				var _custom = new _notifications2.default({
					type: 'error',
					text: (0, _utils.translate)('Please enter valid voting limit.'),
					time: 4000
				});

				_custom.open();

				this.closePopup(isPublish);

				return false;
			}

			_axios2.default.post(forminatorData.ajaxUrl, _qs2.default.stringify(object)).then(function (data) {
				if (data.data.success) {
					// Update form ID
					if (object.form_id === -1) {
						_this4.props.actions.settingsActions.updateSetting('form_id', data.data.data);
						// update form_id on window forminatorData, for future reference
						forminatorData.currentForm.settings.form_id = data.data.data;

						window.history.pushState({}, "Edit Poll", forminatorData.pollEditUrl + '&id=' + data.data.data);
					}

					// Update form status
					_this4.props.actions.settingsActions.saveBuilder('form_status', newStatus);

					// We use `false` intentionally cuz if isPublish is `true` - a new popup will close the previous one automatically.
					_this4.closePopup(false);

					if (isPublish) {
						// Close method
						var close = function close(open) {
							self.props.actions.modalActions.showModal({
								open: false
							}, 'shortcode');
						};

						self.props.actions.modalActions.showModal({
							open: true,
							closeModal: close
						}, 'shortcode');
					}
				} else {
					_this4.closePopup(isPublish);

					var _custom2 = new _notifications2.default({
						type: 'error',
						text: (0, _utils.translate)('Something went wrong while saving your form. Please try again.')
					});

					_custom2.open();
				}
			}).catch(function (err) {
				var custom = new _notifications2.default({
					type: 'error',
					text: (0, _utils.translate)('Something went wrong while saving your form. Please try again.')
				});

				custom.open();

				console.log(err);

				_this4.closePopup(isPublish);
			});
		}
	}, {
		key: 'closePopup',
		value: function closePopup(isPublish) {
			var self = this;

			if (isPublish) {
				self.props.actions.modalActions.showModal({
					open: false,
					closeModal: this.closeModal
				}, 'publish');
			}

			this.setState({
				publishLoading: false,
				draftLoading: false
			});
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-status' },
				_react2.default.createElement(_status2.default, _extends({}, this.props, {
					state: this.state
				})),
				_react2.default.createElement(_buttons2.default, _extends({}, this.props, {
					publish: this.publish,
					draft: this.draft,
					state: this.state
				}))
			);
		}
	}]);

	return Meta;
}(_react.Component);

exports.default = Meta;

/***/ }),
/* 661 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = Status;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Status(props) {
	var status = props.status;


	var classType = status === 'publish' ? 'sui-tag-published' : 'sui-tag-draft';

	var isLoading = props.state.draftLoading || props.state.publishLoading ? true : false;

	return _react2.default.createElement(
		'div',
		{ className: 'sui-status' },
		_react2.default.createElement(
			'div',
			{ className: 'sui-status-module' },
			(0, _utils.translate)('Status'),
			_react2.default.createElement(
				'span',
				{ className: 'sui-tag ' + classType },
				function () {
					switch (status) {
						case 'publish':
							return (0, _utils.translate)('Published');
						default:
							return (0, _utils.translate)('Draft');
					}
				}()
			)
		),
		isLoading && _react2.default.createElement(
			'div',
			{ className: 'sui-status-changes' },
			_react2.default.createElement('i', { className: 'sui-icon-loader sui-loading', 'aria-hidden': 'true' }),
			(0, _utils.translate)('Saving...')
		),
		!isLoading && props.changed.settings && _react2.default.createElement(
			'div',
			{ className: 'sui-status-changes' },
			_react2.default.createElement('i', { className: 'sui-icon-update', 'aria-hidden': 'true' }),
			(0, _utils.translate)('Unsaved changes')
		),
		!isLoading && !props.changed.settings && props.changed.saved && _react2.default.createElement(
			'div',
			{ className: 'sui-status-changes' },
			_react2.default.createElement('i', { className: 'sui-icon-check-tick', 'aria-hidden': 'true' }),
			(0, _utils.translate)('Saved')
		)
	);
}

/***/ }),
/* 662 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _preview = __webpack_require__(663);

var _preview2 = _interopRequireDefault(_preview);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Buttons = function (_Component) {
	_inherits(Buttons, _Component);

	function Buttons(props) {
		_classCallCheck(this, Buttons);

		var _this = _possibleConstructorReturn(this, (Buttons.__proto__ || Object.getPrototypeOf(Buttons)).call(this, props));

		_this.publish = _this.publish.bind(_this);
		_this.draft = _this.draft.bind(_this);
		return _this;
	}

	_createClass(Buttons, [{
		key: 'closeModal',
		value: function closeModal() {
			this.props.actions.modalActions.showModal({
				open: false
			}, 'publish');
		}
	}, {
		key: 'publish',
		value: function publish() {
			var self = this;
			var _props = this.props,
			    status = _props.status,
			    title = _props.title;


			if (_.isEmpty(title.trim())) {
				return;
			}

			// Call parent method for publish
			this.props.publish();

			if (status === 'draft' || _.isEmpty(status)) {
				this.props.actions.modalActions.showModal({
					open: true,
					closeModal: this.closeModal
				}, 'publish');
			}
		}
	}, {
		key: 'draft',
		value: function draft() {
			var title = this.props.title;


			if (_.isEmpty(title.trim())) {
				return;
			}

			// Call parent method for draft
			this.props.draft();
		}
	}, {
		key: 'render',
		value: function render() {
			var status = this.props.status;
			var _props$state = this.props.state,
			    draftLoading = _props$state.draftLoading,
			    publishLoading = _props$state.publishLoading;


			return _react2.default.createElement(
				'div',
				{ className: 'sui-actions' },
				_react2.default.createElement(
					'button',
					{
						id: 'forminator-module-save',
						className: 'sui-button sui-button-ghost',
						style: { borderColor: 'transparent' },
						disabled: !!draftLoading || publishLoading,
						onClick: this.draft
					},
					'publish' === status && _react2.default.createElement(
						_react.Fragment,
						null,
						_react2.default.createElement('span', { className: 'sui-icon-unpublish', 'aria-hidden': 'true' }),
						(0, _utils.translate)('Unpublish')
					),
					'publish' !== status && _react2.default.createElement(
						_react.Fragment,
						null,
						_react2.default.createElement('span', { className: 'sui-icon-save', 'aria-hidden': 'true' }),
						(0, _utils.translate)('Save Draft')
					)
				),
				_react2.default.createElement(_preview2.default, _extends({}, this.props, {
					disabled: !!(draftLoading || publishLoading)
				})),
				_react2.default.createElement(
					'button',
					{
						id: 'forminator-module-publish',
						className: 'sui-button sui-button-blue',
						disabled: !!(draftLoading || publishLoading),
						onClick: this.publish
					},
					_react2.default.createElement(
						'span',
						{ className: 'sui-loading-text' },
						_react2.default.createElement('span', { className: 'sui-icon-web-globe-world', 'aria-hidden': 'true' }),
						_react2.default.createElement(
							'span',
							{ className: 'button-text' },
							function () {
								switch (status) {
									case 'publish':
										return (0, _utils.translate)('Update');
									default:
										return (0, _utils.translate)('Publish');
								}
							}()
						)
					),
					_react2.default.createElement('span', { className: 'sui-icon-loader sui-loading', 'aria-hidden': 'true' })
				)
			);
		}
	}]);

	return Buttons;
}(_react.Component);

exports.default = Buttons;

/***/ }),
/* 663 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Preview = function (_Component) {
	_inherits(Preview, _Component);

	function Preview(props) {
		_classCallCheck(this, Preview);

		var _this = _possibleConstructorReturn(this, (Preview.__proto__ || Object.getPrototypeOf(Preview)).call(this, props));

		_this.closeModal = _this.closeModal.bind(_this);
		_this.openModal = _this.openModal.bind(_this);
		return _this;
	}

	_createClass(Preview, [{
		key: 'closeModal',
		value: function closeModal(event) {
			this.props.actions.modalActions.showModal({
				open: false,
				title: (0, _utils.translate)('Preview')
			}, 'preview');

			// Remove preview custom styles
			jQuery('#forminator-module-styles-' + this.props.id).remove();
		}
	}, {
		key: 'openModal',
		value: function openModal(event) {
			this.props.actions.modalActions.showModal({
				open: true,
				title: 'Preview',
				closeModal: this.closeModal
			}, 'preview');
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					id: 'forminator-preview-button',
					className: 'sui-button sui-sidenav-hide-md',
					accessKey: 'p',
					onClick: this.openModal,
					disabled: this.props.disabled
				},
				_react2.default.createElement('i', { className: 'sui-icon-eye', 'aria-hidden': 'true' }),
				' ',
				(0, _utils.translate)('Preview')
			);
		}
	}]);

	return Preview;
}(_react.Component);

exports.default = Preview;

/***/ }),
/* 664 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(13);

var _redux = __webpack_require__(11);

var _modal = __webpack_require__(184);

var modalActions = _interopRequireWildcard(_modal);

var _navigation = __webpack_require__(400);

var navigationActions = _interopRequireWildcard(_navigation);

var _navigation2 = __webpack_require__(665);

var _navigation3 = _interopRequireDefault(_navigation2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function mapStateToProps(state) {
	return {
		id: state.settings.form_id,
		title: state.settings.formName || ''
	};
}

function mapDispatchToProps(dispatch) {
	return {
		actions: {
			navigationActions: (0, _redux.bindActionCreators)(navigationActions, dispatch),
			modalActions: (0, _redux.bindActionCreators)(modalActions, dispatch)
		}
	};
}

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(_navigation3.default);

/***/ }),
/* 665 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = Navigation;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _menu = __webpack_require__(666);

var _menu2 = _interopRequireDefault(_menu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Navigation(props) {
	return _react2.default.createElement(
		'div',
		{ className: 'sui-sidenav fui-sidenav' },
		_react2.default.createElement(_menu2.default, props)
	);
}

/***/ }),
/* 666 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(27);

var _utils = __webpack_require__(1);

var _mobileSelect = __webpack_require__(667);

var _mobileSelect2 = _interopRequireDefault(_mobileSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Menu = function (_Component) {
	_inherits(Menu, _Component);

	function Menu(props) {
		_classCallCheck(this, Menu);

		return _possibleConstructorReturn(this, (Menu.__proto__ || Object.getPrototypeOf(Menu)).call(this, props));
	}

	_createClass(Menu, [{
		key: 'render',
		value: function render() {
			var _this2 = this;

			var goToSection = function goToSection(module) {
				_this2.props.history.push('/' + module);
			};

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'ul',
					{ className: 'sui-vertical-tabs ' + 'sui-sidenav-sticky ' + 'sui-sidenav-hide-md ' + 'fui-sidenav' },
					_react2.default.createElement(
						'li',
						{ className: 'sui-vertical-tab' },
						_react2.default.createElement(
							_reactRouterDom.NavLink,
							{ to: '/builder', activeClassName: 'current' },
							(0, _utils.translate)('Details')
						)
					),
					_react2.default.createElement(
						'li',
						{ className: 'sui-vertical-tab' },
						_react2.default.createElement(
							_reactRouterDom.NavLink,
							{ to: '/appearance', activeClassName: 'current' },
							(0, _utils.translate)('Appearance')
						)
					),
					_react2.default.createElement(
						'li',
						{ className: 'sui-vertical-tab' },
						_react2.default.createElement(
							_reactRouterDom.NavLink,
							{ to: '/behaviour', activeClassName: 'current' },
							(0, _utils.translate)('Behavior')
						)
					),
					_react2.default.createElement(
						'li',
						{ className: 'sui-vertical-tab' },
						_react2.default.createElement(
							_reactRouterDom.NavLink,
							{ to: '/notifications', activeClassName: 'current' },
							(0, _utils.translate)('Notifications')
						)
					),
					_react2.default.createElement(
						'li',
						{ className: 'sui-vertical-tab' },
						_react2.default.createElement(
							_reactRouterDom.NavLink,
							{ to: '/integrations', activeClassName: 'current' },
							(0, _utils.translate)('Integrations')
						)
					),
					_react2.default.createElement(
						'li',
						{ className: 'sui-vertical-tab' },
						_react2.default.createElement(
							_reactRouterDom.NavLink,
							{ to: '/settings', activeClassName: 'current' },
							(0, _utils.translate)('Settings')
						)
					)
				),
				_react2.default.createElement(
					_mobileSelect2.default,
					this.props,
					_react2.default.createElement(
						'option',
						{ value: '' },
						(0, _utils.translate)('Details')
					),
					_react2.default.createElement(
						'option',
						{ value: 'appearance' },
						(0, _utils.translate)('Appearance')
					),
					_react2.default.createElement(
						'option',
						{ value: 'behaviour' },
						(0, _utils.translate)('Behavior')
					),
					_react2.default.createElement(
						'option',
						{ value: 'notifications' },
						(0, _utils.translate)('Email Notifications')
					),
					_react2.default.createElement(
						'option',
						{ value: 'integrations' },
						(0, _utils.translate)('Integrations')
					),
					_react2.default.createElement(
						'option',
						{ value: 'settings' },
						(0, _utils.translate)('Settings')
					)
				)
			);
		}
	}]);

	return Menu;
}(_react.Component);

exports.default = Menu;

/***/ }),
/* 667 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MobileSelect = function (_Component) {
	_inherits(MobileSelect, _Component);

	function MobileSelect(props) {
		_classCallCheck(this, MobileSelect);

		var _this = _possibleConstructorReturn(this, (MobileSelect.__proto__ || Object.getPrototypeOf(MobileSelect)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		return _this;
	}

	_createClass(MobileSelect, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.$el = jQuery(this.el);
			SUI.select.init(this.$el);

			this.updateValue = this.updateValue.bind(this);
			this.$el.on('change', this.updateValue);
		}
	}, {
		key: 'updateValue',
		value: function updateValue(e) {
			var value = e.target.value;

			this.props.history.push('/' + value);
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.$el.off('change', this.updateValue);
			this.$el.unbind().removeData();
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			return _react2.default.createElement(
				'div',
				{ className: 'sui-form-field sui-sidenav-hide-lg' },
				_react2.default.createElement(
					'label',
					{ className: 'sui-label' },
					(0, _utils.translate)('Navigate')
				),
				_react2.default.createElement(
					'select',
					{
						className: 'sui-select sui-mobile-nav',
						ref: function ref(el) {
							return _this2.el = el;
						}
					},
					this.props.children
				)
			);
		}
	}]);

	return MobileSelect;
}(_react.Component);

exports.default = MobileSelect;

/***/ }),
/* 668 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(13);

var _redux = __webpack_require__(11);

var _settings = __webpack_require__(185);

var settingsActions = _interopRequireWildcard(_settings);

var _modal = __webpack_require__(184);

var modalActions = _interopRequireWildcard(_modal);

var _builder = __webpack_require__(299);

var builderActions = _interopRequireWildcard(_builder);

var _builder2 = __webpack_require__(669);

var _builder3 = _interopRequireDefault(_builder2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function mapStateToProps(state) {
	return {
		answers: state.answers,
		settings: state.settings,
		submitData: state.settings.submitData || {},
		changed: window.forminatorChanges
	};
}

function mapDispatchToProps(dispatch) {
	return {
		actions: {
			settingsActions: (0, _redux.bindActionCreators)(settingsActions, dispatch),
			builderActions: (0, _redux.bindActionCreators)(builderActions, dispatch),
			modalActions: (0, _redux.bindActionCreators)(modalActions, dispatch)
		}
	};
}

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(_builder3.default);

/***/ }),
/* 669 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _details = __webpack_require__(670);

var _details2 = _interopRequireDefault(_details);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Builder = function (_Component) {
	_inherits(Builder, _Component);

	function Builder(props) {
		_classCallCheck(this, Builder);

		return _possibleConstructorReturn(this, (Builder.__proto__ || Object.getPrototypeOf(Builder)).call(this, props));
	}

	_createClass(Builder, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			jQuery('html, body').animate({
				scrollTop: 0
			}, 'fast');
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var goToSection = function goToSection(module) {
				_this2.props.history.push('/' + module);
			};

			return _react2.default.createElement(
				'div',
				{ id: 'forminator-form-fields', className: 'sui-box' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-header' },
					_react2.default.createElement(
						'h2',
						{ className: 'sui-box-title' },
						(0, _utils.translate)('Details')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-body' },
					_react2.default.createElement(_details2.default, this.props)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-footer' },
					_react2.default.createElement(
						'div',
						{ className: 'sui-actions-right' },
						_react2.default.createElement(
							'button',
							{
								className: 'sui-button sui-button-icon-right',
								onClick: function onClick() {
									return goToSection('appearance');
								}
							},
							(0, _utils.translate)('Appearance'),
							_react2.default.createElement('i', { className: 'sui-icon-arrow-right', 'aria-hidden': 'true' })
						)
					)
				)
			);
		}
	}]);

	return Builder;
}(_react.Component);

exports.default = Builder;

/***/ }),
/* 670 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _input = __webpack_require__(3);

var _input2 = _interopRequireDefault(_input);

var _uploads = __webpack_require__(67);

var _uploads2 = _interopRequireDefault(_uploads);

var _checkbox = __webpack_require__(41);

var _checkbox2 = _interopRequireDefault(_checkbox);

var _answers = __webpack_require__(671);

var _answers2 = _interopRequireDefault(_answers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Details = function (_Component) {
	_inherits(Details, _Component);

	function Details(props) {
		_classCallCheck(this, Details);

		return _possibleConstructorReturn(this, (Details.__proto__ || Object.getPrototypeOf(Details)).call(this, props));
	}

	_createClass(Details, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-row' },
					_react2.default.createElement(
						'div',
						{ className: 'sui-box-settings-col-1' },
						_react2.default.createElement(
							'span',
							{ className: 'sui-settings-label' },
							(0, _utils.translate)('Question')
						),
						_react2.default.createElement(
							'span',
							{ className: 'sui-description' },
							(0, _utils.translate)('Start by adding the question you will be asking ' + 'poll visitors to vote on.')
						)
					),
					_react2.default.createElement(
						'div',
						{ className: 'sui-box-settings-col-2' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('What is your main question?'),
							type: 'text',
							placeholder: (0, _utils.translate)('E.g. Why did the chicken cross the road?'),
							property: 'poll-question'
						})),
						_react2.default.createElement(_uploads2.default, _extends({}, this.props, {
							type: 'image',
							label: (0, _utils.translate)('Feature Image (optional)'),
							property: 'poll-image',
							imageSize: 'large',
							description: (0, _utils.translate)('This image will appear under your main question ' + 'and can be used to create polls based on an image.')
						})),
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Description (optional)'),
							type: 'text',
							placeholder: (0, _utils.translate)('Enter an optional description'),
							property: 'poll-description',
							description: (0, _utils.translate)('This will appear below the main question and ' + 'can be used to further explain the main question.')
						}))
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-row sui-flushed',
						style: { borderBottom: '0' } },
					_react2.default.createElement(
						'div',
						{ className: 'sui-box-settings-col-2' },
						_react2.default.createElement(
							'label',
							{ className: 'sui-settings-label sui-dark' },
							(0, _utils.translate)('Answers')
						),
						_react2.default.createElement(
							'span',
							{ className: 'sui-description' },
							(0, _utils.translate)('Now add answers to your question that your users will use ' + 'to vote with. Add as many as you like, just be careful to ' + 'make sure each one is unique!')
						),
						_react2.default.createElement(
							'div',
							{ className: 'switch-box' },
							_react2.default.createElement(_checkbox2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Enable Images'),
								property: 'enable_images',
								itemClass: 'sui-checkbox-sm '
							}))
						),
						_react2.default.createElement(_answers2.default, this.props)
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-row' },
					_react2.default.createElement(
						'div',
						{ className: 'sui-box-settings-col-1' },
						_react2.default.createElement(
							'span',
							{ className: 'sui-settings-label' },
							(0, _utils.translate)('Button')
						),
						_react2.default.createElement(
							'span',
							{ className: 'sui-description' },
							(0, _utils.translate)('Customize the button label used for ' + 'submitting the users answer.')
						)
					),
					_react2.default.createElement(
						'div',
						{ className: 'sui-box-settings-col-2' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Button Text'),
							type: 'text',
							placeholder: (0, _utils.translate)('E.g. Vote'),
							property: 'poll-button-label'
						}))
					)
				)
			);
		}
	}]);

	return Details;
}(_react.Component);

exports.default = Details;

/***/ }),
/* 671 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _answerRow = __webpack_require__(672);

var _answerRow2 = _interopRequireDefault(_answerRow);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Answers = function (_Component) {
	_inherits(Answers, _Component);

	function Answers(props) {
		_classCallCheck(this, Answers);

		var _this = _possibleConstructorReturn(this, (Answers.__proto__ || Object.getPrototypeOf(Answers)).call(this, props));

		_this.addAnswer = _this.addAnswer.bind(_this);
		return _this;
	}

	_createClass(Answers, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var self = this;

			this.$el = jQuery(this.el);

			this.moveOption = this.moveOption.bind(this);

			this.$el.find('.fui-answers').sortable({
				stop: function stop(e, ui) {
					var to = ui.item.index();
					self.$el.find('.fui-answers').sortable('cancel');
					var from = ui.item.index();

					self.moveOption(from, to);
				}
			});
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.$el.unbind().removeData();
		}
	}, {
		key: 'moveOption',
		value: function moveOption(from, to) {
			var newState = this.props.answers;

			newState.splice(to, 0, newState.splice(from, 1)[0]);

			this.props.actions.builderActions.updateAnswers(newState);

			this.forceUpdate();
		}
	}, {
		key: 'addAnswer',
		value: function addAnswer() {
			var answers = [].concat(_toConsumableArray(this.props.answers));

			var newAnswer = [{
				element_id: 'answer-' + (0, _utils.getMaxID)('answer', this.props.answers)
			}];

			var newState = [].concat(_toConsumableArray(answers), newAnswer);

			this.props.actions.builderActions.updateAnswers(newState);
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			return _react2.default.createElement(
				'div',
				{ className: 'fui-multi-answers', ref: function ref(el) {
						return _this2.el = el;
					} },
				_react2.default.createElement(
					'ul',
					{ className: 'fui-answers' },
					_.map(this.props.answers, function (answer, i) {
						return _react2.default.createElement(_answerRow2.default, _extends({ key: answer.element_id, answer: answer }, _this2.props, { counter: i }));
					})
				),
				_react2.default.createElement(
					'button',
					{ className: 'sui-button sui-button-dashed', onClick: this.addAnswer },
					_react2.default.createElement('i', { className: 'sui-icon-plus', 'aria-hidden': 'true' }),
					(0, _utils.translate)('Add Answer')
				),
				this.props.answers.length === 0 && _react2.default.createElement(
					'div',
					{ className: 'fui-empty-message' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)('A poll without answers isnt going to be very useful ' + 'Add your answers above!')
					)
				)
			);
		}
	}]);

	return Answers;
}(_react.Component);

exports.default = Answers;

/***/ }),
/* 672 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _uploads = __webpack_require__(67);

var _uploads2 = _interopRequireDefault(_uploads);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Answer = function (_Component) {
	_inherits(Answer, _Component);

	function Answer(props) {
		_classCallCheck(this, Answer);

		var _this = _possibleConstructorReturn(this, (Answer.__proto__ || Object.getPrototypeOf(Answer)).call(this, props));

		_this.trashField = _this.trashField.bind(_this);
		_this.deleteField = _this.deleteField.bind(_this);
		_this.closeDeleteField = _this.closeDeleteField.bind(_this);
		_this.updateImage = _this.updateImage.bind(_this);
		return _this;
	}

	_createClass(Answer, [{
		key: 'updateTitle',
		value: function updateTitle(e) {
			var answer = Object.assign({}, this.props.answer);
			answer.title = e.target.value;

			this.props.actions.builderActions.updateAnswer(answer);
		}
	}, {
		key: 'updateExtra',
		value: function updateExtra(e) {
			var answer = Object.assign({}, this.props.answer);
			answer.extra = e.target.value;

			this.props.actions.builderActions.updateAnswer(answer);
		}
	}, {
		key: 'addExtra',
		value: function addExtra() {
			var answer = Object.assign({}, this.props.answer);
			answer.use_extra = true;

			this.props.actions.builderActions.updateAnswer(answer);
		}
	}, {
		key: 'removeExtra',
		value: function removeExtra() {
			var answer = Object.assign({}, this.props.answer);
			answer.use_extra = false;
			answer.extra = '';

			this.props.actions.builderActions.updateAnswer(answer);
		}
	}, {
		key: 'getAnswersWithoutCurrent',
		value: function getAnswersWithoutCurrent(answers) {
			var _this2 = this;

			return answers.filter(function (field) {
				return field.element_id !== _this2.props.answer.element_id;
			});
		}
	}, {
		key: 'closeMenu',
		value: function closeMenu() {
			jQuery('.sui-dropdown').removeClass('open');
		}
	}, {
		key: 'deleteField',
		value: function deleteField() {
			// Hide field settings menu
			this.closeMenu();

			this.props.actions.modalActions.showModal({
				open: true,
				answer: this.props.answer,
				closeModal: this.closeDeleteField,
				trashField: this.trashField
			}, 'delete');
		}
	}, {
		key: 'closeDeleteField',
		value: function closeDeleteField() {
			this.props.actions.modalActions.showModal({
				open: false,
				answer: this.props.answer,
				closeModal: this.closeDeleteField,
				trashField: this.trashField
			}, 'delete');
		}
	}, {
		key: 'trashField',
		value: function trashField() {
			var answers = [].concat(_toConsumableArray(this.props.answers));

			var answersObj = this.getAnswersWithoutCurrent(answers);

			// Hide field settings menu
			this.closeMenu();

			// Update state
			this.props.actions.builderActions.updateAnswers(answersObj);
		}
	}, {
		key: 'updateImage',
		value: function updateImage(property, value) {
			this.props.answer[property] = value;
			this.props.actions.builderActions.updateAnswer(this.props.answer);
		}
	}, {
		key: 'render',
		value: function render() {
			var hasTitle = this.props.answer.title ? true : false;
			var validationClass = !hasTitle ? 'fui-error' : '';
			var enable_images = !_.isUndefined(this.props.settings.enable_images) ? this.props.settings.enable_images : false;

			return _react2.default.createElement(
				'li',
				{ 'data-index': this.props.counter, className: 'answer-row ' + validationClass },
				_react2.default.createElement(
					'span',
					{ className: 'fui-answer--move' },
					_react2.default.createElement('i', { className: 'sui-icon-drag', 'aria-hidden': 'true' })
				),
				_react2.default.createElement(
					'span',
					{ className: 'fui-answer--fields' },
					_react2.default.createElement(
						'div',
						{ className: 'sui-form-field' },
						_react2.default.createElement(
							'div',
							{ className: 'answer-title' },
							_react2.default.createElement('input', { className: 'sui-form-control', defaultValue: this.props.answer.title, onChange: this.updateTitle.bind(this), onTouchEnd: function onTouchEnd(e) {
									e.target.focus();
								} })
						),
						enable_images && _react2.default.createElement(
							'div',
							{ className: 'answer-image' },
							_react2.default.createElement(_uploads2.default, _extends({}, this.props, {
								settings: this.props.answer,
								type: 'image',
								fieldClass: 'sui-auto',
								property: 'answer_image',
								updateProperty: this.updateImage.bind(this)
							}))
						)
					),
					this.props.answer.use_extra === true && _react2.default.createElement(
						'div',
						{ className: 'sui-form-field' },
						_react2.default.createElement('input', { className: 'sui-form-control', placeholder: (0, _utils.translate)('Enter Placeholder'), defaultValue: this.props.answer.extra, onChange: this.updateExtra.bind(this), onTouchEnd: function onTouchEnd(e) {
								e.target.focus();
							} })
					)
				),
				_react2.default.createElement(
					'span',
					{ className: 'fui-answer--actions' },
					_react2.default.createElement(
						'button',
						{ onClick: this.deleteField,
							className: 'sui-button-icon sui-button-red sui-tooltip',
							'data-tooltip': (0, _utils.translate)('Delete') },
						_react2.default.createElement('i', { className: 'sui-icon-trash', 'aria-hidden': 'true' }),
						_react2.default.createElement(
							'span',
							{ className: 'sui-screen-reader-text' },
							(0, _utils.translate)('Delete answer')
						)
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-dropdown' },
						_react2.default.createElement(
							'button',
							{ className: 'sui-button-icon sui-dropdown-anchor' },
							_react2.default.createElement('i', { className: 'sui-icon-widget-settings-config',
								'aria-hidden': 'true' }),
							_react2.default.createElement(
								'span',
								{ className: 'sui-screen-reader-text' },
								(0, _utils.translate)('Answer options')
							)
						),
						_react2.default.createElement(
							'ul',
							null,
							this.props.answer.use_extra !== true && _react2.default.createElement(
								'li',
								null,
								_react2.default.createElement(
									'button',
									{ onClick: this.addExtra.bind(this) },
									(0, _utils.translate)('Enable custom input')
								)
							),
							this.props.answer.use_extra === true && _react2.default.createElement(
								'li',
								null,
								_react2.default.createElement(
									'button',
									{ onClick: this.removeExtra.bind(this) },
									(0, _utils.translate)('Remove custom input')
								)
							)
						)
					)
				)
			);
		}
	}]);

	return Answer;
}(_react.Component);

exports.default = Answer;

/***/ }),
/* 673 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(13);

var _redux = __webpack_require__(11);

var _settings = __webpack_require__(185);

var settingsActions = _interopRequireWildcard(_settings);

var _builder = __webpack_require__(299);

var builderActions = _interopRequireWildcard(_builder);

var _modal = __webpack_require__(184);

var modalActions = _interopRequireWildcard(_modal);

var _appearance = __webpack_require__(674);

var _appearance2 = _interopRequireDefault(_appearance);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function mapStateToProps(state) {
	return {
		answers: state.answers,
		settings: state.settings
	};
}

function mapDispatchToProps(dispatch) {
	return {
		actions: {
			settingsActions: (0, _redux.bindActionCreators)(settingsActions, dispatch),
			builderActions: (0, _redux.bindActionCreators)(builderActions, dispatch),
			modalActions: (0, _redux.bindActionCreators)(modalActions, dispatch)
		}
	};
}

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(_appearance2.default);

/***/ }),
/* 674 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _axios = __webpack_require__(39);

var _axios2 = _interopRequireDefault(_axios);

var _qs = __webpack_require__(40);

var _qs2 = _interopRequireDefault(_qs);

var _designStyle = __webpack_require__(675);

var _designStyle2 = _interopRequireDefault(_designStyle);

var _colors = __webpack_require__(682);

var _colors2 = _interopRequireDefault(_colors);

var _optionsLayout = __webpack_require__(694);

var _optionsLayout2 = _interopRequireDefault(_optionsLayout);

var _container = __webpack_require__(696);

var _container2 = _interopRequireDefault(_container);

var _customCss = __webpack_require__(700);

var _customCss2 = _interopRequireDefault(_customCss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Appearance = function (_Component) {
	_inherits(Appearance, _Component);

	function Appearance(props) {
		_classCallCheck(this, Appearance);

		return _possibleConstructorReturn(this, (Appearance.__proto__ || Object.getPrototypeOf(Appearance)).call(this, props));
	}

	_createClass(Appearance, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			jQuery('html, body').animate({
				scrollTop: 0
			}, 'fast');
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var goToSection = function goToSection(module) {
				_this2.props.history.push('/' + module);
			};
			var enableImages = !_.isUndefined(this.props.settings.enable_images) ? this.props.settings.enable_images : false;

			return _react2.default.createElement(
				'div',
				{ id: 'forminator-form-appearance',
					className: 'sui-box' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-header' },
					_react2.default.createElement(
						'h2',
						{ className: 'sui-box-title' },
						(0, _utils.translate)('Appearance')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-body', key: (0, _utils.getThemePrefix)(this.props) + 'themeKey' },
					_react2.default.createElement(_designStyle2.default, this.props),
					_react2.default.createElement(_colors2.default, this.props),
					enableImages && _react2.default.createElement(_optionsLayout2.default, this.props),
					_react2.default.createElement(_container2.default, this.props),
					_react2.default.createElement(_customCss2.default, this.props)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-footer' },
					_react2.default.createElement(
						'button',
						{ className: 'sui-button',
							onClick: function onClick() {
								return goToSection('');
							}
						},
						_react2.default.createElement('i', { className: 'sui-icon-arrow-left', 'aria-hidden': 'true' }),
						(0, _utils.translate)('Details')
					),
					_react2.default.createElement(
						'div',
						{ className: 'sui-actions-right' },
						_react2.default.createElement(
							'button',
							{ className: 'sui-button sui-button-icon-right',
								onClick: function onClick() {
									return goToSection('behaviour');
								}
							},
							(0, _utils.translate)('Behavior'),
							_react2.default.createElement('i', { className: 'sui-icon-arrow-right', 'aria-hidden': 'true' })
						)
					)
				)
			);
		}
	}]);

	return Appearance;
}(_react.Component);

exports.default = Appearance;

/***/ }),
/* 675 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _radioTabs = __webpack_require__(7);

var _radioTabs2 = _interopRequireDefault(_radioTabs);

var _default = __webpack_require__(676);

var _default2 = _interopRequireDefault(_default);

var _flat = __webpack_require__(677);

var _flat2 = _interopRequireDefault(_flat);

var _bold = __webpack_require__(678);

var _bold2 = _interopRequireDefault(_bold);

var _material = __webpack_require__(679);

var _material2 = _interopRequireDefault(_material);

var _basic = __webpack_require__(680);

var _basic2 = _interopRequireDefault(_basic);

var _none = __webpack_require__(681);

var _none2 = _interopRequireDefault(_none);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DesignStyle = function (_Component) {
	_inherits(DesignStyle, _Component);

	function DesignStyle(props) {
		_classCallCheck(this, DesignStyle);

		return _possibleConstructorReturn(this, (DesignStyle.__proto__ || Object.getPrototypeOf(DesignStyle)).call(this, props));
	}

	_createClass(DesignStyle, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Design Style')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)('Choose a pre-made style for your poll and ' + "further customize it's appearance below.")
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(
						_radioTabs2.default,
						_extends({}, this.props, {
							property: 'forminator-poll-design',
							'default': 'default'
						}),
						_react2.default.createElement(
							_default2.default,
							{
								value: 'default',
								boxClass: 'sui-tab-content sui-tab-boxed'
							},
							(0, _utils.translate)('Default')
						),
						_react2.default.createElement(
							_flat2.default,
							{
								value: 'flat',
								boxClass: 'sui-tab-content sui-tab-boxed'
							},
							(0, _utils.translate)('Flat')
						),
						_react2.default.createElement(
							_bold2.default,
							{
								value: 'bold',
								boxClass: 'sui-tab-content sui-tab-boxed'
							},
							(0, _utils.translate)('Bold')
						),
						_react2.default.createElement(
							_material2.default,
							{
								value: 'material',
								boxClass: 'sui-tab-content sui-tab-boxed'
							},
							(0, _utils.translate)('Material')
						),
						_react2.default.createElement(
							_none2.default,
							{
								value: 'none',
								boxClass: 'sui-tab-content'
							},
							(0, _utils.translate)('None')
						)
					)
				)
			);
		}
	}]);

	return DesignStyle;
}(_react.Component);

exports.default = DesignStyle;

/***/ }),
/* 676 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DesignDefault = function (_Component) {
	_inherits(DesignDefault, _Component);

	function DesignDefault() {
		_classCallCheck(this, DesignDefault);

		return _possibleConstructorReturn(this, (DesignDefault.__proto__ || Object.getPrototypeOf(DesignDefault)).apply(this, arguments));
	}

	_createClass(DesignDefault, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'fui-demo fui-demo--poll fui-demo--default' },
				_react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-poll-preview--default-default' },
					_react2.default.createElement('input', {
						type: 'radio',
						id: 'forminator-poll-preview--default-default'
					}),
					_react2.default.createElement('span', { 'aria-hidden': 'true' }),
					(0, _utils.translate)('Default')
				),
				_react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-poll-preview--default-checked' },
					_react2.default.createElement('input', {
						type: 'radio',
						id: 'forminator-poll-preview--default-checked',
						checked: true
					}),
					_react2.default.createElement('span', { 'aria-hidden': 'true' }),
					(0, _utils.translate)('Checked')
				),
				_react2.default.createElement(
					'button',
					null,
					(0, _utils.translate)('Button')
				)
			);
		}
	}]);

	return DesignDefault;
}(_react.Component);

exports.default = DesignDefault;

/***/ }),
/* 677 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DesignFlat = function (_Component) {
	_inherits(DesignFlat, _Component);

	function DesignFlat() {
		_classCallCheck(this, DesignFlat);

		return _possibleConstructorReturn(this, (DesignFlat.__proto__ || Object.getPrototypeOf(DesignFlat)).apply(this, arguments));
	}

	_createClass(DesignFlat, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'fui-demo fui-demo--poll fui-demo--flat' },
				_react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-poll-preview--flat-default' },
					_react2.default.createElement('input', {
						type: 'radio',
						id: 'forminator-poll-preview--flat-default'
					}),
					_react2.default.createElement('span', { 'aria-hidden': 'true' }),
					(0, _utils.translate)('Default')
				),
				_react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-poll-preview--flat-checked' },
					_react2.default.createElement('input', {
						type: 'radio',
						id: 'forminator-poll-preview--flat-checked',
						checked: true
					}),
					_react2.default.createElement('span', { 'aria-hidden': 'true' }),
					(0, _utils.translate)('Checked')
				),
				_react2.default.createElement(
					'button',
					null,
					(0, _utils.translate)('Button')
				)
			);
		}
	}]);

	return DesignFlat;
}(_react.Component);

exports.default = DesignFlat;

/***/ }),
/* 678 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DesignBold = function (_Component) {
	_inherits(DesignBold, _Component);

	function DesignBold() {
		_classCallCheck(this, DesignBold);

		return _possibleConstructorReturn(this, (DesignBold.__proto__ || Object.getPrototypeOf(DesignBold)).apply(this, arguments));
	}

	_createClass(DesignBold, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'fui-demo fui-demo--poll fui-demo--bold' },
				_react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-poll-preview--bold-default' },
					_react2.default.createElement('input', {
						type: 'radio',
						id: 'forminator-poll-preview--bold-default'
					}),
					_react2.default.createElement('span', { 'aria-hidden': 'true' }),
					(0, _utils.translate)('Default')
				),
				_react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-poll-preview--bold-checked' },
					_react2.default.createElement('input', {
						type: 'radio',
						id: 'forminator-poll-preview--bold-checked',
						checked: true
					}),
					_react2.default.createElement('span', { 'aria-hidden': 'true' }),
					(0, _utils.translate)('Checked')
				),
				_react2.default.createElement(
					'button',
					null,
					(0, _utils.translate)('Button')
				)
			);
		}
	}]);

	return DesignBold;
}(_react.Component);

exports.default = DesignBold;

/***/ }),
/* 679 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DesignMaterial = function (_Component) {
	_inherits(DesignMaterial, _Component);

	function DesignMaterial() {
		_classCallCheck(this, DesignMaterial);

		return _possibleConstructorReturn(this, (DesignMaterial.__proto__ || Object.getPrototypeOf(DesignMaterial)).apply(this, arguments));
	}

	_createClass(DesignMaterial, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'fui-demo fui-demo--poll fui-demo--material' },
				_react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-poll-preview--material-default' },
					_react2.default.createElement('input', {
						type: 'radio',
						id: 'forminator-poll-preview--material-default'
					}),
					_react2.default.createElement('span', { 'aria-hidden': 'true' }),
					(0, _utils.translate)('Default')
				),
				_react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-poll-preview--material-checked' },
					_react2.default.createElement('input', {
						type: 'radio',
						id: 'forminator-poll-preview--material-checked',
						checked: true
					}),
					_react2.default.createElement('span', { 'aria-hidden': 'true' }),
					(0, _utils.translate)('Checked')
				),
				_react2.default.createElement(
					'button',
					null,
					(0, _utils.translate)('Button')
				)
			);
		}
	}]);

	return DesignMaterial;
}(_react.Component);

exports.default = DesignMaterial;

/***/ }),
/* 680 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DesignBasic = function (_Component) {
	_inherits(DesignBasic, _Component);

	function DesignBasic() {
		_classCallCheck(this, DesignBasic);

		return _possibleConstructorReturn(this, (DesignBasic.__proto__ || Object.getPrototypeOf(DesignBasic)).apply(this, arguments));
	}

	_createClass(DesignBasic, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'fui-demo fui-demo--poll fui-demo--basic' },
				_react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-poll-preview--basic-default' },
					_react2.default.createElement('input', {
						type: 'radio',
						id: 'forminator-poll-preview--basic-default'
					}),
					_react2.default.createElement('span', { 'aria-hidden': 'true' }),
					(0, _utils.translate)('Default')
				),
				_react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-poll-preview--basic-checked' },
					_react2.default.createElement('input', {
						type: 'radio',
						id: 'forminator-poll-preview--basic-checked',
						checked: true
					}),
					_react2.default.createElement('span', { 'aria-hidden': 'true' }),
					(0, _utils.translate)('Checked')
				),
				_react2.default.createElement(
					'button',
					null,
					(0, _utils.translate)('Button')
				)
			);
		}
	}]);

	return DesignBasic;
}(_react.Component);

exports.default = DesignBasic;

/***/ }),
/* 681 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DesignNone = function (_Component) {
	_inherits(DesignNone, _Component);

	function DesignNone() {
		_classCallCheck(this, DesignNone);

		return _possibleConstructorReturn(this, (DesignNone.__proto__ || Object.getPrototypeOf(DesignNone)).apply(this, arguments));
	}

	_createClass(DesignNone, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'sui-notice sui-active', style: { display: 'block' } },
				_react2.default.createElement(
					'div',
					{ className: 'sui-notice-content' },
					_react2.default.createElement(
						'div',
						{ className: 'sui-notice-message' },
						_react2.default.createElement(
							'p',
							null,
							(0, _utils.translate)('You have opted for no stylesheet to be enqueued. ' + "The form will inherit styles from your theme's CSS.")
						)
					)
				)
			);
		}
	}]);

	return DesignNone;
}(_react.Component);

exports.default = DesignNone;

/***/ }),
/* 682 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _radioTabs = __webpack_require__(7);

var _radioTabs2 = _interopRequireDefault(_radioTabs);

var _empty = __webpack_require__(12);

var _empty2 = _interopRequireDefault(_empty);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _accordion = __webpack_require__(35);

var _accordion2 = _interopRequireDefault(_accordion);

var _container3 = __webpack_require__(683);

var _container4 = _interopRequireDefault(_container3);

var _responseSuccess = __webpack_require__(684);

var _responseSuccess2 = _interopRequireDefault(_responseSuccess);

var _responseError = __webpack_require__(685);

var _responseError2 = _interopRequireDefault(_responseError);

var _content = __webpack_require__(686);

var _content2 = _interopRequireDefault(_content);

var _options = __webpack_require__(687);

var _options2 = _interopRequireDefault(_options);

var _images = __webpack_require__(688);

var _images2 = _interopRequireDefault(_images);

var _input = __webpack_require__(689);

var _input2 = _interopRequireDefault(_input);

var _submit = __webpack_require__(690);

var _submit2 = _interopRequireDefault(_submit);

var _links = __webpack_require__(691);

var _links2 = _interopRequireDefault(_links);

var _chart = __webpack_require__(692);

var _chart2 = _interopRequireDefault(_chart);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Colors = function (_Component) {
	_inherits(Colors, _Component);

	function Colors(props) {
		_classCallCheck(this, Colors);

		return _possibleConstructorReturn(this, (Colors.__proto__ || Object.getPrototypeOf(Colors)).call(this, props));
	}

	_createClass(Colors, [{
		key: 'render',
		value: function render() {
			var enableImages = !_.isUndefined(this.props.settings.enable_images) ? this.props.settings.enable_images : false;

			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Colors')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)('Adjust the default color combinations to match your theme styling.')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(
						_radioTabs2.default,
						_extends({}, this.props, {
							property: 'poll-colors',
							'default': ''
						}),
						_react2.default.createElement(
							_empty2.default,
							{ value: '' },
							(0, _utils.translate)('Use default colors')
						),
						_react2.default.createElement(
							_container2.default,
							{
								value: 'true',
								label: (0, _utils.translate)('Custom')
							},
							_react2.default.createElement(
								'div',
								{ className: 'sui-accordion' },
								_react2.default.createElement(
									'div',
									{ className: 'sui-accordion-header' },
									_react2.default.createElement(
										'div',
										null,
										(0, _utils.translate)('Element')
									)
								),
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Poll Container')
									}),
									_react2.default.createElement(_container4.default, this.props)
								),
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Poll Basics')
									}),
									_react2.default.createElement(_content2.default, this.props)
								),
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: enableImages ? (0, _utils.translate)('Answers - Radio Option') : (0, _utils.translate)('Radio Options')
									}),
									_react2.default.createElement(_options2.default, this.props)
								),
								enableImages && _react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Answers - Radio Image')
									}),
									_react2.default.createElement(_images2.default, this.props)
								),
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Custom Answer Input')
									}),
									_react2.default.createElement(_input2.default, this.props)
								),
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Submit Button')
									}),
									_react2.default.createElement(_submit2.default, this.props)
								),
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('View Results Link')
									}),
									_react2.default.createElement(_links2.default, this.props)
								),
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Response Success')
									}),
									_react2.default.createElement(_responseSuccess2.default, this.props)
								),
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Response Error')
									}),
									_react2.default.createElement(_responseError2.default, this.props)
								),
								'none' !== (0, _utils.getChartType)(this.props.settings) && _react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Results Chart')
									}),
									_react2.default.createElement(_chart2.default, this.props)
								)
							)
						)
					)
				)
			);
		}
	}]);

	return Colors;
}(_react.Component);

exports.default = Colors;

/***/ }),
/* 683 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ContainerColors = function (_Component) {
	_inherits(ContainerColors, _Component);

	function ContainerColors(props) {
		_classCallCheck(this, ContainerColors);

		return _possibleConstructorReturn(this, (ContainerColors.__proto__ || Object.getPrototypeOf(ContainerColors)).call(this, props));
	}

	_createClass(ContainerColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('Border color'),
					property: (0, _utils.getThemePrefix)(this.props) + 'box_border',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#00000000"),
					isAlpha: true
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('Background color'),
					property: (0, _utils.getThemePrefix)(this.props) + 'box_background',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#ffffff00"),
					isAlpha: true
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('Box shadow'),
					property: (0, _utils.getThemePrefix)(this.props) + 'box_shadow',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#e6e6e600"),
					isAlpha: true
				}))
			);
		}
	}]);

	return ContainerColors;
}(_react.Component);

exports.default = ContainerColors;

/***/ }),
/* 684 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SuccessColors = function (_Component) {
	_inherits(SuccessColors, _Component);

	function SuccessColors(props) {
		_classCallCheck(this, SuccessColors);

		return _possibleConstructorReturn(this, (SuccessColors.__proto__ || Object.getPrototypeOf(SuccessColors)).call(this, props));
	}

	_createClass(SuccessColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'p',
					{ className: 'sui-description' },
					(0, _utils.translate)('Successful response message will be displayed after poll submission succeeds.')
				),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('Border color'),
					property: (0, _utils.getThemePrefix)(this.props) + 'success_border',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#1ABCA1")
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('Background color'),
					property: (0, _utils.getThemePrefix)(this.props) + 'success_background',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#BCEEE6")
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('Text color'),
					property: (0, _utils.getThemePrefix)(this.props) + 'success_text',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#333333")
				}))
			);
		}
	}]);

	return SuccessColors;
}(_react.Component);

exports.default = SuccessColors;

/***/ }),
/* 685 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ErrorColors = function (_Component) {
	_inherits(ErrorColors, _Component);

	function ErrorColors(props) {
		_classCallCheck(this, ErrorColors);

		return _possibleConstructorReturn(this, (ErrorColors.__proto__ || Object.getPrototypeOf(ErrorColors)).call(this, props));
	}

	_createClass(ErrorColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'p',
					{ className: 'sui-description' },
					(0, _utils.translate)('Error response message will be displayed after poll vote submission fails.')
				),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('Border color'),
					property: (0, _utils.getThemePrefix)(this.props) + 'error_border',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E04562")
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('Background color'),
					property: (0, _utils.getThemePrefix)(this.props) + 'error_background',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#F9E4E8")
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('Text color'),
					property: (0, _utils.getThemePrefix)(this.props) + 'error_text',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#333333")
				}))
			);
		}
	}]);

	return ErrorColors;
}(_react.Component);

exports.default = ErrorColors;

/***/ }),
/* 686 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ContentColors = function (_Component) {
	_inherits(ContentColors, _Component);

	function ContentColors(props) {
		_classCallCheck(this, ContentColors);

		return _possibleConstructorReturn(this, (ContentColors.__proto__ || Object.getPrototypeOf(ContentColors)).call(this, props));
	}

	_createClass(ContentColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('Question color'),
					property: (0, _utils.getThemePrefix)(this.props) + 'poll_question',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#333333")
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('Description color'),
					property: (0, _utils.getThemePrefix)(this.props) + 'poll_description',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771")
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('"No votes yet" text color'),
					property: (0, _utils.getThemePrefix)(this.props) + 'novotes_text',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#333333"),
					description: (0, _utils.translate)('Users see this text next to submit button when ' + '"link on poll" submission is enabled.')
				}))
			);
		}
	}]);

	return ContentColors;
}(_react.Component);

exports.default = ContentColors;

/***/ }),
/* 687 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ContentColors = function (_Component) {
	_inherits(ContentColors, _Component);

	function ContentColors(props) {
		_classCallCheck(this, ContentColors);

		return _possibleConstructorReturn(this, (ContentColors.__proto__ || Object.getPrototypeOf(ContentColors)).call(this, props));
	}

	_createClass(ContentColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					type: 'tabs',
					'default': 'default',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						value: 'default',
						label: (0, _utils.translate)('Default')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'inputbo',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(119,119,113,1)"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background'),
						property: (0, _utils.getThemePrefix)(this.props) + 'inputbg',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(237,237,237,1)"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'poll_answers',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'checked',
						label: (0, _utils.translate)('Checked')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'inputbo_active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(23,168,227,1)"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background'),
						property: (0, _utils.getThemePrefix)(this.props) + 'inputbg_active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(237,237,237,1)"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Icon color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'radio_dot',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(23,168,227,1)"),
						isAlpha: true
					}))
				)
			);
		}
	}]);

	return ContentColors;
}(_react.Component);

exports.default = ContentColors;

/***/ }),
/* 688 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RadioImagesColors = function (_Component) {
	_inherits(RadioImagesColors, _Component);

	function RadioImagesColors(props) {
		_classCallCheck(this, RadioImagesColors);

		return _possibleConstructorReturn(this, (RadioImagesColors.__proto__ || Object.getPrototypeOf(RadioImagesColors)).call(this, props));
	}

	_createClass(RadioImagesColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					type: 'tabs',
					'default': 'default',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						value: 'default',
						label: (0, _utils.translate)('Default')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'image-border-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background'),
						property: (0, _utils.getThemePrefix)(this.props) + 'image-background-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#ededed"),
						isAlpha: true
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'hover',
						label: (0, _utils.translate)('Hover')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'image-border-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17a8e3"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background'),
						property: (0, _utils.getThemePrefix)(this.props) + 'image-background-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#e1f6ff"),
						isAlpha: true
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'checked',
						label: (0, _utils.translate)('Checked')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'image-border-checked',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17a8e3"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background'),
						property: (0, _utils.getThemePrefix)(this.props) + 'image-background-checked',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#e1f6ff"),
						isAlpha: true
					}))
				)
			);
		}
	}]);

	return RadioImagesColors;
}(_react.Component);

exports.default = RadioImagesColors;

/***/ }),
/* 689 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputColors = function (_Component) {
	_inherits(InputColors, _Component);

	function InputColors(props) {
		_classCallCheck(this, InputColors);

		return _possibleConstructorReturn(this, (InputColors.__proto__ || Object.getPrototypeOf(InputColors)).call(this, props));
	}

	_createClass(InputColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					type: 'tabs',
					'default': 'default',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						value: 'default',
						label: (0, _utils.translate)('Default')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'forminator-poll-input-border_static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(119,119,113,1)"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'forminator-poll-input-background_static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(237,237,237,1)"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Placeholder'),
						property: (0, _utils.getThemePrefix)(this.props) + 'input_placeholder',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#888888")
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'input_text',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'hover',
						label: (0, _utils.translate)('Hover')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'forminator-poll-input-border_hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(23,168,227,1)"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'forminator-poll-input-background_hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(230,230,230,1)"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'input_text_hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'focus',
						label: (0, _utils.translate)('Focus')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'forminator-poll-input-border_active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(23,168,227,1)"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'forminator-poll-input-background_active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(230,230,230,1)"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'input_text_active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000")
					}))
				)
			);
		}
	}]);

	return InputColors;
}(_react.Component);

exports.default = InputColors;

/***/ }),
/* 690 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SubmitColors = function (_Component) {
	_inherits(SubmitColors, _Component);

	function SubmitColors(props) {
		_classCallCheck(this, SubmitColors);

		return _possibleConstructorReturn(this, (SubmitColors.__proto__ || Object.getPrototypeOf(SubmitColors)).call(this, props));
	}

	_createClass(SubmitColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					type: 'tabs',
					'default': 'default',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						value: 'default',
						label: (0, _utils.translate)('Default')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'buttonbg',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(23,168,227,1)"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'buttontxt',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(255,255,255,1)"),
						isAlpha: true
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'hover',
						label: (0, _utils.translate)('Hover')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'buttonbg_hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(0,143,202,1)"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'buttontxt_hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(255,255,255,1)"),
						isAlpha: true
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'active',
						label: (0, _utils.translate)('Active')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'buttonbg_active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(0,143,202,1)"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'buttontxt_active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(255,255,255,1)"),
						isAlpha: true
					}))
				)
			);
		}
	}]);

	return SubmitColors;
}(_react.Component);

exports.default = SubmitColors;

/***/ }),
/* 691 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LinksColors = function (_Component) {
	_inherits(LinksColors, _Component);

	function LinksColors(props) {
		_classCallCheck(this, LinksColors);

		return _possibleConstructorReturn(this, (LinksColors.__proto__ || Object.getPrototypeOf(LinksColors)).call(this, props));
	}

	_createClass(LinksColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					type: 'tabs',
					'default': 'default',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						value: 'default',
						label: (0, _utils.translate)('Default')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Link color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'color_link',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(23,168,227, 1)"),
						isAlpha: true
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'hover',
						label: (0, _utils.translate)('Hover')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Link color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'color_link_hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(0,143,202, 1)"),
						isAlpha: true
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'active',
						label: (0, _utils.translate)('Active')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Link color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'color_link_active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(0,143,202, 1)"),
						isAlpha: true
					}))
				)
			);
		}
	}]);

	return LinksColors;
}(_react.Component);

exports.default = LinksColors;

/***/ }),
/* 692 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _answerColor = __webpack_require__(693);

var _answerColor2 = _interopRequireDefault(_answerColor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ChartColors = function (_Component) {
	_inherits(ChartColors, _Component);

	function ChartColors(props) {
		_classCallCheck(this, ChartColors);

		return _possibleConstructorReturn(this, (ChartColors.__proto__ || Object.getPrototypeOf(ChartColors)).call(this, props));
	}

	_createClass(ChartColors, [{
		key: 'render',
		value: function render() {
			var _this2 = this;

			return _react2.default.createElement(
				_tabs2.default,
				{
					type: 'tabs',
					'default': 'basics',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						value: 'basics',
						label: (0, _utils.translate)('Basics')
					},
					'bar' === (0, _utils.getChartType)(this.props.settings) && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Chart grid lines'),
						property: (0, _utils.getThemePrefix)(this.props) + 'grid_lines',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E5E5E5")
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: 'pie' === (0, _utils.getChartType)(this.props.settings) ? (0, _utils.translate)('Legend text color') : (0, _utils.translate)('Chart labels color'),
						description: 'pie' === (0, _utils.getChartType)(this.props.settings) ? (0, _utils.translate)('Legends are always displayed on top of the chart.') : '',
						property: (0, _utils.getThemePrefix)(this.props) + 'grid_labels',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771")
					})),
					'bar' === (0, _utils.getChartType)(this.props.settings) && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Votes count'),
						property: (0, _utils.getThemePrefix)(this.props) + 'onbar_votes',
						description: (0, _utils.translate)('Text displayed inside bars.'),
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#333333"),
						isAlpha: true
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'tooltips',
						label: (0, _utils.translate)('Tooltips')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'tooltips_background',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#333333"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'tooltips_text',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'votes',
						label: (0, _utils.translate)('Answers')
					},
					_react2.default.createElement(
						'p',
						{ className: 'sui-description' },
						(0, _utils.translate)('Choose the graph colors for each poll answers below.')
					),
					_.map(this.props.answers, function (answer, i) {
						return _react2.default.createElement(_answerColor2.default, _extends({}, _this2.props, {
							key: answer.element_id,
							answer: answer,
							counter: i
						}));
					})
				)
			);
		}
	}]);

	return ChartColors;
}(_react.Component);

exports.default = ChartColors;

/***/ }),
/* 693 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AnswerColor = function (_Component) {
	_inherits(AnswerColor, _Component);

	function AnswerColor(props) {
		_classCallCheck(this, AnswerColor);

		var _this = _possibleConstructorReturn(this, (AnswerColor.__proto__ || Object.getPrototypeOf(AnswerColor)).call(this, props));

		_this.updateProperty = _this.updateProperty.bind(_this);
		return _this;
	}

	_createClass(AnswerColor, [{
		key: 'updateProperty',
		value: function updateProperty(prop, value) {
			var answer = Object.assign({}, this.props.answer);
			answer.color = value;

			this.props.actions.builderActions.updateAnswer(answer);
		}
	}, {
		key: 'render',
		value: function render() {
			var defaultColor = forminatorData.pollAnswerColors[this.props.counter] || '#E5E5E5';

			return _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
				label: this.props.answer.title,
				property: (0, _utils.getThemePrefix)(this.props) + 'color',
				defaultValue: defaultColor,
				settings: this.props.answer,
				updateProperty: this.updateProperty,
				isAlpha: true
			}));
		}
	}]);

	return AnswerColor;
}(_react.Component);

exports.default = AnswerColor;

/***/ }),
/* 694 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _settingsRow = __webpack_require__(16);

var _settingsRow2 = _interopRequireDefault(_settingsRow);

var _radioTabs = __webpack_require__(7);

var _radioTabs2 = _interopRequireDefault(_radioTabs);

var _radioOptions = __webpack_require__(114);

var _radioOptions2 = _interopRequireDefault(_radioOptions);

var _suiSelect = __webpack_require__(20);

var _suiSelect2 = _interopRequireDefault(_suiSelect);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _empty = __webpack_require__(12);

var _empty2 = _interopRequireDefault(_empty);

var _fieldImageSize = __webpack_require__(695);

var _fieldImageSize2 = _interopRequireDefault(_fieldImageSize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var OptionsLayout = function (_Component) {
	_inherits(OptionsLayout, _Component);

	function OptionsLayout() {
		_classCallCheck(this, OptionsLayout);

		return _possibleConstructorReturn(this, (OptionsLayout.__proto__ || Object.getPrototypeOf(OptionsLayout)).apply(this, arguments));
	}

	_createClass(OptionsLayout, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_settingsRow2.default,
				{
					label: (0, _utils.translate)('Layout'),
					description: (0, _utils.translate)('Adjust the answers layout and overall poll alignment.')
				},
				_react2.default.createElement(
					_radioTabs2.default,
					_extends({}, this.props, {
						property: 'field-image-size',
						'default': 'custom',
						settingsLabel: (0, _utils.translate)('Radio/Checkbox Image Size'),
						description: (0, _utils.translate)('Set radio/checkbox image size.')
					}),
					_react2.default.createElement(
						_empty2.default,
						{ value: 'auto' },
						(0, _utils.translate)('Automatic')
					),
					_react2.default.createElement(
						_fieldImageSize2.default,
						_extends({}, this.props, {
							value: 'custom',
							boxClass: 'sui-tab-boxed' }),
						(0, _utils.translate)('Custom')
					)
				),
				_react2.default.createElement(
					_radioOptions2.default,
					_extends({}, this.props, {
						property: 'visual_style',
						defaultValue: 'list',
						settingsLabel: (0, _utils.translate)('Answers'),
						settingsDesc: (0, _utils.translate)('Choose whether the poll answers should appear in a list or a grid.'),
						radioClass: 'sui-radio-sm',
						radioContent: 'true'
					}),
					_react2.default.createElement(_empty2.default, {
						value: 'list',
						hasImage: true,
						image1x: 'quiz-list.png',
						image2x: 'quiz-list@2x.png',
						label: (0, _utils.translate)('List')
					}),
					_react2.default.createElement(
						_container2.default,
						{
							value: 'grid',
							hasImage: true,
							image1x: 'quiz-grid.png',
							image2x: 'quiz-grid@2x.png',
							label: (0, _utils.translate)('Grid')
						},
						_react2.default.createElement(
							'p',
							{
								className: 'sui-description',
								style: { marginBottom: '20px' }
							},
							(0, _utils.translate)('Choose the number of columns to fit in one row. ' + 'Note that grid layout changes to two columns on ' + "smaller screens so this won't affect the smaller " + 'screens.')
						),
						_react2.default.createElement(
							_suiSelect2.default,
							_extends({}, this.props, {
								property: 'poll-grid-cols',
								defaultValue: '3',
								label: (0, _utils.translate)('Columns per row'),
								fieldsize: '100'
							}),
							_react2.default.createElement(
								'option',
								{ value: '2' },
								'2'
							),
							_react2.default.createElement(
								'option',
								{ value: '3' },
								'3'
							),
							_react2.default.createElement(
								'option',
								{ value: '4' },
								'4'
							),
							_react2.default.createElement(
								'option',
								{ value: '5' },
								'5'
							),
							_react2.default.createElement(
								'option',
								{ value: '6' },
								'6'
							)
						)
					)
				),
				_react2.default.createElement(
					_radioTabs2.default,
					_extends({}, this.props, {
						property: 'input_visibility',
						'default': 'true',
						settingsLabel: (0, _utils.translate)('Answer Type'),
						description: (0, _utils.translate)('Choose how your poll answers should be displayed on the frontend.')
					}),
					_react2.default.createElement(
						_empty2.default,
						{ value: 'true' },
						(0, _utils.translate)('Image and Radio Button')
					),
					_react2.default.createElement(
						_empty2.default,
						{ value: 'false' },
						(0, _utils.translate)('Image only')
					)
				)
			);
		}
	}]);

	return OptionsLayout;
}(_react.Component);

exports.default = OptionsLayout;

/***/ }),
/* 695 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _col = __webpack_require__(5);

var _col2 = _interopRequireDefault(_col);

var _input = __webpack_require__(3);

var _input2 = _interopRequireDefault(_input);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FieldImageSize = function (_Component) {
	_inherits(FieldImageSize, _Component);

	function FieldImageSize(props) {
		_classCallCheck(this, FieldImageSize);

		return _possibleConstructorReturn(this, (FieldImageSize.__proto__ || Object.getPrototypeOf(FieldImageSize)).call(this, props));
	}

	_createClass(FieldImageSize, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'div',
					{
						role: 'alert',
						className: 'sui-notice sui-notice-blue sui-active',
						'aria-live': 'assertive',
						style: { display: 'block' }
					},
					_react2.default.createElement(
						'div',
						{ className: 'sui-notice-content' },
						_react2.default.createElement(
							'div',
							{ className: 'sui-notice-message' },
							_react2.default.createElement('span', {
								className: 'sui-notice-icon sui-icon-info',
								'aria-hidden': 'true'
							}),
							_react2.default.createElement(
								'p',
								null,
								(0, _utils.translate)('Note: If value is empty or zero, image will fallback to default size.')
							)
						)
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-row',
						style: { marginBottom: '10px' } },
					_react2.default.createElement(
						_col2.default,
						{ cols: '3' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Width'),
							type: 'number',
							placeholder: '0',
							defaultValue: 70,
							property: 'field-image-width'
						}))
					),
					_react2.default.createElement(
						_col2.default,
						{ cols: '3' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Height'),
							type: 'number',
							placeholder: '0',
							defaultValue: 70,
							property: 'field-image-height'
						}))
					)
				),
				_react2.default.createElement(
					'span',
					{ className: 'sui-description' },
					(0, _utils.translate)('Set your custom dimensions in pixels.')
				)
			);
		}
	}]);

	return FieldImageSize;
}(_react.Component);

exports.default = FieldImageSize;

/***/ }),
/* 696 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _empty = __webpack_require__(12);

var _empty2 = _interopRequireDefault(_empty);

var _paddingCustom = __webpack_require__(697);

var _paddingCustom2 = _interopRequireDefault(_paddingCustom);

var _borderCustom = __webpack_require__(698);

var _borderCustom2 = _interopRequireDefault(_borderCustom);

var _radioTabs = __webpack_require__(7);

var _radioTabs2 = _interopRequireDefault(_radioTabs);

var _spacingCustom = __webpack_require__(699);

var _spacingCustom2 = _interopRequireDefault(_spacingCustom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Container = function (_Component) {
	_inherits(Container, _Component);

	function Container() {
		_classCallCheck(this, Container);

		return _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));
	}

	_createClass(Container, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Form Container')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)("Customize the form container's padding and border.")
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(
						_radioTabs2.default,
						_extends({}, this.props, {
							property: 'poll-padding',
							settingsLabel: (0, _utils.translate)('Padding'),
							description: (0, _utils.translate)('By default the form will fill the available ' + 'space where you insert it. You can add some ' + 'padding here to better suit your theme.') }),
						_react2.default.createElement(
							_empty2.default,
							{ value: '' },
							(0, _utils.translate)('None')
						),
						_react2.default.createElement(
							_paddingCustom2.default,
							_extends({}, this.props, {
								value: 'custom',
								boxClass: 'sui-tab-boxed' }),
							(0, _utils.translate)('Custom')
						)
					),
					_react2.default.createElement(
						_radioTabs2.default,
						_extends({}, this.props, {
							property: 'poll-border',
							settingsLabel: (0, _utils.translate)('Border'),
							description: (0, _utils.translate)('Add an optional border around the form.') }),
						_react2.default.createElement(
							_empty2.default,
							{ value: '' },
							(0, _utils.translate)('None')
						),
						_react2.default.createElement(
							_borderCustom2.default,
							_extends({}, this.props, {
								value: 'custom',
								boxClass: 'sui-tab-boxed' }),
							(0, _utils.translate)('Custom')
						)
					),
					_react2.default.createElement(
						_radioTabs2.default,
						_extends({}, this.props, {
							property: 'answers-spacing',
							settingsLabel: (0, _utils.translate)('Spacing'),
							'default': 'open',
							description: (0, _utils.translate)('Choose how much spacing you want between each poll option.') }),
						_react2.default.createElement(
							_empty2.default,
							{ value: 'open' },
							(0, _utils.translate)('Comfortable')
						),
						_react2.default.createElement(
							_empty2.default,
							{ value: 'enclosed' },
							(0, _utils.translate)('Enclosed')
						),
						_react2.default.createElement(
							_spacingCustom2.default,
							_extends({}, this.props, {
								value: 'custom',
								boxClass: 'sui-tab-boxed'
							}),
							(0, _utils.translate)('Custom')
						)
					)
				)
			);
		}
	}]);

	return Container;
}(_react.Component);

exports.default = Container;

/***/ }),
/* 697 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _col = __webpack_require__(5);

var _col2 = _interopRequireDefault(_col);

var _input = __webpack_require__(3);

var _input2 = _interopRequireDefault(_input);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var paddingCustom = function (_Component) {
	_inherits(paddingCustom, _Component);

	function paddingCustom(props) {
		_classCallCheck(this, paddingCustom);

		return _possibleConstructorReturn(this, (paddingCustom.__proto__ || Object.getPrototypeOf(paddingCustom)).call(this, props));
	}

	_createClass(paddingCustom, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'div',
					{ className: 'sui-row',
						style: { marginBottom: '10px' } },
					_react2.default.createElement(
						_col2.default,
						{ cols: '3' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Top'),
							type: 'number',
							placeholder: '0',
							defaultValue: '20',
							property: 'forminator-poll-padding-top'
						}))
					),
					_react2.default.createElement(
						_col2.default,
						{ cols: '3' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Bottom'),
							type: 'number',
							placeholder: '0',
							defaultValue: '20',
							property: 'forminator-poll-padding-bottom'
						}))
					),
					_react2.default.createElement(
						_col2.default,
						{ cols: '3' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Left'),
							type: 'number',
							placeholder: '0',
							defaultValue: '20',
							property: 'forminator-poll-padding-left'
						}))
					),
					_react2.default.createElement(
						_col2.default,
						{ cols: '3' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Right'),
							type: 'number',
							placeholder: '0',
							defaultValue: '20',
							property: 'forminator-poll-padding-right'
						}))
					)
				),
				_react2.default.createElement(
					'span',
					{ className: 'sui-description' },
					(0, _utils.translate)('Set your custom padding in pixels.')
				)
			);
		}
	}]);

	return paddingCustom;
}(_react.Component);

exports.default = paddingCustom;

/***/ }),
/* 698 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _col = __webpack_require__(5);

var _col2 = _interopRequireDefault(_col);

var _input = __webpack_require__(3);

var _input2 = _interopRequireDefault(_input);

var _suiSelect = __webpack_require__(17);

var _suiSelect2 = _interopRequireDefault(_suiSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var borderCustom = function (_Component) {
	_inherits(borderCustom, _Component);

	function borderCustom(props) {
		_classCallCheck(this, borderCustom);

		return _possibleConstructorReturn(this, (borderCustom.__proto__ || Object.getPrototypeOf(borderCustom)).call(this, props));
	}

	_createClass(borderCustom, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'div',
					{ className: 'sui-row',
						style: { marginBottom: '10px' } },
					_react2.default.createElement(
						_col2.default,
						{ cols: '4' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Radius'),
							note: (0, _utils.translate)('in px'),
							type: 'number',
							placeholder: '0',
							property: 'forminator-poll-border-radius'
						}))
					),
					_react2.default.createElement(
						_col2.default,
						{ cols: '4' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Thickness'),
							note: (0, _utils.translate)('in px'),
							type: 'number',
							placeholder: '0',
							property: 'forminator-poll-border-width'
						}))
					),
					_react2.default.createElement(
						_col2.default,
						{ cols: '4' },
						_react2.default.createElement(
							_suiSelect2.default,
							_extends({
								property: 'forminator-poll-border-style',
								label: (0, _utils.translate)('Style') }, this.props, {
								defaultValue: 'none'
							}),
							_react2.default.createElement(
								'option',
								{ value: 'solid' },
								(0, _utils.translate)('Solid')
							),
							_react2.default.createElement(
								'option',
								{ value: 'dashed' },
								(0, _utils.translate)('Dashed')
							),
							_react2.default.createElement(
								'option',
								{ value: 'dotted' },
								(0, _utils.translate)('Dotted')
							),
							_react2.default.createElement(
								'option',
								{ value: 'none' },
								(0, _utils.translate)('None')
							)
						)
					)
				),
				_react2.default.createElement(
					'span',
					{ className: 'sui-description' },
					(0, _utils.translate)('Note: Set the color of the border in the Colors settings area above.')
				)
			);
		}
	}]);

	return borderCustom;
}(_react.Component);

exports.default = borderCustom;

/***/ }),
/* 699 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _input = __webpack_require__(3);

var _input2 = _interopRequireDefault(_input);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var spacingCustom = function (_Component) {
	_inherits(spacingCustom, _Component);

	function spacingCustom(props) {
		_classCallCheck(this, spacingCustom);

		return _possibleConstructorReturn(this, (spacingCustom.__proto__ || Object.getPrototypeOf(spacingCustom)).call(this, props));
	}

	_createClass(spacingCustom, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(_input2.default, _extends({}, this.props, {
				label: (0, _utils.translate)('Spacing'),
				note: (0, _utils.translate)('in pixels'),
				type: 'number',
				placeholder: (0, _utils.translate)('0'),
				property: (0, _utils.getThemePrefix)(this.props) + 'spacing'
			}));
		}
	}]);

	return spacingCustom;
}(_react.Component);

exports.default = spacingCustom;

/***/ }),
/* 700 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _toggle = __webpack_require__(25);

var _toggle2 = _interopRequireDefault(_toggle);

var _aceEditor = __webpack_require__(183);

var _aceEditor2 = _interopRequireDefault(_aceEditor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CustomCss = function (_Component) {
	_inherits(CustomCss, _Component);

	function CustomCss(props) {
		_classCallCheck(this, CustomCss);

		return _possibleConstructorReturn(this, (CustomCss.__proto__ || Object.getPrototypeOf(CustomCss)).call(this, props));
	}

	_createClass(CustomCss, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Custom CSS')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)('For more advanced customization options use custom CSS.')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(
						'div',
						{ className: 'sui-form-field' },
						_react2.default.createElement(
							'div',
							{ style: { marginBottom: '10px' } },
							_react2.default.createElement(_toggle2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Enable custom CSS'),
								property: 'use-custom-css',
								unWrap: true
							}))
						),
						!_.isUndefined(this.props.settings['use-custom-css']) && this.props.settings['use-custom-css'] && _react2.default.createElement(_aceEditor2.default, _extends({}, this.props, {
							property: 'custom_css',
							type: 'poll'
						}))
					)
				)
			);
		}
	}]);

	return CustomCss;
}(_react.Component);

exports.default = CustomCss;

/***/ }),
/* 701 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(13);

var _redux = __webpack_require__(11);

var _settings = __webpack_require__(185);

var settingsActions = _interopRequireWildcard(_settings);

var _modal = __webpack_require__(184);

var modalActions = _interopRequireWildcard(_modal);

var _behaviour = __webpack_require__(702);

var _behaviour2 = _interopRequireDefault(_behaviour);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function mapStateToProps(state) {
	return {
		settings: state.settings
	};
}

function mapDispatchToProps(dispatch) {
	return {
		actions: {
			settingsActions: (0, _redux.bindActionCreators)(settingsActions, dispatch),
			modalActions: (0, _redux.bindActionCreators)(modalActions, dispatch)
		}
	};
}

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(_behaviour2.default);

/***/ }),
/* 702 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _resultsDisplay = __webpack_require__(703);

var _resultsDisplay2 = _interopRequireDefault(_resultsDisplay);

var _voteCount = __webpack_require__(704);

var _voteCount2 = _interopRequireDefault(_voteCount);

var _submissionMethod = __webpack_require__(705);

var _submissionMethod2 = _interopRequireDefault(_submissionMethod);

var _opening = __webpack_require__(706);

var _opening2 = _interopRequireDefault(_opening);

var _security = __webpack_require__(298);

var _security2 = _interopRequireDefault(_security);

var _limits = __webpack_require__(708);

var _limits2 = _interopRequireDefault(_limits);

var _render = __webpack_require__(709);

var _render2 = _interopRequireDefault(_render);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Behaviour = function (_Component) {
	_inherits(Behaviour, _Component);

	function Behaviour(props) {
		_classCallCheck(this, Behaviour);

		return _possibleConstructorReturn(this, (Behaviour.__proto__ || Object.getPrototypeOf(Behaviour)).call(this, props));
	}

	_createClass(Behaviour, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			jQuery('html, body').animate({
				scrollTop: 0
			}, 'fast');
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var goToSection = function goToSection(module) {
				_this2.props.history.push('/' + module);
			};

			return _react2.default.createElement(
				'div',
				{ id: 'forminator-form-appearance', className: 'sui-box' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-header' },
					_react2.default.createElement(
						'h2',
						{ className: 'sui-box-title' },
						(0, _utils.translate)('Behavior')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-body' },
					_react2.default.createElement(_resultsDisplay2.default, this.props),
					_react2.default.createElement(_voteCount2.default, this.props),
					_react2.default.createElement(_submissionMethod2.default, this.props),
					_react2.default.createElement(_opening2.default, this.props),
					_react2.default.createElement(_limits2.default, this.props),
					_react2.default.createElement(_security2.default, _extends({}, this.props, {
						moduleSlug: 'poll'
					})),
					_react2.default.createElement(_render2.default, this.props)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-footer' },
					_react2.default.createElement(
						'button',
						{ className: 'sui-button', onClick: function onClick() {
								return goToSection('appearance');
							} },
						_react2.default.createElement('i', { className: 'sui-icon-arrow-left', 'aria-hidden': 'true' }),
						(0, _utils.translate)('Appearance')
					),
					_react2.default.createElement(
						'div',
						{ className: 'sui-actions-right' },
						_react2.default.createElement(
							'button',
							{
								className: 'sui-button sui-button-icon-right',
								onClick: function onClick() {
									return goToSection('notifications');
								}
							},
							(0, _utils.translate)('Email Notifications'),
							_react2.default.createElement('i', { className: 'sui-icon-arrow-right', 'aria-hidden': 'true' })
						)
					)
				)
			);
		}
	}]);

	return Behaviour;
}(_react.Component);

exports.default = Behaviour;

/***/ }),
/* 703 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _empty = __webpack_require__(12);

var _empty2 = _interopRequireDefault(_empty);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _radio = __webpack_require__(21);

var _radio2 = _interopRequireDefault(_radio);

var _radioTabs = __webpack_require__(7);

var _radioTabs2 = _interopRequireDefault(_radioTabs);

var _radioOptions = __webpack_require__(114);

var _radioOptions2 = _interopRequireDefault(_radioOptions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ResultsDisplay = function (_Component) {
	_inherits(ResultsDisplay, _Component);

	function ResultsDisplay(props) {
		_classCallCheck(this, ResultsDisplay);

		return _possibleConstructorReturn(this, (ResultsDisplay.__proto__ || Object.getPrototypeOf(ResultsDisplay)).call(this, props));
	}

	_createClass(ResultsDisplay, [{
		key: 'render',
		value: function render() {
			var _this2 = this;

			var goToSection = function goToSection(module) {
				_this2.props.history.push('/' + module);
			};

			var resultStyle = _react2.default.createElement(
				_radioOptions2.default,
				_extends({}, this.props, {
					defaultValue: 'bar',
					property: 'results-style',
					radioClass: 'sui-radio-sm'
				}),
				_react2.default.createElement(
					'div',
					{
						value: 'pie',
						image1x: 'graph-pie.png',
						image2x: 'graph-pie@2x.png',
						hasImage: true
					},
					(0, _utils.translate)('Pie Chart')
				),
				_react2.default.createElement(
					'div',
					{
						value: 'bar',
						image1x: 'graph-bar.png',
						image2x: 'graph-bar@2x.png',
						hasImage: true
					},
					(0, _utils.translate)('Bar Graph')
				)
			);

			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Results Display')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)('Choose how you want to display poll results to new submissions. ' + 'You can customise colors in the {{link}}Appearance{{/link}} tab.', {
							components: {
								link: _react2.default.createElement('a', { href: '#', onClick: function onClick() {
										return goToSection('appearance');
									} })
							}
						})
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(
						_radioTabs2.default,
						_extends({}, this.props, {
							property: 'results-behav',
							'default': 'not_show'
						}),
						_react2.default.createElement(
							_container2.default,
							_extends({}, this.props, {
								value: 'link_on',
								label: (0, _utils.translate)('Link on poll'),
								boxClass: 'sui-tab-boxed'
							}),
							resultStyle
						),
						_react2.default.createElement(
							_container2.default,
							_extends({}, this.props, {
								value: 'show_after',
								label: (0, _utils.translate)('Show after voted'),
								boxClass: 'sui-tab-boxed'
							}),
							resultStyle
						),
						_react2.default.createElement(_empty2.default, {
							value: 'not_show',
							label: (0, _utils.translate)('Do not show')
						})
					)
				)
			);
		}
	}]);

	return ResultsDisplay;
}(_react.Component);

exports.default = ResultsDisplay;

/***/ }),
/* 704 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _radio = __webpack_require__(21);

var _radio2 = _interopRequireDefault(_radio);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var VoteCount = function (_Component) {
	_inherits(VoteCount, _Component);

	function VoteCount(props) {
		_classCallCheck(this, VoteCount);

		return _possibleConstructorReturn(this, (VoteCount.__proto__ || Object.getPrototypeOf(VoteCount)).call(this, props));
	}

	_createClass(VoteCount, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Vote Count')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)('Display the numbers of votes on bar chart results')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(
						_radio2.default,
						_extends({}, this.props, {
							property: 'show-votes-count',
							defaultValue: 'false'
						}),
						_react2.default.createElement(
							'div',
							{ value: 'false' },
							(0, _utils.translate)('Hide')
						),
						_react2.default.createElement(
							'div',
							{ value: 'true' },
							(0, _utils.translate)('Show')
						)
					)
				)
			);
		}
	}]);

	return VoteCount;
}(_react.Component);

exports.default = VoteCount;

/***/ }),
/* 705 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _radio = __webpack_require__(21);

var _radio2 = _interopRequireDefault(_radio);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SubMethod = function (_Component) {
	_inherits(SubMethod, _Component);

	function SubMethod(props) {
		_classCallCheck(this, SubMethod);

		return _possibleConstructorReturn(this, (SubMethod.__proto__ || Object.getPrototypeOf(SubMethod)).call(this, props));
	}

	_createClass(SubMethod, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Submission Method')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)("By default, submissions don't require the page to reload. " + 'If you are having issues you might want use the traditional ' + 'method of reloading the page.')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(
						_radio2.default,
						_extends({}, this.props, {
							property: 'enable-ajax',
							defaultValue: ''
						}),
						_react2.default.createElement(
							'div',
							{ value: '' },
							(0, _utils.translate)('Reload Page')
						),
						_react2.default.createElement(
							'div',
							{ value: 'true' },
							(0, _utils.translate)('Ajax')
						)
					)
				)
			);
		}
	}]);

	return SubMethod;
}(_react.Component);

exports.default = SubMethod;

/***/ }),
/* 706 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _radioTabs = __webpack_require__(7);

var _radioTabs2 = _interopRequireDefault(_radioTabs);

var _empty = __webpack_require__(12);

var _empty2 = _interopRequireDefault(_empty);

var _row = __webpack_require__(8);

var _row2 = _interopRequireDefault(_row);

var _col = __webpack_require__(5);

var _col2 = _interopRequireDefault(_col);

var _input = __webpack_require__(3);

var _input2 = _interopRequireDefault(_input);

var _dateTimePicker = __webpack_require__(707);

var _dateTimePicker2 = _interopRequireDefault(_dateTimePicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Opening = function (_Component) {
	_inherits(Opening, _Component);

	function Opening(props) {
		_classCallCheck(this, Opening);

		return _possibleConstructorReturn(this, (Opening.__proto__ || Object.getPrototypeOf(Opening)).call(this, props));
	}

	_createClass(Opening, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Vote Opening')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)('Choose when you want to open and close voting')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(
						'div',
						{ className: 'sui-form-field' },
						_react2.default.createElement(
							'label',
							{ className: 'sui-settings-label' },
							(0, _utils.translate)('Status')
						),
						_react2.default.createElement(
							'span',
							{ className: 'sui-description' },
							(0, _utils.translate)('Choose the status of voting')
						),
						_react2.default.createElement(
							_radioTabs2.default,
							_extends({}, this.props, {
								property: 'opening_status',
								'default': 'open',
								simple: true
							}),
							_react2.default.createElement(_empty2.default, {
								value: 'open',
								label: (0, _utils.translate)('Open')
							}),
							_react2.default.createElement(_empty2.default, {
								value: 'pause',
								label: (0, _utils.translate)('Pause')
							}),
							_react2.default.createElement(_empty2.default, {
								value: 'close',
								label: (0, _utils.translate)('Close')
							})
						)
					),
					_react2.default.createElement(
						'div',
						{ className: 'sui-form-field' },
						_react2.default.createElement(
							'label',
							{ className: 'sui-settings-label' },
							(0, _utils.translate)('Open from')
						),
						_react2.default.createElement(
							'span',
							{ className: 'sui-description' },
							(0, _utils.translate)('Choose when voting will be opened')
						),
						_react2.default.createElement(
							_radioTabs2.default,
							_extends({}, this.props, {
								property: 'opening_open_from',
								'default': 'now',
								simple: true
							}),
							_react2.default.createElement(_empty2.default, {
								value: 'now',
								label: (0, _utils.translate)('Now')
							}),
							_react2.default.createElement(
								_row2.default,
								_extends({}, this.props, {
									value: 'specific_date_time',
									label: (0, _utils.translate)('Specific Date Time'),
									boxClass: 'sui-tab-boxed'
								}),
								_react2.default.createElement(
									_col2.default,
									{ cols: '12' },
									_react2.default.createElement(_dateTimePicker2.default, _extends({}, this.props, {
										property: 'opening_open_from_date_time'
									}))
								)
							)
						)
					),
					_react2.default.createElement(
						'div',
						{ className: 'sui-form-field' },
						_react2.default.createElement(
							'label',
							{ className: 'sui-settings-label' },
							(0, _utils.translate)('Open until')
						),
						_react2.default.createElement(
							'span',
							{ className: 'sui-description' },
							(0, _utils.translate)('Choose how long voting will remain open')
						),
						_react2.default.createElement(
							_radioTabs2.default,
							_extends({}, this.props, {
								property: 'opening_open_until',
								'default': 'forever',
								simple: true
							}),
							_react2.default.createElement(_empty2.default, {
								value: 'forever',
								label: (0, _utils.translate)('Forever')
							}),
							_react2.default.createElement(
								_row2.default,
								_extends({}, this.props, {
									value: 'specific_date_time',
									label: (0, _utils.translate)('Specific Date Time'),
									boxClass: 'sui-tab-boxed'
								}),
								_react2.default.createElement(
									_col2.default,
									{ cols: '12' },
									_react2.default.createElement(_dateTimePicker2.default, _extends({}, this.props, {
										property: 'opening_open_until_date_time'
									}))
								)
							)
						)
					),
					_react2.default.createElement(
						'div',
						{ className: 'sui-form-field' },
						_react2.default.createElement(
							'label',
							{ className: 'sui-settings-label' },
							(0, _utils.translate)('Custom messages')
						),
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Message when voting is closed'),
							type: 'text',
							property: 'opening_close_msg',
							placeholder: (0, _utils.translate)('E.g. Voting is closed')
						})),
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Message when voting is paused'),
							type: 'text',
							property: 'opening_pause_msg',
							placeholder: (0, _utils.translate)('E.g. Voting is paused, check again later')
						})),
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Message before voting open from time'),
							type: 'text',
							property: 'opening_before_open_from_msg',
							placeholder: (0, _utils.translate)('E.g. Voting has not been started yet')
						}))
					)
				)
			);
		}
	}]);

	return Opening;
}(_react.Component);

exports.default = Opening;

/***/ }),
/* 707 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _datePicker = __webpack_require__(110);

var _datePicker2 = _interopRequireDefault(_datePicker);

var _suiSelect = __webpack_require__(17);

var _suiSelect2 = _interopRequireDefault(_suiSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable dot-notation */


var DateTimePicker = function (_Component) {
	_inherits(DateTimePicker, _Component);

	function DateTimePicker(props) {
		_classCallCheck(this, DateTimePicker);

		var _this = _possibleConstructorReturn(this, (DateTimePicker.__proto__ || Object.getPrototypeOf(DateTimePicker)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		_this.updateDateValue = _this.updateDateValue.bind(_this);
		_this.updateHourValue = _this.updateHourValue.bind(_this);
		_this.updateMinuteValue = _this.updateMinuteValue.bind(_this);
		_this.updateAmPmValue = _this.updateAmPmValue.bind(_this);

		_this.data = {};
		_this.value = '';
		_this.timeType = 'twelve'; //or twentyfour
		_this.dateFormat = 'd MM yy';

		_this.init();
		return _this;
	}

	_createClass(DateTimePicker, [{
		key: 'init',
		value: function init() {
			this.value = _.isUndefined(this.props.settings[this.props.property]) ? this.props.defaultValue : this.props.settings[this.props.property];

			if (!_.isUndefined(this.props['timeType']) && (this.props['timeType'] === 'twelve' || this.props['timeType'] === 'twentyfour')) {
				this.timeType = this.props['timeType'];
			}

			if (!_.isUndefined(this.props['dateFormat'])) {
				this.dateFormat = this.props['dateFormat'];
			}

			var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

			var d = new Date(this.value);

			if (d instanceof Date && !isNaN(d)) {
				var h = d.getHours();

				this.setData('date', d.getDate() + ' ' + monthNames[d.getMonth()] + ' ' + d.getFullYear());
				this.setData('hour', this.leadingZero(h));
				this.setData('minute', this.leadingZero(d.getMinutes()));

				if (this.timeType === 'twelve') {
					var ampm = h >= 12 ? 'pm' : 'am';
					if (h === 0) {
						this.setData('hour', 12);
					}
					this.setData('ampm', ampm);
					if (ampm === 'pm' && h > 12) {
						this.setData('hour', this.leadingZero(h - 12));
					}
				}
			} else {
				d = new Date();

				this.setData('date', d.getDate() + ' ' + monthNames[d.getMonth()] + ' ' + d.getFullYear());
				this.setData('hour', '00');
				this.setData('minute', '00');
				this.setData('ampm', '');

				if (this.timeType === 'twelve') {
					this.setData('ampm', 'am');
					this.setData('hour', '12');
				}
			}
		}
	}, {
		key: 'updateValue',
		value: function updateValue(value) {
			this.value = value;

			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'setData',
		value: function setData(property, value) {
			var key = this.props.property + '_' + property;
			this.data[key] = value;
		}
	}, {
		key: 'getData',
		value: function getData(property) {
			var key = this.props.property + '_' + property;
			return !_.isUndefined(this.data[key]) ? this.data[key] : '';
		}
	}, {
		key: 'updateData',
		value: function updateData(property, value) {
			this.setData(property, value);

			// Make full date time value
			var fullValue = this.getData('date') + ' ' + this.getData('hour') + ':' + this.getData('minute');

			if (this.timeType === 'twelve') {
				fullValue += ' ' + this.getData('ampm');
			}

			this.updateValue(fullValue);
		}
	}, {
		key: 'updateDateValue',
		value: function updateDateValue(property, value) {
			this.updateData('date', value);
		}
	}, {
		key: 'updateHourValue',
		value: function updateHourValue(property, value) {
			this.updateData('hour', value);
		}
	}, {
		key: 'updateMinuteValue',
		value: function updateMinuteValue(property, value) {
			this.updateData('minute', value);
		}
	}, {
		key: 'updateAmPmValue',
		value: function updateAmPmValue(property, value) {
			this.updateData('ampm', value);
		}
	}, {
		key: 'leadingZero',
		value: function leadingZero(num) {
			var s = num + '';
			return s.length < 2 ? '0' + s : s;
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var hoursMax = this.timeType === 'twelve' ? 12 : 24;
			var hourFix = hoursMax === 12 ? 1 : 0;
			var prefiex = this.props.property;

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'div',
					{ className: 'sui-form-field-inline forminator-fields-line-2x' },
					_react2.default.createElement(_datePicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Date'),
						settings: this.data,
						property: prefiex + '_date',
						placeholder: (0, _utils.translate)('10 January 2020'),
						updateProperty: this.updateDateValue,
						dateFormat: this.dateFormat
					}))
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-form-field-inline forminator-fields-line-2x' },
					_react2.default.createElement(
						_suiSelect2.default,
						_extends({}, this.props, {
							settings: this.data,
							label: (0, _utils.translate)('Hour'),
							property: prefiex + '_hour',
							updateProperty: this.updateHourValue,
							'data-width': '86'
						}),
						[].concat(_toConsumableArray(Array(hoursMax))).map(function (x, i) {
							return _react2.default.createElement(
								'option',
								{
									value: _this2.leadingZero(i + hourFix),
									key: _this2.leadingZero(i + hourFix)
								},
								_this2.leadingZero(i + hourFix)
							);
						})
					),
					_react2.default.createElement(
						_suiSelect2.default,
						_extends({}, this.props, {
							settings: this.data,
							label: (0, _utils.translate)('Minute'),
							property: prefiex + '_minute',
							updateProperty: this.updateMinuteValue,
							'data-width': '86'
						}),
						[].concat(_toConsumableArray(Array(60))).map(function (x, i) {
							return _react2.default.createElement(
								'option',
								{ value: _this2.leadingZero(i), key: _this2.leadingZero(i) },
								_this2.leadingZero(i)
							);
						})
					),
					this.timeType === 'twelve' && _react2.default.createElement(
						_suiSelect2.default,
						_extends({}, this.props, {
							settings: this.data,
							label: (0, _utils.translate)('AM/PM'),
							property: prefiex + '_ampm',
							updateProperty: this.updateAmPmValue,
							'data-width': '86'
						}),
						_react2.default.createElement(
							'option',
							{ value: 'am', key: 'am' },
							'AM'
						),
						_react2.default.createElement(
							'option',
							{ value: 'pm', key: 'pm' },
							'PM'
						)
					)
				)
			);
		}
	}]);

	return DateTimePicker;
}(_react.Component);

exports.default = DateTimePicker;

/***/ }),
/* 708 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _radioTabs = __webpack_require__(7);

var _radioTabs2 = _interopRequireDefault(_radioTabs);

var _empty = __webpack_require__(12);

var _empty2 = _interopRequireDefault(_empty);

var _row = __webpack_require__(8);

var _row2 = _interopRequireDefault(_row);

var _col = __webpack_require__(5);

var _col2 = _interopRequireDefault(_col);

var _input = __webpack_require__(3);

var _input2 = _interopRequireDefault(_input);

var _suiSelect = __webpack_require__(20);

var _suiSelect2 = _interopRequireDefault(_suiSelect);

var _radio = __webpack_require__(21);

var _radio2 = _interopRequireDefault(_radio);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Limits = function (_Component) {
	_inherits(Limits, _Component);

	function Limits(props) {
		_classCallCheck(this, Limits);

		return _possibleConstructorReturn(this, (Limits.__proto__ || Object.getPrototypeOf(Limits)).call(this, props));
	}

	_createClass(Limits, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Voting Limit')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)('Choose whether you want to limit the number of votes ' + 'per users and how do you want to impose that limit. ')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(
						'div',
						{ className: 'sui-form-field' },
						_react2.default.createElement(
							'label',
							{ className: 'sui-settings-label' },
							(0, _utils.translate)('Votes per user')
						),
						_react2.default.createElement(
							'span',
							{
								className: 'sui-description',
								style: { marginBottom: '20px' }
							},
							(0, _utils.translate)('By default, a user can only vote once on a poll. However, ' + 'you can allow the users to vote multiple times and also ' + 'specify the time after which a user can vote again.')
						),
						_react2.default.createElement(
							_radioTabs2.default,
							_extends({}, this.props, {
								property: 'enable-votes-limit',
								'default': 'false',
								simple: true
							}),
							_react2.default.createElement(_empty2.default, {
								value: 'false',
								label: (0, _utils.translate)('Once')
							}),
							_react2.default.createElement(
								_row2.default,
								_extends({}, this.props, {
									value: 'true',
									label: (0, _utils.translate)('Allow Multiple'),
									boxClass: 'sui-tab-boxed'
								}),
								_react2.default.createElement(
									_col2.default,
									{ cols: '6' },
									_react2.default.createElement(_input2.default, _extends({}, this.props, {
										type: 'number',
										property: 'vote_limit_input',
										placeholder: '10',
										minValue: '0',
										isPositive: true
									}))
								),
								_react2.default.createElement(
									_col2.default,
									{ cols: '6' },
									_react2.default.createElement(
										_suiSelect2.default,
										_extends({}, this.props, {
											property: 'vote_limit_options',
											defaultValue: 'm'
										}),
										_react2.default.createElement(
											'option',
											{ value: 'm' },
											(0, _utils.translate)('minute(s)')
										),
										_react2.default.createElement(
											'option',
											{ value: 'h' },
											(0, _utils.translate)('hour(s)')
										),
										_react2.default.createElement(
											'option',
											{ value: 'd' },
											(0, _utils.translate)('day(s)')
										),
										_react2.default.createElement(
											'option',
											{ value: 'W' },
											(0, _utils.translate)('week(s)')
										),
										_react2.default.createElement(
											'option',
											{ value: 'M' },
											(0, _utils.translate)('month(s)')
										),
										_react2.default.createElement(
											'option',
											{ value: 'Y' },
											(0, _utils.translate)('year(s)')
										)
									)
								)
							)
						)
					),
					_react2.default.createElement(
						'div',
						{ className: 'sui-form-field' },
						_react2.default.createElement(
							'label',
							{ className: 'sui-settings-label' },
							(0, _utils.translate)('Method')
						),
						_react2.default.createElement(
							'span',
							{ className: 'sui-description' },
							(0, _utils.translate)('Choose the method you want to use to limit the number of votes.')
						),
						_react2.default.createElement(
							_radio2.default,
							_extends({}, this.props, {
								property: 'enable-votes-method',
								defaultValue: 'user_ip'
							}),
							_react2.default.createElement(
								'div',
								{ value: 'user_ip' },
								(0, _utils.translate)('User IP')
							),
							_react2.default.createElement(
								'div',
								{ value: 'browser_cookie' },
								(0, _utils.translate)('Browser Cookie')
							)
						)
					)
				)
			);
		}
	}]);

	return Limits;
}(_react.Component);

exports.default = Limits;

/***/ }),
/* 709 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _toggle = __webpack_require__(25);

var _toggle2 = _interopRequireDefault(_toggle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RenderBehaviour = function (_Component) {
	_inherits(RenderBehaviour, _Component);

	function RenderBehaviour() {
		_classCallCheck(this, RenderBehaviour);

		return _possibleConstructorReturn(this, (RenderBehaviour.__proto__ || Object.getPrototypeOf(RenderBehaviour)).apply(this, arguments));
	}

	_createClass(RenderBehaviour, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Rendering')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)('Choose how you want your poll to be rendered for users.')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(_toggle2.default, _extends({}, this.props, {
						property: 'use_ajax_load',
						label: (0, _utils.translate)('Load poll using AJAX'),
						description: (0, _utils.translate)('Enabling this feature will load the poll via AJAX after the page ' + 'has loaded up, effectively speeding up your page load time. ' + 'This method can also (in most cases) avoid page caching issues ' + 'with your poll.')
					})),
					_react2.default.createElement(_toggle2.default, _extends({}, this.props, {
						property: 'use_donotcachepage',
						label: (0, _utils.translate)('Prevent page caching on poll pages'),
						description: (0, _utils.translate)('Page caching plugins serve a static HTML version of the page which ' + "can cause issues to your dynamic polls. By enabling this, we'll " + 'use {{strong}}DONOTCACHEPAGE{{/strong}} constant to prevent ' + 'pages with this poll on it from being cached.', {
							components: {
								strong: _react2.default.createElement('strong', null)
							}
						})
					}))
				)
			);
		}
	}]);

	return RenderBehaviour;
}(_react.Component);

exports.default = RenderBehaviour;

/***/ }),
/* 710 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(13);

var _redux = __webpack_require__(11);

var _settings = __webpack_require__(185);

var settingsActions = _interopRequireWildcard(_settings);

var _modal = __webpack_require__(184);

var modalActions = _interopRequireWildcard(_modal);

var _notifications = __webpack_require__(711);

var _notifications2 = _interopRequireDefault(_notifications);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function mapStateToProps(state) {
	return {
		settings: state.settings
	};
}

function mapDispatchToProps(dispatch) {
	return {
		actions: {
			settingsActions: (0, _redux.bindActionCreators)(settingsActions, dispatch),
			modalActions: (0, _redux.bindActionCreators)(modalActions, dispatch)
		}
	};
}

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(_notifications2.default);

/***/ }),
/* 711 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _adminEmail = __webpack_require__(712);

var _adminEmail2 = _interopRequireDefault(_adminEmail);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Notifications = function (_Component) {
	_inherits(Notifications, _Component);

	function Notifications(props) {
		_classCallCheck(this, Notifications);

		return _possibleConstructorReturn(this, (Notifications.__proto__ || Object.getPrototypeOf(Notifications)).call(this, props));
	}

	_createClass(Notifications, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			jQuery('html, body').animate({
				scrollTop: 0
			}, 'fast');
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var goToSection = function goToSection(module) {
				_this2.props.history.push('/' + module);
			};

			return _react2.default.createElement(
				'div',
				{ id: 'forminator-form-notifications', className: 'sui-box' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-header' },
					_react2.default.createElement(
						'h2',
						{ className: 'sui-box-title' },
						(0, _utils.translate)('Email Notifications')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-body' },
					_react2.default.createElement(_adminEmail2.default, this.props)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-footer' },
					_react2.default.createElement(
						'button',
						{ className: 'sui-button', onClick: function onClick() {
								return goToSection('behaviour');
							} },
						_react2.default.createElement('i', { className: 'sui-icon-arrow-left', 'aria-hidden': 'true' }),
						(0, _utils.translate)('Behavior')
					),
					_react2.default.createElement(
						'div',
						{ className: 'sui-actions-right' },
						_react2.default.createElement(
							'button',
							{
								className: 'sui-button sui-button-icon-right',
								onClick: function onClick() {
									return goToSection('integrations');
								}
							},
							(0, _utils.translate)('Integrations'),
							_react2.default.createElement('i', { className: 'sui-icon-arrow-right', 'aria-hidden': 'true' })
						)
					)
				)
			);
		}
	}]);

	return Notifications;
}(_react.Component);

exports.default = Notifications;

/***/ }),
/* 712 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _escapeHtml = __webpack_require__(18);

var _input = __webpack_require__(3);

var _input2 = _interopRequireDefault(_input);

var _toggle = __webpack_require__(25);

var _toggle2 = _interopRequireDefault(_toggle);

var _suiTags = __webpack_require__(300);

var _suiTags2 = _interopRequireDefault(_suiTags);

var _wpEditor = __webpack_require__(31);

var _wpEditor2 = _interopRequireDefault(_wpEditor);

var _suiVariables = __webpack_require__(53);

var _suiVariables2 = _interopRequireDefault(_suiVariables);

var _suiSelect = __webpack_require__(17);

var _suiSelect2 = _interopRequireDefault(_suiSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AdminEmail = function (_Component) {
	_inherits(AdminEmail, _Component);

	function AdminEmail() {
		_classCallCheck(this, AdminEmail);

		return _possibleConstructorReturn(this, (AdminEmail.__proto__ || Object.getPrototypeOf(AdminEmail)).apply(this, arguments));
	}

	_createClass(AdminEmail, [{
		key: 'getNameOptions',
		value: function getNameOptions() {
			var nameOptions = [];
			_.map(forminatorData.variables, function (label, key) {
				nameOptions.push({
					label: label,
					value: '{' + key + '}'
				});
			});

			return nameOptions;
		}
	}, {
		key: 'getEmailOptions',
		value: function getEmailOptions() {
			return [];
		}
	}, {
		key: 'getRecipientTagsOptions',
		value: function getRecipientTagsOptions() {
			return {
				tags: true,
				tokenSeparators: [',', ' '],
				language: {
					searching: function searching() {
						return (0, _utils.translate)('Searching');
					},
					noResults: function noResults() {
						return (0, _utils.translate)('No Result Found');
					}
				},
				placeholder: (0, _utils.translate)('Recipient(s)'),
				ajax: {
					url: forminatorData.ajaxUrl,
					type: 'POST',
					delay: 350,
					data: function data(params) {
						return {
							action: 'forminator_builder_search_emails',
							_wpnonce: forminatorData.searchNonce,
							q: params.term,
							permission: 'forminator'
						};
					},
					processResults: function processResults(data) {
						return {
							results: data.data
						};
					},
					cache: true
				},
				templateResult: function templateResult(result) {
					if (!_.isUndefined(result.id) && !_.isUndefined(result.text) && !_.isUndefined(result.display_name)) {
						return jQuery('<span>' + '<b>' + result.text + '</b> - ' + '<small>' + result.display_name + '</small>' + '</span>');
					}

					return result.text;
				},
				createTag: function createTag(params) {
					var term = params.term.trim();
					if (!(0, _utils.isEmailWp)(term)) {
						return null;
					}
					return {
						id: term,
						text: term
					};
				}
			};
		}
	}, {
		key: 'getCcBccOptions',
		value: function getCcBccOptions() {
			return {
				tags: true,
				placeholder: (0, _utils.translate)('None'),
				createTag: function createTag(params) {
					var term = params.term.trim();
					if (!(0, _utils.isEmailWp)(term)) {
						return null;
					}
					return {
						id: term,
						text: term
					};
				},
				tokenSeparators: [',', ' '],
				language: {
					searching: function searching() {
						return (0, _utils.translate)('Searching');
					},
					noResults: function noResults() {
						return (0, _utils.translate)('No Result Found');
					}
				},
				ajax: {
					url: forminatorData.ajaxUrl,
					type: 'POST',
					delay: 350,
					data: function data(params) {
						return {
							action: 'forminator_builder_search_emails',
							_wpnonce: forminatorData.searchNonce,
							q: params.term,
							permission: 'forminator'
						};
					},
					processResults: function processResults(data) {
						return {
							results: data.data
						};
					},
					cache: true
				},
				templateResult: function templateResult(result) {
					if (!_.isUndefined(result.id) && !_.isUndefined(result.text) && !_.isUndefined(result.display_name)) {
						return jQuery('<span>' + '<b>' + result.text + '</b> - ' + '<small>' + result.display_name + '</small>' + '</span>');
					}

					return result.text;
				}
			};
		}
		/*getCcAddressesOptions() {
  	const ccEmailOptions = this.getEmailOptions();
  	const ccEmailOptionsValues = [];
  	ccEmailOptions.map( opt => {
  		ccEmailOptionsValues.push( opt.value );
  	} );
  		const savedCcAddresses =
  		_.isUndefined( this.props.settings[ 'admin-email-cc-address' ] ) ||
  		! _.isArray( this.props.settings[ 'admin-email-cc-address' ] )
  			? []
  			: this.props.settings[ 'admin-email-cc-address' ];
  		const ccAddressOptions = savedCcAddresses.filter(
  		ccAddress => ccEmailOptionsValues.indexOf( ccAddress ) < 0
  	);
  	ccAddressOptions.map( ccAddress => {
  		ccEmailOptions.push( {
  			value: ccAddress,
  			label: ccAddress,
  		} );
  	} );
  		return ccEmailOptions;
  }*/
		/*getBccAddressesOptions() {
  	const bccEmailOptions = this.getEmailOptions();
  	const bccEmailOptionsValues = [];
  	bccEmailOptions.map( opt => {
  		bccEmailOptionsValues.push( opt.value );
  	} );
  		const savedBCcAddresses =
  		_.isUndefined( this.props.settings[ 'admin-email-bcc-address' ] ) ||
  		! _.isArray( this.props.settings[ 'admin-email-bcc-address' ] )
  			? []
  			: this.props.settings[ 'admin-email-bcc-address' ];
  		const bccAddressOptions = savedBCcAddresses.filter(
  		bccAddress => bccEmailOptionsValues.indexOf( bccAddress ) < 0
  	);
  	bccAddressOptions.map( bccAddress => {
  		bccEmailOptions.push( {
  			value: bccAddress,
  			label: bccAddress,
  		} );
  	} );
  		return bccEmailOptions;
  }*/

	}, {
		key: 'getAutoCreateEmailAddressOptions',
		value: function getAutoCreateEmailAddressOptions() {
			return {
				tags: true,
				createTag: function createTag(params) {
					var term = params.term.trim();
					if (!(0, _utils.isEmailWp)(term)) {
						return null;
					}
					return {
						id: term,
						text: term
					};
				},
				insertTag: function insertTag(data, tag) {
					// Insert the tag at the end of the results
					data.push(tag);
				}
			};
		}
	}, {
		key: 'getFromAddressOptions',
		value: function getFromAddressOptions() {
			var fromEmailOptions = this.getEmailOptions();
			fromEmailOptions.unshift({
				value: '',
				label: (0, _utils.translate)('Default')
			});

			var fromEmailOptionsValues = [];
			fromEmailOptions.map(function (opt) {
				fromEmailOptionsValues.push(opt.value);
			});

			var savedFromAddress = _.isUndefined(this.props.settings['admin-email-from-address']) ? '' : this.props.settings['admin-email-from-address'];

			if (fromEmailOptionsValues.indexOf(savedFromAddress) < 0) {
				fromEmailOptions.push({
					value: savedFromAddress,
					label: savedFromAddress
				});
			}

			return fromEmailOptions;
		}
	}, {
		key: 'getReplyToAddressOptions',
		value: function getReplyToAddressOptions() {
			var replyToAddressOptions = this.getEmailOptions();
			replyToAddressOptions.unshift({
				value: '',
				label: (0, _utils.translate)('None')
			});

			var emailOptionsValues = [];
			replyToAddressOptions.map(function (opt) {
				emailOptionsValues.push(opt.value);
			});

			var savedAddress = _.isUndefined(this.props.settings['admin-email-reply-to-address']) ? '' : this.props.settings['admin-email-reply-to-address'];

			if (emailOptionsValues.indexOf(savedAddress) < 0) {
				replyToAddressOptions.push({
					value: savedAddress,
					label: savedAddress
				});
			}

			return replyToAddressOptions;
		}
	}, {
		key: 'render',
		value: function render() {
			var fromAddressOptions = this.getEmailOptions();
			fromAddressOptions.unshift({
				value: '',
				label: (0, _utils.translate)('Default')
			});

			var replyToAddressOptions = this.getEmailOptions();
			replyToAddressOptions.unshift({
				value: '',
				label: (0, _utils.translate)('None')
			});

			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Admin Email')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)('Optionally, you can send a notification email to ' + 'nominated email accounts when poll submissions come in.')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(
						'div',
						{
							className: 'sui-form-field',
							style: { marginBottom: '10px' }
						},
						_react2.default.createElement(_toggle2.default, _extends({}, this.props, {
							property: 'use-admin-email',
							label: (0, _utils.translate)('Send an email to admin users'),
							unWrap: true
						}))
					),
					!_.isUndefined(this.props.settings['use-admin-email']) && this.props.settings['use-admin-email'] && _react2.default.createElement(
						'div',
						{ className: 'sui-border-frame sui-toggle-content' },
						_react2.default.createElement(
							_suiVariables2.default,
							_extends({}, this.props, {
								property: 'admin-email-from-name',
								placeholder: (0, _utils.translate)('Default'),
								label: (0, _utils.translate)('From Name')
							}),
							this.getNameOptions().map(function (option, i) {
								return _react2.default.createElement(
									'option',
									{
										key: i,
										value: option.value,
										'data-content': option.value
									},
									(0, _escapeHtml.escapeHTML)(option.label)
								);
							})
						),
						_react2.default.createElement(
							_suiSelect2.default,
							_extends({}, this.props, {
								property: 'admin-email-from-address',
								label: (0, _utils.translate)('From Address'),
								defaultValue: '',
								options: this.getAutoCreateEmailAddressOptions()
							}),
							this.getFromAddressOptions().map(function (option, i) {
								return _react2.default.createElement(
									'option',
									{ key: i, value: option.value },
									option.label
								);
							})
						),
						_react2.default.createElement(_suiTags2.default, _extends({}, this.props, {
							property: 'admin-email-recipients',
							placeholder: (0, _utils.translate)('Recipient(s)'),
							options: this.getRecipientTagsOptions(),
							label: (0, _utils.translate)('Recipients')
						})),
						_react2.default.createElement(
							_suiSelect2.default,
							_extends({}, this.props, {
								property: 'admin-email-reply-to-address',
								label: (0, _utils.translate)('Reply To Address'),
								defaultValue: '',
								options: this.getAutoCreateEmailAddressOptions()
							}),
							this.getReplyToAddressOptions().map(function (option, i) {
								return _react2.default.createElement(
									'option',
									{ key: i, value: option.value },
									option.label
								);
							})
						),
						_react2.default.createElement(_suiTags2.default, _extends({}, this.props, {
							property: 'admin-email-cc-address',
							placeholder: (0, _utils.translate)('None'),
							label: (0, _utils.translate)('CC Addresses'),
							options: this.getCcBccOptions()
						})),
						_react2.default.createElement(_suiTags2.default, _extends({}, this.props, {
							property: 'admin-email-bcc-address',
							placeholder: (0, _utils.translate)('None'),
							label: (0, _utils.translate)('BCC Addresses'),
							options: this.getCcBccOptions()
						})),
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							property: 'admin-email-title',
							placeholder: (0, _utils.translate)('Enter subject'),
							label: (0, _utils.translate)('Subject'),
							defaultValue: ''
						})),
						_react2.default.createElement(_wpEditor2.default, _extends({}, this.props, {
							property: 'admin-email-editor',
							editorOptions: forminatorData.variables,
							enableFormData: false,
							boxClass: 'sui-tab-boxed',
							mainOptions: {
								poll_name: (0, _utils.translate)('Poll Name'),
								poll_answer: (0, _utils.translate)('Poll Answer'),
								poll_result: (0, _utils.translate)('Poll Result')
							},
							label: (0, _utils.translate)('Body')
						}))
					)
				)
			);
		}
	}]);

	return AdminEmail;
}(_react.Component);

exports.default = AdminEmail;

/***/ }),
/* 713 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(13);

var _modal = __webpack_require__(184);

var _integrations = __webpack_require__(714);

var _integrations2 = _interopRequireDefault(_integrations);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	return {
		hideModal: function hideModal() {
			return dispatch((0, _modal.hideModal)());
		},
		showModal: function showModal(modalProps, modalType) {
			dispatch((0, _modal.showModal)({ modalProps: modalProps, modalType: modalType }));
		}
	};
};

exports.default = (0, _reactRedux.connect)(null, mapDispatchToProps)(_integrations2.default);

/***/ }),
/* 714 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _integrationsModal = __webpack_require__(196);

var _integrationsModal2 = _interopRequireDefault(_integrationsModal);

__webpack_require__(198);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Integrations = function (_Component) {
	_inherits(Integrations, _Component);

	function Integrations(props) {
		_classCallCheck(this, Integrations);

		var _this = _possibleConstructorReturn(this, (Integrations.__proto__ || Object.getPrototypeOf(Integrations)).call(this, props));

		_this.state = {
			loading: false,
			markup: ''
		};
		_this.loadIntegrations = _this.loadIntegrations.bind(_this);
		return _this;
	}

	_createClass(Integrations, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.mounted = true;

			this.loadIntegrations();

			jQuery('html, body').animate({
				scrollTop: 0
			}, 'fast');
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.mounted = false;
		}
	}, {
		key: 'loadIntegrations',
		value: function loadIntegrations() {
			var _this2 = this;

			var formId = forminatorData.currentForm.settings.form_id;

			// check if form id exists, means its saved
			if (_.isUndefined(formId) || +formId <= 0) {
				return;
			}

			// Check if we already process ajax request
			if (this.state.loading) {
				// Ajax request in process, skip
				return;
			}

			this.setState({
				markup: '',
				loading: true
			});

			window.fetch(forminatorData.ajaxUrl, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8'
				},
				body: 'action=forminator_addon_get_module_addons&_ajax_nonce=' + forminatorData.addonNonce + '&data[module_type]=poll' + '&data[module_id]=' + formId
			}).then(function (response) {
				return response.json();
			}).then(function (data) {
				if (data.success && _this2.mounted) {
					var self = _this2;
					_this2.setState({ markup: data.data.data });

					setTimeout(function () {
						var $addons = window.jQuery('.form-integrations-wrapper');

						$addons.ForminatorIntegrationsModal({
							type: 'poll'
						});

						$addons.on('reload', function () {
							$addons.unbind();
							self.loadIntegrations();
						});
					}, 10);

					// Set loading to false
					_this2.setState({ loading: false });
				}
			}).catch(function (error) {
				console.log(error);
			});
		}
	}, {
		key: 'render',
		value: function render() {
			var _this3 = this;

			var loading = this.state.loading;
			var markup = this.state.markup;


			var formId = forminatorData.currentForm.settings.form_id;

			var goToSection = function goToSection(module) {
				_this3.props.history.push('/' + module);
			};

			var content = '';

			if (loading) {
				content = _react2.default.createElement(
					'div',
					{ className: 'sui-notice sui-active', style: { display: 'block' } },
					_react2.default.createElement(
						'div',
						{ className: 'sui-notice-content' },
						_react2.default.createElement(
							'div',
							{ className: 'sui-notice-message' },
							_react2.default.createElement('span', { className: 'sui-notice-icon sui-icon-loader sui-loading', 'aria-hidden': 'true' }),
							_react2.default.createElement(
								'p',
								null,
								(0, _utils.translate)('Fetching integration list')
							)
						)
					)
				);
			} else if (_.isUndefined(formId) || +formId <= 0) {
				content = _react2.default.createElement(
					'div',
					{ className: 'sui-notice sui-notice-yellow sui-active', style: { display: 'block' } },
					_react2.default.createElement(
						'div',
						{ className: 'sui-notice-content' },
						_react2.default.createElement(
							'div',
							{ className: 'sui-notice-message' },
							_react2.default.createElement('span', { className: 'sui-notice-icon sui-icon-info', 'aria-hidden': 'true' }),
							_react2.default.createElement(
								'p',
								null,
								(0, _utils.translate)('You need to save this poll before using integrations.')
							),
							_react2.default.createElement(
								'a',
								{ className: 'sui-button', onClick: this.loadIntegrations },
								(0, _utils.translate)('Try Again')
							)
						)
					)
				);
			} else {
				content = _react2.default.createElement('span', {
					className: 'form-integrations-wrapper',
					dangerouslySetInnerHTML: { __html: markup }
				});
			}

			return _react2.default.createElement(
				'div',
				{ id: 'forminator-form-appearance', className: 'sui-box' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-header' },
					_react2.default.createElement(
						'h2',
						{ className: 'sui-box-title' },
						(0, _utils.translate)('Integrations')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-body' },
					content
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-footer' },
					_react2.default.createElement(
						'button',
						{ className: 'sui-button', onClick: function onClick() {
								return goToSection('notifications');
							} },
						_react2.default.createElement('i', { className: 'sui-icon-arrow-left', 'aria-hidden': 'true' }),
						(0, _utils.translate)('Email Notifications')
					),
					_react2.default.createElement(
						'div',
						{ className: 'sui-actions-right' },
						_react2.default.createElement(
							'button',
							{
								className: 'sui-button sui-button-icon-right',
								onClick: function onClick() {
									return goToSection('settings');
								}
							},
							(0, _utils.translate)('Settings'),
							_react2.default.createElement('i', { className: 'sui-icon-arrow-right', 'aria-hidden': 'true' })
						)
					)
				)
			);
		}
	}]);

	return Integrations;
}(_react.Component);

exports.default = Integrations;

/***/ }),
/* 715 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRedux = __webpack_require__(13);

var _redux = __webpack_require__(11);

var _settings = __webpack_require__(185);

var settingsActions = _interopRequireWildcard(_settings);

var _modal = __webpack_require__(184);

var modalActions = _interopRequireWildcard(_modal);

var _settings2 = __webpack_require__(716);

var _settings3 = _interopRequireDefault(_settings2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function mapStateToProps(state) {
	return {
		settings: state.settings
	};
}

function mapDispatchToProps(dispatch) {
	return {
		actions: {
			settingsActions: (0, _redux.bindActionCreators)(settingsActions, dispatch),
			modalActions: (0, _redux.bindActionCreators)(modalActions, dispatch)
		}
	};
}

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(_settings3.default);

/***/ }),
/* 716 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _dataStorage = __webpack_require__(717);

var _dataStorage2 = _interopRequireDefault(_dataStorage);

var _privacy = __webpack_require__(718);

var _privacy2 = _interopRequireDefault(_privacy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Settings = function (_Component) {
	_inherits(Settings, _Component);

	function Settings(props) {
		_classCallCheck(this, Settings);

		return _possibleConstructorReturn(this, (Settings.__proto__ || Object.getPrototypeOf(Settings)).call(this, props));
	}

	_createClass(Settings, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			jQuery('html, body').animate({
				scrollTop: 0
			}, 'fast');
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var goToSection = function goToSection(module) {
				_this2.props.history.push('/' + module);
			};

			return _react2.default.createElement(
				'div',
				{
					id: 'forminator-form-appearance',
					className: 'sui-box'
				},
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-header' },
					_react2.default.createElement(
						'h2',
						{ className: 'sui-box-title' },
						(0, _utils.translate)('Settings')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-body' },
					_react2.default.createElement(_dataStorage2.default, this.props),
					_react2.default.createElement(_privacy2.default, this.props)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-footer' },
					_react2.default.createElement(
						'button',
						{ className: 'sui-button', onClick: function onClick() {
								return goToSection('integrations');
							} },
						_react2.default.createElement('i', { className: 'sui-icon-arrow-left', 'aria-hidden': 'true' }),
						' ',
						(0, _utils.translate)('Integrations')
					)
				)
			);
		}
	}]);

	return Settings;
}(_react.Component);

exports.default = Settings;

/***/ }),
/* 717 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _toggle = __webpack_require__(25);

var _toggle2 = _interopRequireDefault(_toggle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DataStorage = function (_Component) {
	_inherits(DataStorage, _Component);

	function DataStorage(props) {
		_classCallCheck(this, DataStorage);

		return _possibleConstructorReturn(this, (DataStorage.__proto__ || Object.getPrototypeOf(DataStorage)).call(this, props));
	}

	_createClass(DataStorage, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Data Storage')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)("By default we'll store all submissions in your database.")
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(_toggle2.default, _extends({}, this.props, {
						property: 'store_submissions',
						label: (0, _utils.translate)('Store Submissions in Database'),
						description: (0, _utils.translate)('Disable this feature to prevent submissions from being stored in your database. ' + 'Note that any submissions previously stored in the database will be retained and automatically deleted ' + 'according to the retention schedule configured in the Privacy settings below.')
					}))
				)
			);
		}
	}]);

	return DataStorage;
}(_react.Component);

exports.default = DataStorage;

/***/ }),
/* 718 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _radioTabs = __webpack_require__(7);

var _radioTabs2 = _interopRequireDefault(_radioTabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _col = __webpack_require__(5);

var _col2 = _interopRequireDefault(_col);

var _input = __webpack_require__(3);

var _input2 = _interopRequireDefault(_input);

var _suiSelect = __webpack_require__(20);

var _suiSelect2 = _interopRequireDefault(_suiSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Privacy = function (_Component) {
	_inherits(Privacy, _Component);

	function Privacy(props) {
		_classCallCheck(this, Privacy);

		return _possibleConstructorReturn(this, (Privacy.__proto__ || Object.getPrototypeOf(Privacy)).call(this, props));
	}

	_createClass(Privacy, [{
		key: 'render',
		value: function render() {
			var ipRetainForever = _.isEmpty(forminatorData.poll_ip_retain_number) || forminatorData.poll_ip_retain_number === '0';

			var ipRetainDefault = (0, _utils.translate)('forever');

			if (!ipRetainForever) {
				ipRetainDefault = forminatorData.poll_ip_retain_number + ' ' + forminatorData.poll_ip_retain_unit;
			}

			var submissionsRetainForever = _.isEmpty(forminatorData.submissions_ip_retain_number) || forminatorData.submissions_ip_retain_number === '0';

			var submisionsRetainDefault = (0, _utils.translate)('forever');

			if (!submissionsRetainForever) {
				submisionsRetainDefault = forminatorData.submissions_ip_retain_number + ' ' + forminatorData.submissions_ip_retain_unit;
			}

			var canManageSettings = (0, _utils.isTrue)(forminatorData.userPermissions.manage_forminator_settings) || (0, _utils.isTrue)(forminatorData.userPermissions.manage_options);

			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Privacy')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)('Choose how you want to handle this poll\'s data storage. ' + "By default we'll use the configuration you've set in your "),
						canManageSettings && _react2.default.createElement(
							'a',
							{ href: forminatorData.settingsUrl + '&section=submissions', target: '_blank' },
							(0, _utils.translate)('global privacy settings.')
						),
						!canManageSettings && (0, _utils.translate)('global privacy settings.')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(
						'div',
						{ className: 'sui-form-field' },
						_react2.default.createElement(
							'label',
							{ className: 'sui-settings-label' },
							(0, _utils.translate)('Submissions')
						),
						_react2.default.createElement(
							'span',
							{
								className: 'sui-description',
								style: { marginBottom: '10px' }
							},
							(0, _utils.translate)("How long do you want to retain this poll's submissions for?")
						),
						_react2.default.createElement(
							'div',
							{ style: { marginTop: '10px' } },
							_react2.default.createElement(
								_radioTabs2.default,
								_extends({}, this.props, {
									'default': 'false',
									property: 'enable-submissions-retention',
									simple: true
								}),
								_react2.default.createElement(
									_container2.default,
									{
										value: 'false',
										label: (0, _utils.translate)('Use default')
									},
									_react2.default.createElement(
										'div',
										{ className: 'sui-notice sui-active', style: { display: 'block' } },
										_react2.default.createElement(
											'div',
											{ className: 'sui-notice-content' },
											_react2.default.createElement(
												'div',
												{ className: 'sui-notice-message' },
												_react2.default.createElement('span', { className: 'sui-notice-icon sui-icon-info', 'aria-hidden': 'true' }),
												_react2.default.createElement(
													'p',
													null,
													(0, _utils.translate)('Your default setting value is to keep the submissions %s.', {
														args: [submisionsRetainDefault]
													})
												)
											)
										)
									)
								),
								_react2.default.createElement(
									_container2.default,
									_extends({}, this.props, {
										value: 'true',
										label: (0, _utils.translate)('Custom'),
										boxClass: 'sui-tab-boxed'
									}),
									_react2.default.createElement(
										'div',
										{
											className: 'sui-row',
											style: { marginBottom: '10px' }
										},
										_react2.default.createElement(
											_col2.default,
											{ cols: '6' },
											_react2.default.createElement(_input2.default, _extends({}, this.props, {
												type: 'number',
												defaultValue: '0',
												property: 'submissions-retention-number',
												placeholder: '10'
											}))
										),
										_react2.default.createElement(
											_col2.default,
											{ cols: '6' },
											_react2.default.createElement(
												_suiSelect2.default,
												_extends({}, this.props, {
													defaultValue: 'days',
													property: 'submissions-retention-unit'
												}),
												_react2.default.createElement(
													'option',
													{ value: 'days' },
													(0, _utils.translate)('day(s)')
												),
												_react2.default.createElement(
													'option',
													{ value: 'weeks' },
													(0, _utils.translate)('week(s)')
												),
												_react2.default.createElement(
													'option',
													{ value: 'months' },
													(0, _utils.translate)('month(s)')
												),
												_react2.default.createElement(
													'option',
													{ value: 'years' },
													(0, _utils.translate)('year(s)')
												)
											)
										)
									),
									_react2.default.createElement(
										'span',
										{ className: 'sui-description' },
										(0, _utils.translate)('Leave the field blank to retain submissions forever.')
									)
								)
							)
						)
					),
					_react2.default.createElement(
						'div',
						{ className: 'sui-form-field' },
						_react2.default.createElement(
							'label',
							{ className: 'sui-settings-label' },
							(0, _utils.translate)('IP Retention')
						),
						_react2.default.createElement(
							'span',
							{ className: 'sui-description' },
							(0, _utils.translate)('Choose how long to retain IP address before a submission is ' + 'anonymized. Keep in mind that the IP address is being used ' + 'in checking multiple votes from same user.')
						),
						_react2.default.createElement(
							'div',
							{ style: { marginTop: '10px' } },
							_react2.default.createElement(
								_radioTabs2.default,
								_extends({}, this.props, {
									'default': 'false',
									property: 'enable-ip-address-retention',
									simple: true
								}),
								_react2.default.createElement(
									_container2.default,
									_extends({}, this.props, {
										value: 'false',
										label: (0, _utils.translate)('Use default')
									}),
									_react2.default.createElement(
										'div',
										{ className: 'sui-notice' },
										_react2.default.createElement(
											'p',
											null,
											(0, _utils.translate)('Your default setting keep the IPs %s.', {
												args: [ipRetainDefault]
											})
										)
									)
								),
								_react2.default.createElement(
									_container2.default,
									_extends({}, this.props, {
										value: 'true',
										label: (0, _utils.translate)('Custom'),
										boxClass: 'sui-tab-boxed'
									}),
									_react2.default.createElement(
										'div',
										{
											className: 'sui-row',
											style: { marginBottom: '10px' }
										},
										_react2.default.createElement(
											_col2.default,
											{ cols: '6' },
											_react2.default.createElement(_input2.default, _extends({}, this.props, {
												type: 'number',
												defaultValue: '0',
												property: 'ip-address-retention-number',
												placeholder: '10'
											}))
										),
										_react2.default.createElement(
											_col2.default,
											{ cols: '6' },
											_react2.default.createElement(
												_suiSelect2.default,
												_extends({}, this.props, {
													defaultValue: 'days',
													property: 'ip-address-retention-unit'
												}),
												_react2.default.createElement(
													'option',
													{ value: 'days' },
													(0, _utils.translate)('day(s)')
												),
												_react2.default.createElement(
													'option',
													{ value: 'weeks' },
													(0, _utils.translate)('week(s)')
												),
												_react2.default.createElement(
													'option',
													{ value: 'months' },
													(0, _utils.translate)('month(s)')
												),
												_react2.default.createElement(
													'option',
													{ value: 'years' },
													(0, _utils.translate)('year(s)')
												)
											)
										)
									),
									_react2.default.createElement(
										'span',
										{ className: 'sui-description' },
										(0, _utils.translate)('Leave the field blank to keep IPs forever.')
									)
								)
							)
						)
					)
				)
			);
		}
	}]);

	return Privacy;
}(_react.Component);

exports.default = Privacy;

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYjk0NWM3YzRhNmI2NmM5OTA1MzMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiUmVhY3RcIiIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MvaW5wdXRzL2lucHV0LmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy9jb250YWluZXJzL2NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MvY29udGFpbmVycy9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzL2lucHV0cy9jb2xvci1waWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzL2lucHV0cy9yYWRpby10YWJzLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy9jb250YWluZXJzL3Jvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MvY29udGFpbmVycy90YWJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9yZWR1eC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MvY29udGFpbmVycy9lbXB0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzL2NvbnRhaW5lcnMvc2V0dGluZ3Mtcm93LmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy9pbnB1dHMvc3VpLXNlbGVjdDIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3b3JkcHJlc3MvZXNjYXBlLWh0bWwvYnVpbGQtbW9kdWxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93YXJuaW5nL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzL2lucHV0cy9zdWktc2VsZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy9pbnB1dHMvcmFkaW8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3cG11ZGV2L3JlYWN0LWJ1dHRvbi1pY29uL2Rpc3QvcmVhY3QtYnV0dG9uLWljb24uZXNtLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcIlJlYWN0RE9NXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzL2lucHV0cy90b2dnbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvUGF0aFV0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9ub3RpZmljYXRpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy9pbnB1dHMvd3AtZWRpdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L25vZGVfbW9kdWxlcy93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvTG9jYXRpb25VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MvY29udGFpbmVycy9hY2NvcmRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzL2lucHV0cy9jaGVja2JveC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9tYXRjaFBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdwbXVkZXYvcmVhY3QtYnV0dG9uL2Rpc3QvcmVhY3QtYnV0dG9uLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaTE4bi13cC1wbHVnaW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzL2lucHV0cy9zdWktdmFyaWFibGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9taW5pbWFsaXN0aWMtYXNzZXJ0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3cG11ZGV2L3JlYWN0LWJveC9kaXN0L3JlYWN0LWJveC5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzL2lucHV0cy91cGxvYWRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9Qcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9kaXN0L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzLmNqcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC93cmFwTWFwVG9Qcm9wcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0RPTVV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUm91dGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9nZW5lcmF0ZVBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXMvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xcy9saWIvZm9ybWF0cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyQmxvY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbXZlci9zZW12ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2kxOG4td3AtcGx1Z2luL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaTE4bi13cC1wbHVnaW4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pMThuLXdwLXBsdWdpbi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamVkL2plZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW50ZXJwb2xhdGUtY29tcG9uZW50cy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWFkZG9ucy1jcmVhdGUtZnJhZ21lbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ludGVycG9sYXRlLWNvbXBvbmVudHMvbGliL3Rva2VuaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9scnUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2kxOG4td3AtcGx1Z2luL2xpYi9udW1iZXItZm9ybWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pMThuLXdwLXBsdWdpbi9saWIvbG9jYWxpemUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1yZWFjdC1jbGFzcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JlYXRlLXJlYWN0LWNsYXNzL2ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy9pbnB1dHMvZGF0ZS1waWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlZC1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVkdXgtdGh1bmsvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzL2lucHV0cy9yYWRpby1vcHRpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL1Byb3ZpZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvU3Vic2NyaXB0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L2Nvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tYXBEaXNwYXRjaFRvUHJvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2VzL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9oYXJtb255LW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvZXMvcG9ueWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcm9vdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tYXBTdGF0ZVRvUHJvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWVyZ2VQcm9wcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9zZWxlY3RvckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvdmVyaWZ5U3Vic2VsZWN0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0Jyb3dzZXJSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlQnJvd3Nlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Jlc29sdmUtcGF0aG5hbWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ZhbHVlLWVxdWFsL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUhhc2hIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvSGFzaFJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9NZW1vcnlSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9NZW1vcnlSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTmF2TGluay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Qcm9tcHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Qcm9tcHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9SZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9TdGF0aWNSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9TdGF0aWNSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvU3dpdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3dpdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL2dlbmVyYXRlUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9tYXRjaFBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvd2l0aFJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL3dpdGhSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi9wYXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZGlzcGxhY2UvZGlzdC9kaXNwbGFjZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MvaW5wdXRzL2FjZS1lZGl0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvYWN0aW9ucy9tb2RhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9hY3Rpb25zL3NldHRpbmdzLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy9jb250YWluZXJzL2xheW91dC9tZXRhLWRyb3Bkb3duLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad29yZHByZXNzL2VzY2FwZS1odG1sL2J1aWxkLW1vZHVsZS9lc2NhcGUtZ3JlYXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tcHVyaWZ5L2Rpc3QvcHVyaWZ5LmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbXBvbmVudHMvbW9kYWxzL3BhcnRpYWxzL2ZvY3VzLXRyYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZvY3VzLXRyYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RhYmJhYmxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9pbnRlZ3JhdGlvbnMtbW9kYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9pbnRlZ3JhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGVkLWNvbXBvbmVudHMvZGlzdC9zdHlsZWQtY29tcG9uZW50cy5icm93c2VyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGVkLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGVkLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2hhbGxvd2VxdWFsL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9zdHlsaXMvZGlzdC9zdHlsaXMuYnJvd3Nlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL3VuaXRsZXNzL2Rpc3QvdW5pdGxlc3MuYnJvd3Nlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL2lzLXByb3AtdmFsaWQvZGlzdC9pcy1wcm9wLXZhbGlkLmJyb3dzZXIuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9tZW1vaXplL2Rpc3QvbWVtb2l6ZS5icm93c2VyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGVkLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2Rpc3QvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MuY2pzLmpzIiwid2VicGFjazovLy8uL3NyYy9nbG9iYWwvY29tcG9uZW50cy9iZWhhdmlvdXIvc2VjdXJpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvYWN0aW9ucy9idWlsZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy9pbnB1dHMvc3VpLXRhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvYWN0aW9ucy9uYXZpZ2F0aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL3N0b3JlL2NvbmZpZ3VyZVN0b3JlLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL3JlZHVjZXJzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL3JlZHVjZXJzL2Fuc3dlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvcmVkdWNlcnMvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvcmVkdWNlcnMvbW9kYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29udGFpbmVycy9tYWluLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbnRhaW5lcnMvaGVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvaGVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvaGVhZGVyL2RvY3VtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9oZWFkZXIvdGl0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29udGFpbmVycy9tb2RhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL21vZGFsLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvbW9kYWxzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvbW9kYWxzL3ByZXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9tb2RhbHMvcHVibGlzaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL21vZGFscy9zaG9ydGNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9tb2RhbHMvZGVsZXRlLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbnRhaW5lcnMvbWV0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL21ldGEuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9tZXRhL3N0YXR1cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL21ldGEvYnV0dG9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL25hdmlnYXRpb24vcHJldmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb250YWluZXJzL25hdmlnYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9uYXZpZ2F0aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9tZW51LmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9tb2JpbGUtc2VsZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbnRhaW5lcnMvYnVpbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL2J1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9idWlsZGVyL2RldGFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9idWlsZGVyL2Fuc3dlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9idWlsZGVyL2Fuc3dlci1yb3cuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29udGFpbmVycy9hcHBlYXJhbmNlLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvYXBwZWFyYW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvZGVzaWduLXN0eWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9kZXNpZ24tc3R5bGUvZGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvZGVzaWduLXN0eWxlL2ZsYXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2Rlc2lnbi1zdHlsZS9ib2xkLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9kZXNpZ24tc3R5bGUvbWF0ZXJpYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2Rlc2lnbi1zdHlsZS9iYXNpYy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvZGVzaWduLXN0eWxlL25vbmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL3Jlc3BvbnNlLXN1Y2Nlc3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9yZXNwb25zZS1lcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2NvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9vcHRpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvaW1hZ2VzLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvaW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9zdWJtaXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9saW5rcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2NoYXJ0LmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvYW5zd2VyLWNvbG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9vcHRpb25zLWxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvbGF5b3V0L2ZpZWxkLWltYWdlLXNpemUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29udGFpbmVyL3BhZGRpbmctY3VzdG9tLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb250YWluZXIvYm9yZGVyLWN1c3RvbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29udGFpbmVyL3NwYWNpbmctY3VzdG9tLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jdXN0b20tY3NzLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbnRhaW5lcnMvYmVoYXZpb3VyLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvYmVoYXZpb3VyLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvYmVoYXZpb3VyL3Jlc3VsdHMtZGlzcGxheS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL2JlaGF2aW91ci92b3RlLWNvdW50LmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvYmVoYXZpb3VyL3N1Ym1pc3Npb24tbWV0aG9kLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvYmVoYXZpb3VyL29wZW5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzL2lucHV0cy9kYXRlLXRpbWUtcGlja2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvYmVoYXZpb3VyL2xpbWl0cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL2JlaGF2aW91ci9yZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29udGFpbmVycy9ub3RpZmljYXRpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvbm90aWZpY2F0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL25vdGlmaWNhdGlvbnMvYWRtaW4tZW1haWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29udGFpbmVycy9pbnRlZ3JhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29tcG9uZW50cy9pbnRlZ3JhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BvbGwvY29udGFpbmVycy9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9sbC9jb21wb25lbnRzL3NldHRpbmdzLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvc2V0dGluZ3MvZGF0YS1zdG9yYWdlLmpzIiwid2VicGFjazovLy8uL3NyYy9wb2xsL2NvbXBvbmVudHMvc2V0dGluZ3MvcHJpdmFjeS5qcyJdLCJuYW1lcyI6WyJyYW5kTnVtYmVyIiwiZ2VuZXJhdGVXcmFwcGVySWQiLCJnZXRXcmFwcGVyIiwiZ2V0RGVmYXVsdFZhbHVlIiwiZ2V0VGhlbWVQcmVmaXgiLCJyZXN0cmljdGVkR3JvdXBGaWVsZHMiLCJsb25lckZpZWxkcyIsImdldFN1Ym1pc3Npb25CZWhhdmlvcnMiLCJjb3VudEZpZWxkc0J5VHlwZSIsImdldE1heElEQnlUeXBlIiwiZ2V0TWF4SUQiLCJnZW5lcmF0ZVZhbHVlIiwiaGFzRmllbGRUeXBlIiwiZ2V0RmllbGRzQnlUeXBlIiwibWFwRmllbGRzQnlUeXBlIiwiZ2V0RmllbGRMYWJlbCIsImZpZWxkRXhpc3QiLCJidWlsZEZpZWxkT2JqZWN0IiwiYnVpbGRGaWVsZE9iamVjdEZyb21TbHVnIiwiZ2V0RmllbGRUeXBlIiwiZ2V0Rm9ybWluYXRvckZpZWxkIiwiaW5zZXJ0SW5Qb3NpdGlvbiIsInJlcGxhY2VJblBvc2l0aW9uIiwidHJhbnNsYXRlIiwiZ2V0Rm9udFZhcmlhbnRzIiwidWNmaXJzdCIsImdldENvbmRpdGlvbkxhYmVsIiwiY29udmVydFRpbWVzdGFtcCIsImdldEZpZWxkcyIsImdldERhdGVGaWVsZHMiLCJnZXROYW1lRmllbGRzIiwiZ2V0UmFuZ2VTbGlkZXJGaWVsZHMiLCJmaWVsZEhhc051bWJlciIsImZpZWxkSGFzQ2FsY3MiLCJmaWVsZEZvcm11bGEiLCJmaWVsZEhhc09wdGlvbnMiLCJnZXRGaWVsZFZhbHVlcyIsImdldEFkZHJlc3NGaWVsZHMiLCJnZXRUaW1lRmllbGRzIiwiZ2V0RmllbGRBdXRvZmlsbFByb3ZpZGVycyIsImdldFJ1bGVMYWJlbCIsImlzRW1haWxXcCIsInN1aURlbGVnYXRlRXZlbnRzIiwiZ2V0Q2hhcnRUeXBlIiwiZ2V0Q2FsY3VsYXRpb25GaWVsZHMiLCJzZWxlY3QyVGFncyIsImlzRmllbGRSZXF1aXJlZCIsImhhc0ZpZWxkV2l0aEF0dHJpYnV0ZSIsImhhc1Bvc3RkYXRhRmllbGRXaXRoTXVsdGlzZWxlY3QiLCJnZXRQZXJzb25hbGl0eVF1ZXN0aW9ucyIsImdldFBsYW5WYWxpZGF0aW9uIiwiaXNUcnVlIiwicGFyc2VRdWVyeVN0cmluZyIsImdvVG9MaW5rIiwibWluIiwiTWF0aCIsImNlaWwiLCJtYXgiLCJmbG9vciIsInJhbmRvbSIsIndyYXBwZXJJRCIsIndyYXBwZXJzIiwid3JhcHBlck9iamVjdCIsIm1hcCIsIndyYXBwZXIiLCJ3cmFwcGVyX2lkIiwicHJvcHMiLCJnZXRUaGVtZU5hbWUiLCJmb3JtRGVzaWduIiwic2V0dGluZ3MiLCJxdWl6RGVzaWduIiwidHlwZSIsImNvdW50ZXIiLCJmaWVsZHMiLCJmaWVsZCIsImZpZWxkSURzIiwiZmllbGRJZCIsImVsZW1lbnRfaWQiLCJmaWVsZElkQXJyYXkiLCJzcGxpdCIsInB1c2giLCJwYXJzZUludCIsIm1heFZhbHVlIiwiXyIsImlzRW1wdHkiLCJ2YWx1ZXMiLCJpZHMiLCJ2YWx1ZSIsInRyaW0iLCJyZXBsYWNlIiwiaXNHbG9iYWxQcmVzZXQiLCJmaWVsZHNCeVR5cGUiLCJsYWJlbCIsImZpZWxkX2xhYmVsIiwiaWQiLCJleGlzdCIsImNvbHMiLCJ0ZW1wTmV3RmllbGRzIiwid3JhcHMiLCJmaWVsZE51bWJlciIsImV4dGVuZCIsImZvcm1JRCIsInNsdWciLCJmb3JtaW5hdG9yRGF0YSIsImZpbmQiLCJmaWVsZERhdGEiLCJvcHRpb25zIiwiY29uZGl0aW9ucyIsImNvbnRhaW5zIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiZGVmYXVsdHMiLCJmb3JtaW5hdG9yRmllbGQiLCJhcnJheSIsInBvc2l0aW9uIiwicmVwbGFjZW1lbnQiLCJzbGljZSIsImkxOG4iLCJhcHBseSIsImFyZ3VtZW50cyIsImZvbnRzIiwiZm9udE9iamVjdCIsImZpbHRlciIsImZvbnQiLCJmYW1pbHkiLCJpc1VuZGVmaW5lZCIsInZhcmlhbnRzIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJjb25kaXRpb24iLCJ2YWx1ZUxhYmVsIiwiaGFzT3B0aW9ucyIsImxlbmd0aCIsIndoZXJlIiwiZmllbGRfdHlwZSIsImluY2x1ZGVzIiwicnVsZSIsImlzTmFOIiwiTnVtYmVyIiwiZGF0ZSIsIkRhdGUiLCJkYXkiLCJtb250aCIsInllYXIiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJkaXNhYmxlZEZpZWxkcyIsImV4dHJhIiwiaW5jbHVkZWRGaWVsZHMiLCJleGNsdWRlU3ViRmllbGRzIiwiZmllbGRzQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJtYWluX2RhdGVfZmllbGQiLCJwYXJlbnRHcm91cCIsInBhcmVudF9ncm91cCIsImNvbmNhdCIsInNsaWRlcl90eXBlIiwicmVxdWlyZWQiLCJmaWVsZF9zbHVnIiwiaGFzQ2FsY3MiLCJmb3JtdWxhIiwiaXNOdW1iZXIiLCJmaWVsZExhYmVsIiwiZGF5X2xhYmVsIiwibW9udGhfbGFiZWwiLCJ5ZWFyX2xhYmVsIiwibXVsdGlwbGVfbmFtZSIsImF0dHIiLCJlbGVtZW50X3N1ZmZpeCIsImF0dHJpYnV0ZSIsInN1ZmZpeCIsImNhbGN1bGF0aW9ucyIsImhoX2xhYmVsIiwibW1fbGFiZWwiLCJ0aW1lX3R5cGUiLCJmaWVsZFR5cGUiLCJhdXRvZmlsbFByb3ZpZGVycyIsImZpZWxkU2V0dGluZ3MiLCJhdXRvZmlsbF9zZXR0aW5ncyIsInZhbCIsImluZGV4T2YiLCJwYXJ0cyIsIm1hdGNoIiwiZG9tYWluIiwic3VicyIsInN1YnNMZW4iLCJpIiwid2luZG93IiwiU1VJIiwic2V0VGltZW91dCIsInN1aUFjY29yZGlvbiIsImpRdWVyeSIsInN1aVRhYnMiLCJlYWNoIiwic2VsZWN0IiwiaW5pdEljb24iLCJpbml0Q29sb3IiLCJpbml0U2VhcmNoIiwiaW5pdCIsImluaXRWYXJzIiwibG9hZENpcmNsZVNjb3JlIiwic2hvd0hpZGVQYXNzd29yZCIsImRpc2FibGVkIiwiJGVsIiwiYWxsb3dDbGVhciIsImRyb3Bkb3duQ3NzQ2xhc3MiLCJvbiIsImUiLCJlbG0iLCJwYXJhbXMiLCJkYXRhIiwiZWxlbWVudCIsIiRlbG0iLCIkdCIsImFwcGVuZCIsInRyaWdnZXIiLCJTVUlzZWxlY3QyIiwicG9zdF9jYXRlZ29yeSIsInBvc3RDYXRlZ29yaWVzIiwicG9zdF90eXBlIiwiY2F0ZWdvcnlfa2V5IiwiY2F0ZWdvcnkiLCJjdXJyZW50UGVyc29uYWxpdHkiLCJxdWVzdGlvbnMiLCJwZXJzb25hbGl0eVNsdWciLCJxdWVzdGlvbnNBcnJheSIsInF1ZXN0aW9uIiwia2V5UXVlc3Rpb24iLCJhbnN3ZXJzIiwiYW5zd2VyIiwia2V5QW5zd2VyIiwicmVzdWx0IiwidGl0bGUiLCJ1bmlxIiwidmFsaWRhdGlvbiIsInBheW1lbnRzIiwicGF5bWVudEluZGV4IiwicGF5bWVudCIsImluZGV4IiwiYW1vdW50X3R5cGUiLCJwbGFuX25hbWUiLCJlcnJvciIsImlzVmFsaWQiLCJwYXltZW50X21ldGhvZCIsImFtb3VudCIsInZhcmlhYmxlIiwic3Vic2NyaXB0aW9uQW1vdW50Iiwic3Vic2NyaXB0aW9uX2Ftb3VudF90eXBlIiwic3Vic2NyaXB0aW9uUXVhbnRpdHkiLCJxdWFudGl0eV90eXBlIiwiUXVhbnRpdHkiLCJxdWFudGl0eSIsIkJpbGxJbnB1dCIsImJpbGxfaW5wdXQiLCJzdWJzY3JpcHRpb25fYW1vdW50Iiwic3Vic2NyaXB0aW9uX3ZhcmlhYmxlIiwidmFyaWFibGVfcXVhbnRpdHkiLCJwYXltZW50S2V5IiwidG9Mb3dlckNhc2UiLCJwYXJzZWRQYXJhbWV0ZXJzIiwidXJpUGFyYW1ldGVycyIsImxvY2F0aW9uIiwic2VhcmNoIiwic3Vic3RyaW5nIiwicGFyYW1ldGVyIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwibGluayIsInRhcmdldCIsIm9wZW4iLCJJbnB1dCIsInVwZGF0ZVZhbHVlIiwiYmluZCIsInVwZGF0ZVByb3BlcnR5IiwicHJvcGVydHkiLCJhY3Rpb25zIiwic2V0dGluZ3NBY3Rpb25zIiwidXBkYXRlU2V0dGluZyIsImlzUmVxdWlyZWQiLCJpc1Bvc2l0aXZlIiwiZGVmYXVsdFZhbHVlIiwicmVxdWlyZWRFcnJvciIsImhhc0Vycm9yQ2xhc3MiLCJmaWVsZENsYXNzIiwiaW5wdXRDbGFzcyIsInByZWZpeCIsImlucHV0SWQiLCJpbnB1dExhYmVsIiwiZGFya0xhYmVsIiwibm90ZSIsImlucHV0RmllbGQiLCJwbGFjZWhvbGRlciIsIm5vdFdyaXRhYmxlIiwicmVhZG9ubHkiLCJtaW5WYWx1ZSIsInN0ZXAiLCJtYXhMZW5ndGgiLCJpbnB1dFN0eWxlcyIsInN0eWxlIiwiY2FuVHJhc2giLCJkZXNjcmlwdGlvbiIsInNpbXBsZSIsIkNvbXBvbmVudCIsIkNvbnRhaW5lciIsImNoaWxkcmVuIiwiUmVhY3QiLCJDaGlsZHJlbiIsImNoaWxkIiwiQ29sIiwiY3VzdG9tQ2xhc3MiLCJDb2xvclBpY2tlciIsImVsIiwid3BDb2xvclBpY2tlciIsImNoYW5nZSIsImV2ZW50IiwidWkiLCIkdGhpcyIsImNvbG9yIiwidG9DU1MiLCJwYWxldHRlcyIsIiRzdWlQaWNrZXJJbnB1dCIsIiRzdWlQaWNrZXIiLCJjbG9zZXN0IiwiJHN1aVBpY2tlckNvbG9yIiwiJHN1aVBpY2tlclZhbHVlIiwiJHN1aVBpY2tlckNsZWFyIiwiJHdwUGlja2VyIiwiJHdwUGlja2VyQnV0dG9uIiwiJHdwUGlja2VyQWxwaGEiLCIkd3BQaWNrZXJDbGVhciIsIiRwaWNrZXJCYWNrZ3JvdW5kIiwiY3NzIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJjbGljayIsIm9mZiIsInVuYmluZCIsInJlbW92ZURhdGEiLCJpc0FscGhhIiwiYmFja2dyb3VuZENvbG9yIiwiUmFkaW9UYWJzIiwiZGVmYXVsdCIsInRhYlRpdGxlcyIsInRhYiIsIm9wYWNpdHkiLCJjdXJzb3IiLCJ0b2dnbGVWYWx1ZSIsImNvbnRlbnRDbGFzcyIsImRpdkNsYXNzIiwidGFiQ29udGVudHMiLCJib3hDbGFzcyIsIm5hbWUiLCJ0YWJzTGFiZWwiLCJzZXR0aW5nc0xhYmVsIiwibGFiZWxDbGFzcyIsIm1hcmdpbkJvdHRvbSIsIndyYXBwZXJDbGFzcyIsImJhc2ljVGFicyIsInRhYnNNYXJrdXAiLCJSb3ciLCJjb2x1bW5zIiwiY2xhc3MiLCJUYWJzIiwic3RhdGUiLCJhY3RpdmUiLCJzZXRTdGF0ZSIsImV4dHJhQ2xhc3MiLCJpc051bGwiLCJib3hDbGFzc1ZhbHVlIiwiRW1wdHkiLCJTZXR0aW5nc1JvdyIsImNvbnRlbnQiLCJsYWJlbERhcmsiLCJkZXNjcmlwdGlvblNwYWNpbmciLCJzaWRlYmFyIiwiY29uZGl0aW9uYWxTdHlsZXMiLCJsYXN0Q2hpbGQiLCJib3JkZXJCb3R0b20iLCJTdWlTZWxlY3QyIiwiYWZ0ZXJTYXZlIiwicGFyZW50IiwicGFyZW50SWQiLCJoYXNTZWFyY2giLCJPYmplY3QiLCJhc3NpZ24iLCJkcm9wZG93blBhcmVudCIsIm1pbmltdW1SZXN1bHRzRm9yU2VhcmNoIiwiaGFzQ2xhc3MiLCJ3aWR0aCIsIkZVSXNlbGVjdDIiLCJFcnJvciIsInRyaWdnZXJDaGFuZ2UiLCJzZWxlY3RJZCIsImVsZW1lbnRJZCIsIm11bHRpcGxlIiwiZm9ybVR5cGUiLCJub1dyYXBwZXIiLCJzdGF0aWNDb250ZXh0IiwiZmllbGRTaXplIiwic2VsZWN0UHJvcHMiLCJnZXRTZWxlY3QiLCJnZXRFbGVtZW50IiwiZmllbGRzaXplIiwibWF4V2lkdGgiLCJtYXJnaW5Ub3AiLCJTdWlTZWxlY3QiLCJzZWxlY3RDbGFzcyIsImVsZW1lbnRDbGFzcyIsInNlbGVjdExhYmVsIiwic2VsZWN0RmllbGQiLCJnZXRGaWVsZCIsIlJhZGlvIiwicmFkaW9Db250YWluZXIiLCJjcmVhdGVSZWYiLCJzZWxmIiwiJHJhZGlvQ29udGFpbmVyIiwidGltZVR5cGUiLCJjdXJyZW50VGFyZ2V0IiwiY2xlYXJPcHRpb25zIiwib3B0aW9uIiwidGFiSW5kZXgiLCJmaWVsZERlc2NyaXB0aW9uIiwic2V0dGluZ3NEZXNjcmlwdGlvbiIsInNldHRpbmdzRGVzYyIsImZpZWxkQ29udGVudCIsInRhYnNDb250ZW50IiwiVG9nZ2xlIiwiY2hlY2tlZCIsInRvZ2dsZUNvbnRlbnQiLCJzdWJUb2dnbGUiLCJ1bldyYXAiLCJOb3RpZmljYXRpb24iLCJwcmVwZW5kIiwicmVtb3ZlIiwiaW5pdGlhbGl6ZSIsIiRub3RpZmljYXRpb24iLCJub3RpY2VJZCIsIm5vdGljZU1lc3NhZ2UiLCJ0ZXh0Iiwibm90aWNlT3B0aW9ucyIsImF1dG9jbG9zZSIsInRpbWVvdXQiLCJ0aW1lIiwiZGlzbWlzcyIsInNob3ciLCJvcGVuTm90aWNlIiwiY2xvc2VOb3RpY2UiLCJXcEVkaXRvciIsInRleHRFZGl0b3IiLCJ1cGRhdGVFZGl0b3IiLCJ0b2dnbGVPcHRpb25zIiwiZWRpdG9yT3B0aW9uc09wZW4iLCJpbml0RWRpdG9yIiwid3AiLCJlZGl0b3IiLCJ0aW55TUNFIiwidGlueW1jZVByb3BzIiwiYWxsb3dCdXR0b25PbmNsaWNrIiwiZXh0ZW5kZWRfdmFsaWRfZWxlbWVudHMiLCJjdXRvbVRpbnltY2UiLCJ0b29sYmFyMSIsImV4dHJhSWQiLCJ0aW55bWNlIiwicXVpY2t0YWdzIiwiYmluZEV2ZW50cyIsImdldCIsImdldENvbnRlbnQiLCJET01QdXJpZnkiLCJzYW5pdGl6ZSIsIkFERF9BVFRSIiwiaGlkZGVuIiwic3RhcnRQb3MiLCJwcm9wIiwiZW5kUG9zIiwidGV4dEVkaXRvclZhbCIsImluc2VydENvbnRlbnQiLCJlbmFibGVQb3N0RGF0YSIsImVuYWJsZVVwbG9hZCIsImdldERpc2FibGVkRmllbGRzIiwiZm9ybV93cmFwcGVycyIsImVuYWJsZVBhcmVudEZvcm0iLCJwYXJlbnRGb3JtRmllbGRzIiwidW5kZWZpbmVkIiwiYWxsb3dSZXBlYXRlciIsInJlcXVpcmVkRmllbGRzIiwiY3VycmVudFR5cGUiLCJub25yZXF1aXJlZEZpZWxkcyIsInNvbWUiLCJpdGVtIiwiZWRpdG9yT3B0aW9ucyIsImtleSIsImZvcm1XcmFwcGVycyIsInBheXBhbEZpZWxkcyIsInN0cmlwZUZpZWxkcyIsInBheW1lbnRPcHRpb25zIiwiaGlkZUVkaXRvck9wdGlvbnMiLCJtaXNjTWFya3VwIiwiZGlzYWJsZU1pc2NEYXRhIiwiZ2V0TWlzY0RhdGEiLCJwYXltZW50TWFya3VwIiwiZW5hYmxlRm9ybURhdGEiLCJnZXRQYXltZW50RGF0YSIsImZpZWxkc01hcmt1cCIsImdldEZvcm1EYXRhIiwibWFpbk9wdGlvbnMiLCJmb3JtX25hbWUiLCJlbmFibGVBbGxGb3JtRmllbGRzIiwiZW5hYmxlQWxsTm9uRm9ybUZpZWxkcyIsIm1haW5PcHRpb25zTGFiZWwiLCJnZXRFZGl0b3JPcHRpb25zIiwiZWRpdG9yT3B0aW9uc01hcmt1cCIsInRvb2x0aXBMYWJlbCIsIndwRWRpdG9yTGFiZWwiLCJkZXNjcmlwdGlvblRvcCIsIkFjY29yZGlvbiIsImV4cGFuZGVkIiwidG9nZ2xlU3RhdGUiLCJib3hlZENvbnRlbnQiLCJkZWZhdWx0Q29udGVudFJlbmRlciIsImFjY29yZGlvbkNvbnRlbnRzIiwiQ2hlY2tib3giLCJpdGVtQ2xhc3MiLCJ0b29sdGlwIiwibWFyZ2luTGVmdCIsInZlcnRpY2FsQWxpZ24iLCJwb2ludGVyRXZlbnRzIiwiU3VpVGFncyIsImNsZWFyVmFsdWUiLCJpc1JlZGlyZWN0VXJsIiwiaW5zZXJ0Rm9ybUZpZWxkcyIsIm5leHQiLCJodG1sIiwiaGFzQ3VzdG9tQ2xhc3MiLCJ0ZXh0YXJlYUNsYXNzIiwiZmllbGRDb250cm9sIiwicm93cyIsIlVwbG9hZHMiLCJidWlsZGVyQWN0aW9ucyIsInVwZGF0ZUFuc3dlciIsIm1lZGlhIiwiYnV0dG9uIiwiaW1hZ2VVcmwiLCJmaXJzdCIsInRvSlNPTiIsImltYWdlU2l6ZSIsInNpemVzIiwidGh1bWJuYWlsIiwidXJsIiwibWVkaXVtIiwiZnVsbCIsImxhcmdlIiwiZmlsZW5hbWUiLCJhbHQiLCJoYXNWYWx1ZUNsYXNzIiwicHJldmlldyIsImJnSW1hZ2UiLCJvcGVuTWVkaWEiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJjbGVhckltYWdlIiwicmVuZGVyQmxvY2siLCJjb250YWluZXJJZCIsImNvbnRhaW5lciIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJzZW12ZXIiLCJndGUiLCJ2ZXJzaW9uIiwicm9vdCIsInJlbmRlciIsIkRhdGVQaWNrZXIiLCJoYXNXb3JkRm9ybWF0IiwiZGF0ZUZvcm1hdCIsImRhdGVwaWNrZXIiLCJiZWZvcmVTaG93IiwiaW5wdXQiLCJpbnN0IiwiYWRkQ2xhc3MiLCJwYXN0X2RhdGVzIiwiZGF5TmFtZXNNaW4iLCJmb3JtaW5hdG9ybDEwbiIsImNhbGVuZGFyIiwiZGF5X25hbWVzX21pbiIsIm1vbnRoTmFtZXMiLCJtb250aF9uYW1lcyIsIm9uU2VsZWN0IiwiZ2V0VGltZSIsImNhbGVuZGFySWNvbiIsIm1lZGl1bVNpemUiLCJpY29uQnV0dG9uIiwiY2FuQWRkIiwiZGF0ZUlucHV0Iiwib25seVJlYWQiLCJkaXNwbGF5IiwiZGF0ZUZpZWxkIiwibm9DYWxlbmRhciIsIm11bHRpRGF0ZSIsIlJhZGlvT3B0aW9ucyIsInJhZGlvQ2xhc3MiLCJyYWRpb09wdGlvbnMiLCJvcHRpb25JbWFnZSIsIm9wdGlvbkxhYmVsIiwiaW1hZ2UxeCIsImltYWdlMngiLCJpbWFnZXNVcmwiLCJoYXNJbWFnZSIsInJhZGlvQ29udGVudCIsIkFjZUVkaXRvciIsImluc2VydFNlbGVjdG9yIiwiYWNlIiwiZWRpdCIsInNlc3Npb24iLCJnZXRTZXNzaW9uIiwic2V0VXNlV29ya2VyIiwic2V0U2hvd1ByaW50TWFyZ2luIiwic2V0TW9kZSIsInNldFRoZW1lIiwicmVuZGVyZXIiLCJzZXRTaG93R3V0dGVyIiwic2V0SGlnaGxpZ2h0QWN0aXZlTGluZSIsImZvY3VzIiwiZGVzdHJveSIsInNlbGVjdG9yIiwibmF2aWdhdGVGaWxlRW5kIiwiaW5zZXJ0IiwibmF2aWdhdGVMZWZ0IiwiZ2V0VmFsdWUiLCJiYXNpY1NlbGVjdG9ycyIsInBvbGxTZWxlY3RvcnMiLCJxdWl6U2VsZWN0b3JzIiwicGRmU2VsZWN0b3JzIiwiaGVpZ2h0Iiwic2hvd01vZGFsIiwibW9kYWxQcm9wcyIsIm1vZGFsVHlwZSIsImRpc3BhdGNoIiwiaGlkZU1vZGFsIiwic2V0dGluZyIsImZvcm1pbmF0b3JDaGFuZ2VzIiwidXBkYXRlU2V0dGluZ3MiLCJzYXZlQnVpbGRlciIsInNhdmVkIiwiTWV0YURyb3Bkb3duIiwiTWV0YURhdGEiLCJmb3JtIiwic2hvcnRjb2RlIiwicHJvY2Vzc0FjdGlvbiIsImFkbWluVXJsIiwicHJvY2Vzc05vbmNlIiwiZm9ybVByb2Nlc3NOb25jZSIsImV4cG9ydE5vbmNlIiwiZm9ybUV4cG9ydE5vbmNlIiwic3VibWlzc2lvbnMiLCJkcm9wZG93bkxhYmVsIiwicG9sbCIsInBvbGxQcm9jZXNzTm9uY2UiLCJwb2xsRXhwb3J0Tm9uY2UiLCJxdWl6IiwicXVpelByb2Nlc3NOb25jZSIsInF1aXpFeHBvcnROb25jZSIsImNvcHlUb0NsaXBib2FyZCIsInJlc2V0VHJhY2tpbmdEYXRhIiwiZXhlY0NvbW1hbmQiLCJjdXN0b20iLCJhY3Rpb24iLCJfYWpheF9ub25jZSIsInJlc2V0VHJhY2tpbmdEYXRhTm9uY2UiLCJhamF4IiwicG9zdCIsImFqYXhVcmwiLCJkb25lIiwic3VjY2VzcyIsImV4cG9ydFVybCIsImRlbGV0ZVVybCIsInRvcCIsImhhc0xlYWQiLCJjbG9uZU5vbmNlIiwiZGFzaGJvYXJkVXJsIiwiRm9jdXNUcmFwIiwicHJldmlvdXNseUZvY3VzZWRFbGVtZW50IiwiYWN0aXZlRWxlbWVudCIsInNwZWNpZmllZEZvY3VzVHJhcE9wdGlvbnMiLCJmb2N1c1RyYXBPcHRpb25zIiwidGFpbG9yZWRGb2N1c1RyYXBPcHRpb25zIiwicmV0dXJuRm9jdXNPbkRlYWN0aXZhdGUiLCJmYWxsYmFja0ZvY3VzIiwib3B0aW9uTmFtZSIsImhhc093blByb3BlcnR5IiwiZm9jdXNUcmFwRWxlbWVudERPTU5vZGUiLCJSZWFjdERPTSIsImZpbmRET01Ob2RlIiwiZm9jdXNUcmFwRWxlbWVudCIsImZvY3VzVHJhcCIsIl9jcmVhdGVGb2N1c1RyYXAiLCJhY3RpdmF0ZSIsInBhdXNlZCIsInBhdXNlIiwicHJldlByb3BzIiwicmV0dXJuRm9jdXMiLCJjb25maWciLCJkZWFjdGl2YXRlIiwidW5wYXVzZSIsIm9ubHkiLCJjb21wb3NlZFJlZkNhbGxiYWNrIiwic2V0Rm9jdXNUcmFwRWxlbWVudCIsInJlZiIsImNoaWxkV2l0aFJlZiIsImNsb25lRWxlbWVudCIsImRlZmF1bHRQcm9wcyIsImNyZWF0ZUZvY3VzVHJhcCIsIm1vZHVsZSIsImV4cG9ydHMiLCIkIiwicGx1Z2luTmFtZSIsIkZvcm1pbmF0b3JJbnRlZ3JhdGlvbnNNb2RhbCIsImFkZG9ucyIsIiRwb3B1cCIsIl9kZWZlcnJlZCIsInByb3RvdHlwZSIsIm1lIiwiJHRhcmdldCIsImNsb3NlQ2xpY2siLCJjbG9zZSIsIm5vbmNlIiwiZ2xvYmFsX2lkIiwiaW1hZ2UiLCJmb3JtX2lkIiwibXVsdGlfaWQiLCJwb2xsX2lkIiwicXVpel9pZCIsInRwbCIsInRlbXBsYXRlIiwidmlld09wdGlvbnMiLCJ2aWV3IiwiRm9ybWluYXRvckludGVncmF0aW9ucyIsIm9wZW5Nb2RhbCIsIkRlZmVycmVkIiwicHJvbWlzZSIsImNsb3NlTW9kYWwiLCJyZXNvbHZlIiwiZm4iLCJ0YWdOYW1lIiwiZXZlbnRzIiwibmV4dF9zdGVwIiwicHJldl9zdGVwIiwic2Nyb2xsYmFyX3dpZHRoIiwiZ2V0U2Nyb2xsYmFyV2lkdGgiLCJtb2R1bGVfaWQiLCJjdXJyZW50X3N0ZXAiLCJnZXRBamF4TW9kdWxlRGF0YSIsInJlcXVlc3QiLCIkZWxlbWVudCIsInJlbW92ZUNsYXNzIiwibG9hZGVyIiwiZnVuY3Rpb25fcGFyYW1zIiwiYXBwbHlMb2FkZXIiLCJyZW5kZXJCb2R5IiwicmVuZGVyRm9vdGVyIiwicmVzdWx0RGF0YSIsIm9uUmVuZGVyIiwicmVzZXRMb2FkZXIiLCJpc19jbG9zZSIsIm5vdGlmaWNhdGlvbiIsImhhc19iYWNrIiwiaGlkZSIsInNpemUiLCJpc19wb2xsIiwiJHBvcHVwQm94IiwiJHBvcHVwQm94SGVpZ2h0IiwiJHdpbmRvd0hlaWdodCIsImdyb3VwIiwiYWx3YXlzIiwiaW50ZWdyYXRpb25IZWFkZXIiLCJidXR0b25zIiwibWFya3VwIiwiZm9ybWluYXRvcl9hZGRvbl9jdXJyZW50X3N0ZXAiLCJmb3JtaW5hdG9yX2FkZG9uX2hhc19uZXh0X3N0ZXAiLCJmb3JtaW5hdG9yX2FkZG9uX2hhc19wcmV2X3N0ZXAiLCJhYm9ydCIsImFqYXh1cmwiLCIkc2VsZWN0Iiwic2libGluZ3MiLCJnZXRQYXJlbnQiLCJnZXRQYXJlbnRJZCIsInNlbGVjdFBhcmVudCIsImlzU21hbGwiLCJmYWlsIiwibW9kdWxlX3R5cGUiLCJmb3JtRGF0YSIsInNlcmlhbGl6ZSIsInBhcmFtIiwiYWZ0ZXIiLCJnZXRTdGVwIiwiZ2V0UHJldlN0ZXAiLCJnZXRBamF4TW9kdWxlQWN0aW9uIiwic2Nyb2xsYmFyV2lkdGgiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCIkdGV4dGFyZWExIiwibGVmdCIsImFwcGVuZFRvIiwiJHRleHRhcmVhMiIsImFkZCIsIiRkaXYiLCJvdmVyZmxvdyIsInByZXBlbmRUbyIsIndpdGhfbXVsdGlfaWQiLCJCYWNrYm9uZSIsIlZpZXciLCJTZWN1cml0eUJlaGF2aW91ciIsImN1cnJlbnRGb3JtIiwic3BlY2lhbEZvcm1UeXBlcyIsImlzRGlzYWJsZUZvcm0iLCJha2lzbWV0RW5hYmxlZCIsIm1vZHVsZVNsdWciLCJjb21wb25lbnRzIiwidXBkYXRlQW5zd2VycyIsImhhbmRsZUNoYW5nZSIsImNvbnNvbGUiLCJsb2ciLCJwZXJtaXNzaW9uX3R5cGUiLCJ1c2VyX2luZm8iLCJ1c2VySW5mb3MiLCJlbWFpbCIsInByZXZTdGF0ZSIsInVzZXJfcm9sZSIsInVwZGF0ZVRpdGxlIiwiVVBEQVRFX1RJVExFIiwic3RvcmUiLCJzZXRMb2NhbGUiLCJsb2NhbGUiLCJNYWluIiwiY29uZmlndXJlU3RvcmUiLCJuZXdDcmVhdGVTdG9yZSIsInRodW5rIiwiY3JlYXRlU3RvcmUiLCJpbml0aWFsU3RhdGUiLCJhcHBSZWR1Y2VycyIsIm1vZGFsIiwiYW5zd2VySW5kZXgiLCJmaW5kSW5kZXgiLCJhbnN3ZXJPYmoiLCJmb3JtTmFtZSIsIm5ld1N0YXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImhhbmRsZUJlZm9yZXVubG9hZCIsImFwcGx5U3RpY2t5IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm5vZGUiLCJyZWZzIiwiU3RpY2t5SGVhZGVyIiwiY3VycmVudE9mZnNldCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInN0aWNreU9mZnNldCIsImdldENvbXB1dGVkU3R5bGUiLCJpc1N0dWNrIiwiY2xhc3NMaXN0IiwicmV0dXJuVmFsdWUiLCJCdWlsZGVyIiwiQXBwZWFyYW5jZSIsIkJlaGF2aW91ciIsIk5vdGlmaWNhdGlvbnMiLCJJbnRlZ3JhdGlvbnMiLCJTZXR0aW5ncyIsIm1vZGFsQWN0aW9ucyIsIm5hdmlnYXRpb25BY3Rpb25zIiwibWFwU3RhdGVUb1Byb3BzIiwibWFwRGlzcGF0Y2hUb1Byb3BzIiwiSGVhZGVyIiwiRG9jdW1lbnRhdGlvbiIsInNob3dEb2NMaW5rIiwiVGl0bGUiLCIkbW9kdWxlTmFtZSIsIiRwYWdlSGVhZGVyIiwiJHBhZ2VUaXRsZSIsIiR0aXRsZVdpZHRoIiwiJG5hdldpZHRoIiwiZW1wdHlUaXRsZSIsIk1vZGFsIiwiTU9EQUxfVFlQRVMiLCJtb2RhbFR5cGVzIiwicHJldmlld01vZGFsIiwicHVibGlzaCIsInB1Ymxpc2hNb2RhbCIsInNob3J0Y29kZU1vZGFsIiwiZGVsZXRlIiwiZGVsZXRlTW9kYWwiLCJtb2RhbEVsZW1lbnQiLCJmb2N1c0FmdGVyQ2xvc2VkIiwiZm9jdXNGaXJzdCIsInNldEZvY3VzIiwiaGlkZU1vZGFsVGltZW91dCIsInNldEF0dHJpYnV0ZSIsImZvcmNlVXBkYXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiZm9jdXNJbnRlcnZhbCIsImZvY3VzVG90YWxSZXBldGl0aW9ucyIsImJsdXIiLCJmb2N1c1JlcGV0aXRpb25zIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJjbGVhclRpbWVvdXQiLCJtb2RhbENsYXNzIiwib3ZlcmxheUNsYXNzIiwiU3BlY2lmaWVkTW9kYWwiLCJjbGFzc2VzIiwiam9pbiIsImxhYmVsbGVkQnkiLCJkZXNjcmliZWRCeSIsIkRpc3BsYWNlZE1vZGFsIiwicmVuZGVyVG8iLCJwcmV2aWV3TG9hZGVkIiwiJGJvZHkiLCJib2R5IiwibW91bnRlZCIsImxvYWQiLCJwcmV2aWV3Tm9uY2UiLCJyZW5kZXJfaWQiLCJpc19wcmV2aWV3IiwicHJldmlld19kYXRhIiwibGFzdF9zdWJtaXRfZGF0YSIsImZvcm1pbmF0b3JMb2FkZXIiLCJzaG93QnJhbmRpbmciLCJ0cmFzaEZpZWxkIiwic3RhdHVzIiwiZm9ybV9zdGF0dXMiLCJjaGFuZ2VkIiwiTWV0YSIsInB1Ymxpc2hMb2FkaW5nIiwiZHJhZnRMb2FkaW5nIiwiZHJhZnQiLCJmb3JtTmFtZVZhbHVlIiwiZm9ybUlkIiwiX3dwbm9uY2UiLCJmb3JtTm9uY2UiLCJzYXZlIiwiaGFzRW1wdHkiLCJvYmplY3QiLCJuZXdTdGF0dXMiLCJpc1B1Ymxpc2giLCJ2b3RlX2xpbWl0X2lucHV0IiwiY2xvc2VQb3B1cCIsImF4aW9zIiwicXMiLCJ0aGVuIiwiaGlzdG9yeSIsInB1c2hTdGF0ZSIsInBvbGxFZGl0VXJsIiwiY2F0Y2giLCJlcnIiLCJTdGF0dXMiLCJjbGFzc1R5cGUiLCJpc0xvYWRpbmciLCJCdXR0b25zIiwiYm9yZGVyQ29sb3IiLCJQcmV2aWV3IiwiTmF2aWdhdGlvbiIsIk1lbnUiLCJnb1RvU2VjdGlvbiIsIk1vYmlsZVNlbGVjdCIsInN1Ym1pdERhdGEiLCJhbmltYXRlIiwic2Nyb2xsVG9wIiwiRGV0YWlscyIsIkFuc3dlcnMiLCJhZGRBbnN3ZXIiLCJtb3ZlT3B0aW9uIiwic29ydGFibGUiLCJzdG9wIiwidG8iLCJmcm9tIiwic3BsaWNlIiwibmV3QW5zd2VyIiwiQW5zd2VyIiwiZGVsZXRlRmllbGQiLCJjbG9zZURlbGV0ZUZpZWxkIiwidXBkYXRlSW1hZ2UiLCJ1c2VfZXh0cmEiLCJjbG9zZU1lbnUiLCJhbnN3ZXJzT2JqIiwiZ2V0QW5zd2Vyc1dpdGhvdXRDdXJyZW50IiwiaGFzVGl0bGUiLCJ2YWxpZGF0aW9uQ2xhc3MiLCJlbmFibGVfaW1hZ2VzIiwidXBkYXRlRXh0cmEiLCJhZGRFeHRyYSIsInJlbW92ZUV4dHJhIiwiZW5hYmxlSW1hZ2VzIiwiRGVzaWduU3R5bGUiLCJEZXNpZ25EZWZhdWx0IiwiRGVzaWduRmxhdCIsIkRlc2lnbkJvbGQiLCJEZXNpZ25NYXRlcmlhbCIsIkRlc2lnbkJhc2ljIiwiRGVzaWduTm9uZSIsIkNvbG9ycyIsIkNvbnRhaW5lckNvbG9ycyIsIlN1Y2Nlc3NDb2xvcnMiLCJFcnJvckNvbG9ycyIsIkNvbnRlbnRDb2xvcnMiLCJSYWRpb0ltYWdlc0NvbG9ycyIsIklucHV0Q29sb3JzIiwiU3VibWl0Q29sb3JzIiwiTGlua3NDb2xvcnMiLCJDaGFydENvbG9ycyIsIkFuc3dlckNvbG9yIiwiZGVmYXVsdENvbG9yIiwicG9sbEFuc3dlckNvbG9ycyIsIk9wdGlvbnNMYXlvdXQiLCJGaWVsZEltYWdlU2l6ZSIsInBhZGRpbmdDdXN0b20iLCJib3JkZXJDdXN0b20iLCJzcGFjaW5nQ3VzdG9tIiwiQ3VzdG9tQ3NzIiwiUmVzdWx0c0Rpc3BsYXkiLCJyZXN1bHRTdHlsZSIsIlZvdGVDb3VudCIsIlN1Yk1ldGhvZCIsIk9wZW5pbmciLCJEYXRlVGltZVBpY2tlciIsInVwZGF0ZURhdGVWYWx1ZSIsInVwZGF0ZUhvdXJWYWx1ZSIsInVwZGF0ZU1pbnV0ZVZhbHVlIiwidXBkYXRlQW1QbVZhbHVlIiwiZCIsImgiLCJnZXRIb3VycyIsInNldERhdGEiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJnZXRGdWxsWWVhciIsImxlYWRpbmdaZXJvIiwiZ2V0TWludXRlcyIsImFtcG0iLCJmdWxsVmFsdWUiLCJnZXREYXRhIiwidXBkYXRlRGF0YSIsIm51bSIsInMiLCJob3Vyc01heCIsImhvdXJGaXgiLCJwcmVmaWV4IiwieCIsIkxpbWl0cyIsIlJlbmRlckJlaGF2aW91ciIsInN0cm9uZyIsIkFkbWluRW1haWwiLCJuYW1lT3B0aW9ucyIsInZhcmlhYmxlcyIsInRhZ3MiLCJ0b2tlblNlcGFyYXRvcnMiLCJsYW5ndWFnZSIsInNlYXJjaGluZyIsIm5vUmVzdWx0cyIsImRlbGF5Iiwic2VhcmNoTm9uY2UiLCJxIiwidGVybSIsInBlcm1pc3Npb24iLCJwcm9jZXNzUmVzdWx0cyIsInJlc3VsdHMiLCJjYWNoZSIsInRlbXBsYXRlUmVzdWx0IiwiZGlzcGxheV9uYW1lIiwiY3JlYXRlVGFnIiwiaW5zZXJ0VGFnIiwidGFnIiwiZnJvbUVtYWlsT3B0aW9ucyIsImdldEVtYWlsT3B0aW9ucyIsInVuc2hpZnQiLCJmcm9tRW1haWxPcHRpb25zVmFsdWVzIiwib3B0Iiwic2F2ZWRGcm9tQWRkcmVzcyIsInJlcGx5VG9BZGRyZXNzT3B0aW9ucyIsImVtYWlsT3B0aW9uc1ZhbHVlcyIsInNhdmVkQWRkcmVzcyIsImZyb21BZGRyZXNzT3B0aW9ucyIsImdldE5hbWVPcHRpb25zIiwiZ2V0QXV0b0NyZWF0ZUVtYWlsQWRkcmVzc09wdGlvbnMiLCJnZXRGcm9tQWRkcmVzc09wdGlvbnMiLCJnZXRSZWNpcGllbnRUYWdzT3B0aW9ucyIsImdldFJlcGx5VG9BZGRyZXNzT3B0aW9ucyIsImdldENjQmNjT3B0aW9ucyIsInBvbGxfbmFtZSIsInBvbGxfYW5zd2VyIiwicG9sbF9yZXN1bHQiLCJsb2FkaW5nIiwibG9hZEludGVncmF0aW9ucyIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImFkZG9uTm9uY2UiLCJyZXNwb25zZSIsImpzb24iLCIkYWRkb25zIiwiX19odG1sIiwiRGF0YVN0b3JhZ2UiLCJQcml2YWN5IiwiaXBSZXRhaW5Gb3JldmVyIiwicG9sbF9pcF9yZXRhaW5fbnVtYmVyIiwiaXBSZXRhaW5EZWZhdWx0IiwicG9sbF9pcF9yZXRhaW5fdW5pdCIsInN1Ym1pc3Npb25zUmV0YWluRm9yZXZlciIsInN1Ym1pc3Npb25zX2lwX3JldGFpbl9udW1iZXIiLCJzdWJtaXNpb25zUmV0YWluRGVmYXVsdCIsInN1Ym1pc3Npb25zX2lwX3JldGFpbl91bml0IiwiY2FuTWFuYWdlU2V0dGluZ3MiLCJ1c2VyUGVybWlzc2lvbnMiLCJtYW5hZ2VfZm9ybWluYXRvcl9zZXR0aW5ncyIsIm1hbmFnZV9vcHRpb25zIiwic2V0dGluZ3NVcmwiLCJhcmdzIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM3REEsdUI7Ozs7Ozs7Ozs7Ozs7OztRQ01nQkEsVSxHQUFBQSxVO1FBWUFDLGlCLEdBQUFBLGlCO1FBWUFDLFUsR0FBQUEsVTtRQW1CQUMsZSxHQUFBQSxlO1FBVUFDLGMsR0FBQUEsYztRQTZCQUMscUIsR0FBQUEscUI7UUFVQUMsVyxHQUFBQSxXO1FBU0FDLHNCLEdBQUFBLHNCO1FBZ0JBQyxpQixHQUFBQSxpQjtRQXNCQUMsYyxHQUFBQSxjO1FBa0NBQyxRLEdBQUFBLFE7UUEwQkFDLGEsR0FBQUEsYTtRQXdCQUMsWSxHQUFBQSxZO1FBMEJBQyxlLEdBQUFBLGU7UUFzQkFDLGUsR0FBQUEsZTtRQTRCQUMsYSxHQUFBQSxhO1FBb0JBQyxVLEdBQUFBLFU7UUF5QkFDLGdCLEdBQUFBLGdCO1FBcUJBQyx3QixHQUFBQSx3QjtRQWlDQUMsWSxHQUFBQSxZO1FBZUFDLGtCLEdBQUFBLGtCO1FBYUFDLGdCLEdBQUFBLGdCO1FBYUFDLGlCLEdBQUFBLGlCO1FBV0FDLFMsR0FBQUEsUztRQVlBQyxlLEdBQUFBLGU7UUFrQkFDLE8sR0FBQUEsTztRQVNBQyxpQixHQUFBQSxpQjtRQXlDQUMsZ0IsR0FBQUEsZ0I7UUFrQkFDLFMsR0FBQUEsUztRQWtGQUMsYSxHQUFBQSxhO1FBMEdBQyxhLEdBQUFBLGE7UUEwRkFDLG9CLEdBQUFBLG9CO1FBNEJBQyxjLEdBQUFBLGM7UUFXQUMsYSxHQUFBQSxhO1FBUUFDLFksR0FBQUEsWTtRQVdBQyxlLEdBQUFBLGU7UUFXQUMsYyxHQUFBQSxjO1FBZ0JBQyxnQixHQUFBQSxnQjtRQW9GQUMsYSxHQUFBQSxhO1FBZ0VBQyx5QixHQUFBQSx5QjtRQTBCQUMsWSxHQUFBQSxZO1FBeURBQyxTLEdBQUFBLFM7UUE2Q0FDLGlCLEdBQUFBLGlCO1FBa0RBQyxZLEdBQUFBLFk7UUFtQkFDLG9CLEdBQUFBLG9CO1FBbUJBQyxXLEdBQUFBLFc7UUE2QkFDLGUsR0FBQUEsZTtRQXdDQUMscUIsR0FBQUEscUI7UUFxQkFDLCtCLEdBQUFBLCtCO1FBK0JBQyx1QixHQUFBQSx1QjtRQWdDQUMsaUIsR0FBQUEsaUI7UUF3RUFDLE0sR0FBQUEsTTtRQTBCQUMsZ0IsR0FBQUEsZ0I7UUFpQkFDLFEsR0FBQUEsUTs7QUE3Z0RoQjs7Ozs7Ozs7QUFDQTs7Ozs7QUFLTyxTQUFTckQsVUFBVCxHQUFzQjtBQUM1QjtBQUNBLEtBQUlzRCxNQUFNQyxLQUFLQyxJQUFMLENBQVcsSUFBWCxDQUFWO0FBQ0EsS0FBSUMsTUFBTUYsS0FBS0csS0FBTCxDQUFZLElBQVosQ0FBVjtBQUNBLFFBQU9ILEtBQUtHLEtBQUwsQ0FBWUgsS0FBS0ksTUFBTCxNQUFrQkYsTUFBTUgsR0FBeEIsSUFBZ0NBLEdBQTVDLENBQVA7QUFDQTs7QUFFRDs7Ozs7QUFLTyxTQUFTckQsaUJBQVQsR0FBNkI7QUFDbkMsUUFBTyxhQUFhRCxZQUFiLEdBQTRCLEdBQTVCLEdBQWtDQSxZQUF6QztBQUNBOztBQUVEOzs7Ozs7OztBQVFPLFNBQVNFLFVBQVQsQ0FBcUIwRCxTQUFyQixFQUFnQ0MsUUFBaEMsRUFBMkM7QUFDakQsS0FBSUMsc0JBQUo7O0FBRUFELFVBQVNFLEdBQVQsQ0FBYyxtQkFBVztBQUN4QixNQUFLQyxRQUFRQyxVQUFSLEtBQXVCTCxTQUE1QixFQUF3QztBQUN2Q0UsbUJBQWdCRSxPQUFoQjtBQUNBO0FBQ0QsRUFKRDs7QUFNQSxRQUFPRixhQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7QUFPTyxTQUFTM0QsZUFBVCxDQUEwQitELEtBQTFCLEVBQWlDL0QsZUFBakMsRUFBbUQ7QUFDekQsUUFBT2dFLGFBQWNELEtBQWQsTUFBMEIsT0FBMUIsR0FBb0MvRCxlQUFwQyxHQUFzRCxFQUE3RDtBQUNBOztBQUVEOzs7Ozs7QUFNTyxTQUFTQyxjQUFULENBQXlCOEQsS0FBekIsRUFBaUM7QUFDdkMsUUFBT0MsYUFBY0QsS0FBZCxNQUEwQixPQUExQixHQUFvQyxRQUFwQyxHQUErQyxFQUF0RDtBQUNBOztBQUVEOzs7Ozs7QUFNQSxTQUFTQyxZQUFULENBQXVCRCxLQUF2QixFQUErQjtBQUM5QixLQUFLLGdCQUFnQixPQUFPQSxNQUFNRSxVQUFsQyxFQUErQztBQUM5QyxTQUFPRixNQUFNRSxVQUFiO0FBQ0E7O0FBRUQsS0FBSyxnQkFBZ0IsT0FBT0YsTUFBTUcsUUFBN0IsSUFBeUMsZ0JBQWdCLE9BQU9ILE1BQU1HLFFBQU4sQ0FBZSx3QkFBZixDQUFyRSxFQUNDLE9BQU9ILE1BQU1HLFFBQU4sQ0FBZSx3QkFBZixDQUFQOztBQUVELEtBQUssZ0JBQWdCLE9BQU9ILE1BQU1JLFVBQWxDLEVBQ0MsT0FBT0osTUFBTUksVUFBYjs7QUFFRCxRQUFPLEVBQVA7QUFDQTs7QUFFRDs7Ozs7QUFLTyxTQUFTakUscUJBQVQsR0FBaUM7QUFDdkMsUUFBTyxDQUFFLFlBQUYsRUFBZ0IsUUFBaEIsRUFBMEIsUUFBMUIsRUFBb0MsV0FBcEMsRUFBaUQsU0FBakQsRUFBNEQsVUFBNUQsRUFBd0UsT0FBeEUsQ0FBUDtBQUNBOztBQUVEOzs7Ozs7QUFNTyxTQUFTQyxXQUFULEdBQXVCO0FBQzdCLFFBQU8sQ0FBRSxnQkFBRixFQUFvQixlQUFwQixDQUFQO0FBQ0E7O0FBRUQ7Ozs7O0FBS08sU0FBU0Msc0JBQVQsR0FBa0M7QUFDeEMsUUFBTztBQUNOLHdCQUFzQmdCLFVBQVcsZ0JBQVgsQ0FEaEI7QUFFTix3QkFBc0JBLFVBQVcsd0JBQVgsQ0FGaEI7QUFHTixvQkFBa0JBLFVBQVcsV0FBWDtBQUhaLEVBQVA7QUFLQTs7QUFFRDs7Ozs7Ozs7QUFRTyxTQUFTZixpQkFBVCxDQUE0QitELElBQTVCLEVBQWtDVixRQUFsQyxFQUE2QztBQUNuRCxLQUFJVyxVQUFVLENBQWQ7O0FBRUFYLFVBQVNFLEdBQVQsQ0FBYyxtQkFBVztBQUN4QkMsVUFBUVMsTUFBUixDQUFlVixHQUFmLENBQW9CLGlCQUFTO0FBQzVCLE9BQUtXLE1BQU1ILElBQU4sS0FBZUEsSUFBcEIsRUFBMkI7QUFDMUJDO0FBQ0E7QUFDRCxHQUpEO0FBS0EsRUFORDs7QUFRQSxRQUFPQSxPQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7O0FBUU8sU0FBUy9ELGNBQVQsQ0FBeUI4RCxJQUF6QixFQUErQlYsUUFBL0IsRUFBMEM7QUFDaEQsS0FBTWMsV0FBVyxFQUFqQjs7QUFFQWQsVUFBU0UsR0FBVCxDQUFjLG1CQUFXO0FBQ3hCQyxVQUFRUyxNQUFSLENBQWVWLEdBQWYsQ0FBb0IsaUJBQVM7QUFDNUIsT0FBS1csTUFBTUgsSUFBTixLQUFlQSxJQUFwQixFQUEyQjtBQUMxQixRQUFNSyxVQUFVRixNQUFNRyxVQUF0QjtBQUNBLFFBQU1DLGVBQWVGLFFBQVFHLEtBQVIsQ0FBZSxHQUFmLENBQXJCO0FBQ0EsWUFBU0wsTUFBTUgsSUFBZjtBQUNDLFVBQUssWUFBTDtBQUNBLFVBQUssV0FBTDtBQUNDSSxlQUFTSyxJQUFULENBQWVDLFNBQVVILGFBQWMsQ0FBZCxDQUFWLENBQWY7QUFDQTtBQUNELFVBQUssZUFBTDtBQUNBLFVBQUssZ0JBQUw7QUFDQ0gsZUFBU0ssSUFBVCxDQUFlQyxTQUFVSCxhQUFjLENBQWQsQ0FBVixDQUFmO0FBQ0E7QUFDRDtBQUNDSCxlQUFTSyxJQUFULENBQWVDLFNBQVVILGFBQWMsQ0FBZCxDQUFWLENBQWY7QUFDQTtBQVhGO0FBYUE7QUFDRCxHQWxCRDtBQW1CQSxFQXBCRDs7QUFzQkEsS0FBSUksV0FBVyxDQUFmOztBQUVBLEtBQUssQ0FBRUMsRUFBRUMsT0FBRixDQUFXVCxRQUFYLENBQVAsRUFBK0I7QUFDOUJPLGFBQVdDLEVBQUUxQixHQUFGLENBQU9rQixRQUFQLENBQVg7QUFDQTs7QUFFRCxRQUFPTSxTQUFVQyxRQUFWLElBQXVCLENBQTlCO0FBQ0E7O0FBRU0sU0FBU3hFLFFBQVQsQ0FBbUI2RCxJQUFuQixFQUF5QmMsTUFBekIsRUFBa0M7QUFDeEMsS0FBTUMsTUFBTSxFQUFaOztBQUVBSCxHQUFFcEIsR0FBRixDQUFPc0IsTUFBUCxFQUFlLGlCQUFTO0FBQ3ZCLE1BQU1ULFVBQVVXLE1BQU1WLFVBQXRCO0FBQ0EsTUFBTUMsZUFBZUYsUUFBUUcsS0FBUixDQUFlLEdBQWYsQ0FBckI7O0FBRUFPLE1BQUlOLElBQUosQ0FBVUMsU0FBVUgsYUFBYyxDQUFkLENBQVYsQ0FBVjtBQUNBLEVBTEQ7O0FBT0EsS0FBSUksV0FBVyxDQUFmOztBQUVBLEtBQUssQ0FBRUMsRUFBRUMsT0FBRixDQUFXRSxHQUFYLENBQVAsRUFBMEI7QUFDekJKLGFBQVdDLEVBQUUxQixHQUFGLENBQU82QixHQUFQLENBQVg7QUFDQTs7QUFFRCxRQUFPTCxTQUFVQyxRQUFWLElBQXVCLENBQTlCO0FBQ0E7O0FBRUQ7Ozs7Ozs7QUFPTyxTQUFTdkUsYUFBVCxDQUF3QjRFLEtBQXhCLEVBQWdDO0FBQ3RDQSxTQUFRQSxNQUFNQyxJQUFOLEdBQWFDLE9BQWIsQ0FBc0IsU0FBdEIsRUFBaUMsR0FBakMsQ0FBUjs7QUFFQSxRQUFPRixLQUFQO0FBQ0E7O0FBRUQ7Ozs7OztBQU1BLFNBQVNHLGNBQVQsQ0FBeUI3QixRQUF6QixFQUFvQztBQUNuQyxRQUFPLFNBQVNBLFFBQWhCO0FBQ0E7O0FBRUQ7Ozs7Ozs7O0FBUU8sU0FBU2pELFlBQVQsQ0FBdUIyRCxJQUF2QixFQUE2QlYsUUFBN0IsRUFBd0M7QUFDOUMsS0FBSVcsVUFBVSxDQUFkOztBQUVBLEtBQUtrQixlQUFnQjdCLFFBQWhCLENBQUwsRUFBa0M7QUFDakMsU0FBTyxJQUFQO0FBQ0E7O0FBRURBLFVBQVNFLEdBQVQsQ0FBYyxtQkFBVztBQUN4QkMsVUFBUVMsTUFBUixDQUFlVixHQUFmLENBQW9CLGlCQUFTO0FBQzVCLE9BQUtXLE1BQU1ILElBQU4sS0FBZUEsSUFBcEIsRUFBMkI7QUFDMUJDO0FBQ0E7QUFDRCxHQUpEO0FBS0EsRUFORDs7QUFRQSxRQUFPQSxVQUFVLENBQWpCO0FBQ0E7O0FBRUQ7Ozs7Ozs7O0FBUU8sU0FBUzNELGVBQVQsQ0FBMEIwRCxJQUExQixFQUFnQ1YsUUFBaEMsRUFBMkM7QUFDakQsS0FBTVksU0FBUyxFQUFmOztBQUVBWixVQUFTRSxHQUFULENBQWMsbUJBQVc7QUFDeEJDLFVBQVFTLE1BQVIsQ0FBZVYsR0FBZixDQUFvQixpQkFBUztBQUM1QixPQUFLVyxNQUFNSCxJQUFOLEtBQWVBLElBQXBCLEVBQTJCO0FBQzFCRSxXQUFPTyxJQUFQLENBQWFOLEtBQWI7QUFDQTtBQUNELEdBSkQ7QUFLQSxFQU5EOztBQVFBLFFBQU9ELE1BQVA7QUFDQTs7QUFFRDs7Ozs7Ozs7QUFRTyxTQUFTM0QsZUFBVCxDQUEwQnlELElBQTFCLEVBQWdDVixRQUFoQyxFQUEyQztBQUNqRCxLQUFNWSxTQUFTLEVBQWY7QUFDQSxLQUFNa0IsZUFBZTlFLGdCQUFpQjBELElBQWpCLEVBQXVCVixRQUF2QixDQUFyQjtBQUNBOEIsY0FBYTVCLEdBQWIsQ0FBa0IsaUJBQVM7QUFDMUIsTUFBSTZCLFFBQVFsQixNQUFNbUIsV0FBbEI7O0FBRUEsTUFBS3RCLFNBQVMsU0FBZCxFQUEwQjtBQUN6QnFCLFdBQVFsQixNQUFNRyxVQUFkO0FBQ0E7O0FBRURKLFNBQU9PLElBQVAsQ0FBYTtBQUNaTyxVQUFPYixNQUFNRyxVQUREO0FBRVplLFVBQU9BLEtBRks7QUFHWmYsZUFBWUgsTUFBTUc7QUFITixHQUFiO0FBS0EsRUFaRDs7QUFjQSxRQUFPSixNQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7O0FBUU8sU0FBUzFELGFBQVQsQ0FBd0IrRSxFQUF4QixFQUE0QmpDLFFBQTVCLEVBQXVDO0FBQzdDLEtBQUkrQixRQUFRLEVBQVo7QUFDQS9CLFVBQVNFLEdBQVQsQ0FBYyxtQkFBVztBQUN4QkMsVUFBUVMsTUFBUixDQUFlVixHQUFmLENBQW9CLGlCQUFTO0FBQzVCLE9BQUtXLE1BQU1HLFVBQU4sS0FBcUJpQixFQUExQixFQUErQjtBQUM5QkYsWUFBUWxCLE1BQU1tQixXQUFkO0FBQ0E7QUFDRCxHQUpEO0FBS0EsRUFORDs7QUFRQSxRQUFPRCxLQUFQO0FBQ0E7QUFDRDs7Ozs7Ozs7QUFRTyxTQUFTNUUsVUFBVCxDQUFxQjhFLEVBQXJCLEVBQXlCakMsUUFBekIsRUFBb0M7QUFDMUMsS0FBSWtDLFFBQVEsQ0FBWjs7QUFFQWxDLFVBQVNFLEdBQVQsQ0FBYyxtQkFBVztBQUN4QkMsVUFBUVMsTUFBUixDQUFlVixHQUFmLENBQW9CLGlCQUFTO0FBQzVCLE9BQUtXLE1BQU1HLFVBQU4sS0FBcUJpQixFQUExQixFQUErQjtBQUM5QkM7QUFDQTtBQUNELEdBSkQ7QUFLQSxFQU5EOztBQVFBLFFBQU9BLFFBQVEsQ0FBZjtBQUNBOztBQUVEOzs7Ozs7Ozs7OztBQVdPLFNBQVM5RSxnQkFBVCxDQUEyQnlELEtBQTNCLEVBQWtDZCxTQUFsQyxFQUE2Q29DLElBQTdDLEVBQW1EbkMsUUFBbkQsRUFBNkRvQyxhQUE3RCxFQUE2RTtBQUNuRkEsaUJBQWdCQSxpQkFBaUIsRUFBakM7QUFDQSxLQUFNQyxxQ0FBYXJDLFFBQWIsSUFBdUIsRUFBRVksUUFBUXdCLGFBQVYsRUFBdkIsRUFBTjtBQUNBLEtBQU1FLGNBQWMxRixlQUFnQmlFLE1BQU1ILElBQXRCLEVBQTRCMkIsS0FBNUIsQ0FBcEI7O0FBRUEsUUFBT2YsRUFBRWlCLE1BQUYsQ0FBVTFCLEtBQVYsRUFBaUI7QUFDdkJHLGNBQVlILE1BQU1ILElBQU4sR0FBYSxHQUFiLEdBQW1CNEIsV0FEUjtBQUV2QkUsVUFBUXpDLFNBRmU7QUFHdkJvQyxRQUFNQTtBQUhpQixFQUFqQixDQUFQO0FBS0E7O0FBRUQ7Ozs7Ozs7OztBQVNPLFNBQVM5RSx3QkFBVCxDQUFtQ29GLElBQW5DLEVBQXlDekMsUUFBekMsRUFBbURELFNBQW5ELEVBQStEO0FBQ3JFLEtBQU1jLFFBQVE2QixlQUFlOUIsTUFBZixDQUFzQitCLElBQXRCLENBQTRCLHFCQUFhO0FBQ3RELFNBQU9DLFVBQVVILElBQVYsS0FBbUJBLElBQTFCO0FBQ0EsRUFGYSxDQUFkOztBQUlBLEtBQU1ILGNBQWMxRixlQUFnQmlFLE1BQU1ILElBQXRCLEVBQTRCVixRQUE1QixDQUFwQjs7QUFFQSxLQUFNSyxRQUFRO0FBQ2JXLGNBQVlILE1BQU1ILElBQU4sR0FBYSxHQUFiLEdBQW1CNEIsV0FEbEI7QUFFYjVCLFFBQU1HLE1BQU1ILElBRkM7QUFHYm1DLFdBQVNoQyxNQUFNZ0MsT0FIRjtBQUliVixRQUFNLEVBSk87QUFLYlcsY0FBWSxFQUxDO0FBTWIxQyxjQUFZTDtBQU5DLEVBQWQ7O0FBU0EsS0FBTXVCLEVBQUV5QixRQUFGLENBQVksQ0FBRSxhQUFGLEVBQWlCLFFBQWpCLEVBQTJCLFFBQTNCLEVBQXFDLE9BQXJDLEVBQThDLFVBQTlDLEVBQTBELFFBQTFELEVBQW9FLFVBQXBFLENBQVosRUFBOEZsQyxNQUFNSCxJQUFwRyxDQUFOLEVBQW1IO0FBQ2xITCxRQUFNLGlCQUFOLElBQTJCLE1BQTNCO0FBQ0E7O0FBRUQsUUFBT2lCLEVBQUVpQixNQUFGLENBQ05sQyxLQURNLEVBRU4yQyxLQUFLQyxLQUFMLENBQVlELEtBQUtFLFNBQUwsQ0FBZ0JyQyxNQUFNc0MsUUFBdEIsQ0FBWixDQUZNLENBQVA7QUFJQTs7QUFFRDs7Ozs7OztBQU9PLFNBQVM3RixZQUFULENBQXVCdUQsS0FBdkIsRUFBK0I7QUFBQSxLQUM3QkgsSUFENkIsR0FDcEJHLEtBRG9CLENBQzdCSCxJQUQ2Qjs7O0FBR3JDLFFBQU9BLElBQVA7QUFDQTs7QUFFRDs7Ozs7Ozs7O0FBU08sU0FBU25ELGtCQUFULENBQTZCc0QsS0FBN0IsRUFBcUM7QUFDM0MsUUFBTzZCLGVBQWU5QixNQUFmLENBQXNCK0IsSUFBdEIsQ0FBNEI7QUFBQSxTQUFtQlMsZ0JBQWdCMUMsSUFBaEIsS0FBeUJHLE1BQU1ILElBQWxEO0FBQUEsRUFBNUIsQ0FBUDtBQUNBOztBQUVEOzs7Ozs7Ozs7QUFTTyxTQUFTbEQsZ0JBQVQsQ0FBMkI2RixLQUEzQixFQUFrQ0MsUUFBbEMsRUFBNENDLFdBQTVDLEVBQTBEO0FBQ2hFLHFDQUFZRixNQUFNRyxLQUFOLENBQWEsQ0FBYixFQUFnQkYsUUFBaEIsQ0FBWixJQUF3Q0MsV0FBeEMsc0JBQXdERixNQUFNRyxLQUFOLENBQWFGLFFBQWIsQ0FBeEQ7QUFDQTs7QUFFRDs7Ozs7Ozs7O0FBU08sU0FBUzdGLGlCQUFULENBQTRCNEYsS0FBNUIsRUFBbUNDLFFBQW5DLEVBQTZDQyxXQUE3QyxFQUEyRDtBQUNqRSxxQ0FBWUYsTUFBTUcsS0FBTixDQUFhLENBQWIsRUFBZ0JGLFFBQWhCLENBQVosSUFBd0NDLFdBQXhDLHNCQUF3REYsTUFBTUcsS0FBTixDQUFhRixXQUFXLENBQXhCLENBQXhEO0FBQ0E7O0FBRUQ7Ozs7Ozs7QUFPTyxTQUFTNUYsU0FBVCxHQUFxQjtBQUMzQixRQUFPK0YsdUJBQUsvRixTQUFMLENBQWVnRyxLQUFmLENBQXNCLElBQXRCLEVBQTRCQyxTQUE1QixDQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7O0FBUU8sU0FBU2hHLGVBQVQsQ0FBMEIrRCxLQUExQixFQUFpQ2tDLEtBQWpDLEVBQXlDO0FBQy9DLEtBQU1DLGFBQWF2QyxFQUFFd0MsTUFBRixDQUFVRixLQUFWLEVBQWlCLFVBQVVHLElBQVYsRUFBaUI7QUFDcEQsU0FBT0EsS0FBS0MsTUFBTCxLQUFnQnRDLEtBQXZCO0FBQ0EsRUFGa0IsQ0FBbkI7O0FBSUEsS0FBSyxDQUFFSixFQUFFMkMsV0FBRixDQUFlSixXQUFZLENBQVosQ0FBZixDQUFGLElBQXNDLENBQUV2QyxFQUFFMkMsV0FBRixDQUFlSixXQUFZLENBQVosRUFBZ0JLLFFBQS9CLENBQTdDLEVBQXlGO0FBQ3hGLFNBQU9MLFdBQVksQ0FBWixFQUFnQkssUUFBdkI7QUFDQTs7QUFFRCxRQUFPLENBQUV4RyxVQUFXLE1BQVgsQ0FBRixDQUFQO0FBQ0E7O0FBRUQ7Ozs7OztBQU1PLFNBQVNFLE9BQVQsQ0FBa0I4RCxLQUFsQixFQUEwQjtBQUNoQyxRQUFPQSxNQUFNeUMsTUFBTixDQUFjLENBQWQsRUFBa0JDLFdBQWxCLEtBQWtDMUMsTUFBTThCLEtBQU4sQ0FBYSxDQUFiLENBQXpDO0FBQ0E7O0FBRUQ7Ozs7O0FBS08sU0FBUzNGLGlCQUFULENBQTRCZ0QsS0FBNUIsRUFBbUN3RCxTQUFuQyxFQUErQztBQUNyRCxLQUFNM0MsUUFBUTJDLFVBQVUzQyxLQUF4QjtBQUNBLEtBQUk0QyxtQkFBSjs7QUFFQTtBQUNBO0FBQ0EsS0FBS3pELE1BQU0wRCxVQUFOLElBQW9CMUQsTUFBTVcsTUFBTixDQUFhZ0QsTUFBYixHQUFzQixDQUEvQyxFQUFtRDtBQUNsRCxNQUFJekMsY0FBSjs7QUFFQTtBQUNBQSxVQUFRVCxFQUFFbUQsS0FBRixDQUFTNUQsTUFBTVcsTUFBZixFQUF1QixFQUFFRSxPQUFPQSxLQUFULEVBQXZCLEVBQTJDLENBQTNDLENBQVI7O0FBRUE7QUFDQSxNQUFLLENBQUVLLEtBQVAsRUFBZTtBQUNkQSxXQUFRVCxFQUFFbUQsS0FBRixDQUFTNUQsTUFBTVcsTUFBZixFQUF1QixFQUFFTyxPQUFPTCxLQUFULEVBQXZCLEVBQTJDLENBQTNDLENBQVI7QUFDQTs7QUFFRDtBQUNBLE1BQUssQ0FBRUssS0FBUCxFQUFlO0FBQ2Q7QUFDQTs7QUFFRHVDLGVBQWF2QyxNQUFNQSxLQUFuQjtBQUNBLEVBakJELE1BaUJPLElBQUssV0FBV2xCLE1BQU02RCxVQUFqQixJQUErQixDQUFFLFdBQUYsRUFBZSxVQUFmLEVBQTRCQyxRQUE1QixDQUFzQ04sVUFBVU8sSUFBaEQsQ0FBcEMsRUFBOEY7QUFDcEc7QUFDQU4sZUFBYXhHLGlCQUFrQjRELEtBQWxCLENBQWI7QUFDQSxFQUhNLE1BR0E7QUFDTjRDLGVBQWE1QyxLQUFiO0FBQ0E7O0FBRUQ7QUFDQSxLQUFLSixFQUFFQyxPQUFGLENBQVcrQyxVQUFYLENBQUwsRUFBK0I7QUFDOUIsU0FBTzVHLFVBQVcsTUFBWCxDQUFQO0FBQ0E7O0FBRUQsUUFBTzRHLFVBQVA7QUFDQTs7QUFFRDs7O0FBR08sU0FBU3hHLGdCQUFULENBQTJCNEQsS0FBM0IsRUFBbUM7QUFDekMsS0FBSyxDQUFFbUQsTUFBT0MsT0FBUXBELEtBQVIsQ0FBUCxDQUFQLEVBQWtDO0FBQ2pDO0FBQ0EsTUFBTXFELE9BQU8sSUFBSUMsSUFBSixDQUFVdEQsUUFBTSxDQUFoQixDQUFiOztBQUVBO0FBQ0EsTUFBTW1CLFVBQVUsRUFBRW9DLEtBQUssU0FBUCxFQUFrQkMsT0FBTyxTQUF6QixFQUFvQ0MsTUFBTSxTQUExQyxFQUFoQjs7QUFFQTtBQUNBekQsVUFBUXFELEtBQUtLLGtCQUFMLENBQXlCLE9BQXpCLEVBQWtDdkMsT0FBbEMsQ0FBUjtBQUNBOztBQUVELFFBQU9uQixLQUFQO0FBQ0E7O0FBRUQ7OztBQUdPLFNBQVMzRCxTQUFULENBQW9CaUMsUUFBcEIsRUFBOEJxRixjQUE5QixFQUE4Q0MsS0FBOUMsRUFBcURDLGNBQXJELEVBQXFFQyxnQkFBckUsRUFBd0Y7QUFDOUYsS0FBSUMsY0FBYyxFQUFsQjs7QUFFQSxLQUFLbkUsRUFBRTJDLFdBQUYsQ0FBZW9CLGNBQWYsQ0FBTCxFQUF1QztBQUN0Q0EsbUJBQWlCLENBQUUsWUFBRixFQUFnQixVQUFoQixFQUE0QixPQUE1QixFQUFxQyxTQUFyQyxFQUFnRCxTQUFoRCxDQUFqQjtBQUNBO0FBQ0QsS0FBS0ssTUFBTUMsT0FBTixDQUFlTixjQUFmLEtBQW1DLENBQUUvRixPQUFRa0csZ0JBQVIsQ0FBMUMsRUFBdUU7QUFDdEVILGlCQUFlbEUsSUFBZixDQUFxQixPQUFyQjtBQUNBO0FBQ0QsS0FBSXlFLGtCQUFrQixLQUF0Qjs7QUFFQSxLQUFLLENBQUV0RSxFQUFFMkMsV0FBRixDQUFlcUIsS0FBZixDQUFGLElBQTRCLENBQUVoRSxFQUFFMkMsV0FBRixDQUFlcUIsTUFBTU0sZUFBckIsQ0FBOUIsSUFBd0VOLE1BQU1NLGVBQU4sS0FBMEIsSUFBdkcsRUFBOEc7QUFDN0dBLG9CQUFrQixJQUFsQjtBQUNBOztBQUdEO0FBQ0E1RixVQUFTRSxHQUFULENBQWMsbUJBQVc7QUFDeEIsTUFBTVUsU0FBU1QsUUFBUVMsTUFBdkI7QUFBQSxNQUNDaUYsY0FBYzFGLFFBQVEyRixZQUR2QjtBQUVBbEYsU0FBT1YsR0FBUCxDQUFZLGlCQUFTO0FBQ3BCO0FBQ0EsT0FBSyxDQUFFb0IsRUFBRTJDLFdBQUYsQ0FBZXNCLGNBQWYsQ0FBUCxFQUF5QztBQUN4QyxRQUFLLENBQUVqRSxFQUFFeUIsUUFBRixDQUFZd0MsY0FBWixFQUE0QjFFLE1BQU1ILElBQWxDLENBQVAsRUFBa0Q7QUFDakQ7QUFDQTtBQUNELElBSkQsTUFJTyxJQUFLWSxFQUFFeUIsUUFBRixDQUFZc0MsY0FBWixFQUE0QnhFLE1BQU1ILElBQWxDLENBQUwsRUFBZ0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVELE9BQUlxQixjQUFKOztBQUVBO0FBQ0EsT0FBSyxDQUFFVCxFQUFFMkMsV0FBRixDQUFlcEQsTUFBTW1CLFdBQXJCLENBQUYsSUFBd0MsQ0FBRVYsRUFBRUMsT0FBRixDQUFXVixNQUFNbUIsV0FBakIsQ0FBL0MsRUFBZ0Y7QUFDL0VELFlBQVFsQixNQUFNbUIsV0FBZDtBQUNBLElBRkQsTUFFTztBQUNORCxZQUFRbEIsTUFBTUgsSUFBZDtBQUNBcUIsWUFBUW5FLFFBQVNtRSxLQUFULENBQVI7QUFDQTs7QUFFRDtBQUNBLE9BQUtsQixNQUFNSCxJQUFOLEtBQWUsTUFBZixJQUF5QixDQUFFcEIsT0FBUWtHLGdCQUFSLENBQWhDLEVBQTZEO0FBQzVEQyxrQkFBY0EsWUFBWU0sTUFBWixDQUFvQjlILGNBQWU0QyxLQUFmLEVBQXNCa0IsS0FBdEIsRUFBNkI4RCxXQUE3QixDQUFwQixDQUFkO0FBQ0EsSUFGRCxNQUVPLElBQUtoRixNQUFNSCxJQUFOLEtBQWUsU0FBZixJQUE0QixDQUFFcEIsT0FBUWtHLGdCQUFSLENBQW5DLEVBQWdFO0FBQ3RFQyxrQkFBY0EsWUFBWU0sTUFBWixDQUFvQnZILGlCQUFrQnFDLEtBQWxCLEVBQXlCa0IsS0FBekIsRUFBZ0M4RCxXQUFoQyxDQUFwQixDQUFkO0FBQ0EsSUFGTSxNQUVBLElBQUtoRixNQUFNSCxJQUFOLEtBQWUsUUFBZixJQUEyQkcsTUFBTW1GLFdBQU4sS0FBc0IsT0FBdEQsRUFBZ0U7QUFDdEVQLGtCQUFjQSxZQUFZTSxNQUFaLENBQW9CN0gscUJBQXNCMkMsS0FBdEIsRUFBNkJrQixLQUE3QixFQUFvQzhELFdBQXBDLENBQXBCLENBQWQ7QUFDQSxJQUZNLE1BRUEsSUFBS2hGLE1BQU1ILElBQU4sS0FBZSxNQUFmLElBQXlCLENBQUVwQixPQUFRa0csZ0JBQVIsQ0FBaEMsRUFBNkQ7QUFDbkVDLGtCQUFjQSxZQUFZTSxNQUFaLENBQW9CdEgsY0FBZW9DLEtBQWYsRUFBc0JrQixLQUF0QixFQUE2QjhELFdBQTdCLENBQXBCLENBQWQ7QUFDQSxJQUZNLE1BRUQsSUFBS2hGLE1BQU1ILElBQU4sS0FBZSxNQUFmLElBQXlCRyxNQUFNNkQsVUFBTixLQUFxQixRQUE5QyxJQUEwRGtCLG9CQUFvQixLQUFuRixFQUEyRjtBQUNoRztBQUNBLElBRkssTUFFQztBQUNOSCxnQkFBWXRFLElBQVosQ0FBa0I7QUFDakJILGlCQUFZSCxNQUFNRyxVQUREO0FBRWpCOEUsbUJBQWNELFdBRkc7QUFHakJJLGVBQVVwRixNQUFNb0YsUUFIQztBQUlqQnZCLGlCQUFZN0QsTUFBTUgsSUFKRDtBQUtqQndGLGlCQUFZckYsTUFBTUgsSUFMRDtBQU1qQnFCLFlBQU9BLEtBTlU7QUFPakJQLGFBQVFqRCxlQUFnQnNDLEtBQWhCLENBUFM7QUFRakIwRCxpQkFBWWpHLGdCQUFpQnVDLEtBQWpCLENBUks7QUFTakJzRixlQUFVL0gsY0FBZXlDLEtBQWYsQ0FUTztBQVVqQnVGLGNBQVMvSCxhQUFjd0MsS0FBZCxDQVZRO0FBV2pCd0YsZUFBVWxJLGVBQWdCMEMsS0FBaEIsQ0FYTztBQVlqQitCLGdCQUFXL0I7QUFaTSxLQUFsQjtBQWNBO0FBQ0QsT0FBS0EsTUFBTUgsSUFBTixLQUFlLE1BQWYsSUFBeUJHLE1BQU02RCxVQUFOLEtBQXFCLFFBQTlDLElBQTBELENBQUVwRixPQUFRa0csZ0JBQVIsQ0FBakUsRUFBOEY7QUFDN0ZDLGtCQUFjQSxZQUFZTSxNQUFaLENBQW9CL0gsY0FBZTZDLEtBQWYsRUFBc0JrQixLQUF0QixFQUE2QjhELFdBQTdCLENBQXBCLENBQWQ7QUFDQTtBQUVELEdBcEREO0FBcURBLEVBeEREO0FBeURBLFFBQU9KLFdBQVA7QUFDQTtBQUNEOzs7Ozs7QUFNTyxTQUFTekgsYUFBVCxDQUF3QjZDLEtBQXhCLEVBQStCeUYsVUFBL0IsRUFBMkNULFdBQTNDLEVBQXlEO0FBQy9ELEtBQU1KLGNBQWMsRUFBcEI7O0FBRUEsS0FBSWMsa0JBQUo7QUFDQSxLQUFLLENBQUVqRixFQUFFMkMsV0FBRixDQUFlcEQsTUFBTTBGLFNBQXJCLENBQUYsSUFBc0MsQ0FBRWpGLEVBQUVDLE9BQUYsQ0FBV1YsTUFBTTBGLFNBQWpCLENBQTdDLEVBQTRFO0FBQzNFQSxjQUFZRCxhQUFhLEtBQWIsR0FBcUJ6RixNQUFNMEYsU0FBdkM7QUFDQSxFQUZELE1BRU87QUFDTkEsY0FBWUQsYUFBYSxLQUFiLEdBQXFCNUksVUFBVyxLQUFYLENBQWpDO0FBQ0E7O0FBRUQsS0FBSThJLG9CQUFKO0FBQ0EsS0FBSyxDQUFFbEYsRUFBRTJDLFdBQUYsQ0FBZXBELE1BQU0yRixXQUFyQixDQUFGLElBQXdDLENBQUVsRixFQUFFQyxPQUFGLENBQVdWLE1BQU0yRixXQUFqQixDQUEvQyxFQUFnRjtBQUMvRUEsZ0JBQWNGLGFBQWEsS0FBYixHQUFxQnpGLE1BQU0yRixXQUF6QztBQUNBLEVBRkQsTUFFTztBQUNOQSxnQkFBY0YsYUFBYSxLQUFiLEdBQXFCNUksVUFBVyxPQUFYLENBQW5DO0FBQ0E7O0FBRUQsS0FBSStJLG1CQUFKO0FBQ0EsS0FBSyxDQUFFbkYsRUFBRTJDLFdBQUYsQ0FBZXBELE1BQU00RixVQUFyQixDQUFGLElBQXVDLENBQUVuRixFQUFFQyxPQUFGLENBQVdWLE1BQU00RixVQUFqQixDQUE5QyxFQUE4RTtBQUM3RUEsZUFBYUgsYUFBYSxLQUFiLEdBQXFCekYsTUFBTTRGLFVBQXhDO0FBQ0EsRUFGRCxNQUVPO0FBQ05BLGVBQWFILGFBQWEsS0FBYixHQUFxQjVJLFVBQVcsTUFBWCxDQUFsQztBQUNBO0FBQ0QsS0FBSW1ELE1BQU02RCxVQUFOLEtBQXFCLE9BQXpCLEVBQWtDO0FBQ2pDZSxjQUFZdEUsSUFBWixDQUNDO0FBQ0NILGVBQVlILE1BQU1HLFVBQU4sR0FBbUIsTUFEaEM7QUFFQzhFLGlCQUFjRCxXQUZmO0FBR0NJLGFBQVVwRixNQUFNb0YsUUFIakI7QUFJQ3ZCLGVBQVk3RCxNQUFNSCxJQUpuQjtBQUtDd0YsZUFBWXJGLE1BQU1ILElBQU4sR0FBYSxNQUwxQjtBQU1DcUIsVUFBT3dFLFNBTlI7QUFPQy9FLFdBQVEsS0FQVDtBQVFDK0MsZUFBWSxLQVJiO0FBU0M4QixhQUFVO0FBVFgsR0FERCxFQVlDO0FBQ0NyRixlQUFZSCxNQUFNRyxVQUFOLEdBQW1CLFFBRGhDO0FBRUM4RSxpQkFBY0QsV0FGZjtBQUdDSSxhQUFVcEYsTUFBTW9GLFFBSGpCO0FBSUN2QixlQUFZN0QsTUFBTUgsSUFKbkI7QUFLQ3dGLGVBQVlyRixNQUFNSCxJQUFOLEdBQWEsUUFMMUI7QUFNQ3FCLFVBQU95RSxXQU5SO0FBT0NoRixXQUFRLEtBUFQ7QUFRQytDLGVBQVksS0FSYjtBQVNDOEIsYUFBVTtBQVRYLEdBWkQsRUF1QkM7QUFDQ3JGLGVBQVlILE1BQU1HLFVBQU4sR0FBbUIsT0FEaEM7QUFFQzhFLGlCQUFjRCxXQUZmO0FBR0NJLGFBQVVwRixNQUFNb0YsUUFIakI7QUFJQ3ZCLGVBQVk3RCxNQUFNSCxJQUpuQjtBQUtDd0YsZUFBWXJGLE1BQU1ILElBQU4sR0FBYSxPQUwxQjtBQU1DcUIsVUFBTzBFLFVBTlI7QUFPQ2pGLFdBQVEsS0FQVDtBQVFDK0MsZUFBWSxLQVJiO0FBU0M4QixhQUFVO0FBVFgsR0F2QkQ7QUFtQ0EsRUFwQ0QsTUFvQ0s7QUFDSlosY0FBWXRFLElBQVosQ0FDQztBQUNDSCxlQUFZSCxNQUFNRyxVQUFOLEdBQW1CLE1BRGhDO0FBRUM4RSxpQkFBY0QsV0FGZjtBQUdDSSxhQUFVcEYsTUFBTW9GLFFBSGpCO0FBSUN2QixlQUFZN0QsTUFBTUgsSUFKbkI7QUFLQ3dGLGVBQVlyRixNQUFNSCxJQUFOLEdBQWEsTUFMMUI7QUFNQ3FCLFVBQU93RSxTQU5SO0FBT0MvRSxXQUFRakQsZUFBZ0JzQyxLQUFoQixDQVBUO0FBUUMwRCxlQUFZakcsZ0JBQWlCdUMsS0FBakIsQ0FSYjtBQVNDd0YsYUFBVWxJLGVBQWdCMEMsS0FBaEI7QUFUWCxHQURELEVBWUM7QUFDQ0csZUFBWUgsTUFBTUcsVUFBTixHQUFtQixRQURoQztBQUVDOEUsaUJBQWNELFdBRmY7QUFHQ0ksYUFBVXBGLE1BQU1vRixRQUhqQjtBQUlDdkIsZUFBWTdELE1BQU1ILElBSm5CO0FBS0N3RixlQUFZckYsTUFBTUgsSUFBTixHQUFhLFFBTDFCO0FBTUNxQixVQUFPeUUsV0FOUjtBQU9DaEYsV0FBUWpELGVBQWdCc0MsS0FBaEIsQ0FQVDtBQVFDMEQsZUFBWWpHLGdCQUFpQnVDLEtBQWpCLENBUmI7QUFTQ3dGLGFBQVVsSSxlQUFnQjBDLEtBQWhCO0FBVFgsR0FaRCxFQXVCQztBQUNDRyxlQUFZSCxNQUFNRyxVQUFOLEdBQW1CLE9BRGhDO0FBRUM4RSxpQkFBY0QsV0FGZjtBQUdDSSxhQUFVcEYsTUFBTW9GLFFBSGpCO0FBSUN2QixlQUFZN0QsTUFBTUgsSUFKbkI7QUFLQ3dGLGVBQVlyRixNQUFNSCxJQUFOLEdBQWEsT0FMMUI7QUFNQ3FCLFVBQU8wRSxVQU5SO0FBT0NqRixXQUFRakQsZUFBZ0JzQyxLQUFoQixDQVBUO0FBUUMwRCxlQUFZakcsZ0JBQWlCdUMsS0FBakIsQ0FSYjtBQVNDd0YsYUFBVWxJLGVBQWdCMEMsS0FBaEI7QUFUWCxHQXZCRDtBQW1DQTs7QUFFRCxRQUFPNEUsV0FBUDtBQUNBOztBQUVEOzs7Ozs7QUFNTyxTQUFTeEgsYUFBVCxDQUF3QjRDLEtBQXhCLEVBQStCeUYsVUFBL0IsRUFBMkNULFdBQTNDLEVBQXlEO0FBQy9ELEtBQU1KLGNBQWMsRUFBcEI7QUFDQTtBQUNBLEtBQUs1RSxNQUFNNkYsYUFBTixLQUF3QixNQUF4QixJQUFrQyxTQUFTN0YsTUFBTTZGLGFBQXRELEVBQXNFO0FBQ3JFLEdBQ0M7QUFDQ0MsU0FBTSxRQURQO0FBRUM1RSxVQUFPLGNBRlI7QUFHQzZFLG1CQUFnQixRQUhqQjtBQUlDckMsZUFBWSxJQUpiO0FBS0MvQyxXQUFRLENBQ1AsRUFBRU8sT0FBTyxLQUFULEVBQWdCTCxPQUFPLElBQXZCLEVBRE8sRUFFUCxFQUFFSyxPQUFPLE1BQVQsRUFBaUJMLE9BQU8sS0FBeEIsRUFGTyxFQUdQLEVBQUVLLE9BQU8sS0FBVCxFQUFnQkwsT0FBTyxJQUF2QixFQUhPLEVBSVAsRUFBRUssT0FBTyxLQUFULEVBQWdCTCxPQUFPLElBQXZCLEVBSk8sRUFLUCxFQUFFSyxPQUFPLE1BQVQsRUFBaUJMLE9BQU8sTUFBeEIsRUFMTyxFQU1QLEVBQUVLLE9BQU8sS0FBVCxFQUFnQkwsT0FBTyxJQUF2QixFQU5PLEVBT1AsRUFBRUssT0FBTyxPQUFULEVBQWtCTCxPQUFPLE1BQXpCLEVBUE8sQ0FMVDtBQWNDMkUsYUFBVTtBQWRYLEdBREQsRUFpQkM7QUFDQ00sU0FBTSxPQURQO0FBRUM1RSxVQUFPLGFBRlI7QUFHQzZFLG1CQUFnQixZQUhqQjtBQUlDckMsZUFBWSxLQUpiO0FBS0MvQyxXQUFRLEtBTFQ7QUFNQzZFLGFBQVU7QUFOWCxHQWpCRCxFQXlCQztBQUNDTSxTQUFNLE9BRFA7QUFFQzVFLFVBQU8sYUFGUjtBQUdDNkUsbUJBQWdCLGFBSGpCO0FBSUNyQyxlQUFZLEtBSmI7QUFLQy9DLFdBQVEsS0FMVDtBQU1DNkUsYUFBVTtBQU5YLEdBekJELEVBaUNDO0FBQ0NNLFNBQU0sT0FEUDtBQUVDNUUsVUFBTyxhQUZSO0FBR0M2RSxtQkFBZ0IsV0FIakI7QUFJQ3JDLGVBQVksS0FKYjtBQUtDL0MsV0FBUSxLQUxUO0FBTUM2RSxhQUFVO0FBTlgsR0FqQ0QsRUF5Q0VuRyxHQXpDRixDQXlDTyxxQkFBYTtBQUNuQixPQUFLVyxNQUFPZ0csVUFBVUYsSUFBakIsTUFBNEIsTUFBNUIsSUFBc0M5RixNQUFPZ0csVUFBVUYsSUFBakIsTUFBNEIsSUFBdkUsRUFBOEU7QUFDN0UsUUFBSTVFLGNBQUo7QUFDQSxRQUFLLENBQUVULEVBQUUyQyxXQUFGLENBQWVwRCxNQUFPZ0csVUFBVTlFLEtBQWpCLENBQWYsQ0FBRixJQUErQyxDQUFFVCxFQUFFQyxPQUFGLENBQVdWLE1BQU9nRyxVQUFVOUUsS0FBakIsQ0FBWCxDQUF0RCxFQUE4RjtBQUM3RkEsYUFBUXVFLGFBQWEsS0FBYixHQUFxQnpGLE1BQU9nRyxVQUFVOUUsS0FBakIsQ0FBN0I7QUFDQSxLQUZELE1BRU87QUFDTkEsYUFBUXVFLGFBQWEsS0FBckI7QUFDQTs7QUFFRGIsZ0JBQVl0RSxJQUFaLENBQWtCO0FBQ2pCSCxpQkFBWUgsTUFBTUcsVUFBTixHQUFtQixHQUFuQixHQUF5QjZGLFVBQVVELGNBRDlCO0FBRWpCZCxtQkFBY0QsV0FGRztBQUdqQkksZUFBVXBGLE1BQU1vRixRQUhDO0FBSWpCdkIsaUJBQVk3RCxNQUFNSCxJQUpEO0FBS2pCd0YsaUJBQVlyRixNQUFNSCxJQUFOLEdBQWEsR0FBYixHQUFtQm1HLFVBQVVELGNBTHhCO0FBTWpCN0UsWUFBT0EsS0FOVTtBQU9qQlAsYUFBUXFGLFVBQVVyRixNQVBEO0FBUWpCK0MsaUJBQVlzQyxVQUFVdEMsVUFSTDtBQVNqQjhCLGVBQVVRLFVBQVVSO0FBVEgsS0FBbEI7QUFXQTtBQUNELEdBOUREO0FBK0RBLEVBaEVELE1BZ0VPO0FBQ05aLGNBQVl0RSxJQUFaLENBQWtCO0FBQ2pCSCxlQUFZSCxNQUFNRyxVQUREO0FBRWpCOEUsaUJBQWNELFdBRkc7QUFHakJJLGFBQVVwRixNQUFNb0YsUUFIQztBQUlqQnZCLGVBQVk3RCxNQUFNSCxJQUpEO0FBS2pCd0YsZUFBWXJGLE1BQU1ILElBTEQ7QUFNakJxQixVQUFPdUUsVUFOVTtBQU9qQjlFLFdBQVFqRCxlQUFnQnNDLEtBQWhCLENBUFM7QUFRakIwRCxlQUFZakcsZ0JBQWlCdUMsS0FBakIsQ0FSSztBQVNqQndGLGFBQVVsSSxlQUFnQjBDLEtBQWhCO0FBVE8sR0FBbEI7QUFXQTs7QUFFRCxRQUFPNEUsV0FBUDtBQUNBOztBQUVEOzs7Ozs7QUFNTyxTQUFTdkgsb0JBQVQsQ0FBK0IyQyxLQUEvQixFQUFzQ3lGLFVBQXRDLEVBQWtEVCxXQUFsRCxFQUFnRTtBQUN0RSxLQUFNSixjQUFjLEVBQXBCO0FBQ0MsRUFDQztBQUNDcUIsVUFBUTtBQURULEVBREQsRUFJQztBQUNDQSxVQUFRO0FBRFQsRUFKRCxFQU9FNUcsR0FQRixDQU9PLHFCQUFhO0FBQ25CdUYsY0FBWXRFLElBQVosQ0FBa0I7QUFDakJILGVBQVlILE1BQU1HLFVBQU4sR0FBbUIsR0FBbkIsR0FBeUI2RixVQUFVQyxNQUQ5QjtBQUVqQmhCLGlCQUFjRCxXQUZHO0FBR2pCSSxhQUFVcEYsTUFBTW9GLFFBSEM7QUFJakJ2QixlQUFZN0QsTUFBTUgsSUFKRDtBQUtqQndGLGVBQVlyRixNQUFNSCxJQUFOLEdBQWEsR0FBYixHQUFtQm1HLFVBQVVDLE1BTHhCO0FBTWpCL0UsVUFBT3VFLGFBQWEsS0FBYixHQUFxQk8sVUFBVUMsTUFOckI7QUFPakJULGFBQVUsSUFQTztBQVFqQkYsYUFBVS9ILGNBQWV5QyxLQUFmO0FBUk8sR0FBbEI7QUFVQSxFQWxCRDs7QUFvQkQsUUFBTzRFLFdBQVA7QUFDQTs7QUFFRDs7O0FBR08sU0FBU3RILGNBQVQsQ0FBeUIwQyxLQUF6QixFQUFpQztBQUN2QyxLQUFLUyxFQUFFeUIsUUFBRixDQUFZLENBQUUsYUFBRixFQUFpQixRQUFqQixFQUEyQixRQUEzQixFQUFxQyxPQUFyQyxFQUE4QyxVQUE5QyxDQUFaLEVBQXdFbEMsTUFBTUgsSUFBOUUsQ0FBTCxFQUE0RjtBQUMzRixTQUFPLElBQVA7QUFDQTs7QUFFRCxRQUFPLEtBQVA7QUFDQTs7QUFFRDs7O0FBR08sU0FBU3RDLGFBQVQsQ0FBd0J5QyxLQUF4QixFQUFnQztBQUN0QyxLQUFLQSxNQUFNa0csWUFBTixLQUF1QixNQUF2QixJQUFpQ2xHLE1BQU1rRyxZQUFOLEtBQXVCLElBQTdELEVBQW9FO0FBQ25FLFNBQU8sSUFBUDtBQUNBOztBQUVELFFBQU8sS0FBUDtBQUNBOztBQUVNLFNBQVMxSSxZQUFULENBQXVCd0MsS0FBdkIsRUFBK0I7QUFDckMsS0FBS0EsTUFBTXVGLE9BQVgsRUFBcUI7QUFDcEIsU0FBT3ZGLE1BQU11RixPQUFiO0FBQ0E7O0FBRUQsUUFBTyxLQUFQO0FBQ0E7O0FBRUQ7OztBQUdPLFNBQVM5SCxlQUFULENBQTBCdUMsS0FBMUIsRUFBa0M7QUFDeEMsS0FBS0EsTUFBTUgsSUFBTixLQUFlLFFBQWYsSUFBMkJHLE1BQU1ILElBQU4sS0FBZSxVQUExQyxJQUF3REcsTUFBTUgsSUFBTixLQUFlLE9BQTVFLEVBQXNGO0FBQ3JGLFNBQU8sSUFBUDtBQUNBOztBQUVELFFBQU8sS0FBUDtBQUNBOztBQUVEOzs7QUFHTyxTQUFTbkMsY0FBVCxDQUF5QnNDLEtBQXpCLEVBQWlDO0FBQ3ZDLEtBQU1ILE9BQU9HLE1BQU1ILElBQW5COztBQUVBLEtBQUtBLFNBQVMsUUFBVCxJQUFxQkEsU0FBUyxVQUE5QixJQUE0Q0EsU0FBUyxPQUExRCxFQUFvRTtBQUNuRSxTQUFPRyxNQUFNZ0MsT0FBYjtBQUNBOztBQUVELFFBQU8sS0FBUDtBQUNBOztBQUVEOzs7Ozs7QUFNTyxTQUFTckUsZ0JBQVQsQ0FBMkJxQyxLQUEzQixFQUFrQ3lGLFVBQWxDLEVBQThDVCxXQUE5QyxFQUE0RDtBQUNsRSxLQUFNSixjQUFjLEVBQXBCOztBQUVBLEVBQ0M7QUFDQ2tCLFFBQU0sZ0JBRFA7QUFFQzVFLFNBQU8sc0JBRlI7QUFHQzZFLGtCQUFnQixnQkFIakI7QUFJQ3JDLGNBQVksS0FKYjtBQUtDL0MsVUFBUSxLQUxUO0FBTUM2RSxZQUFVO0FBTlgsRUFERCxFQVNDO0FBQ0NNLFFBQU0sY0FEUDtBQUVDNUUsU0FBTyxvQkFGUjtBQUdDNkUsa0JBQWdCLGNBSGpCO0FBSUNyQyxjQUFZLEtBSmI7QUFLQy9DLFVBQVEsS0FMVDtBQU1DNkUsWUFBVTtBQU5YLEVBVEQsRUFpQkM7QUFDQ00sUUFBTSxjQURQO0FBRUM1RSxTQUFPLG9CQUZSO0FBR0M2RSxrQkFBZ0IsTUFIakI7QUFJQ3JDLGNBQVksS0FKYjtBQUtDL0MsVUFBUSxLQUxUO0FBTUM2RSxZQUFVO0FBTlgsRUFqQkQsRUF5QkM7QUFDQ00sUUFBTSxlQURQO0FBRUM1RSxTQUFPLHFCQUZSO0FBR0M2RSxrQkFBZ0IsT0FIakI7QUFJQ3JDLGNBQVksS0FKYjtBQUtDL0MsVUFBUSxLQUxUO0FBTUM2RSxZQUFVO0FBTlgsRUF6QkQsRUFpQ0M7QUFDQ00sUUFBTSxhQURQO0FBRUM1RSxTQUFPLG1CQUZSO0FBR0M2RSxrQkFBZ0IsS0FIakI7QUFJQ3JDLGNBQVksS0FKYjtBQUtDL0MsVUFBUSxLQUxUO0FBTUM2RSxZQUFVO0FBTlgsRUFqQ0QsRUF5Q0M7QUFDQ00sUUFBTSxpQkFEUDtBQUVDNUUsU0FBTyx1QkFGUjtBQUdDNkUsa0JBQWdCLFNBSGpCO0FBSUNyQyxjQUFZLEtBSmI7QUFLQy9DLFVBQVEsS0FMVDtBQU1DNkUsWUFBVTtBQU5YLEVBekNELEVBaURFbkcsR0FqREYsQ0FpRE8scUJBQWE7QUFDbkIsTUFBS1osT0FBUXVCLE1BQU9nRyxVQUFVRixJQUFqQixDQUFSLENBQUwsRUFBeUM7QUFDeEMsT0FBSTVFLGNBQUo7QUFDQSxPQUFLLENBQUVULEVBQUUyQyxXQUFGLENBQWVwRCxNQUFPZ0csVUFBVTlFLEtBQWpCLENBQWYsQ0FBRixJQUErQyxDQUFFVCxFQUFFQyxPQUFGLENBQVdWLE1BQU9nRyxVQUFVOUUsS0FBakIsQ0FBWCxDQUF0RCxFQUE4RjtBQUM3RkEsWUFBUXVFLGFBQWEsS0FBYixHQUFxQnpGLE1BQU9nRyxVQUFVOUUsS0FBakIsQ0FBN0I7QUFDQSxJQUZELE1BRU87QUFDTkEsWUFBUXVFLGFBQWEsS0FBckI7QUFDQTs7QUFFRGIsZUFBWXRFLElBQVosQ0FBa0I7QUFDakJILGdCQUFZSCxNQUFNRyxVQUFOLEdBQW1CLEdBQW5CLEdBQXlCNkYsVUFBVUQsY0FEOUI7QUFFakJkLGtCQUFjRCxXQUZHO0FBR2pCSSxjQUFVcEYsTUFBTW9GLFFBSEM7QUFJakJ2QixnQkFBWTdELE1BQU1ILElBSkQ7QUFLakJ3RixnQkFBWXJGLE1BQU1ILElBQU4sR0FBYSxHQUFiLEdBQW1CbUcsVUFBVUQsY0FMeEI7QUFNakI3RSxXQUFPQSxLQU5VO0FBT2pCUCxZQUFRcUYsVUFBVXJGLE1BUEQ7QUFRakIrQyxnQkFBWXNDLFVBQVV0QyxVQVJMO0FBU2pCOEIsY0FBVVEsVUFBVVI7QUFUSCxJQUFsQjtBQVdBO0FBQ0QsRUF0RUQ7O0FBd0VBLFFBQU9aLFdBQVA7QUFDQTs7QUFFRDs7Ozs7O0FBTU8sU0FBU2hILGFBQVQsQ0FBd0JvQyxLQUF4QixFQUErQnlGLFVBQS9CLEVBQTJDVCxXQUEzQyxFQUF5RDtBQUMvRCxLQUFNSixjQUFjLEVBQXBCOztBQUVBLEtBQUl1QixpQkFBSjtBQUNBLEtBQUssQ0FBRTFGLEVBQUUyQyxXQUFGLENBQWVwRCxNQUFNbUcsUUFBckIsQ0FBRixJQUFxQyxDQUFFMUYsRUFBRUMsT0FBRixDQUFXVixNQUFNbUcsUUFBakIsQ0FBNUMsRUFBMEU7QUFDekVBLGFBQVdWLGFBQWEsS0FBYixHQUFxQnpGLE1BQU1tRyxRQUF0QztBQUNBLEVBRkQsTUFFTztBQUNOQSxhQUFXVixhQUFhLEtBQWIsR0FBcUI1SSxVQUFXLE1BQVgsQ0FBaEM7QUFDQTs7QUFFRCxLQUFJdUosaUJBQUo7QUFDQSxLQUFLLENBQUUzRixFQUFFMkMsV0FBRixDQUFlcEQsTUFBTW9HLFFBQXJCLENBQUYsSUFBcUMsQ0FBRTNGLEVBQUVDLE9BQUYsQ0FBV1YsTUFBTW9HLFFBQWpCLENBQTVDLEVBQTBFO0FBQ3pFQSxhQUFXWCxhQUFhLEtBQWIsR0FBcUJ6RixNQUFNb0csUUFBdEM7QUFDQSxFQUZELE1BRU87QUFDTkEsYUFBV1gsYUFBYSxLQUFiLEdBQXFCNUksVUFBVyxRQUFYLENBQWhDO0FBQ0E7O0FBRUQrSCxhQUFZdEUsSUFBWixDQUNDO0FBQ0NILGNBQVlILE1BQU1HLFVBQU4sR0FBbUIsUUFEaEM7QUFFQzhFLGdCQUFjRCxXQUZmO0FBR0NJLFlBQVVwRixNQUFNb0YsUUFIakI7QUFJQ3ZCLGNBQVk3RCxNQUFNSCxJQUpuQjtBQUtDd0YsY0FBWXJGLE1BQU1ILElBQU4sR0FBYSxRQUwxQjtBQU1DcUIsU0FBT2lGLFFBTlI7QUFPQ3hGLFVBQVEsS0FQVDtBQVFDK0MsY0FBWSxLQVJiO0FBU0M4QixZQUFVO0FBVFgsRUFERCxFQVlDO0FBQ0NyRixjQUFZSCxNQUFNRyxVQUFOLEdBQW1CLFVBRGhDO0FBRUM4RSxnQkFBY0QsV0FGZjtBQUdDSSxZQUFVcEYsTUFBTW9GLFFBSGpCO0FBSUN2QixjQUFZN0QsTUFBTUgsSUFKbkI7QUFLQ3dGLGNBQVlyRixNQUFNSCxJQUFOLEdBQWEsVUFMMUI7QUFNQ3FCLFNBQU9rRixRQU5SO0FBT0N6RixVQUFRLEtBUFQ7QUFRQytDLGNBQVksS0FSYjtBQVNDOEIsWUFBVTtBQVRYLEVBWkQ7O0FBeUJBLEtBQUt4RixNQUFNcUcsU0FBTixLQUFvQixRQUF6QixFQUFvQztBQUNuQ3pCLGNBQVl0RSxJQUFaLENBQWtCO0FBQ2pCSCxlQUFZSCxNQUFNRyxVQUFOLEdBQW1CLE9BRGQ7QUFFakI4RSxpQkFBY0QsV0FGRztBQUdqQkksYUFBVXBGLE1BQU1vRixRQUhDO0FBSWpCdkIsZUFBWTdELE1BQU1ILElBSkQ7QUFLakJ3RixlQUFZckYsTUFBTUgsSUFBTixHQUFhLE9BTFI7QUFNakJxQixVQUFPdUUsYUFBYSxRQU5IO0FBT2pCOUUsV0FBUSxDQUFFLEVBQUVPLE9BQU8sSUFBVCxFQUFlTCxPQUFPLElBQXRCLEVBQUYsRUFBZ0MsRUFBRUssT0FBTyxJQUFULEVBQWVMLE9BQU8sSUFBdEIsRUFBaEMsQ0FQUztBQVFqQjZDLGVBQVksSUFSSztBQVNqQjhCLGFBQVU7QUFUTyxHQUFsQjtBQVdBOztBQUVELFFBQU9aLFdBQVA7QUFDQTs7QUFFRDs7Ozs7QUFLTyxTQUFTL0cseUJBQVQsQ0FBb0N5SSxTQUFwQyxFQUFnRDtBQUN0RCxLQUFJQyxvQkFBb0IsRUFBeEI7QUFDQSxLQUFJQyxnQkFBZ0IzRSxlQUFlOUIsTUFBZixDQUFzQmtELE1BQXRCLENBQThCLGlCQUFTO0FBQzFELFNBQU9qRCxNQUFNSCxJQUFOLEtBQWV5RyxTQUF0QjtBQUNBLEVBRm1CLENBQXBCOztBQUlBLEtBQUtFLGNBQWM3QyxNQUFkLEdBQXVCLENBQTVCLEVBQWdDO0FBQy9CLFNBQU8sRUFBUDtBQUNBOztBQUVENkMsaUJBQWdCQSxjQUFlLENBQWYsQ0FBaEI7QUFDQSxLQUFLLENBQUUvRixFQUFFMkMsV0FBRixDQUFlb0QsY0FBY0MsaUJBQTdCLENBQVAsRUFBMEQ7QUFDekRGLHNCQUFvQkMsY0FBY0MsaUJBQWxDO0FBQ0E7O0FBRUQsUUFBT0YsaUJBQVA7QUFDQTs7QUFFRDs7Ozs7Ozs7QUFRTyxTQUFTekksWUFBVCxDQUF1QmlHLElBQXZCLEVBQTZCbEUsSUFBN0IsRUFBb0NnQixLQUFwQyxFQUE0QztBQUNsRCxLQUFJNkYsTUFBUSxDQUFDakcsRUFBRTJDLFdBQUYsQ0FBZXZDLEtBQWYsQ0FBSCxHQUE4QkEsS0FBOUIsR0FBc0MsRUFBaEQ7QUFDQSxTQUFTa0QsSUFBVDtBQUNDLE9BQUssSUFBTDtBQUNDLFVBQU9sSCxVQUFXLElBQVgsQ0FBUDtBQUNELE9BQUssUUFBTDtBQUNDLFVBQU9BLFVBQVcsUUFBWCxDQUFQO0FBQ0QsT0FBSyxRQUFMO0FBQ0MsVUFBT0EsVUFBVyxRQUFYLENBQVA7QUFDRCxPQUFLLFlBQUw7QUFDQyxVQUFPQSxVQUFXLFlBQVgsQ0FBUDtBQUNELE9BQUssY0FBTDtBQUNDLFVBQU9BLFVBQVcsY0FBWCxDQUFQO0FBQ0QsT0FBSyxVQUFMO0FBQ0MsVUFBT0EsVUFBVyxVQUFYLENBQVA7QUFDRCxPQUFLLFdBQUw7QUFDQyxVQUFPQSxVQUFXLFdBQVgsQ0FBUDtBQUNELE9BQUssVUFBTDtBQUNDLFVBQU9BLFVBQVcsVUFBWCxDQUFQO0FBQ0QsT0FBSywwQkFBTDtBQUNDLFVBQU9BLFVBQVcsNkNBQVgsRUFBMkRrRSxPQUEzRCxDQUFvRSxJQUFwRSxFQUEwRTJGLEdBQTFFLENBQVA7QUFDRCxPQUFLLDRCQUFMO0FBQ0MsVUFBTzdKLFVBQVcsK0NBQVgsRUFBNkRrRSxPQUE3RCxDQUFzRSxJQUF0RSxFQUE0RTJGLEdBQTVFLENBQVA7QUFDRCxPQUFLLHlCQUFMO0FBQ0MsVUFBTzdKLFVBQVcsNENBQVgsRUFBMERrRSxPQUExRCxDQUFtRSxJQUFuRSxFQUF5RTJGLEdBQXpFLENBQVA7QUFDRCxPQUFLLDJCQUFMO0FBQ0MsVUFBTzdKLFVBQVcsOENBQVgsRUFBNERrRSxPQUE1RCxDQUFxRSxJQUFyRSxFQUEyRTJGLEdBQTNFLENBQVA7QUFDRCxPQUFLLFVBQUw7QUFDQyxVQUFPN0osVUFBVyxpQkFBWCxDQUFQO0FBQ0QsT0FBSyxTQUFMO0FBQ0MsVUFBT0EsVUFBVyxjQUFYLENBQVA7QUFDRCxPQUFLLFVBQUw7QUFDQyxVQUFPQSxVQUFXLFVBQVgsQ0FBUDtBQUNELE9BQUssUUFBTDtBQUNDLFVBQU9BLFVBQVcsYUFBWCxDQUFQO0FBQ0QsT0FBSyxNQUFMO0FBQ0MsVUFBT0EsVUFBVyxXQUFYLENBQVA7QUFDRCxPQUFLLFlBQUw7QUFDQyxVQUFPQSxVQUFXLFlBQVgsQ0FBUDtBQUNELE9BQUssY0FBTDtBQUNDLFVBQU9BLFVBQVcsY0FBWCxDQUFQO0FBQ0Q7QUFDQSxPQUFLLGlCQUFMO0FBQ0MsVUFBT0EsVUFBVyxpQkFBWCxDQUFQO0FBQ0QsT0FBSyxxQkFBTDtBQUNDLFVBQU9BLFVBQVcscUJBQVgsQ0FBUDtBQUNEO0FBQ0MsVUFBTyxHQUFQO0FBN0NGO0FBK0NBOztBQUVEOzs7Ozs7QUFNTyxTQUFTa0IsU0FBVCxDQUFvQjhDLEtBQXBCLEVBQTRCO0FBQ2xDLEtBQUtBLE1BQU04QyxNQUFOLEdBQWUsQ0FBcEIsRUFBd0I7QUFDdkIsU0FBTyxLQUFQO0FBQ0E7O0FBRUQ7QUFDQSxLQUFLOUMsTUFBTThGLE9BQU4sQ0FBZSxHQUFmLEVBQW9CLENBQXBCLElBQTBCLENBQS9CLEVBQW1DO0FBQ2xDLFNBQU8sS0FBUDtBQUNBOztBQUVEO0FBQ0EsS0FBTUMsUUFBUS9GLE1BQU1SLEtBQU4sQ0FBYSxHQUFiLEVBQWtCLENBQWxCLENBQWQ7O0FBRUE7QUFDQTtBQUNBLEtBQUssQ0FBRXVHLE1BQU8sQ0FBUCxFQUFXQyxLQUFYLENBQWtCLHNDQUFsQixDQUFQLEVBQW9FO0FBQ25FLFNBQU8sS0FBUDtBQUNBOztBQUVEO0FBQ0E7QUFDQSxLQUFLRCxNQUFPLENBQVAsRUFBV0MsS0FBWCxDQUFrQixRQUFsQixDQUFMLEVBQW9DO0FBQ25DLFNBQU8sS0FBUDtBQUNBOztBQUVELEtBQU1DLFNBQVNGLE1BQU8sQ0FBUCxDQUFmO0FBQ0E7QUFDQSxLQUFNRyxPQUFPRCxPQUFPekcsS0FBUCxDQUFjLEdBQWQsQ0FBYjtBQUNBLEtBQUswRyxLQUFLcEQsTUFBTCxHQUFjLENBQW5CLEVBQXVCO0FBQ3RCLFNBQU8sS0FBUDtBQUNBOztBQUVELEtBQU1xRCxVQUFVRCxLQUFLcEQsTUFBckI7QUFDQSxNQUFNLElBQUlzRCxJQUFJLENBQWQsRUFBaUJBLElBQUlELE9BQXJCLEVBQThCQyxHQUE5QixFQUFvQztBQUNuQztBQUNBLE1BQUssQ0FBRUYsS0FBTUUsQ0FBTixFQUFVSixLQUFWLENBQWlCLGVBQWpCLENBQVAsRUFBNEM7QUFDM0MsVUFBTyxLQUFQO0FBQ0E7QUFDRDtBQUNELFFBQU8sSUFBUDtBQUNBOztBQUVEOzs7QUFHTyxTQUFTN0ksaUJBQVQsR0FBNkI7QUFDbkMsS0FBSyxxQkFBb0JrSixPQUFPQyxHQUEzQixDQUFMLEVBQXNDO0FBQ3JDO0FBQ0E7O0FBRUQ7QUFDQUMsWUFBWSxZQUFXO0FBQ3RCO0FBQ0FELE1BQUlFLFlBQUosQ0FBa0JDLE9BQVEsZ0JBQVIsQ0FBbEI7O0FBRUE7QUFDQUgsTUFBSUksT0FBSixDQUFhRCxPQUFRLFdBQVIsQ0FBYjs7QUFFQTtBQUNBQSxTQUFRLHNDQUFSLEVBQWlERSxJQUFqRCxDQUF1RCxZQUFXO0FBQ2pFTCxPQUFJTSxNQUFKLENBQVdDLFFBQVgsQ0FBcUJKLE9BQVEsSUFBUixDQUFyQjtBQUNBLEdBRkQ7O0FBSUFBLFNBQVEsdUNBQVIsRUFBa0RFLElBQWxELENBQXdELFlBQVc7QUFDbEVMLE9BQUlNLE1BQUosQ0FBV0UsU0FBWCxDQUFzQkwsT0FBUSxJQUFSLENBQXRCO0FBQ0EsR0FGRDs7QUFJQUEsU0FBUSx3Q0FBUixFQUFtREUsSUFBbkQsQ0FBeUQsWUFBVztBQUNuRUwsT0FBSU0sTUFBSixDQUFXRyxVQUFYLENBQXVCTixPQUFRLElBQVIsQ0FBdkI7QUFDQSxHQUZEOztBQUlBQSxTQUFRLGlGQUFSLEVBQTRGRSxJQUE1RixDQUFrRyxZQUFXO0FBQzVHTCxPQUFJTSxNQUFKLENBQVdJLElBQVgsQ0FBaUJQLE9BQVEsSUFBUixDQUFqQjtBQUNBLEdBRkQ7O0FBSUE7QUFDQUEsU0FBUSxzQkFBUixFQUFpQ0UsSUFBakMsQ0FBdUMsWUFBVztBQUNqREwsT0FBSU0sTUFBSixDQUFXSyxRQUFYLENBQXFCUixPQUFRLElBQVIsQ0FBckI7QUFDQSxHQUZEOztBQUlBO0FBQ0FILE1BQUlZLGVBQUosQ0FBcUJULE9BQVEsbUJBQVIsQ0FBckI7O0FBRUE7QUFDQUgsTUFBSWEsZ0JBQUo7QUFDQSxFQWxDRCxFQWtDRyxFQWxDSDtBQW1DQTs7QUFFRDs7Ozs7OztBQU9PLFNBQVMvSixZQUFULENBQXVCMEIsUUFBdkIsRUFBa0M7QUFDeEMsS0FBSUUsT0FBTyxNQUFYOztBQUVBLEtBQUssUUFBT0YsU0FBVSxlQUFWLENBQVAsYUFBNkNBLFNBQVUsZUFBVixDQUE3QyxDQUFMLEVBQWdGO0FBQy9FLE1BQUtBLFNBQVUsZUFBVixNQUFnQyxTQUFoQyxJQUE2Q0EsU0FBVSxlQUFWLE1BQWdDLFlBQWxGLEVBQWlHO0FBQ2hHRSxVQUFPRixTQUFVLGVBQVYsQ0FBUDtBQUNBO0FBQ0Q7O0FBRUQsUUFBT0UsSUFBUDtBQUNBOztBQUVEOzs7Ozs7O0FBT08sU0FBUzNCLG9CQUFULENBQStCaUIsUUFBL0IsRUFBMEM7QUFDaEQsS0FBTThJLFdBQVcsRUFBakI7O0FBRUE7QUFDQXhILEdBQUUrRyxJQUFGLENBQVEzRixlQUFlOUIsTUFBdkIsRUFBK0IsaUJBQVM7QUFDdkMsTUFBS0MsTUFBTUgsSUFBTixLQUFlLGFBQXBCLEVBQW9DO0FBQ25Db0ksWUFBUzNILElBQVQsQ0FBZU4sTUFBTUgsSUFBckI7QUFDQTtBQUNELEVBSkQ7O0FBTUEsUUFBTzNDLFVBQVdpQyxRQUFYLEVBQXFCOEksUUFBckIsQ0FBUDtBQUNBOztBQUVEOzs7Ozs7QUFNTyxTQUFTOUosV0FBVCxDQUFzQitKLEdBQXRCLEVBQTJCbEcsT0FBM0IsRUFBcUM7QUFDM0NBLFdBQVV2QixFQUFFNkIsUUFBRixDQUFZTixPQUFaLEVBQXFCO0FBQzlCbUcsY0FBWSxJQURrQjtBQUU5QkMsb0JBQWtCO0FBRlksRUFBckIsQ0FBVjs7QUFLQTtBQUNBRixLQUFJcEcsSUFBSixDQUFVLG9DQUFWLEVBQWlEMEYsSUFBakQsQ0FBdUQsWUFBVztBQUNqRTtBQUNBLE1BQUtGLE9BQVEsSUFBUixFQUFleEIsSUFBZixDQUFxQixjQUFyQixDQUFMLEVBQTZDO0FBQzVDd0IsVUFBUSxJQUFSLEVBQWVlLEVBQWYsQ0FBbUIsZ0JBQW5CLEVBQXFDLFVBQVVDLENBQVYsRUFBYztBQUNsRCxRQUFNQyxNQUFNRCxFQUFFRSxNQUFGLENBQVNDLElBQVQsQ0FBY0MsT0FBMUI7QUFBQSxRQUNDQyxPQUFPckIsT0FBUWlCLEdBQVIsQ0FEUjtBQUFBLFFBRUNLLEtBQUt0QixPQUFRLElBQVIsQ0FGTjtBQUdBc0IsT0FBR0MsTUFBSCxDQUFXRixJQUFYO0FBQ0FDLE9BQUdFLE9BQUgsQ0FBWSxnQkFBWjtBQUNBLElBTkQ7QUFPQTtBQUNEeEIsU0FBUSxJQUFSLEVBQWV5QixVQUFmLENBQTJCL0csT0FBM0I7QUFDQSxFQVpEO0FBYUE7O0FBRUQ7Ozs7Ozs7QUFPTyxTQUFTNUQsZUFBVCxDQUEwQjRCLEtBQTFCLEVBQWtDO0FBQ3hDO0FBQ0EsS0FBS0EsTUFBTUgsSUFBTixLQUFlLE1BQXBCLEVBQTZCO0FBQzVCLE1BQUtHLE1BQU02RixhQUFOLEtBQXdCLE1BQXhCLElBQWtDN0YsTUFBTTZGLGFBQU4sS0FBd0IsSUFBL0QsRUFBc0U7QUFDckU7O0FBRUEsT0FBSzdGLE1BQU8saUJBQVAsS0FDSkEsTUFBTyxnQkFBUCxDQURJLElBRUpBLE1BQU8sZ0JBQVAsQ0FGSSxJQUdKQSxNQUFPLGdCQUFQLENBSEQsRUFJRTtBQUNELFdBQU8sSUFBUDtBQUNBLElBTkQsTUFNTztBQUNOLFdBQU8sS0FBUDtBQUNBO0FBQ0Q7QUFDRDs7QUFFRDtBQUNBLEtBQUtBLE1BQU1ILElBQU4sS0FBZSxTQUFwQixFQUFnQztBQUMvQixNQUFLRyxNQUFPLHlCQUFQLEtBQ0pBLE1BQU8sdUJBQVAsQ0FESSxJQUVKQSxNQUFPLHVCQUFQLENBRkksSUFHSkEsTUFBTyx3QkFBUCxDQUhJLElBSUpBLE1BQU8sc0JBQVAsQ0FKSSxJQUtKQSxNQUFPLDBCQUFQLENBTEQsRUFNRTtBQUNELFVBQU8sSUFBUDtBQUNBLEdBUkQsTUFRTztBQUNOLFVBQU8sS0FBUDtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFPQSxNQUFNb0YsUUFBYjtBQUNBOztBQUVEOzs7QUFHTyxTQUFTL0cscUJBQVQsQ0FBZ0NjLFFBQWhDLEVBQTBDVSxJQUExQyxFQUFnRG1HLFNBQWhELEVBQTJEbkYsS0FBM0QsRUFBbUU7QUFDekUsS0FBSWYsVUFBVSxDQUFkOztBQUVBLEtBQUtrQixlQUFnQjdCLFFBQWhCLENBQUwsRUFBa0M7QUFDakMsU0FBTyxJQUFQO0FBQ0E7O0FBRURBLFVBQVNFLEdBQVQsQ0FBYyxtQkFBVztBQUN4QkMsVUFBUVMsTUFBUixDQUFlVixHQUFmLENBQW9CLGlCQUFTO0FBQzVCLE9BQUtRLFNBQVNHLE1BQU1ILElBQWYsSUFBdUJnQixVQUFVYixNQUFPZ0csU0FBUCxDQUF0QyxFQUEyRDtBQUMxRGxHO0FBQ0E7QUFDRCxHQUpEO0FBS0EsRUFORDs7QUFRQSxRQUFPQSxVQUFVLENBQWpCO0FBQ0E7O0FBRUQ7OztBQUdPLFNBQVN4QiwrQkFBVCxDQUEwQ2EsUUFBMUMsRUFBcUQ7QUFDM0QsS0FBSVcsVUFBVSxDQUFkOztBQUVBLEtBQUtrQixlQUFnQjdCLFFBQWhCLENBQUwsRUFBa0M7QUFDakMsU0FBTyxJQUFQO0FBQ0E7O0FBRURBLFVBQVNFLEdBQVQsQ0FBYyxtQkFBVztBQUN4QkMsVUFBUVMsTUFBUixDQUFlVixHQUFmLENBQW9CLGlCQUFTO0FBQzVCLE9BQU0ySixnQkFBZ0JuSCxlQUFlb0gsY0FBZixDQUErQmpKLE1BQU1rSixTQUFyQyxDQUF0QjtBQUNBLE9BQUksT0FBT0YsYUFBUCxLQUF5QixXQUE3QixFQUEyQztBQUMxQ0Esa0JBQWMzSixHQUFkLENBQW1CLG9CQUFZO0FBQzlCLFNBQU04SixlQUFlQyxTQUFTdkksS0FBVCxHQUFpQixXQUF0QztBQUNBLFNBQUksTUFBTU4sU0FBVVAsTUFBT21KLFlBQVAsQ0FBVixDQUFWLEVBQThDO0FBQzdDcko7QUFDQTtBQUNELEtBTEQ7QUFNQTtBQUNELEdBVkQ7QUFXQSxFQVpEOztBQWNBLFFBQU9BLFVBQVUsQ0FBakI7QUFDQTs7QUFFRDs7Ozs7OztBQU9PLFNBQVN2Qix1QkFBVCxDQUFrQzhLLGtCQUFsQyxFQUFzREMsU0FBdEQsRUFBa0U7QUFDeEUsS0FBTUMsa0JBQWtCRixtQkFBbUJ6SCxJQUEzQztBQUNBLEtBQUk0SCxpQkFBaUIsRUFBckI7O0FBRUEsS0FBSyxDQUFFL0ksRUFBRUMsT0FBRixDQUFXNEksU0FBWCxDQUFQLEVBQWdDO0FBQy9CN0ksSUFBRStHLElBQUYsQ0FBUThCLFNBQVIsRUFBbUIsVUFBVUcsUUFBVixFQUFvQkMsV0FBcEIsRUFBa0M7QUFDcEQsT0FBSyxDQUFFakosRUFBRUMsT0FBRixDQUFXK0ksU0FBU0UsT0FBcEIsQ0FBUCxFQUF1QztBQUN0Q2xKLE1BQUUrRyxJQUFGLENBQVFpQyxTQUFTRSxPQUFqQixFQUEwQixVQUFVQyxNQUFWLEVBQWtCQyxTQUFsQixFQUE4QjtBQUN2RCxTQUFLRCxPQUFPRSxNQUFQLEtBQWtCUCxlQUF2QixFQUF5QztBQUN4Q0MscUJBQWVsSixJQUFmLENBQXFCO0FBQ3BCeUosY0FBT04sU0FBU00sS0FESTtBQUVwQm5JLGFBQU02SCxTQUFTN0gsSUFGSztBQUdwQjZILGlCQUFVQTtBQUhVLE9BQXJCO0FBS0E7QUFDRCxLQVJEO0FBU0E7QUFDRCxHQVpEO0FBYUFELG1CQUFpQi9JLEVBQUV1SixJQUFGLENBQVFSLGNBQVIsRUFBd0IsTUFBeEIsQ0FBakI7QUFDQTs7QUFFRCxRQUFPQSxjQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7O0FBUU8sU0FBU2hMLGlCQUFULENBQTRCeUwsVUFBNUIsRUFBd0NDLFFBQXhDLEVBQW1EOztBQUV6RCxLQUFJQyxlQUFlLEVBQW5COztBQUVBMUosR0FBRStHLElBQUYsQ0FBUTBDLFFBQVIsRUFBa0IsVUFBVUUsT0FBVixFQUFtQkMsS0FBbkIsRUFBMkI7QUFDNUMsTUFBSyxDQUFFRCxRQUFRRSxXQUFWLElBQXlCLENBQUVGLFFBQVFHLFNBQXhDLEVBQW9EO0FBQ25ETixjQUFXTyxLQUFYLEdBQW1CM04sVUFBVyw4Q0FBWCxDQUFuQjtBQUNBb04sY0FBV1EsT0FBWCxHQUFxQixLQUFyQjtBQUNBTixnQkFBYTdKLElBQWIsQ0FBbUIrSixLQUFuQjtBQUNBOztBQUVELE1BQUssYUFBYUQsUUFBUU0sY0FBckIsS0FDQSxZQUFZTixRQUFRRSxXQUFwQixJQUFtQzdKLEVBQUVDLE9BQUYsQ0FBVzBKLFFBQVFPLE1BQW5CLENBQXJDLElBQ0MsZUFBZVAsUUFBUUUsV0FBdkIsSUFBc0M3SixFQUFFQyxPQUFGLENBQVcwSixRQUFRUSxRQUFuQixDQUZyQyxDQUFMLEVBSUU7QUFDRFgsY0FBV08sS0FBWCxHQUFtQjNOLFVBQVcsOENBQVgsQ0FBbkI7QUFDQW9OLGNBQVdRLE9BQVgsR0FBcUIsS0FBckI7QUFDQU4sZ0JBQWE3SixJQUFiLENBQW1CK0osS0FBbkI7QUFDQSxHQVJELE1BUU8sSUFBSyxtQkFBbUJELFFBQVFNLGNBQWhDLEVBQWlEO0FBQ3ZELE9BQU1HLHFCQUFxQixDQUFFcEssRUFBRTJDLFdBQUYsQ0FBZWdILFFBQVFVLHdCQUF2QixDQUFGLEdBQ3hCVixRQUFRVSx3QkFEZ0IsR0FFeEIsT0FGSDtBQUdBLE9BQU1DLHVCQUF1QixDQUFFdEssRUFBRTJDLFdBQUYsQ0FBZWdILFFBQVFZLGFBQXZCLENBQUYsR0FDMUJaLFFBQVFZLGFBRGtCLEdBRTFCLE9BRkg7QUFHQSxPQUFNQyxXQUFXLENBQUV4SyxFQUFFMkMsV0FBRixDQUFlZ0gsUUFBUWMsUUFBdkIsQ0FBRixHQUNkZCxRQUFRYyxRQURNLEdBRWQsQ0FGSDtBQUdBLE9BQU1DLFlBQVksQ0FBRTFLLEVBQUUyQyxXQUFGLENBQWVnSCxRQUFRZ0IsVUFBdkIsQ0FBRixHQUNmaEIsUUFBUWdCLFVBRE8sR0FFZixDQUZIO0FBR0EsT0FBTyxZQUFZUCxrQkFBWixJQUFrQ3BLLEVBQUVDLE9BQUYsQ0FBVzBKLFFBQVFpQixtQkFBbkIsQ0FBcEMsSUFDRixlQUFlUixrQkFBZixJQUFxQ3BLLEVBQUVDLE9BQUYsQ0FBVzBKLFFBQVFrQixxQkFBbkIsQ0FEeEMsRUFFRTtBQUNEckIsZUFBV08sS0FBWCxHQUFtQjNOLFVBQVcsOENBQVgsQ0FBbkI7QUFDQW9OLGVBQVdRLE9BQVgsR0FBcUIsS0FBckI7QUFDQU4saUJBQWE3SixJQUFiLENBQW1CK0osS0FBbkI7QUFDQTtBQUNELE9BQU8sWUFBWVUsb0JBQVosSUFBb0MsQ0FBRUUsUUFBeEMsSUFDRixlQUFlRixvQkFBZixJQUF1Q3RLLEVBQUVDLE9BQUYsQ0FBVzBKLFFBQVFtQixpQkFBbkIsQ0FEMUMsRUFFRTtBQUNEdEIsZUFBV08sS0FBWCxHQUFtQjNOLFVBQVcsOENBQVgsQ0FBbkI7QUFDQW9OLGVBQVdRLE9BQVgsR0FBcUIsS0FBckI7QUFDQU4saUJBQWE3SixJQUFiLENBQW1CK0osS0FBbkI7QUFDQTtBQUNELE9BQUssQ0FBRWMsU0FBUCxFQUFtQjtBQUNsQmxCLGVBQVdPLEtBQVgsR0FBbUIzTixVQUFXLDhDQUFYLENBQW5CO0FBQ0FvTixlQUFXUSxPQUFYLEdBQXFCLEtBQXJCO0FBQ0FOLGlCQUFhN0osSUFBYixDQUFtQitKLEtBQW5CO0FBQ0EsSUFKRCxNQUlPLElBQUtjLGFBQWEsQ0FBbEIsRUFBc0I7QUFDNUJsQixlQUFXTyxLQUFYLEdBQW1CM04sVUFBVyx3REFBWCxDQUFuQjtBQUNBb04sZUFBV1EsT0FBWCxHQUFxQixLQUFyQjtBQUNBTixpQkFBYTdKLElBQWIsQ0FBbUIrSixLQUFuQjtBQUNBO0FBQ0Q7QUFDRCxFQXBERDs7QUFzREEsS0FBS0YsYUFBYXhHLE1BQWIsR0FBc0IsQ0FBM0IsRUFBK0I7QUFDOUJzRyxhQUFXdUIsVUFBWCxHQUF3QnJCLFlBQXhCO0FBQ0E7O0FBRUQsUUFBT0YsVUFBUDtBQUNBOztBQUVEOzs7Ozs7O0FBT08sU0FBU3hMLE1BQVQsQ0FBa0JvQyxLQUFsQixFQUF5QjtBQUM1QixLQUFLLGdCQUFnQixPQUFRQSxLQUE3QixFQUF1QztBQUN6QyxTQUFPLEtBQVA7QUFDRztBQUNELEtBQUssYUFBYSxPQUFRQSxLQUExQixFQUFvQztBQUNuQ0EsVUFBUUEsTUFBTUMsSUFBTixHQUFhMkssV0FBYixFQUFSO0FBQ0E7O0FBRUQsU0FBUTVLLEtBQVI7QUFDSSxPQUFLLElBQUw7QUFDQSxPQUFLLE1BQUw7QUFDQSxPQUFLLENBQUw7QUFDQSxPQUFLLEdBQUw7QUFDQSxPQUFLLElBQUw7QUFDQSxPQUFLLEtBQUw7QUFDSSxVQUFPLElBQVA7QUFDSjtBQUNJLFVBQU8sS0FBUDtBQVRSO0FBV0g7O0FBRUQ7Ozs7O0FBS08sU0FBU25DLGdCQUFULEdBQTZCO0FBQ25DLEtBQUlnTixtQkFBbUIsRUFBdkI7QUFBQSxLQUNDQyxnQkFBZ0JDLFNBQVNDLE1BQVQsQ0FBZ0JDLFNBQWhCLENBQTBCLENBQTFCLEVBQTZCekwsS0FBN0IsQ0FBbUMsR0FBbkMsQ0FEakI7O0FBR0EsTUFBSyxJQUFJNEcsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMEUsY0FBY2hJLE1BQWxDLEVBQTBDc0QsR0FBMUMsRUFBK0M7QUFDOUMsTUFBSThFLFlBQVlKLGNBQWMxRSxDQUFkLEVBQWlCNUcsS0FBakIsQ0FBdUIsR0FBdkIsQ0FBaEI7QUFDQXFMLG1CQUFpQkssVUFBVSxDQUFWLENBQWpCLElBQWlDQyxtQkFBbUJELFVBQVUsQ0FBVixDQUFuQixDQUFqQztBQUNBOztBQUVELFFBQU9MLGdCQUFQO0FBQ0E7O0FBRUQ7Ozs7O0FBS08sU0FBUy9NLFFBQVQsQ0FBb0JzTixJQUFwQixFQUE4QztBQUFBLEtBQXBCQyxNQUFvQix1RUFBWCxRQUFXOztBQUNwRGhGLFFBQU9pRixJQUFQLENBQWFGLElBQWIsRUFBbUJDLE1BQW5CO0FBQ0EsQzs7Ozs7O0FDL2dERDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2THRDOzs7O0FBQ0E7Ozs7Ozs7Ozs7SUFFcUJFLEs7OztBQUNwQixnQkFBYTVNLEtBQWIsRUFBcUI7QUFBQTs7QUFBQSw0R0FDYkEsS0FEYTs7QUFHcEIsUUFBSzZNLFdBQUwsR0FBbUIsTUFBS0EsV0FBTCxDQUFpQkMsSUFBakIsT0FBbkI7QUFIb0I7QUFJcEI7Ozs7OEJBRVl6TCxLLEVBQVE7QUFDcEI7QUFDQSxPQUFLLE9BQU8sS0FBS3JCLEtBQUwsQ0FBVytNLGNBQWxCLEtBQXFDLFVBQTFDLEVBQXVEO0FBQ3REO0FBQ0EsU0FBSy9NLEtBQUwsQ0FBVytNLGNBQVgsQ0FBMkIsS0FBSy9NLEtBQUwsQ0FBV2dOLFFBQXRDLEVBQWdEM0wsS0FBaEQ7QUFDQSxJQUhELE1BR087QUFDTjtBQUNBLFNBQUtyQixLQUFMLENBQVdpTixPQUFYLENBQW1CQyxlQUFuQixDQUFtQ0MsYUFBbkMsQ0FBa0QsS0FBS25OLEtBQUwsQ0FBV2dOLFFBQTdELEVBQXVFM0wsS0FBdkU7QUFDQTtBQUNEOzs7MEJBRVFBLEssRUFBUTtBQUNoQixPQUFLLEtBQUtyQixLQUFMLENBQVdvTixVQUFoQixFQUE2QjtBQUM1QixXQUFPLEtBQUtwTixLQUFMLENBQVdvTixVQUFYLElBQXlCLENBQUVuTSxFQUFFQyxPQUFGLENBQVdHLEtBQVgsQ0FBbEM7QUFDQSxJQUZELE1BRU8sSUFBSyxDQUFFSixFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdxTixVQUExQixDQUFQLEVBQWdEO0FBQ3RELFdBQU9wTSxFQUFFQyxPQUFGLENBQVdHLEtBQVgsS0FBc0JBLFNBQVMsQ0FBdEM7QUFDQTs7QUFFRCxVQUFPLElBQVA7QUFDQTs7OzJCQUVRO0FBQUE7O0FBQ1IsT0FBTUEsUUFBUUosRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXRyxRQUFYLENBQXFCLEtBQUtILEtBQUwsQ0FBV2dOLFFBQWhDLENBQWYsSUFDWCxLQUFLaE4sS0FBTCxDQUFXc04sWUFEQSxHQUVYLEtBQUt0TixLQUFMLENBQVdHLFFBQVgsQ0FBcUIsS0FBS0gsS0FBTCxDQUFXZ04sUUFBaEMsQ0FGSDs7QUFJQSxPQUFNM00sT0FBTyxDQUFFWSxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdLLElBQTFCLENBQUYsR0FBcUMsS0FBS0wsS0FBTCxDQUFXSyxJQUFoRCxHQUF1RCxNQUFwRTs7QUFFQSxPQUFNa04sZ0JBQWdCLENBQUV0TSxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVd1TixhQUExQixDQUFGLEdBQThDLEtBQUt2TixLQUFMLENBQVd1TixhQUF6RCxHQUF5RSxzQkFBVyx5QkFBWCxDQUEvRjs7QUFFQSxPQUFNQyxnQkFBZ0IsQ0FBRSxLQUFLdkMsT0FBTCxDQUFjNUosS0FBZCxDQUFGLEdBQTBCLHNCQUExQixHQUFtRCxFQUF6RTs7QUFFQSxPQUFNb00sYUFBYSxDQUFFeE0sRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXeU4sVUFBMUIsQ0FBRixHQUNoQixvQkFBb0IsS0FBS3pOLEtBQUwsQ0FBV3lOLFVBRGYsR0FFaEIsZ0JBRkg7O0FBSUEsT0FBSUMsYUFBYSxrQkFBakI7O0FBRUEsT0FBSyxDQUFFek0sRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXME4sVUFBMUIsQ0FBRixJQUE0QyxPQUFPLEtBQUsxTixLQUFMLENBQVcwTixVQUFuRSxFQUFnRjtBQUMvRUEsa0JBQWMsTUFBTSxLQUFLMU4sS0FBTCxDQUFXME4sVUFBL0I7QUFDQTs7QUFFRCxPQUFLLENBQUV6TSxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVcyTixNQUExQixDQUFGLElBQXdDLE9BQU8sS0FBSzNOLEtBQUwsQ0FBVzJOLE1BQS9ELEVBQXdFO0FBQ3ZFRCxrQkFBYyx1QkFBZDtBQUNBOztBQUVELE9BQUssQ0FBRXpNLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV3lHLE1BQTFCLENBQUYsSUFBd0MsT0FBTyxLQUFLekcsS0FBTCxDQUFXeUcsTUFBL0QsRUFBd0U7QUFDdkVpSCxrQkFBYyx1QkFBZDtBQUNBOztBQUVELE9BQU1FLFVBQVUsQ0FBRTNNLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBVzROLE9BQTFCLENBQUYsR0FDYixLQUFLNU4sS0FBTCxDQUFXNE4sT0FERSxHQUViLEtBQUs1TixLQUFMLENBQVdnTixRQUZkOztBQUlBLE9BQUlhLG1CQUFKOztBQUVBLE9BQUssS0FBSzdOLEtBQUwsQ0FBVzBCLEtBQWhCLEVBQXdCO0FBQ3ZCbU0saUJBQ0M7QUFBQTtBQUFBO0FBQ0MscUNBQStCRCxPQURoQztBQUVDLGlCQUFZLEtBQUs1TixLQUFMLENBQVc4TixTQUFYLEdBQ1QsNkJBRFMsR0FFVDtBQUpKO0FBT0csVUFBSzlOLEtBQUwsQ0FBVzBCLEtBUGQ7QUFRRyxVQUFLMUIsS0FBTCxDQUFXb04sVUFBWCxJQUNEO0FBQUMscUJBQUQsQ0FBTyxRQUFQO0FBQUE7QUFBQTtBQUNPO0FBQUE7QUFBQSxTQUFNLFdBQVUsV0FBaEI7QUFBQTtBQUFBO0FBRFAsTUFURjtBQWFHLFVBQUtwTixLQUFMLENBQVcrTixJQUFYLElBQ0Q7QUFBQTtBQUFBLFFBQU0sV0FBVSxnQkFBaEI7QUFBbUMsV0FBSy9OLEtBQUwsQ0FBVytOO0FBQTlDO0FBZEYsS0FERDtBQW1CQTs7QUFFRCxPQUFNQyxhQUNMLGtEQUFPLE1BQU8zTixJQUFkO0FBQ0MsaUJBQWMsS0FBS0wsS0FBTCxDQUFXaU8sV0FEMUI7QUFFQyxXQUFRNU0sU0FBUyxFQUZsQjtBQUdDLDhCQUEwQnVNLE9BSDNCO0FBSUMsZUFBWUY7QUFKYixNQUtPLEtBQUsxTixLQUFMLENBQVdrTyxXQUFYLElBQTBCLEVBQUVDLFVBQVUsRUFBWixFQUxqQyxFQU1PLEtBQUtuTyxLQUFMLENBQVdvTyxRQUFYLElBQXVCLEVBQUVoUCxLQUFLLEtBQUtZLEtBQUwsQ0FBV29PLFFBQWxCLEVBTjlCLEVBT08sS0FBS3BPLEtBQUwsQ0FBV2dCLFFBQVgsSUFBdUIsRUFBRXpCLEtBQUssS0FBS1MsS0FBTCxDQUFXZ0IsUUFBbEIsRUFQOUIsRUFRTyxLQUFLaEIsS0FBTCxDQUFXcU8sSUFBWCxJQUFtQixFQUFFQSxNQUFNLEtBQUtyTyxLQUFMLENBQVdxTyxJQUFuQixFQVIxQixFQVNPLEtBQUtyTyxLQUFMLENBQVdzTyxTQUFYLElBQXdCLEVBQUVBLFdBQVcsS0FBS3RPLEtBQUwsQ0FBV3NPLFNBQXhCLEVBVC9CLEVBVU8sS0FBS3RPLEtBQUwsQ0FBV3VPLFdBQVgsSUFBMEIsRUFBRUMsT0FBTyxLQUFLeE8sS0FBTCxDQUFXdU8sV0FBcEIsRUFWakM7QUFXQyxjQUFXLEtBQUt2TyxLQUFMLENBQVd5SSxRQUFYLEdBQXNCLElBQXRCLEdBQTZCLEtBWHpDO0FBWUMsY0FBVyxxQkFBSztBQUNmLFlBQUtvRSxXQUFMLENBQWtCL0QsRUFBRTRELE1BQUYsQ0FBU3JMLEtBQTNCO0FBQ0E7QUFkRixNQUREOztBQW1CQSxPQUFNM0QsWUFDTDtBQUFBO0FBQUEsTUFBSyxXQUFnQitQLFVBQWhCLFNBQWdDRCxhQUFyQztBQUNHSyxjQURIO0FBRUssS0FBRTVNLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBVzJOLE1BQTFCLENBQUYsSUFBd0MsT0FBTyxLQUFLM04sS0FBTCxDQUFXMk4sTUFBNUQsSUFDRDtBQUFBO0FBQUEsT0FBTSxXQUFVLGtCQUFoQjtBQUFxQyxVQUFLM04sS0FBTCxDQUFXMk47QUFBaEQsS0FIRjtBQUtLLEtBQUUsS0FBSzNOLEtBQUwsQ0FBV3lPLFFBQWIsR0FDRFQsVUFEQyxHQUVEO0FBQUE7QUFBQSxPQUFLLFdBQVUsc0NBQWY7QUFDQ0EsZUFERDtBQUVEO0FBQUE7QUFBQSxRQUFRLFdBQVUsbURBQWxCO0FBQ0MsdUJBQWUsc0JBQVcsUUFBWCxDQURoQjtBQUVDLDJDQUFHLFdBQVUsZ0JBQWIsRUFBOEIsZUFBWSxNQUExQztBQUZEO0FBRkMsS0FQSjtBQWVHLFNBQUtoTyxLQUFMLENBQVd5RyxNQUFYLElBQ0Q7QUFBQTtBQUFBLE9BQU0sV0FBVSxrQkFBaEI7QUFBcUMsVUFBS3pHLEtBQUwsQ0FBV3lHO0FBQWhELEtBaEJGO0FBa0JHLFNBQUt6RyxLQUFMLENBQVdvTixVQUFYLElBQXlCLENBQUUsS0FBS25DLE9BQUwsQ0FBYzVKLEtBQWQsQ0FBM0IsSUFDRDtBQUFBO0FBQUEsT0FBTSxXQUFVLG1CQUFoQjtBQUFzQ2tNO0FBQXRDLEtBbkJGO0FBcUJHLEtBQUV0TSxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdxTixVQUExQixDQUFGLElBQTRDLENBQUUsS0FBS3BDLE9BQUwsQ0FBYzVKLEtBQWQsQ0FBOUMsSUFDRDtBQUFBO0FBQUEsT0FBTSxXQUFVLG1CQUFoQjtBQUFzQywyQkFBVyw0QkFBWDtBQUF0QyxLQXRCRjtBQXdCRyxTQUFLckIsS0FBTCxDQUFXME8sV0FBWCxJQUNEO0FBQUE7QUFBQSxPQUFNLFdBQVUsaUJBQWhCO0FBQW9DLFVBQUsxTyxLQUFMLENBQVcwTztBQUEvQztBQXpCRixJQUREOztBQStCQSxPQUFLLEtBQUsxTyxLQUFMLENBQVcyTyxNQUFoQixFQUF5QjtBQUN4QixXQUFPWCxVQUFQO0FBQ0E7O0FBRUQsVUFBT3RRLFNBQVA7QUFDQTs7OztFQTVJaUNrUixnQjs7a0JBQWRoQyxLOzs7Ozs7Ozs7Ozs7Ozs7QUNIckI7Ozs7Ozs7Ozs7OztJQUVxQmlDLFM7OztBQUNwQixvQkFBYTdPLEtBQWIsRUFBcUI7QUFBQTs7QUFBQSwrR0FDYkEsS0FEYTtBQUVwQjs7OzsyQkFFUTtBQUNSLE9BQU04TyxXQUFXQyxnQkFBTUMsUUFBTixDQUFlblAsR0FBZixDQUFvQixLQUFLRyxLQUFMLENBQVc4TyxRQUEvQixFQUF5QyxpQkFBUztBQUNsRSxXQUFPRyxLQUFQO0FBQ0EsSUFGZ0IsQ0FBakI7O0FBSUEsVUFDQztBQUFBO0FBQUE7QUFDR0g7QUFESCxJQUREO0FBS0E7Ozs7RUFmcUNGLGdCOztrQkFBbEJDLFM7Ozs7Ozs7Ozs7Ozs7OztBQ0ZyQjs7Ozs7Ozs7Ozs7O0lBRXFCSyxHOzs7QUFDcEIsY0FBYWxQLEtBQWIsRUFBcUI7QUFBQTs7QUFBQSxtR0FDYkEsS0FEYTtBQUVwQjs7OzsyQkFFUTtBQUNSLE9BQU04TyxXQUFXQyxnQkFBTUMsUUFBTixDQUFlblAsR0FBZixDQUFvQixLQUFLRyxLQUFMLENBQVc4TyxRQUEvQixFQUF5QyxvQkFBWTtBQUNyRSxXQUFPQSxRQUFQO0FBQ0EsSUFGZ0IsQ0FBakI7O0FBSUEsT0FBTUssY0FBYyxLQUFLblAsS0FBTCxDQUFXbVAsV0FBWCxHQUF5QixLQUFLblAsS0FBTCxDQUFXbVAsV0FBcEMsR0FBa0QsRUFBdEU7O0FBRUEsVUFDQztBQUFBO0FBQUEsTUFBSywyQkFBMkIsS0FBS25QLEtBQUwsQ0FBVzhCLElBQXRDLFNBQWdEcU4sV0FBckQ7QUFDR0w7QUFESCxJQUREO0FBS0E7Ozs7RUFqQitCRixnQjs7a0JBQVpNLEc7Ozs7Ozs7Ozs7Ozs7OztBQ0ZyQjs7OztBQUNBOzs7Ozs7Ozs7O0lBRXFCRSxXOzs7QUFDcEIsc0JBQWFwUCxLQUFiLEVBQXFCO0FBQUE7O0FBQUEsd0hBQ2JBLEtBRGE7O0FBR3BCLFFBQUs2TSxXQUFMLEdBQW1CLE1BQUtBLFdBQUwsQ0FBaUJDLElBQWpCLE9BQW5CO0FBSG9CO0FBSXBCOzs7O3NDQUVtQjtBQUNuQixRQUFLcEUsR0FBTCxHQUFXWixPQUFRLEtBQUt1SCxFQUFiLENBQVg7QUFDQSxRQUFLM0csR0FBTCxDQUFTNEcsYUFBVCxDQUF3QjtBQUN2QkMsWUFBUSxnQkFBVUMsS0FBVixFQUFpQkMsRUFBakIsRUFBc0I7QUFDN0IsU0FBTUMsUUFBUTVILE9BQVEsSUFBUixDQUFkO0FBQ0E0SCxXQUFNeEksR0FBTixDQUFXdUksR0FBR0UsS0FBSCxDQUFTQyxLQUFULEVBQVgsRUFBOEJ0RyxPQUE5QixDQUF1QyxRQUF2QztBQUNBLEtBSnNCO0FBS3ZCdUcsY0FBVSxDQUNULFNBRFMsRUFFVCxTQUZTLEVBR1QsU0FIUyxFQUlULFNBSlMsRUFLVCxTQUxTLEVBTVQsU0FOUyxFQU9ULFNBUFM7QUFMYSxJQUF4Qjs7QUFnQkEsT0FBTUMsa0JBQWtCLEtBQUtwSCxHQUE3QjtBQUFBLE9BQ0NxSCxhQUFhRCxnQkFBZ0JFLE9BQWhCLENBQXlCLHVCQUF6QixDQURkO0FBQUEsT0FFQ0Msa0JBQWtCRixXQUFXek4sSUFBWCxDQUFpQiwwQ0FBakIsQ0FGbkI7QUFBQSxPQUdDNE4sa0JBQWtCSCxXQUFXek4sSUFBWCxDQUFpQix3QkFBakIsQ0FIbkI7QUFBQSxPQUlDNk4sa0JBQWtCRCxnQkFBZ0I1TixJQUFoQixDQUFzQixRQUF0QixDQUpuQjs7QUFPQSxPQUFNOE4sWUFBWU4sZ0JBQWdCRSxPQUFoQixDQUF5QixzQkFBekIsQ0FBbEI7QUFBQSxPQUNDSyxrQkFBa0JELFVBQVU5TixJQUFWLENBQWdCLGtCQUFoQixDQURuQjtBQUFBLE9BRUNnTyxpQkFBaUJELGdCQUFnQi9OLElBQWhCLENBQXNCLGNBQXRCLENBRmxCO0FBQUEsT0FHQ2lPLGlCQUFpQkgsVUFBVTlOLElBQVYsQ0FBZ0Isa0JBQWhCLENBSGxCOztBQU1BLE9BQUlrTyxvQkFBb0JGLGNBQXhCOztBQUVBO0FBQ0EsT0FBS1IsZ0JBQWdCN0csSUFBaEIsQ0FBc0IsT0FBdEIsTUFBb0MsSUFBekMsRUFBZ0Q7QUFDL0N1SCx3QkFBb0JGLGNBQXBCO0FBQ0EsSUFGRCxNQUVPO0FBQ05FLHdCQUFvQkgsZUFBcEI7QUFDQTs7QUFFRDtBQUNBUCxtQkFBZ0JoRCxJQUFoQixDQUFzQixRQUF0QixFQUFnQyxZQUFXO0FBQzFDO0FBQ0FtRCxvQkFBZ0IzTixJQUFoQixDQUFzQixNQUF0QixFQUErQm1PLEdBQS9CLENBQW9DO0FBQ25DLHlCQUFvQkQsa0JBQWtCQyxHQUFsQixDQUF1QixrQkFBdkI7QUFEZSxLQUFwQzs7QUFJQTtBQUNBUCxvQkFBZ0I1TixJQUFoQixDQUFzQixPQUF0QixFQUFnQzRFLEdBQWhDLENBQXFDNEksZ0JBQWdCNUksR0FBaEIsRUFBckM7QUFDQSxJQVJEOztBQVVBO0FBQ0E2SSxjQUFXek4sSUFBWCxDQUFpQixnQ0FBakIsRUFBb0R1RyxFQUFwRCxDQUF3RCxPQUF4RCxFQUFpRSxVQUFVQyxDQUFWLEVBQWM7QUFDOUVBLE1BQUU0SCxjQUFGO0FBQ0E1SCxNQUFFNkgsZUFBRjtBQUNBTixvQkFBZ0JPLEtBQWhCO0FBQ0EsSUFKRDs7QUFNQTtBQUNBVCxtQkFBZ0J0SCxFQUFoQixDQUFvQixPQUFwQixFQUE2QixVQUFVQyxDQUFWLEVBQWM7QUFDMUNBLE1BQUU0SCxjQUFGO0FBQ0E1SCxNQUFFNkgsZUFBRjs7QUFFQUosbUJBQWVLLEtBQWY7QUFDQVYsb0JBQWdCNU4sSUFBaEIsQ0FBc0IsT0FBdEIsRUFBZ0M0RSxHQUFoQyxDQUFxQyxFQUFyQztBQUNBK0ksb0JBQWdCM04sSUFBaEIsQ0FBc0IsTUFBdEIsRUFBK0JtTyxHQUEvQixDQUFvQztBQUNuQyx5QkFBb0I7QUFEZSxLQUFwQztBQUdBLElBVEQ7O0FBV0EsUUFBSzVELFdBQUwsR0FBbUIsS0FBS0EsV0FBTCxDQUFpQkMsSUFBakIsQ0FBdUIsSUFBdkIsQ0FBbkI7QUFDQSxRQUFLcEUsR0FBTCxDQUFTRyxFQUFULENBQWEsUUFBYixFQUF1QixLQUFLZ0UsV0FBNUI7QUFDQTs7OzhCQUVZL0QsQyxFQUFJO0FBQ2hCLE9BQU16SCxRQUFReUgsRUFBRTRELE1BQUYsQ0FBU3JMLEtBQXZCOztBQUVBO0FBQ0EsT0FBSyxPQUFPLEtBQUtyQixLQUFMLENBQVcrTSxjQUFsQixLQUFxQyxVQUExQyxFQUF1RDtBQUN0RDtBQUNBLFNBQUsvTSxLQUFMLENBQVcrTSxjQUFYLENBQ0MsS0FBSy9NLEtBQUwsQ0FBV2dOLFFBRFosRUFFQzNMLEtBRkQ7QUFJQSxJQU5ELE1BTU87QUFDTjtBQUNBLFNBQUtyQixLQUFMLENBQVdpTixPQUFYLENBQW1CQyxlQUFuQixDQUFtQ0MsYUFBbkMsQ0FBa0QsS0FBS25OLEtBQUwsQ0FBV2dOLFFBQTdELEVBQXVFM0wsS0FBdkU7QUFDQTtBQUNEOzs7eUNBRXNCO0FBQ3RCLFFBQUtxSCxHQUFMLENBQVNtSSxHQUFULENBQWMsUUFBZCxFQUF3QixLQUFLaEUsV0FBN0I7QUFDQSxRQUFLbkUsR0FBTCxDQUFTb0ksTUFBVCxHQUFrQkMsVUFBbEI7QUFDQTs7OzJCQUVRO0FBQUE7O0FBQ1IsT0FBTTFQLFFBQVVKLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV0csUUFBWCxDQUFxQixLQUFLSCxLQUFMLENBQVdnTixRQUFoQyxDQUFmLEtBQStELEtBQUtoTixLQUFMLENBQVdHLFFBQVgsQ0FBcUIsS0FBS0gsS0FBTCxDQUFXZ04sUUFBaEMsTUFBK0MsSUFBaEgsR0FDWCxLQUFLaE4sS0FBTCxDQUFXc04sWUFEQSxHQUVYLEtBQUt0TixLQUFMLENBQVdHLFFBQVgsQ0FBcUIsS0FBS0gsS0FBTCxDQUFXZ04sUUFBaEMsQ0FGSDs7QUFJQSxPQUFJL0csYUFBYSxFQUFqQjs7QUFFQSxPQUFLLEtBQUtqRyxLQUFMLENBQVcwQixLQUFoQixFQUF3QjtBQUN2QnVFLGlCQUNDO0FBQUE7QUFBQSxPQUFPLFdBQVUsV0FBakI7QUFDQyxxQ0FBK0IsS0FBS2pHLEtBQUwsQ0FBV2dOLFFBRDNDO0FBRUcsVUFBS2hOLEtBQUwsQ0FBVzBCLEtBRmQ7QUFHRyxVQUFLMUIsS0FBTCxDQUFXK04sSUFBWCxJQUNEO0FBQUE7QUFBQSxRQUFNLFdBQVUsZ0JBQWhCO0FBQUE7QUFBb0MsV0FBSy9OLEtBQUwsQ0FBVytOO0FBQS9DO0FBSkYsS0FERDtBQVNBOztBQUVELFVBQ0M7QUFBQTtBQUFBLE1BQUssV0FBVSxnQkFBZjtBQUNHOUgsY0FESDtBQUVDO0FBQUE7QUFBQSxPQUFLLFdBQVUsc0JBQWY7QUFDQztBQUFBO0FBQUE7QUFDQyx3REFBZ0QsS0FBS2pHLEtBQUwsQ0FBV2dSLE9BQVgsR0FDN0MsTUFENkMsR0FFN0MsS0FGSCxDQUREO0FBS0Msc0JBQVksTUFMYjtBQU1DO0FBQUE7QUFBQSxTQUFLLFdBQVUsdUJBQWY7QUFDQztBQUFBO0FBQUEsVUFBTSxNQUFLLFFBQVg7QUFDQyxnREFBTSxPQUFRLEVBQUVDLGlCQUFpQjVQLEtBQW5CLEVBQWQ7QUFERCxRQUREO0FBSUMsZ0RBQU8sTUFBSyxNQUFaLEVBQW1CLGNBQWVBLEtBQWxDO0FBQ0Msa0JBQVMsVUFEVixHQUpEO0FBTUM7QUFBQTtBQUFBO0FBQ0MsNkNBQUcsV0FBVSxnQkFBYixFQUE4QixlQUFZLE1BQTFDO0FBREQ7QUFORCxPQU5EO0FBZ0JDO0FBQUE7QUFBQSxTQUFRLFdBQVUsWUFBbEI7QUFBaUMsNkJBQVcsUUFBWDtBQUFqQztBQWhCRCxNQUREO0FBbUJDLDhDQUFPLEtBQU07QUFBQSxjQUFRLE9BQUtnTyxFQUFMLEdBQVVBLEVBQWxCO0FBQUEsT0FBYjtBQUNDLG9CQUFlaE8sS0FEaEI7QUFFQyxnQ0FBMEIsS0FBS3JCLEtBQUwsQ0FBV2dOLFFBRnRDO0FBR0MsaUJBQVUsdUJBSFg7QUFJQyxvQkFBYSxLQUFLaE4sS0FBTCxDQUFXZ1IsT0FBWCxHQUFxQixNQUFyQixHQUE4QjtBQUo1QztBQW5CRCxLQUZEO0FBNEJLLFNBQUtoUixLQUFMLENBQVcwTyxXQUFYLElBQTBCLE9BQU8sS0FBSzFPLEtBQUwsQ0FBVzBPLFdBQTlDLElBQ0Q7QUFBQTtBQUFBLE9BQU0sV0FBVSxpQkFBaEI7QUFBb0MsVUFBSzFPLEtBQUwsQ0FBVzBPO0FBQS9DO0FBN0JGLElBREQ7QUFrQ0E7Ozs7RUEzSnVDRSxnQjs7a0JBQXBCUSxXOzs7Ozs7Ozs7Ozs7Ozs7QUNIckI7Ozs7Ozs7Ozs7OztJQUVxQjhCLFM7OztBQUNwQixvQkFBYWxSLEtBQWIsRUFBcUI7QUFBQTs7QUFBQSwrR0FDYkEsS0FEYTtBQUVwQjs7Ozs4QkFFWXFCLEssRUFBUTtBQUNwQjtBQUNBLE9BQUssT0FBTyxLQUFLckIsS0FBTCxDQUFXK00sY0FBbEIsS0FBcUMsVUFBMUMsRUFBdUQ7QUFDdEQ7QUFDQSxTQUFLL00sS0FBTCxDQUFXK00sY0FBWCxDQUNDLEtBQUsvTSxLQUFMLENBQVdnTixRQURaLEVBRUMzTCxLQUZEO0FBSUEsSUFORCxNQU1PO0FBQ047QUFDQSxTQUFLckIsS0FBTCxDQUFXaU4sT0FBWCxDQUFtQkMsZUFBbkIsQ0FBbUNDLGFBQW5DLENBQWtELEtBQUtuTixLQUFMLENBQVdnTixRQUE3RCxFQUF1RTNMLEtBQXZFO0FBQ0E7QUFDRDs7O29DQUVpQjtBQUNqQixPQUFNaU0sZUFBZSxLQUFLdE4sS0FBTCxDQUFXbVIsT0FBWCxHQUFxQixLQUFLblIsS0FBTCxDQUFXbVIsT0FBaEMsR0FBMEMsRUFBL0Q7O0FBRUEsT0FBTTlQLFFBQVFKLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV0csUUFBWCxDQUFxQixLQUFLSCxLQUFMLENBQVdnTixRQUFoQyxDQUFmLElBQ1hNLFlBRFcsR0FFWCxLQUFLdE4sS0FBTCxDQUFXRyxRQUFYLENBQXFCLEtBQUtILEtBQUwsQ0FBV2dOLFFBQWhDLENBRkg7O0FBSUEsVUFBTzNMLEtBQVA7QUFDQTs7OzJCQUVRO0FBQUE7O0FBQ1IsT0FBTUEsUUFBUSxLQUFLcEYsZUFBTCxFQUFkOztBQUVBLE9BQU1tVixZQUFZckMsZ0JBQU1DLFFBQU4sQ0FBZW5QLEdBQWYsQ0FBb0IsS0FBS0csS0FBTCxDQUFXOE8sUUFBL0IsRUFBeUMsZUFBTztBQUNqRSxRQUFLLENBQUV1QyxHQUFQLEVBQWE7QUFDWixZQUNDLDhCQUFDLGVBQUQsQ0FBTyxRQUFQLE9BREQ7QUFHQTs7QUFFRCxRQUFNM1AsUUFBUSxDQUFFVCxFQUFFMkMsV0FBRixDQUFleU4sSUFBSXJSLEtBQUosQ0FBVTBCLEtBQXpCLENBQUYsR0FDWDJQLElBQUlyUixLQUFKLENBQVUwQixLQURDLEdBRVgyUCxJQUFJclIsS0FBSixDQUFVOE8sUUFGYjs7QUFJQSxRQUFLLE9BQUs5TyxLQUFMLENBQVd5SSxRQUFoQixFQUEyQjtBQUMxQixZQUNDO0FBQUE7QUFBQSxRQUFLLFdBQVksa0JBQW1CNEksSUFBSXJSLEtBQUosQ0FBVXFCLEtBQVYsS0FBb0JBLEtBQXBCLEdBQTRCLFNBQTVCLEdBQXdDLEVBQTNELENBQWpCO0FBQ0MsY0FBUTtBQUNQaVEsaUJBQVMsR0FERjtBQUVQQyxnQkFBUTtBQUZEO0FBRFQ7QUFNRzdQO0FBTkgsTUFERDtBQVVBOztBQUVELFFBQUssQ0FBRSxPQUFLMUIsS0FBTCxDQUFXeUksUUFBbEIsRUFBNkI7QUFDNUIsWUFDQztBQUFBO0FBQUEsUUFBSyxXQUFZLGtCQUFtQjRJLElBQUlyUixLQUFKLENBQVVxQixLQUFWLEtBQW9CQSxLQUFwQixHQUE0QixTQUE1QixHQUF3QyxFQUEzRCxDQUFqQjtBQUNDLGdCQUFVLE9BQUttUSxXQUFMLENBQWlCMUUsSUFBakIsQ0FBdUIsTUFBdkIsRUFBNkJ1RSxJQUFJclIsS0FBSixDQUFVcUIsS0FBdkM7QUFEWDtBQUdHSztBQUhILE1BREQ7QUFPQTtBQUNELElBakNpQixDQUFsQjs7QUFtQ0EsT0FBTStQLGVBQWUsQ0FBRXhRLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBVzBSLFFBQTFCLENBQUYsR0FDbEIsc0JBQXNCLEtBQUsxUixLQUFMLENBQVcwUixRQURmLEdBRWxCLGtCQUZIOztBQUlBLE9BQU1DLGNBQWM1QyxnQkFBTUMsUUFBTixDQUFlblAsR0FBZixDQUFvQixLQUFLRyxLQUFMLENBQVc4TyxRQUEvQixFQUF5QyxlQUFPO0FBQ25FLFFBQUssQ0FBRXVDLEdBQVAsRUFBYTtBQUNaLFlBQ0MsOEJBQUMsZUFBRCxDQUFPLFFBQVAsT0FERDtBQUdBOztBQUVELFFBQU1PLFdBQVcsQ0FBRTNRLEVBQUUyQyxXQUFGLENBQWV5TixJQUFJclIsS0FBSixDQUFVNFIsUUFBekIsQ0FBRixHQUNkUCxJQUFJclIsS0FBSixDQUFVNFIsUUFESSxHQUVkLEVBRkg7O0FBSUEsUUFBS1AsSUFBSWhSLElBQUosQ0FBU3dSLElBQVQsS0FBa0IsT0FBdkIsRUFBaUM7QUFDaEMsWUFDQztBQUFBO0FBQUEsUUFBSyxXQUNKRCxXQUFXLGtCQUFYLElBQWtDUCxJQUFJclIsS0FBSixDQUFVcUIsS0FBVixLQUFvQkEsS0FBcEIsR0FBNEIsU0FBNUIsR0FBd0MsRUFBMUUsQ0FERDtBQUdHZ1EsVUFBSXJSLEtBQUosQ0FBVXFCLEtBQVYsS0FBb0JBLEtBQXBCLElBQTZCZ1E7QUFIaEMsTUFERDtBQU9BOztBQUVELFdBQ0MsOEJBQUMsZUFBRCxDQUFPLFFBQVAsT0FERDtBQUdBLElBeEJtQixDQUFwQjs7QUEwQkEsT0FBSVMsWUFBWSxFQUFoQjs7QUFFQSxPQUFLLEtBQUs5UixLQUFMLENBQVcwQixLQUFYLElBQW9CLE9BQU8sS0FBSzFCLEtBQUwsQ0FBVzBCLEtBQTNDLEVBQW1EO0FBQ2xEb1EsZ0JBQ0M7QUFBQTtBQUFBLE9BQU8sK0JBQStCLEtBQUs5UixLQUFMLENBQVdnTixRQUFqRDtBQUNDLGlCQUFVLFdBRFg7QUFFRyxVQUFLaE4sS0FBTCxDQUFXMEIsS0FGZDtBQUdHLFVBQUsxQixLQUFMLENBQVcrTixJQUFYLElBQ0Q7QUFBQTtBQUFBLFFBQU0sV0FBVSxnQkFBaEI7QUFBQTtBQUFvQyxXQUFLL04sS0FBTCxDQUFXK047QUFBL0M7QUFKRixLQUREO0FBU0E7O0FBRUQsT0FBSWdFLGdCQUFnQixFQUFwQjs7QUFFQSxPQUFLLEtBQUsvUixLQUFMLENBQVcrUixhQUFYLElBQTRCLE9BQU8sS0FBSy9SLEtBQUwsQ0FBVytSLGFBQW5ELEVBQW1FO0FBQ2xFLFFBQU1DLGFBQWEsS0FBS2hTLEtBQUwsQ0FBV2dTLFVBQVgsR0FBd0IsS0FBS2hTLEtBQUwsQ0FBV2dTLFVBQW5DLEdBQWdELG9CQUFuRTtBQUNBRCxvQkFDQztBQUFBO0FBQUEsT0FBTyxXQUFZQyxVQUFuQjtBQUNHLFVBQUtoUyxLQUFMLENBQVcrUjtBQURkLEtBREQ7QUFLQTs7QUFFRCxPQUFJckQsY0FBYyxFQUFsQjs7QUFFQSxPQUFLLEtBQUsxTyxLQUFMLENBQVcwTyxXQUFYLElBQTBCLE9BQU8sS0FBSzFPLEtBQUwsQ0FBVzBPLFdBQWpELEVBQStEO0FBQzlEQSxrQkFDQztBQUFBO0FBQUE7QUFDQyxpQkFBVSxpQkFEWDtBQUVDLGFBQVEsRUFBRXVELGNBQWMsRUFBaEI7QUFGVDtBQUlHLFVBQUtqUyxLQUFMLENBQVcwTztBQUpkLEtBREQ7QUFRQTs7QUFFRCxPQUFJd0QsZUFBZSxDQUFFalIsRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXa1MsWUFBMUIsQ0FBRixHQUNoQixLQUFLbFMsS0FBTCxDQUFXa1MsWUFESyxHQUVoQixFQUZIOztBQUlBQSxrQkFBZSxLQUFLbFMsS0FBTCxDQUFXbVMsU0FBWCxtQ0FDbUJELFlBRG5CLHNCQUVNQSxZQUZyQjs7QUFJQSxPQUFJRSxhQUNIO0FBQUE7QUFBQSxNQUFLLFdBQVlGLFlBQWpCO0FBRUM7QUFBQTtBQUFBLE9BQUssV0FBVSxlQUFmO0FBQ0dkO0FBREgsS0FGRDtBQU1DO0FBQUE7QUFBQSxPQUFLLFdBQVlLLFlBQWpCO0FBQ0dFO0FBREg7QUFORCxJQUREOztBQWNBLE9BQUssQ0FBRSxLQUFLM1IsS0FBTCxDQUFXMk8sTUFBbEIsRUFBMkI7QUFDMUJ5RCxpQkFDQztBQUFBO0FBQUEsT0FBSyxXQUFVLGdCQUFmO0FBRUdMLGtCQUZIO0FBSUdELGNBSkg7QUFNR3BELGdCQU5IO0FBUUM7QUFBQTtBQUFBLFFBQUssV0FBWXdELFlBQWpCO0FBRUM7QUFBQTtBQUFBLFNBQUssV0FBVSxlQUFmO0FBQ0dkO0FBREgsT0FGRDtBQU1DO0FBQUE7QUFBQSxTQUFLLFdBQVlLLFlBQWpCO0FBQ0dFO0FBREg7QUFORDtBQVJELEtBREQ7QUF1QkE7O0FBRUQsVUFBT1MsVUFBUDtBQUNBOzs7O0VBeExxQ3hELGdCOztrQkFBbEJzQyxTOzs7Ozs7Ozs7Ozs7Ozs7QUNGckI7Ozs7Ozs7Ozs7OztJQUVxQm1CLEc7OztBQUNwQixjQUFhclMsS0FBYixFQUFxQjtBQUFBOztBQUFBLG1HQUNiQSxLQURhO0FBRXBCOzs7OzJCQUVRO0FBQ1IsT0FBTXNTLFVBQVV2RCxnQkFBTUMsUUFBTixDQUFlblAsR0FBZixDQUNmLEtBQUtHLEtBQUwsQ0FBVzhPLFFBREksRUFFZixvQkFBWTtBQUNYLFdBQU9BLFFBQVA7QUFDQSxJQUpjLENBQWhCOztBQU9BLFVBQ0M7QUFBQTtBQUFBLE1BQUssV0FBWSxhQUFjLENBQUU3TixFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVd1UyxLQUExQixDQUFGLEdBQzVCLE1BQU0sS0FBS3ZTLEtBQUwsQ0FBV3VTLEtBRFcsR0FFNUIsRUFGYyxDQUFqQjtBQUlHRDtBQUpILElBREQ7QUFRQTs7OztFQXJCK0IxRCxnQjs7a0JBQVp5RCxHOzs7Ozs7QUNGckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQkE7Ozs7Ozs7Ozs7OztJQUVxQkcsSTs7O0FBQ3BCLGVBQWF4UyxLQUFiLEVBQXFCO0FBQUE7O0FBQUEsMEdBQ2JBLEtBRGE7O0FBR3BCLFFBQUt5UyxLQUFMLEdBQWE7QUFDWkMsV0FBUSxNQUFLMVMsS0FBTCxDQUFXbVIsT0FBWCxHQUFxQixNQUFLblIsS0FBTCxDQUFXbVIsT0FBaEMsR0FBMEM7QUFEdEMsR0FBYjtBQUhvQjtBQU1wQjs7Ozs4QkFFWTlQLEssRUFBUTtBQUNwQixRQUFLc1IsUUFBTCxDQUFlO0FBQ2RELFlBQVFyUjtBQURNLElBQWY7QUFHQTs7OzJCQUVRO0FBQUE7O0FBQ1IsT0FBTWlNLGVBQWUsS0FBS3ROLEtBQUwsQ0FBV21SLE9BQVgsR0FBcUIsS0FBS25SLEtBQUwsQ0FBV21SLE9BQWhDLEdBQTBDLEVBQS9EOztBQUVBLE9BQU05USxPQUFPLEtBQUtMLEtBQUwsQ0FBV0ssSUFBWCxHQUFrQixLQUFLTCxLQUFMLENBQVdLLElBQTdCLEdBQW9DLFdBQWpEOztBQUVBLE9BQU11UyxhQUFhLEtBQUs1UyxLQUFMLENBQVc0UyxVQUFYLEdBQXdCLEtBQUs1UyxLQUFMLENBQVc0UyxVQUFuQyxHQUFnRCxFQUFuRTs7QUFFQSxPQUFNeEIsWUFBWXJDLGdCQUFNQyxRQUFOLENBQWVuUCxHQUFmLENBQW9CLEtBQUtHLEtBQUwsQ0FBVzhPLFFBQS9CLEVBQXlDLGVBQU87QUFDakUsUUFBSzdOLEVBQUUyQyxXQUFGLENBQWV5TixHQUFmLEtBQXdCcFEsRUFBRTRSLE1BQUYsQ0FBVXhCLEdBQVYsQ0FBN0IsRUFBK0M7QUFDOUM7QUFDQTs7QUFFRCxXQUNDO0FBQUE7QUFBQTtBQUNDLGlCQUFZLG9DQUNYQSxJQUFJclIsS0FBSixDQUFVcUIsS0FBVixLQUFvQixPQUFLb1IsS0FBTCxDQUFXQyxNQUEvQixHQUF3QyxTQUF4QyxHQUFvRCxFQUR6QyxDQURiO0FBSUMsZUFBVSxPQUFLbEIsV0FBTCxDQUFpQjFFLElBQWpCLENBQXVCLE1BQXZCLEVBQTZCdUUsSUFBSXJSLEtBQUosQ0FBVXFCLEtBQXZDO0FBSlg7QUFNR2dRLFNBQUlyUixLQUFKLENBQVUwQixLQU5iO0FBQUE7QUFNdUIyUCxTQUFJclIsS0FBSixDQUFVNEYsUUFBVixJQUNyQjtBQUFBO0FBQUEsUUFBTSxXQUFVLFdBQWhCO0FBQUE7QUFBQTtBQVBGLEtBREQ7QUFZQSxJQWpCaUIsQ0FBbEI7O0FBbUJBLE9BQU0rTCxjQUFjNUMsZ0JBQU1DLFFBQU4sQ0FBZW5QLEdBQWYsQ0FBb0IsS0FBS0csS0FBTCxDQUFXOE8sUUFBL0IsRUFBeUMsZUFBTztBQUNuRSxRQUFLN04sRUFBRTJDLFdBQUYsQ0FBZXlOLEdBQWYsS0FBd0JwUSxFQUFFNFIsTUFBRixDQUFVeEIsR0FBVixDQUE3QixFQUErQztBQUM5QztBQUNBOztBQUVELFFBQU15QixnQkFBZ0IsQ0FBRTdSLEVBQUUyQyxXQUFGLENBQWV5TixJQUFJclIsS0FBSixDQUFVNFIsUUFBekIsQ0FBRixHQUNyQlAsSUFBSXJSLEtBQUosQ0FBVTRSLFFBRFcsR0FDQSxpQkFEdEI7O0FBR0EsV0FDQztBQUFBO0FBQUEsT0FBSyxXQUFZa0IsaUJBQWtCekIsSUFBSXJSLEtBQUosQ0FBVXFCLEtBQVYsS0FBb0IsT0FBS29SLEtBQUwsQ0FBV0MsTUFBL0IsR0FBd0MsU0FBeEMsR0FBb0QsRUFBdEUsQ0FBakI7QUFDR3JCLFNBQUlyUixLQUFKLENBQVVxQixLQUFWLEtBQW9CLE9BQUtvUixLQUFMLENBQVdDLE1BQS9CLElBQXlDckI7QUFENUMsS0FERDtBQUtBLElBYm1CLENBQXBCOztBQWVBLFVBQ0M7QUFBQTtBQUFBLE1BQUssb0JBQW9CaFIsSUFBcEIsU0FBOEJ1UyxVQUFuQztBQUNDO0FBQUE7QUFBQSxPQUFLLFdBQVUsZUFBZjtBQUNHeEI7QUFESCxLQUREO0FBS0M7QUFBQTtBQUFBLE9BQUssV0FBVSxrQkFBZjtBQUNHTztBQURIO0FBTEQsSUFERDtBQVdBOzs7O0VBbkVnQy9DLGdCOztrQkFBYjRELEk7Ozs7Ozs7Ozs7Ozs7OztBQ0ZyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLFdBQVcsSUFBSTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxhQUFhO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBbUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlCQUF5Qjs7QUFFcEU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRSxhQUFhO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSx3RUFBd0UsYUFBYTtBQUNyRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3RUFBd0UsZUFBZTtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFUTs7Ozs7Ozs7Ozs7Ozs7a0JDemtCZ0JPLEs7O0FBRnhCOzs7Ozs7QUFFZSxTQUFTQSxLQUFULEdBQWlCO0FBQy9CLFFBQU8sRUFBUDtBQUNBLEM7Ozs7Ozs7Ozs7Ozs7OztBQ0prQztBQUNuQztBQUNBOzs7Ozs7Ozs7QUNGQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVMsR0FBRyxTQUFTO0FBQzVDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx5QkFBeUIsRUFBRTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoREE7Ozs7Ozs7Ozs7OztJQUVxQkMsVzs7O0FBQ3BCLHNCQUFhaFQsS0FBYixFQUFxQjtBQUFBOztBQUFBLG1IQUNiQSxLQURhO0FBRXBCOzs7OzJCQUVRO0FBQ1IsT0FBTWlULFVBQVVsRSxnQkFBTUMsUUFBTixDQUFlblAsR0FBZixDQUNmLEtBQUtHLEtBQUwsQ0FBVzhPLFFBREksRUFFZixvQkFBWTtBQUNYLFdBQU9BLFFBQVA7QUFDQSxJQUpjLENBQWhCOztBQU9BLE9BQUlwTixRQUFRLEVBQVo7O0FBRUEsT0FBSyxLQUFLMUIsS0FBTCxDQUFXMEIsS0FBWCxJQUFvQixPQUFPLEtBQUsxQixLQUFMLENBQVcwQixLQUEzQyxFQUFtRDtBQUNsREEsWUFDQztBQUFBO0FBQUEsT0FBTSxXQUNMLDhCQUNJLEtBQUsxQixLQUFMLENBQVdrVCxTQUFYLEtBQXlCLElBQXpCLEdBQWdDLFdBQWhDLEdBQThDLEVBRGxELEVBREQ7QUFJRyxVQUFLbFQsS0FBTCxDQUFXMEI7QUFKZCxLQUREO0FBUUE7O0FBRUQsT0FBSWdOLGNBQWMsRUFBbEI7QUFDQSxPQUFJeUUscUJBQXFCLEVBQXpCOztBQUVBLE9BQUssQ0FBRWxTLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV21ULGtCQUExQixDQUFGLElBQW9ELE9BQU8sS0FBS25ULEtBQUwsQ0FBV21ULGtCQUEzRSxFQUFnRztBQUMvRkEseUJBQXFCLEtBQUtuVCxLQUFMLENBQVdtVCxrQkFBaEM7QUFDQTs7QUFFRCxPQUFLLENBQUVsUyxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVcwTyxXQUExQixDQUFGLElBQTZDLE9BQU8sS0FBSzFPLEtBQUwsQ0FBVzBPLFdBQXBFLEVBQWtGO0FBQ2pGLFFBQUssS0FBSzFPLEtBQUwsQ0FBV29ULE9BQVgsS0FBdUIsS0FBNUIsRUFBb0M7QUFDbkMxRSxtQkFDQztBQUFBO0FBQUE7QUFDQyxrQkFBVSxpQkFEWDtBQUVDLGNBQVEsRUFBRXVELGNBQWNrQixxQkFBcUIsSUFBckM7QUFGVDtBQUlHLFdBQUtuVCxLQUFMLENBQVcwTztBQUpkLE1BREQ7QUFRQSxLQVRELE1BU087QUFDTkEsbUJBQ0M7QUFBQTtBQUFBLFFBQU0sV0FBVSxpQkFBaEI7QUFBb0MsV0FBSzFPLEtBQUwsQ0FBVzBPO0FBQS9DLE1BREQ7QUFHQTtBQUNEOztBQUVELE9BQUkwRSxVQUFVLEVBQWQ7O0FBRUEsT0FDRyxLQUFLcFQsS0FBTCxDQUFXMEIsS0FBWCxJQUFvQixPQUFPLEtBQUsxQixLQUFMLENBQVcwQixLQUF4QyxJQUNFLEtBQUsxQixLQUFMLENBQVcwTyxXQUFYLElBQTBCLE9BQU8sS0FBSzFPLEtBQUwsQ0FBVzBPLFdBRi9DLEVBR0U7QUFDRDBFLGNBQ0M7QUFBQTtBQUFBLE9BQUssV0FBVSx3QkFBZjtBQUNHMVIsVUFESDtBQUVHZ047QUFGSCxLQUREO0FBTUE7O0FBRUQsT0FBTTJFLG9CQUFvQixLQUFLclQsS0FBTCxDQUFXc1QsU0FBWCxHQUN2QixFQUFFckIsY0FBYyxDQUFoQixFQUFtQnNCLGNBQWMsT0FBakMsRUFEdUIsR0FFdkIsRUFGSDs7QUFJQSxVQUNDO0FBQUE7QUFBQSxNQUFLLFdBQVUsc0JBQWYsRUFBc0MsT0FBUUYsaUJBQTlDO0FBQ0csS0FBRXBTLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV29ULE9BQTFCLEtBQXVDLEtBQUtwVCxLQUFMLENBQVdvVCxPQUFYLEtBQXVCLEtBQWhFLEtBQ0RBLE9BRkY7QUFJQztBQUFBO0FBQUEsT0FBSyxXQUFVLHdCQUFmO0FBQ0ssTUFBRW5TLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV29ULE9BQTFCLENBQUYsSUFBeUMsS0FBS3BULEtBQUwsQ0FBV29ULE9BQVgsS0FBdUIsS0FBbEUsSUFDRDFSLEtBRkY7QUFJSyxNQUFFVCxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdvVCxPQUExQixDQUFGLElBQXlDLEtBQUtwVCxLQUFMLENBQVdvVCxPQUFYLEtBQXVCLEtBQWxFLElBQ0QxRSxXQUxGO0FBT0d1RTtBQVBIO0FBSkQsSUFERDtBQWdCQTs7OztFQXBGdUNyRSxnQjs7a0JBQXBCb0UsVzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGckI7Ozs7Ozs7Ozs7Ozs7O0lBRXFCUSxVOzs7QUFDcEIscUJBQWF4VCxLQUFiLEVBQXFCO0FBQUE7O0FBQUEsc0hBQ2JBLEtBRGE7O0FBR3BCLFFBQUs2TSxXQUFMLEdBQW1CLE1BQUtBLFdBQUwsQ0FBaUJDLElBQWpCLE9BQW5CO0FBQ0EsUUFBSzJHLFNBQUwsR0FBaUIsTUFBS0EsU0FBTCxDQUFlM0csSUFBZixPQUFqQjtBQUpvQjtBQUtwQjs7OztzQ0FFbUI7QUFDbkIsUUFBS3BFLEdBQUwsR0FBV1osT0FBUSxLQUFLdUgsRUFBYixDQUFYOztBQUVBLE9BQU1xRSxTQUFTLEtBQUtoTCxHQUFMLENBQVNzSCxPQUFULENBQWtCLG9CQUFsQixDQUFmO0FBQ0EsT0FBTTJELFdBQVdELE9BQU9wTixJQUFQLENBQWEsSUFBYixDQUFqQjtBQUNBLE9BQU1zTixZQUFZLEtBQUs1VCxLQUFMLENBQVc0VCxTQUFYLEdBQXVCLENBQXZCLEdBQTJCLENBQUMsQ0FBOUM7O0FBRUEsT0FBTXBSLFVBQVVxUixPQUFPQyxNQUFQLENBQ2Y7QUFDQ0Msb0JBQWtCTCxPQUFPdlAsTUFBVCxHQUNiMkQsT0FBUSxNQUFNNkwsUUFBZCxDQURhLEdBRWI3TCxPQUFRLHFCQUFSLENBSEo7QUFJQ2tNLDZCQUF5QkosU0FKMUI7QUFLQ2hMLHNCQUFrQixLQUFLRixHQUFMLENBQVN1TCxRQUFULENBQW1CLGVBQW5CLElBQ2Ysd0JBRGUsR0FFZixFQVBKO0FBUUNDLFdBQU87QUFSUixJQURlLEVBV2YsS0FBS2xVLEtBQUwsQ0FBV3dDLE9BWEksQ0FBaEI7O0FBY0EsT0FBSyxPQUFPLEtBQUtrRyxHQUFMLENBQVNhLFVBQWhCLEtBQStCLFVBQXBDLEVBQWlEO0FBQ2hELFNBQUtiLEdBQUwsQ0FBU2EsVUFBVCxDQUFxQi9HLE9BQXJCO0FBQ0EsSUFGRCxNQUVPLElBQUssT0FBTyxLQUFLa0csR0FBTCxDQUFTeUwsVUFBaEIsS0FBK0IsVUFBcEMsRUFBaUQ7QUFDdkQsU0FBS3pMLEdBQUwsQ0FBU3lMLFVBQVQsQ0FBcUIzUixPQUFyQjtBQUNBLElBRk0sTUFFQTtBQUNOLFVBQU00UixNQUFPLDJCQUFQLENBQU47QUFDQTs7QUFFRCxRQUFLdkgsV0FBTCxHQUFtQixLQUFLQSxXQUFMLENBQWlCQyxJQUFqQixDQUF1QixJQUF2QixDQUFuQjtBQUNBLFFBQUtwRSxHQUFMLENBQVNHLEVBQVQsQ0FBYSxRQUFiLEVBQXVCLEtBQUtnRSxXQUE1Qjs7QUFFQSxPQUFLLEtBQUs3TSxLQUFMLENBQVdxVSxhQUFoQixFQUFnQztBQUMvQixTQUFLM0wsR0FBTCxDQUFTWSxPQUFULENBQWtCLFFBQWxCO0FBQ0E7QUFDRDs7OzhCQUVZUixDLEVBQUk7QUFDaEIsT0FBTXpILFFBQVF5RyxPQUFRZ0IsRUFBRTRELE1BQVYsRUFBbUJ4RixHQUFuQixFQUFkOztBQUVBO0FBQ0EsT0FBSyxPQUFPLEtBQUtsSCxLQUFMLENBQVcrTSxjQUFsQixLQUFxQyxVQUExQyxFQUF1RDtBQUN0RDtBQUNBLFNBQUsvTSxLQUFMLENBQVcrTSxjQUFYLENBQTJCLEtBQUsvTSxLQUFMLENBQVdnTixRQUF0QyxFQUFnRDNMLEtBQWhEO0FBQ0EsSUFIRCxNQUdPO0FBQ047QUFDQSxTQUFLckIsS0FBTCxDQUFXaU4sT0FBWCxDQUFtQkMsZUFBbkIsQ0FBbUNDLGFBQW5DLENBQWtELEtBQUtuTixLQUFMLENBQVdnTixRQUE3RCxFQUF1RTNMLEtBQXZFO0FBQ0E7O0FBRUQsUUFBS29TLFNBQUwsQ0FBZ0JwUyxLQUFoQjtBQUNBOzs7OEJBRVc7QUFDWCxVQUFPLEtBQVA7QUFDQTs7O3lDQUVzQjtBQUN0QixRQUFLcUgsR0FBTCxDQUFTbUksR0FBVCxDQUFjLFFBQWQsRUFBd0IsS0FBS2hFLFdBQTdCO0FBQ0EsUUFBS25FLEdBQUwsQ0FBU29JLE1BQVQsR0FBa0JDLFVBQWxCO0FBQ0E7OzsyQkFFUTtBQUFBOztBQUNSLE9BQU0xUCxRQUFRSixFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdHLFFBQVgsQ0FBcUIsS0FBS0gsS0FBTCxDQUFXZ04sUUFBaEMsQ0FBZixJQUNYLEtBQUtoTixLQUFMLENBQVdzTixZQURBLEdBRVgsS0FBS3ROLEtBQUwsQ0FBV0csUUFBWCxDQUFxQixLQUFLSCxLQUFMLENBQVdnTixRQUFoQyxDQUZIOztBQUlBLE9BQU0wRSxXQUFXLENBQUV6USxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVd5TixVQUExQixDQUFGLEdBQ2Qsb0JBQW9CLEtBQUt6TixLQUFMLENBQVd5TixVQURqQixHQUVkLGdCQUZIOztBQUlBLE9BQU02RyxXQUFXLENBQUVyVCxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVd1VSxTQUExQixDQUFGLEdBQ2QsS0FBS3ZVLEtBQUwsQ0FBV3VVLFNBREcsR0FFZCxLQUFLdlUsS0FBTCxDQUFXZ04sUUFGZDs7QUFJQSxPQUFJYSxtQkFBSjs7QUFFQSxPQUFLLEtBQUs3TixLQUFMLENBQVcwQixLQUFoQixFQUF3QjtBQUN2Qm1NLGlCQUNDO0FBQUE7QUFBQTtBQUNDLHFDQUErQixLQUFLN04sS0FBTCxDQUFXZ04sUUFEM0M7QUFFQyxpQkFBVTtBQUZYO0FBSUcsVUFBS2hOLEtBQUwsQ0FBVzBCLEtBSmQ7QUFBQTtBQUk2QixVQUFLMUIsS0FBTCxDQUFXNEYsUUFBWCxJQUMzQjtBQUFBO0FBQUEsUUFBTSxXQUFVLFdBQWhCO0FBQUE7QUFBQSxNQUxGO0FBT0csVUFBSzVGLEtBQUwsQ0FBVytOLElBQVgsSUFDRDtBQUFBO0FBQUEsUUFBTSxXQUFVLGdCQUFoQjtBQUFtQyxXQUFLL04sS0FBTCxDQUFXK047QUFBOUM7QUFSRixLQUREO0FBYUE7O0FBRUQsT0FBTXlHLFdBQVcsS0FBS3hVLEtBQUwsQ0FBV3dVLFFBQTVCOztBQS9CUSxnQkFnQzBHLEtBQUt4VSxLQWhDL0c7QUFBQSxPQWdDQXlVLFFBaENBLFVBZ0NBQSxRQWhDQTtBQUFBLE9BZ0NVMUgsY0FoQ1YsVUFnQ1VBLGNBaENWO0FBQUEsT0FnQzBCMkgsU0FoQzFCLFVBZ0MwQkEsU0FoQzFCO0FBQUEsT0FnQ3FDakgsVUFoQ3JDLFVBZ0NxQ0EsVUFoQ3JDO0FBQUEsT0FnQ2lEa0gsYUFoQ2pELFVBZ0NpREEsYUFoQ2pEO0FBQUEsT0FnQ2dFelUsVUFoQ2hFLFVBZ0NnRUEsVUFoQ2hFO0FBQUEsT0FnQzRFMFUsU0FoQzVFLFVBZ0M0RUEsU0FoQzVFO0FBQUEsT0FnQzBGQyxXQWhDMUY7O0FBa0NSLE9BQU1DLFlBQ0w7QUFBQTtBQUFBO0FBQ0MsK0JBQTBCUixRQUQzQjtBQUVDLGdCQUFVLFlBRlg7QUFHQyxVQUFNO0FBQUEsYUFBUSxPQUFLakYsRUFBTCxHQUFVQSxFQUFsQjtBQUFBLE1BSFA7QUFJQyxtQkFBZWhPLEtBSmhCO0FBS0MsZUFBV21UO0FBTFosT0FNTUssV0FOTjtBQVFFLFNBQUs3VSxLQUFMLENBQVc4TztBQVJiLElBREQ7O0FBYUEsT0FBSWlHLGFBQ0g7QUFBQTtBQUFBO0FBQ0MsK0JBQTBCVCxRQUQzQjtBQUVDLGdCQUFVLFlBRlg7QUFHQyxVQUFNO0FBQUEsYUFBUSxPQUFLakYsRUFBTCxHQUFVQSxFQUFsQjtBQUFBLE1BSFA7QUFJQyxtQkFBZWhPLEtBSmhCO0FBS0MsZUFBV21UO0FBTFo7QUFPRSxTQUFLeFUsS0FBTCxDQUFXOE87QUFQYixJQUREOztBQVlBLE9BQUssU0FBUyxLQUFLOU8sS0FBTCxDQUFXZ1YsU0FBcEIsSUFBaUMsYUFBYSxLQUFLaFYsS0FBTCxDQUFXZ1YsU0FBOUQsRUFBMEU7QUFDekVELGlCQUNDO0FBQUE7QUFBQSxPQUFLLFdBQVUsNkJBQWY7QUFDR0Q7QUFESCxLQUREO0FBS0EsSUFORCxNQU1PLElBQUssU0FBUyxLQUFLOVUsS0FBTCxDQUFXZ1YsU0FBcEIsSUFBaUMsWUFBWSxLQUFLaFYsS0FBTCxDQUFXZ1YsU0FBN0QsRUFBeUU7QUFDL0VELGlCQUNDO0FBQUE7QUFBQSxPQUFLLFdBQVUsNkJBQWY7QUFDR0Q7QUFESCxLQUREO0FBS0EsSUFOTSxNQU1BLElBQUssQ0FBRTdULEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV2dWLFNBQTFCLENBQUYsSUFBMkMsT0FBTyxLQUFLaFYsS0FBTCxDQUFXZ1YsU0FBbEUsRUFBOEU7QUFDcEZELGlCQUNDO0FBQUE7QUFBQSxPQUFLLE9BQVEsRUFBRWIsT0FBTyxNQUFULEVBQWlCZSxVQUFVLEtBQUtqVixLQUFMLENBQVdnVixTQUFYLEdBQXVCLElBQWxELEVBQWI7QUFDR0Y7QUFESCxLQUREO0FBS0E7O0FBRUQsT0FBSyxLQUFLOVUsS0FBTCxDQUFXMFUsU0FBaEIsRUFBNEI7QUFDM0IsV0FBT0ksU0FBUDtBQUNBOztBQUVELFVBQ0M7QUFBQTtBQUFBLE1BQUssV0FBWXBELFFBQWpCO0FBRUc3RCxjQUZIO0FBSUdrSCxjQUpIO0FBTUcsU0FBSy9VLEtBQUwsQ0FBVzBPLFdBQVgsSUFDRDtBQUFBO0FBQUE7QUFDQyxpQkFBVSxpQkFEWDtBQUVDLGFBQVEsRUFBRXdHLFdBQVcsTUFBYjtBQUZUO0FBSUcsVUFBS2xWLEtBQUwsQ0FBVzBPO0FBSmQ7QUFQRixJQUREO0FBa0JBOzs7O0VBMUtzQ0UsZ0I7O2tCQUFuQjRFLFU7Ozs7Ozs7Ozs7Ozs7OztBQ0ZyQjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQSw0REFBNEQsWUFBWTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksUUFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7OztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQy9EQTs7Ozs7Ozs7Ozs7O0lBRXFCMkIsUzs7O0FBQ3BCLG9CQUFhblYsS0FBYixFQUFxQjtBQUFBOztBQUFBLG9IQUNiQSxLQURhOztBQUdwQixRQUFLNk0sV0FBTCxHQUFtQixNQUFLQSxXQUFMLENBQWlCQyxJQUFqQixPQUFuQjtBQUhvQjtBQUlwQjs7OztzQ0FFbUI7QUFDbkIsUUFBS3BFLEdBQUwsR0FBV1osT0FBUSxLQUFLdUgsRUFBYixDQUFYO0FBQ0E7O0FBRUEsUUFBS3hDLFdBQUwsR0FBbUIsS0FBS0EsV0FBTCxDQUFpQkMsSUFBakIsQ0FBdUIsSUFBdkIsQ0FBbkI7QUFDQSxRQUFLcEUsR0FBTCxDQUFTRyxFQUFULENBQWEsUUFBYixFQUF1QixLQUFLZ0UsV0FBNUI7QUFDQTs7OzhCQUVZL0QsQyxFQUFJO0FBQ2hCLE9BQU16SCxRQUFReUgsRUFBRTRELE1BQUYsQ0FBU3JMLEtBQXZCOztBQUVBO0FBQ0EsT0FBSyxPQUFPLEtBQUtyQixLQUFMLENBQVcrTSxjQUFsQixLQUFxQyxVQUExQyxFQUF1RDtBQUN0RDtBQUNBLFNBQUsvTSxLQUFMLENBQVcrTSxjQUFYLENBQTJCLEtBQUsvTSxLQUFMLENBQVdnTixRQUF0QyxFQUFnRDNMLEtBQWhEO0FBQ0EsSUFIRCxNQUdPO0FBQ047QUFDQSxTQUFLckIsS0FBTCxDQUFXaU4sT0FBWCxDQUFtQkMsZUFBbkIsQ0FBbUNDLGFBQW5DLENBQWtELEtBQUtuTixLQUFMLENBQVdnTixRQUE3RCxFQUF1RTNMLEtBQXZFO0FBQ0E7QUFDRDs7O3lDQUVzQjtBQUN0QixRQUFLcUgsR0FBTCxDQUFTbUksR0FBVCxDQUFjLFFBQWQsRUFBd0IsS0FBS2hFLFdBQTdCO0FBQ0EsUUFBS25FLEdBQUwsQ0FBU29JLE1BQVQsR0FBa0JDLFVBQWxCO0FBQ0E7OzsyQkFFUTtBQUFBOztBQUNSLE9BQUkxUCxRQUFRSixFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdHLFFBQVgsQ0FBcUIsS0FBS0gsS0FBTCxDQUFXZ04sUUFBaEMsQ0FBZixJQUNULEtBQUtoTixLQUFMLENBQVdzTixZQURGLEdBRVQsS0FBS3ROLEtBQUwsQ0FBV0csUUFBWCxDQUFxQixLQUFLSCxLQUFMLENBQVdnTixRQUFoQyxDQUZIOztBQUlBLE9BQU1TLGFBQWEsQ0FBRXhNLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV3lOLFVBQTFCLENBQUYsR0FDaEIsb0JBQW9CLEtBQUt6TixLQUFMLENBQVd5TixVQURmLEdBRWhCLGdCQUZIOztBQUlBLE9BQU0ySCxjQUFjLENBQUVuVSxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdxVixZQUExQixDQUFGLEdBQ2pCLEtBQUtyVixLQUFMLENBQVdxVixZQURNLEdBRWpCLEVBRkg7O0FBSUEsT0FBTWYsV0FBVyxDQUFFclQsRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXdVUsU0FBMUIsQ0FBRixHQUNkLEtBQUt2VSxLQUFMLENBQVd1VSxTQURHLEdBRWQsS0FBS3ZVLEtBQUwsQ0FBV2dOLFFBRmQ7O0FBSUEsT0FBSXNJLGNBQWMsRUFBbEI7O0FBRUEsT0FBSyxLQUFLdFYsS0FBTCxDQUFXMEIsS0FBaEIsRUFBd0I7QUFDdkI0VCxrQkFDQztBQUFBO0FBQUE7QUFDQyxxQ0FBK0IsS0FBS3RWLEtBQUwsQ0FBV2dOLFFBRDNDO0FBRUMsZ0NBQTBCLEtBQUtoTixLQUFMLENBQVdnTixRQUFyQyxXQUZEO0FBR0MsaUJBQVU7QUFIWDtBQUtHLFVBQUtoTixLQUFMLENBQVcwQixLQUxkO0FBQUE7QUFLNkIsVUFBSzFCLEtBQUwsQ0FBVzRGLFFBQVgsSUFDM0I7QUFBQTtBQUFBLFFBQU0sV0FBVSxXQUFoQjtBQUFBO0FBQUEsTUFORjtBQVFHLFVBQUs1RixLQUFMLENBQVcrTixJQUFYLElBQ0Q7QUFBQTtBQUFBLFFBQU0sV0FBVSxnQkFBaEI7QUFBa0MsV0FBSy9OLEtBQUwsQ0FBVytOO0FBQTdDO0FBVEYsS0FERDtBQWNBOztBQUVEO0FBQ0EsT0FDQyxDQUFFOU0sRUFBRTJDLFdBQUYsQ0FBZXZDLEtBQWYsQ0FBRixLQUNFLDZCQUE2QixLQUFLckIsS0FBTCxDQUFXZ04sUUFBeEMsSUFBb0Qsa0NBQWtDLEtBQUtoTixLQUFMLENBQVdnTixRQURuRyxDQURELEVBR0U7QUFDRDNMLFlBQVFBLE1BQU00SyxXQUFOLEVBQVI7QUFDQTs7QUFFRCxPQUFNc0osY0FDTDtBQUFBO0FBQUE7QUFDQyxtQkFBZWxVLEtBRGhCO0FBRUMsK0JBQTBCaVQsUUFGM0I7QUFHQyxnQkFBWWMsV0FIYjtBQUlDLDhDQUF1Q2QsUUFBdkMsV0FKRDtBQUtDLFVBQU07QUFBQSxhQUFRLE9BQUtqRixFQUFMLEdBQVVBLEVBQWxCO0FBQUEsTUFMUDtBQU1DLFlBQVEsRUFBRTRGLFVBQVUsTUFBWjtBQU5UO0FBUUcsU0FBS2pWLEtBQUwsQ0FBVzhPO0FBUmQsSUFERDs7QUFhQSxPQUFJaUcsYUFBYVEsV0FBakI7O0FBRUEsT0FBSyxTQUFTLEtBQUt2VixLQUFMLENBQVdnVixTQUFwQixJQUFpQyxhQUFhLEtBQUtoVixLQUFMLENBQVdnVixTQUE5RCxFQUEwRTtBQUN6RUQsaUJBQ0M7QUFBQTtBQUFBLE9BQUssV0FBVSw2QkFBZjtBQUNHUTtBQURILEtBREQ7QUFLQSxJQU5ELE1BTU8sSUFBSyxTQUFTLEtBQUt2VixLQUFMLENBQVdnVixTQUFwQixJQUFpQyxZQUFZLEtBQUtoVixLQUFMLENBQVdnVixTQUE3RCxFQUF5RTtBQUMvRUQsaUJBQ0M7QUFBQTtBQUFBLE9BQUssV0FBVSw2QkFBZjtBQUNHUTtBQURILEtBREQ7QUFLQSxJQU5NLE1BTUEsSUFBSyxPQUFPLEtBQUt2VixLQUFMLENBQVdnVixTQUF2QixFQUFtQztBQUN6Q0QsaUJBQ0M7QUFBQTtBQUFBLE9BQUssT0FBUSxFQUFFYixPQUFPLE1BQVQsRUFBaUJlLFVBQVUsS0FBS2pWLEtBQUwsQ0FBV2dWLFNBQVgsR0FBdUIsSUFBbEQsRUFBYjtBQUNHTztBQURILEtBREQ7QUFLQTs7QUFFRCxPQUFJQyxXQUFXVCxVQUFmOztBQUVBLE9BQUssQ0FBRSxLQUFLL1UsS0FBTCxDQUFXMk8sTUFBbEIsRUFBMkI7QUFDMUI2RyxlQUNDO0FBQUE7QUFBQSxPQUFLLFdBQVkvSCxVQUFqQjtBQUVHNkgsZ0JBRkg7QUFJR1AsZUFKSDtBQU1HLFVBQUsvVSxLQUFMLENBQVcwTyxXQUFYLElBQ0Q7QUFBQTtBQUFBO0FBQ0Msa0JBQVUsaUJBRFg7QUFFQyxjQUFRLEVBQUV3RyxXQUFXLE1BQWI7QUFGVDtBQUlHLFdBQUtsVixLQUFMLENBQVcwTztBQUpkO0FBUEYsS0FERDtBQWtCQTs7QUFFRCxVQUFPOEcsUUFBUDtBQUNBOzs7O0VBeElxQzVHLGdCOztrQkFBbEJ1RyxTOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZyQjs7Ozs7Ozs7Ozs7O0lBRXFCTSxLOzs7QUFDcEIsZ0JBQWF6VixLQUFiLEVBQXFCO0FBQUE7O0FBQUEsNEdBQ2JBLEtBRGE7O0FBR3BCLFFBQUswVixjQUFMLEdBQXNCM0csZ0JBQU00RyxTQUFOLEVBQXRCO0FBSG9CO0FBSXBCOzs7O3NDQUVtQjtBQUNuQixPQUFNQyxPQUFPLElBQWI7QUFDQSxRQUFLQyxlQUFMLEdBQXVCL04sT0FBUSxLQUFLNE4sY0FBYixDQUF2Qjs7QUFFQSxPQUFLLEtBQUtHLGVBQUwsQ0FBcUI1QixRQUFyQixDQUErQixXQUEvQixDQUFMLEVBQW9EO0FBQ25ELFNBQUs0QixlQUFMLENBQXFCaE4sRUFBckIsQ0FBeUIsT0FBekIsRUFBa0MsaUNBQWxDLEVBQXFFLGFBQUs7QUFDekUrTSxVQUFLNVYsS0FBTCxDQUFXOFYsUUFBWCxDQUFxQmhPLE9BQVFnQixFQUFFaU4sYUFBVixFQUEwQjlNLElBQTFCLENBQWdDLEtBQWhDLENBQXJCO0FBQ0EsS0FGRDtBQUdBO0FBQ0Q7Ozt5Q0FFc0I7QUFDdEIsUUFBSzRNLGVBQUwsQ0FBcUJoRixHQUFyQixDQUEwQixPQUExQixFQUFtQyxLQUFLaEUsV0FBeEMsRUFBc0RrRSxVQUF0RDtBQUNBOzs7OEJBRVkxUCxLLEVBQVE7QUFDcEI7QUFDQSxPQUFLLE9BQU8sS0FBS3JCLEtBQUwsQ0FBVytNLGNBQWxCLEtBQXFDLFVBQTFDLEVBQXVEO0FBQ3REO0FBQ0EsU0FBSy9NLEtBQUwsQ0FBVytNLGNBQVgsQ0FDQyxLQUFLL00sS0FBTCxDQUFXZ04sUUFEWixFQUVDM0wsS0FGRDs7QUFLQTtBQUNBLFFBQUssS0FBS3JCLEtBQUwsQ0FBV2dXLFlBQVgsS0FBNEIsTUFBakMsRUFBMEM7QUFDekMsU0FBSzNVLFVBQVUsUUFBZixFQUEwQjtBQUN6QixVQUFNbUIsVUFBVSxFQUFoQjtBQUNBdkIsUUFBRStHLElBQUYsQ0FBUSxLQUFLaEksS0FBTCxDQUFXeVMsS0FBWCxDQUFpQmpRLE9BQXpCLEVBQWtDLGtCQUFVO0FBQzNDeVQsY0FBTzlFLE9BQVAsR0FBaUIsS0FBakI7QUFDQTNPLGVBQVExQixJQUFSLENBQWNtVixNQUFkO0FBQ0EsT0FIRDs7QUFLQSxXQUFLalcsS0FBTCxDQUFXK00sY0FBWCxDQUNDLFNBREQsRUFFQ3ZLLE9BRkQ7QUFJQTtBQUNEO0FBQ0QsSUF0QkQsTUFzQk87QUFDTjtBQUNBLFNBQUt4QyxLQUFMLENBQVdpTixPQUFYLENBQW1CQyxlQUFuQixDQUFtQ0MsYUFBbkMsQ0FBa0QsS0FBS25OLEtBQUwsQ0FBV2dOLFFBQTdELEVBQXVFM0wsS0FBdkU7QUFDQTtBQUNEOzs7MkJBRVE7QUFBQTs7QUFDUixPQUFNQSxRQUFRSixFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdHLFFBQVgsQ0FBcUIsS0FBS0gsS0FBTCxDQUFXZ04sUUFBaEMsQ0FBZixJQUNYLEtBQUtoTixLQUFMLENBQVdzTixZQURBLEdBRVgsS0FBS3ROLEtBQUwsQ0FBV0csUUFBWCxDQUFxQixLQUFLSCxLQUFMLENBQVdnTixRQUFoQyxDQUZIOztBQUlBLE9BQU1vRSxZQUFZckMsZ0JBQU1DLFFBQU4sQ0FBZW5QLEdBQWYsQ0FBb0IsS0FBS0csS0FBTCxDQUFXOE8sUUFBL0IsRUFBeUMsZUFBTztBQUNqRSxXQUNDO0FBQUE7QUFBQTtBQUNDLFVBQUssZ0JBQWdCdUMsSUFBSXJSLEtBQUosQ0FBVXFCLEtBRGhDO0FBRUMsWUFBSyxLQUZOO0FBR0MsaUJBQVkscUNBQ1hnUSxJQUFJclIsS0FBSixDQUFVcUIsS0FBVixLQUFvQkEsS0FBcEIsR0FBNEIsUUFBNUIsR0FBdUMsRUFENUIsQ0FIYjtBQU1DLHVCQUFnQmdRLElBQUlyUixLQUFKLENBQVVxQixLQUFWLEtBQW9CQSxLQUFwQixHQUE0QixNQUE1QixHQUFxQztBQU50RCxRQU9NZ1EsSUFBSXJSLEtBQUosQ0FBVXFCLEtBQVYsS0FBb0JBLEtBQXBCLElBQ0osRUFBRTZVLFVBQVUsSUFBWixFQVJGO0FBVUMsa0JBQVc3RSxJQUFJclIsS0FBSixDQUFVcUIsS0FWdEI7QUFXQyxlQUFVLE9BQUt3TCxXQUFMLENBQWlCQyxJQUFqQixDQUF1QixNQUF2QixFQUE2QnVFLElBQUlyUixLQUFKLENBQVVxQixLQUF2QztBQVhYO0FBYUdnUSxTQUFJclIsS0FBSixDQUFVOE87QUFiYixLQUREO0FBaUJBLElBbEJpQixDQUFsQjs7QUFvQkEsT0FBSTdJLGFBQWEsRUFBakI7O0FBRUEsT0FBSyxLQUFLakcsS0FBTCxDQUFXMEIsS0FBWCxJQUFvQixPQUFPLEtBQUsxQixLQUFMLENBQVcwQixLQUEzQyxFQUFtRDtBQUNsRHVFLGlCQUNDO0FBQUE7QUFBQSxPQUFPLCtCQUErQixLQUFLakcsS0FBTCxDQUFXZ04sUUFBakQ7QUFDQyxpQkFBVSxXQURYO0FBRUcsVUFBS2hOLEtBQUwsQ0FBVzBCLEtBRmQ7QUFHRyxVQUFLMUIsS0FBTCxDQUFXK04sSUFBWCxJQUNEO0FBQUE7QUFBQSxRQUFNLFdBQVUsZ0JBQWhCO0FBQW1DLFdBQUsvTixLQUFMLENBQVcrTjtBQUE5QztBQUpGLEtBREQ7QUFTQTs7QUFFRCxPQUFJb0ksbUJBQW1CLEVBQXZCOztBQUVBLE9BQUssS0FBS25XLEtBQUwsQ0FBVzBPLFdBQVgsSUFBMEIsT0FBTyxLQUFLMU8sS0FBTCxDQUFXME8sV0FBakQsRUFBK0Q7QUFDOUR5SCx1QkFDQztBQUFBO0FBQUEsT0FBTSxXQUFVLGlCQUFoQjtBQUNHLFVBQUtuVyxLQUFMLENBQVcwTztBQURkLEtBREQ7QUFLQTs7QUFFRCxPQUFJcUQsZ0JBQWdCLEVBQXBCOztBQUVBLE9BQUssQ0FBRSxLQUFLL1IsS0FBTCxDQUFXMEIsS0FBYixJQUFzQixLQUFLMUIsS0FBTCxDQUFXK1IsYUFBdEMsRUFBc0Q7QUFDckRBLG9CQUNDO0FBQUE7QUFBQSxPQUFPLFdBQVUsb0JBQWpCO0FBQ0csVUFBSy9SLEtBQUwsQ0FBVytSO0FBRGQsS0FERDtBQUtBOztBQUVELE9BQUlxRSxzQkFBc0IsRUFBMUI7O0FBRUEsT0FBSyxDQUFFLEtBQUtwVyxLQUFMLENBQVcwQixLQUFiLElBQXNCLEtBQUsxQixLQUFMLENBQVdxVyxZQUF0QyxFQUFxRDtBQUNwREQsMEJBQ0M7QUFBQTtBQUFBLE9BQU0sV0FBVSxpQkFBaEI7QUFDQyxhQUFRLEVBQUVuRSxjQUFjLE1BQWhCLEVBRFQ7QUFFRyxVQUFLalMsS0FBTCxDQUFXcVc7QUFGZCxLQUREO0FBTUE7O0FBRUQsT0FBTUMsZUFDTDtBQUFBO0FBQUE7QUFDQyxtQ0FBOEIsS0FBS3RXLEtBQUwsQ0FBV2dOLFFBRDFDO0FBRUMsWUFBUSxLQUFLaE4sS0FBTCxDQUFXME8sV0FBWCxJQUEwQixFQUFFdUQsY0FBYyxLQUFoQixFQUZuQztBQUdDLFVBQU07QUFBQSxhQUFvQixPQUFLeUQsY0FBTCxHQUFzQkEsY0FBMUM7QUFBQTtBQUhQO0FBS0M7QUFBQTtBQUFBLE9BQUssV0FBVSxlQUFmLEVBQStCLE1BQUssU0FBcEM7QUFBZ0R0RTtBQUFoRDtBQUxELElBREQ7O0FBVUEsT0FBSW1GLGNBQ0g7QUFBQyxtQkFBRCxDQUFPLFFBQVA7QUFBQTtBQUNHdFEsY0FESDtBQUVHcVE7QUFGSCxJQUREOztBQU9BLE9BQUssQ0FBRSxLQUFLdFcsS0FBTCxDQUFXMFUsU0FBbEIsRUFBOEI7QUFDN0I2QixrQkFDQztBQUFBO0FBQUEsT0FBSyxXQUFVLGdCQUFmO0FBQ0d0USxlQURIO0FBRUc4TCxrQkFGSDtBQUdHcUUsd0JBSEg7QUFJR0UsaUJBSkg7QUFLR0g7QUFMSCxLQUREO0FBU0E7O0FBRUQsVUFBT0ksV0FBUDtBQUNBOzs7O0VBeEppQzNILGdCOztrQkFBZDZHLEs7Ozs7Ozs7Ozs7O0FDRnJCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLDZCQUE2QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRVE7Ozs7Ozs7QUMzSlIsMEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNRO0FBQ1I7QUFDUTtBQUNSO0FBQ1E7O0FBRW9DOzs7Ozs7Ozs7Ozs7Ozs7O0FDUDVDOzs7O0FBQ0E7Ozs7Ozs7Ozs7SUFFcUJlLE07OztBQUNwQixpQkFBYXhXLEtBQWIsRUFBcUI7QUFBQTs7QUFBQSw4R0FDYkEsS0FEYTs7QUFHcEIsUUFBSzZNLFdBQUwsR0FBbUIsTUFBS0EsV0FBTCxDQUFpQkMsSUFBakIsT0FBbkI7QUFIb0I7QUFJcEI7Ozs7OEJBRVl6TCxLLEVBQVE7QUFDcEI7QUFDQSxPQUFLLE9BQU8sS0FBS3JCLEtBQUwsQ0FBVytNLGNBQWxCLEtBQXFDLFVBQTFDLEVBQXVEO0FBQ3REO0FBQ0EsU0FBSy9NLEtBQUwsQ0FBVytNLGNBQVgsQ0FBMkIsS0FBSy9NLEtBQUwsQ0FBV2dOLFFBQXRDLEVBQWdEM0wsS0FBaEQ7QUFDQSxJQUhELE1BR087QUFDTjtBQUNBLFNBQUtyQixLQUFMLENBQVdpTixPQUFYLENBQW1CQyxlQUFuQixDQUFtQ0MsYUFBbkMsQ0FBa0QsS0FBS25OLEtBQUwsQ0FBV2dOLFFBQTdELEVBQXVFM0wsS0FBdkU7QUFDQTtBQUNEOzs7MkJBRVE7QUFBQTs7QUFDUixPQUFNQSxRQUFRSixFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdHLFFBQVgsQ0FBcUIsS0FBS0gsS0FBTCxDQUFXZ04sUUFBaEMsQ0FBZixJQUNYLEVBRFcsR0FFWCxLQUFLaE4sS0FBTCxDQUFXRyxRQUFYLENBQXFCLEtBQUtILEtBQUwsQ0FBV2dOLFFBQWhDLENBRkg7O0FBS0EsT0FBTW1DLGNBQWMsQ0FBRWxPLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV21QLFdBQTFCLENBQUYsR0FDakIsS0FBS25QLEtBQUwsQ0FBV21QLFdBRE0sR0FFakIsa0JBRkg7O0FBS0EsT0FBTTFHLFdBQVcsQ0FBRXhILEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV3lJLFFBQTFCLENBQUYsSUFBMEMsS0FBS3pJLEtBQUwsQ0FBV3lJLFFBQXRFO0FBQ0EsT0FBTWdPLFVBQVVwVixTQUFTLENBQUVvSCxRQUEzQjs7QUFFQSxPQUFNaU8sZ0JBQ0w7QUFBQTtBQUFBLE1BQU8sK0JBQStCLEtBQUsxVyxLQUFMLENBQVdnTixRQUFqRDtBQUNDLGdCQUFVO0FBRFg7QUFHQyw2Q0FBTyxNQUFLLFVBQVo7QUFDQyxZQUFNLE1BRFA7QUFFQywrQkFBMEIsS0FBS2hOLEtBQUwsQ0FBV2dOLFFBRnRDO0FBR0MsZ0JBQVltQyxXQUhiO0FBSUMsZUFBVzFHLFdBQVcsVUFBWCxHQUF3QixFQUpwQztBQUtDLGNBQVVnTyxVQUFVLFNBQVYsR0FBc0IsRUFMakM7QUFNQyxlQUFXLHFCQUFLO0FBQ2YsYUFBSzVKLFdBQUwsQ0FBa0IvRCxFQUFFNEQsTUFBRixDQUFTK0osT0FBM0I7QUFDQTtBQVJGLE1BSEQ7QUFhQyw0Q0FBTSxXQUFVLG1CQUFoQixHQWJEO0FBY0csU0FBS3pXLEtBQUwsQ0FBVzBCLEtBQVgsSUFDRDtBQUFDLG9CQUFELENBQU8sUUFBUDtBQUFBO0FBQ0M7QUFBQTtBQUFBLFFBQU0sV0FBVSx3QkFBaEI7QUFDRyw0QkFBVyxRQUFYLENBREg7QUFBQTtBQUM2QixXQUFLMUIsS0FBTCxDQUFXMEI7QUFEeEMsTUFERDtBQUlDO0FBQUE7QUFBQSxRQUFNLFdBQVUsa0JBQWhCO0FBQ0csV0FBSzFCLEtBQUwsQ0FBVzBCO0FBRGQ7QUFKRCxLQWZGO0FBd0JHLFNBQUsxQixLQUFMLENBQVcwTyxXQUFYLElBQ0Q7QUFBQTtBQUFBLE9BQU0sV0FBVSx3Q0FBaEI7QUFDRyxVQUFLMU8sS0FBTCxDQUFXME87QUFEZDtBQXpCRixJQUREOztBQWlDQSxPQUFJaUksWUFBWSxFQUFoQjs7QUFFQSxPQUFLLEtBQUszVyxLQUFMLENBQVc4TyxRQUFYLElBQXVCLEtBQUs5TyxLQUFMLENBQVdHLFFBQVgsQ0FBcUIsS0FBS0gsS0FBTCxDQUFXZ04sUUFBaEMsQ0FBNUIsRUFBeUU7QUFDeEUySixnQkFDQztBQUFDLG9CQUFELENBQU8sUUFBUDtBQUFBO0FBQ0M7QUFBQTtBQUFBO0FBQ0MsaUJBQVMsR0FEVjtBQUVDLGtCQUFVLHFDQUZYO0FBR0MscUJBQWEsS0FBSzNXLEtBQUwsQ0FBVzBCO0FBSHpCO0FBS0csV0FBSzFCLEtBQUwsQ0FBVzhPO0FBTGQ7QUFERCxLQUREO0FBV0E7O0FBRUQsT0FBSyxLQUFLOU8sS0FBTCxDQUFXNFcsTUFBaEIsRUFBeUI7QUFDeEIsV0FDQztBQUFDLG9CQUFELENBQU8sUUFBUDtBQUFBO0FBQ0dGLGtCQURIO0FBRUdDO0FBRkgsS0FERDtBQU1BOztBQUVELE9BQUssQ0FBRSxLQUFLM1csS0FBTCxDQUFXNFcsTUFBbEIsRUFBMkI7QUFDMUIsV0FDQztBQUFBO0FBQUEsT0FBSyxXQUFVLGdCQUFmO0FBQ0dGLGtCQURIO0FBRUdDO0FBRkgsS0FERDtBQU1BO0FBQ0Q7Ozs7RUFsR2tDL0gsZ0I7O2tCQUFmNEgsTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0hyQjtBQUNRO0FBQ1I7QUFDUTtBQUNSO0FBQ1E7QUFDUjtBQUNRO0FBQ1I7QUFDUTtBQUNSO0FBQ1E7QUFDUjtBQUNRO0FBQ1I7QUFDUTtBQUNSO0FBQ1E7QUFDUjtBQUNRO0FBQ1I7QUFDUTtBQUNSO0FBQ1E7QUFDUjtBQUNRO0FBQ1I7Ozs7Ozs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsRTs7Ozs7Ozs7Ozs7Ozs7OztBQ3pEQTs7Ozs7Ozs7Ozs7O0lBRXFCSyxZOzs7QUFDcEIsdUJBQWE3VyxLQUFiLEVBQXFCO0FBQUE7O0FBQUEscUhBQ2JBLEtBRGE7QUFFcEI7Ozs7K0JBRVk7QUFDWixPQUFLLENBQUU4SCxPQUFRLHVCQUFSLEVBQWtDM0QsTUFBekMsRUFBa0Q7QUFDakQyRCxXQUFRLGVBQVIsRUFBMEJnUCxPQUExQixDQUFtQywwQ0FBbkM7QUFDQTs7QUFFRCxPQUFLLENBQUVoUCxPQUFRLDBCQUFSLEVBQXFDM0QsTUFBNUMsRUFBcUQ7QUFDcEQyRCxXQUFRLHVCQUFSLEVBQWtDdUIsTUFBbEMsQ0FDQyxnR0FERDtBQUdBLElBSkQsTUFJTztBQUNOdkIsV0FBUSwwQkFBUixFQUFxQ2lQLE1BQXJDO0FBQ0EsU0FBS0MsVUFBTDtBQUNBOztBQUVELFFBQUtDLGFBQUwsR0FBcUJuUCxPQUFRLDBCQUFSLENBQXJCO0FBQ0E7Ozt5QkFFTTtBQUNOLFFBQUtrUCxVQUFMOztBQUVBLE9BQU1FLFdBQVcseUJBQWpCO0FBQ0EsT0FBTUMsZ0JBQWdCLFFBQVEsS0FBS25YLEtBQUwsQ0FBV29YLElBQW5CLEdBQTBCLE1BQWhEO0FBQ0EsT0FBTUMsZ0JBQWdCO0FBQ3JCaFgsVUFBTSxLQUFLTCxLQUFMLENBQVdLLElBQVgsSUFBbUIsU0FESjtBQUVyQmlYLGVBQVc7QUFDVkMsY0FBUyxLQUFLdlgsS0FBTCxDQUFXd1gsSUFBWCxJQUFtQjtBQURsQixLQUZVO0FBS3JCQyxhQUFTO0FBQ1JDLFdBQU0sS0FBSzFYLEtBQUwsQ0FBV3lYLE9BQVgsSUFBc0I7QUFEcEI7QUFMWSxJQUF0Qjs7QUFVQTlQLE9BQUlnUSxVQUFKLENBQWdCVCxRQUFoQixFQUEwQkMsYUFBMUIsRUFBeUNFLGFBQXpDO0FBQ0E7OzswQkFFTztBQUNQLE9BQU1ILFdBQVcseUJBQWpCO0FBQ0F2UCxPQUFJaVEsV0FBSixDQUFpQlYsUUFBakI7QUFDQTs7OztFQTNDd0N0SSxnQjs7a0JBQXJCaUksWTs7Ozs7Ozs7Ozs7Ozs7O0FDRnJCOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7OztJQUVxQmdCLFE7OztBQUNwQixtQkFBYTdYLEtBQWIsRUFBcUI7QUFBQTs7QUFBQSxrSEFDYkEsS0FEYTs7QUFHcEIsUUFBSzhYLFVBQUwsR0FBa0IvSSxnQkFBTTRHLFNBQU4sRUFBbEI7QUFDQSxRQUFLOUksV0FBTCxHQUFtQixNQUFLQSxXQUFMLENBQWlCQyxJQUFqQixPQUFuQjtBQUNBLFFBQUtpTCxZQUFMLEdBQW9CLE1BQUtBLFlBQUwsQ0FBa0JqTCxJQUFsQixPQUFwQjtBQUNBLFFBQUtrTCxhQUFMLEdBQXFCLE1BQUtBLGFBQUwsQ0FBbUJsTCxJQUFuQixPQUFyQjtBQUNBLFFBQUsyRixLQUFMLEdBQWE7QUFDWndGLHNCQUFtQjtBQURQLEdBQWI7QUFQb0I7QUFVcEI7Ozs7c0NBRW1CO0FBQUE7O0FBQ25CLFFBQUt2UCxHQUFMLEdBQVdaLE9BQVEsS0FBS3VILEVBQWIsQ0FBWDs7QUFFQTtBQUNBLE9BQUssQ0FBRXBPLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV3NOLFlBQTFCLENBQVAsRUFBa0Q7QUFDakQsU0FBS1QsV0FBTCxDQUFrQixLQUFLN00sS0FBTCxDQUFXc04sWUFBN0I7QUFDQTs7QUFFRDFGLGNBQVksWUFBTTtBQUNqQixXQUFLc1EsVUFBTDtBQUNBLElBRkQsRUFFRyxFQUZIO0FBR0E7OzsrQkFFWTtBQUFBOztBQUNaLE9BQUtqWCxFQUFFMkMsV0FBRixDQUFldVUsR0FBR0MsTUFBbEIsS0FBOEIsT0FBUUMsT0FBUixLQUFzQixXQUF6RCxFQUF1RTtBQUN0RXpRLGVBQVksWUFBTTtBQUNqQixZQUFLc1EsVUFBTDtBQUNBLEtBRkQsRUFFRyxFQUZIOztBQUlBO0FBQ0E7QUFDRCxPQUFJSSxlQUFlLEVBQW5CO0FBQ0EsT0FBSyxDQUFFclgsRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXdVksa0JBQTFCLENBQVAsRUFBeUQ7QUFDeEQ7QUFDQUQsaUJBQWFFLHVCQUFiLEdBQXVDLDRHQUF2QztBQUNBO0FBQ0QsT0FBSSxDQUFFdlgsRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXeVksWUFBMUIsQ0FBTixFQUFrRDtBQUNqREgsaUJBQWFJLFFBQWIsR0FBd0IsS0FBSzFZLEtBQUwsQ0FBV3lZLFlBQW5DO0FBQ0E7QUFDRCxPQUFLeFgsRUFBRUMsT0FBRixDQUFXb1gsWUFBWCxDQUFMLEVBQWlDO0FBQ2hDQSxtQkFBZSxJQUFmO0FBQ0E7O0FBRUQ7QUFDQUgsTUFBR0MsTUFBSCxDQUFVcEIsVUFBVix3QkFBeUMsS0FBS2hYLEtBQUwsQ0FBV2dOLFFBQVgsR0FBc0IsQ0FBQy9MLEVBQUUyQyxXQUFGLENBQWMsS0FBSzVELEtBQUwsQ0FBVzJZLE9BQXpCLENBQXZCLEdBQTJELEtBQUszWSxLQUFMLENBQVcyWSxPQUF0RSxHQUFnRixFQUF6SCxHQUErSDtBQUM5SEMsYUFBU04sWUFEcUg7QUFFOUhPLGVBQVc7QUFGbUgsSUFBL0g7O0FBS0EsUUFBS0MsVUFBTDtBQUNBOzs7K0JBRVk7QUFBQTs7QUFDWixRQUFLVixNQUFMLEdBQWNDLFFBQVFVLEdBQVIsd0JBQWtDLEtBQUsvWSxLQUFMLENBQVdnTixRQUFYLEdBQXNCLENBQUUvTCxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVcyWSxPQUExQixDQUF4QixHQUE4RCxLQUFLM1ksS0FBTCxDQUFXMlksT0FBekUsR0FBbUYsRUFBckgsRUFBZDs7QUFFQSxPQUFLLEtBQUtQLE1BQUwsS0FBZ0IsSUFBckIsRUFBNEI7QUFDM0J4USxlQUFZLFlBQU07QUFDakIsWUFBS2tSLFVBQUw7QUFDQSxLQUZELEVBRUcsRUFGSDs7QUFJQTtBQUNBOztBQUVELFFBQUtWLE1BQUwsQ0FBWXZQLEVBQVosQ0FBZ0IsT0FBaEIsRUFBeUIsS0FBS2tQLFlBQTlCO0FBQ0EsUUFBS0ssTUFBTCxDQUFZdlAsRUFBWixDQUFnQixRQUFoQixFQUEwQixLQUFLa1AsWUFBL0I7QUFDQTs7O3lDQUVzQjtBQUN0QixRQUFLclAsR0FBTCxDQUFTbUksR0FBVCxDQUFjLFFBQWQsRUFBd0IsS0FBS2tILFlBQTdCO0FBQ0FJLE1BQUdDLE1BQUgsQ0FBVXJCLE1BQVYsd0JBQXVDLEtBQUsvVyxLQUFMLENBQVdnTixRQUFYLEdBQXNCLENBQUUvTCxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVcyWSxPQUExQixDQUF4QixHQUE4RCxLQUFLM1ksS0FBTCxDQUFXMlksT0FBekUsR0FBbUYsRUFBMUg7QUFDQSxRQUFLalEsR0FBTCxDQUFTb0ksTUFBVCxHQUFrQkMsVUFBbEI7QUFDQTs7O2lDQUVjO0FBQ2Q7QUFDQSxPQUFNMVAsUUFBUSxLQUFLK1csTUFBTCxDQUFZWSxVQUFaLEVBQWQ7O0FBRUEsUUFBS25NLFdBQUwsQ0FBa0J4TCxLQUFsQjtBQUNBOzs7OEJBRVlBLEssRUFBUTtBQUNwQjtBQUNBLE9BQUssT0FBTyxLQUFLckIsS0FBTCxDQUFXK00sY0FBbEIsS0FBcUMsVUFBMUMsRUFBdUQ7QUFDdEQ7QUFDQSxTQUFLL00sS0FBTCxDQUFXK00sY0FBWCxDQUEyQixLQUFLL00sS0FBTCxDQUFXZ04sUUFBdEMsRUFBZ0RpTSxvQkFBVUMsUUFBVixDQUFvQjdYLEtBQXBCLEVBQTJCLEVBQUU4WCxVQUFVLENBQUUsUUFBRixDQUFaLEVBQTNCLENBQWhEO0FBQ0EsSUFIRCxNQUdPO0FBQ047QUFDQSxTQUFLblosS0FBTCxDQUFXaU4sT0FBWCxDQUFtQkMsZUFBbkIsQ0FBbUNDLGFBQW5DLENBQWtELEtBQUtuTixLQUFMLENBQVdnTixRQUE3RCxFQUF1RWlNLG9CQUFVQyxRQUFWLENBQW9CN1gsS0FBcEIsRUFBMkIsRUFBRThYLFVBQVUsQ0FBRSxRQUFGLENBQVosRUFBM0IsQ0FBdkU7QUFDQTtBQUNEOzs7a0NBRWU7QUFDZixPQUFLLEtBQUsxRyxLQUFMLENBQVd3RixpQkFBaEIsRUFBb0M7QUFDbkMsU0FBS3RGLFFBQUwsQ0FBZSxFQUFFc0YsbUJBQW1CLEtBQXJCLEVBQWY7QUFDQSxJQUZELE1BRU87QUFDTixTQUFLdEYsUUFBTCxDQUFlLEVBQUVzRixtQkFBbUIsSUFBckIsRUFBZjtBQUNBO0FBQ0Q7OztnQ0FFY2hGLE8sRUFBVTtBQUN4QjtBQUNBLE9BQUssS0FBS21GLE1BQUwsQ0FBWWdCLE1BQWpCLEVBQTBCO0FBQ3pCLFFBQU10QixhQUFhaFEsT0FBUSxLQUFLZ1EsVUFBYixDQUFuQjtBQUNBLFFBQU11QixXQUFXdkIsV0FBV3dCLElBQVgsQ0FBZ0IsZ0JBQWhCLENBQWpCO0FBQ0EsUUFBTUMsU0FBU3pCLFdBQVd3QixJQUFYLENBQWdCLGNBQWhCLENBQWY7QUFDQSxRQUFNRSxnQkFBZ0IxQixXQUFXNVEsR0FBWCxFQUF0Qjs7QUFFQTRRLGVBQVc1USxHQUFYLENBQ0NzUyxjQUFjbE4sU0FBZCxDQUF5QixDQUF6QixFQUE0QitNLFFBQTVCLElBQ0EsR0FEQSxHQUNNcEcsT0FETixHQUNnQixHQURoQixHQUVBdUcsY0FBY2xOLFNBQWQsQ0FBeUJpTixNQUF6QixFQUFpQ0MsY0FBY3JWLE1BQS9DLENBSEQ7O0FBTUEyVCxlQUFXeE8sT0FBWCxDQUFvQixRQUFwQjtBQUNBLElBYkQsTUFhTztBQUNOLFNBQUs4TyxNQUFMLENBQVlxQixhQUFaLENBQTJCLE1BQU14RyxPQUFOLEdBQWdCLEdBQTNDO0FBQ0E7O0FBRUQ7QUFDQSxRQUFLK0UsYUFBTDtBQUNBOzs7c0NBRW1CO0FBQ25CLE9BQUloVCxpQkFBaUIsQ0FDcEIsU0FEb0IsRUFFcEIsU0FGb0IsRUFHcEIsUUFIb0IsRUFJcEIsWUFKb0IsRUFLcEIsVUFMb0IsRUFNcEIsT0FOb0IsRUFPcEIsUUFQb0IsRUFRcEIsUUFSb0IsRUFTcEIsUUFUb0IsRUFVcEIsVUFWb0IsQ0FBckI7O0FBYUEsT0FDQyxDQUFFL0QsRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXMFosY0FBMUIsQ0FBRixJQUNBLEtBQUsxWixLQUFMLENBQVcwWixjQURYLElBRUEsQ0FBRXpZLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBVzJaLFlBQTFCLENBRkYsSUFHQSxLQUFLM1osS0FBTCxDQUFXMlosWUFKWixFQUtFO0FBQ0QzVSxxQkFBaUIsQ0FBRSxTQUFGLEVBQWEsU0FBYixFQUF3QixRQUF4QixFQUFrQyxZQUFsQyxFQUFnRCxPQUFoRCxFQUF5RCxRQUF6RCxFQUFtRSxRQUFuRSxFQUE2RSxVQUE3RSxDQUFqQjtBQUNBOztBQUVELFVBQU9BLGNBQVA7QUFDQTs7OzhCQUVXO0FBQ1gsT0FBTUEsaUJBQWlCLEtBQUs0VSxpQkFBTCxFQUF2QjtBQUNBLE9BQU16VSxtQkFBbUIsQ0FBRWxFLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV21GLGdCQUExQixDQUFGLEdBQ3RCLEtBQUtuRixLQUFMLENBQVdtRixnQkFEVyxHQUV0QixLQUZIO0FBR0EsT0FBSTBVLGdCQUFnQixLQUFLN1osS0FBTCxDQUFXTCxRQUEvQjs7QUFFQSxPQUFLLENBQUVzQixFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVc4WixnQkFBMUIsQ0FBRixJQUFtRCxDQUFFN1ksRUFBRTJDLFdBQUYsQ0FBZXZCLGVBQWUwWCxnQkFBOUIsQ0FBMUQsRUFBNkc7QUFDNUdGLG9CQUFnQnhYLGVBQWUwWCxnQkFBL0I7QUFDQTs7QUFFRCxVQUFPLHNCQUFXRixhQUFYLEVBQTBCN1UsY0FBMUIsRUFBMENnVixTQUExQyxFQUFxREEsU0FBckQsRUFBZ0U3VSxnQkFBaEUsQ0FBUDtBQUNBOzs7Z0NBRWE7QUFBQTs7QUFDYixPQUFNNUUsU0FBUyxLQUFLN0MsU0FBTCxFQUFmO0FBQ0EsT0FBTXVjLGdCQUFnQixDQUFFaFosRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXaWEsYUFBMUIsQ0FBRixHQUNuQixLQUFLamEsS0FBTCxDQUFXaWEsYUFEUSxHQUVuQixJQUZIOztBQUlBLE9BQU1DLGlCQUFpQmpaLEVBQUVwQixHQUFGLENBQU9VLE1BQVAsRUFBZSxVQUFFQyxLQUFGLEVBQVNxSyxLQUFULEVBQW9CO0FBQ3pELFFBQUtySyxNQUFNb0YsUUFBWCxFQUFzQjtBQUNyQixTQUNDcVUsaUJBQ0UsQ0FBRUEsYUFBRixJQUFtQmhaLEVBQUVDLE9BQUYsQ0FBV1YsTUFBTWlGLFlBQWpCLENBRnRCLEVBR0U7QUFDRCxhQUNDO0FBQUE7QUFBQSxTQUFJLFdBQVUsMEJBQWQsRUFBeUMsS0FBTW9GLEtBQS9DO0FBQ0M7QUFBQTtBQUFBO0FBQ0Msb0JBQVUsd0JBRFg7QUFFQyxrQkFBVSxPQUFLNE8sYUFBTCxDQUFtQjNNLElBQW5CLENBQXlCLE1BQXpCLEVBQStCdE0sTUFBTUcsVUFBckM7QUFGWDtBQUlHLG9DQUFZSCxNQUFNa0IsS0FBbEI7QUFKSDtBQURELE9BREQ7QUFVQTtBQUNEO0FBQ0QsSUFsQnNCLENBQXZCOztBQW9CQSxPQUFNeVksY0FBYyxDQUFFbFosRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXRyxRQUFYLENBQW9CRSxJQUFuQyxDQUFGLEdBQ2pCLEtBQUtMLEtBQUwsQ0FBV0csUUFBWCxDQUFvQkUsSUFESCxHQUVqQixFQUZIO0FBR0EsT0FBTStaLG9CQUFvQm5aLEVBQUVwQixHQUFGLENBQU9VLE1BQVAsRUFBZSxVQUFFQyxLQUFGLEVBQVNxSyxLQUFULEVBQW9CO0FBQzVELFFBQUssQ0FBRXJLLE1BQU1vRixRQUFSLElBQW9CdVUsZ0JBQWdCM1osTUFBTTZELFVBQS9DLEVBQTREO0FBQzNELFNBQ0M0VixpQkFDRSxDQUFFQSxhQUFGLElBQW1CaFosRUFBRUMsT0FBRixDQUFXVixNQUFNaUYsWUFBakIsQ0FGdEIsRUFHRTtBQUNELGFBQ0M7QUFBQTtBQUFBLFNBQUksV0FBVSwwQkFBZCxFQUF5QyxLQUFNb0YsS0FBL0M7QUFDQztBQUFBO0FBQUE7QUFDQyxvQkFBVSx3QkFEWDtBQUVDLGtCQUFVLE9BQUs0TyxhQUFMLENBQW1CM00sSUFBbkIsQ0FBeUIsTUFBekIsRUFBK0J0TSxNQUFNRyxVQUFyQztBQUZYO0FBSUcsb0NBQVlILE1BQU1rQixLQUFsQjtBQUpIO0FBREQsT0FERDtBQVVBO0FBQ0Q7QUFDRCxJQWxCeUIsQ0FBMUI7O0FBb0JBLFVBQ0M7QUFBQyxtQkFBRCxDQUFPLFFBQVA7QUFBQTtBQUNFd1ksc0JBQWtCQSxlQUFlRyxJQUFmLENBQXFCLFVBQVVDLElBQVYsRUFBaUI7QUFBRSxZQUFPLGdCQUFnQixPQUFPQSxJQUE5QjtBQUFvQyxLQUE1RSxDQUFsQixJQUNBO0FBQUMsb0JBQUQsQ0FBTyxRQUFQO0FBQUE7QUFDQztBQUFBO0FBQUEsUUFBSSxXQUFVLDBCQUFkO0FBQ0M7QUFBQTtBQUFBO0FBQVMsNkJBQVcsaUJBQVg7QUFBVDtBQURELE1BREQ7QUFLQztBQUFDLHFCQUFELENBQU8sUUFBUDtBQUFBO0FBQWlCSjtBQUFqQjtBQUxELEtBRkY7QUFXR0UseUJBQXFCQSxrQkFBa0JDLElBQWxCLENBQXdCLFVBQVVDLElBQVYsRUFBaUI7QUFBRSxZQUFPLGdCQUFnQixPQUFPQSxJQUE5QjtBQUFvQyxLQUEvRSxDQUFyQixJQUNEO0FBQUMsb0JBQUQsQ0FBTyxRQUFQO0FBQUE7QUFDQztBQUFBO0FBQUEsUUFBSSxXQUFVLDBCQUFkO0FBQ0M7QUFBQTtBQUFBO0FBQVMsNkJBQVcsaUJBQVg7QUFBVDtBQURELE1BREQ7QUFLQztBQUFDLHFCQUFELENBQU8sUUFBUDtBQUFBO0FBQWlCRjtBQUFqQjtBQUxEO0FBWkYsSUFERDtBQXVCQTs7O2dDQUVhO0FBQUE7O0FBQ2IsT0FBTUcsZ0JBQWdCLENBQUV0WixFQUFFQyxPQUFGLENBQVcsS0FBS2xCLEtBQUwsQ0FBV3VhLGFBQXRCLENBQUYsR0FBMEMsS0FBS3ZhLEtBQUwsQ0FBV3VhLGFBQXJELEdBQXFFLEVBQTNGOztBQUVBLFVBQ0M7QUFBQyxtQkFBRCxDQUFPLFFBQVA7QUFBQTtBQUNDO0FBQUE7QUFBQSxPQUFJLFdBQVUsMEJBQWQ7QUFDQztBQUFBO0FBQUE7QUFBUyw0QkFBVyxXQUFYO0FBQVQ7QUFERCxLQUREO0FBS0V0WixNQUFFcEIsR0FBRixDQUFPMGEsYUFBUCxFQUFzQixVQUFFN1ksS0FBRixFQUFTOFksR0FBVDtBQUFBLFlBQ3RCO0FBQUE7QUFBQSxRQUFJLFdBQVUsMEJBQWQsRUFBeUMsS0FBTUEsR0FBL0M7QUFDQztBQUFBO0FBQUE7QUFDQyxtQkFBVSx3QkFEWDtBQUVDLGlCQUFVLE9BQUtmLGFBQUwsQ0FBbUIzTSxJQUFuQixDQUF5QixNQUF6QixFQUErQjBOLEdBQS9CO0FBRlg7QUFJRTlZO0FBSkY7QUFERCxNQURzQjtBQUFBLEtBQXRCO0FBTEYsSUFERDtBQWtCQTs7O21DQUNnQjtBQUFBOztBQUNoQixPQUFJK1ksZUFBZSxLQUFLemEsS0FBTCxDQUFXTCxRQUE5QjtBQUNBLE9BQUssQ0FBRXNCLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBVzhaLGdCQUExQixDQUFGLElBQWtELENBQUU3WSxFQUFFMkMsV0FBRixDQUFldkIsZUFBZTBYLGdCQUE5QixDQUF6RCxFQUE0RztBQUMzR1UsbUJBQWVwWSxlQUFlMFgsZ0JBQTlCO0FBQ0E7QUFDRCxPQUFNVyxlQUFlLDRCQUFpQixRQUFqQixFQUEyQkQsWUFBM0IsQ0FBckI7QUFDQSxPQUFNRSxlQUFlLDRCQUFpQixRQUFqQixFQUEyQkYsWUFBM0IsQ0FBckI7QUFDQSxPQUFNRyxpQkFBaUIsQ0FBRTNaLEVBQUVDLE9BQUYsQ0FBVyxLQUFLbEIsS0FBTCxDQUFXNGEsY0FBdEIsQ0FBRixHQUEyQyxLQUFLNWEsS0FBTCxDQUFXNGEsY0FBdEQsR0FBdUUsRUFBOUY7QUFDQSxPQUFJLENBQUUzWixFQUFFQyxPQUFGLENBQVd3WixZQUFYLENBQUYsSUFBK0IsQ0FBRXpaLEVBQUVDLE9BQUYsQ0FBV3laLFlBQVgsQ0FBckMsRUFBaUU7QUFDaEUsV0FDQztBQUFDLG9CQUFELENBQU8sUUFBUDtBQUFBO0FBQ0UsVUFBSzNhLEtBQUwsQ0FBVzRhLGNBQVgsSUFDQTtBQUFBO0FBQUEsUUFBSSxXQUFVLDBCQUFkO0FBQ0M7QUFBQTtBQUFBO0FBQVMsNkJBQVUsY0FBVjtBQUFUO0FBREQsTUFGRjtBQU9FM1osT0FBRXBCLEdBQUYsQ0FBTSthLGNBQU4sRUFBc0IsVUFBQ2xaLEtBQUQsRUFBUThZLEdBQVI7QUFBQSxhQUN0QjtBQUFBO0FBQUEsU0FBSSxXQUFVLDBCQUFkLEVBQXlDLEtBQUtBLEdBQTlDO0FBQ0M7QUFBQTtBQUFBO0FBQ0Msb0JBQVUsd0JBRFg7QUFFQyxrQkFBUyxPQUFLZixhQUFMLENBQW1CM00sSUFBbkIsQ0FBd0IsTUFBeEIsRUFBOEIwTixHQUE5QjtBQUZWO0FBSUU5WTtBQUpGO0FBREQsT0FEc0I7QUFBQSxNQUF0QjtBQVBGLEtBREQ7QUFvQkE7QUFDRDs7O3FDQUVrQjtBQUFBOztBQUNsQixPQUFLLEtBQUsxQixLQUFMLENBQVc2YSxpQkFBaEIsRUFBb0M7QUFDbkMsV0FBTyxFQUFQO0FBQ0E7O0FBRUQsT0FBTUMsYUFBYSxLQUFLOWEsS0FBTCxDQUFXK2EsZUFBWCxHQUE2QixFQUE3QixHQUFrQyxLQUFLQyxXQUFMLEVBQXJEO0FBQ0EsT0FBTUMsZ0JBQWdCLEtBQUtqYixLQUFMLENBQVdrYixjQUFYLEdBQTRCLEtBQUtDLGNBQUwsRUFBNUIsR0FBb0QsRUFBMUU7QUFDQSxPQUFNQyxlQUFlLEtBQUtwYixLQUFMLENBQVdrYixjQUFYLEdBQTRCLEtBQUtHLFdBQUwsRUFBNUIsR0FBaUQsRUFBdEU7QUFDQSxPQUFNQyxjQUFjLEtBQUt0YixLQUFMLENBQVdzYixXQUFYLEdBQ2pCLEtBQUt0YixLQUFMLENBQVdzYixXQURNLEdBRWpCLEVBQUVDLFdBQVcsc0JBQVcsV0FBWCxDQUFiLEVBRkg7O0FBSUEsVUFDQztBQUFBO0FBQUEsTUFBSSxXQUFZLEtBQUs5SSxLQUFMLENBQVd3RixpQkFBWCxHQUErQixZQUEvQixHQUE4QyxFQUE5RDtBQUNFLFNBQUtqWSxLQUFMLENBQVd3YixtQkFBWCxJQUNBO0FBQUE7QUFBQSxPQUFJLFdBQVUsMEJBQWQ7QUFDQztBQUFBO0FBQUE7QUFDQyxrQkFBVSx3QkFEWDtBQUVDLGdCQUFVLEtBQUsvQixhQUFMLENBQW1CM00sSUFBbkIsQ0FBeUIsSUFBekIsRUFBK0IsWUFBL0I7QUFGWDtBQUlFLDRCQUFXLGlCQUFYO0FBSkY7QUFERCxLQUZGO0FBV0UsU0FBSzlNLEtBQUwsQ0FBV3liLHNCQUFYLElBQ0E7QUFBQTtBQUFBLE9BQUksV0FBVSwwQkFBZDtBQUNDO0FBQUE7QUFBQTtBQUNDLGtCQUFVLHdCQURYO0FBRUMsZ0JBQVUsS0FBS2hDLGFBQUwsQ0FBbUIzTSxJQUFuQixDQUF5QixJQUF6QixFQUErQixzQkFBL0I7QUFGWDtBQUlFLDRCQUFXLHNCQUFYO0FBSkY7QUFERCxLQVpGO0FBc0JFc08sZ0JBdEJGO0FBd0JDO0FBQUMsb0JBQUQsQ0FBTyxRQUFQO0FBQUE7QUFDRSxVQUFLcGIsS0FBTCxDQUFXMGIsZ0JBQVgsSUFDQTtBQUFBO0FBQUEsUUFBSSxXQUFVLDBCQUFkO0FBQ0M7QUFBQTtBQUFBO0FBQVUsWUFBSzFiLEtBQUwsQ0FBVzBiO0FBQXJCO0FBREQsTUFGRjtBQU9FemEsT0FBRXBCLEdBQUYsQ0FBT3liLFdBQVAsRUFBb0IsVUFBRTVaLEtBQUYsRUFBUzhZLEdBQVQ7QUFBQSxhQUNwQjtBQUFBO0FBQUEsU0FBSSxXQUFVLDBCQUFkLEVBQXlDLEtBQU1BLEdBQS9DO0FBQ0M7QUFBQTtBQUFBO0FBQ0Msb0JBQVUsd0JBRFg7QUFFQyxrQkFBVSxPQUFLZixhQUFMLENBQW1CM00sSUFBbkIsQ0FBeUIsTUFBekIsRUFBK0IwTixHQUEvQjtBQUZYO0FBSUU5WTtBQUpGO0FBREQsT0FEb0I7QUFBQSxNQUFwQjtBQVBGLEtBeEJEO0FBMkNFb1osY0EzQ0Y7QUE0Q0VHO0FBNUNGLElBREQ7QUFnREE7OzswQkFDUTVaLEssRUFBUTtBQUNoQixPQUFLLEtBQUtyQixLQUFMLENBQVdvTixVQUFoQixFQUE2QjtBQUM1QixXQUFPLEtBQUtwTixLQUFMLENBQVdvTixVQUFYLElBQXlCLENBQUVuTSxFQUFFQyxPQUFGLENBQVdHLEtBQVgsQ0FBbEM7QUFDQSxJQUZELE1BRU8sSUFBSyxDQUFFSixFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdxTixVQUExQixDQUFQLEVBQWdEO0FBQ3RELFdBQU9wTSxFQUFFQyxPQUFGLENBQVdHLEtBQVgsS0FBc0JBLFNBQVMsQ0FBdEM7QUFDQTs7QUFFRCxVQUFPLElBQVA7QUFDQTs7OzJCQUVRO0FBQUE7O0FBQ1IsT0FBTUEsUUFBUSxLQUFLckIsS0FBTCxDQUFXRyxRQUFYLENBQXFCLEtBQUtILEtBQUwsQ0FBV2dOLFFBQWhDLEtBQThDLEtBQUtoTixLQUFMLENBQVdzTixZQUF6RCxJQUF5RSxFQUF2Rjs7QUFFQSxPQUFNaU4sZ0JBQWdCLEtBQUtvQixnQkFBTCxFQUF0Qjs7QUFFQSxPQUFNcE8sZ0JBQWdCLENBQUV0TSxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVd1TixhQUExQixDQUFGLEdBQ25CLEtBQUt2TixLQUFMLENBQVd1TixhQURRLEdBRW5CLHNCQUFXLHlCQUFYLENBRkg7O0FBSUEsT0FBTUMsZ0JBQWdCLENBQUUsS0FBS3ZDLE9BQUwsQ0FBYzVKLEtBQWQsQ0FBRixHQUEwQixzQkFBMUIsR0FBbUQsRUFBekU7O0FBRUEsT0FBSXVhLDRCQUFKOztBQUVBLE9BQUssQ0FBRTNhLEVBQUVDLE9BQUYsQ0FBV3FaLGFBQVgsQ0FBUCxFQUFvQztBQUNuQ3FCLDBCQUNDO0FBQUE7QUFBQSxPQUFLLFdBQVUsb0JBQWY7QUFDQztBQUFBO0FBQUE7QUFDQyxrQkFDQyxLQUFLbkosS0FBTCxDQUFXd0YsaUJBQVgsR0FBK0Isd0JBQS9CLEdBQTBELGFBRjVEO0FBSUMsdUJBQWUsQ0FBRWhYLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBVzZiLFlBQTFCLENBQUYsR0FBNkMsS0FBSzdiLEtBQUwsQ0FBVzZiLFlBQXhELEdBQXVFLHNCQUFXLGVBQVgsQ0FKdkY7QUFLQyxnQkFBVSxLQUFLN0Q7QUFMaEI7QUFPQywyQ0FBRyxXQUFVLHNCQUFiLEVBQW9DLGVBQVksTUFBaEQsR0FQRDtBQVFHLE9BQUUvVyxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdzVixXQUExQixDQUFGLEdBQTRDLEtBQUt0VixLQUFMLENBQVdzVixXQUF2RCxHQUFxRSxzQkFBVyxvQkFBWDtBQVJ4RSxNQUREO0FBWUVpRjtBQVpGLEtBREQ7QUFnQkE7O0FBRUQsT0FBSXVCLGdCQUFnQixFQUFwQjs7QUFFQSxPQUFLLEtBQUs5YixLQUFMLENBQVcwQixLQUFoQixFQUF3QjtBQUN2Qm9hLG9CQUNDO0FBQUE7QUFBQTtBQUNDLHNDQUVFLEtBQUs5YixLQUFMLENBQVdnTixRQUFYLEdBQXNCLENBQUUvTCxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVcyWSxPQUExQixDQUF4QixHQUNHLEtBQUszWSxLQUFMLENBQVcyWSxPQURkLEdBRUcsRUFKTCxDQUREO0FBUUMsaUJBQVU7QUFSWDtBQVVFLFVBQUszWSxLQUFMLENBQVcwQixLQVZiO0FBQUE7QUFVMkIsVUFBSzFCLEtBQUwsQ0FBV29OLFVBQVgsSUFDekI7QUFBQTtBQUFBLFFBQU0sV0FBVSxXQUFoQjtBQUFBO0FBQUEsTUFYRjtBQWFFLFVBQUtwTixLQUFMLENBQVcrTixJQUFYLElBQW1CO0FBQUE7QUFBQSxRQUFNLFdBQVUsZ0JBQWhCO0FBQWtDLFdBQUsvTixLQUFMLENBQVcrTjtBQUE3QztBQWJyQixLQUREO0FBaUJBOztBQUVELFVBQ0M7QUFBQTtBQUFBLE1BQUssK0JBQStCUCxhQUFwQztBQUVHc08saUJBRkg7QUFJRyxTQUFLOWIsS0FBTCxDQUFXK2IsY0FBWCxJQUNEO0FBQUE7QUFBQSxPQUFNLFdBQVUsaUJBQWhCLEVBQWtDLE9BQVEsRUFBRTlKLGNBQWMsTUFBaEIsRUFBMUM7QUFDRyxVQUFLalMsS0FBTCxDQUFXK2I7QUFEZCxLQUxGO0FBVUM7QUFBQTtBQUFBLE9BQUssV0FBWSxnQkFDaEI5YSxFQUFFQyxPQUFGLENBQVdxWixhQUFYLElBQ0csRUFESCxHQUVHLDBCQUhhLENBQWpCO0FBTUdxQix3QkFOSDtBQVFDO0FBQ0MsaUNBRUUsS0FBSzViLEtBQUwsQ0FBV2dOLFFBQVgsR0FBc0IsQ0FBRS9MLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBVzJZLE9BQTFCLENBQXhCLEdBQ0csS0FBSzNZLEtBQUwsQ0FBVzJZLE9BRGQsR0FFRyxFQUpMLENBREQ7QUFRQyxtQkFBYyxLQUFLM1ksS0FBTCxDQUFXaU8sV0FSMUI7QUFTQyxvQkFBZTVNLEtBVGhCO0FBVUMsZ0JBQVcscUJBQUs7QUFDZixjQUFLd0wsV0FBTCxDQUFrQi9ELEVBQUU0RCxNQUFGLENBQVNyTCxLQUEzQjtBQUNBLE9BWkY7QUFhQyxXQUFNO0FBQUEsY0FBZ0IsT0FBS3lXLFVBQUwsR0FBa0JBLFVBQWxDO0FBQUE7QUFiUDtBQVJELEtBVkQ7QUFvQ0csU0FBSzlYLEtBQUwsQ0FBV29OLFVBQVgsSUFBeUIsQ0FBRSxLQUFLbkMsT0FBTCxDQUFjNUosS0FBZCxDQUEzQixJQUNEO0FBQUE7QUFBQSxPQUFNLFdBQVUsbUJBQWhCO0FBQXNDa007QUFBdEMsS0FyQ0Y7QUF3Q0csU0FBS3ZOLEtBQUwsQ0FBVzBPLFdBQVgsSUFDRDtBQUFBO0FBQUEsT0FBTSxXQUFVLGlCQUFoQjtBQUFvQyxVQUFLMU8sS0FBTCxDQUFXME87QUFBL0M7QUF6Q0YsSUFERDtBQThDQTs7OztFQWhkb0NFLGdCOztrQkFBakJpSixROzs7Ozs7OztBQ0xyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDM0RBO0FBQUEsbURBQW1ELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCwyQkFBMkIsRUFBRSxFQUFFLEVBQUUsZUFBZTs7QUFFOVA7QUFDQTtBQUNvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMEJBQTBCOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7Ozs7O0FDaEVBOzs7O0FBQ0E7Ozs7Ozs7Ozs7SUFFcUJtRSxTOzs7QUFDcEIsb0JBQWFoYyxLQUFiLEVBQXFCO0FBQUE7O0FBQUEsb0hBQ2JBLEtBRGE7O0FBR3BCLFFBQUt5UyxLQUFMLEdBQWE7QUFDWjlGLFNBQU0zTSxNQUFNaWMsUUFBTixJQUFrQjtBQURaLEdBQWI7O0FBSUEsUUFBS0MsV0FBTCxHQUFtQixNQUFLQSxXQUFMLENBQWlCcFAsSUFBakIsT0FBbkI7QUFQb0I7QUFRcEI7Ozs7Z0NBRWE7QUFDYixRQUFLNkYsUUFBTCxDQUFlO0FBQ2RoRyxVQUFNLENBQUUsS0FBSzhGLEtBQUwsQ0FBVzlGO0FBREwsSUFBZjtBQUdBOzs7MkJBRVE7QUFBQTs7QUFBQSxPQUNBakwsS0FEQSxHQUNVLEtBQUsxQixLQURmLENBQ0EwQixLQURBO0FBQUEsT0FFQWlMLElBRkEsR0FFUyxLQUFLOEYsS0FGZCxDQUVBOUYsSUFGQTs7QUFHUixPQUFJK0UsV0FBVyxFQUFmOztBQUVBLE9BQUsvRSxJQUFMLEVBQVk7QUFDWCtFLGVBQVcsMEJBQVg7QUFDQTs7QUFFRDtBQUNBLE9BQU15SyxlQUFpQixDQUFFbGIsRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXbWMsWUFBMUIsQ0FBRixJQUE4QyxPQUFPLEtBQUtuYyxLQUFMLENBQVdtYyxZQUFsRSxHQUNsQixLQUFLbmMsS0FBTCxDQUFXbWMsWUFETyxHQUVsQixJQUZIOztBQUlBLE9BQU1DLHVCQUF5QixDQUFFbmIsRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXb2Msb0JBQTFCLENBQUosR0FDMUIsS0FBS3BjLEtBQUwsQ0FBV29jLG9CQURlLEdBRTFCLEtBRkg7O0FBSUEsT0FBTUMsb0JBQW9CdE4sZ0JBQU1DLFFBQU4sQ0FBZW5QLEdBQWYsQ0FBb0IsS0FBS0csS0FBTCxDQUFXOE8sUUFBL0IsRUFBeUMsZUFBTztBQUN6RSxXQUFPdUMsR0FBUDtBQUNBLElBRnlCLENBQTFCOztBQUlBO0FBQ0EsVUFDQztBQUFBO0FBQUEsTUFBSyxXQUFZLHdCQUF3QkssUUFBekM7QUFDQztBQUFBO0FBQUEsT0FBTSxXQUFVLDJCQUFoQixFQUE0QyxTQUFVO0FBQUEsY0FBTSxPQUFLd0ssV0FBTCxFQUFOO0FBQUEsT0FBdEQ7QUFDQztBQUFBO0FBQUEsUUFBSyxXQUFVLDBCQUFmO0FBQ0M7QUFBQTtBQUFBO0FBQVF4YTtBQUFSLE9BREQ7QUFFQztBQUFBO0FBQUE7QUFDQyxtQkFBVSw4Q0FEWDtBQUVDLGlCQUFVO0FBQUEsZ0JBQU0sT0FBS3dhLFdBQUwsRUFBTjtBQUFBO0FBRlg7QUFJQyw0Q0FBRyxXQUFVLHVCQUFiLEVBQXFDLGVBQVksTUFBakQsR0FKRDtBQUtDO0FBQUE7QUFBQSxVQUFNLFdBQVUsd0JBQWhCO0FBQ0csa0JBQVUsS0FBS3pKLEtBQUwsQ0FBVzlGLElBQXJCLEdBQTRCLE1BQTVCLEdBQXFDO0FBRHhDO0FBTEQ7QUFGRDtBQURELEtBREQ7QUFlQztBQUFBO0FBQUEsT0FBSyxXQUFVLHlCQUFmO0FBQ0csZUFBVXdQLFlBQVYsR0FDQyxDQUFFQyx3QkFBd0J6UCxJQUExQixLQUFvQzBQLGlCQURyQyxHQUdBO0FBQUE7QUFBQSxRQUFLLFdBQVUsU0FBZjtBQUNDO0FBQUE7QUFBQSxTQUFLLFdBQVUsY0FBZjtBQUNHLFFBQUVELHdCQUF3QnpQLElBQTFCLEtBQW9DMFA7QUFEdkMsT0FERDtBQUlHRjtBQUpIO0FBSkg7QUFmRCxJQUREO0FBK0JBOzs7O0VBdkVxQ3ZOLGdCOztrQkFBbEJvTixTOzs7Ozs7OztBQ0hyQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM1UEEsMEM7Ozs7Ozs7QUNBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ1ZBOzs7Ozs7Ozs7Ozs7SUFFcUJNLFE7OztBQUNwQixtQkFBYXRjLEtBQWIsRUFBcUI7QUFBQTs7QUFBQSxrSEFDYkEsS0FEYTs7QUFHcEIs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QUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNILG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQzdTQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0I7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQSwyQjs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBYTtBQUNuRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsNEZBQTRGLGVBQWU7QUFDM0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Qjs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQsMEJBQTBCLG9DQUFvQztBQUM5RCwwQkFBMEIsb0NBQW9DO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCxzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0QyxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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WSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNyYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQzs7Ozs7OztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5Q0FBeUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyxZQUFZO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUN6VkE7O0FBRUE7QUFDQSxNQUFNO0FBQ04sb0JBQW9CLEVBQUU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxQkFBcUIsRUFBRTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLEVBQUUsaUJBQWlCLEVBQUUsS0FBSztBQUNwRTtBQUNBO0FBQ0Esb0M7Ozs7OztBQ2xDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0JBQStCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7Ozs7Ozs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEVBQUU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQzFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7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QSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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QUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOzs7QUFH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a0JnQjtBQUpNLENBQXpCOztBQU9BQyxPQUFPQyxPQUFQLEdBQWlCakMsU0FBakIsQzs7Ozs7O0FDNUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQzs7QUFFQTs7QUFFQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLDBCQUEwQixlQUFlO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25nQnlZLGFBQWEsb0NBQW9DLFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLHNFQUFzRSxTQUFTLHdCQUF3QixvQkFBb0IsZ0NBQWdDLElBQUkseUJBQXlCLFNBQVMsZUFBZSxtTEFBNEgsdUNBQXVDLEVBQUUsY0FBYywyQkFBMkIsY0FBYyxxR0FBcUcsY0FBYywrQ0FBK0MscXBCQUFxcEIsd0NBQXdDLHdYQUF3WCx1dkJBQXV2QixTQUFTLEVBQUUsaytDQUFrK0MsR0FBRyxrSEFBa0gsNEJBQTRCLEVBQUUsaWFBQWlhLElBQUksYUFBYSw4RUFBOEUsSUFBSSwwREFBMEQsOEJBQThCLHdCQUF3QixLQUFLLGNBQWMsc0RBQXNELElBQUksd0JBQXdCLHdOQUF3TixpQkFBaUIsY0FBYyxnRUFBZ0Usa0JBQWtCLGtDQUFrQyxnQkFBZ0IsSUFBSSwwQkFBMEIsU0FBUyw2QkFBNkIsOEJBQThCLHlDQUF5QyxLQUFLLHVCQUF1Qix3RUFBd0UsWUFBWSxJQUFJLHlCQUF5QixnREFBZ0QsSUFBSSw0REFBNEQsMEJBQTBCLGtCQUFrQixzREFBc0QscUJBQXFCLFlBQVksSUFBSSw0QkFBNEIsd0JBQXdCLFNBQVMsbURBQW1ELDhEQUE4RCxJQUFJLHVDQUF1QyxTQUFTLEdBQUcseUNBQXlDLDRCQUE0QixLQUFLLFNBQVMsS0FBSyxVQUFVLGtHQUFrRyxlQUFlLGdCQUFnQixpQkFBaUIsb0NBQW9DLG9JQUFvSSx3Q0FBd0MsSUFBSSxrQ0FBa0MsaUJBQWlCLHFFQUFxRSxJQUFJLEtBQUssa0JBQWtCLE1BQU0saUJBQWlCLE1BQU0saUNBQWlDLG1FQUFtRSxpQkFBaUIsY0FBYyxrR0FBa0csZUFBZSwyRUFBMkUsa0NBQWtDLEtBQUssS0FBSyxXQUFXLGtEQUFrRCxvQ0FBb0MseUVBQXlFLFVBQVUsMERBQTBELGNBQWMsY0FBYyx3QkFBd0Isa0VBQWtFLDBCQUEwQiw4Q0FBOEMsSUFBSSxLQUFLLFdBQVcsNEJBQTRCLE1BQU0sa0JBQWtCLGtCQUFrQixrQ0FBa0MsSUFBSSxtREFBbUQsU0FBUyxVQUFVLDBCQUEwQix1Q0FBdUMsdUJBQXVCLDZCQUE2QiwyREFBMkQsR0FBRyxnQkFBZ0IsY0FBYyx3QkFBd0Isc0NBQXNDLGtCQUFrQixrQ0FBa0MseUJBQXlCLGlEQUFpRCw2REFBNkQsU0FBUywwQkFBMEIsc0RBQXNELHVCQUF1QixrREFBa0QsR0FBRyxnQkFBZ0IsY0FBYyw0QkFBNEIsa0JBQWtCLGtDQUFrQyxtRUFBbUUsMEJBQTBCLHFDQUFxQyx1QkFBdUIsc0NBQXNDLEdBQUcsVUFBVSxpQ0FBaUMsY0FBYyxrQkFBa0IsbUNBQW1DLG1CQUFtQixLQUFLLG1HQUFtRyxzREFBc0QsSUFBSSxLQUFLLFdBQVcscUZBQXFGLFFBQVEseUJBQXlCLGFBQWEsa0JBQWtCLDhDQUE4QyxvQ0FBb0MsZ0JBQWdCLG1DQUFtQyxrQ0FBa0Msb0NBQW9DLHFCQUFxQixxSUFBcUksY0FBYyw4QkFBOEIsbURBQW1ELDhCQUE4QixtREFBbUQsS0FBSyxjQUFjLDhCQUE4QiwrQkFBK0IseURBQXlELDBCQUEwQiw2Q0FBNkMsMEJBQTBCLGtEQUFrRCx1QkFBdUIsZ0JBQWdCLHVCQUF1QixtQkFBbUIseUNBQXlDLElBQUksS0FBSyxXQUFXLGVBQWUscUNBQXFDLGlCQUFpQixtQ0FBbUMsbUNBQW1DLHVCQUF1QixlQUFlLGdCQUFnQixhQUFhLFNBQVMsT0FBTyxHQUFHLDhCQUE4Qiw0Q0FBNEMsZUFBZSxXQUFXLGtCQUFrQixLQUFLLHFCQUFxQixxQ0FBcUMscUJBQXFCLG1CQUFtQixFQUFFLDBCQUEwQixTQUFTLGdCQUFnQixtQkFBbUIsZUFBZSxZQUFZLFdBQVcsTUFBTSxXQUFXLHdCQUF3QixTQUFTLGlDQUFpQyxrQkFBa0IsaU1BQWlNLDJEQUEyRCw0QkFBNEIsdUxBQXVMLEtBQUssa0VBQWtFLHlCQUF5QiwwQkFBMEIscUJBQXFCLCtCQUErQixLQUFLLGdFQUFnRSxJQUFJLEtBQUssb0JBQW9CLDhFQUE4RSxXQUFXLGtEQUFrRCxrQkFBa0IsTUFBTSxnQkFBZ0IseUJBQXlCLDBCQUEwQixxQkFBcUIsV0FBVyxtQkFBbUIsR0FBRywyQ0FBMkMsZUFBZSxvTEFBcUgsY0FBYyxTQUFTLE1BQU0sR0FBRyxXQUFXLHFDQUFxQyxVQUFVLG1EQUFtRCxNQUFNLE1BQU0saUNBQWlDLE1BQU0saUJBQWlCLHNDQUFzQyxvQ0FBb0Msc0JBQXNCLGdCQUFnQixjQUFjLFVBQVUscUJBQXFCLGdFQUFnRSxvQkFBb0Isb0JBQW9CLHlDQUF5QyxRQUFRLElBQUkseUVBQXlFLEdBQUcsbUJBQW1CLDBDQUEwQyxpRUFBaUUsZUFBZSxXQUFXLFFBQVEsZUFBZSw0Q0FBNEMsa0NBQWtDLHdCQUF3QixvTEFBNEYsY0FBYyx5RUFBaUIsY0FBYyx5RUFBaUIsZUFBZSx5S0FBOEQsUUFBUSxnRUFBZ0UsZ0JBQWdCLDREQUE0RCxxQkFBcUIsS0FBSyxtSEFBOEQsV0FBVyxTQUFTLGdDQUFnQyxXQUFXLEVBQUUsK0JBQStCLDRFQUFxQiw0RkFBeUMsOEZBQWtELFFBQVEsMEVBQThCLFFBQVEsMEhBQThFLGtCQUFrQixnQkFBZ0IsV0FBVywwQkFBMEIsbUJBQW1CLG9CQUFvQix3RUFBd0UsMEJBQTBCLDRCQUE0QixvREFBb0QsdUNBQXVDLDJDQUEyQyxHQUFHLHVEQUF1RCwyQkFBMkIsZUFBZSx3REFBd0QsbUJBQW1CLGdDQUFnQyxxQkFBcUIscUJBQXFCLDhCQUE4QixJQUFJLDZFQUE2RSxTQUFTLGtCQUFrQixzQ0FBc0MsU0FBUyxtRkFBbUYsV0FBVyw2VEFBbVEsTUFBTSw2RUFBNkUsYUFBYSxpSEFBaUgseU9BQXdLLElBQUksZUFBZSxlQUFlLE1BQU0saUJBQWlCLG1CQUFtQix5Q0FBeUMsZUFBZSxzREFBc0QsSUFBSSx3QkFBd0IsZ0hBQWdILHdEQUF3RCx3Q0FBd0MsbVNBQW1TLElBQUksU0FBUywwQkFBMEIsZ0NBQWdDLEtBQUssc0RBQXNELElBQUksd0JBQXdCLCtCQUErQixvR0FBZ0QsU0FBUyxpQ0FBaUMsUUFBUSxrQkFBa0Isb0JBQW9CLGdFQUFnRSxzQkFBc0IsYUFBYSxFQUFFLHFCQUFxQixlQUFlLHdDQUF3QyxtQkFBbUIsc0JBQXNCLGVBQWUseUdBQXlHLG1CQUFtQiw0RUFBNEUsZ0JBQWdCLDJEQUEyRCxtQkFBbUIsV0FBVyw0QkFBNEIsZUFBZSxzREFBc0QsSUFBSSx3QkFBd0IsZ0JBQWdCLFdBQVcsS0FBSyxXQUFXLDRDQUE0QyxTQUFTLG9GQUF3QyxlQUFlLHlJQUE0QixxQkFBcUIsbUJBQW1CLFNBQVMsV0FBVyxrR0FBa0csdURBQXVELEtBQUssTUFBTSxZQUFZLGVBQWUsMkZBQStDLFFBQVEsa0JBQWtCLFVBQVUsbUJBQW1CLDBGQUEwRixvQ0FBb0MsbUJBQW1CLGdDQUFnQyxtQkFBbUIsK0VBQStFLDRDQUE0QyxpTEFBaUwsK0RBQStELDhEQUE4RCxzQkFBc0IseUZBQXlGLHlCQUF5QixnSUFBZ0kscUdBQTBDLHNCQUFzQixrQkFBa0IsVUFBVSxJQUFJLFFBQVEsT0FBTyw4QkFBOEIsY0FBYywyRkFBMkYsU0FBUyxpSEFBeUQsd0ZBQXdGLDhKQUFtRyw4SEFBOEgsS0FBSyxXQUFXLDBQQUFzRyxnREFBZ0QsV0FBVyw0TEFBaUksV0FBVywwVEFBOFEsb0NBQW9DLG9CQUFvQixZQUFZLGtCQUFrQixRQUFRLFdBQVcsd0NBQXdDLFNBQVMsa0RBQWtELGdCQUFnQixJQUFJLHNCQUFzQixLQUFLLHlDQUF5QyxlQUFlLGdDQUFnQyxpQkFBaUIsZ0NBQWdDLHNCQUFzQixtRkFBbUYsUUFBUSxNQUFNLG1CQUFtQiw2Q0FBNkMscUNBQXFDLDhOQUE4TixjQUFjLDRDQUE0QyxNQUFNLGVBQWUsbUNBQW1DLDZCQUE2Qiw4QkFBOEIseUVBQVcscUlBQXFJLElBQUksbUJBQW1CLHlCQUF5QixvSEFBaUQsaUJBQWlCLDBDQUEwQyxnQ0FBZ0MsaUJBQWlCLEtBQUssS0FBSyxxQkFBcUIsaUJBQWlCLElBQUksd0RBQXdELEdBQUcsR0FBRyxRQUFRLDJpQ0FBMmlDLFlBQVksR0FBRyxrQkFBa0IsZ0JBQWdCLHFGQUFxRixrQkFBa0Isd0NBQXdDLCtEQUErRCxxQkFBcUIsOEJBQThCLGlDQUFpQyxrQ0FBa0Msd0ZBQXdGLEdBQUcsR0FBRyxlQUFlLHNEQUFzRCxJQUFJLHdCQUF3Qix3RkFBd0YsY0FBYywyS0FBK0QsZ1NBQW9QLG9EQUFvRCxtY0FBc1ksNENBQTRDLDRCQUE0QixvQkFBb0Isc0JBQXNCLHNDQUFzQyxLQUFLLFVBQVUsSUFBSSw2QkFBNkIsRUFBRSx5QkFBeUIsdUdBQTJELGVBQWUsdU9BQXVPLHNEQUFzRCxJQUFJLHdCQUF3QixzREFBc0QsbUJBQW1CLGtCQUFrQixhQUFhLFdBQVcsOEJBQThCLDRCQUE0QixlQUFlLFVBQVUsMEhBQTBILDhCQUE4Qix1Q0FBdUMsaUNBQWlDLE1BQU0sd0JBQXdCLFlBQVksb0VBQW9FLDZCQUE2QixVQUFVLCtGQUFtRCxJQUFJLGFBQWEsSUFBSSxzQkFBc0IsWUFBWSxzQkFBc0IsWUFBWSxpQkFBaUIsa0JBQWtCLG1DQUFtQyx3RkFBNEMsb0JBQW9CLElBQUksd0NBQXdDLFlBQVksR0FBRyxrQkFBa0IsOEVBQWtDLGlHQUF5Qyx5UUFBNk4sSUFBSSxjQUFjLEdBQUcsR0FBRyxrSEFBb0QsZUFBZSxxRUFBYSxLQUFLLDZCQUE2QixzNUJBQXM1Qiw2REFBeUI7QUFDamowQjs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiO0FBQ0EsY0FBYyxrQ0FBa0MsaUJBQWlCLFVBQVUsMEJBQTBCLG1EQUFtRCxrQ0FBa0MsNENBQTRDLGtCQUFrQixrQkFBa0IsY0FBYyxnQkFBZ0Isb0JBQW9CLHlCQUF5QiwwQkFBMEIsMEJBQTBCLGtCQUFrQixxQkFBcUIsbUJBQW1CLGVBQWUsZUFBZTtBQUNqZSxtQkFBbUIscUJBQXFCLG1CQUFtQixnQ0FBZ0MsdUJBQXVCLDJCQUEyQixzQ0FBc0MsaUJBQWlCLHNDQUFzQyxpQkFBaUIsOEJBQThCLHFEQUFxRCxpQ0FBaUMsaUJBQWlCLCtCQUErQixpQkFBaUIsMkJBQTJCO0FBQzNjLDJCQUEyQixpQkFBaUIsNkJBQTZCLGlCQUFpQiwrQkFBK0IsaUJBQWlCLGlDQUFpQyxpQkFBaUIsK0JBQStCO0FBQzNOLHVDQUF1Qyw2UUFBNlE7Ozs7Ozs7O0FDZHBUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7QUNwTEE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUM3Q0E7QUFDQTtBQUNBLHlLQUF5SyxPQUFPO0FBQ2hMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isa0NBQWtDO0FBQzFEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQTtBQUNBLGtGQUFrRixxQ0FBcUMseUNBQXlDO0FBQ2hLOztBQUVBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpTUFBaU07QUFDak07O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELDZEQUE2RCxPQUFPO0FBQ3BIO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEVBQUU7QUFDN0I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDdG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQ2pEQTs7QUFFQSxrN0hBQWs3SDs7QUFFbDdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNSQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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c291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNjQxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBiOTQ1YzdjNGE2YjY2Yzk5MDUzMyIsIm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJSZWFjdFwiXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUiLCJpbXBvcnQgaTE4biBmcm9tICdpMThuLXdwLXBsdWdpbic7XG4vKipcbiAqIFJldHVybnMgdW5pcXVlIDQgZGlnaXQgbnVtYmVyXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmROdW1iZXIoKSB7XG5cdC8vcmV0dXJuIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiA5OTk5ICk7XG5cdHZhciBtaW4gPSBNYXRoLmNlaWwoIDEwMDAgKTtcblx0dmFyIG1heCA9IE1hdGguZmxvb3IoIDk5OTkgKTtcblx0cmV0dXJuIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIG1heCAtIG1pbiApICsgbWluICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB3cmFwcGVyIHVuaXEgSURcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVXcmFwcGVySWQoKSB7XG5cdHJldHVybiAnd3JhcHBlci0nICsgcmFuZE51bWJlcigpICsgJy0nICsgcmFuZE51bWJlcigpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd3JhcHBlciBvYmplY3QgYnkgd3JhcHBlciBJRFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB3cmFwcGVySUQgSUQgb2YgdGhlIHdyYXBwZXJcbiAqIEBwYXJhbSB7YXJyYXl9IHdyYXBwZXJzIGN1cnJlbnQgd3JhcHBlcnNcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V3JhcHBlciggd3JhcHBlcklELCB3cmFwcGVycyApIHtcblx0bGV0IHdyYXBwZXJPYmplY3Q7XG5cblx0d3JhcHBlcnMubWFwKCB3cmFwcGVyID0+IHtcblx0XHRpZiAoIHdyYXBwZXIud3JhcHBlcl9pZCA9PT0gd3JhcHBlcklEICkge1xuXHRcdFx0d3JhcHBlck9iamVjdCA9IHdyYXBwZXI7XG5cdFx0fVxuXHR9ICk7XG5cblx0cmV0dXJuIHdyYXBwZXJPYmplY3Q7XG59XG5cbi8qKlxuICogUmV0dXJuIHBhc3NlZCBkZWZhdWx0IHZhbHVlIG9yIGVtcHR5IGlmIGl0J3MgQmFzaWMgdGhlbWVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZ2V0RGVmYXVsdFZhbHVlIERlZmF1bHQgdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtRGVzaWduIFByb3BlcnR5XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0VmFsdWUoIHByb3BzLCBnZXREZWZhdWx0VmFsdWUgKSB7XG5cdHJldHVybiBnZXRUaGVtZU5hbWUoIHByb3BzICkgIT09ICdiYXNpYycgPyBnZXREZWZhdWx0VmFsdWUgOiAnJztcbn1cblxuLyoqXG4gKiBHZXQgcHJlZml4IGZvciBwcm9wZXJ0aWVzIGlmIGl0J3MgQmFzaWMgdGhlbWVcbiAqXG4gKiBAcGFyYW0ge3R5cGV9IGZvcm1EZXNpZ24gUHJvcGVydHlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRoZW1lUHJlZml4KCBwcm9wcyApIHtcblx0cmV0dXJuIGdldFRoZW1lTmFtZSggcHJvcHMgKSA9PT0gJ2Jhc2ljJyA/ICdiYXNpYy0nIDogJyc7XG59XG5cbi8qKlxuICogR2V0IGRlc2lnbiB0aGVtZSBuYW1lXG4gKlxuICogQHBhcmFtIHt0eXBlfSBwcm9wc1Byb3BlcnRpZXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0VGhlbWVOYW1lKCBwcm9wcyApIHtcblx0aWYgKCBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgcHJvcHMuZm9ybURlc2lnbiApIHtcblx0XHRyZXR1cm4gcHJvcHMuZm9ybURlc2lnbjtcblx0fVxuXG5cdGlmICggXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHByb3BzLnNldHRpbmdzICYmIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBwcm9wcy5zZXR0aW5nc1snZm9ybWluYXRvci1wb2xsLWRlc2lnbiddIClcblx0XHRyZXR1cm4gcHJvcHMuc2V0dGluZ3NbJ2Zvcm1pbmF0b3ItcG9sbC1kZXNpZ24nXTtcblxuXHRpZiAoIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBwcm9wcy5xdWl6RGVzaWduIClcblx0XHRyZXR1cm4gcHJvcHMucXVpekRlc2lnbjtcblxuXHRyZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbGwgZmllbGQgdHlwZXMgZGlzYWJsZWQgaW5zaWRlIEdyb3VwIEZpZWxkc1xuICpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzdHJpY3RlZEdyb3VwRmllbGRzKCkge1xuXHRyZXR1cm4gWyAncGFnZS1icmVhaycsICdwYXlwYWwnLCAnc3RyaXBlJywgJ3NpZ25hdHVyZScsICdjYXB0Y2hhJywgJ3Bvc3RkYXRhJywgJ2dyb3VwJyBdO1xufVxuXG4vKipcbiAqIFJldHVybnMgYWxsIGZpZWxkIHR5cGVzIHRoYXQgc2hvdWxkIG9ubHkgb2NjdXB5IGEgc2luZ2xlIHJvdy4gOyhcbiAqIEZpZWxkIGNhbiBvbmx5IGJlIGFkZGVkIGZvciBuZXcvdW5yZWxlYXNlZCBmaWVsZCB0eXBlcy5cbiAqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvbmVyRmllbGRzKCkge1xuXHRyZXR1cm4gWyAncGRmLXBhZ2UtYnJlYWsnLCAnYWxsLWZvcm0tZGF0YScgXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBiZWhhdmlvciB0eXBlc1xuICpcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN1Ym1pc3Npb25CZWhhdmlvcnMoKSB7XG5cdHJldHVybiB7XG5cdFx0J2JlaGF2aW91ci10aGFua3lvdSc6IHRyYW5zbGF0ZSggJ0lubGluZSBNZXNzYWdlJyApLFxuXHRcdCdiZWhhdmlvdXItcmVkaXJlY3QnOiB0cmFuc2xhdGUoICdSZWRpcmVjdCB1c2VyIHRvIGEgVVJMJyApLFxuXHRcdCdiZWhhdmlvdXItaGlkZSc6IHRyYW5zbGF0ZSggJ0hpZGUgZm9ybScgKVxuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgY291bnQgb2YgZXhpc3RpbmcgZmllbGRzIGJ5IHR5cGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSB0eXBlIG9mIGZpZWxkXG4gKiBAcGFyYW0ge2FycmF5fSB3cmFwcGVycyBjdXJyZW50IHdyYXBwZXJzXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvdW50RmllbGRzQnlUeXBlKCB0eXBlLCB3cmFwcGVycyApIHtcblx0bGV0IGNvdW50ZXIgPSAwO1xuXG5cdHdyYXBwZXJzLm1hcCggd3JhcHBlciA9PiB7XG5cdFx0d3JhcHBlci5maWVsZHMubWFwKCBmaWVsZCA9PiB7XG5cdFx0XHRpZiAoIGZpZWxkLnR5cGUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdGNvdW50ZXIrKztcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gY291bnRlcjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIG1heCBJRCBudW1iZXIgYnkgdHlwZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHR5cGUgb2YgZmllbGRcbiAqIEBwYXJhbSB7YXJyYXl9IHdyYXBwZXJzIGN1cnJlbnQgd3JhcHBlcnNcbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF4SURCeVR5cGUoIHR5cGUsIHdyYXBwZXJzICkge1xuXHRjb25zdCBmaWVsZElEcyA9IFtdO1xuXG5cdHdyYXBwZXJzLm1hcCggd3JhcHBlciA9PiB7XG5cdFx0d3JhcHBlci5maWVsZHMubWFwKCBmaWVsZCA9PiB7XG5cdFx0XHRpZiAoIGZpZWxkLnR5cGUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdGNvbnN0IGZpZWxkSWQgPSBmaWVsZC5lbGVtZW50X2lkO1xuXHRcdFx0XHRjb25zdCBmaWVsZElkQXJyYXkgPSBmaWVsZElkLnNwbGl0KCAnLScgKTtcblx0XHRcdFx0c3dpdGNoICggZmllbGQudHlwZSApIHtcblx0XHRcdFx0XHRjYXNlICdwYWdlLWJyZWFrJzpcblx0XHRcdFx0XHRjYXNlICdyaWNoLXRleHQnOlxuXHRcdFx0XHRcdFx0ZmllbGRJRHMucHVzaCggcGFyc2VJbnQoIGZpZWxkSWRBcnJheVsgMiBdICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2FsbC1mb3JtLWRhdGEnOlxuXHRcdFx0XHRcdGNhc2UgJ3BkZi1wYWdlLWJyZWFrJzpcblx0XHRcdFx0XHRcdGZpZWxkSURzLnB1c2goIHBhcnNlSW50KCBmaWVsZElkQXJyYXlbIDMgXSApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0ZmllbGRJRHMucHVzaCggcGFyc2VJbnQoIGZpZWxkSWRBcnJheVsgMSBdICkgKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcblxuXHRsZXQgbWF4VmFsdWUgPSAwO1xuXG5cdGlmICggISBfLmlzRW1wdHkoIGZpZWxkSURzICkgKSB7XG5cdFx0bWF4VmFsdWUgPSBfLm1heCggZmllbGRJRHMgKTtcblx0fVxuXG5cdHJldHVybiBwYXJzZUludCggbWF4VmFsdWUgKSArIDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXhJRCggdHlwZSwgdmFsdWVzICkge1xuXHRjb25zdCBpZHMgPSBbXTtcblxuXHRfLm1hcCggdmFsdWVzLCB2YWx1ZSA9PiB7XG5cdFx0Y29uc3QgZmllbGRJZCA9IHZhbHVlLmVsZW1lbnRfaWQ7XG5cdFx0Y29uc3QgZmllbGRJZEFycmF5ID0gZmllbGRJZC5zcGxpdCggJy0nICk7XG5cblx0XHRpZHMucHVzaCggcGFyc2VJbnQoIGZpZWxkSWRBcnJheVsgMSBdICkgKTtcblx0fSApO1xuXG5cdGxldCBtYXhWYWx1ZSA9IDA7XG5cblx0aWYgKCAhIF8uaXNFbXB0eSggaWRzICkgKSB7XG5cdFx0bWF4VmFsdWUgPSBfLm1heCggaWRzICk7XG5cdH1cblxuXHRyZXR1cm4gcGFyc2VJbnQoIG1heFZhbHVlICkgKyAxO1xufVxuXG4vKipcbiAqIFJldHVybnMgTGFiZWwgY29udmVydGVkIHRvIHZhbHVlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIGVudGVyZWQgbGFiZWxcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVWYWx1ZSggdmFsdWUgKSB7XG5cdHZhbHVlID0gdmFsdWUudHJpbSgpLnJlcGxhY2UoIC9cXHMrfFxcLy9nLCAnLScgKTtcblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgaXQncyBHbG9iYWwgQXBwZWFyYW5jZSBQcmVzZXRcbiAqXG4gKiBAcGFyYW0ge2FycmF5fSB3cmFwcGVycyBjdXJyZW50IHdyYXBwZXJzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc0dsb2JhbFByZXNldCggd3JhcHBlcnMgKSB7XG5cdHJldHVybiBudWxsID09PSB3cmFwcGVycztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZmllbGQgZXhpc3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSB0eXBlIG9mIGZpZWxkXG4gKiBAcGFyYW0ge2FycmF5fSB3cmFwcGVycyBjdXJyZW50IHdyYXBwZXJzXG4gKlxuICogQHJldHVybiB7Ym9vbH1cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNGaWVsZFR5cGUoIHR5cGUsIHdyYXBwZXJzICkge1xuXHRsZXQgY291bnRlciA9IDA7XG5cblx0aWYgKCBpc0dsb2JhbFByZXNldCggd3JhcHBlcnMgKSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHdyYXBwZXJzLm1hcCggd3JhcHBlciA9PiB7XG5cdFx0d3JhcHBlci5maWVsZHMubWFwKCBmaWVsZCA9PiB7XG5cdFx0XHRpZiAoIGZpZWxkLnR5cGUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdGNvdW50ZXIrKztcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gY291bnRlciA+IDA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhcnJheSBvZiBmaWVsZHMgYnkgdHlwZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHR5cGUgb2YgZmllbGRcbiAqIEBwYXJhbSB7YXJyYXl9IHdyYXBwZXJzIGN1cnJlbnQgd3JhcHBlcnNcbiAqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZHNCeVR5cGUoIHR5cGUsIHdyYXBwZXJzICkge1xuXHRjb25zdCBmaWVsZHMgPSBbXTtcblxuXHR3cmFwcGVycy5tYXAoIHdyYXBwZXIgPT4ge1xuXHRcdHdyYXBwZXIuZmllbGRzLm1hcCggZmllbGQgPT4ge1xuXHRcdFx0aWYgKCBmaWVsZC50eXBlID09PSB0eXBlICkge1xuXHRcdFx0XHRmaWVsZHMucHVzaCggZmllbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gZmllbGRzO1xufVxuXG4vKipcbiAqIFJldHVybnMgYXJyYXkgb2YgZmllbGRzIGJ5IHR5cGUgbWFwcGVkIGZvciBzZWxlY3QgZmllbGRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSB0eXBlIG9mIGZpZWxkXG4gKiBAcGFyYW0ge2FycmF5fSB3cmFwcGVycyBjdXJyZW50IHdyYXBwZXJzXG4gKlxuICogQHJldHVybiB7YXJyYXl9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gbWFwRmllbGRzQnlUeXBlKCB0eXBlLCB3cmFwcGVycyApIHtcblx0Y29uc3QgZmllbGRzID0gW107XG5cdGNvbnN0IGZpZWxkc0J5VHlwZSA9IGdldEZpZWxkc0J5VHlwZSggdHlwZSwgd3JhcHBlcnMgKTtcblx0ZmllbGRzQnlUeXBlLm1hcCggZmllbGQgPT4ge1xuXHRcdGxldCBsYWJlbCA9IGZpZWxkLmZpZWxkX2xhYmVsO1xuXG5cdFx0aWYgKCB0eXBlID09PSAnYWRkcmVzcycgKSB7XG5cdFx0XHRsYWJlbCA9IGZpZWxkLmVsZW1lbnRfaWQ7XG5cdFx0fVxuXG5cdFx0ZmllbGRzLnB1c2goIHtcblx0XHRcdHZhbHVlOiBmaWVsZC5lbGVtZW50X2lkLFxuXHRcdFx0bGFiZWw6IGxhYmVsLFxuXHRcdFx0ZWxlbWVudF9pZDogZmllbGQuZWxlbWVudF9pZCxcblx0XHR9ICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gZmllbGRzO1xufVxuXG4vKipcbiAqIFJldHVybnMgZmllbGQgbGFiZWwgYnkgSURcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgZmllbGQgSURcbiAqIEBwYXJhbSB7YXJyYXl9IHdyYXBwZXJzIGN1cnJlbnQgd3JhcHBlcnNcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRMYWJlbCggaWQsIHdyYXBwZXJzICkge1xuXHRsZXQgbGFiZWwgPSAnJztcblx0d3JhcHBlcnMubWFwKCB3cmFwcGVyID0+IHtcblx0XHR3cmFwcGVyLmZpZWxkcy5tYXAoIGZpZWxkID0+IHtcblx0XHRcdGlmICggZmllbGQuZWxlbWVudF9pZCA9PT0gaWQgKSB7XG5cdFx0XHRcdGxhYmVsID0gZmllbGQuZmllbGRfbGFiZWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cblx0cmV0dXJuIGxhYmVsO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaWYgZmllbGQgZXhpc3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgZmllbGQgSURcbiAqIEBwYXJhbSB7YXJyYXl9IHdyYXBwZXJzIGN1cnJlbnQgd3JhcHBlcnNcbiAqXG4gKiBAcmV0dXJuIHtib29sfVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpZWxkRXhpc3QoIGlkLCB3cmFwcGVycyApIHtcblx0bGV0IGV4aXN0ID0gMDtcblxuXHR3cmFwcGVycy5tYXAoIHdyYXBwZXIgPT4ge1xuXHRcdHdyYXBwZXIuZmllbGRzLm1hcCggZmllbGQgPT4ge1xuXHRcdFx0aWYgKCBmaWVsZC5lbGVtZW50X2lkID09PSBpZCApIHtcblx0XHRcdFx0ZXhpc3QrKztcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gZXhpc3QgPiAwO1xufVxuXG4vKipcbiAqIFJldHVybnMgZmllbGQgb2JqZWN0IHdpdGggZGVmYXVsdHMgZnJvbSBzbHVnXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGZpZWxkIGZpZWxkXG4gKiBAcGFyYW0ge3N0cmluZ30gd3JhcHBlcklEIHdyYXBwZXIgaWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2xzIGNvbHVtbnNcbiAqIEBwYXJhbSB7YXJyYXl9IHdyYXBwZXJzIHdyYXBwZXJzXG4gKiBAcGFyYW0ge2FycmF5fSB0ZW1wTmV3RmllbGRzIE5ldyBTaWJsaW5ncyBGaWVsZHMgdGhhdCBhcmVuJ3QgaW5jbHVkZWQgaW4gd3JhcHBlcnMgeWV0XG4gKlxuICogQHJldHVybiB7b2JqZWN0fVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRmllbGRPYmplY3QoIGZpZWxkLCB3cmFwcGVySUQsIGNvbHMsIHdyYXBwZXJzLCB0ZW1wTmV3RmllbGRzICkge1xuXHR0ZW1wTmV3RmllbGRzID0gdGVtcE5ld0ZpZWxkcyB8fCBbXTtcblx0Y29uc3Qgd3JhcHMgPSBbIC4uLndyYXBwZXJzLCB7IGZpZWxkczogdGVtcE5ld0ZpZWxkcyB9IF07XG5cdGNvbnN0IGZpZWxkTnVtYmVyID0gZ2V0TWF4SURCeVR5cGUoIGZpZWxkLnR5cGUsIHdyYXBzICk7XG5cblx0cmV0dXJuIF8uZXh0ZW5kKCBmaWVsZCwge1xuXHRcdGVsZW1lbnRfaWQ6IGZpZWxkLnR5cGUgKyAnLScgKyBmaWVsZE51bWJlcixcblx0XHRmb3JtSUQ6IHdyYXBwZXJJRCxcblx0XHRjb2xzOiBjb2xzLFxuXHR9ICk7XG59XG5cbi8qKlxuICogUmV0dXJucyBmaWVsZCBvYmplY3Qgd2l0aCBkZWZhdWx0cyBmcm9tIHNsdWdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2x1ZyBmaWVsZCBzbHVnXG4gKiBAcGFyYW0ge2FycmF5fSB3cmFwcGVycyB3cmFwcGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IHdyYXBlcHIgSURcbiAqXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRGaWVsZE9iamVjdEZyb21TbHVnKCBzbHVnLCB3cmFwcGVycywgd3JhcHBlcklEICkge1xuXHRjb25zdCBmaWVsZCA9IGZvcm1pbmF0b3JEYXRhLmZpZWxkcy5maW5kKCBmaWVsZERhdGEgPT4ge1xuXHRcdHJldHVybiBmaWVsZERhdGEuc2x1ZyA9PT0gc2x1Zztcblx0fSApO1xuXG5cdGNvbnN0IGZpZWxkTnVtYmVyID0gZ2V0TWF4SURCeVR5cGUoIGZpZWxkLnR5cGUsIHdyYXBwZXJzICk7XG5cblx0Y29uc3QgcHJvcHMgPSB7XG5cdFx0ZWxlbWVudF9pZDogZmllbGQudHlwZSArICctJyArIGZpZWxkTnVtYmVyLFxuXHRcdHR5cGU6IGZpZWxkLnR5cGUsXG5cdFx0b3B0aW9uczogZmllbGQub3B0aW9ucyxcblx0XHRjb2xzOiAxMixcblx0XHRjb25kaXRpb25zOiB7fSxcblx0XHR3cmFwcGVyX2lkOiB3cmFwcGVySUQsXG5cdH07XG5cblx0aWYgKCAgXy5jb250YWlucyggWyAnY2FsY3VsYXRpb24nLCAnbnVtYmVyJywgJ3NsaWRlcicsICdyYWRpbycsICdjdXJyZW5jeScsICdzZWxlY3QnLCAnY2hlY2tib3gnIF0sIGZpZWxkLnR5cGUgKSApIHtcblx0XHRwcm9wc1snaGlkZGVuX2JlaGF2aW9yJ10gPSAnemVybyc7XG5cdH1cblxuXHRyZXR1cm4gXy5leHRlbmQoXG5cdFx0cHJvcHMsXG5cdFx0SlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIGZpZWxkLmRlZmF1bHRzICkgKVxuXHQpO1xufVxuXG4vKipcbiAqIFJldHVybnMgZmllbGQgdHlwZSBieSBmaWVsZCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZmllbGQgZmllbGRcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRUeXBlKCBmaWVsZCApIHtcblx0Y29uc3QgeyB0eXBlIH0gPSBmaWVsZDtcblxuXHRyZXR1cm4gdHlwZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGZvcm1pbmF0b3JEYXRhLmZpZWxkcyhQSFApIGZyb20gZmllbGQgb2JqZWN0IGZyb20gYnVpbGRlclxuICpcbiAqIENvbXBhcmluZyBgdHlwZWBcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZmllbGQgZmllbGRcbiAqXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9ybWluYXRvckZpZWxkKCBmaWVsZCApIHtcblx0cmV0dXJuIGZvcm1pbmF0b3JEYXRhLmZpZWxkcy5maW5kKCBmb3JtaW5hdG9yRmllbGQgPT4gZm9ybWluYXRvckZpZWxkLnR5cGUgPT09IGZpZWxkLnR5cGUgKTtcbn1cblxuLyoqXG4gKiBJbnNlcnQgaXRlbSBpbnRvIGFycmF5IGluIHNwZWNpZmljIHBvc2l0aW9uXG4gKlxuICogQHBhcmFtIHthcnJheX0gYXJyYXkgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBwb3NpdGlvblxuICogQHBhcmFtIHthbnl9IHJlcGxhY2VtZW50IHJlcGxhY2VtZW50XG4gKlxuICogQHJldHVybiB7YXJyYXl9IGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRJblBvc2l0aW9uKCBhcnJheSwgcG9zaXRpb24sIHJlcGxhY2VtZW50ICkge1xuXHRyZXR1cm4gWyAuLi5hcnJheS5zbGljZSggMCwgcG9zaXRpb24gKSwgcmVwbGFjZW1lbnQsIC4uLmFycmF5LnNsaWNlKCBwb3NpdGlvbiApIF07XG59XG5cbi8qKlxuICogUmVwbGFjZSBpdGVtIGluIGFycmF5IGluIHNwZWNpZmljIHBvc2l0aW9uXG4gKlxuICogQHBhcmFtIHthcnJheX0gYXJyYXkgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBwb3NpdGlvblxuICogQHBhcmFtIHthbnl9IHJlcGxhY2VtZW50IHJlcGxhY2VtZW50XG4gKlxuICogQHJldHVybiB7YXJyYXl9IGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlSW5Qb3NpdGlvbiggYXJyYXksIHBvc2l0aW9uLCByZXBsYWNlbWVudCApIHtcblx0cmV0dXJuIFsgLi4uYXJyYXkuc2xpY2UoIDAsIHBvc2l0aW9uICksIHJlcGxhY2VtZW50LCAuLi5hcnJheS5zbGljZSggcG9zaXRpb24gKyAxICkgXTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgc3RyaW5nXG4gKlxuICogQHNlZSBpMThuLnRyYW5zbGF0ZVxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gdHJhbnNsYXRlZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZSgpIHtcblx0cmV0dXJuIGkxOG4udHJhbnNsYXRlLmFwcGx5KCBudWxsLCBhcmd1bWVudHMgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHZhcmlhbnRzIGZvciBzZWxlY3RlZCBmb250XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIGZvbnRcbiAqIEBwYXJhbSB7YXJyYXl9IGZvbnRzIGZvbnRzXG5cbiAqIEByZXR1cm4ge2FycmF5fVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZvbnRWYXJpYW50cyggdmFsdWUsIGZvbnRzICkge1xuXHRjb25zdCBmb250T2JqZWN0ID0gXy5maWx0ZXIoIGZvbnRzLCBmdW5jdGlvbiggZm9udCApIHtcblx0XHRyZXR1cm4gZm9udC5mYW1pbHkgPT09IHZhbHVlO1xuXHR9ICk7XG5cblx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIGZvbnRPYmplY3RbIDAgXSApICYmICEgXy5pc1VuZGVmaW5lZCggZm9udE9iamVjdFsgMCBdLnZhcmlhbnRzICkgKSB7XG5cdFx0cmV0dXJuIGZvbnRPYmplY3RbIDAgXS52YXJpYW50cztcblx0fVxuXG5cdHJldHVybiBbIHRyYW5zbGF0ZSggJ05vbmUnICkgXTtcbn1cblxuLyoqXG4gKiBDYXBpdGFsaXplIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiB1Y2ZpcnN0KCB2YWx1ZSApIHtcblx0cmV0dXJuIHZhbHVlLmNoYXJBdCggMCApLnRvVXBwZXJDYXNlKCkgKyB2YWx1ZS5zbGljZSggMSApO1xufVxuXG4vKipcbiAqIEdldCBjb25kaXRpb24gbGFiZWxcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29uZGl0aW9uTGFiZWwoIGZpZWxkLCBjb25kaXRpb24gKSB7XG5cdGNvbnN0IHZhbHVlID0gY29uZGl0aW9uLnZhbHVlO1xuXHRsZXQgdmFsdWVMYWJlbDtcblxuXHQvLyBJZiBvcHRpb24gZmllbGQgYW5kIGhhdmUgdmFsdWVzLCB3ZSBuZWVkIHRoZSBvcHRpb24gdXBkYXRlVmFsdWVcblx0Ly8gRWxzZSByZXR1cm4gdGhlIGZpZWxkIHZhbHVlXG5cdGlmICggZmllbGQuaGFzT3B0aW9ucyAmJiBmaWVsZC52YWx1ZXMubGVuZ3RoID4gMCApIHtcblx0XHRsZXQgbGFiZWw7XG5cblx0XHQvLyBDaGVjayBpbiB2YWx1ZXNcblx0XHRsYWJlbCA9IF8ud2hlcmUoIGZpZWxkLnZhbHVlcywgeyB2YWx1ZTogdmFsdWUgfSApWyAwIF07XG5cblx0XHQvLyBJZiBsYWJlbCBpcyBub3Qgc2V0LCBjaGVjayBpbiBsYWJlbHNcblx0XHRpZiAoICEgbGFiZWwgKSB7XG5cdFx0XHRsYWJlbCA9IF8ud2hlcmUoIGZpZWxkLnZhbHVlcywgeyBsYWJlbDogdmFsdWUgfSApWyAwIF07XG5cdFx0fVxuXG5cdFx0Ly8gSWYgbGFiZWwgaXMgc3RpbGwgbm90IGZvdW5kLCByZXR1cm5cblx0XHRpZiAoICEgbGFiZWwgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVMYWJlbCA9IGxhYmVsLmxhYmVsO1xuXHR9IGVsc2UgaWYgKCAnZGF0ZScgPT09IGZpZWxkLmZpZWxkX3R5cGUgJiYgWyAnaXNfYmVmb3JlJywgJ2lzX2FmdGVyJyBdLmluY2x1ZGVzKCBjb25kaXRpb24ucnVsZSApICApIHtcblx0XHQvLyBHZXQgZm9ybWF0dGVkIGRhdGUgc3RyaW5nXG5cdFx0dmFsdWVMYWJlbCA9IGNvbnZlcnRUaW1lc3RhbXAoIHZhbHVlICk7XG5cdH0gZWxzZSB7XG5cdFx0dmFsdWVMYWJlbCA9IHZhbHVlO1xuXHR9XG5cblx0Ly8gSWYgbGFiZWwgZW1wdHksIHJldHVybiBudWxsXG5cdGlmICggXy5pc0VtcHR5KCB2YWx1ZUxhYmVsICkgKSB7XG5cdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ251bGwnICk7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWVMYWJlbDtcbn1cblxuLypcbiAqIENvbnZlcnQgZGF0ZSBmcm9tIHRpbWVzdGFtcFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRpbWVzdGFtcCggdmFsdWUgKSB7XG5cdGlmICggISBpc05hTiggTnVtYmVyKCB2YWx1ZSApICkgKSB7XG5cdFx0Ly8gQ29udmVydCB0aW1lc3RhbXAgdG8gRGF0ZSBvYmplY3Rcblx0XHRjb25zdCBkYXRlID0gbmV3IERhdGUoIHZhbHVlKjEgKTtcblxuXHRcdC8vIE9wdGlvbnMgZm9yIGZvcm1hdHRpbmcgdGhlIGRhdGVcblx0XHRjb25zdCBvcHRpb25zID0geyBkYXk6ICdudW1lcmljJywgbW9udGg6ICdudW1lcmljJywgeWVhcjogJ251bWVyaWMnIH07XG5cblx0XHQvLyBHZXQgdGhlIGZvcm1hdHRlZCBkYXRlIHN0cmluZ1xuXHRcdHZhbHVlID0gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoICdlbi1VUycsIG9wdGlvbnMgKTtcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLypcbiAqIFJldHVybnMgYnVpbGRlciBmaWVsZHMgZnJvbSB3cmFwcGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRzKCB3cmFwcGVycywgZGlzYWJsZWRGaWVsZHMsIGV4dHJhLCBpbmNsdWRlZEZpZWxkcywgZXhjbHVkZVN1YkZpZWxkcyApIHtcblx0bGV0IGZpZWxkc0FycmF5ID0gW107XG5cblx0aWYgKCBfLmlzVW5kZWZpbmVkKCBkaXNhYmxlZEZpZWxkcyApICkge1xuXHRcdGRpc2FibGVkRmllbGRzID0gWyAncGFnZS1icmVhaycsICdwb3N0ZGF0YScsICd0b3RhbCcsICdwcm9kdWN0JywgJ2NhcHRjaGEnIF07XG5cdH1cblx0aWYgKCBBcnJheS5pc0FycmF5KCBkaXNhYmxlZEZpZWxkcyApICYmICEgaXNUcnVlKCBleGNsdWRlU3ViRmllbGRzICkgKSB7XG5cdFx0ZGlzYWJsZWRGaWVsZHMucHVzaCggJ2dyb3VwJyApO1xuXHR9XG5cdGxldCBtYWluX2RhdGVfZmllbGQgPSBmYWxzZTtcblxuXHRpZiAoICEgXy5pc1VuZGVmaW5lZCggZXh0cmEgKSAmJiAhIF8uaXNVbmRlZmluZWQoIGV4dHJhLm1haW5fZGF0ZV9maWVsZCApICYmIGV4dHJhLm1haW5fZGF0ZV9maWVsZCA9PT0gdHJ1ZSApIHtcblx0XHRtYWluX2RhdGVfZmllbGQgPSB0cnVlO1xuXHR9XG5cblxuXHQvLyBMb29wIGFsbCB3cmFwcGVycyB3ZSBoYXZlXG5cdHdyYXBwZXJzLm1hcCggd3JhcHBlciA9PiB7XG5cdFx0Y29uc3QgZmllbGRzID0gd3JhcHBlci5maWVsZHMsXG5cdFx0XHRwYXJlbnRHcm91cCA9IHdyYXBwZXIucGFyZW50X2dyb3VwO1xuXHRcdGZpZWxkcy5tYXAoIGZpZWxkID0+IHtcblx0XHRcdC8vIENoZWNrIGlmIGZpZWxkIGlzIGluY2x1ZGVkXG5cdFx0XHRpZiAoICEgXy5pc1VuZGVmaW5lZCggaW5jbHVkZWRGaWVsZHMgKSApIHtcblx0XHRcdFx0aWYgKCAhIF8uY29udGFpbnMoIGluY2x1ZGVkRmllbGRzLCBmaWVsZC50eXBlICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCBfLmNvbnRhaW5zKCBkaXNhYmxlZEZpZWxkcywgZmllbGQudHlwZSApICkge1xuXHRcdFx0XHQvLyBDaGVjayBpZiBmaWVsZCBpcyBkaXNhYmxlZFxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGxldCBsYWJlbDtcblxuXHRcdFx0Ly8gR2V0IGZpZWxkIGxhYmVsXG5cdFx0XHRpZiAoICEgXy5pc1VuZGVmaW5lZCggZmllbGQuZmllbGRfbGFiZWwgKSAmJiAhIF8uaXNFbXB0eSggZmllbGQuZmllbGRfbGFiZWwgKSApIHtcblx0XHRcdFx0bGFiZWwgPSBmaWVsZC5maWVsZF9sYWJlbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxhYmVsID0gZmllbGQudHlwZTtcblx0XHRcdFx0bGFiZWwgPSB1Y2ZpcnN0KCBsYWJlbCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBmaWVsZCBpcyBuYW1lLCBnZXQgYWxsIGV4aXN0aW5nIHN1YiBmaWVsZHNcblx0XHRcdGlmICggZmllbGQudHlwZSA9PT0gJ25hbWUnICYmICEgaXNUcnVlKCBleGNsdWRlU3ViRmllbGRzICkgKSB7XG5cdFx0XHRcdGZpZWxkc0FycmF5ID0gZmllbGRzQXJyYXkuY29uY2F0KCBnZXROYW1lRmllbGRzKCBmaWVsZCwgbGFiZWwsIHBhcmVudEdyb3VwICkgKTtcblx0XHRcdH0gZWxzZSBpZiAoIGZpZWxkLnR5cGUgPT09ICdhZGRyZXNzJyAmJiAhIGlzVHJ1ZSggZXhjbHVkZVN1YkZpZWxkcyApICkge1xuXHRcdFx0XHRmaWVsZHNBcnJheSA9IGZpZWxkc0FycmF5LmNvbmNhdCggZ2V0QWRkcmVzc0ZpZWxkcyggZmllbGQsIGxhYmVsLCBwYXJlbnRHcm91cCApICk7XG5cdFx0XHR9IGVsc2UgaWYgKCBmaWVsZC50eXBlID09PSAnc2xpZGVyJyAmJiBmaWVsZC5zbGlkZXJfdHlwZSA9PT0gJ3JhbmdlJyApIHtcblx0XHRcdFx0ZmllbGRzQXJyYXkgPSBmaWVsZHNBcnJheS5jb25jYXQoIGdldFJhbmdlU2xpZGVyRmllbGRzKCBmaWVsZCwgbGFiZWwsIHBhcmVudEdyb3VwICkgKTtcblx0XHRcdH0gZWxzZSBpZiAoIGZpZWxkLnR5cGUgPT09ICd0aW1lJyAmJiAhIGlzVHJ1ZSggZXhjbHVkZVN1YkZpZWxkcyApICkge1xuXHRcdFx0XHRmaWVsZHNBcnJheSA9IGZpZWxkc0FycmF5LmNvbmNhdCggZ2V0VGltZUZpZWxkcyggZmllbGQsIGxhYmVsLCBwYXJlbnRHcm91cCApICk7XG5cdFx0XHR9ZWxzZSBpZiAoIGZpZWxkLnR5cGUgPT09ICdkYXRlJyAmJiBmaWVsZC5maWVsZF90eXBlICE9PSAncGlja2VyJyAmJiBtYWluX2RhdGVfZmllbGQgPT09IGZhbHNlICkge1xuXHRcdFx0XHQvL3NraXAgbm93XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmaWVsZHNBcnJheS5wdXNoKCB7XG5cdFx0XHRcdFx0ZWxlbWVudF9pZDogZmllbGQuZWxlbWVudF9pZCxcblx0XHRcdFx0XHRwYXJlbnRfZ3JvdXA6IHBhcmVudEdyb3VwLFxuXHRcdFx0XHRcdHJlcXVpcmVkOiBmaWVsZC5yZXF1aXJlZCxcblx0XHRcdFx0XHRmaWVsZF90eXBlOiBmaWVsZC50eXBlLFxuXHRcdFx0XHRcdGZpZWxkX3NsdWc6IGZpZWxkLnR5cGUsXG5cdFx0XHRcdFx0bGFiZWw6IGxhYmVsLFxuXHRcdFx0XHRcdHZhbHVlczogZ2V0RmllbGRWYWx1ZXMoIGZpZWxkICksXG5cdFx0XHRcdFx0aGFzT3B0aW9uczogZmllbGRIYXNPcHRpb25zKCBmaWVsZCApLFxuXHRcdFx0XHRcdGhhc0NhbGNzOiBmaWVsZEhhc0NhbGNzKCBmaWVsZCApLFxuXHRcdFx0XHRcdGZvcm11bGE6IGZpZWxkRm9ybXVsYSggZmllbGQgKSxcblx0XHRcdFx0XHRpc051bWJlcjogZmllbGRIYXNOdW1iZXIoIGZpZWxkICksXG5cdFx0XHRcdFx0ZmllbGREYXRhOiBmaWVsZCxcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBmaWVsZC50eXBlID09PSAnZGF0ZScgJiYgZmllbGQuZmllbGRfdHlwZSAhPT0gJ3BpY2tlcicgJiYgISBpc1RydWUoIGV4Y2x1ZGVTdWJGaWVsZHMgKSApIHtcblx0XHRcdFx0ZmllbGRzQXJyYXkgPSBmaWVsZHNBcnJheS5jb25jYXQoIGdldERhdGVGaWVsZHMoIGZpZWxkLCBsYWJlbCwgcGFyZW50R3JvdXAgKSApO1xuXHRcdFx0fVxuXG5cdFx0fSApO1xuXHR9ICk7XG5cdHJldHVybiBmaWVsZHNBcnJheTtcbn1cbi8qKlxuICogR2V0IG5hbWVfZmllbGRzIChzdXBwb3J0IGRyb3Bkb3duICYgaW5wdXQgZGF0ZSBmaWVsZHMpXG4gKiBAcGFyYW0ge29iamVjdH0gZmllbGQgZmllbGQgdG8gcGFyc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZExhYmVsIHBhcmVudCBsYWJlbFxuICogQHJldHVybnMge0FycmF5fVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGVGaWVsZHMoIGZpZWxkLCBmaWVsZExhYmVsLCBwYXJlbnRHcm91cCApIHtcblx0Y29uc3QgZmllbGRzQXJyYXkgPSBbXTtcblxuXHRsZXQgZGF5X2xhYmVsO1xuXHRpZiAoICEgXy5pc1VuZGVmaW5lZCggZmllbGQuZGF5X2xhYmVsICkgJiYgISBfLmlzRW1wdHkoIGZpZWxkLmRheV9sYWJlbCApICkge1xuXHRcdGRheV9sYWJlbCA9IGZpZWxkTGFiZWwgKyAnIC0gJyArIGZpZWxkLmRheV9sYWJlbDtcblx0fSBlbHNlIHtcblx0XHRkYXlfbGFiZWwgPSBmaWVsZExhYmVsICsgJyAtICcgKyB0cmFuc2xhdGUoICdEYXknICk7XG5cdH1cblxuXHRsZXQgbW9udGhfbGFiZWw7XG5cdGlmICggISBfLmlzVW5kZWZpbmVkKCBmaWVsZC5tb250aF9sYWJlbCApICYmICEgXy5pc0VtcHR5KCBmaWVsZC5tb250aF9sYWJlbCApICkge1xuXHRcdG1vbnRoX2xhYmVsID0gZmllbGRMYWJlbCArICcgLSAnICsgZmllbGQubW9udGhfbGFiZWw7XG5cdH0gZWxzZSB7XG5cdFx0bW9udGhfbGFiZWwgPSBmaWVsZExhYmVsICsgJyAtICcgKyB0cmFuc2xhdGUoICdNb250aCcgKTtcblx0fVxuXG5cdGxldCB5ZWFyX2xhYmVsO1xuXHRpZiAoICEgXy5pc1VuZGVmaW5lZCggZmllbGQueWVhcl9sYWJlbCApICYmICEgXy5pc0VtcHR5KCBmaWVsZC55ZWFyX2xhYmVsICkgKSB7XG5cdFx0eWVhcl9sYWJlbCA9IGZpZWxkTGFiZWwgKyAnIC0gJyArIGZpZWxkLnllYXJfbGFiZWw7XG5cdH0gZWxzZSB7XG5cdFx0eWVhcl9sYWJlbCA9IGZpZWxkTGFiZWwgKyAnIC0gJyArIHRyYW5zbGF0ZSggJ1llYXInICk7XG5cdH1cblx0aWYoIGZpZWxkLmZpZWxkX3R5cGUgPT09ICdpbnB1dCcgKXtcblx0XHRmaWVsZHNBcnJheS5wdXNoKFxuXHRcdFx0e1xuXHRcdFx0XHRlbGVtZW50X2lkOiBmaWVsZC5lbGVtZW50X2lkICsgJy1kYXknLFxuXHRcdFx0XHRwYXJlbnRfZ3JvdXA6IHBhcmVudEdyb3VwLFxuXHRcdFx0XHRyZXF1aXJlZDogZmllbGQucmVxdWlyZWQsXG5cdFx0XHRcdGZpZWxkX3R5cGU6IGZpZWxkLnR5cGUsXG5cdFx0XHRcdGZpZWxkX3NsdWc6IGZpZWxkLnR5cGUgKyAnLWRheScsXG5cdFx0XHRcdGxhYmVsOiBkYXlfbGFiZWwsXG5cdFx0XHRcdHZhbHVlczogZmFsc2UsXG5cdFx0XHRcdGhhc09wdGlvbnM6IGZhbHNlLFxuXHRcdFx0XHRpc051bWJlcjogdHJ1ZSxcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdGVsZW1lbnRfaWQ6IGZpZWxkLmVsZW1lbnRfaWQgKyAnLW1vbnRoJyxcblx0XHRcdFx0cGFyZW50X2dyb3VwOiBwYXJlbnRHcm91cCxcblx0XHRcdFx0cmVxdWlyZWQ6IGZpZWxkLnJlcXVpcmVkLFxuXHRcdFx0XHRmaWVsZF90eXBlOiBmaWVsZC50eXBlLFxuXHRcdFx0XHRmaWVsZF9zbHVnOiBmaWVsZC50eXBlICsgJy1tb250aCcsXG5cdFx0XHRcdGxhYmVsOiBtb250aF9sYWJlbCxcblx0XHRcdFx0dmFsdWVzOiBmYWxzZSxcblx0XHRcdFx0aGFzT3B0aW9uczogZmFsc2UsXG5cdFx0XHRcdGlzTnVtYmVyOiB0cnVlLFxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZWxlbWVudF9pZDogZmllbGQuZWxlbWVudF9pZCArICcteWVhcicsXG5cdFx0XHRcdHBhcmVudF9ncm91cDogcGFyZW50R3JvdXAsXG5cdFx0XHRcdHJlcXVpcmVkOiBmaWVsZC5yZXF1aXJlZCxcblx0XHRcdFx0ZmllbGRfdHlwZTogZmllbGQudHlwZSxcblx0XHRcdFx0ZmllbGRfc2x1ZzogZmllbGQudHlwZSArICcteWVhcicsXG5cdFx0XHRcdGxhYmVsOiB5ZWFyX2xhYmVsLFxuXHRcdFx0XHR2YWx1ZXM6IGZhbHNlLFxuXHRcdFx0XHRoYXNPcHRpb25zOiBmYWxzZSxcblx0XHRcdFx0aXNOdW1iZXI6IHRydWUsXG5cdFx0XHR9XG5cdFx0KTtcblx0fWVsc2V7XG5cdFx0ZmllbGRzQXJyYXkucHVzaChcblx0XHRcdHtcblx0XHRcdFx0ZWxlbWVudF9pZDogZmllbGQuZWxlbWVudF9pZCArICctZGF5Jyxcblx0XHRcdFx0cGFyZW50X2dyb3VwOiBwYXJlbnRHcm91cCxcblx0XHRcdFx0cmVxdWlyZWQ6IGZpZWxkLnJlcXVpcmVkLFxuXHRcdFx0XHRmaWVsZF90eXBlOiBmaWVsZC50eXBlLFxuXHRcdFx0XHRmaWVsZF9zbHVnOiBmaWVsZC50eXBlICsgJy1kYXknLFxuXHRcdFx0XHRsYWJlbDogZGF5X2xhYmVsLFxuXHRcdFx0XHR2YWx1ZXM6IGdldEZpZWxkVmFsdWVzKCBmaWVsZCApLFxuXHRcdFx0XHRoYXNPcHRpb25zOiBmaWVsZEhhc09wdGlvbnMoIGZpZWxkICksXG5cdFx0XHRcdGlzTnVtYmVyOiBmaWVsZEhhc051bWJlciggZmllbGQgKSxcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdGVsZW1lbnRfaWQ6IGZpZWxkLmVsZW1lbnRfaWQgKyAnLW1vbnRoJyxcblx0XHRcdFx0cGFyZW50X2dyb3VwOiBwYXJlbnRHcm91cCxcblx0XHRcdFx0cmVxdWlyZWQ6IGZpZWxkLnJlcXVpcmVkLFxuXHRcdFx0XHRmaWVsZF90eXBlOiBmaWVsZC50eXBlLFxuXHRcdFx0XHRmaWVsZF9zbHVnOiBmaWVsZC50eXBlICsgJy1tb250aCcsXG5cdFx0XHRcdGxhYmVsOiBtb250aF9sYWJlbCxcblx0XHRcdFx0dmFsdWVzOiBnZXRGaWVsZFZhbHVlcyggZmllbGQgKSxcblx0XHRcdFx0aGFzT3B0aW9uczogZmllbGRIYXNPcHRpb25zKCBmaWVsZCApLFxuXHRcdFx0XHRpc051bWJlcjogZmllbGRIYXNOdW1iZXIoIGZpZWxkICksXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRlbGVtZW50X2lkOiBmaWVsZC5lbGVtZW50X2lkICsgJy15ZWFyJyxcblx0XHRcdFx0cGFyZW50X2dyb3VwOiBwYXJlbnRHcm91cCxcblx0XHRcdFx0cmVxdWlyZWQ6IGZpZWxkLnJlcXVpcmVkLFxuXHRcdFx0XHRmaWVsZF90eXBlOiBmaWVsZC50eXBlLFxuXHRcdFx0XHRmaWVsZF9zbHVnOiBmaWVsZC50eXBlICsgJy15ZWFyJyxcblx0XHRcdFx0bGFiZWw6IHllYXJfbGFiZWwsXG5cdFx0XHRcdHZhbHVlczogZ2V0RmllbGRWYWx1ZXMoIGZpZWxkICksXG5cdFx0XHRcdGhhc09wdGlvbnM6IGZpZWxkSGFzT3B0aW9ucyggZmllbGQgKSxcblx0XHRcdFx0aXNOdW1iZXI6IGZpZWxkSGFzTnVtYmVyKCBmaWVsZCApLFxuXHRcdFx0fVxuXHRcdCk7XG5cdH1cblxuXHRyZXR1cm4gZmllbGRzQXJyYXk7XG59XG5cbi8qKlxuICogR2V0IG5hbWVfZmllbGRzIChzdXBwb3J0IG11bHRpcGxlIG5hbWUgZmllbGRzKVxuICogQHBhcmFtIHtvYmplY3R9IGZpZWxkIGZpZWxkIHRvIHBhcnNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGRMYWJlbCBwYXJlbnQgbGFiZWxcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROYW1lRmllbGRzKCBmaWVsZCwgZmllbGRMYWJlbCwgcGFyZW50R3JvdXAgKSB7XG5cdGNvbnN0IGZpZWxkc0FycmF5ID0gW107XG5cdC8vaGFuZGxlIG11bHRpcGxlIG5hbWVcblx0aWYgKCBmaWVsZC5tdWx0aXBsZV9uYW1lID09PSAndHJ1ZScgfHwgdHJ1ZSA9PT0gZmllbGQubXVsdGlwbGVfbmFtZSApIHtcblx0XHRbXG5cdFx0XHR7XG5cdFx0XHRcdGF0dHI6ICdwcmVmaXgnLFxuXHRcdFx0XHRsYWJlbDogJ3ByZWZpeF9sYWJlbCcsXG5cdFx0XHRcdGVsZW1lbnRfc3VmZml4OiAncHJlZml4Jyxcblx0XHRcdFx0aGFzT3B0aW9uczogdHJ1ZSxcblx0XHRcdFx0dmFsdWVzOiBbXG5cdFx0XHRcdFx0eyBsYWJlbDogJ01yLicsIHZhbHVlOiAnTXInIH0sXG5cdFx0XHRcdFx0eyBsYWJlbDogJ01ycy4nLCB2YWx1ZTogJ01ycycgfSxcblx0XHRcdFx0XHR7IGxhYmVsOiAnTXMuJywgdmFsdWU6ICdNcycgfSxcblx0XHRcdFx0XHR7IGxhYmVsOiAnTXguJywgdmFsdWU6ICdNeCcgfSxcblx0XHRcdFx0XHR7IGxhYmVsOiAnTWlzcycsIHZhbHVlOiAnTWlzcycgfSxcblx0XHRcdFx0XHR7IGxhYmVsOiAnRHIuJywgdmFsdWU6ICdEcicgfSxcblx0XHRcdFx0XHR7IGxhYmVsOiAnUHJvZi4nLCB2YWx1ZTogJ1Byb2YnIH0sXG5cdFx0XHRcdF0sXG5cdFx0XHRcdGlzTnVtYmVyOiBmYWxzZSxcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdGF0dHI6ICdmbmFtZScsXG5cdFx0XHRcdGxhYmVsOiAnZm5hbWVfbGFiZWwnLFxuXHRcdFx0XHRlbGVtZW50X3N1ZmZpeDogJ2ZpcnN0LW5hbWUnLFxuXHRcdFx0XHRoYXNPcHRpb25zOiBmYWxzZSxcblx0XHRcdFx0dmFsdWVzOiBmYWxzZSxcblx0XHRcdFx0aXNOdW1iZXI6IGZhbHNlLFxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0YXR0cjogJ21uYW1lJyxcblx0XHRcdFx0bGFiZWw6ICdtbmFtZV9sYWJlbCcsXG5cdFx0XHRcdGVsZW1lbnRfc3VmZml4OiAnbWlkZGxlLW5hbWUnLFxuXHRcdFx0XHRoYXNPcHRpb25zOiBmYWxzZSxcblx0XHRcdFx0dmFsdWVzOiBmYWxzZSxcblx0XHRcdFx0aXNOdW1iZXI6IGZhbHNlLFxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0YXR0cjogJ2xuYW1lJyxcblx0XHRcdFx0bGFiZWw6ICdsbmFtZV9sYWJlbCcsXG5cdFx0XHRcdGVsZW1lbnRfc3VmZml4OiAnbGFzdC1uYW1lJyxcblx0XHRcdFx0aGFzT3B0aW9uczogZmFsc2UsXG5cdFx0XHRcdHZhbHVlczogZmFsc2UsXG5cdFx0XHRcdGlzTnVtYmVyOiBmYWxzZSxcblx0XHRcdH0sXG5cdFx0XS5tYXAoIGF0dHJpYnV0ZSA9PiB7XG5cdFx0XHRpZiAoIGZpZWxkWyBhdHRyaWJ1dGUuYXR0ciBdID09PSAndHJ1ZScgfHwgZmllbGRbIGF0dHJpYnV0ZS5hdHRyIF0gPT09IHRydWUgKSB7XG5cdFx0XHRcdGxldCBsYWJlbDtcblx0XHRcdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIGZpZWxkWyBhdHRyaWJ1dGUubGFiZWwgXSApICYmICEgXy5pc0VtcHR5KCBmaWVsZFsgYXR0cmlidXRlLmxhYmVsIF0gKSApIHtcblx0XHRcdFx0XHRsYWJlbCA9IGZpZWxkTGFiZWwgKyAnIC0gJyArIGZpZWxkWyBhdHRyaWJ1dGUubGFiZWwgXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsYWJlbCA9IGZpZWxkTGFiZWwgKyAnIC0gJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZpZWxkc0FycmF5LnB1c2goIHtcblx0XHRcdFx0XHRlbGVtZW50X2lkOiBmaWVsZC5lbGVtZW50X2lkICsgJy0nICsgYXR0cmlidXRlLmVsZW1lbnRfc3VmZml4LFxuXHRcdFx0XHRcdHBhcmVudF9ncm91cDogcGFyZW50R3JvdXAsXG5cdFx0XHRcdFx0cmVxdWlyZWQ6IGZpZWxkLnJlcXVpcmVkLFxuXHRcdFx0XHRcdGZpZWxkX3R5cGU6IGZpZWxkLnR5cGUsXG5cdFx0XHRcdFx0ZmllbGRfc2x1ZzogZmllbGQudHlwZSArICctJyArIGF0dHJpYnV0ZS5lbGVtZW50X3N1ZmZpeCxcblx0XHRcdFx0XHRsYWJlbDogbGFiZWwsXG5cdFx0XHRcdFx0dmFsdWVzOiBhdHRyaWJ1dGUudmFsdWVzLFxuXHRcdFx0XHRcdGhhc09wdGlvbnM6IGF0dHJpYnV0ZS5oYXNPcHRpb25zLFxuXHRcdFx0XHRcdGlzTnVtYmVyOiBhdHRyaWJ1dGUuaXNOdW1iZXIsXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZmllbGRzQXJyYXkucHVzaCgge1xuXHRcdFx0ZWxlbWVudF9pZDogZmllbGQuZWxlbWVudF9pZCxcblx0XHRcdHBhcmVudF9ncm91cDogcGFyZW50R3JvdXAsXG5cdFx0XHRyZXF1aXJlZDogZmllbGQucmVxdWlyZWQsXG5cdFx0XHRmaWVsZF90eXBlOiBmaWVsZC50eXBlLFxuXHRcdFx0ZmllbGRfc2x1ZzogZmllbGQudHlwZSxcblx0XHRcdGxhYmVsOiBmaWVsZExhYmVsLFxuXHRcdFx0dmFsdWVzOiBnZXRGaWVsZFZhbHVlcyggZmllbGQgKSxcblx0XHRcdGhhc09wdGlvbnM6IGZpZWxkSGFzT3B0aW9ucyggZmllbGQgKSxcblx0XHRcdGlzTnVtYmVyOiBmaWVsZEhhc051bWJlciggZmllbGQgKSxcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gZmllbGRzQXJyYXk7XG59XG5cbi8qKlxuICogR2V0IFJhbmdlIFNsaWRlciBmaWVsZHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBmaWVsZCBmaWVsZCB0byBwYXJzZVxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTGFiZWwgcGFyZW50IGxhYmVsXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZ2VTbGlkZXJGaWVsZHMoIGZpZWxkLCBmaWVsZExhYmVsLCBwYXJlbnRHcm91cCApIHtcblx0Y29uc3QgZmllbGRzQXJyYXkgPSBbXTtcblx0XHRbXG5cdFx0XHR7XG5cdFx0XHRcdHN1ZmZpeDogJ21pbicsXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRzdWZmaXg6ICdtYXgnLFxuXHRcdFx0fSxcblx0XHRdLm1hcCggYXR0cmlidXRlID0+IHtcblx0XHRcdGZpZWxkc0FycmF5LnB1c2goIHtcblx0XHRcdFx0ZWxlbWVudF9pZDogZmllbGQuZWxlbWVudF9pZCArICctJyArIGF0dHJpYnV0ZS5zdWZmaXgsXG5cdFx0XHRcdHBhcmVudF9ncm91cDogcGFyZW50R3JvdXAsXG5cdFx0XHRcdHJlcXVpcmVkOiBmaWVsZC5yZXF1aXJlZCxcblx0XHRcdFx0ZmllbGRfdHlwZTogZmllbGQudHlwZSxcblx0XHRcdFx0ZmllbGRfc2x1ZzogZmllbGQudHlwZSArICctJyArIGF0dHJpYnV0ZS5zdWZmaXgsXG5cdFx0XHRcdGxhYmVsOiBmaWVsZExhYmVsICsgJyAtICcgKyBhdHRyaWJ1dGUuc3VmZml4LFxuXHRcdFx0XHRpc051bWJlcjogdHJ1ZSxcblx0XHRcdFx0aGFzQ2FsY3M6IGZpZWxkSGFzQ2FsY3MoIGZpZWxkICksXG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiBmaWVsZHNBcnJheTtcbn1cblxuLypcbiAqIFJldHVybnMgaWYgZmllbGQgaGFzIG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZmllbGRIYXNOdW1iZXIoIGZpZWxkICkge1xuXHRpZiAoIF8uY29udGFpbnMoIFsgJ2NhbGN1bGF0aW9uJywgJ251bWJlcicsICdzbGlkZXInLCAncGhvbmUnLCAnY3VycmVuY3knIF0sIGZpZWxkLnR5cGUgKSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuLypcbiAqIFJldHVybnMgaWYgZmllbGQgaGFzIGNhbGN1bGF0aW9ucyBlbmFibGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWVsZEhhc0NhbGNzKCBmaWVsZCApIHtcblx0aWYgKCBmaWVsZC5jYWxjdWxhdGlvbnMgPT09ICd0cnVlJyB8fCBmaWVsZC5jYWxjdWxhdGlvbnMgPT09IHRydWUgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWVsZEZvcm11bGEoIGZpZWxkICkge1xuXHRpZiAoIGZpZWxkLmZvcm11bGEgKSB7XG5cdFx0cmV0dXJuIGZpZWxkLmZvcm11bGE7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8qXG4gKiBSZXR1cm5zIGlmIGZpZWxkIGhhcyBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWVsZEhhc09wdGlvbnMoIGZpZWxkICkge1xuXHRpZiAoIGZpZWxkLnR5cGUgPT09ICdzZWxlY3QnIHx8IGZpZWxkLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZmllbGQudHlwZSA9PT0gJ3JhZGlvJyApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuLypcbiAqIFJldHVybnMgZmllbGQgdmFsdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZFZhbHVlcyggZmllbGQgKSB7XG5cdGNvbnN0IHR5cGUgPSBmaWVsZC50eXBlO1xuXG5cdGlmICggdHlwZSA9PT0gJ3NlbGVjdCcgfHwgdHlwZSA9PT0gJ2NoZWNrYm94JyB8fCB0eXBlID09PSAncmFkaW8nICkge1xuXHRcdHJldHVybiBmaWVsZC5vcHRpb25zO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEdldCBhZGRyZXNzX2ZpZWxkcyAoc3VwcG9ydCBtdWx0aSBzdWIgZmllbGRzKVxuICogQHBhcmFtIHtvYmplY3R9IGZpZWxkIGZpZWxkXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGRMYWJlbCBsYmVsXG4gKiBAcmV0dXJucyB7YXJyYXl9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzc0ZpZWxkcyggZmllbGQsIGZpZWxkTGFiZWwsIHBhcmVudEdyb3VwICkge1xuXHRjb25zdCBmaWVsZHNBcnJheSA9IFtdO1xuXG5cdFtcblx0XHR7XG5cdFx0XHRhdHRyOiAnc3RyZWV0X2FkZHJlc3MnLFxuXHRcdFx0bGFiZWw6ICdzdHJlZXRfYWRkcmVzc19sYWJlbCcsXG5cdFx0XHRlbGVtZW50X3N1ZmZpeDogJ3N0cmVldF9hZGRyZXNzJyxcblx0XHRcdGhhc09wdGlvbnM6IGZhbHNlLFxuXHRcdFx0dmFsdWVzOiBmYWxzZSxcblx0XHRcdGlzTnVtYmVyOiBmYWxzZSxcblx0XHR9LFxuXHRcdHtcblx0XHRcdGF0dHI6ICdhZGRyZXNzX2xpbmUnLFxuXHRcdFx0bGFiZWw6ICdhZGRyZXNzX2xpbmVfbGFiZWwnLFxuXHRcdFx0ZWxlbWVudF9zdWZmaXg6ICdhZGRyZXNzX2xpbmUnLFxuXHRcdFx0aGFzT3B0aW9uczogZmFsc2UsXG5cdFx0XHR2YWx1ZXM6IGZhbHNlLFxuXHRcdFx0aXNOdW1iZXI6IGZhbHNlLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0YXR0cjogJ2FkZHJlc3NfY2l0eScsXG5cdFx0XHRsYWJlbDogJ2FkZHJlc3NfY2l0eV9sYWJlbCcsXG5cdFx0XHRlbGVtZW50X3N1ZmZpeDogJ2NpdHknLFxuXHRcdFx0aGFzT3B0aW9uczogZmFsc2UsXG5cdFx0XHR2YWx1ZXM6IGZhbHNlLFxuXHRcdFx0aXNOdW1iZXI6IGZhbHNlLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0YXR0cjogJ2FkZHJlc3Nfc3RhdGUnLFxuXHRcdFx0bGFiZWw6ICdhZGRyZXNzX3N0YXRlX2xhYmVsJyxcblx0XHRcdGVsZW1lbnRfc3VmZml4OiAnc3RhdGUnLFxuXHRcdFx0aGFzT3B0aW9uczogZmFsc2UsXG5cdFx0XHR2YWx1ZXM6IGZhbHNlLFxuXHRcdFx0aXNOdW1iZXI6IGZhbHNlLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0YXR0cjogJ2FkZHJlc3NfemlwJyxcblx0XHRcdGxhYmVsOiAnYWRkcmVzc196aXBfbGFiZWwnLFxuXHRcdFx0ZWxlbWVudF9zdWZmaXg6ICd6aXAnLFxuXHRcdFx0aGFzT3B0aW9uczogZmFsc2UsXG5cdFx0XHR2YWx1ZXM6IGZhbHNlLFxuXHRcdFx0aXNOdW1iZXI6IGZhbHNlLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0YXR0cjogJ2FkZHJlc3NfY291bnRyeScsXG5cdFx0XHRsYWJlbDogJ2FkZHJlc3NfY291bnRyeV9sYWJlbCcsXG5cdFx0XHRlbGVtZW50X3N1ZmZpeDogJ2NvdW50cnknLFxuXHRcdFx0aGFzT3B0aW9uczogZmFsc2UsXG5cdFx0XHR2YWx1ZXM6IGZhbHNlLFxuXHRcdFx0aXNOdW1iZXI6IGZhbHNlLFxuXHRcdH0sXG5cdF0ubWFwKCBhdHRyaWJ1dGUgPT4ge1xuXHRcdGlmICggaXNUcnVlKCBmaWVsZFsgYXR0cmlidXRlLmF0dHIgXSApICkge1xuXHRcdFx0bGV0IGxhYmVsO1xuXHRcdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIGZpZWxkWyBhdHRyaWJ1dGUubGFiZWwgXSApICYmICEgXy5pc0VtcHR5KCBmaWVsZFsgYXR0cmlidXRlLmxhYmVsIF0gKSApIHtcblx0XHRcdFx0bGFiZWwgPSBmaWVsZExhYmVsICsgJyAtICcgKyBmaWVsZFsgYXR0cmlidXRlLmxhYmVsIF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsYWJlbCA9IGZpZWxkTGFiZWwgKyAnIC0gJztcblx0XHRcdH1cblxuXHRcdFx0ZmllbGRzQXJyYXkucHVzaCgge1xuXHRcdFx0XHRlbGVtZW50X2lkOiBmaWVsZC5lbGVtZW50X2lkICsgJy0nICsgYXR0cmlidXRlLmVsZW1lbnRfc3VmZml4LFxuXHRcdFx0XHRwYXJlbnRfZ3JvdXA6IHBhcmVudEdyb3VwLFxuXHRcdFx0XHRyZXF1aXJlZDogZmllbGQucmVxdWlyZWQsXG5cdFx0XHRcdGZpZWxkX3R5cGU6IGZpZWxkLnR5cGUsXG5cdFx0XHRcdGZpZWxkX3NsdWc6IGZpZWxkLnR5cGUgKyAnLScgKyBhdHRyaWJ1dGUuZWxlbWVudF9zdWZmaXgsXG5cdFx0XHRcdGxhYmVsOiBsYWJlbCxcblx0XHRcdFx0dmFsdWVzOiBhdHRyaWJ1dGUudmFsdWVzLFxuXHRcdFx0XHRoYXNPcHRpb25zOiBhdHRyaWJ1dGUuaGFzT3B0aW9ucyxcblx0XHRcdFx0aXNOdW1iZXI6IGF0dHJpYnV0ZS5pc051bWJlcixcblx0XHRcdH0gKTtcblx0XHR9XG5cdH0gKTtcblxuXHRyZXR1cm4gZmllbGRzQXJyYXk7XG59XG5cbi8qKlxuICogR2V0IHRpbWVfZmllbGRzIChzdXBwb3J0IG11bHRpIHN1YiBmaWVsZHMpXG4gKiBAcGFyYW0ge29iamVjdH0gZmllbGQgZmllbGRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZExhYmVsIGxhYmVsXG4gKiBAcmV0dXJucyB7YXJyYXl9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGltZUZpZWxkcyggZmllbGQsIGZpZWxkTGFiZWwsIHBhcmVudEdyb3VwICkge1xuXHRjb25zdCBmaWVsZHNBcnJheSA9IFtdO1xuXG5cdGxldCBoaF9sYWJlbDtcblx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIGZpZWxkLmhoX2xhYmVsICkgJiYgISBfLmlzRW1wdHkoIGZpZWxkLmhoX2xhYmVsICkgKSB7XG5cdFx0aGhfbGFiZWwgPSBmaWVsZExhYmVsICsgJyAtICcgKyBmaWVsZC5oaF9sYWJlbDtcblx0fSBlbHNlIHtcblx0XHRoaF9sYWJlbCA9IGZpZWxkTGFiZWwgKyAnIC0gJyArIHRyYW5zbGF0ZSggJ0hvdXInICk7XG5cdH1cblxuXHRsZXQgbW1fbGFiZWw7XG5cdGlmICggISBfLmlzVW5kZWZpbmVkKCBmaWVsZC5tbV9sYWJlbCApICYmICEgXy5pc0VtcHR5KCBmaWVsZC5tbV9sYWJlbCApICkge1xuXHRcdG1tX2xhYmVsID0gZmllbGRMYWJlbCArICcgLSAnICsgZmllbGQubW1fbGFiZWw7XG5cdH0gZWxzZSB7XG5cdFx0bW1fbGFiZWwgPSBmaWVsZExhYmVsICsgJyAtICcgKyB0cmFuc2xhdGUoICdNaW51dGUnICk7XG5cdH1cblxuXHRmaWVsZHNBcnJheS5wdXNoKFxuXHRcdHtcblx0XHRcdGVsZW1lbnRfaWQ6IGZpZWxkLmVsZW1lbnRfaWQgKyAnLWhvdXJzJyxcblx0XHRcdHBhcmVudF9ncm91cDogcGFyZW50R3JvdXAsXG5cdFx0XHRyZXF1aXJlZDogZmllbGQucmVxdWlyZWQsXG5cdFx0XHRmaWVsZF90eXBlOiBmaWVsZC50eXBlLFxuXHRcdFx0ZmllbGRfc2x1ZzogZmllbGQudHlwZSArICctaG91cnMnLFxuXHRcdFx0bGFiZWw6IGhoX2xhYmVsLFxuXHRcdFx0dmFsdWVzOiBmYWxzZSxcblx0XHRcdGhhc09wdGlvbnM6IGZhbHNlLFxuXHRcdFx0aXNOdW1iZXI6IHRydWUsXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRlbGVtZW50X2lkOiBmaWVsZC5lbGVtZW50X2lkICsgJy1taW51dGVzJyxcblx0XHRcdHBhcmVudF9ncm91cDogcGFyZW50R3JvdXAsXG5cdFx0XHRyZXF1aXJlZDogZmllbGQucmVxdWlyZWQsXG5cdFx0XHRmaWVsZF90eXBlOiBmaWVsZC50eXBlLFxuXHRcdFx0ZmllbGRfc2x1ZzogZmllbGQudHlwZSArICctbWludXRlcycsXG5cdFx0XHRsYWJlbDogbW1fbGFiZWwsXG5cdFx0XHR2YWx1ZXM6IGZhbHNlLFxuXHRcdFx0aGFzT3B0aW9uczogZmFsc2UsXG5cdFx0XHRpc051bWJlcjogdHJ1ZSxcblx0XHR9XG5cdCk7XG5cblx0aWYgKCBmaWVsZC50aW1lX3R5cGUgPT09ICd0d2VsdmUnICkge1xuXHRcdGZpZWxkc0FycmF5LnB1c2goIHtcblx0XHRcdGVsZW1lbnRfaWQ6IGZpZWxkLmVsZW1lbnRfaWQgKyAnLWFtcG0nLFxuXHRcdFx0cGFyZW50X2dyb3VwOiBwYXJlbnRHcm91cCxcblx0XHRcdHJlcXVpcmVkOiBmaWVsZC5yZXF1aXJlZCxcblx0XHRcdGZpZWxkX3R5cGU6IGZpZWxkLnR5cGUsXG5cdFx0XHRmaWVsZF9zbHVnOiBmaWVsZC50eXBlICsgJy1hbXBtJyxcblx0XHRcdGxhYmVsOiBmaWVsZExhYmVsICsgJy1BTS9QTScsXG5cdFx0XHR2YWx1ZXM6IFsgeyBsYWJlbDogJ0FNJywgdmFsdWU6ICdhbScgfSwgeyBsYWJlbDogJ1BNJywgdmFsdWU6ICdwbScgfSBdLFxuXHRcdFx0aGFzT3B0aW9uczogdHJ1ZSxcblx0XHRcdGlzTnVtYmVyOiBmYWxzZSxcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gZmllbGRzQXJyYXk7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZFR5cGUgZmllbGRUeXBlXG4gKiBAcmV0dXJucyB7YXJyYXl9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRBdXRvZmlsbFByb3ZpZGVycyggZmllbGRUeXBlICkge1xuXHRsZXQgYXV0b2ZpbGxQcm92aWRlcnMgPSBbXTtcblx0bGV0IGZpZWxkU2V0dGluZ3MgPSBmb3JtaW5hdG9yRGF0YS5maWVsZHMuZmlsdGVyKCBmaWVsZCA9PiB7XG5cdFx0cmV0dXJuIGZpZWxkLnR5cGUgPT09IGZpZWxkVHlwZTtcblx0fSApO1xuXG5cdGlmICggZmllbGRTZXR0aW5ncy5sZW5ndGggPCAxICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdGZpZWxkU2V0dGluZ3MgPSBmaWVsZFNldHRpbmdzWyAwIF07XG5cdGlmICggISBfLmlzVW5kZWZpbmVkKCBmaWVsZFNldHRpbmdzLmF1dG9maWxsX3NldHRpbmdzICkgKSB7XG5cdFx0YXV0b2ZpbGxQcm92aWRlcnMgPSBmaWVsZFNldHRpbmdzLmF1dG9maWxsX3NldHRpbmdzO1xuXHR9XG5cblx0cmV0dXJuIGF1dG9maWxsUHJvdmlkZXJzO1xufVxuXG4vKipcbiAqIFJldHVybnMgbGFiZWwgYnkgcnVsZSB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlIHJ1bGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHR5cGVcbiAqIEBwYXJhbSB7bWl4fSB0eXBlIHZhbHVlICggb3B0aW9uYWwgKVxuICogQHJldHVybnMge3N0cmluZ31cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdWxlTGFiZWwoIHJ1bGUsIHR5cGUgLCB2YWx1ZSApIHtcblx0bGV0IHZhbCA9ICggIV8uaXNVbmRlZmluZWQoIHZhbHVlICkgKSA/IHZhbHVlIDogJyc7XG5cdHN3aXRjaCAoIHJ1bGUgKSB7XG5cdFx0Y2FzZSAnaXMnOlxuXHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ2lzJyApO1xuXHRcdGNhc2UgJ2lzX25vdCc6XG5cdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnaXMgbm90JyApO1xuXHRcdGNhc2UgJ2RheV9pcyc6XG5cdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnZGF5IGlzJyApO1xuXHRcdGNhc2UgJ2RheV9pc19ub3QnOlxuXHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ2RheSBpcyBub3QnICk7XG5cdFx0Y2FzZSAnbW9udGhfaXNfbm90Jzpcblx0XHRcdHJldHVybiB0cmFuc2xhdGUoICdtb250aCBpcyBub3QnICk7XG5cdFx0Y2FzZSAnbW9udGhfaXMnOlxuXHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ21vbnRoIGlzJyApO1xuXHRcdGNhc2UgJ2lzX2JlZm9yZSc6XG5cdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnaXMgYmVmb3JlJyApO1xuXHRcdGNhc2UgJ2lzX2FmdGVyJzpcblx0XHRcdHJldHVybiB0cmFuc2xhdGUoICdpcyBhZnRlcicgKTtcblx0XHRjYXNlICdpc19iZWZvcmVfbl9vcl9tb3JlX2RheXMnOlxuXHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ2lzIGJlZm9yZSAlcyBvciBtb3JlIGRheXMgZnJvbSBjdXJyZW50IGRhdGUnICkucmVwbGFjZSggJyVzJywgdmFsICk7XG5cdFx0Y2FzZSAnaXNfYmVmb3JlX2xlc3NfdGhhbl9uX2RheXMnOlxuXHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ2lzIGJlZm9yZSBsZXNzIHRoYW4gJXMgZGF5cyBmcm9tIGN1cnJlbnQgZGF0ZScgKS5yZXBsYWNlKCAnJXMnLCB2YWwgKTtcblx0XHRjYXNlICdpc19hZnRlcl9uX29yX21vcmVfZGF5cyc6XG5cdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnaXMgYWZ0ZXIgJXMgb3IgbW9yZSBkYXlzIGZyb20gY3VycmVudCBkYXRlJyApLnJlcGxhY2UoICclcycsIHZhbCApO1xuXHRcdGNhc2UgJ2lzX2FmdGVyX2xlc3NfdGhhbl9uX2RheXMnOlxuXHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ2lzIGFmdGVyIGxlc3MgdGhhbiAlcyBkYXlzIGZyb20gY3VycmVudCBkYXRlJyApLnJlcGxhY2UoICclcycsIHZhbCApO1xuXHRcdGNhc2UgJ2lzX2dyZWF0Jzpcblx0XHRcdHJldHVybiB0cmFuc2xhdGUoICdpcyBncmVhdGVyIHRoYW4nICk7XG5cdFx0Y2FzZSAnaXNfbGVzcyc6XG5cdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnaXMgbGVzcyB0aGFuJyApO1xuXHRcdGNhc2UgJ2NvbnRhaW5zJzpcblx0XHRcdHJldHVybiB0cmFuc2xhdGUoICdjb250YWlucycgKTtcblx0XHRjYXNlICdzdGFydHMnOlxuXHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ3N0YXJ0cyB3aXRoJyApO1xuXHRcdGNhc2UgJ2VuZHMnOlxuXHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ2VuZHMgd2l0aCcgKTtcblx0XHRjYXNlICdpc19jb3JyZWN0Jzpcblx0XHRcdHJldHVybiB0cmFuc2xhdGUoICdpcyBjb3JyZWN0JyApO1xuXHRcdGNhc2UgJ2lzX2luY29ycmVjdCc6XG5cdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnaXMgaW5jb3JyZWN0JyApO1xuXHRcdC8vIFBlcnNvbmFsaXR5IHF1aXogcnVsZXMuXG5cdFx0Y2FzZSAnaXNfZmluYWxfcmVzdWx0Jzpcblx0XHRcdHJldHVybiB0cmFuc2xhdGUoICdpcyBmaW5hbCByZXN1bHQnICk7XG5cdFx0Y2FzZSAnaXNfbm90X2ZpbmFsX3Jlc3VsdCc6XG5cdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnaXMgbm90IGZpbmFsIHJlc3VsdCcgKTtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuICctJztcblx0fVxufVxuXG4vKipcbiAqIFJldHVybiBpZiB2YWx1ZSBpcyB2YWxpZCBlbWFpbCB3cFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB2YWx1ZSB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2x9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gaXNFbWFpbFdwKCB2YWx1ZSApIHtcblx0aWYgKCB2YWx1ZS5sZW5ndGggPCA2ICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIFRlc3QgZm9yIGFuIEAgY2hhcmFjdGVyIGFmdGVyIHRoZSBmaXJzdCBwb3NpdGlvblxuXHRpZiAoIHZhbHVlLmluZGV4T2YoICdAJywgMSApIDwgMCApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBTcGxpdCBvdXQgdGhlIGxvY2FsIGFuZCBkb21haW4gcGFydHNcblx0Y29uc3QgcGFydHMgPSB2YWx1ZS5zcGxpdCggJ0AnLCAyICk7XG5cblx0Ly8gTE9DQUwgUEFSVFxuXHQvLyBUZXN0IGZvciBpbnZhbGlkIGNoYXJhY3RlcnNcblx0aWYgKCAhIHBhcnRzWyAwIF0ubWF0Y2goIC9eW2EtekEtWjAtOSEjJCUmJyorXFwvPT9eX2B7fH1+XFwuLV0rJC8gKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBET01BSU4gUEFSVFxuXHQvLyBUZXN0IGZvciBzZXF1ZW5jZXMgb2YgcGVyaW9kc1xuXHRpZiAoIHBhcnRzWyAxIF0ubWF0Y2goIC9cXC57Mix9LyApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGNvbnN0IGRvbWFpbiA9IHBhcnRzWyAxIF07XG5cdC8vIFNwbGl0IHRoZSBkb21haW4gaW50byBzdWJzXG5cdGNvbnN0IHN1YnMgPSBkb21haW4uc3BsaXQoICcuJyApO1xuXHRpZiAoIHN1YnMubGVuZ3RoIDwgMiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRjb25zdCBzdWJzTGVuID0gc3Vicy5sZW5ndGg7XG5cdGZvciAoIGxldCBpID0gMDsgaSA8IHN1YnNMZW47IGkrKyApIHtcblx0XHQvLyBUZXN0IGZvciBpbnZhbGlkIGNoYXJhY3RlcnNcblx0XHRpZiAoICEgc3Vic1sgaSBdLm1hdGNoKCAvXlthLXowLTktXSskL2kgKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRGlzcGxheSBTVUkgSlMgRWxlbWVudHNcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWlEZWxlZ2F0ZUV2ZW50cygpIHtcblx0aWYgKCAnb2JqZWN0JyAhPT0gdHlwZW9mIHdpbmRvdy5TVUkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gVGltZSBpdCBvdXRcblx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0Ly8gUmViaW5kIEFjY29yZGlvbiBzY3JpcHRzXG5cdFx0U1VJLnN1aUFjY29yZGlvbiggalF1ZXJ5KCAnLnN1aS1hY2NvcmRpb24nICkgKTtcblxuXHRcdC8vIFJlYmluZCBUYWJzIHNjcmlwdHNcblx0XHRTVUkuc3VpVGFicyggalF1ZXJ5KCAnLnN1aS10YWJzJyApICk7XG5cblx0XHQvLyBSZWJpbmQgU2VsZWN0MiBzY3JpcHRzLlxuXHRcdGpRdWVyeSggJ3NlbGVjdC5zdWktc2VsZWN0W2RhdGEtdGhlbWU9XCJpY29uXCJdJyApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0U1VJLnNlbGVjdC5pbml0SWNvbiggalF1ZXJ5KCB0aGlzICkgKTtcblx0XHR9ICk7XG5cblx0XHRqUXVlcnkoICdzZWxlY3Quc3VpLXNlbGVjdFtkYXRhLXRoZW1lPVwiY29sb3JcIl0nICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRTVUkuc2VsZWN0LmluaXRDb2xvciggalF1ZXJ5KCB0aGlzICkgKTtcblx0XHR9ICk7XG5cblx0XHRqUXVlcnkoICdzZWxlY3Quc3VpLXNlbGVjdFtkYXRhLXRoZW1lPVwic2VhcmNoXCJdJyApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0U1VJLnNlbGVjdC5pbml0U2VhcmNoKCBqUXVlcnkoIHRoaXMgKSApO1xuXHRcdH0gKTtcblxuXHRcdGpRdWVyeSggJ3NlbGVjdC5zdWktc2VsZWN0Om5vdChbZGF0YS10aGVtZV0pOm5vdCguY3VzdG9tLXNlbGVjdDIpOm5vdCguZnVpLW11bHRpLXNlbGVjdCknICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRTVUkuc2VsZWN0LmluaXQoIGpRdWVyeSggdGhpcyApICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gUmViaW5kIFZhcmlhYmxlcyBzY3JpcHRzLlxuXHRcdGpRdWVyeSggJ3NlbGVjdC5zdWktdmFyaWFibGVzJyApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0U1VJLnNlbGVjdC5pbml0VmFycyggalF1ZXJ5KCB0aGlzICkgKTtcblx0XHR9ICk7XG5cblx0XHQvLyBSZWJpbmQgQ2lyY2xlIHNjcmlwdHNcblx0XHRTVUkubG9hZENpcmNsZVNjb3JlKCBqUXVlcnkoICcuc3VpLWNpcmNsZS1zY29yZScgKSApO1xuXG5cdFx0Ly8gUmViaW5kIFBhc3N3b3JkIHNjcmlwdHNcblx0XHRTVUkuc2hvd0hpZGVQYXNzd29yZCgpO1xuXHR9LCA1MCApO1xufVxuXG4vKipcbiAqIFJldHVybnMgY2hhcnQgdHlwZSBmcm9tIHNldHRpbmdzXG4gKlxuICogQHBhcmFtIHthcnJheX0gc2V0dGluZ3MgU2V0dGluZ3MgYXJyYXlcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENoYXJ0IHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENoYXJ0VHlwZSggc2V0dGluZ3MgKSB7XG5cdGxldCB0eXBlID0gJ25vbmUnO1xuXG5cdGlmICggdHlwZW9mIHNldHRpbmdzWyAncmVzdWx0cy1iZWhhdicgXSAmJiB0eXBlb2Ygc2V0dGluZ3NbICdyZXN1bHRzLXN0eWxlJyBdICkge1xuXHRcdGlmICggc2V0dGluZ3NbICdyZXN1bHRzLWJlaGF2JyBdID09PSAnbGlua19vbicgfHwgc2V0dGluZ3NbICdyZXN1bHRzLWJlaGF2JyBdID09PSAnc2hvd19hZnRlcicgKSB7XG5cdFx0XHR0eXBlID0gc2V0dGluZ3NbICdyZXN1bHRzLXN0eWxlJyBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0eXBlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYXJyYXkgb2YgY2FsY3VsYXRpb24gZmllbGRzXG4gKlxuICogQHBhcmFtIHthcnJheX0gd3JhcHBlcnMgY3VycmVudCB3cmFwcGVyc1xuICpcbiAqIEByZXR1cm4ge2FycmF5fVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENhbGN1bGF0aW9uRmllbGRzKCB3cmFwcGVycyApIHtcblx0Y29uc3QgZGlzYWJsZWQgPSBbXTtcblxuXHQvLyBQdXNoIGRpc2FibGVkIGZpZWxkc1xuXHRfLmVhY2goIGZvcm1pbmF0b3JEYXRhLmZpZWxkcywgZmllbGQgPT4ge1xuXHRcdGlmICggZmllbGQudHlwZSAhPT0gJ2NhbGN1bGF0aW9uJyApIHtcblx0XHRcdGRpc2FibGVkLnB1c2goIGZpZWxkLnR5cGUgKTtcblx0XHR9XG5cdH0gKTtcblxuXHRyZXR1cm4gZ2V0RmllbGRzKCB3cmFwcGVycywgZGlzYWJsZWQgKTtcbn1cblxuLyoqXG4gKiBEaXNwbGF5IFNlbGVjdDIgd2l0aCBtdWx0aXBsZSB0YWdzXG4gKlxuICogQHBhcmFtIHtqUXVlcnl9ICRlbCBqUXVlcnkgd3JhcHBlciBlbCB0byBmaW5kXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBTZWxlY3QyIG9wdGlvbnNcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3QyVGFncyggJGVsLCBvcHRpb25zICkge1xuXHRvcHRpb25zID0gXy5kZWZhdWx0cyggb3B0aW9ucywge1xuXHRcdGFsbG93Q2xlYXI6IHRydWUsXG5cdFx0ZHJvcGRvd25Dc3NDbGFzczogJ3N1aS1zZWxlY3QtZHJvcGRvd24nLFxuXHR9ICk7XG5cblx0Ly8gU0VMRUNUMiBmb3JtaW5hdG9yLXVpLXRhZ3Ncblx0JGVsLmZpbmQoICdzZWxlY3Quc3VpLXNlbGVjdC5mdWktbXVsdGktc2VsZWN0JyApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdC8vIHJlb3JkZXItc3VwcG9ydCwgaXQgd2lsbCBwcmVzZXJ2ZSBvcmRlciBiYXNlZCBvbiB1c2VyIHRhZ3MgYWRkZWRcblx0XHRpZiAoIGpRdWVyeSggdGhpcyApLmF0dHIoICdkYXRhLXJlb3JkZXInICkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5vbiggJ3NlbGVjdDI6c2VsZWN0JywgZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRcdGNvbnN0IGVsbSA9IGUucGFyYW1zLmRhdGEuZWxlbWVudCxcblx0XHRcdFx0XHQkZWxtID0galF1ZXJ5KCBlbG0gKSxcblx0XHRcdFx0XHQkdCA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHQkdC5hcHBlbmQoICRlbG0gKTtcblx0XHRcdFx0JHQudHJpZ2dlciggJ2NoYW5nZS5zZWxlY3QyJyApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRqUXVlcnkoIHRoaXMgKS5TVUlzZWxlY3QyKCBvcHRpb25zICk7XG5cdH0gKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGlmIGZpZWxkIGlzIHJlcXVpcmVkXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGZpZWxkIGZpZWxkXG4gKlxuICogQHJldHVybiB7Ym9vbH1cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpZWxkUmVxdWlyZWQoIGZpZWxkICkge1xuXHQvLyBIYW5kbGUgbmFtZSBmaWVsZCBzdWIgZmllbGRzXG5cdGlmICggZmllbGQudHlwZSA9PT0gJ25hbWUnICkge1xuXHRcdGlmICggZmllbGQubXVsdGlwbGVfbmFtZSA9PT0gJ3RydWUnIHx8IGZpZWxkLm11bHRpcGxlX25hbWUgPT09IHRydWUgKSB7XG5cdFx0XHQvLyBXZSBoYXZlIG11bHRpIGZpZWxkXG5cblx0XHRcdGlmICggZmllbGRbICdwcmVmaXhfcmVxdWlyZWQnIF0gfHxcblx0XHRcdFx0ZmllbGRbICdmbmFtZV9yZXF1aXJlZCcgXSB8fFxuXHRcdFx0XHRmaWVsZFsgJ21uYW1lX3JlcXVpcmVkJyBdIHx8XG5cdFx0XHRcdGZpZWxkWyAnbG5hbWVfcmVxdWlyZWQnIF1cblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBIYW5kbGUgbmFtZSBmaWVsZCBzdWIgZmllbGRzXG5cdGlmICggZmllbGQudHlwZSA9PT0gJ2FkZHJlc3MnICkge1xuXHRcdGlmICggZmllbGRbICdzdHJlZXRfYWRkcmVzc19yZXF1aXJlZCcgXSB8fFxuXHRcdFx0ZmllbGRbICdhZGRyZXNzX2xpbmVfcmVxdWlyZWQnIF0gfHxcblx0XHRcdGZpZWxkWyAnYWRkcmVzc19jaXR5X3JlcXVpcmVkJyBdIHx8XG5cdFx0XHRmaWVsZFsgJ2FkZHJlc3Nfc3RhdGVfcmVxdWlyZWQnIF0gfHxcblx0XHRcdGZpZWxkWyAnYWRkcmVzc196aXBfcmVxdWlyZWQnIF0gfHxcblx0XHRcdGZpZWxkWyAnYWRkcmVzc19jb3VudHJ5X3JlcXVpcmVkJyBdXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8vIEZhbGxiYWNrIHRvIGRlZmF1bHQgcmVxdWlyZWQgcHJvcFxuXHRyZXR1cm4gZmllbGQucmVxdWlyZWQ7XG59XG5cbi8qXG4gKiBSZXR1cm5zIGlmIGZvcm0gaGFzIGEgZmllbGQgd2l0aCByZXF1ZXN0ZWQgYXR0cmlidXRlIGFuZCB0aGUgcmVxdWVzdGVkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNGaWVsZFdpdGhBdHRyaWJ1dGUoIHdyYXBwZXJzLCB0eXBlLCBhdHRyaWJ1dGUsIHZhbHVlICkge1xuXHRsZXQgY291bnRlciA9IDA7XG5cblx0aWYgKCBpc0dsb2JhbFByZXNldCggd3JhcHBlcnMgKSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHdyYXBwZXJzLm1hcCggd3JhcHBlciA9PiB7XG5cdFx0d3JhcHBlci5maWVsZHMubWFwKCBmaWVsZCA9PiB7XG5cdFx0XHRpZiAoIHR5cGUgPT09IGZpZWxkLnR5cGUgJiYgdmFsdWUgPT09IGZpZWxkWyBhdHRyaWJ1dGUgXSApIHtcblx0XHRcdFx0Y291bnRlcisrO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSApO1xuXG5cdHJldHVybiBjb3VudGVyID4gMDtcbn1cblxuLypcbiAqIFJldHVybnMgaWYgZm9ybSBoYXMgYSBmaWVsZCB3aXRoIG11bHRpcGxlIGNhdGVnb3J5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNQb3N0ZGF0YUZpZWxkV2l0aE11bHRpc2VsZWN0KCB3cmFwcGVycyApIHtcblx0bGV0IGNvdW50ZXIgPSAwO1xuXG5cdGlmICggaXNHbG9iYWxQcmVzZXQoIHdyYXBwZXJzICkgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHR3cmFwcGVycy5tYXAoIHdyYXBwZXIgPT4ge1xuXHRcdHdyYXBwZXIuZmllbGRzLm1hcCggZmllbGQgPT4ge1xuXHRcdFx0Y29uc3QgcG9zdF9jYXRlZ29yeSA9IGZvcm1pbmF0b3JEYXRhLnBvc3RDYXRlZ29yaWVzWyBmaWVsZC5wb3N0X3R5cGUgXTtcblx0XHRcdGlmKCB0eXBlb2YgcG9zdF9jYXRlZ29yeSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdHBvc3RfY2F0ZWdvcnkubWFwKCBjYXRlZ29yeSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgY2F0ZWdvcnlfa2V5ID0gY2F0ZWdvcnkudmFsdWUgKyAnX211bHRpcGxlJztcblx0XHRcdFx0XHRpZiggMSA9PT0gcGFyc2VJbnQoIGZpZWxkWyBjYXRlZ29yeV9rZXkgXSApICkge1xuXHRcdFx0XHRcdFx0Y291bnRlcisrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSApO1xuXG5cdHJldHVybiBjb3VudGVyID4gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIHBlcnNvbmFsaXR5IHF1ZXN0aW9uc1xuICpcbiAqIEBwYXJhbSB7YXJyYXl9XG4gKlxuICogQHJldHVybiB7YXJyYXl9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGVyc29uYWxpdHlRdWVzdGlvbnMoIGN1cnJlbnRQZXJzb25hbGl0eSwgcXVlc3Rpb25zICkge1xuXHRjb25zdCBwZXJzb25hbGl0eVNsdWcgPSBjdXJyZW50UGVyc29uYWxpdHkuc2x1Zztcblx0bGV0IHF1ZXN0aW9uc0FycmF5ID0gW107XG5cblx0aWYgKCAhIF8uaXNFbXB0eSggcXVlc3Rpb25zICkgKSB7XG5cdFx0Xy5lYWNoKCBxdWVzdGlvbnMsIGZ1bmN0aW9uKCBxdWVzdGlvbiwga2V5UXVlc3Rpb24gKSB7XG5cdFx0XHRpZiAoICEgXy5pc0VtcHR5KCBxdWVzdGlvbi5hbnN3ZXJzICkgKSB7XG5cdFx0XHRcdF8uZWFjaCggcXVlc3Rpb24uYW5zd2VycywgZnVuY3Rpb24oIGFuc3dlciwga2V5QW5zd2VyICkge1xuXHRcdFx0XHRcdGlmICggYW5zd2VyLnJlc3VsdCA9PT0gcGVyc29uYWxpdHlTbHVnICkge1xuXHRcdFx0XHRcdFx0cXVlc3Rpb25zQXJyYXkucHVzaCgge1xuXHRcdFx0XHRcdFx0XHR0aXRsZTogcXVlc3Rpb24udGl0bGUsXG5cdFx0XHRcdFx0XHRcdHNsdWc6IHF1ZXN0aW9uLnNsdWcsXG5cdFx0XHRcdFx0XHRcdHF1ZXN0aW9uOiBxdWVzdGlvbixcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cXVlc3Rpb25zQXJyYXkgPSBfLnVuaXEoIHF1ZXN0aW9uc0FycmF5LCAnc2x1ZycgKTtcblx0fVxuXG5cdHJldHVybiBxdWVzdGlvbnNBcnJheTtcbn1cblxuLyoqXG4gKiBHZXQgcGF5bWVudCBwbGFuIHZhbGlkYXRpb25cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSB2YWxpZGF0aW9uXG4gKiBAcGFyYW0ge2FycmF5fSBwYXltZW50c1xuICpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGxhblZhbGlkYXRpb24oIHZhbGlkYXRpb24sIHBheW1lbnRzICkge1xuXG5cdGxldCBwYXltZW50SW5kZXggPSBbXTtcblxuXHRfLmVhY2goIHBheW1lbnRzLCBmdW5jdGlvbiggcGF5bWVudCwgaW5kZXggKSB7XG5cdFx0aWYgKCAhIHBheW1lbnQuYW1vdW50X3R5cGUgfHwgISBwYXltZW50LnBsYW5fbmFtZSApIHtcblx0XHRcdHZhbGlkYXRpb24uZXJyb3IgPSB0cmFuc2xhdGUoICdQbGVhc2UgZml4IHRoZSBlcnJvcihzKSBpbiB0aGUgU0VUVElOR1MgdGFiLicgKTtcblx0XHRcdHZhbGlkYXRpb24uaXNWYWxpZCA9IGZhbHNlO1xuXHRcdFx0cGF5bWVudEluZGV4LnB1c2goIGluZGV4ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAnc2luZ2xlJyA9PT0gcGF5bWVudC5wYXltZW50X21ldGhvZCAmJlxuXHRcdFx0KCAoICdmaXhlZCcgPT09IHBheW1lbnQuYW1vdW50X3R5cGUgJiYgXy5pc0VtcHR5KCBwYXltZW50LmFtb3VudCApICkgfHxcblx0XHRcdFx0KCAndmFyaWFibGUnID09PSBwYXltZW50LmFtb3VudF90eXBlICYmIF8uaXNFbXB0eSggcGF5bWVudC52YXJpYWJsZSApIClcblx0XHRcdClcblx0XHQpIHtcblx0XHRcdHZhbGlkYXRpb24uZXJyb3IgPSB0cmFuc2xhdGUoICdQbGVhc2UgZml4IHRoZSBlcnJvcihzKSBpbiB0aGUgU0VUVElOR1MgdGFiLicgKTtcblx0XHRcdHZhbGlkYXRpb24uaXNWYWxpZCA9IGZhbHNlO1xuXHRcdFx0cGF5bWVudEluZGV4LnB1c2goIGluZGV4ICk7XG5cdFx0fSBlbHNlIGlmICggJ3N1YnNjcmlwdGlvbicgPT09IHBheW1lbnQucGF5bWVudF9tZXRob2QgKSB7XG5cdFx0XHRjb25zdCBzdWJzY3JpcHRpb25BbW91bnQgPSAhIF8uaXNVbmRlZmluZWQoIHBheW1lbnQuc3Vic2NyaXB0aW9uX2Ftb3VudF90eXBlIClcblx0XHRcdFx0PyBwYXltZW50LnN1YnNjcmlwdGlvbl9hbW91bnRfdHlwZVxuXHRcdFx0XHQ6ICdmaXhlZCc7XG5cdFx0XHRjb25zdCBzdWJzY3JpcHRpb25RdWFudGl0eSA9ICEgXy5pc1VuZGVmaW5lZCggcGF5bWVudC5xdWFudGl0eV90eXBlIClcblx0XHRcdFx0PyBwYXltZW50LnF1YW50aXR5X3R5cGVcblx0XHRcdFx0OiAnZml4ZWQnO1xuXHRcdFx0Y29uc3QgUXVhbnRpdHkgPSAhIF8uaXNVbmRlZmluZWQoIHBheW1lbnQucXVhbnRpdHkgKVxuXHRcdFx0XHQ/IHBheW1lbnQucXVhbnRpdHlcblx0XHRcdFx0OiAxO1xuXHRcdFx0Y29uc3QgQmlsbElucHV0ID0gISBfLmlzVW5kZWZpbmVkKCBwYXltZW50LmJpbGxfaW5wdXQgKVxuXHRcdFx0XHQ/IHBheW1lbnQuYmlsbF9pbnB1dFxuXHRcdFx0XHQ6IDE7XG5cdFx0XHRpZiAoICggJ2ZpeGVkJyA9PT0gc3Vic2NyaXB0aW9uQW1vdW50ICYmIF8uaXNFbXB0eSggcGF5bWVudC5zdWJzY3JpcHRpb25fYW1vdW50ICkgKSB8fFxuXHRcdFx0XHQoICd2YXJpYWJsZScgPT09IHN1YnNjcmlwdGlvbkFtb3VudCAmJiBfLmlzRW1wdHkoIHBheW1lbnQuc3Vic2NyaXB0aW9uX3ZhcmlhYmxlICkgKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHZhbGlkYXRpb24uZXJyb3IgPSB0cmFuc2xhdGUoICdQbGVhc2UgZml4IHRoZSBlcnJvcihzKSBpbiB0aGUgU0VUVElOR1MgdGFiLicgKTtcblx0XHRcdFx0dmFsaWRhdGlvbi5pc1ZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdHBheW1lbnRJbmRleC5wdXNoKCBpbmRleCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoICdmaXhlZCcgPT09IHN1YnNjcmlwdGlvblF1YW50aXR5ICYmICEgUXVhbnRpdHkgKSB8fFxuXHRcdFx0XHQoICd2YXJpYWJsZScgPT09IHN1YnNjcmlwdGlvblF1YW50aXR5ICYmIF8uaXNFbXB0eSggcGF5bWVudC52YXJpYWJsZV9xdWFudGl0eSApIClcblx0XHRcdCkge1xuXHRcdFx0XHR2YWxpZGF0aW9uLmVycm9yID0gdHJhbnNsYXRlKCAnUGxlYXNlIGZpeCB0aGUgZXJyb3IocykgaW4gdGhlIFNFVFRJTkdTIHRhYi4nICk7XG5cdFx0XHRcdHZhbGlkYXRpb24uaXNWYWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRwYXltZW50SW5kZXgucHVzaCggaW5kZXggKTtcblx0XHRcdH1cblx0XHRcdGlmICggISBCaWxsSW5wdXQgKSB7XG5cdFx0XHRcdHZhbGlkYXRpb24uZXJyb3IgPSB0cmFuc2xhdGUoICdQbGVhc2UgZml4IHRoZSBlcnJvcihzKSBpbiB0aGUgU0VUVElOR1MgdGFiLicgKTtcblx0XHRcdFx0dmFsaWRhdGlvbi5pc1ZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdHBheW1lbnRJbmRleC5wdXNoKCBpbmRleCApO1xuXHRcdFx0fSBlbHNlIGlmICggQmlsbElucHV0IDw9IDAgKSB7XG5cdFx0XHRcdHZhbGlkYXRpb24uZXJyb3IgPSB0cmFuc2xhdGUoICdCaWxsaW5nIGZyZXF1ZW5jeSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnICk7XG5cdFx0XHRcdHZhbGlkYXRpb24uaXNWYWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRwYXltZW50SW5kZXgucHVzaCggaW5kZXggKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblxuXHRpZiAoIHBheW1lbnRJbmRleC5sZW5ndGggPiAwICkge1xuXHRcdHZhbGlkYXRpb24ucGF5bWVudEtleSA9IHBheW1lbnRJbmRleDtcblx0fVxuXG5cdHJldHVybiB2YWxpZGF0aW9uO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGV2YWx1YXRlcyB0byB0cnVlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKlxuICogQHJldHVybiB7Ym9vbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVHJ1ZSAoIHZhbHVlICl7XG4gICAgaWYgKCAndW5kZWZpbmVkJyA9PT0gdHlwZW9mKCB2YWx1ZSApICkge1xuXHRcdHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCAnc3RyaW5nJyA9PT0gdHlwZW9mKCB2YWx1ZSApICkge1xuICAgIFx0dmFsdWUgPSB2YWx1ZS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBzd2l0Y2goIHZhbHVlICl7XG4gICAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgY2FzZSBcInRydWVcIjpcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIFwiMVwiOlxuICAgICAgICBjYXNlIFwib25cIjpcbiAgICAgICAgY2FzZSBcInllc1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIFBhcnNlIHF1ZXJ5IHN0cmluZ1xuICogKlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZyAoKSB7XG5cdHZhciBwYXJzZWRQYXJhbWV0ZXJzID0ge30sXG5cdFx0dXJpUGFyYW1ldGVycyA9IGxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkuc3BsaXQoJyYnKTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHVyaVBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgcGFyYW1ldGVyID0gdXJpUGFyYW1ldGVyc1tpXS5zcGxpdCgnPScpO1xuXHRcdHBhcnNlZFBhcmFtZXRlcnNbcGFyYW1ldGVyWzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJhbWV0ZXJbMV0pO1xuXHR9XG5cblx0cmV0dXJuIHBhcnNlZFBhcmFtZXRlcnM7XG59XG5cbi8qKiBHbyB0byBsaW5rXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ29Ub0xpbmsgKCBsaW5rLCB0YXJnZXQgPSAnX2JsYW5rJyApIHtcblx0d2luZG93Lm9wZW4oIGxpbmssIHRhcmdldCApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzLmpzIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cblx0XHR0aGlzLnVwZGF0ZVZhbHVlID0gdGhpcy51cGRhdGVWYWx1ZS5iaW5kKCB0aGlzICk7XG5cdH1cblxuXHR1cGRhdGVWYWx1ZSggdmFsdWUgKSB7XG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgb24gZmllbGQgc2V0dGluZ3Ncblx0XHRpZiAoIHR5cGVvZiB0aGlzLnByb3BzLnVwZGF0ZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0Ly8gVXBkYXRlIGZpZWxkIHN0YXRlXG5cdFx0XHR0aGlzLnByb3BzLnVwZGF0ZVByb3BlcnR5KCB0aGlzLnByb3BzLnByb3BlcnR5LCB2YWx1ZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBVcGRhdGUgc3RvcmVcblx0XHRcdHRoaXMucHJvcHMuYWN0aW9ucy5zZXR0aW5nc0FjdGlvbnMudXBkYXRlU2V0dGluZyggdGhpcy5wcm9wcy5wcm9wZXJ0eSwgdmFsdWUgKTtcblx0XHR9XG5cdH1cblxuXHRpc1ZhbGlkKCB2YWx1ZSApIHtcblx0XHRpZiAoIHRoaXMucHJvcHMuaXNSZXF1aXJlZCApIHtcblx0XHRcdHJldHVybiB0aGlzLnByb3BzLmlzUmVxdWlyZWQgJiYgISBfLmlzRW1wdHkoIHZhbHVlICk7XG5cdFx0fSBlbHNlIGlmICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmlzUG9zaXRpdmUgKSApIHtcblx0XHRcdHJldHVybiBfLmlzRW1wdHkoIHZhbHVlICkgfHwgdmFsdWUgPj0gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCB2YWx1ZSA9IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXSApXG5cdFx0XHQ/IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlXG5cdFx0XHQ6IHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXTtcblxuXHRcdGNvbnN0IHR5cGUgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMudHlwZSApID8gdGhpcy5wcm9wcy50eXBlIDogJ3RleHQnO1xuXG5cdFx0Y29uc3QgcmVxdWlyZWRFcnJvciA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5yZXF1aXJlZEVycm9yICkgPyB0aGlzLnByb3BzLnJlcXVpcmVkRXJyb3IgOiB0cmFuc2xhdGUoICdUaGlzIGZpZWxkIGlzIHJlcXVpcmVkIScgKTtcblxuXHRcdGNvbnN0IGhhc0Vycm9yQ2xhc3MgPSAhIHRoaXMuaXNWYWxpZCggdmFsdWUgKSA/ICdzdWktZm9ybS1maWVsZC1lcnJvcicgOiAnJztcblxuXHRcdGNvbnN0IGZpZWxkQ2xhc3MgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZmllbGRDbGFzcyApXG5cdFx0XHQ/ICdzdWktZm9ybS1maWVsZCAnICsgdGhpcy5wcm9wcy5maWVsZENsYXNzXG5cdFx0XHQ6ICdzdWktZm9ybS1maWVsZCc7XG5cblx0XHRsZXQgaW5wdXRDbGFzcyA9ICdzdWktZm9ybS1jb250cm9sJztcblxuXHRcdGlmICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmlucHV0Q2xhc3MgKSAmJiAnJyAhPT0gdGhpcy5wcm9wcy5pbnB1dENsYXNzICkge1xuXHRcdFx0aW5wdXRDbGFzcyArPSAnICcgKyB0aGlzLnByb3BzLmlucHV0Q2xhc3M7XG5cdFx0fVxuXG5cdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMucHJlZml4ICkgJiYgJycgIT09IHRoaXMucHJvcHMucHJlZml4ICkge1xuXHRcdFx0aW5wdXRDbGFzcyArPSAnIHN1aS1maWVsZC1oYXMtcHJlZml4Jztcblx0XHR9XG5cblx0XHRpZiAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zdWZmaXggKSAmJiAnJyAhPT0gdGhpcy5wcm9wcy5zdWZmaXggKSB7XG5cdFx0XHRpbnB1dENsYXNzICs9ICcgc3VpLWZpZWxkLWhhcy1zdWZmaXgnO1xuXHRcdH1cblxuXHRcdGNvbnN0IGlucHV0SWQgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuaW5wdXRJZCApXG5cdFx0XHQ/IHRoaXMucHJvcHMuaW5wdXRJZFxuXHRcdFx0OiB0aGlzLnByb3BzLnByb3BlcnR5O1xuXG5cdFx0bGV0IGlucHV0TGFiZWw7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMubGFiZWwgKSB7XG5cdFx0XHRpbnB1dExhYmVsID0gKFxuXHRcdFx0XHQ8bGFiZWxcblx0XHRcdFx0XHRodG1sRm9yPXsgYGZvcm1pbmF0b3ItZmllbGQtJHsgaW5wdXRJZCB9YCB9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPXsgdGhpcy5wcm9wcy5kYXJrTGFiZWxcblx0XHRcdFx0XHRcdD8gJ3N1aS1zZXR0aW5ncy1sYWJlbCBzdWktZGFyaydcblx0XHRcdFx0XHRcdDogJ3N1aS1sYWJlbCdcblx0XHRcdFx0XHR9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMubGFiZWwgfVxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5pc1JlcXVpcmVkICYmXG5cdFx0XHRcdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdFx0XHRcdCZuYnNwOzxzcGFuIGNsYXNzTmFtZT1cInN1aS1lcnJvclwiPio8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMubm90ZSAmJlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWxhYmVsLW5vdGVcIj57IHRoaXMucHJvcHMubm90ZSB9PC9zcGFuPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5wdXRGaWVsZCA9IChcblx0XHRcdDxpbnB1dCB0eXBlPXsgdHlwZSB9XG5cdFx0XHRcdHBsYWNlaG9sZGVyPXsgdGhpcy5wcm9wcy5wbGFjZWhvbGRlciB9XG5cdFx0XHRcdHZhbHVlPXsgdmFsdWUgfHwgJycgfVxuXHRcdFx0XHRpZD17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IGlucHV0SWQgfWAgfVxuXHRcdFx0XHRjbGFzc05hbWU9eyBpbnB1dENsYXNzIH1cblx0XHRcdFx0eyAuLi4gdGhpcy5wcm9wcy5ub3RXcml0YWJsZSAmJiB7IHJlYWRvbmx5OiAnJyB9IH1cblx0XHRcdFx0eyAuLi4gdGhpcy5wcm9wcy5taW5WYWx1ZSAmJiB7IG1pbjogdGhpcy5wcm9wcy5taW5WYWx1ZSB9IH1cblx0XHRcdFx0eyAuLi4gdGhpcy5wcm9wcy5tYXhWYWx1ZSAmJiB7IG1heDogdGhpcy5wcm9wcy5tYXhWYWx1ZSB9IH1cblx0XHRcdFx0eyAuLi4gdGhpcy5wcm9wcy5zdGVwICYmIHsgc3RlcDogdGhpcy5wcm9wcy5zdGVwIH0gfVxuXHRcdFx0XHR7IC4uLiB0aGlzLnByb3BzLm1heExlbmd0aCAmJiB7IG1heExlbmd0aDogdGhpcy5wcm9wcy5tYXhMZW5ndGggfSB9XG5cdFx0XHRcdHsgLi4uIHRoaXMucHJvcHMuaW5wdXRTdHlsZXMgJiYgeyBzdHlsZTogdGhpcy5wcm9wcy5pbnB1dFN0eWxlcyB9IH1cblx0XHRcdFx0ZGlzYWJsZWQ9eyB0aGlzLnByb3BzLmRpc2FibGVkID8gdHJ1ZSA6IGZhbHNlIH1cblx0XHRcdFx0b25DaGFuZ2U9eyBlID0+IHtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZVZhbHVlKCBlLnRhcmdldC52YWx1ZSApO1xuXHRcdFx0XHR9IH1cblx0XHRcdC8+XG5cdFx0KTtcblxuXHRcdGNvbnN0IGdldEZpZWxkcyA9IChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPXsgYCR7IGZpZWxkQ2xhc3MgfSAkeyBoYXNFcnJvckNsYXNzIH1gIH0+XG5cdFx0XHRcdHsgaW5wdXRMYWJlbCB9XG5cdFx0XHRcdHsgKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMucHJlZml4ICkgJiYgJycgIT09IHRoaXMucHJvcHMucHJlZml4ICkgJiYgKFxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1maWVsZC1wcmVmaXhcIj57IHRoaXMucHJvcHMucHJlZml4IH08L3NwYW4+XG5cdFx0XHRcdCkgfVxuXHRcdFx0XHR7ICggISB0aGlzLnByb3BzLmNhblRyYXNoXG5cdFx0XHRcdFx0PyBpbnB1dEZpZWxkXG5cdFx0XHRcdFx0OiA8ZGl2IGNsYXNzTmFtZT1cInN1aS13aXRoLWJ1dHRvbiBzdWktd2l0aC1idXR0b24taWNvblwiPlxuXHRcdFx0XHRcdFx0eyBpbnB1dEZpZWxkIH1cblx0XHRcdFx0XHRcdDxidXR0b24gY2xhc3NOYW1lPVwic3VpLWJ1dHRvbi1pY29uIHN1aS10b29sdGlwIHN1aS10b29sdGlwLXRvcC1yaWdodFwiXG5cdFx0XHRcdFx0XHRcdGRhdGEtdG9vbHRpcD17IHRyYW5zbGF0ZSggJ0RlbGV0ZScgKSB9PlxuXHRcdFx0XHRcdFx0XHQ8aSBjbGFzc05hbWU9XCJzdWktaWNvbi10cmFzaFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG5cdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0KSB9XG5cdFx0XHRcdHsgdGhpcy5wcm9wcy5zdWZmaXggJiYgKFxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1maWVsZC1zdWZmaXhcIj57IHRoaXMucHJvcHMuc3VmZml4IH08L3NwYW4+XG5cdFx0XHRcdCkgfVxuXHRcdFx0XHR7IHRoaXMucHJvcHMuaXNSZXF1aXJlZCAmJiAhIHRoaXMuaXNWYWxpZCggdmFsdWUgKSAmJiAoXG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWVycm9yLW1lc3NhZ2VcIj57IHJlcXVpcmVkRXJyb3IgfTwvc3Bhbj5cblx0XHRcdFx0KSB9XG5cdFx0XHRcdHsgISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmlzUG9zaXRpdmUgKSAmJiAhIHRoaXMuaXNWYWxpZCggdmFsdWUgKSAmJiAoXG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWVycm9yLW1lc3NhZ2VcIj57IHRyYW5zbGF0ZSggJ1BsZWFzZSBlbnRlciB2YWxpZCBudW1iZXIuJyApIH08L3NwYW4+XG5cdFx0XHRcdCkgfVxuXHRcdFx0XHR7IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gJiYgKFxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPnsgdGhpcy5wcm9wcy5kZXNjcmlwdGlvbiB9PC9zcGFuPlxuXHRcdFx0XHQpIH1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMuc2ltcGxlICkge1xuXHRcdFx0cmV0dXJuIGlucHV0RmllbGQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdldEZpZWxkcztcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzL2lucHV0cy9pbnB1dC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRhaW5lciBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLm1hcCggdGhpcy5wcm9wcy5jaGlsZHJlbiwgY2hpbGQgPT4ge1xuXHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdH0gKTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2PlxuXHRcdFx0XHR7IGNoaWxkcmVuIH1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9jb250YWluZXJzL2NvbnRhaW5lci5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbCBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLm1hcCggdGhpcy5wcm9wcy5jaGlsZHJlbiwgY2hpbGRyZW4gPT4ge1xuXHRcdFx0cmV0dXJuIGNoaWxkcmVuO1xuXHRcdH0gKTtcblxuXHRcdGNvbnN0IGN1c3RvbUNsYXNzID0gdGhpcy5wcm9wcy5jdXN0b21DbGFzcyA/IHRoaXMucHJvcHMuY3VzdG9tQ2xhc3MgOiAnJztcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT17IGBzdWktY29sLW1kLSR7IHRoaXMucHJvcHMuY29scyB9ICR7IGN1c3RvbUNsYXNzIH1gIH0+XG5cdFx0XHRcdHsgY2hpbGRyZW4gfVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzL2NvbnRhaW5lcnMvY29sLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sb3JQaWNrZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cblx0XHR0aGlzLnVwZGF0ZVZhbHVlID0gdGhpcy51cGRhdGVWYWx1ZS5iaW5kKCB0aGlzICk7XG5cdH1cblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLiRlbCA9IGpRdWVyeSggdGhpcy5lbCApO1xuXHRcdHRoaXMuJGVsLndwQ29sb3JQaWNrZXIoIHtcblx0XHRcdGNoYW5nZTogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcblx0XHRcdFx0Y29uc3QgJHRoaXMgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0JHRoaXMudmFsKCB1aS5jb2xvci50b0NTUygpICkudHJpZ2dlciggJ2NoYW5nZScgKTtcblx0XHRcdH0sXG5cdFx0XHRwYWxldHRlczogW1xuXHRcdFx0XHQnIzMzMzMzMycsXG5cdFx0XHRcdCcjRkZGRkZGJyxcblx0XHRcdFx0JyMxN0E4RTMnLFxuXHRcdFx0XHQnI0UxRjZGRicsXG5cdFx0XHRcdCcjNjY2NjY2Jyxcblx0XHRcdFx0JyNBQUFBQUEnLFxuXHRcdFx0XHQnI0U2RTZFNicsXG5cdFx0XHRdLFxuXHRcdH0gKTtcblxuXHRcdGNvbnN0ICRzdWlQaWNrZXJJbnB1dCA9IHRoaXMuJGVsLFxuXHRcdFx0JHN1aVBpY2tlciA9ICRzdWlQaWNrZXJJbnB1dC5jbG9zZXN0KCAnLnN1aS1jb2xvcnBpY2tlci13cmFwJyApLFxuXHRcdFx0JHN1aVBpY2tlckNvbG9yID0gJHN1aVBpY2tlci5maW5kKCAnLnN1aS1jb2xvcnBpY2tlci12YWx1ZSBzcGFuW3JvbGU9YnV0dG9uXScgKSxcblx0XHRcdCRzdWlQaWNrZXJWYWx1ZSA9ICRzdWlQaWNrZXIuZmluZCggJy5zdWktY29sb3JwaWNrZXItdmFsdWUnICksXG5cdFx0XHQkc3VpUGlja2VyQ2xlYXIgPSAkc3VpUGlja2VyVmFsdWUuZmluZCggJ2J1dHRvbicgKVxuXHRcdDtcblxuXHRcdGNvbnN0ICR3cFBpY2tlciA9ICRzdWlQaWNrZXJJbnB1dC5jbG9zZXN0KCAnLndwLXBpY2tlci1jb250YWluZXInICksXG5cdFx0XHQkd3BQaWNrZXJCdXR0b24gPSAkd3BQaWNrZXIuZmluZCggJy53cC1jb2xvci1yZXN1bHQnICksXG5cdFx0XHQkd3BQaWNrZXJBbHBoYSA9ICR3cFBpY2tlckJ1dHRvbi5maW5kKCAnLmNvbG9yLWFscGhhJyApLFxuXHRcdFx0JHdwUGlja2VyQ2xlYXIgPSAkd3BQaWNrZXIuZmluZCggJy53cC1waWNrZXItY2xlYXInIClcblx0XHQ7XG5cblx0XHRsZXQgJHBpY2tlckJhY2tncm91bmQgPSAkd3BQaWNrZXJBbHBoYTtcblxuXHRcdC8vIENoZWNrIGlmIGFscGhhIGV4aXN0c1xuXHRcdGlmICggJHN1aVBpY2tlcklucHV0LmRhdGEoICdhbHBoYScgKSA9PT0gdHJ1ZSApIHtcblx0XHRcdCRwaWNrZXJCYWNrZ3JvdW5kID0gJHdwUGlja2VyQWxwaGE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCRwaWNrZXJCYWNrZ3JvdW5kID0gJHdwUGlja2VyQnV0dG9uO1xuXHRcdH1cblxuXHRcdC8vIExpc3RlbiB0byBjb2xvciBjaGFuZ2Vcblx0XHQkc3VpUGlja2VySW5wdXQuYmluZCggJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gQ2hhbmdlIGNvbG9yIHByZXZpZXdcblx0XHRcdCRzdWlQaWNrZXJDb2xvci5maW5kKCAnc3BhbicgKS5jc3MoIHtcblx0XHRcdFx0J2JhY2tncm91bmQtY29sb3InOiAkcGlja2VyQmFja2dyb3VuZC5jc3MoICdiYWNrZ3JvdW5kLWNvbG9yJyApLFxuXHRcdFx0fSApO1xuXG5cdFx0XHQvLyBDaGFuZ2UgY29sb3IgdmFsdWVcblx0XHRcdCRzdWlQaWNrZXJWYWx1ZS5maW5kKCAnaW5wdXQnICkudmFsKCAkc3VpUGlja2VySW5wdXQudmFsKCkgKTtcblx0XHR9ICk7XG5cblx0XHQvLyBPcGVuIGlyaXMgcGlja2VyXG5cdFx0JHN1aVBpY2tlci5maW5kKCAnLnN1aS1idXR0b24sIHNwYW5bcm9sZT1idXR0b25dJyApLm9uKCAnY2xpY2snLCBmdW5jdGlvbiggZSApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHQkd3BQaWNrZXJCdXR0b24uY2xpY2soKTtcblx0XHR9ICk7XG5cblx0XHQvLyBDbGVhciBjb2xvciB2YWx1ZVxuXHRcdCRzdWlQaWNrZXJDbGVhci5vbiggJ2NsaWNrJywgZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0XHQkd3BQaWNrZXJDbGVhci5jbGljaygpO1xuXHRcdFx0JHN1aVBpY2tlclZhbHVlLmZpbmQoICdpbnB1dCcgKS52YWwoICcnICk7XG5cdFx0XHQkc3VpUGlja2VyQ29sb3IuZmluZCggJ3NwYW4nICkuY3NzKCB7XG5cdFx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzogJycsXG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXG5cdFx0dGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUuYmluZCggdGhpcyApO1xuXHRcdHRoaXMuJGVsLm9uKCAnY2hhbmdlJywgdGhpcy51cGRhdGVWYWx1ZSApO1xuXHR9XG5cblx0dXBkYXRlVmFsdWUoIGUgKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIG9uIGZpZWxkIHNldHRpbmdzXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5wcm9wcy51cGRhdGVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdC8vIFVwZGF0ZSBmaWVsZCBzdGF0ZVxuXHRcdFx0dGhpcy5wcm9wcy51cGRhdGVQcm9wZXJ0eShcblx0XHRcdFx0dGhpcy5wcm9wcy5wcm9wZXJ0eSxcblx0XHRcdFx0dmFsdWVcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFVwZGF0ZSBzdG9yZVxuXHRcdFx0dGhpcy5wcm9wcy5hY3Rpb25zLnNldHRpbmdzQWN0aW9ucy51cGRhdGVTZXR0aW5nKCB0aGlzLnByb3BzLnByb3BlcnR5LCB2YWx1ZSApO1xuXHRcdH1cblx0fVxuXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdHRoaXMuJGVsLm9mZiggJ2NoYW5nZScsIHRoaXMudXBkYXRlVmFsdWUgKTtcblx0XHR0aGlzLiRlbC51bmJpbmQoKS5yZW1vdmVEYXRhKCk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSAoIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXSApIHx8IHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXSA9PT0gbnVsbCApXG5cdFx0XHQ/IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlXG5cdFx0XHQ6IHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXTtcblxuXHRcdGxldCBmaWVsZExhYmVsID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMubGFiZWwgKSB7XG5cdFx0XHRmaWVsZExhYmVsID0gKFxuXHRcdFx0XHQ8bGFiZWwgY2xhc3NOYW1lPVwic3VpLWxhYmVsXCJcblx0XHRcdFx0XHRodG1sRm9yPXsgYGZvcm1pbmF0b3ItY29sb3ItJHsgdGhpcy5wcm9wcy5wcm9wZXJ0eSB9YCB9PlxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5sYWJlbCB9XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLm5vdGUgJiZcblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1sYWJlbC1ub3RlXCI+IHsgdGhpcy5wcm9wcy5ub3RlIH08L3NwYW4+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQ8L2xhYmVsPlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktZm9ybS1maWVsZFwiPlxuXHRcdFx0XHR7IGZpZWxkTGFiZWwgfVxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1jb2xvcnBpY2tlci13cmFwXCI+XG5cdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXsgYHN1aS1jb2xvcnBpY2tlciBzdWktY29sb3JwaWNrZXItJHsgdGhpcy5wcm9wcy5pc0FscGhhXG5cdFx0XHRcdFx0XHRcdD8gJ3JnYmEnXG5cdFx0XHRcdFx0XHRcdDogJ2hleCdcblx0XHRcdFx0XHRcdH1gIH1cblx0XHRcdFx0XHRcdGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktY29sb3JwaWNrZXItdmFsdWVcIj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gcm9sZT1cImJ1dHRvblwiPlxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuIHN0eWxlPXsgeyBiYWNrZ3JvdW5kQ29sb3I6IHZhbHVlIH0gfT48L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGVmYXVsdFZhbHVlPXsgdmFsdWUgfVxuXHRcdFx0XHRcdFx0XHRcdHJlYWRPbmx5PVwicmVhZG9ubHlcIiAvPlxuXHRcdFx0XHRcdFx0XHQ8YnV0dG9uPlxuXHRcdFx0XHRcdFx0XHRcdDxpIGNsYXNzTmFtZT1cInN1aS1pY29uLWNsb3NlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuXHRcdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PGJ1dHRvbiBjbGFzc05hbWU9XCJzdWktYnV0dG9uXCI+eyB0cmFuc2xhdGUoICdTZWxlY3QnICkgfTwvYnV0dG9uPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxpbnB1dCByZWY9eyBlbCA9PiAoIHRoaXMuZWwgPSBlbCApIH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17IHZhbHVlIH1cblx0XHRcdFx0XHRcdGlkPXsgYGZvcm1pbmF0b3ItY29sb3ItJHsgdGhpcy5wcm9wcy5wcm9wZXJ0eSB9YCB9XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktY29sb3JwaWNrZXItaW5wdXRcIlxuXHRcdFx0XHRcdFx0ZGF0YS1hbHBoYT17IHRoaXMucHJvcHMuaXNBbHBoYSA/ICd0cnVlJyA6ICdmYWxzZScgfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHR7ICggdGhpcy5wcm9wcy5kZXNjcmlwdGlvbiAmJiAnJyAhPT0gdGhpcy5wcm9wcy5kZXNjcmlwdGlvbiApICYmIChcblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj57IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gfTwvc3Bhbj5cblx0XHRcdFx0KSB9XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MvaW5wdXRzL2NvbG9yLXBpY2tlci5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGlvVGFicyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHRvZ2dsZVZhbHVlKCB2YWx1ZSApIHtcblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBvbiBmaWVsZCBzZXR0aW5nc1xuXHRcdGlmICggdHlwZW9mIHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHQvLyBVcGRhdGUgZmllbGQgc3RhdGVcblx0XHRcdHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkoXG5cdFx0XHRcdHRoaXMucHJvcHMucHJvcGVydHksXG5cdFx0XHRcdHZhbHVlXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBVcGRhdGUgc3RvcmVcblx0XHRcdHRoaXMucHJvcHMuYWN0aW9ucy5zZXR0aW5nc0FjdGlvbnMudXBkYXRlU2V0dGluZyggdGhpcy5wcm9wcy5wcm9wZXJ0eSwgdmFsdWUgKTtcblx0XHR9XG5cdH1cblxuXHRnZXREZWZhdWx0VmFsdWUoKSB7XG5cdFx0Y29uc3QgZGVmYXVsdFZhbHVlID0gdGhpcy5wcm9wcy5kZWZhdWx0ID8gdGhpcy5wcm9wcy5kZWZhdWx0IDogJyc7XG5cblx0XHRjb25zdCB2YWx1ZSA9IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXSApXG5cdFx0XHQ/IGRlZmF1bHRWYWx1ZVxuXHRcdFx0OiB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF07XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSB0aGlzLmdldERlZmF1bHRWYWx1ZSgpO1xuXG5cdFx0Y29uc3QgdGFiVGl0bGVzID0gUmVhY3QuQ2hpbGRyZW4ubWFwKCB0aGlzLnByb3BzLmNoaWxkcmVuLCB0YWIgPT4ge1xuXHRcdFx0aWYgKCAhIHRhYiApIHtcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHQ8UmVhY3QuRnJhZ21lbnQgLz5cblx0XHRcdFx0KVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBsYWJlbCA9ICEgXy5pc1VuZGVmaW5lZCggdGFiLnByb3BzLmxhYmVsIClcblx0XHRcdFx0PyB0YWIucHJvcHMubGFiZWxcblx0XHRcdFx0OiB0YWIucHJvcHMuY2hpbGRyZW47XG5cblx0XHRcdGlmICggdGhpcy5wcm9wcy5kaXNhYmxlZCApIHtcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17ICdzdWktdGFiLWl0ZW0nICsgKCB0YWIucHJvcHMudmFsdWUgPT09IHZhbHVlID8gJyBhY3RpdmUnIDogJycgKSB9XG5cdFx0XHRcdFx0XHRzdHlsZT17IHtcblx0XHRcdFx0XHRcdFx0b3BhY2l0eTogMC41LFxuXHRcdFx0XHRcdFx0XHRjdXJzb3I6ICdub3QtYWxsb3dlZCcsXG5cdFx0XHRcdFx0XHR9IH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IGxhYmVsIH1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIHRoaXMucHJvcHMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9eyAnc3VpLXRhYi1pdGVtJyArICggdGFiLnByb3BzLnZhbHVlID09PSB2YWx1ZSA/ICcgYWN0aXZlJyA6ICcnICkgfVxuXHRcdFx0XHRcdFx0b25DbGljaz17IHRoaXMudG9nZ2xlVmFsdWUuYmluZCggdGhpcywgdGFiLnByb3BzLnZhbHVlICkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgbGFiZWwgfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IGNvbnRlbnRDbGFzcyA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5kaXZDbGFzcyApXG5cdFx0XHQ/ICdzdWktdGFicy1jb250ZW50ICcgKyB0aGlzLnByb3BzLmRpdkNsYXNzXG5cdFx0XHQ6ICdzdWktdGFicy1jb250ZW50JztcblxuXHRcdGNvbnN0IHRhYkNvbnRlbnRzID0gUmVhY3QuQ2hpbGRyZW4ubWFwKCB0aGlzLnByb3BzLmNoaWxkcmVuLCB0YWIgPT4ge1xuXHRcdFx0aWYgKCAhIHRhYiApIHtcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHQ8UmVhY3QuRnJhZ21lbnQgLz5cblx0XHRcdFx0KVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBib3hDbGFzcyA9ICEgXy5pc1VuZGVmaW5lZCggdGFiLnByb3BzLmJveENsYXNzIClcblx0XHRcdFx0PyB0YWIucHJvcHMuYm94Q2xhc3Ncblx0XHRcdFx0OiAnJztcblxuXHRcdFx0aWYgKCB0YWIudHlwZS5uYW1lICE9PSAnRW1wdHknICkge1xuXHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXtcblx0XHRcdFx0XHRcdGJveENsYXNzICsgJyBzdWktdGFiLWNvbnRlbnQnICsgKCB0YWIucHJvcHMudmFsdWUgPT09IHZhbHVlID8gJyBhY3RpdmUnIDogJycgKVxuXHRcdFx0XHRcdH0+XG5cdFx0XHRcdFx0XHR7IHRhYi5wcm9wcy52YWx1ZSA9PT0gdmFsdWUgJiYgdGFiIH1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PFJlYWN0LkZyYWdtZW50IC8+XG5cdFx0XHQpO1xuXHRcdH0gKTtcblxuXHRcdGxldCB0YWJzTGFiZWwgPSAnJztcblxuXHRcdGlmICggdGhpcy5wcm9wcy5sYWJlbCAmJiAnJyAhPT0gdGhpcy5wcm9wcy5sYWJlbCApIHtcblx0XHRcdHRhYnNMYWJlbCA9IChcblx0XHRcdFx0PGxhYmVsIGh0bWxGb3I9eyBgZm9ybWluYXRvci1maWVsZC0keyB0aGlzLnByb3BzLnByb3BlcnR5IH1gIH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktbGFiZWxcIj5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMubGFiZWwgfVxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5ub3RlICYmXG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktbGFiZWwtbm90ZVwiPiB7IHRoaXMucHJvcHMubm90ZSB9PC9zcGFuPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0bGV0IHNldHRpbmdzTGFiZWwgPSAnJztcblxuXHRcdGlmICggdGhpcy5wcm9wcy5zZXR0aW5nc0xhYmVsICYmICcnICE9PSB0aGlzLnByb3BzLnNldHRpbmdzTGFiZWwgKSB7XG5cdFx0XHRjb25zdCBsYWJlbENsYXNzID0gdGhpcy5wcm9wcy5sYWJlbENsYXNzID8gdGhpcy5wcm9wcy5sYWJlbENsYXNzIDogJ3N1aS1zZXR0aW5ncy1sYWJlbCc7XG5cdFx0XHRzZXR0aW5nc0xhYmVsID0gKFxuXHRcdFx0XHQ8bGFiZWwgY2xhc3NOYW1lPXsgbGFiZWxDbGFzcyB9PlxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5zZXR0aW5nc0xhYmVsIH1cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0bGV0IGRlc2NyaXB0aW9uID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMuZGVzY3JpcHRpb24gJiYgJycgIT09IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gKSB7XG5cdFx0XHRkZXNjcmlwdGlvbiA9IChcblx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIlxuXHRcdFx0XHRcdHN0eWxlPXsgeyBtYXJnaW5Cb3R0b206IDEwIH0gfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmRlc2NyaXB0aW9uIH1cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRsZXQgd3JhcHBlckNsYXNzID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLndyYXBwZXJDbGFzcyApXG5cdFx0XHQ/IHRoaXMucHJvcHMud3JhcHBlckNsYXNzXG5cdFx0XHQ6ICcnO1xuXG5cdFx0d3JhcHBlckNsYXNzID0gdGhpcy5wcm9wcy5iYXNpY1RhYnNcblx0XHRcdD8gYHN1aS10YWJzIHN1aS10YWJzLW92ZXJmbG93ICR7IHdyYXBwZXJDbGFzcyB9YFxuXHRcdFx0OiBgc3VpLXNpZGUtdGFicyAkeyB3cmFwcGVyQ2xhc3MgfWA7XG5cblx0XHRsZXQgdGFic01hcmt1cCA9IChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPXsgd3JhcHBlckNsYXNzIH0+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktdGFicy1tZW51XCI+XG5cdFx0XHRcdFx0eyB0YWJUaXRsZXMgfVxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17IGNvbnRlbnRDbGFzcyB9PlxuXHRcdFx0XHRcdHsgdGFiQ29udGVudHMgfVxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblxuXHRcdGlmICggISB0aGlzLnByb3BzLnNpbXBsZSApIHtcblx0XHRcdHRhYnNNYXJrdXAgPSAoXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGRcIj5cblxuXHRcdFx0XHRcdHsgc2V0dGluZ3NMYWJlbCB9XG5cblx0XHRcdFx0XHR7IHRhYnNMYWJlbCB9XG5cblx0XHRcdFx0XHR7IGRlc2NyaXB0aW9uIH1cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXsgd3JhcHBlckNsYXNzIH0+XG5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLXRhYnMtbWVudVwiPlxuXHRcdFx0XHRcdFx0XHR7IHRhYlRpdGxlcyB9XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9eyBjb250ZW50Q2xhc3MgfT5cblx0XHRcdFx0XHRcdFx0eyB0YWJDb250ZW50cyB9XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGFic01hcmt1cDtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzL2lucHV0cy9yYWRpby10YWJzLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm93IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNvbHVtbnMgPSBSZWFjdC5DaGlsZHJlbi5tYXAoXG5cdFx0XHR0aGlzLnByb3BzLmNoaWxkcmVuLFxuXHRcdFx0Y2hpbGRyZW4gPT4ge1xuXHRcdFx0XHRyZXR1cm4gY2hpbGRyZW47XG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT17ICdzdWktcm93JyArICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmNsYXNzIClcblx0XHRcdFx0PyAnICcgKyB0aGlzLnByb3BzLmNsYXNzXG5cdFx0XHRcdDogJydcblx0XHRcdCkgfT5cblx0XHRcdFx0eyBjb2x1bW5zIH1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9jb250YWluZXJzL3Jvdy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy5zdGF0ZSA9IHtcblx0XHRcdGFjdGl2ZTogdGhpcy5wcm9wcy5kZWZhdWx0ID8gdGhpcy5wcm9wcy5kZWZhdWx0IDogJycsXG5cdFx0fTtcblx0fVxuXG5cdHRvZ2dsZVZhbHVlKCB2YWx1ZSApIHtcblx0XHR0aGlzLnNldFN0YXRlKCB7XG5cdFx0XHRhY3RpdmU6IHZhbHVlLFxuXHRcdH0gKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLnByb3BzLmRlZmF1bHQgPyB0aGlzLnByb3BzLmRlZmF1bHQgOiAnJztcblxuXHRcdGNvbnN0IHR5cGUgPSB0aGlzLnByb3BzLnR5cGUgPyB0aGlzLnByb3BzLnR5cGUgOiAnc2lkZS10YWJzJztcblxuXHRcdGNvbnN0IGV4dHJhQ2xhc3MgPSB0aGlzLnByb3BzLmV4dHJhQ2xhc3MgPyB0aGlzLnByb3BzLmV4dHJhQ2xhc3MgOiAnJztcblxuXHRcdGNvbnN0IHRhYlRpdGxlcyA9IFJlYWN0LkNoaWxkcmVuLm1hcCggdGhpcy5wcm9wcy5jaGlsZHJlbiwgdGFiID0+IHtcblx0XHRcdGlmICggXy5pc1VuZGVmaW5lZCggdGFiICkgfHwgXy5pc051bGwoIHRhYiApICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRjbGFzc05hbWU9eyAnZm9ybWluYXRvci10b2dnbGUgc3VpLXRhYi1pdGVtJyArIChcblx0XHRcdFx0XHRcdHRhYi5wcm9wcy52YWx1ZSA9PT0gdGhpcy5zdGF0ZS5hY3RpdmUgPyAnIGFjdGl2ZScgOiAnJ1xuXHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLnRvZ2dsZVZhbHVlLmJpbmQoIHRoaXMsIHRhYi5wcm9wcy52YWx1ZSApIH1cblx0XHRcdFx0PlxuXHRcdFx0XHRcdHsgdGFiLnByb3BzLmxhYmVsIH0geyB0YWIucHJvcHMucmVxdWlyZWQgJiZcblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1lcnJvclwiPio8L3NwYW4+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdCk7XG5cdFx0fSApO1xuXG5cdFx0Y29uc3QgdGFiQ29udGVudHMgPSBSZWFjdC5DaGlsZHJlbi5tYXAoIHRoaXMucHJvcHMuY2hpbGRyZW4sIHRhYiA9PiB7XG5cdFx0XHRpZiAoIF8uaXNVbmRlZmluZWQoIHRhYiApIHx8IF8uaXNOdWxsKCB0YWIgKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBib3hDbGFzc1ZhbHVlID0gISBfLmlzVW5kZWZpbmVkKCB0YWIucHJvcHMuYm94Q2xhc3MgKSA/XG5cdFx0XHRcdHRhYi5wcm9wcy5ib3hDbGFzcyA6ICdzdWktdGFiLWNvbnRlbnQnO1xuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17IGJveENsYXNzVmFsdWUgKyAoIHRhYi5wcm9wcy52YWx1ZSA9PT0gdGhpcy5zdGF0ZS5hY3RpdmUgPyAnIGFjdGl2ZScgOiAnJyApIH0+XG5cdFx0XHRcdFx0eyB0YWIucHJvcHMudmFsdWUgPT09IHRoaXMuc3RhdGUuYWN0aXZlICYmIHRhYiB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9eyBgc3VpLSR7IHR5cGUgfSAkeyBleHRyYUNsYXNzIH1gIH0+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLXRhYnMtbWVudVwiPlxuXHRcdFx0XHRcdHsgdGFiVGl0bGVzIH1cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktdGFicy1jb250ZW50XCI+XG5cdFx0XHRcdFx0eyB0YWJDb250ZW50cyB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzL2NvbnRhaW5lcnMvdGFicy5qcyIsImltcG9ydCAkJG9ic2VydmFibGUgZnJvbSAnc3ltYm9sLW9ic2VydmFibGUnO1xuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xudmFyIEFjdGlvblR5cGVzID0ge1xuICBJTklUOiAnQEByZWR1eC9JTklUJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpLFxuICBSRVBMQUNFOiAnQEByZWR1eC9SRVBMQUNFJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpXG59O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG9iaiBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYXJndW1lbnQgYXBwZWFycyB0byBiZSBhIHBsYWluIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgaWYgKCh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIHByb3RvID0gb2JqO1xuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gKiBUaGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZSBkYXRhIGluIHRoZSBzdG9yZSBpcyB0byBjYWxsIGBkaXNwYXRjaCgpYCBvbiBpdC5cbiAqXG4gKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gKiBwYXJ0cyBvZiB0aGUgc3RhdGUgdHJlZSByZXNwb25kIHRvIGFjdGlvbnMsIHlvdSBtYXkgY29tYmluZSBzZXZlcmFsIHJlZHVjZXJzXG4gKiBpbnRvIGEgc2luZ2xlIHJlZHVjZXIgZnVuY3Rpb24gYnkgdXNpbmcgYGNvbWJpbmVSZWR1Y2Vyc2AuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVkdWNlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSB0cmVlLCBnaXZlblxuICogdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGFjdGlvbiB0byBoYW5kbGUuXG4gKlxuICogQHBhcmFtIHthbnl9IFtwcmVsb2FkZWRTdGF0ZV0gVGhlIGluaXRpYWwgc3RhdGUuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBoeWRyYXRlIHRoZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYVxuICogcHJldmlvdXNseSBzZXJpYWxpemVkIHVzZXIgc2Vzc2lvbi5cbiAqIElmIHlvdSB1c2UgYGNvbWJpbmVSZWR1Y2Vyc2AgdG8gcHJvZHVjZSB0aGUgcm9vdCByZWR1Y2VyIGZ1bmN0aW9uLCB0aGlzIG11c3QgYmVcbiAqIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGBjb21iaW5lUmVkdWNlcnNgIGtleXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2VuaGFuY2VyXSBUaGUgc3RvcmUgZW5oYW5jZXIuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXG4gKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gKiBpcyBgYXBwbHlNaWRkbGV3YXJlKClgLlxuICpcbiAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gKiBhbmQgc3Vic2NyaWJlIHRvIGNoYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICB2YXIgX3JlZjI7XG5cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50U3RhdGUgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgdmFyIGN1cnJlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICB2YXIgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbWF5IG5vdCBjYWxsIHN0b3JlLmdldFN0YXRlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ1RoZSByZWR1Y2VyIGhhcyBhbHJlYWR5IHJlY2VpdmVkIHRoZSBzdGF0ZSBhcyBhbiBhcmd1bWVudC4gJyArICdQYXNzIGl0IGRvd24gZnJvbSB0aGUgdG9wIHJlZHVjZXIgaW5zdGVhZCBvZiByZWFkaW5nIGl0IGZyb20gdGhlIHN0b3JlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNoYW5nZSBsaXN0ZW5lci4gSXQgd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQsXG4gICAqIGFuZCBzb21lIHBhcnQgb2YgdGhlIHN0YXRlIHRyZWUgbWF5IHBvdGVudGlhbGx5IGhhdmUgY2hhbmdlZC4gWW91IG1heSB0aGVuXG4gICAqIGNhbGwgYGdldFN0YXRlKClgIHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBpbnNpZGUgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBZb3UgbWF5IGNhbGwgYGRpc3BhdGNoKClgIGZyb20gYSBjaGFuZ2UgbGlzdGVuZXIsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBjYXZlYXRzOlxuICAgKlxuICAgKiAxLiBUaGUgc3Vic2NyaXB0aW9ucyBhcmUgc25hcHNob3R0ZWQganVzdCBiZWZvcmUgZXZlcnkgYGRpc3BhdGNoKClgIGNhbGwuXG4gICAqIElmIHlvdSBzdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgd2hpbGUgdGhlIGxpc3RlbmVycyBhcmUgYmVpbmcgaW52b2tlZCwgdGhpc1xuICAgKiB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGBkaXNwYXRjaCgpYCB0aGF0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cbiAgICogSG93ZXZlciwgdGhlIG5leHQgYGRpc3BhdGNoKClgIGNhbGwsIHdoZXRoZXIgbmVzdGVkIG9yIG5vdCwgd2lsbCB1c2UgYSBtb3JlXG4gICAqIHJlY2VudCBzbmFwc2hvdCBvZiB0aGUgc3Vic2NyaXB0aW9uIGxpc3QuXG4gICAqXG4gICAqIDIuIFRoZSBsaXN0ZW5lciBzaG91bGQgbm90IGV4cGVjdCB0byBzZWUgYWxsIHN0YXRlIGNoYW5nZXMsIGFzIHRoZSBzdGF0ZVxuICAgKiBtaWdodCBoYXZlIGJlZW4gdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBuZXN0ZWQgYGRpc3BhdGNoKClgIGJlZm9yZVxuICAgKiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLiBJdCBpcywgaG93ZXZlciwgZ3VhcmFudGVlZCB0aGF0IGFsbCBzdWJzY3JpYmVyc1xuICAgKiByZWdpc3RlcmVkIGJlZm9yZSB0aGUgYGRpc3BhdGNoKClgIHN0YXJ0ZWQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgbGF0ZXN0XG4gICAqIHN0YXRlIGJ5IHRoZSB0aW1lIGl0IGV4aXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZXZlcnkgZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyBjaGFuZ2UgbGlzdGVuZXIuXG4gICAqL1xuICBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtYXkgbm90IGNhbGwgc3RvcmUuc3Vic2NyaWJlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ0lmIHlvdSB3b3VsZCBsaWtlIHRvIGJlIG5vdGlmaWVkIGFmdGVyIHRoZSBzdG9yZSBoYXMgYmVlbiB1cGRhdGVkLCBzdWJzY3JpYmUgZnJvbSBhICcgKyAnY29tcG9uZW50IGFuZCBpbnZva2Ugc3RvcmUuZ2V0U3RhdGUoKSBpbiB0aGUgY2FsbGJhY2sgdG8gYWNjZXNzIHRoZSBsYXRlc3Qgc3RhdGUuICcgKyAnU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS1yZWZlcmVuY2Uvc3RvcmUjc3Vic2NyaWJlKGxpc3RlbmVyKSBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuXG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG1heSBub3QgdW5zdWJzY3JpYmUgZnJvbSBhIHN0b3JlIGxpc3RlbmVyIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gJyArICdTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpLXJlZmVyZW5jZS9zdG9yZSNzdWJzY3JpYmUobGlzdGVuZXIpIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuXG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuICcgKyAnVXNlIGN1c3RvbSBtaWRkbGV3YXJlIGZvciBhc3luYyBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gJyArICdIYXZlIHlvdSBtaXNzcGVsbGVkIGEgY29uc3RhbnQ/Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyO1xuICAgIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuUkVQTEFDRSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIF9yZWYgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKCh0eXBlb2Ygb2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9ic2VydmVyKSkgIT09ICdvYmplY3QnIHx8IG9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHsgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlIH07XG4gICAgICB9XG4gICAgfSwgX3JlZlskJG9ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgX3JlZjtcbiAgfVxuXG4gIC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG5cbiAgcmV0dXJuIF9yZWYyID0ge1xuICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXG4gICAgcmVwbGFjZVJlZHVjZXI6IHJlcGxhY2VSZWR1Y2VyXG4gIH0sIF9yZWYyWyQkb2JzZXJ2YWJsZV0gPSBvYnNlcnZhYmxlLCBfcmVmMjtcbn1cblxuLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG59XG5cbmZ1bmN0aW9uIGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKGtleSwgYWN0aW9uKSB7XG4gIHZhciBhY3Rpb25UeXBlID0gYWN0aW9uICYmIGFjdGlvbi50eXBlO1xuICB2YXIgYWN0aW9uRGVzY3JpcHRpb24gPSBhY3Rpb25UeXBlICYmICdhY3Rpb24gXCInICsgU3RyaW5nKGFjdGlvblR5cGUpICsgJ1wiJyB8fCAnYW4gYWN0aW9uJztcblxuICByZXR1cm4gJ0dpdmVuICcgKyBhY3Rpb25EZXNjcmlwdGlvbiArICcsIHJlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZC4gJyArICdUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuICcgKyAnSWYgeW91IHdhbnQgdGhpcyByZWR1Y2VyIHRvIGhvbGQgbm8gdmFsdWUsIHlvdSBjYW4gcmV0dXJuIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuJztcbn1cblxuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgYXJndW1lbnROYW1lID0gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBBY3Rpb25UeXBlcy5JTklUID8gJ3ByZWxvYWRlZFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuICdUaGUgJyArIGFyZ3VtZW50TmFtZSArICcgaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcIicgKyB7fS50b1N0cmluZy5jYWxsKGlucHV0U3RhdGUpLm1hdGNoKC9cXHMoW2EtenxBLVpdKykvKVsxXSArICdcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyAnICsgKCdrZXlzOiBcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIicpO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldO1xuICB9KTtcblxuICB1bmV4cGVjdGVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSA9IHRydWU7XG4gIH0pO1xuXG4gIGlmIChhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IEFjdGlvblR5cGVzLlJFUExBQ0UpIHJldHVybjtcblxuICBpZiAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiAnVW5leHBlY3RlZCAnICsgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDEgPyAna2V5cycgOiAna2V5JykgKyAnICcgKyAoJ1wiJyArIHVuZXhwZWN0ZWRLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiIGZvdW5kIGluICcgKyBhcmd1bWVudE5hbWUgKyAnLiAnKSArICdFeHBlY3RlZCB0byBmaW5kIG9uZSBvZiB0aGUga25vd24gcmVkdWNlciBrZXlzIGluc3RlYWQ6ICcgKyAoJ1wiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiLiBVbmV4cGVjdGVkIGtleXMgd2lsbCBiZSBpZ25vcmVkLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlZHVjZXJTaGFwZShyZWR1Y2Vycykge1xuICBPYmplY3Qua2V5cyhyZWR1Y2VycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHJlZHVjZXIgPSByZWR1Y2Vyc1trZXldO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uICcgKyAnSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0ICcgKyAnZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSAnICsgJ25vdCBiZSB1bmRlZmluZWQuIElmIHlvdSBkb25cXCd0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgJyArICd5b3UgY2FuIHVzZSBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLicpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gJ0BAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT05fJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xuICAgIGlmICh0eXBlb2YgcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogdHlwZSB9KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gJyArICgnRG9uXFwndCB0cnkgdG8gaGFuZGxlICcgKyBBY3Rpb25UeXBlcy5JTklUICsgJyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiICcpICsgJ25hbWVzcGFjZS4gVGhleSBhcmUgY29uc2lkZXJlZCBwcml2YXRlLiBJbnN0ZWFkLCB5b3UgbXVzdCByZXR1cm4gdGhlICcgKyAnY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgJyArICdpbiB3aGljaCBjYXNlIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZSwgcmVnYXJkbGVzcyBvZiB0aGUgJyArICdhY3Rpb24gdHlwZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQsIGJ1dCBjYW4gYmUgbnVsbC4nKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGRpZmZlcmVudCByZWR1Y2VyIGZ1bmN0aW9ucywgaW50byBhIHNpbmdsZVxuICogcmVkdWNlciBmdW5jdGlvbi4gSXQgd2lsbCBjYWxsIGV2ZXJ5IGNoaWxkIHJlZHVjZXIsIGFuZCBnYXRoZXIgdGhlaXIgcmVzdWx0c1xuICogaW50byBhIHNpbmdsZSBzdGF0ZSBvYmplY3QsIHdob3NlIGtleXMgY29ycmVzcG9uZCB0byB0aGUga2V5cyBvZiB0aGUgcGFzc2VkXG4gKiByZWR1Y2VyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVkdWNlcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBjb3JyZXNwb25kIHRvIGRpZmZlcmVudFxuICogcmVkdWNlciBmdW5jdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNvbWJpbmVkIGludG8gb25lLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpblxuICogaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXMgcmVkdWNlcnNgIHN5bnRheC4gVGhlIHJlZHVjZXJzIG1heSBuZXZlciByZXR1cm5cbiAqIHVuZGVmaW5lZCBmb3IgYW55IGFjdGlvbi4gSW5zdGVhZCwgdGhleSBzaG91bGQgcmV0dXJuIHRoZWlyIGluaXRpYWwgc3RhdGVcbiAqIGlmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlbSB3YXMgdW5kZWZpbmVkLCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueVxuICogdW5yZWNvZ25pemVkIGFjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgZXZlcnkgcmVkdWNlciBpbnNpZGUgdGhlXG4gKiBwYXNzZWQgb2JqZWN0LCBhbmQgYnVpbGRzIGEgc3RhdGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2Vycykge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBmaW5hbFJlZHVjZXJzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gcmVkdWNlcktleXNbaV07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKCdObyByZWR1Y2VyIHByb3ZpZGVkIGZvciBrZXkgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmaW5hbFJlZHVjZXJzW2tleV0gPSByZWR1Y2Vyc1trZXldO1xuICAgIH1cbiAgfVxuICB2YXIgZmluYWxSZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKGZpbmFsUmVkdWNlcnMpO1xuXG4gIHZhciB1bmV4cGVjdGVkS2V5Q2FjaGUgPSB2b2lkIDA7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlID0ge307XG4gIH1cblxuICB2YXIgc2hhcGVBc3NlcnRpb25FcnJvciA9IHZvaWQgMDtcbiAgdHJ5IHtcbiAgICBhc3NlcnRSZWR1Y2VyU2hhcGUoZmluYWxSZWR1Y2Vycyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzaGFwZUFzc2VydGlvbkVycm9yID0gZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHNbMV07XG5cbiAgICBpZiAoc2hhcGVBc3NlcnRpb25FcnJvcikge1xuICAgICAgdGhyb3cgc2hhcGVBc3NlcnRpb25FcnJvcjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHdhcm5pbmdNZXNzYWdlID0gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShzdGF0ZSwgZmluYWxSZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpO1xuICAgICAgaWYgKHdhcm5pbmdNZXNzYWdlKSB7XG4gICAgICAgIHdhcm5pbmcod2FybmluZ01lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHt9O1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9rZXkgPSBmaW5hbFJlZHVjZXJLZXlzW19pXTtcbiAgICAgIHZhciByZWR1Y2VyID0gZmluYWxSZWR1Y2Vyc1tfa2V5XTtcbiAgICAgIHZhciBwcmV2aW91c1N0YXRlRm9yS2V5ID0gc3RhdGVbX2tleV07XG4gICAgICB2YXIgbmV4dFN0YXRlRm9yS2V5ID0gcmVkdWNlcihwcmV2aW91c1N0YXRlRm9yS2V5LCBhY3Rpb24pO1xuICAgICAgaWYgKHR5cGVvZiBuZXh0U3RhdGVGb3JLZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShfa2V5LCBhY3Rpb24pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIG5leHRTdGF0ZVtfa2V5XSA9IG5leHRTdGF0ZUZvcktleTtcbiAgICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZUZvcktleSAhPT0gcHJldmlvdXNTdGF0ZUZvcktleTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0NoYW5nZWQgPyBuZXh0U3RhdGUgOiBzdGF0ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZnVuY3Rpb24gaW4gcmV0dXJuLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBhY3Rpb25DcmVhdG9ycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb25cbiAqIGNyZWF0b3IgZnVuY3Rpb25zLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpbiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhc2BcbiAqIHN5bnRheC4gWW91IG1heSBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcGF0Y2ggVGhlIGBkaXNwYXRjaGAgZnVuY3Rpb24gYXZhaWxhYmxlIG9uIHlvdXIgUmVkdXhcbiAqIHN0b3JlLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFRoZSBvYmplY3QgbWltaWNraW5nIHRoZSBvcmlnaW5hbCBvYmplY3QsIGJ1dCB3aXRoXG4gKiBldmVyeSBhY3Rpb24gY3JlYXRvciB3cmFwcGVkIGludG8gdGhlIGBkaXNwYXRjaGAgY2FsbC4gSWYgeW91IHBhc3NlZCBhXG4gKiBmdW5jdGlvbiBhcyBgYWN0aW9uQ3JlYXRvcnNgLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYWxzbyBiZSBhIHNpbmdsZVxuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG5cbiAgaWYgKCh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGFjdGlvbkNyZWF0b3JzKSkgIT09ICdvYmplY3QnIHx8IGFjdGlvbkNyZWF0b3JzID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGluc3RlYWQgcmVjZWl2ZWQgJyArIChhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYWN0aW9uQ3JlYXRvcnMpKSArICcuICcgKyAnRGlkIHlvdSB3cml0ZSBcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXCIgaW5zdGVhZCBvZiBcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cIj8nKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWN0aW9uQ3JlYXRvcnMpO1xuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG4vKipcbiAqIENvbXBvc2VzIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LiBUaGUgcmlnaHRtb3N0XG4gKiBmdW5jdGlvbiBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMgYXMgaXQgcHJvdmlkZXMgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIHRoZSByZXN1bHRpbmcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiBvYnRhaW5lZCBieSBjb21wb3NpbmcgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uc1xuICogZnJvbSByaWdodCB0byBsZWZ0LiBGb3IgZXhhbXBsZSwgY29tcG9zZShmLCBnLCBoKSBpcyBpZGVudGljYWwgdG8gZG9pbmdcbiAqICguLi5hcmdzKSA9PiBmKGcoaCguLi5hcmdzKSkpLlxuICovXG5cbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmNzWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmNzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYShiLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0b3JlIGVuaGFuY2VyIHRoYXQgYXBwbGllcyBtaWRkbGV3YXJlIHRvIHRoZSBkaXNwYXRjaCBtZXRob2RcbiAqIG9mIHRoZSBSZWR1eCBzdG9yZS4gVGhpcyBpcyBoYW5keSBmb3IgYSB2YXJpZXR5IG9mIHRhc2tzLCBzdWNoIGFzIGV4cHJlc3NpbmdcbiAqIGFzeW5jaHJvbm91cyBhY3Rpb25zIGluIGEgY29uY2lzZSBtYW5uZXIsIG9yIGxvZ2dpbmcgZXZlcnkgYWN0aW9uIHBheWxvYWQuXG4gKlxuICogU2VlIGByZWR1eC10aHVua2AgcGFja2FnZSBhcyBhbiBleGFtcGxlIG9mIHRoZSBSZWR1eCBtaWRkbGV3YXJlLlxuICpcbiAqIEJlY2F1c2UgbWlkZGxld2FyZSBpcyBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMsIHRoaXMgc2hvdWxkIGJlIHRoZSBmaXJzdFxuICogc3RvcmUgZW5oYW5jZXIgaW4gdGhlIGNvbXBvc2l0aW9uIGNoYWluLlxuICpcbiAqIE5vdGUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgd2lsbCBiZSBnaXZlbiB0aGUgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBmdW5jdGlvbnNcbiAqIGFzIG5hbWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBtaWRkbGV3YXJlcyBUaGUgbWlkZGxld2FyZSBjaGFpbiB0byBiZSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHN0b3JlIGVuaGFuY2VyIGFwcGx5aW5nIHRoZSBtaWRkbGV3YXJlLlxuICovXG5mdW5jdGlvbiBhcHBseU1pZGRsZXdhcmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtaWRkbGV3YXJlcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjcmVhdGVTdG9yZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICB2YXIgX2Rpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGlzcGF0Y2hpbmcgd2hpbGUgY29uc3RydWN0aW5nIHlvdXIgbWlkZGxld2FyZSBpcyBub3QgYWxsb3dlZC4gJyArICdPdGhlciBtaWRkbGV3YXJlIHdvdWxkIG5vdCBiZSBhcHBsaWVkIHRvIHRoaXMgZGlzcGF0Y2guJyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gICAgICAgICAgcmV0dXJuIF9kaXNwYXRjaC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSk7XG4gICAgICB9KTtcbiAgICAgIF9kaXNwYXRjaCA9IGNvbXBvc2UuYXBwbHkodW5kZWZpbmVkLCBjaGFpbikoc3RvcmUuZGlzcGF0Y2gpO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0b3JlLCB7XG4gICAgICAgIGRpc3BhdGNoOiBfZGlzcGF0Y2hcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG59XG5cbi8qXG4gKiBUaGlzIGlzIGEgZHVtbXkgZnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIGZ1bmN0aW9uIG5hbWUgaGFzIGJlZW4gYWx0ZXJlZCBieSBtaW5pZmljYXRpb24uXG4gKiBJZiB0aGUgZnVuY3Rpb24gaGFzIGJlZW4gbWluaWZpZWQgYW5kIE5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsIHdhcm4gdGhlIHVzZXIuXG4gKi9cbmZ1bmN0aW9uIGlzQ3J1c2hlZCgpIHt9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XG4gIHdhcm5pbmcoXCJZb3UgYXJlIGN1cnJlbnRseSB1c2luZyBtaW5pZmllZCBjb2RlIG91dHNpZGUgb2YgTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJy4gXCIgKyAnVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gJyArICdZb3UgY2FuIHVzZSBsb29zZS1lbnZpZnkgKGh0dHBzOi8vZ2l0aHViLmNvbS96ZXJ0b3NoL2xvb3NlLWVudmlmeSkgZm9yIGJyb3dzZXJpZnkgJyArICdvciBEZWZpbmVQbHVnaW4gZm9yIHdlYnBhY2sgKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzAwMzAwMzEpICcgKyAndG8gZW5zdXJlIHlvdSBoYXZlIHRoZSBjb3JyZWN0IGNvZGUgZm9yIHlvdXIgcHJvZHVjdGlvbiBidWlsZC4nKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RvcmUsIGNvbWJpbmVSZWR1Y2VycywgYmluZEFjdGlvbkNyZWF0b3JzLCBhcHBseU1pZGRsZXdhcmUsIGNvbXBvc2UsIEFjdGlvblR5cGVzIGFzIF9fRE9fTk9UX1VTRV9fQWN0aW9uVHlwZXMgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL3JlZHV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEVtcHR5KCkge1xuXHRyZXR1cm4gJyc7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MvY29udGFpbmVycy9lbXB0eS5qcyIsImltcG9ydCBQcm92aWRlciwgeyBjcmVhdGVQcm92aWRlciB9IGZyb20gJy4vY29tcG9uZW50cy9Qcm92aWRlcic7XG5pbXBvcnQgY29ubmVjdEFkdmFuY2VkIGZyb20gJy4vY29tcG9uZW50cy9jb25uZWN0QWR2YW5jZWQnO1xuaW1wb3J0IGNvbm5lY3QgZnJvbSAnLi9jb25uZWN0L2Nvbm5lY3QnO1xuXG5leHBvcnQgeyBQcm92aWRlciwgY3JlYXRlUHJvdmlkZXIsIGNvbm5lY3RBZHZhbmNlZCwgY29ubmVjdCB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIGlzQnVmZmVyID0gcmVxdWlyZSgnaXMtYnVmZmVyJyk7XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH0pXG4gICAgICApO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2V0dGluZ3NSb3cgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY29udGVudCA9IFJlYWN0LkNoaWxkcmVuLm1hcChcblx0XHRcdHRoaXMucHJvcHMuY2hpbGRyZW4sXG5cdFx0XHRjaGlsZHJlbiA9PiB7XG5cdFx0XHRcdHJldHVybiBjaGlsZHJlbjtcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0bGV0IGxhYmVsID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMubGFiZWwgJiYgJycgIT09IHRoaXMucHJvcHMubGFiZWwgKSB7XG5cdFx0XHRsYWJlbCA9IChcblx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPXtcblx0XHRcdFx0XHQnc3VpLXNldHRpbmdzLWxhYmVsJyArXG5cdFx0XHRcdFx0YCR7IHRoaXMucHJvcHMubGFiZWxEYXJrID09PSB0cnVlID8gJyBzdWktZGFyaycgOiAnJyB9YFxuXHRcdFx0XHR9PlxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5sYWJlbCB9XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0bGV0IGRlc2NyaXB0aW9uID0gJyc7XG5cdFx0bGV0IGRlc2NyaXB0aW9uU3BhY2luZyA9IDEwO1xuXG5cdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZGVzY3JpcHRpb25TcGFjaW5nICkgJiYgJycgIT09IHRoaXMucHJvcHMuZGVzY3JpcHRpb25TcGFjaW5nICkge1xuXHRcdFx0ZGVzY3JpcHRpb25TcGFjaW5nID0gdGhpcy5wcm9wcy5kZXNjcmlwdGlvblNwYWNpbmc7XG5cdFx0fVxuXG5cdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZGVzY3JpcHRpb24gKSAmJiAnJyAhPT0gdGhpcy5wcm9wcy5kZXNjcmlwdGlvbiApIHtcblx0XHRcdGlmICggdGhpcy5wcm9wcy5zaWRlYmFyID09PSBmYWxzZSApIHtcblx0XHRcdFx0ZGVzY3JpcHRpb24gPSAoXG5cdFx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiXG5cdFx0XHRcdFx0XHRzdHlsZT17IHsgbWFyZ2luQm90dG9tOiBkZXNjcmlwdGlvblNwYWNpbmcgKyAncHgnIH0gfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5kZXNjcmlwdGlvbiB9XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVzY3JpcHRpb24gPSAoXG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCI+eyB0aGlzLnByb3BzLmRlc2NyaXB0aW9uIH08L3NwYW4+XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHNpZGViYXIgPSAnJztcblxuXHRcdGlmIChcblx0XHRcdCggdGhpcy5wcm9wcy5sYWJlbCAmJiAnJyAhPT0gdGhpcy5wcm9wcy5sYWJlbCApIHx8XG5cdFx0XHQoIHRoaXMucHJvcHMuZGVzY3JpcHRpb24gJiYgJycgIT09IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gKVxuXHRcdCkge1xuXHRcdFx0c2lkZWJhciA9IChcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0xXCI+XG5cdFx0XHRcdFx0eyBsYWJlbCB9XG5cdFx0XHRcdFx0eyBkZXNjcmlwdGlvbiB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRjb25zdCBjb25kaXRpb25hbFN0eWxlcyA9IHRoaXMucHJvcHMubGFzdENoaWxkXG5cdFx0XHQ/IHsgbWFyZ2luQm90dG9tOiAwLCBib3JkZXJCb3R0b206ICd1bnNldCcgfVxuXHRcdFx0OiB7fTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3Mtcm93XCIgc3R5bGU9eyBjb25kaXRpb25hbFN0eWxlcyB9PlxuXHRcdFx0XHR7ICggXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zaWRlYmFyICkgfHwgdGhpcy5wcm9wcy5zaWRlYmFyICE9PSBmYWxzZSApICYmXG5cdFx0XHRcdFx0c2lkZWJhclxuXHRcdFx0XHR9XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMlwiPlxuXHRcdFx0XHRcdHsgKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2lkZWJhciApICYmIHRoaXMucHJvcHMuc2lkZWJhciA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRcdFx0bGFiZWxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0eyAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zaWRlYmFyICkgJiYgdGhpcy5wcm9wcy5zaWRlYmFyID09PSBmYWxzZSApICYmXG5cdFx0XHRcdFx0XHRkZXNjcmlwdGlvblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR7IGNvbnRlbnQgfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9jb250YWluZXJzL3NldHRpbmdzLXJvdy5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1aVNlbGVjdDIgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cblx0XHR0aGlzLnVwZGF0ZVZhbHVlID0gdGhpcy51cGRhdGVWYWx1ZS5iaW5kKCB0aGlzICk7XG5cdFx0dGhpcy5hZnRlclNhdmUgPSB0aGlzLmFmdGVyU2F2ZS5iaW5kKCB0aGlzICk7XG5cdH1cblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLiRlbCA9IGpRdWVyeSggdGhpcy5lbCApO1xuXG5cdFx0Y29uc3QgcGFyZW50ID0gdGhpcy4kZWwuY2xvc2VzdCggJy5zdWktbW9kYWwtY29udGVudCcgKTtcblx0XHRjb25zdCBwYXJlbnRJZCA9IHBhcmVudC5hdHRyKCAnaWQnICk7XG5cdFx0Y29uc3QgaGFzU2VhcmNoID0gdGhpcy5wcm9wcy5oYXNTZWFyY2ggPyAwIDogLTE7XG5cblx0XHRjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihcblx0XHRcdHtcblx0XHRcdFx0ZHJvcGRvd25QYXJlbnQ6ICggcGFyZW50Lmxlbmd0aCApXG5cdFx0XHRcdFx0PyBqUXVlcnkoICcjJyArIHBhcmVudElkIClcblx0XHRcdFx0XHQ6IGpRdWVyeSggJ2JvZHlbY2xhc3MqPVwic3VpLVwiXScgKSxcblx0XHRcdFx0bWluaW11bVJlc3VsdHNGb3JTZWFyY2g6IGhhc1NlYXJjaCxcblx0XHRcdFx0ZHJvcGRvd25Dc3NDbGFzczogdGhpcy4kZWwuaGFzQ2xhc3MoICdzdWktc2VsZWN0LXNtJyApXG5cdFx0XHRcdFx0PyAnc3VpLXNlbGVjdC1kcm9wZG93bi1zbSdcblx0XHRcdFx0XHQ6ICcnLFxuXHRcdFx0XHR3aWR0aDogJzEwMCUnLFxuXHRcdFx0fSxcblx0XHRcdHRoaXMucHJvcHMub3B0aW9uc1xuXHRcdCk7XG5cblx0XHRpZiAoIHR5cGVvZiB0aGlzLiRlbC5TVUlzZWxlY3QyID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0dGhpcy4kZWwuU1VJc2VsZWN0Miggb3B0aW9ucyApO1xuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB0aGlzLiRlbC5GVUlzZWxlY3QyID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0dGhpcy4kZWwuRlVJc2VsZWN0Miggb3B0aW9ucyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBFcnJvciggJ1NVSSBTZWxlY3QyIG5vdCBpbml0aWF0ZWQnICk7XG5cdFx0fVxuXG5cdFx0dGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUuYmluZCggdGhpcyApO1xuXHRcdHRoaXMuJGVsLm9uKCAnY2hhbmdlJywgdGhpcy51cGRhdGVWYWx1ZSApO1xuXG5cdFx0aWYgKCB0aGlzLnByb3BzLnRyaWdnZXJDaGFuZ2UgKSB7XG5cdFx0XHR0aGlzLiRlbC50cmlnZ2VyKCAnY2hhbmdlJyApO1xuXHRcdH1cblx0fVxuXG5cdHVwZGF0ZVZhbHVlKCBlICkge1xuXHRcdGNvbnN0IHZhbHVlID0galF1ZXJ5KCBlLnRhcmdldCApLnZhbCgpO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgb24gZmllbGQgc2V0dGluZ3Ncblx0XHRpZiAoIHR5cGVvZiB0aGlzLnByb3BzLnVwZGF0ZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0Ly8gVXBkYXRlIGZpZWxkIHN0YXRlXG5cdFx0XHR0aGlzLnByb3BzLnVwZGF0ZVByb3BlcnR5KCB0aGlzLnByb3BzLnByb3BlcnR5LCB2YWx1ZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBVcGRhdGUgc3RvcmVcblx0XHRcdHRoaXMucHJvcHMuYWN0aW9ucy5zZXR0aW5nc0FjdGlvbnMudXBkYXRlU2V0dGluZyggdGhpcy5wcm9wcy5wcm9wZXJ0eSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHR0aGlzLmFmdGVyU2F2ZSggdmFsdWUgKTtcblx0fVxuXG5cdGFmdGVyU2F2ZSgpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0XHR0aGlzLiRlbC5vZmYoICdjaGFuZ2UnLCB0aGlzLnVwZGF0ZVZhbHVlICk7XG5cdFx0dGhpcy4kZWwudW5iaW5kKCkucmVtb3ZlRGF0YSgpO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IHZhbHVlID0gXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdIClcblx0XHRcdD8gdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWVcblx0XHRcdDogdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdO1xuXG5cdFx0Y29uc3QgZGl2Q2xhc3MgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZmllbGRDbGFzcyApXG5cdFx0XHQ/ICdzdWktZm9ybS1maWVsZCAnICsgdGhpcy5wcm9wcy5maWVsZENsYXNzXG5cdFx0XHQ6ICdzdWktZm9ybS1maWVsZCc7XG5cblx0XHRjb25zdCBzZWxlY3RJZCA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5lbGVtZW50SWQgKVxuXHRcdFx0PyB0aGlzLnByb3BzLmVsZW1lbnRJZFxuXHRcdFx0OiB0aGlzLnByb3BzLnByb3BlcnR5O1xuXG5cdFx0bGV0IGlucHV0TGFiZWw7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMubGFiZWwgKSB7XG5cdFx0XHRpbnB1dExhYmVsID0gKFxuXHRcdFx0XHQ8bGFiZWxcblx0XHRcdFx0XHRodG1sRm9yPXsgYGZvcm1pbmF0b3ItZmllbGQtJHsgdGhpcy5wcm9wcy5wcm9wZXJ0eSB9YCB9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWxhYmVsXCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5sYWJlbCB9Jm5ic3A7eyB0aGlzLnByb3BzLnJlcXVpcmVkICYmXG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZXJyb3JcIj4gKjwvc3Bhbj5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLm5vdGUgJiZcblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1sYWJlbC1ub3RlXCI+eyB0aGlzLnByb3BzLm5vdGUgfTwvc3Bhbj5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdDwvbGFiZWw+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGNvbnN0IG11bHRpcGxlID0gdGhpcy5wcm9wcy5tdWx0aXBsZTtcblx0XHRjb25zdCB7IGZvcm1UeXBlLCB1cGRhdGVQcm9wZXJ0eSwgbm9XcmFwcGVyLCBmaWVsZENsYXNzLCBzdGF0aWNDb250ZXh0LCBmb3JtRGVzaWduLCBmaWVsZFNpemUsIC4uLnNlbGVjdFByb3BzIH0gPSB0aGlzLnByb3BzO1xuXG5cdFx0Y29uc3QgZ2V0U2VsZWN0ID0gKFxuXHRcdFx0PHNlbGVjdFxuXHRcdFx0XHRpZD17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHNlbGVjdElkIH1gIH1cblx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLXNlbGVjdFwiXG5cdFx0XHRcdHJlZj17IGVsID0+ICggdGhpcy5lbCA9IGVsICkgfVxuXHRcdFx0XHRkZWZhdWx0VmFsdWU9eyB2YWx1ZSB9XG5cdFx0XHRcdG11bHRpcGxlPXsgbXVsdGlwbGUgfVxuXHRcdFx0XHR7IC4uLnNlbGVjdFByb3BzIH1cblx0XHRcdD5cblx0XHRcdFx0e3RoaXMucHJvcHMuY2hpbGRyZW59XG5cdFx0XHQ8L3NlbGVjdD5cblx0XHQpO1xuXG5cdFx0bGV0IGdldEVsZW1lbnQgPSAoXG5cdFx0XHQ8c2VsZWN0XG5cdFx0XHRcdGlkPXsgYGZvcm1pbmF0b3ItZmllbGQtJHsgc2VsZWN0SWQgfWAgfVxuXHRcdFx0XHRjbGFzc05hbWU9XCJzdWktc2VsZWN0XCJcblx0XHRcdFx0cmVmPXsgZWwgPT4gKCB0aGlzLmVsID0gZWwgKSB9XG5cdFx0XHRcdGRlZmF1bHRWYWx1ZT17IHZhbHVlIH1cblx0XHRcdFx0bXVsdGlwbGU9eyBtdWx0aXBsZSB9XG5cdFx0XHQ+XG5cdFx0XHRcdHt0aGlzLnByb3BzLmNoaWxkcmVufVxuXHRcdFx0PC9zZWxlY3Q+XG5cdFx0KTtcblxuXHRcdGlmICggJ21kJyA9PT0gdGhpcy5wcm9wcy5maWVsZHNpemUgfHwgJ21lZGl1bScgPT09IHRoaXMucHJvcHMuZmllbGRzaXplICkge1xuXHRcdFx0Z2V0RWxlbWVudCA9IChcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktZm9ybS1maWVsZCBzdWktaW5wdXQtbWRcIj5cblx0XHRcdFx0XHR7IGdldFNlbGVjdCB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKCAnc20nID09PSB0aGlzLnByb3BzLmZpZWxkc2l6ZSB8fCAnc21hbGwnID09PSB0aGlzLnByb3BzLmZpZWxkc2l6ZSApIHtcblx0XHRcdGdldEVsZW1lbnQgPSAoXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGQgc3VpLWlucHV0LXNtXCI+XG5cdFx0XHRcdFx0eyBnZXRTZWxlY3QgfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmZpZWxkc2l6ZSApICYmICcnICE9PSB0aGlzLnByb3BzLmZpZWxkc2l6ZSApIHtcblx0XHRcdGdldEVsZW1lbnQgPSAoXG5cdFx0XHRcdDxkaXYgc3R5bGU9eyB7IHdpZHRoOiAnMTAwJScsIG1heFdpZHRoOiB0aGlzLnByb3BzLmZpZWxkc2l6ZSArICdweCcgfSB9PlxuXHRcdFx0XHRcdHsgZ2V0U2VsZWN0IH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5wcm9wcy5ub1dyYXBwZXIgKSB7XG5cdFx0XHRyZXR1cm4gZ2V0U2VsZWN0O1xuXHRcdH1cblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT17IGRpdkNsYXNzIH0+XG5cblx0XHRcdFx0eyBpbnB1dExhYmVsIH1cblxuXHRcdFx0XHR7IGdldEVsZW1lbnQgfVxuXG5cdFx0XHRcdHsgdGhpcy5wcm9wcy5kZXNjcmlwdGlvbiAmJiAoXG5cdFx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiXG5cdFx0XHRcdFx0XHRzdHlsZT17IHsgbWFyZ2luVG9wOiAnMTBweCcgfSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0aGlzLnByb3BzLmRlc2NyaXB0aW9uIH1cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdCkgfVxuXG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MvaW5wdXRzL3N1aS1zZWxlY3QyLmpzIiwiLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IF9fdW5zdGFibGVFc2NhcGVHcmVhdGVyVGhhbiBmcm9tICcuL2VzY2FwZS1ncmVhdGVyJztcbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIG1hdGNoaW5nIGludmFsaWQgYXR0cmlidXRlIG5hbWVzLlxuICpcbiAqIFwiQXR0cmlidXRlIG5hbWVzIG11c3QgY29uc2lzdCBvZiBvbmUgb3IgbW9yZSBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gY29udHJvbHMsXG4gKiBVKzAwMjAgU1BBQ0UsIFUrMDAyMiAoXCIpLCBVKzAwMjcgKCcpLCBVKzAwM0UgKD4pLCBVKzAwMkYgKC8pLCBVKzAwM0QgKD0pLFxuICogYW5kIG5vbmNoYXJhY3RlcnMuXCJcbiAqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cblxuY29uc3QgUkVHRVhQX0lOVkFMSURfQVRUUklCVVRFX05BTUUgPSAvW1xcdTAwN0YtXFx1MDA5RiBcIic+Lz1cIlxcdUZERDAtXFx1RkRFRl0vO1xuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYW1wZXJzYW5kcyBlc2NhcGVkLiBOb3RlIHRoYXQgdGhpcyBpcyBhbiBpbXBlcmZlY3RcbiAqIGltcGxlbWVudGF0aW9uLCB3aGVyZSBvbmx5IGFtcGVyc2FuZHMgd2hpY2ggZG8gbm90IGFwcGVhciBhcyBhIHBhdHRlcm4gb2ZcbiAqIG5hbWVkLCBkZWNpbWFsLCBvciBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIgcmVmZXJlbmNlcyBhcmUgZXNjYXBlZC4gSW52YWxpZFxuICogbmFtZWQgcmVmZXJlbmNlcyAoaS5lLiBhbWJpZ3VvdXMgYW1wZXJzYW5kKSBhcmUgYXJlIHN0aWxsIHBlcm1pdHRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9odG1sL3N5bnRheC5odG1sI2NoYXJhY3Rlci1yZWZlcmVuY2VzXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9odG1sL3N5bnRheC5odG1sI2FtYmlndW91cy1hbXBlcnNhbmRcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL2h0bWwvc3ludGF4Lmh0bWwjbmFtZWQtY2hhcmFjdGVyLXJlZmVyZW5jZXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgT3JpZ2luYWwgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gRXNjYXBlZCBzdHJpbmcuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUFtcGVyc2FuZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZSgvJig/IShbYS16MC05XSt8I1swLTldK3wjeFthLWYwLTldKyk7KS9naSwgJyZhbXA7Jyk7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCBxdW90YXRpb24gbWFya3MgcmVwbGFjZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIE9yaWdpbmFsIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEVzY2FwZWQgc3RyaW5nLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVRdW90YXRpb25NYXJrKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCBsZXNzLXRoYW4gc2lnbiByZXBsYWNlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgT3JpZ2luYWwgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gRXNjYXBlZCBzdHJpbmcuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUxlc3NUaGFuKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKC88L2csICcmbHQ7Jyk7XG59XG4vKipcbiAqIFJldHVybnMgYW4gZXNjYXBlZCBhdHRyaWJ1dGUgdmFsdWUuXG4gKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vaHRtbC9zeW50YXguaHRtbCNlbGVtZW50cy1hdHRyaWJ1dGVzXG4gKlxuICogXCJbLi4uXSB0aGUgdGV4dCBjYW5ub3QgY29udGFpbiBhbiBhbWJpZ3VvdXMgYW1wZXJzYW5kIFsuLi5dIG11c3Qgbm90IGNvbnRhaW5cbiAqIGFueSBsaXRlcmFsIFUrMDAyMiBRVU9UQVRJT04gTUFSSyBjaGFyYWN0ZXJzIChcIilcIlxuICpcbiAqIE5vdGUgd2UgYWxzbyBlc2NhcGUgdGhlIGdyZWF0ZXIgdGhhbiBzeW1ib2wsIGFzIHRoaXMgaXMgdXNlZCBieSB3cHRleHR1cml6ZSB0b1xuICogc3BsaXQgSFRNTCBzdHJpbmdzLiBUaGlzIGlzIGEgV29yZFByZXNzIHNwZWNpZmljIGZpeFxuICpcbiAqIE5vdGUgdGhhdCBpZiBhIHJlc29sdXRpb24gZm9yIFRyYWMjNDUzODcgY29tZXMgdG8gZnJ1aXRpb24sIGl0IGlzIG5vIGxvbmdlclxuICogbmVjZXNzYXJ5IGZvciBgX191bnN0YWJsZUVzY2FwZUdyZWF0ZXJUaGFuYCB0byBiZSB1c2VkLlxuICpcbiAqIFNlZTogaHR0cHM6Ly9jb3JlLnRyYWMud29yZHByZXNzLm9yZy90aWNrZXQvNDUzODdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gRXNjYXBlZCBhdHRyaWJ1dGUgdmFsdWUuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUF0dHJpYnV0ZSh2YWx1ZSkge1xuICByZXR1cm4gX191bnN0YWJsZUVzY2FwZUdyZWF0ZXJUaGFuKGVzY2FwZVF1b3RhdGlvbk1hcmsoZXNjYXBlQW1wZXJzYW5kKHZhbHVlKSkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGVzY2FwZWQgSFRNTCBlbGVtZW50IHZhbHVlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL2h0bWwvc3ludGF4Lmh0bWwjd3JpdGluZy1odG1sLWRvY3VtZW50cy1lbGVtZW50c1xuICpcbiAqIFwidGhlIHRleHQgbXVzdCBub3QgY29udGFpbiB0aGUgY2hhcmFjdGVyIFUrMDAzQyBMRVNTLVRIQU4gU0lHTiAoPCkgb3IgYW5cbiAqIGFtYmlndW91cyBhbXBlcnNhbmQuXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgRWxlbWVudCB2YWx1ZS5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEVzY2FwZWQgSFRNTCBlbGVtZW50IHZhbHVlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVIVE1MKHZhbHVlKSB7XG4gIHJldHVybiBlc2NhcGVMZXNzVGhhbihlc2NhcGVBbXBlcnNhbmQodmFsdWUpKTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBlc2NhcGVkIEVkaXRhYmxlIEhUTUwgZWxlbWVudCB2YWx1ZS4gVGhpcyBpcyBkaWZmZXJlbnQgZnJvbVxuICogYGVzY2FwZUhUTUxgLCBiZWNhdXNlIGZvciBlZGl0YWJsZSBIVE1MLCBBTEwgYW1wZXJzYW5kcyBtdXN0IGJlIGVzY2FwZWQgaW5cbiAqIG9yZGVyIHRvIHJlbmRlciB0aGUgY29udGVudCBjb3JyZWN0bHkgb24gdGhlIHBhZ2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIEVsZW1lbnQgdmFsdWUuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBFc2NhcGVkIEhUTUwgZWxlbWVudCB2YWx1ZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlRWRpdGFibGVIVE1MKHZhbHVlKSB7XG4gIHJldHVybiBlc2NhcGVMZXNzVGhhbih2YWx1ZS5yZXBsYWNlKC8mL2csICcmYW1wOycpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBhdHRyaWJ1dGUgbmFtZSBpcyB2YWxpZCwgb3IgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEF0dHJpYnV0ZSBuYW1lIHRvIHRlc3QuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBhdHRyaWJ1dGUgaXMgdmFsaWQuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRBdHRyaWJ1dGVOYW1lKG5hbWUpIHtcbiAgcmV0dXJuICFSRUdFWFBfSU5WQUxJRF9BVFRSSUJVVEVfTkFNRS50ZXN0KG5hbWUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdvcmRwcmVzcy9lc2NhcGUtaHRtbC9idWlsZC1tb2R1bGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHdhcm5pbmdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBfX0RFVl9fID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJztcblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAoX19ERVZfXykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfVxuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkobnVsbCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3dhcm5pbmcvd2FybmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWlTZWxlY3QgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cblx0XHR0aGlzLnVwZGF0ZVZhbHVlID0gdGhpcy51cGRhdGVWYWx1ZS5iaW5kKCB0aGlzICk7XG5cdH1cblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLiRlbCA9IGpRdWVyeSggdGhpcy5lbCApO1xuXHRcdC8vIFNVSS5zZWxlY3QuaW5pdCggdGhpcy4kZWwgKTtcblxuXHRcdHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLiRlbC5vbiggJ2NoYW5nZScsIHRoaXMudXBkYXRlVmFsdWUgKTtcblx0fVxuXG5cdHVwZGF0ZVZhbHVlKCBlICkge1xuXHRcdGNvbnN0IHZhbHVlID0gZS50YXJnZXQudmFsdWU7XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBvbiBmaWVsZCBzZXR0aW5nc1xuXHRcdGlmICggdHlwZW9mIHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHQvLyBVcGRhdGUgZmllbGQgc3RhdGVcblx0XHRcdHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkoIHRoaXMucHJvcHMucHJvcGVydHksIHZhbHVlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFVwZGF0ZSBzdG9yZVxuXHRcdFx0dGhpcy5wcm9wcy5hY3Rpb25zLnNldHRpbmdzQWN0aW9ucy51cGRhdGVTZXR0aW5nKCB0aGlzLnByb3BzLnByb3BlcnR5LCB2YWx1ZSApO1xuXHRcdH1cblx0fVxuXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdHRoaXMuJGVsLm9mZiggJ2NoYW5nZScsIHRoaXMudXBkYXRlVmFsdWUgKTtcblx0XHR0aGlzLiRlbC51bmJpbmQoKS5yZW1vdmVEYXRhKCk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IHZhbHVlID0gXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdIClcblx0XHRcdD8gdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWVcblx0XHRcdDogdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdO1xuXG5cdFx0Y29uc3QgZmllbGRDbGFzcyA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5maWVsZENsYXNzIClcblx0XHRcdD8gJ3N1aS1mb3JtLWZpZWxkICcgKyB0aGlzLnByb3BzLmZpZWxkQ2xhc3Ncblx0XHRcdDogJ3N1aS1mb3JtLWZpZWxkJztcblxuXHRcdGNvbnN0IHNlbGVjdENsYXNzID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmVsZW1lbnRDbGFzcyApXG5cdFx0XHQ/IHRoaXMucHJvcHMuZWxlbWVudENsYXNzXG5cdFx0XHQ6ICcnO1xuXG5cdFx0Y29uc3Qgc2VsZWN0SWQgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZWxlbWVudElkIClcblx0XHRcdD8gdGhpcy5wcm9wcy5lbGVtZW50SWRcblx0XHRcdDogdGhpcy5wcm9wcy5wcm9wZXJ0eTtcblxuXHRcdGxldCBzZWxlY3RMYWJlbCA9ICcnO1xuXG5cdFx0aWYgKCB0aGlzLnByb3BzLmxhYmVsICkge1xuXHRcdFx0c2VsZWN0TGFiZWwgPSAoXG5cdFx0XHRcdDxsYWJlbFxuXHRcdFx0XHRcdGh0bWxGb3I9eyBgZm9ybWluYXRvci1maWVsZC0keyB0aGlzLnByb3BzLnByb3BlcnR5IH1gIH1cblx0XHRcdFx0XHRpZD17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHRoaXMucHJvcHMucHJvcGVydHkgfS1sYWJlbGAgfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1sYWJlbFwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMubGFiZWwgfSZuYnNwO3sgdGhpcy5wcm9wcy5yZXF1aXJlZCAmJlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWVycm9yXCI+ICo8L3NwYW4+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5ub3RlICYmXG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktbGFiZWwtbm90ZVwiPnt0aGlzLnByb3BzLm5vdGV9PC9zcGFuPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHRcdGlmIChcblx0XHRcdCEgXy5pc1VuZGVmaW5lZCggdmFsdWUgKSAmJlxuXHRcdFx0KCAncGhvbmVfbmF0aW9uYWxfY291bnRyeScgPT09IHRoaXMucHJvcHMucHJvcGVydHkgfHwgJ3Bob25lX2ludGVybmF0aW9uYWxfY291bnRyeScgPT09IHRoaXMucHJvcHMucHJvcGVydHkgKVxuXHRcdCkge1xuXHRcdFx0dmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHNlbGVjdEZpZWxkID0gKFxuXHRcdFx0PHNlbGVjdFxuXHRcdFx0XHRkZWZhdWx0VmFsdWU9eyB2YWx1ZSB9XG5cdFx0XHRcdGlkPXsgYGZvcm1pbmF0b3ItZmllbGQtJHsgc2VsZWN0SWQgfWAgfVxuXHRcdFx0XHRjbGFzc05hbWU9eyBzZWxlY3RDbGFzcyB9XG5cdFx0XHRcdGFyaWEtbGFiZWxsZWRieT17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHNlbGVjdElkIH0tbGFiZWxgIH1cblx0XHRcdFx0cmVmPXsgZWwgPT4gKCB0aGlzLmVsID0gZWwgKSB9XG5cdFx0XHRcdHN0eWxlPXsgeyBtYXhXaWR0aDogJ25vbmUnIH0gfVxuXHRcdFx0PlxuXHRcdFx0XHR7IHRoaXMucHJvcHMuY2hpbGRyZW4gfVxuXHRcdFx0PC9zZWxlY3Q+XG5cdFx0KTtcblxuXHRcdGxldCBnZXRFbGVtZW50ID0gc2VsZWN0RmllbGQ7XG5cblx0XHRpZiAoICdtZCcgPT09IHRoaXMucHJvcHMuZmllbGRzaXplIHx8ICdtZWRpdW0nID09PSB0aGlzLnByb3BzLmZpZWxkc2l6ZSApIHtcblx0XHRcdGdldEVsZW1lbnQgPSAoXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGQgc3VpLWlucHV0LW1kXCI+XG5cdFx0XHRcdFx0eyBzZWxlY3RGaWVsZCB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKCAnc20nID09PSB0aGlzLnByb3BzLmZpZWxkc2l6ZSB8fCAnc21hbGwnID09PSB0aGlzLnByb3BzLmZpZWxkc2l6ZSApIHtcblx0XHRcdGdldEVsZW1lbnQgPSAoXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGQgc3VpLWlucHV0LXNtXCI+XG5cdFx0XHRcdFx0eyBzZWxlY3RGaWVsZCB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKCAnJyAhPT0gdGhpcy5wcm9wcy5maWVsZHNpemUgKSB7XG5cdFx0XHRnZXRFbGVtZW50ID0gKFxuXHRcdFx0XHQ8ZGl2IHN0eWxlPXsgeyB3aWR0aDogJzEwMCUnLCBtYXhXaWR0aDogdGhpcy5wcm9wcy5maWVsZHNpemUgKyAncHgnIH0gfT5cblx0XHRcdFx0XHR7IHNlbGVjdEZpZWxkIH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGxldCBnZXRGaWVsZCA9IGdldEVsZW1lbnQ7XG5cblx0XHRpZiAoICEgdGhpcy5wcm9wcy5zaW1wbGUgKSB7XG5cdFx0XHRnZXRGaWVsZCA9IChcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9eyBmaWVsZENsYXNzIH0+XG5cblx0XHRcdFx0XHR7IHNlbGVjdExhYmVsIH1cblxuXHRcdFx0XHRcdHsgZ2V0RWxlbWVudCB9XG5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gJiYgKFxuXHRcdFx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCJcblx0XHRcdFx0XHRcdFx0c3R5bGU9eyB7IG1hcmdpblRvcDogJzEwcHgnIH0gfVxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gfVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdCkgfVxuXG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZ2V0RmllbGQ7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9pbnB1dHMvc3VpLXNlbGVjdC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGlvIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy5yYWRpb0NvbnRhaW5lciA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0dGhpcy4kcmFkaW9Db250YWluZXIgPSBqUXVlcnkoIHRoaXMucmFkaW9Db250YWluZXIgKTtcblxuXHRcdGlmICggdGhpcy4kcmFkaW9Db250YWluZXIuaGFzQ2xhc3MoICd0aW1lX3R5cGUnICkgKSB7XG5cdFx0XHR0aGlzLiRyYWRpb0NvbnRhaW5lci5vbiggJ2NsaWNrJywgJy5mb3JtaW5hdG9yLXRvZ2dsZTpub3QoLmFjdGl2ZSknLCBlID0+IHtcblx0XHRcdFx0c2VsZi5wcm9wcy50aW1lVHlwZSggalF1ZXJ5KCBlLmN1cnJlbnRUYXJnZXQgKS5kYXRhKCAndmFsJyApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9XG5cblx0Y29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0dGhpcy4kcmFkaW9Db250YWluZXIub2ZmKCAnY2xpY2snLCB0aGlzLnVwZGF0ZVZhbHVlICkucmVtb3ZlRGF0YSgpO1xuXHR9XG5cblx0dXBkYXRlVmFsdWUoIHZhbHVlICkge1xuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIG9uIGZpZWxkIHNldHRpbmdzXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5wcm9wcy51cGRhdGVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdC8vIFVwZGF0ZSBmaWVsZCBzdGF0ZVxuXHRcdFx0dGhpcy5wcm9wcy51cGRhdGVQcm9wZXJ0eShcblx0XHRcdFx0dGhpcy5wcm9wcy5wcm9wZXJ0eSxcblx0XHRcdFx0dmFsdWVcblx0XHRcdCk7XG5cblx0XHRcdC8vIFVzZWQgdG8gY2xlYXIgb3B0aW9ucyBvbiB2YWx1ZSBjaGFuZ2Vcblx0XHRcdGlmICggdGhpcy5wcm9wcy5jbGVhck9wdGlvbnMgPT09ICd0cnVlJyApIHtcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gJ3NpbmdsZScgKSB7XG5cdFx0XHRcdFx0Y29uc3Qgb3B0aW9ucyA9IFtdO1xuXHRcdFx0XHRcdF8uZWFjaCggdGhpcy5wcm9wcy5zdGF0ZS5vcHRpb25zLCBvcHRpb24gPT4ge1xuXHRcdFx0XHRcdFx0b3B0aW9uLmRlZmF1bHQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdG9wdGlvbnMucHVzaCggb3B0aW9uICk7XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0dGhpcy5wcm9wcy51cGRhdGVQcm9wZXJ0eShcblx0XHRcdFx0XHRcdCdvcHRpb25zJyxcblx0XHRcdFx0XHRcdG9wdGlvbnNcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFVwZGF0ZSBzdG9yZVxuXHRcdFx0dGhpcy5wcm9wcy5hY3Rpb25zLnNldHRpbmdzQWN0aW9ucy51cGRhdGVTZXR0aW5nKCB0aGlzLnByb3BzLnByb3BlcnR5LCB2YWx1ZSApO1xuXHRcdH1cblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCB2YWx1ZSA9IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXSApXG5cdFx0XHQ/IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlXG5cdFx0XHQ6IHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXTtcblxuXHRcdGNvbnN0IHRhYlRpdGxlcyA9IFJlYWN0LkNoaWxkcmVuLm1hcCggdGhpcy5wcm9wcy5jaGlsZHJlbiwgdGFiID0+IHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRpZD17ICd0YWItb3B0aW9uLScgKyB0YWIucHJvcHMudmFsdWUgfVxuXHRcdFx0XHRcdHJvbGU9XCJ0YWJcIlxuXHRcdFx0XHRcdGNsYXNzTmFtZT17ICdmb3JtaW5hdG9yLXRvZ2dsZSBzdWktdGFiLWl0ZW0gJyArIChcblx0XHRcdFx0XHRcdHRhYi5wcm9wcy52YWx1ZSA9PT0gdmFsdWUgPyAnYWN0aXZlJyA6ICcnXG5cdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0YXJpYS1zZWxlY3RlZD17IHRhYi5wcm9wcy52YWx1ZSA9PT0gdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnIH1cblx0XHRcdFx0XHR7IC4uLnRhYi5wcm9wcy52YWx1ZSAhPT0gdmFsdWUgJiZcblx0XHRcdFx0XHRcdHsgdGFiSW5kZXg6ICctMScgfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhLXZhbD17IHRhYi5wcm9wcy52YWx1ZSB9XG5cdFx0XHRcdFx0b25DbGljaz17IHRoaXMudXBkYXRlVmFsdWUuYmluZCggdGhpcywgdGFiLnByb3BzLnZhbHVlICkgfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0eyB0YWIucHJvcHMuY2hpbGRyZW4gfVxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdCk7XG5cdFx0fSApO1xuXG5cdFx0bGV0IGZpZWxkTGFiZWwgPSAnJztcblxuXHRcdGlmICggdGhpcy5wcm9wcy5sYWJlbCAmJiAnJyAhPT0gdGhpcy5wcm9wcy5sYWJlbCApIHtcblx0XHRcdGZpZWxkTGFiZWwgPSAoXG5cdFx0XHRcdDxsYWJlbCBodG1sRm9yPXsgYGZvcm1pbmF0b3ItZmllbGQtJHsgdGhpcy5wcm9wcy5wcm9wZXJ0eSB9YCB9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWxhYmVsXCI+XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmxhYmVsIH1cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMubm90ZSAmJlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWxhYmVsLW5vdGVcIj57IHRoaXMucHJvcHMubm90ZSB9PC9zcGFuPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0bGV0IGZpZWxkRGVzY3JpcHRpb24gPSAnJztcblxuXHRcdGlmICggdGhpcy5wcm9wcy5kZXNjcmlwdGlvbiAmJiAnJyAhPT0gdGhpcy5wcm9wcy5kZXNjcmlwdGlvbiApIHtcblx0XHRcdGZpZWxkRGVzY3JpcHRpb24gPSAoXG5cdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPlxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5kZXNjcmlwdGlvbiB9XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0bGV0IHNldHRpbmdzTGFiZWwgPSAnJztcblxuXHRcdGlmICggISB0aGlzLnByb3BzLmxhYmVsICYmIHRoaXMucHJvcHMuc2V0dGluZ3NMYWJlbCApIHtcblx0XHRcdHNldHRpbmdzTGFiZWwgPSAoXG5cdFx0XHRcdDxsYWJlbCBjbGFzc05hbWU9XCJzdWktc2V0dGluZ3MtbGFiZWxcIj5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuc2V0dGluZ3NMYWJlbCB9XG5cdFx0XHRcdDwvbGFiZWw+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGxldCBzZXR0aW5nc0Rlc2NyaXB0aW9uID0gJyc7XG5cblx0XHRpZiAoICEgdGhpcy5wcm9wcy5sYWJlbCAmJiB0aGlzLnByb3BzLnNldHRpbmdzRGVzYyApIHtcblx0XHRcdHNldHRpbmdzRGVzY3JpcHRpb24gPSAoXG5cdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiXG5cdFx0XHRcdFx0c3R5bGU9eyB7IG1hcmdpbkJvdHRvbTogJzEwcHgnIH0gfT5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuc2V0dGluZ3NEZXNjIH1cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRjb25zdCBmaWVsZENvbnRlbnQgPSAoXG5cdFx0XHQ8ZGl2XG5cdFx0XHRcdGNsYXNzTmFtZT17IGBzdWktc2lkZS10YWJzICR7IHRoaXMucHJvcHMucHJvcGVydHkgfWAgfVxuXHRcdFx0XHRzdHlsZT17IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gJiYgeyBtYXJnaW5Cb3R0b206ICc1cHgnIH0gfVxuXHRcdFx0XHRyZWY9eyByYWRpb0NvbnRhaW5lciA9PiAoIHRoaXMucmFkaW9Db250YWluZXIgPSByYWRpb0NvbnRhaW5lciApIH1cblx0XHRcdD5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktdGFicy1tZW51XCIgcm9sZT1cInRhYmxpc3RcIj57IHRhYlRpdGxlcyB9PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXG5cdFx0bGV0IHRhYnNDb250ZW50ID0gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHR7IGZpZWxkTGFiZWwgfVxuXHRcdFx0XHR7IGZpZWxkQ29udGVudCB9XG5cdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdCk7XG5cblx0XHRpZiAoICEgdGhpcy5wcm9wcy5ub1dyYXBwZXIgKSB7XG5cdFx0XHR0YWJzQ29udGVudCA9IChcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktZm9ybS1maWVsZFwiPlxuXHRcdFx0XHRcdHsgZmllbGRMYWJlbCB9XG5cdFx0XHRcdFx0eyBzZXR0aW5nc0xhYmVsIH1cblx0XHRcdFx0XHR7IHNldHRpbmdzRGVzY3JpcHRpb24gfVxuXHRcdFx0XHRcdHsgZmllbGRDb250ZW50IH1cblx0XHRcdFx0XHR7IGZpZWxkRGVzY3JpcHRpb24gfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhYnNDb250ZW50O1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MvaW5wdXRzL3JhZGlvLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcblxuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG5cbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIEJ1dHRvbkljb24gPSBmdW5jdGlvbiBCdXR0b25JY29uKF9yZWYpIHtcbiAgdmFyIGxhYmVsID0gX3JlZi5sYWJlbCxcbiAgICAgIGljb24gPSBfcmVmLmljb24sXG4gICAgICBpY29uU2l6ZSA9IF9yZWYuaWNvblNpemUsXG4gICAgICBfcmVmJGRlc2lnbiA9IF9yZWYuZGVzaWduLFxuICAgICAgZGVzaWduID0gX3JlZiRkZXNpZ24gPT09IHZvaWQgMCA/IFwic29saWRcIiA6IF9yZWYkZGVzaWduLFxuICAgICAgY29sb3IgPSBfcmVmLmNvbG9yLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBsb2FkaW5nID0gX3JlZi5sb2FkaW5nLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wibGFiZWxcIiwgXCJpY29uXCIsIFwiaWNvblNpemVcIiwgXCJkZXNpZ25cIiwgXCJjb2xvclwiLCBcImNsYXNzTmFtZVwiLCBcImxvYWRpbmdcIl0pO1xuXG4gIHZhciBsb2FkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogXCJzdWktaWNvbi1sb2FkZXIgc3VpLWxvYWRpbmdcIixcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIlxuICAgIH0sXG4gICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICB9KTtcbiAgdmFyIGNvbnRlbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IFwic3VpLWljb24tXCIuY29uY2F0KGljb24pLmNvbmNhdChpY29uU2l6ZSA/ICcgc3VpLScgKyBpY29uU2l6ZSA6ICcnKSxcbiAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogXCJzdWktc2NyZWVuLXJlYWRlci10ZXh0XCJcbiAgfSwgbGFiZWwpKTtcbiAgY2xhc3NOYW1lID0gXCJzdWktYnV0dG9uLWljb24gXCIuY29uY2F0KGNsYXNzTmFtZSB8fCAnJyk7IC8vIFNldCBidXR0b24gY29sb3IuXG5cbiAgc3dpdGNoIChjb2xvcikge1xuICAgIGNhc2UgXCJibHVlXCI6XG4gICAgY2FzZSBcImdyZWVuXCI6XG4gICAgY2FzZSBcInJlZFwiOlxuICAgIGNhc2UgXCJvcmFuZ2VcIjpcbiAgICBjYXNlIFwicHVycGxlXCI6XG4gICAgY2FzZSBcInllbGxvd1wiOlxuICAgIGNhc2UgXCJ3aGl0ZVwiOlxuICAgICAgY2xhc3NOYW1lICs9IFwiIHN1aS1idXR0b24tXCIgKyBjb2xvcjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImdyYXlcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgY2xhc3NOYW1lICs9IFwiXCI7XG4gICAgICBicmVhaztcbiAgfSAvLyBTZXQgYnV0dG9uIHN0eWxlLlxuXG5cbiAgc3dpdGNoIChkZXNpZ24pIHtcbiAgICBjYXNlIFwiZ2hvc3RcIjpcbiAgICBjYXNlIFwib3V0bGluZWRcIjpcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBzdWktYnV0dG9uLVwiICsgZGVzaWduO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwic29saWRcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgY2xhc3NOYW1lICs9IFwiXCI7XG4gICAgICBicmVhaztcbiAgfSAvLyBTZXQgbG9hZGluZyBjbGFzcy5cblxuXG4gIGlmIChsb2FkaW5nKSB7XG4gICAgY2xhc3NOYW1lICs9IFwiIHN1aS1idXR0b24tb25sb2FkXCI7XG4gIH1cblxuICB2YXIgaHRtbFRhZyA9IHByb3BzLmhyZWYgPyAnYScgOiAnYnV0dG9uJztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGh0bWxUYWcsIF9vYmplY3RTcHJlYWQyKHtcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICBkaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQgfHwgbG9hZGluZ1xuICB9LCBwcm9wcyksIGxvYWRpbmcgPyBsb2FkZXIgOiBjb250ZW50KTtcbn07XG5cbmV4cG9ydCB7IEJ1dHRvbkljb24gfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B3cG11ZGV2L3JlYWN0LWJ1dHRvbi1pY29uL2Rpc3QvcmVhY3QtYnV0dG9uLWljb24uZXNtLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMiLCJtb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiUmVhY3RET01cIlxuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsImltcG9ydCBfY3JlYXRlQnJvd3Nlckhpc3RvcnkgZnJvbSAnLi9jcmVhdGVCcm93c2VySGlzdG9yeSc7XG5leHBvcnQgeyBfY3JlYXRlQnJvd3Nlckhpc3RvcnkgYXMgY3JlYXRlQnJvd3Nlckhpc3RvcnkgfTtcbmltcG9ydCBfY3JlYXRlSGFzaEhpc3RvcnkgZnJvbSAnLi9jcmVhdGVIYXNoSGlzdG9yeSc7XG5leHBvcnQgeyBfY3JlYXRlSGFzaEhpc3RvcnkgYXMgY3JlYXRlSGFzaEhpc3RvcnkgfTtcbmltcG9ydCBfY3JlYXRlTWVtb3J5SGlzdG9yeSBmcm9tICcuL2NyZWF0ZU1lbW9yeUhpc3RvcnknO1xuZXhwb3J0IHsgX2NyZWF0ZU1lbW9yeUhpc3RvcnkgYXMgY3JlYXRlTWVtb3J5SGlzdG9yeSB9O1xuXG5leHBvcnQgeyBjcmVhdGVMb2NhdGlvbiwgbG9jYXRpb25zQXJlRXF1YWwgfSBmcm9tICcuL0xvY2F0aW9uVXRpbHMnO1xuZXhwb3J0IHsgcGFyc2VQYXRoLCBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9nZ2xlIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUuYmluZCggdGhpcyApO1xuXHR9XG5cblx0dXBkYXRlVmFsdWUoIHZhbHVlICkge1xuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIG9uIGZpZWxkIHNldHRpbmdzXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5wcm9wcy51cGRhdGVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdC8vIFVwZGF0ZSBmaWVsZCBzdGF0ZVxuXHRcdFx0dGhpcy5wcm9wcy51cGRhdGVQcm9wZXJ0eSggdGhpcy5wcm9wcy5wcm9wZXJ0eSwgdmFsdWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVXBkYXRlIHN0b3JlXG5cdFx0XHR0aGlzLnByb3BzLmFjdGlvbnMuc2V0dGluZ3NBY3Rpb25zLnVwZGF0ZVNldHRpbmcoIHRoaXMucHJvcHMucHJvcGVydHksIHZhbHVlICk7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IHZhbHVlID0gXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdIClcblx0XHRcdD8gJydcblx0XHRcdDogdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdXG5cdFx0XHQ7XG5cblx0XHRjb25zdCBjdXN0b21DbGFzcyA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5jdXN0b21DbGFzcyApXG5cdFx0XHQ/IHRoaXMucHJvcHMuY3VzdG9tQ2xhc3Ncblx0XHRcdDogJ3N1aS1mb3JtLWNvbnRyb2wnXG5cdFx0XHQ7XG5cblx0XHRjb25zdCBkaXNhYmxlZCA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5kaXNhYmxlZCApICYmIHRoaXMucHJvcHMuZGlzYWJsZWQ7XG5cdFx0Y29uc3QgY2hlY2tlZCA9IHZhbHVlICYmICEgZGlzYWJsZWQ7XG5cblx0XHRjb25zdCB0b2dnbGVDb250ZW50ID0gKFxuXHRcdFx0PGxhYmVsIGh0bWxGb3I9eyBgZm9ybWluYXRvci1maWVsZC0keyB0aGlzLnByb3BzLnByb3BlcnR5IH1gIH1cblx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLXRvZ2dsZVwiXG5cdFx0XHQ+XG5cdFx0XHRcdDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIlxuXHRcdFx0XHRcdHZhbHVlPVwidHJ1ZVwiXG5cdFx0XHRcdFx0aWQ9eyBgZm9ybWluYXRvci1maWVsZC0keyB0aGlzLnByb3BzLnByb3BlcnR5IH1gIH1cblx0XHRcdFx0XHRjbGFzc05hbWU9eyBjdXN0b21DbGFzcyB9XG5cdFx0XHRcdFx0ZGlzYWJsZWQ9eyBkaXNhYmxlZCA/ICdkaXNhYmxlZCcgOiAnJyB9XG5cdFx0XHRcdFx0Y2hlY2tlZD17IGNoZWNrZWQgPyAnY2hlY2tlZCcgOiAnJyB9XG5cdFx0XHRcdFx0b25DaGFuZ2U9eyBlID0+IHtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRlVmFsdWUoIGUudGFyZ2V0LmNoZWNrZWQgKTtcblx0XHRcdFx0XHR9IH1cblx0XHRcdFx0Lz5cblx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXRvZ2dsZS1zbGlkZXJcIiAvPlxuXHRcdFx0XHR7IHRoaXMucHJvcHMubGFiZWwgJiYgKFxuXHRcdFx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1zY3JlZW4tcmVhZGVyLXRleHRcIj5cblx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdFbmFibGUnICkgfSB7IHRoaXMucHJvcHMubGFiZWwgfVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXRvZ2dsZS1sYWJlbFwiPlxuXHRcdFx0XHRcdFx0XHR7IHRoaXMucHJvcHMubGFiZWwgfVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdCkgfVxuXHRcdFx0XHR7IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gJiYgKFxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvbiBzdWktdG9nZ2xlLWRlc2NyaXB0aW9uXCI+XG5cdFx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0KSB9XG5cdFx0XHQ8L2xhYmVsPlxuXHRcdCk7XG5cblx0XHRsZXQgc3ViVG9nZ2xlID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMuY2hpbGRyZW4gJiYgdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdICkge1xuXHRcdFx0c3ViVG9nZ2xlID0gKFxuXHRcdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0dGFiSW5kZXg9XCIwXCJcblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS10b2dnbGUtY29udGVudCBzdWktYm9yZGVyLWZyYW1lXCJcblx0XHRcdFx0XHRcdGFyaWEtbGFiZWw9eyB0aGlzLnByb3BzLmxhYmVsIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRoaXMucHJvcHMuY2hpbGRyZW4gfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMucHJvcHMudW5XcmFwICkge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHRcdHsgdG9nZ2xlQ29udGVudCB9XG5cdFx0XHRcdFx0eyBzdWJUb2dnbGUgfVxuXHRcdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoICEgdGhpcy5wcm9wcy51bldyYXAgKSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1mb3JtLWZpZWxkXCI+XG5cdFx0XHRcdFx0eyB0b2dnbGVDb250ZW50IH1cblx0XHRcdFx0XHR7IHN1YlRvZ2dsZSB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9pbnB1dHMvdG9nZ2xlLmpzIiwiaW1wb3J0IF9Ccm93c2VyUm91dGVyIGZyb20gXCIuL0Jyb3dzZXJSb3V0ZXJcIjtcbmV4cG9ydCB7IF9Ccm93c2VyUm91dGVyIGFzIEJyb3dzZXJSb3V0ZXIgfTtcbmltcG9ydCBfSGFzaFJvdXRlciBmcm9tIFwiLi9IYXNoUm91dGVyXCI7XG5leHBvcnQgeyBfSGFzaFJvdXRlciBhcyBIYXNoUm91dGVyIH07XG5pbXBvcnQgX0xpbmsgZnJvbSBcIi4vTGlua1wiO1xuZXhwb3J0IHsgX0xpbmsgYXMgTGluayB9O1xuaW1wb3J0IF9NZW1vcnlSb3V0ZXIgZnJvbSBcIi4vTWVtb3J5Um91dGVyXCI7XG5leHBvcnQgeyBfTWVtb3J5Um91dGVyIGFzIE1lbW9yeVJvdXRlciB9O1xuaW1wb3J0IF9OYXZMaW5rIGZyb20gXCIuL05hdkxpbmtcIjtcbmV4cG9ydCB7IF9OYXZMaW5rIGFzIE5hdkxpbmsgfTtcbmltcG9ydCBfUHJvbXB0IGZyb20gXCIuL1Byb21wdFwiO1xuZXhwb3J0IHsgX1Byb21wdCBhcyBQcm9tcHQgfTtcbmltcG9ydCBfUmVkaXJlY3QgZnJvbSBcIi4vUmVkaXJlY3RcIjtcbmV4cG9ydCB7IF9SZWRpcmVjdCBhcyBSZWRpcmVjdCB9O1xuaW1wb3J0IF9Sb3V0ZSBmcm9tIFwiLi9Sb3V0ZVwiO1xuZXhwb3J0IHsgX1JvdXRlIGFzIFJvdXRlIH07XG5pbXBvcnQgX1JvdXRlciBmcm9tIFwiLi9Sb3V0ZXJcIjtcbmV4cG9ydCB7IF9Sb3V0ZXIgYXMgUm91dGVyIH07XG5pbXBvcnQgX1N0YXRpY1JvdXRlciBmcm9tIFwiLi9TdGF0aWNSb3V0ZXJcIjtcbmV4cG9ydCB7IF9TdGF0aWNSb3V0ZXIgYXMgU3RhdGljUm91dGVyIH07XG5pbXBvcnQgX1N3aXRjaCBmcm9tIFwiLi9Td2l0Y2hcIjtcbmV4cG9ydCB7IF9Td2l0Y2ggYXMgU3dpdGNoIH07XG5pbXBvcnQgX2dlbmVyYXRlUGF0aCBmcm9tIFwiLi9nZW5lcmF0ZVBhdGhcIjtcbmV4cG9ydCB7IF9nZW5lcmF0ZVBhdGggYXMgZ2VuZXJhdGVQYXRoIH07XG5pbXBvcnQgX21hdGNoUGF0aCBmcm9tIFwiLi9tYXRjaFBhdGhcIjtcbmV4cG9ydCB7IF9tYXRjaFBhdGggYXMgbWF0Y2hQYXRoIH07XG5pbXBvcnQgX3dpdGhSb3V0ZXIgZnJvbSBcIi4vd2l0aFJvdXRlclwiO1xuZXhwb3J0IHsgX3dpdGhSb3V0ZXIgYXMgd2l0aFJvdXRlciB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiZXhwb3J0IHZhciBhZGRMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBhZGRMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGggOiAnLycgKyBwYXRoO1xufTtcblxuZXhwb3J0IHZhciBzdHJpcExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIGhhc0Jhc2VuYW1lID0gZnVuY3Rpb24gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHByZWZpeCArICcoXFxcXC98XFxcXD98I3wkKScsICdpJykudGVzdChwYXRoKTtcbn07XG5cbmV4cG9ydCB2YXIgc3RyaXBCYXNlbmFtZSA9IGZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpID8gcGF0aC5zdWJzdHIocHJlZml4Lmxlbmd0aCkgOiBwYXRoO1xufTtcblxuZXhwb3J0IHZhciBzdHJpcFRyYWlsaW5nU2xhc2ggPSBmdW5jdGlvbiBzdHJpcFRyYWlsaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gJy8nID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoO1xufTtcblxuZXhwb3J0IHZhciBwYXJzZVBhdGggPSBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGF0aG5hbWUgPSBwYXRoIHx8ICcvJztcbiAgdmFyIHNlYXJjaCA9ICcnO1xuICB2YXIgaGFzaCA9ICcnO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggIT09IC0xKSB7XG4gICAgaGFzaCA9IHBhdGhuYW1lLnN1YnN0cihoYXNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgc2VhcmNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCc/Jyk7XG4gIGlmIChzZWFyY2hJbmRleCAhPT0gLTEpIHtcbiAgICBzZWFyY2ggPSBwYXRobmFtZS5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoID09PSAnPycgPyAnJyA6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoID09PSAnIycgPyAnJyA6IGhhc2hcbiAgfTtcbn07XG5cbmV4cG9ydCB2YXIgY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2gsXG4gICAgICBoYXNoID0gbG9jYXRpb24uaGFzaDtcblxuXG4gIHZhciBwYXRoID0gcGF0aG5hbWUgfHwgJy8nO1xuXG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSAnPycpIHBhdGggKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gJz8nID8gc2VhcmNoIDogJz8nICsgc2VhcmNoO1xuXG4gIGlmIChoYXNoICYmIGhhc2ggIT09ICcjJykgcGF0aCArPSBoYXNoLmNoYXJBdCgwKSA9PT0gJyMnID8gaGFzaCA6ICcjJyArIGhhc2g7XG5cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvUGF0aFV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vdGlmaWNhdGlvbiBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdGluaXRpYWxpemUoKSB7XG5cdFx0aWYgKCAhIGpRdWVyeSggJy5zdWktZmxvYXRpbmctbm90aWNlcycgKS5sZW5ndGggKSB7XG5cdFx0XHRqUXVlcnkoICdtYWluLnN1aS13cmFwJyApLnByZXBlbmQoICc8ZGl2IGNsYXNzPVwic3VpLWZsb2F0aW5nLW5vdGljZXNcIj48L2Rpdj4nICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhIGpRdWVyeSggJyNmb3JtaW5hdG9yLW5vdGlmaWNhdGlvbicgKS5sZW5ndGggKSB7XG5cdFx0XHRqUXVlcnkoICcuc3VpLWZsb2F0aW5nLW5vdGljZXMnICkuYXBwZW5kKFxuXHRcdFx0XHQnPGRpdiByb2xlPVwiYWxlcnRcIiBpZD1cImZvcm1pbmF0b3Itbm90aWZpY2F0aW9uXCIgY2xhc3M9XCJzdWktbm90aWNlXCIgYXJpYS1saXZlPVwiYXNzZXJ0aXZlXCI+PC9kaXY+J1xuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5KCAnI2Zvcm1pbmF0b3Itbm90aWZpY2F0aW9uJyApLnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5pbml0aWFsaXplKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy4kbm90aWZpY2F0aW9uID0galF1ZXJ5KCAnI2Zvcm1pbmF0b3Itbm90aWZpY2F0aW9uJyApO1xuXHR9XG5cblx0b3BlbigpIHtcblx0XHR0aGlzLmluaXRpYWxpemUoKTtcblxuXHRcdGNvbnN0IG5vdGljZUlkID0gJ2Zvcm1pbmF0b3Itbm90aWZpY2F0aW9uJztcblx0XHRjb25zdCBub3RpY2VNZXNzYWdlID0gJzxwPicgKyB0aGlzLnByb3BzLnRleHQgKyAnPC9wPic7XG5cdFx0Y29uc3Qgbm90aWNlT3B0aW9ucyA9IHtcblx0XHRcdHR5cGU6IHRoaXMucHJvcHMudHlwZSB8fCAnZGVmYXVsdCcsXG5cdFx0XHRhdXRvY2xvc2U6IHtcblx0XHRcdFx0dGltZW91dDogdGhpcy5wcm9wcy50aW1lIHx8IDUwMDAsXG5cdFx0XHR9LFxuXHRcdFx0ZGlzbWlzczoge1xuXHRcdFx0XHRzaG93OiB0aGlzLnByb3BzLmRpc21pc3MgfHwgZmFsc2Vcblx0XHRcdH0sXG5cdFx0fTtcblxuXHRcdFNVSS5vcGVuTm90aWNlKCBub3RpY2VJZCwgbm90aWNlTWVzc2FnZSwgbm90aWNlT3B0aW9ucyApO1xuXHR9XG5cblx0Y2xvc2UoKSB7XG5cdFx0Y29uc3Qgbm90aWNlSWQgPSAnZm9ybWluYXRvci1ub3RpZmljYXRpb24nO1xuXHRcdFNVSS5jbG9zZU5vdGljZSggbm90aWNlSWQgKTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL25vdGlmaWNhdGlvbnMuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHt0cmFuc2xhdGUsIGdldEZpZWxkcywgZ2V0RmllbGRzQnlUeXBlfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBlc2NhcGVIVE1MIH0gZnJvbSAnQHdvcmRwcmVzcy9lc2NhcGUtaHRtbCc7XG5pbXBvcnQgRE9NUHVyaWZ5IGZyb20gJ2RvbXB1cmlmeSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdwRWRpdG9yIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy50ZXh0RWRpdG9yID0gUmVhY3QuY3JlYXRlUmVmKCk7XG5cdFx0dGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUuYmluZCggdGhpcyApO1xuXHRcdHRoaXMudXBkYXRlRWRpdG9yID0gdGhpcy51cGRhdGVFZGl0b3IuYmluZCggdGhpcyApO1xuXHRcdHRoaXMudG9nZ2xlT3B0aW9ucyA9IHRoaXMudG9nZ2xlT3B0aW9ucy5iaW5kKCB0aGlzICk7XG5cdFx0dGhpcy5zdGF0ZSA9IHtcblx0XHRcdGVkaXRvck9wdGlvbnNPcGVuOiBmYWxzZSxcblx0XHR9O1xuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0dGhpcy4kZWwgPSBqUXVlcnkoIHRoaXMuZWwgKTtcblxuXHRcdC8vIHVwZGF0ZSBmaWVsZCBpZiBkZWZhdWx0IHZhbHVlIGlzIHByZXNlbnQuXG5cdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlICkgKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZVZhbHVlKCB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSApO1xuXHRcdH1cblxuXHRcdHNldFRpbWVvdXQoICgpID0+IHtcblx0XHRcdHRoaXMuaW5pdEVkaXRvcigpO1xuXHRcdH0sIDUwICk7XG5cdH1cblxuXHRpbml0RWRpdG9yKCkge1xuXHRcdGlmICggXy5pc1VuZGVmaW5lZCggd3AuZWRpdG9yICkgfHwgdHlwZW9mKCB0aW55TUNFICkgPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0c2V0VGltZW91dCggKCkgPT4ge1xuXHRcdFx0XHR0aGlzLmluaXRFZGl0b3IoKTtcblx0XHRcdH0sIDUwICk7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIHRpbnltY2VQcm9wcyA9IHt9O1xuXHRcdGlmICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmFsbG93QnV0dG9uT25jbGljayAgKSApIHtcblx0XHRcdC8vIEFkZCBvbmNsaWNrIGF0dHJpYnV0ZS5cblx0XHRcdHRpbnltY2VQcm9wcy5leHRlbmRlZF92YWxpZF9lbGVtZW50cyA9ICdidXR0b25bb25jbGlja3xhY2Nlc3NrZXl8Y2xhc3N8ZGlyPGx0cj9ydGx8ZGlzYWJsZWQ8ZGlzYWJsZWR8aWR8bGFuZ3xuYW1lfHN0eWxlfHRhYmluZGV4fHRpdGxlfHR5cGV8dmFsdWVdJztcblx0XHR9XG5cdFx0aWYoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5jdXRvbVRpbnltY2UgICkgKSB7XG5cdFx0XHR0aW55bWNlUHJvcHMudG9vbGJhcjEgPSB0aGlzLnByb3BzLmN1dG9tVGlueW1jZTtcblx0XHR9XG5cdFx0aWYgKCBfLmlzRW1wdHkoIHRpbnltY2VQcm9wcyApICkge1xuXHRcdFx0dGlueW1jZVByb3BzID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBJbml0aWFsaXplIGVkaXRvclxuXHRcdHdwLmVkaXRvci5pbml0aWFsaXplKGBmb3JtaW5hdG9yLWZpZWxkLSR7dGhpcy5wcm9wcy5wcm9wZXJ0eSArICFfLmlzVW5kZWZpbmVkKHRoaXMucHJvcHMuZXh0cmFJZCkgPyB0aGlzLnByb3BzLmV4dHJhSWQgOiAnJ31gLCB7XG5cdFx0XHR0aW55bWNlOiB0aW55bWNlUHJvcHMsXG5cdFx0XHRxdWlja3RhZ3M6IHRydWUsXG5cdFx0fSk7XG5cblx0XHR0aGlzLmJpbmRFdmVudHMoKTtcblx0fVxuXG5cdGJpbmRFdmVudHMoKSB7XG5cdFx0dGhpcy5lZGl0b3IgPSB0aW55TUNFLmdldCggYGZvcm1pbmF0b3ItZmllbGQtJHsgdGhpcy5wcm9wcy5wcm9wZXJ0eSArICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5leHRyYUlkICkgPyB0aGlzLnByb3BzLmV4dHJhSWQgOiAnJyB9YCApO1xuXG5cdFx0aWYgKCB0aGlzLmVkaXRvciA9PT0gbnVsbCApIHtcblx0XHRcdHNldFRpbWVvdXQoICgpID0+IHtcblx0XHRcdFx0dGhpcy5iaW5kRXZlbnRzKCk7XG5cdFx0XHR9LCA1MCApO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5lZGl0b3Iub24oICdrZXl1cCcsIHRoaXMudXBkYXRlRWRpdG9yICk7XG5cdFx0dGhpcy5lZGl0b3Iub24oICdjaGFuZ2UnLCB0aGlzLnVwZGF0ZUVkaXRvciApO1xuXHR9XG5cblx0Y29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0dGhpcy4kZWwub2ZmKCAnY2hhbmdlJywgdGhpcy51cGRhdGVFZGl0b3IgKTtcblx0XHR3cC5lZGl0b3IucmVtb3ZlKCBgZm9ybWluYXRvci1maWVsZC0keyB0aGlzLnByb3BzLnByb3BlcnR5ICsgISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmV4dHJhSWQgKSA/IHRoaXMucHJvcHMuZXh0cmFJZCA6ICcnIH1gICk7XG5cdFx0dGhpcy4kZWwudW5iaW5kKCkucmVtb3ZlRGF0YSgpO1xuXHR9XG5cblx0dXBkYXRlRWRpdG9yKCkge1xuXHRcdC8vIHVzZSBlZGl0b3IgY29udGVudCBhcyB2YWx1ZVxuXHRcdGNvbnN0IHZhbHVlID0gdGhpcy5lZGl0b3IuZ2V0Q29udGVudCgpO1xuXG5cdFx0dGhpcy51cGRhdGVWYWx1ZSggdmFsdWUgKTtcblx0fVxuXG5cdHVwZGF0ZVZhbHVlKCB2YWx1ZSApIHtcblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBvbiBmaWVsZCBzZXR0aW5nc1xuXHRcdGlmICggdHlwZW9mIHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHQvLyBVcGRhdGUgZmllbGQgc3RhdGVcblx0XHRcdHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkoIHRoaXMucHJvcHMucHJvcGVydHksIERPTVB1cmlmeS5zYW5pdGl6ZSggdmFsdWUsIHsgQUREX0FUVFI6IFsgJ3RhcmdldCcgXSB9ICkgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVXBkYXRlIHN0b3JlXG5cdFx0XHR0aGlzLnByb3BzLmFjdGlvbnMuc2V0dGluZ3NBY3Rpb25zLnVwZGF0ZVNldHRpbmcoIHRoaXMucHJvcHMucHJvcGVydHksIERPTVB1cmlmeS5zYW5pdGl6ZSggdmFsdWUsIHsgQUREX0FUVFI6IFsgJ3RhcmdldCcgXSB9ICkgKTtcblx0XHR9XG5cdH1cblxuXHR0b2dnbGVPcHRpb25zKCkge1xuXHRcdGlmICggdGhpcy5zdGF0ZS5lZGl0b3JPcHRpb25zT3BlbiApIHtcblx0XHRcdHRoaXMuc2V0U3RhdGUoIHsgZWRpdG9yT3B0aW9uc09wZW46IGZhbHNlIH0gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRTdGF0ZSggeyBlZGl0b3JPcHRpb25zT3BlbjogdHJ1ZSB9ICk7XG5cdFx0fVxuXHR9XG5cblx0aW5zZXJ0Q29udGVudCggY29udGVudCApIHtcblx0XHQvLyBJZiB0aW55TWNlIGVkaXRvciBpcyBoaWRkZW4sIHdlIGFyZSBvbiBUZXh0IG1vZGVcblx0XHRpZiAoIHRoaXMuZWRpdG9yLmhpZGRlbiApIHtcblx0XHRcdGNvbnN0IHRleHRFZGl0b3IgPSBqUXVlcnkoIHRoaXMudGV4dEVkaXRvciApO1xuXHRcdFx0Y29uc3Qgc3RhcnRQb3MgPSB0ZXh0RWRpdG9yLnByb3AoJ3NlbGVjdGlvblN0YXJ0Jyk7XG5cdFx0XHRjb25zdCBlbmRQb3MgPSB0ZXh0RWRpdG9yLnByb3AoJ3NlbGVjdGlvbkVuZCcpO1xuXHRcdFx0Y29uc3QgdGV4dEVkaXRvclZhbCA9IHRleHRFZGl0b3IudmFsKCk7XG5cblx0XHRcdHRleHRFZGl0b3IudmFsKFxuXHRcdFx0XHR0ZXh0RWRpdG9yVmFsLnN1YnN0cmluZyggMCwgc3RhcnRQb3MgKSArXG5cdFx0XHRcdCd7JyArIGNvbnRlbnQgKyAnfScgK1xuXHRcdFx0XHR0ZXh0RWRpdG9yVmFsLnN1YnN0cmluZyggZW5kUG9zLCB0ZXh0RWRpdG9yVmFsLmxlbmd0aCApXG5cdFx0XHQpO1xuXG5cdFx0XHR0ZXh0RWRpdG9yLnRyaWdnZXIoICdjaGFuZ2UnICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZWRpdG9yLmluc2VydENvbnRlbnQoICd7JyArIGNvbnRlbnQgKyAnfScgKTtcblx0XHR9XG5cblx0XHQvLyBjbG9zZSBvcHRpb25cblx0XHR0aGlzLnRvZ2dsZU9wdGlvbnMoKTtcblx0fVxuXG5cdGdldERpc2FibGVkRmllbGRzKCkge1xuXHRcdGxldCBkaXNhYmxlZEZpZWxkcyA9IFtcblx0XHRcdCdjYXB0Y2hhJyxcblx0XHRcdCdwcm9kdWN0Jyxcblx0XHRcdCdoaWRkZW4nLFxuXHRcdFx0J3BhZ2UtYnJlYWsnLFxuXHRcdFx0J3Bvc3RkYXRhJyxcblx0XHRcdCd0b3RhbCcsXG5cdFx0XHQndXBsb2FkJyxcblx0XHRcdCdzdHJpcGUnLFxuXHRcdFx0J3BheXBhbCcsXG5cdFx0XHQncGFzc3dvcmQnXG5cdFx0XTtcblxuXHRcdGlmIChcblx0XHRcdCEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5lbmFibGVQb3N0RGF0YSApICYmXG5cdFx0XHR0aGlzLnByb3BzLmVuYWJsZVBvc3REYXRhICYmXG5cdFx0XHQhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZW5hYmxlVXBsb2FkICkgJiZcblx0XHRcdHRoaXMucHJvcHMuZW5hYmxlVXBsb2FkXG5cdFx0KSB7XG5cdFx0XHRkaXNhYmxlZEZpZWxkcyA9IFsgJ2NhcHRjaGEnLCAncHJvZHVjdCcsICdoaWRkZW4nLCAncGFnZS1icmVhaycsICd0b3RhbCcsICdzdHJpcGUnLCAncGF5cGFsJywgJ3Bhc3N3b3JkJyBdO1xuXHRcdH1cblxuXHRcdHJldHVybiBkaXNhYmxlZEZpZWxkcztcblx0fVxuXG5cdGdldEZpZWxkcygpIHtcblx0XHRjb25zdCBkaXNhYmxlZEZpZWxkcyA9IHRoaXMuZ2V0RGlzYWJsZWRGaWVsZHMoKTtcblx0XHRjb25zdCBleGNsdWRlU3ViRmllbGRzID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmV4Y2x1ZGVTdWJGaWVsZHMgKVxuXHRcdFx0PyB0aGlzLnByb3BzLmV4Y2x1ZGVTdWJGaWVsZHNcblx0XHRcdDogZmFsc2U7XG5cdFx0bGV0IGZvcm1fd3JhcHBlcnMgPSB0aGlzLnByb3BzLndyYXBwZXJzO1xuXG5cdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZW5hYmxlUGFyZW50Rm9ybSAgKSAmJiAhIF8uaXNVbmRlZmluZWQoIGZvcm1pbmF0b3JEYXRhLnBhcmVudEZvcm1GaWVsZHMgKSApIHtcblx0XHRcdGZvcm1fd3JhcHBlcnMgPSBmb3JtaW5hdG9yRGF0YS5wYXJlbnRGb3JtRmllbGRzO1xuXHRcdH1cblxuXHRcdHJldHVybiBnZXRGaWVsZHMoIGZvcm1fd3JhcHBlcnMsIGRpc2FibGVkRmllbGRzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZXhjbHVkZVN1YkZpZWxkcyApO1xuXHR9XG5cblx0Z2V0Rm9ybURhdGEoKSB7XG5cdFx0Y29uc3QgZmllbGRzID0gdGhpcy5nZXRGaWVsZHMoKTtcblx0XHRjb25zdCBhbGxvd1JlcGVhdGVyID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmFsbG93UmVwZWF0ZXIgKVxuXHRcdFx0PyB0aGlzLnByb3BzLmFsbG93UmVwZWF0ZXJcblx0XHRcdDogdHJ1ZTtcblxuXHRcdGNvbnN0IHJlcXVpcmVkRmllbGRzID0gXy5tYXAoIGZpZWxkcywgKCBmaWVsZCwgaW5kZXggKSA9PiB7XG5cdFx0XHRpZiAoIGZpZWxkLnJlcXVpcmVkICkge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0YWxsb3dSZXBlYXRlciB8fFxuXHRcdFx0XHRcdCggISBhbGxvd1JlcGVhdGVyICYmIF8uaXNFbXB0eSggZmllbGQucGFyZW50X2dyb3VwICkgKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0PGxpIGNsYXNzTmFtZT1cIndwbXVkZXYtZHJvcGRvd24tLW9wdGlvblwiIGtleT17IGluZGV4IH0+XG5cdFx0XHRcdFx0XHRcdDxhXG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwid3BtdWRldi1pbnNlcnQtY29udGVudFwiXG5cdFx0XHRcdFx0XHRcdFx0b25DbGljaz17IHRoaXMuaW5zZXJ0Q29udGVudC5iaW5kKCB0aGlzLCBmaWVsZC5lbGVtZW50X2lkICkgfVxuXHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0eyBlc2NhcGVIVE1MKCBmaWVsZC5sYWJlbCApIH1cblx0XHRcdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0Y29uc3QgY3VycmVudFR5cGUgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3MudHlwZSApXG5cdFx0XHQ/IHRoaXMucHJvcHMuc2V0dGluZ3MudHlwZVxuXHRcdFx0OiAnJztcblx0XHRjb25zdCBub25yZXF1aXJlZEZpZWxkcyA9IF8ubWFwKCBmaWVsZHMsICggZmllbGQsIGluZGV4ICkgPT4ge1xuXHRcdFx0aWYgKCAhIGZpZWxkLnJlcXVpcmVkICYmIGN1cnJlbnRUeXBlICE9PSBmaWVsZC5maWVsZF90eXBlICkge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0YWxsb3dSZXBlYXRlciB8fFxuXHRcdFx0XHRcdCggISBhbGxvd1JlcGVhdGVyICYmIF8uaXNFbXB0eSggZmllbGQucGFyZW50X2dyb3VwICkgKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0PGxpIGNsYXNzTmFtZT1cIndwbXVkZXYtZHJvcGRvd24tLW9wdGlvblwiIGtleT17IGluZGV4IH0+XG5cdFx0XHRcdFx0XHRcdDxhXG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwid3BtdWRldi1pbnNlcnQtY29udGVudFwiXG5cdFx0XHRcdFx0XHRcdFx0b25DbGljaz17IHRoaXMuaW5zZXJ0Q29udGVudC5iaW5kKCB0aGlzLCBmaWVsZC5lbGVtZW50X2lkICkgfVxuXHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0eyBlc2NhcGVIVE1MKCBmaWVsZC5sYWJlbCApIH1cblx0XHRcdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0e3JlcXVpcmVkRmllbGRzICYmIHJlcXVpcmVkRmllbGRzLnNvbWUoIGZ1bmN0aW9uKCBpdGVtICkgeyByZXR1cm4gXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGl0ZW0gfSApICYmIChcblx0XHRcdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdFx0XHQ8bGkgY2xhc3NOYW1lPVwid3BtdWRldi1kcm9wZG93bi0tb3B0aW9uXCI+XG5cdFx0XHRcdFx0XHRcdDxzdHJvbmc+e3RyYW5zbGF0ZSggJ1JlcXVpcmVkIEZpZWxkcycgKX08L3N0cm9uZz5cblx0XHRcdFx0XHRcdDwvbGk+XG5cblx0XHRcdFx0XHRcdDxSZWFjdC5GcmFnbWVudD57cmVxdWlyZWRGaWVsZHN9PC9SZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHQpfVxuXG5cdFx0XHRcdHsgbm9ucmVxdWlyZWRGaWVsZHMgJiYgbm9ucmVxdWlyZWRGaWVsZHMuc29tZSggZnVuY3Rpb24oIGl0ZW0gKSB7IHJldHVybiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgaXRlbSB9ICkgJiYgKFxuXHRcdFx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0XHRcdDxsaSBjbGFzc05hbWU9XCJ3cG11ZGV2LWRyb3Bkb3duLS1vcHRpb25cIj5cblx0XHRcdFx0XHRcdFx0PHN0cm9uZz57dHJhbnNsYXRlKCAnT3B0aW9uYWwgRmllbGRzJyApfTwvc3Ryb25nPlxuXHRcdFx0XHRcdFx0PC9saT5cblxuXHRcdFx0XHRcdFx0PFJlYWN0LkZyYWdtZW50Pntub25yZXF1aXJlZEZpZWxkc308L1JlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdCl9XG5cdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdCk7XG5cdH1cblxuXHRnZXRNaXNjRGF0YSgpIHtcblx0XHRjb25zdCBlZGl0b3JPcHRpb25zID0gISBfLmlzRW1wdHkoIHRoaXMucHJvcHMuZWRpdG9yT3B0aW9ucyApID8gdGhpcy5wcm9wcy5lZGl0b3JPcHRpb25zIDogW107XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHQ8bGkgY2xhc3NOYW1lPVwid3BtdWRldi1kcm9wZG93bi0tb3B0aW9uXCI+XG5cdFx0XHRcdFx0PHN0cm9uZz57dHJhbnNsYXRlKCAnTWlzYyBEYXRhJyApfTwvc3Ryb25nPlxuXHRcdFx0XHQ8L2xpPlxuXG5cdFx0XHRcdHtfLm1hcCggZWRpdG9yT3B0aW9ucywgKCBsYWJlbCwga2V5ICkgPT4gKFxuXHRcdFx0XHRcdDxsaSBjbGFzc05hbWU9XCJ3cG11ZGV2LWRyb3Bkb3duLS1vcHRpb25cIiBrZXk9eyBrZXkgfT5cblx0XHRcdFx0XHRcdDxhXG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cIndwbXVkZXYtaW5zZXJ0LWNvbnRlbnRcIlxuXHRcdFx0XHRcdFx0XHRvbkNsaWNrPXsgdGhpcy5pbnNlcnRDb250ZW50LmJpbmQoIHRoaXMsIGtleSApIH1cblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0e2xhYmVsfVxuXHRcdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdCkgKX1cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblx0fVxuXHRnZXRQYXltZW50RGF0YSgpIHtcblx0XHRsZXQgZm9ybVdyYXBwZXJzID0gdGhpcy5wcm9wcy53cmFwcGVycztcblx0XHRpZiAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5lbmFibGVQYXJlbnRGb3JtICkgJiYgISBfLmlzVW5kZWZpbmVkKCBmb3JtaW5hdG9yRGF0YS5wYXJlbnRGb3JtRmllbGRzICkgKSB7XG5cdFx0XHRmb3JtV3JhcHBlcnMgPSBmb3JtaW5hdG9yRGF0YS5wYXJlbnRGb3JtRmllbGRzO1xuXHRcdH1cblx0XHRjb25zdCBwYXlwYWxGaWVsZHMgPSBnZXRGaWVsZHNCeVR5cGUoICdwYXlwYWwnLCBmb3JtV3JhcHBlcnMgKTtcblx0XHRjb25zdCBzdHJpcGVGaWVsZHMgPSBnZXRGaWVsZHNCeVR5cGUoICdzdHJpcGUnLCBmb3JtV3JhcHBlcnMgKTtcblx0XHRjb25zdCBwYXltZW50T3B0aW9ucyA9ICEgXy5pc0VtcHR5KCB0aGlzLnByb3BzLnBheW1lbnRPcHRpb25zICkgPyB0aGlzLnByb3BzLnBheW1lbnRPcHRpb25zIDogW107XG5cdFx0aWYoICEgXy5pc0VtcHR5KCBwYXlwYWxGaWVsZHMgKSB8fCAhIF8uaXNFbXB0eSggc3RyaXBlRmllbGRzICkgKSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdFx0e3RoaXMucHJvcHMucGF5bWVudE9wdGlvbnMgJiYgKFxuXHRcdFx0XHRcdFx0PGxpIGNsYXNzTmFtZT1cIndwbXVkZXYtZHJvcGRvd24tLW9wdGlvblwiPlxuXHRcdFx0XHRcdFx0XHQ8c3Ryb25nPnt0cmFuc2xhdGUoJ1BheW1lbnQgRGF0YScpfTwvc3Ryb25nPlxuXHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHQpfVxuXG5cdFx0XHRcdFx0e18ubWFwKHBheW1lbnRPcHRpb25zLCAobGFiZWwsIGtleSkgPT4gKFxuXHRcdFx0XHRcdFx0PGxpIGNsYXNzTmFtZT1cIndwbXVkZXYtZHJvcGRvd24tLW9wdGlvblwiIGtleT17a2V5fT5cblx0XHRcdFx0XHRcdFx0PGFcblx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJ3cG11ZGV2LWluc2VydC1jb250ZW50XCJcblx0XHRcdFx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLmluc2VydENvbnRlbnQuYmluZCh0aGlzLCBrZXkpfVxuXHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0e2xhYmVsfVxuXHRcdFx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHRcdCkpfVxuXHRcdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHRnZXRFZGl0b3JPcHRpb25zKCkge1xuXHRcdGlmICggdGhpcy5wcm9wcy5oaWRlRWRpdG9yT3B0aW9ucyApIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cblx0XHRjb25zdCBtaXNjTWFya3VwID0gdGhpcy5wcm9wcy5kaXNhYmxlTWlzY0RhdGEgPyAnJyA6IHRoaXMuZ2V0TWlzY0RhdGEoKTtcblx0XHRjb25zdCBwYXltZW50TWFya3VwID0gdGhpcy5wcm9wcy5lbmFibGVGb3JtRGF0YSA/IHRoaXMuZ2V0UGF5bWVudERhdGEoKSA6ICcnO1xuXHRcdGNvbnN0IGZpZWxkc01hcmt1cCA9IHRoaXMucHJvcHMuZW5hYmxlRm9ybURhdGEgPyB0aGlzLmdldEZvcm1EYXRhKCkgOiAnJztcblx0XHRjb25zdCBtYWluT3B0aW9ucyA9IHRoaXMucHJvcHMubWFpbk9wdGlvbnNcblx0XHRcdD8gdGhpcy5wcm9wcy5tYWluT3B0aW9uc1xuXHRcdFx0OiB7IGZvcm1fbmFtZTogdHJhbnNsYXRlKCAnRm9ybSBOYW1lJyApIH07XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PHVsIGNsYXNzTmFtZT17IHRoaXMuc3RhdGUuZWRpdG9yT3B0aW9uc09wZW4gPyAnc3VpLWFjdGl2ZScgOiAnJyB9PlxuXHRcdFx0XHR7dGhpcy5wcm9wcy5lbmFibGVBbGxGb3JtRmllbGRzICYmIChcblx0XHRcdFx0XHQ8bGkgY2xhc3NOYW1lPVwid3BtdWRldi1kcm9wZG93bi0tb3B0aW9uXCI+XG5cdFx0XHRcdFx0XHQ8YVxuXHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJ3cG11ZGV2LWluc2VydC1jb250ZW50XCJcblx0XHRcdFx0XHRcdFx0b25DbGljaz17IHRoaXMuaW5zZXJ0Q29udGVudC5iaW5kKCB0aGlzLCAnYWxsX2ZpZWxkcycgKSB9XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdHt0cmFuc2xhdGUoICdBbGwgRm9ybSBGaWVsZHMnICl9XG5cdFx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0KX1cblx0XHRcdFx0e3RoaXMucHJvcHMuZW5hYmxlQWxsTm9uRm9ybUZpZWxkcyAmJiAoXG5cdFx0XHRcdFx0PGxpIGNsYXNzTmFtZT1cIndwbXVkZXYtZHJvcGRvd24tLW9wdGlvblwiPlxuXHRcdFx0XHRcdFx0PGFcblx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwid3BtdWRldi1pbnNlcnQtY29udGVudFwiXG5cdFx0XHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLmluc2VydENvbnRlbnQuYmluZCggdGhpcywgJ2FsbF9ub25fZW1wdHlfZmllbGRzJyApIH1cblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0e3RyYW5zbGF0ZSggJ0FsbCBOb24gRW1wdHkgRmllbGRzJyApfVxuXHRcdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdCl9XG5cblx0XHRcdFx0e2ZpZWxkc01hcmt1cH1cblxuXHRcdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdFx0e3RoaXMucHJvcHMubWFpbk9wdGlvbnNMYWJlbCAmJiAoXG5cdFx0XHRcdFx0XHQ8bGkgY2xhc3NOYW1lPVwid3BtdWRldi1kcm9wZG93bi0tb3B0aW9uXCI+XG5cdFx0XHRcdFx0XHRcdDxzdHJvbmc+eyB0aGlzLnByb3BzLm1haW5PcHRpb25zTGFiZWwgfTwvc3Ryb25nPlxuXHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHQpfVxuXG5cdFx0XHRcdFx0e18ubWFwKCBtYWluT3B0aW9ucywgKCBsYWJlbCwga2V5ICkgPT4gKFxuXHRcdFx0XHRcdFx0PGxpIGNsYXNzTmFtZT1cIndwbXVkZXYtZHJvcGRvd24tLW9wdGlvblwiIGtleT17IGtleSB9PlxuXHRcdFx0XHRcdFx0XHQ8YVxuXHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cIndwbXVkZXYtaW5zZXJ0LWNvbnRlbnRcIlxuXHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLmluc2VydENvbnRlbnQuYmluZCggdGhpcywga2V5ICkgfVxuXHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0e2xhYmVsfVxuXHRcdFx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHRcdCkgKX1cblx0XHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblxuXHRcdFx0XHR7bWlzY01hcmt1cH1cblx0XHRcdFx0e3BheW1lbnRNYXJrdXB9XG5cdFx0XHQ8L3VsPlxuXHRcdCk7XG5cdH1cblx0aXNWYWxpZCggdmFsdWUgKSB7XG5cdFx0aWYgKCB0aGlzLnByb3BzLmlzUmVxdWlyZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wcm9wcy5pc1JlcXVpcmVkICYmICEgXy5pc0VtcHR5KCB2YWx1ZSApO1xuXHRcdH0gZWxzZSBpZiAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5pc1Bvc2l0aXZlICkgKSB7XG5cdFx0XHRyZXR1cm4gXy5pc0VtcHR5KCB2YWx1ZSApIHx8IHZhbHVlID49IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF0gfHwgdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWUgfHwgJyc7XG5cblx0XHRjb25zdCBlZGl0b3JPcHRpb25zID0gdGhpcy5nZXRFZGl0b3JPcHRpb25zKCk7XG5cblx0XHRjb25zdCByZXF1aXJlZEVycm9yID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnJlcXVpcmVkRXJyb3IgKVxuXHRcdFx0PyB0aGlzLnByb3BzLnJlcXVpcmVkRXJyb3Jcblx0XHRcdDogdHJhbnNsYXRlKCAnVGhpcyBmaWVsZCBpcyByZXF1aXJlZCEnICk7XG5cblx0XHRjb25zdCBoYXNFcnJvckNsYXNzID0gISB0aGlzLmlzVmFsaWQoIHZhbHVlICkgPyAnc3VpLWZvcm0tZmllbGQtZXJyb3InIDogJyc7XG5cblx0XHRsZXQgZWRpdG9yT3B0aW9uc01hcmt1cDtcblxuXHRcdGlmICggISBfLmlzRW1wdHkoIGVkaXRvck9wdGlvbnMgKSApIHtcblx0XHRcdGVkaXRvck9wdGlvbnNNYXJrdXAgPSAoXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWVkaXRvci1vcHRpb25zXCI+XG5cdFx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXtcblx0XHRcdFx0XHRcdFx0dGhpcy5zdGF0ZS5lZGl0b3JPcHRpb25zT3BlbiA/ICdzdWktdG9vbHRpcCBzdWktYWN0aXZlJyA6ICdzdWktdG9vbHRpcCdcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGRhdGEtdG9vbHRpcD17ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy50b29sdGlwTGFiZWwgKSA/IHRoaXMucHJvcHMudG9vbHRpcExhYmVsIDogdHJhbnNsYXRlKCAnQWRkIGZvcm0gZGF0YScgKSB9XG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgdGhpcy50b2dnbGVPcHRpb25zIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHQ8aSBjbGFzc05hbWU9XCJzdWktaWNvbi1wbHVzIHN1aS1zbVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG5cdFx0XHRcdFx0XHR7ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZWxlY3RMYWJlbCApID8gdGhpcy5wcm9wcy5zZWxlY3RMYWJlbCA6IHRyYW5zbGF0ZSggJ0luc2VydCBmb3JtIGZpZWxkcycgKSB9XG5cdFx0XHRcdFx0PC9idXR0b24+XG5cblx0XHRcdFx0XHR7ZWRpdG9yT3B0aW9uc31cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGxldCB3cEVkaXRvckxhYmVsID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMubGFiZWwgKSB7XG5cdFx0XHR3cEVkaXRvckxhYmVsID0gKFxuXHRcdFx0XHQ8bGFiZWxcblx0XHRcdFx0XHRodG1sRm9yPXtcblx0XHRcdFx0XHRcdGBmb3JtaW5hdG9yLWZpZWxkLSR7XG5cdFx0XHRcdFx0XHRcdHRoaXMucHJvcHMucHJvcGVydHkgKyAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZXh0cmFJZCApXG5cdFx0XHRcdFx0XHRcdFx0PyB0aGlzLnByb3BzLmV4dHJhSWRcblx0XHRcdFx0XHRcdFx0XHQ6ICcnXG5cdFx0XHRcdFx0XHR9YFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktbGFiZWxcIlxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0e3RoaXMucHJvcHMubGFiZWx9Jm5ic3A7eyB0aGlzLnByb3BzLmlzUmVxdWlyZWQgJiZcblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1lcnJvclwiPiAqPC9zcGFuPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR7dGhpcy5wcm9wcy5ub3RlICYmIDxzcGFuIGNsYXNzTmFtZT1cInN1aS1sYWJlbC1ub3RlXCI+e3RoaXMucHJvcHMubm90ZX08L3NwYW4+fVxuXHRcdFx0XHQ8L2xhYmVsPlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9eyBgc3VpLWZvcm0tZmllbGQgJHsgaGFzRXJyb3JDbGFzcyB9YCB9PlxuXG5cdFx0XHRcdHsgd3BFZGl0b3JMYWJlbCB9XG5cblx0XHRcdFx0eyB0aGlzLnByb3BzLmRlc2NyaXB0aW9uVG9wICYmIChcblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIiBzdHlsZT17IHsgbWFyZ2luQm90dG9tOiAnMjBweCcgfSB9PlxuXHRcdFx0XHRcdFx0eyB0aGlzLnByb3BzLmRlc2NyaXB0aW9uVG9wIH1cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdCl9XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9eyAnc3VpLWVkaXRvcicgKyAoXG5cdFx0XHRcdFx0Xy5pc0VtcHR5KCBlZGl0b3JPcHRpb25zIClcblx0XHRcdFx0XHRcdD8gJydcblx0XHRcdFx0XHRcdDogJyBzdWktZWRpdG9yLXdpdGgtb3B0aW9ucydcblx0XHRcdFx0KSB9PlxuXG5cdFx0XHRcdFx0eyBlZGl0b3JPcHRpb25zTWFya3VwIH1cblxuXHRcdFx0XHRcdDx0ZXh0YXJlYVxuXHRcdFx0XHRcdFx0aWQ9e1xuXHRcdFx0XHRcdFx0XHRgZm9ybWluYXRvci1maWVsZC0ke1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucHJvcHMucHJvcGVydHkgKyAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZXh0cmFJZCApXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IHRoaXMucHJvcHMuZXh0cmFJZFxuXHRcdFx0XHRcdFx0XHRcdFx0OiAnJ1xuXHRcdFx0XHRcdFx0XHR9YFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9eyB0aGlzLnByb3BzLnBsYWNlaG9sZGVyIH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17IHZhbHVlIH1cblx0XHRcdFx0XHRcdG9uQ2hhbmdlPXsgZSA9PiB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudXBkYXRlVmFsdWUoIGUudGFyZ2V0LnZhbHVlICk7XG5cdFx0XHRcdFx0XHR9IH1cblx0XHRcdFx0XHRcdHJlZj17IHRleHRFZGl0b3IgPT4gKCB0aGlzLnRleHRFZGl0b3IgPSB0ZXh0RWRpdG9yICkgfVxuXHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0eyB0aGlzLnByb3BzLmlzUmVxdWlyZWQgJiYgISB0aGlzLmlzVmFsaWQoIHZhbHVlICkgJiYgKFxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1lcnJvci1tZXNzYWdlXCI+eyByZXF1aXJlZEVycm9yIH08L3NwYW4+XG5cdFx0XHRcdCl9XG5cblx0XHRcdFx0eyB0aGlzLnByb3BzLmRlc2NyaXB0aW9uICYmIChcblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj57IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gfTwvc3Bhbj5cblx0XHRcdFx0KX1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9pbnB1dHMvd3AtZWRpdG9yLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L25vZGVfbW9kdWxlcy93YXJuaW5nL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHJlc29sdmVQYXRobmFtZSBmcm9tICdyZXNvbHZlLXBhdGhuYW1lJztcbmltcG9ydCB2YWx1ZUVxdWFsIGZyb20gJ3ZhbHVlLWVxdWFsJztcbmltcG9ydCB7IHBhcnNlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcblxuZXhwb3J0IHZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBrZXksIGN1cnJlbnRMb2NhdGlvbikge1xuICB2YXIgbG9jYXRpb24gPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUd28tYXJnIGZvcm06IHB1c2gocGF0aCwgc3RhdGUpXG4gICAgbG9jYXRpb24gPSBwYXJzZVBhdGgocGF0aCk7XG4gICAgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPbmUtYXJnIGZvcm06IHB1c2gobG9jYXRpb24pXG4gICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgcGF0aCk7XG5cbiAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24ucGF0aG5hbWUgPSAnJztcblxuICAgIGlmIChsb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5zZWFyY2guY2hhckF0KDApICE9PSAnPycpIGxvY2F0aW9uLnNlYXJjaCA9ICc/JyArIGxvY2F0aW9uLnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uc2VhcmNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBsb2NhdGlvbi5oYXNoID0gJyMnICsgbG9jYXRpb24uaGFzaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uaGFzaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkICYmIGxvY2F0aW9uLnN0YXRlID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH1cblxuICB0cnkge1xuICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gZGVjb2RlVVJJKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVVJJRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBVUklFcnJvcignUGF0aG5hbWUgXCInICsgbG9jYXRpb24ucGF0aG5hbWUgKyAnXCIgY291bGQgbm90IGJlIGRlY29kZWQuICcgKyAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGFuIGludmFsaWQgcGVyY2VudC1lbmNvZGluZy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBpZiAoa2V5KSBsb2NhdGlvbi5rZXkgPSBrZXk7XG5cbiAgaWYgKGN1cnJlbnRMb2NhdGlvbikge1xuICAgIC8vIFJlc29sdmUgaW5jb21wbGV0ZS9yZWxhdGl2ZSBwYXRobmFtZSByZWxhdGl2ZSB0byBjdXJyZW50IGxvY2F0aW9uLlxuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gY3VycmVudExvY2F0aW9uLnBhdGhuYW1lO1xuICAgIH0gZWxzZSBpZiAobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gcmVzb2x2ZVBhdGhuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIHByaW9yIGxvY2F0aW9uIGFuZCBwYXRobmFtZSBpcyBlbXB0eSwgc2V0IGl0IHRvIC9cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9ICcvJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbG9jYXRpb247XG59O1xuXG5leHBvcnQgdmFyIGxvY2F0aW9uc0FyZUVxdWFsID0gZnVuY3Rpb24gbG9jYXRpb25zQXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoID09PSBiLmhhc2ggJiYgYS5rZXkgPT09IGIua2V5ICYmIHZhbHVlRXF1YWwoYS5zdGF0ZSwgYi5zdGF0ZSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvTG9jYXRpb25VdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBY2NvcmRpb24gZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cblx0XHR0aGlzLnN0YXRlID0ge1xuXHRcdFx0b3BlbjogcHJvcHMuZXhwYW5kZWQgfHwgZmFsc2UsXG5cdFx0fTtcblxuXHRcdHRoaXMudG9nZ2xlU3RhdGUgPSB0aGlzLnRvZ2dsZVN0YXRlLmJpbmQoIHRoaXMgKTtcblx0fVxuXG5cdHRvZ2dsZVN0YXRlKCkge1xuXHRcdHRoaXMuc2V0U3RhdGUoIHtcblx0XHRcdG9wZW46ICEgdGhpcy5zdGF0ZS5vcGVuLFxuXHRcdH0gKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCB7IGxhYmVsIH0gPSB0aGlzLnByb3BzO1xuXHRcdGNvbnN0IHsgb3BlbiB9ID0gdGhpcy5zdGF0ZTtcblx0XHRsZXQgZGl2Q2xhc3MgPSAnJztcblxuXHRcdGlmICggb3BlbiApIHtcblx0XHRcdGRpdkNsYXNzID0gJ3N1aS1hY2NvcmRpb24taXRlbS0tb3Blbic7XG5cdFx0fVxuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cblx0XHRjb25zdCBib3hlZENvbnRlbnQgPSAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5ib3hlZENvbnRlbnQgKSAmJiAnJyAhPT0gdGhpcy5wcm9wcy5ib3hlZENvbnRlbnQgKVxuXHRcdFx0PyB0aGlzLnByb3BzLmJveGVkQ29udGVudFxuXHRcdFx0OiB0cnVlO1xuXG5cdFx0Y29uc3QgZGVmYXVsdENvbnRlbnRSZW5kZXIgPSAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5kZWZhdWx0Q29udGVudFJlbmRlciApIClcblx0XHRcdD8gdGhpcy5wcm9wcy5kZWZhdWx0Q29udGVudFJlbmRlclxuXHRcdFx0OiBmYWxzZTtcblxuXHRcdGNvbnN0IGFjY29yZGlvbkNvbnRlbnRzID0gUmVhY3QuQ2hpbGRyZW4ubWFwKCB0aGlzLnByb3BzLmNoaWxkcmVuLCB0YWIgPT4ge1xuXHRcdFx0cmV0dXJuIHRhYjtcblx0XHR9ICk7XG5cblx0XHQvLyBJdCdzIGludGVudGlvbmFsbHkgd2UgdXNlIHNwYW4gaGVyZSB0byBhdm9pZCB1bndhbnRlZCBoYW5kbGVycyBmcm9tIFNVSSBvbiBkaXYuc3VpLWFjY29yZGlvbi1pdGVtLWhlYWRlci5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9eyAnc3VpLWFjY29yZGlvbi1pdGVtICcgKyBkaXZDbGFzcyB9PlxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktYWNjb3JkaW9uLWl0ZW0taGVhZGVyXCIgb25DbGljaz17ICgpID0+IHRoaXMudG9nZ2xlU3RhdGUoKSB9PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWFjY29yZGlvbi1pdGVtLXRpdGxlXCI+XG5cdFx0XHRcdFx0XHQ8c3Bhbj57IGxhYmVsIH08L3NwYW4+XG5cdFx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1idXR0b24taWNvbiBzdWktYWNjb3JkaW9uLW9wZW4taW5kaWNhdG9yXCJcblx0XHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMudG9nZ2xlU3RhdGUoKSB9XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdDxpIGNsYXNzTmFtZT1cInN1aS1pY29uLWNoZXZyb24tZG93blwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXNjcmVlbi1yZWFkZXItdGV4dFwiPlxuXHRcdFx0XHRcdFx0XHRcdHsgZmFsc2UgPT09IHRoaXMuc3RhdGUub3BlbiA/ICdPcGVuJyA6ICdDbG9zZScgfVxuXHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1hY2NvcmRpb24taXRlbS1ib2R5XCI+XG5cdFx0XHRcdFx0eyBmYWxzZSA9PT0gYm94ZWRDb250ZW50XG5cdFx0XHRcdFx0XHQ/ICggZGVmYXVsdENvbnRlbnRSZW5kZXIgfHwgb3BlbiApICYmIGFjY29yZGlvbkNvbnRlbnRzXG5cdFx0XHRcdFx0XHQ6IChcblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94XCI+XG5cdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LWJvZHlcIj5cblx0XHRcdFx0XHRcdFx0XHRcdHsgKCBkZWZhdWx0Q29udGVudFJlbmRlciB8fCBvcGVuICkgJiYgYWNjb3JkaW9uQ29udGVudHMgfVxuXHRcdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0XHRcdHsgYm94ZWRDb250ZW50IH1cblx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9jb250YWluZXJzL2FjY29yZGlvbi5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuaW5oZXJpdHMgPSBpbmhlcml0cztcblxuZnVuY3Rpb24gdG9BcnJheShtc2csIGVuYykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuICAgIHJldHVybiBtc2cuc2xpY2UoKTtcbiAgaWYgKCFtc2cpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgcmVzID0gW107XG4gIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgIGlmICghZW5jKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgaGkgPSBjID4+IDg7XG4gICAgICAgIHZhciBsbyA9IGMgJiAweGZmO1xuICAgICAgICBpZiAoaGkpXG4gICAgICAgICAgcmVzLnB1c2goaGksIGxvKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJlcy5wdXNoKGxvKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCAnJyk7XG4gICAgICBpZiAobXNnLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICAgIG1zZyA9ICcwJyArIG1zZztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgIHJlcy5wdXNoKHBhcnNlSW50KG1zZ1tpXSArIG1zZ1tpICsgMV0sIDE2KSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgICByZXNbaV0gPSBtc2dbaV0gfCAwO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5mdW5jdGlvbiB0b0hleChtc2cpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICByZXMgKz0gemVybzIobXNnW2ldLnRvU3RyaW5nKDE2KSk7XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLnRvSGV4ID0gdG9IZXg7XG5cbmZ1bmN0aW9uIGh0b25sKHcpIHtcbiAgdmFyIHJlcyA9ICh3ID4+PiAyNCkgfFxuICAgICAgICAgICAgKCh3ID4+PiA4KSAmIDB4ZmYwMCkgfFxuICAgICAgICAgICAgKCh3IDw8IDgpICYgMHhmZjAwMDApIHxcbiAgICAgICAgICAgICgodyAmIDB4ZmYpIDw8IDI0KTtcbiAgcmV0dXJuIHJlcyA+Pj4gMDtcbn1cbmV4cG9ydHMuaHRvbmwgPSBodG9ubDtcblxuZnVuY3Rpb24gdG9IZXgzMihtc2csIGVuZGlhbikge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHcgPSBtc2dbaV07XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2xpdHRsZScpXG4gICAgICB3ID0gaHRvbmwodyk7XG4gICAgcmVzICs9IHplcm84KHcudG9TdHJpbmcoMTYpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy50b0hleDMyID0gdG9IZXgzMjtcblxuZnVuY3Rpb24gemVybzIod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbmV4cG9ydHMuemVybzIgPSB6ZXJvMjtcblxuZnVuY3Rpb24gemVybzgod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDcpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA2KVxuICAgIHJldHVybiAnMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDUpXG4gICAgcmV0dXJuICcwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDQpXG4gICAgcmV0dXJuICcwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAzKVxuICAgIHJldHVybiAnMDAwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDIpXG4gICAgcmV0dXJuICcwMDAwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwMDAwMDAwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbmV4cG9ydHMuemVybzggPSB6ZXJvODtcblxuZnVuY3Rpb24gam9pbjMyKG1zZywgc3RhcnQsIGVuZCwgZW5kaWFuKSB7XG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgYXNzZXJ0KGxlbiAlIDQgPT09IDApO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbiAvIDQpO1xuICBmb3IgKHZhciBpID0gMCwgayA9IHN0YXJ0OyBpIDwgcmVzLmxlbmd0aDsgaSsrLCBrICs9IDQpIHtcbiAgICB2YXIgdztcbiAgICBpZiAoZW5kaWFuID09PSAnYmlnJylcbiAgICAgIHcgPSAobXNnW2tdIDw8IDI0KSB8IChtc2dbayArIDFdIDw8IDE2KSB8IChtc2dbayArIDJdIDw8IDgpIHwgbXNnW2sgKyAzXTtcbiAgICBlbHNlXG4gICAgICB3ID0gKG1zZ1trICsgM10gPDwgMjQpIHwgKG1zZ1trICsgMl0gPDwgMTYpIHwgKG1zZ1trICsgMV0gPDwgOCkgfCBtc2dba107XG4gICAgcmVzW2ldID0gdyA+Pj4gMDtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5qb2luMzIgPSBqb2luMzI7XG5cbmZ1bmN0aW9uIHNwbGl0MzIobXNnLCBlbmRpYW4pIHtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShtc2cubGVuZ3RoICogNCk7XG4gIGZvciAodmFyIGkgPSAwLCBrID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKywgayArPSA0KSB7XG4gICAgdmFyIG0gPSBtc2dbaV07XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JpZycpIHtcbiAgICAgIHJlc1trXSA9IG0gPj4+IDI0O1xuICAgICAgcmVzW2sgKyAxXSA9IChtID4+PiAxNikgJiAweGZmO1xuICAgICAgcmVzW2sgKyAyXSA9IChtID4+PiA4KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDNdID0gbSAmIDB4ZmY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1trICsgM10gPSBtID4+PiAyNDtcbiAgICAgIHJlc1trICsgMl0gPSAobSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgIHJlc1trICsgMV0gPSAobSA+Pj4gOCkgJiAweGZmO1xuICAgICAgcmVzW2tdID0gbSAmIDB4ZmY7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLnNwbGl0MzIgPSBzcGxpdDMyO1xuXG5mdW5jdGlvbiByb3RyMzIodywgYikge1xuICByZXR1cm4gKHcgPj4+IGIpIHwgKHcgPDwgKDMyIC0gYikpO1xufVxuZXhwb3J0cy5yb3RyMzIgPSByb3RyMzI7XG5cbmZ1bmN0aW9uIHJvdGwzMih3LCBiKSB7XG4gIHJldHVybiAodyA8PCBiKSB8ICh3ID4+PiAoMzIgLSBiKSk7XG59XG5leHBvcnRzLnJvdGwzMiA9IHJvdGwzMjtcblxuZnVuY3Rpb24gc3VtMzIoYSwgYikge1xuICByZXR1cm4gKGEgKyBiKSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtMzIgPSBzdW0zMjtcblxuZnVuY3Rpb24gc3VtMzJfMyhhLCBiLCBjKSB7XG4gIHJldHVybiAoYSArIGIgKyBjKSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtMzJfMyA9IHN1bTMyXzM7XG5cbmZ1bmN0aW9uIHN1bTMyXzQoYSwgYiwgYywgZCkge1xuICByZXR1cm4gKGEgKyBiICsgYyArIGQpID4+PiAwO1xufVxuZXhwb3J0cy5zdW0zMl80ID0gc3VtMzJfNDtcblxuZnVuY3Rpb24gc3VtMzJfNShhLCBiLCBjLCBkLCBlKSB7XG4gIHJldHVybiAoYSArIGIgKyBjICsgZCArIGUpID4+PiAwO1xufVxuZXhwb3J0cy5zdW0zMl81ID0gc3VtMzJfNTtcblxuZnVuY3Rpb24gc3VtNjQoYnVmLCBwb3MsIGFoLCBhbCkge1xuICB2YXIgYmggPSBidWZbcG9zXTtcbiAgdmFyIGJsID0gYnVmW3BvcyArIDFdO1xuXG4gIHZhciBsbyA9IChhbCArIGJsKSA+Pj4gMDtcbiAgdmFyIGhpID0gKGxvIDwgYWwgPyAxIDogMCkgKyBhaCArIGJoO1xuICBidWZbcG9zXSA9IGhpID4+PiAwO1xuICBidWZbcG9zICsgMV0gPSBsbztcbn1cbmV4cG9ydHMuc3VtNjQgPSBzdW02NDtcblxuZnVuY3Rpb24gc3VtNjRfaGkoYWgsIGFsLCBiaCwgYmwpIHtcbiAgdmFyIGxvID0gKGFsICsgYmwpID4+PiAwO1xuICB2YXIgaGkgPSAobG8gPCBhbCA/IDEgOiAwKSArIGFoICsgYmg7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfaGkgPSBzdW02NF9oaTtcblxuZnVuY3Rpb24gc3VtNjRfbG8oYWgsIGFsLCBiaCwgYmwpIHtcbiAgdmFyIGxvID0gYWwgKyBibDtcbiAgcmV0dXJuIGxvID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF9sbyA9IHN1bTY0X2xvO1xuXG5mdW5jdGlvbiBzdW02NF80X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCkge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgbG8gPSBhbDtcbiAgbG8gPSAobG8gKyBibCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgYWwgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBjbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgY2wgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBkbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgZGwgPyAxIDogMDtcblxuICB2YXIgaGkgPSBhaCArIGJoICsgY2ggKyBkaCArIGNhcnJ5O1xuICByZXR1cm4gaGkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0XzRfaGkgPSBzdW02NF80X2hpO1xuXG5mdW5jdGlvbiBzdW02NF80X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCkge1xuICB2YXIgbG8gPSBhbCArIGJsICsgY2wgKyBkbDtcbiAgcmV0dXJuIGxvID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF80X2xvID0gc3VtNjRfNF9sbztcblxuZnVuY3Rpb24gc3VtNjRfNV9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwsIGVoLCBlbCkge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgbG8gPSBhbDtcbiAgbG8gPSAobG8gKyBibCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgYWwgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBjbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgY2wgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBkbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgZGwgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBlbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgZWwgPyAxIDogMDtcblxuICB2YXIgaGkgPSBhaCArIGJoICsgY2ggKyBkaCArIGVoICsgY2Fycnk7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfNV9oaSA9IHN1bTY0XzVfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0XzVfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsLCBlaCwgZWwpIHtcbiAgdmFyIGxvID0gYWwgKyBibCArIGNsICsgZGwgKyBlbDtcblxuICByZXR1cm4gbG8gPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0XzVfbG8gPSBzdW02NF81X2xvO1xuXG5mdW5jdGlvbiByb3RyNjRfaGkoYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWwgPDwgKDMyIC0gbnVtKSkgfCAoYWggPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufVxuZXhwb3J0cy5yb3RyNjRfaGkgPSByb3RyNjRfaGk7XG5cbmZ1bmN0aW9uIHJvdHI2NF9sbyhhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhaCA8PCAoMzIgLSBudW0pKSB8IChhbCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59XG5leHBvcnRzLnJvdHI2NF9sbyA9IHJvdHI2NF9sbztcblxuZnVuY3Rpb24gc2hyNjRfaGkoYWgsIGFsLCBudW0pIHtcbiAgcmV0dXJuIGFoID4+PiBudW07XG59XG5leHBvcnRzLnNocjY0X2hpID0gc2hyNjRfaGk7XG5cbmZ1bmN0aW9uIHNocjY0X2xvKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFoIDw8ICgzMiAtIG51bSkpIHwgKGFsID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn1cbmV4cG9ydHMuc2hyNjRfbG8gPSBzaHI2NF9sbztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvcm1hdHM6IGZvcm1hdHMsXG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXMvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoZWNrYm94IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUuYmluZCggdGhpcyApO1xuXHR9XG5cblx0dXBkYXRlVmFsdWUoIHZhbHVlICkge1xuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIG9uIGZpZWxkIHNldHRpbmdzXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5wcm9wcy51cGRhdGVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdC8vIFVwZGF0ZSBmaWVsZCBzdGF0ZVxuXHRcdFx0dGhpcy5wcm9wcy51cGRhdGVQcm9wZXJ0eSggdGhpcy5wcm9wcy5wcm9wZXJ0eSwgdmFsdWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVXBkYXRlIHN0b3JlXG5cdFx0XHR0aGlzLnByb3BzLmFjdGlvbnMuc2V0dGluZ3NBY3Rpb25zLnVwZGF0ZVNldHRpbmcoIHRoaXMucHJvcHMucHJvcGVydHksIHZhbHVlICk7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IHZhbHVlID0gXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdIClcblx0XHRcdD8gdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWVcblx0XHRcdDogdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdO1xuXG5cdFx0Y29uc3QgZmllbGRJZCA9IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZmllbGRJZCApXG5cdFx0XHQ/IHRoaXMucHJvcHMucHJvcGVydHlcblx0XHRcdDogdGhpcy5wcm9wcy5maWVsZElkO1xuXG5cdFx0Y29uc3QgZGlzYWJsZWQgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZGlzYWJsZWQgKSAmJlxuXHRcdFx0dGhpcy5wcm9wcy5kaXNhYmxlZCA/IHRydWUgOiBmYWxzZTtcblxuXHRcdGxldCBleHRyYUNsYXNzID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMuaXRlbUNsYXNzICYmICcnICE9PSB0aGlzLnByb3BzLml0ZW1DbGFzcyApIHtcblx0XHRcdGV4dHJhQ2xhc3MgPSAnICcgKyB0aGlzLnByb3BzLml0ZW1DbGFzcztcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGxhYmVsXG5cdFx0XHRcdGh0bWxGb3I9eyBgZm9ybWluYXRvci1maWVsZC0keyBmaWVsZElkIH1gIH1cblx0XHRcdFx0Y2xhc3NOYW1lPXsgYHN1aS1jaGVja2JveCR7IGV4dHJhQ2xhc3MgfWAgfVxuXHRcdFx0PlxuXHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHR0eXBlPVwiY2hlY2tib3hcIlxuXHRcdFx0XHRcdGlkPXsgYGZvcm1pbmF0b3ItZmllbGQtJHsgZmllbGRJZCB9YCB9XG5cdFx0XHRcdFx0dmFsdWU9XCJ0cnVlXCJcblx0XHRcdFx0XHRjaGVja2VkPXsgdmFsdWUgPyAnY2hlY2tlZCcgOiAnJyB9XG5cdFx0XHRcdFx0ZGlzYWJsZWQ9eyBkaXNhYmxlZCB9XG5cdFx0XHRcdFx0b25DaGFuZ2U9eyBlID0+IHtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRlVmFsdWUoIGUudGFyZ2V0LmNoZWNrZWQgKTtcblx0XHRcdFx0XHR9IH1cblx0XHRcdFx0Lz5cblx0XHRcdFx0PHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuXHRcdFx0XHR7IHRoaXMucHJvcHMubGFiZWwgJiZcblx0XHRcdFx0XHQ8c3Bhbj5cblx0XHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5sYWJlbCB9XG5cdFx0XHRcdFx0XHR7ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy50b29sdGlwICkgJiYgJycgIT09IHRoaXMucHJvcHMudG9vbHRpcCAmJiAoXG5cdFx0XHRcdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLXRvb2x0aXAgc3VpLXRvb2x0aXAtY29uc3RyYWluZWRcIlxuXHRcdFx0XHRcdFx0XHRcdHN0eWxlPXsge1xuXHRcdFx0XHRcdFx0XHRcdFx0bWFyZ2luTGVmdDogMTAsXG5cdFx0XHRcdFx0XHRcdFx0XHR2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcblx0XHRcdFx0XHRcdFx0XHRcdCctLXRvb2x0aXAtd2lkdGgnOiAnMTY1cHgnXG5cdFx0XHRcdFx0XHRcdFx0fSB9XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS10b29sdGlwPXsgdGhpcy5wcm9wcy50b29sdGlwIH1cblx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktaWNvbi1pbmZvXCJcblx0XHRcdFx0XHRcdFx0XHRcdGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHlsZT17IHsgcG9pbnRlckV2ZW50czogJ25vbmUnIH0gfVxuXHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdCl9XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHR9XG5cdFx0XHQ8L2xhYmVsPlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9pbnB1dHMvY2hlY2tib3guanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIvKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3dhcm5pbmcuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5cbnZhciBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IGZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCkge1xuICB2YXIgcHJvbXB0ID0gbnVsbDtcblxuICB2YXIgc2V0UHJvbXB0ID0gZnVuY3Rpb24gc2V0UHJvbXB0KG5leHRQcm9tcHQpIHtcbiAgICB3YXJuaW5nKHByb21wdCA9PSBudWxsLCAnQSBoaXN0b3J5IHN1cHBvcnRzIG9ubHkgb25lIHByb21wdCBhdCBhIHRpbWUnKTtcblxuICAgIHByb21wdCA9IG5leHRQcm9tcHQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb21wdCA9PT0gbmV4dFByb21wdCkgcHJvbXB0ID0gbnVsbDtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjb25maXJtVHJhbnNpdGlvblRvID0gZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IElmIGFub3RoZXIgdHJhbnNpdGlvbiBzdGFydHMgd2hpbGUgd2UncmUgc3RpbGwgY29uZmlybWluZ1xuICAgIC8vIHRoZSBwcmV2aW91cyBvbmUsIHdlIG1heSBlbmQgdXAgaW4gYSB3ZWlyZCBzdGF0ZS4gRmlndXJlIG91dCB0aGVcbiAgICAvLyBiZXN0IHdheSB0byBoYW5kbGUgdGhpcy5cbiAgICBpZiAocHJvbXB0ICE9IG51bGwpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0eXBlb2YgcHJvbXB0ID09PSAnZnVuY3Rpb24nID8gcHJvbXB0KGxvY2F0aW9uLCBhY3Rpb24pIDogcHJvbXB0O1xuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXRVc2VyQ29uZmlybWF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbihyZXN1bHQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnQSBoaXN0b3J5IG5lZWRzIGEgZ2V0VXNlckNvbmZpcm1hdGlvbiBmdW5jdGlvbiBpbiBvcmRlciB0byB1c2UgYSBwcm9tcHQgbWVzc2FnZScpO1xuXG4gICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldHVybiBmYWxzZSBmcm9tIGEgdHJhbnNpdGlvbiBob29rIHRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbi5cbiAgICAgICAgY2FsbGJhY2socmVzdWx0ICE9PSBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbGlzdGVuZXJzID0gW107XG5cbiAgdmFyIGFwcGVuZExpc3RlbmVyID0gZnVuY3Rpb24gYXBwZW5kTGlzdGVuZXIoZm4pIHtcbiAgICB2YXIgaXNBY3RpdmUgPSB0cnVlO1xuXG4gICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICBpZiAoaXNBY3RpdmUpIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzQWN0aXZlID0gZmFsc2U7XG4gICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIG5vdGlmeUxpc3RlbmVycyA9IGZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVycygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgc2V0UHJvbXB0OiBzZXRQcm9tcHQsXG4gICAgY29uZmlybVRyYW5zaXRpb25UbzogY29uZmlybVRyYW5zaXRpb25UbyxcbiAgICBhcHBlbmRMaXN0ZW5lcjogYXBwZW5kTGlzdGVuZXIsXG4gICAgbm90aWZ5TGlzdGVuZXJzOiBub3RpZnlMaXN0ZW5lcnNcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBSb3V0ZXIgZnJvbSBcInJlYWN0LXJvdXRlci9lcy9Sb3V0ZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSBcIndhcm5pbmdcIjtcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSBcImludmFyaWFudFwiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBwdXR0aW5nIGhpc3Rvcnkgb24gY29udGV4dC5cbiAqL1xuXG52YXIgUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG1hdGNoOiBfdGhpcy5jb21wdXRlTWF0Y2goX3RoaXMucHJvcHMuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZSlcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFJvdXRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IF9leHRlbmRzKHt9LCB0aGlzLmNvbnRleHQucm91dGVyLCB7XG4gICAgICAgIGhpc3Rvcnk6IHRoaXMucHJvcHMuaGlzdG9yeSxcbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICBsb2NhdGlvbjogdGhpcy5wcm9wcy5oaXN0b3J5LmxvY2F0aW9uLFxuICAgICAgICAgIG1hdGNoOiB0aGlzLnN0YXRlLm1hdGNoXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXB1dGVNYXRjaCA9IGZ1bmN0aW9uIGNvbXB1dGVNYXRjaChwYXRobmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBcIi9cIixcbiAgICAgIHVybDogXCIvXCIsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgaXNFeGFjdDogcGF0aG5hbWUgPT09IFwiL1wiXG4gICAgfTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgaGlzdG9yeSA9IF9wcm9wcy5oaXN0b3J5O1xuXG5cbiAgICBpbnZhcmlhbnQoY2hpbGRyZW4gPT0gbnVsbCB8fCBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDEsIFwiQSA8Um91dGVyPiBtYXkgaGF2ZSBvbmx5IG9uZSBjaGlsZCBlbGVtZW50XCIpO1xuXG4gICAgLy8gRG8gdGhpcyBoZXJlIHNvIHdlIGNhbiBzZXRTdGF0ZSB3aGVuIGEgPFJlZGlyZWN0PiBjaGFuZ2VzIHRoZVxuICAgIC8vIGxvY2F0aW9uIGluIGNvbXBvbmVudFdpbGxNb3VudC4gVGhpcyBoYXBwZW5zIGUuZy4gd2hlbiBkb2luZ1xuICAgIC8vIHNlcnZlciByZW5kZXJpbmcgdXNpbmcgYSA8U3RhdGljUm91dGVyPi5cbiAgICB0aGlzLnVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyLnNldFN0YXRlKHtcbiAgICAgICAgbWF0Y2g6IF90aGlzMi5jb21wdXRlTWF0Y2goaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgd2FybmluZyh0aGlzLnByb3BzLmhpc3RvcnkgPT09IG5leHRQcm9wcy5oaXN0b3J5LCBcIllvdSBjYW5ub3QgY2hhbmdlIDxSb3V0ZXIgaGlzdG9yeT5cIik7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMudW5saXN0ZW4oKTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuXG4gICAgcmV0dXJuIGNoaWxkcmVuID8gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbikgOiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGhpc3Rvcnk6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuUm91dGVyLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuUm91dGVyLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJpbXBvcnQgcGF0aFRvUmVnZXhwIGZyb20gXCJwYXRoLXRvLXJlZ2V4cFwiO1xuXG52YXIgcGF0dGVybkNhY2hlID0ge307XG52YXIgY2FjaGVMaW1pdCA9IDEwMDAwO1xudmFyIGNhY2hlQ291bnQgPSAwO1xuXG52YXIgY29tcGlsZVBhdGggPSBmdW5jdGlvbiBjb21waWxlUGF0aChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHZhciBjYWNoZUtleSA9IFwiXCIgKyBvcHRpb25zLmVuZCArIG9wdGlvbnMuc3RyaWN0ICsgb3B0aW9ucy5zZW5zaXRpdmU7XG4gIHZhciBjYWNoZSA9IHBhdHRlcm5DYWNoZVtjYWNoZUtleV0gfHwgKHBhdHRlcm5DYWNoZVtjYWNoZUtleV0gPSB7fSk7XG5cbiAgaWYgKGNhY2hlW3BhdHRlcm5dKSByZXR1cm4gY2FjaGVbcGF0dGVybl07XG5cbiAgdmFyIGtleXMgPSBbXTtcbiAgdmFyIHJlID0gcGF0aFRvUmVnZXhwKHBhdHRlcm4sIGtleXMsIG9wdGlvbnMpO1xuICB2YXIgY29tcGlsZWRQYXR0ZXJuID0geyByZTogcmUsIGtleXM6IGtleXMgfTtcblxuICBpZiAoY2FjaGVDb3VudCA8IGNhY2hlTGltaXQpIHtcbiAgICBjYWNoZVtwYXR0ZXJuXSA9IGNvbXBpbGVkUGF0dGVybjtcbiAgICBjYWNoZUNvdW50Kys7XG4gIH1cblxuICByZXR1cm4gY29tcGlsZWRQYXR0ZXJuO1xufTtcblxuLyoqXG4gKiBQdWJsaWMgQVBJIGZvciBtYXRjaGluZyBhIFVSTCBwYXRobmFtZSB0byBhIHBhdGggcGF0dGVybi5cbiAqL1xudmFyIG1hdGNoUGF0aCA9IGZ1bmN0aW9uIG1hdGNoUGF0aChwYXRobmFtZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBwYXJlbnQgPSBhcmd1bWVudHNbMl07XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSBvcHRpb25zID0geyBwYXRoOiBvcHRpb25zIH07XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIHBhdGggPSBfb3B0aW9ucy5wYXRoLFxuICAgICAgX29wdGlvbnMkZXhhY3QgPSBfb3B0aW9ucy5leGFjdCxcbiAgICAgIGV4YWN0ID0gX29wdGlvbnMkZXhhY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkZXhhY3QsXG4gICAgICBfb3B0aW9ucyRzdHJpY3QgPSBfb3B0aW9ucy5zdHJpY3QsXG4gICAgICBzdHJpY3QgPSBfb3B0aW9ucyRzdHJpY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkc3RyaWN0LFxuICAgICAgX29wdGlvbnMkc2Vuc2l0aXZlID0gX29wdGlvbnMuc2Vuc2l0aXZlLFxuICAgICAgc2Vuc2l0aXZlID0gX29wdGlvbnMkc2Vuc2l0aXZlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJHNlbnNpdGl2ZTtcblxuXG4gIGlmIChwYXRoID09IG51bGwpIHJldHVybiBwYXJlbnQ7XG5cbiAgdmFyIF9jb21waWxlUGF0aCA9IGNvbXBpbGVQYXRoKHBhdGgsIHsgZW5kOiBleGFjdCwgc3RyaWN0OiBzdHJpY3QsIHNlbnNpdGl2ZTogc2Vuc2l0aXZlIH0pLFxuICAgICAgcmUgPSBfY29tcGlsZVBhdGgucmUsXG4gICAgICBrZXlzID0gX2NvbXBpbGVQYXRoLmtleXM7XG5cbiAgdmFyIG1hdGNoID0gcmUuZXhlYyhwYXRobmFtZSk7XG5cbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHVybCA9IG1hdGNoWzBdLFxuICAgICAgdmFsdWVzID0gbWF0Y2guc2xpY2UoMSk7XG5cbiAgdmFyIGlzRXhhY3QgPSBwYXRobmFtZSA9PT0gdXJsO1xuXG4gIGlmIChleGFjdCAmJiAhaXNFeGFjdCkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBwYXRoLCAvLyB0aGUgcGF0aCBwYXR0ZXJuIHVzZWQgdG8gbWF0Y2hcbiAgICB1cmw6IHBhdGggPT09IFwiL1wiICYmIHVybCA9PT0gXCJcIiA/IFwiL1wiIDogdXJsLCAvLyB0aGUgbWF0Y2hlZCBwb3J0aW9uIG9mIHRoZSBVUkxcbiAgICBpc0V4YWN0OiBpc0V4YWN0LCAvLyB3aGV0aGVyIG9yIG5vdCB3ZSBtYXRjaGVkIGV4YWN0bHlcbiAgICBwYXJhbXM6IGtleXMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBrZXksIGluZGV4KSB7XG4gICAgICBtZW1vW2tleS5uYW1lXSA9IHZhbHVlc1tpbmRleF07XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCB7fSlcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1hdGNoUGF0aDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvbWF0Y2hQYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgLyogSWdub3JlICovIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG5cbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBCdXR0b24gPSBmdW5jdGlvbiBCdXR0b24oX3JlZikge1xuICB2YXIgbGFiZWwgPSBfcmVmLmxhYmVsLFxuICAgICAgaWNvbiA9IF9yZWYuaWNvbixcbiAgICAgIF9yZWYkZGVzaWduID0gX3JlZi5kZXNpZ24sXG4gICAgICBkZXNpZ24gPSBfcmVmJGRlc2lnbiA9PT0gdm9pZCAwID8gXCJzb2xpZFwiIDogX3JlZiRkZXNpZ24sXG4gICAgICBjb2xvciA9IF9yZWYuY29sb3IsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGxvYWRpbmcgPSBfcmVmLmxvYWRpbmcsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJsYWJlbFwiLCBcImljb25cIiwgXCJkZXNpZ25cIiwgXCJjb2xvclwiLCBcImNsYXNzTmFtZVwiLCBcImxvYWRpbmdcIl0pO1xuXG4gIHZhciBsb2FkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogXCJzdWktaWNvbi1sb2FkZXIgc3VpLWxvYWRpbmdcIixcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIlxuICAgIH0sXG4gICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICB9KTtcbiAgdmFyIGNvbnRlbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgaWNvbiAmJiBcIlwiICE9PSBpY29uICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInN1aS1pY29uLVwiICsgaWNvbixcbiAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiXG4gIH0pLCBsYWJlbCk7XG4gIGNsYXNzTmFtZSA9IFwic3VpLWJ1dHRvblwiLmNvbmNhdChjbGFzc05hbWUgPyAnICcgKyBjbGFzc05hbWUgOiAnJyk7IC8vIFNldCBidXR0b24gY29sb3IuXG5cbiAgc3dpdGNoIChjb2xvcikge1xuICAgIGNhc2UgXCJibHVlXCI6XG4gICAgY2FzZSBcImdyZWVuXCI6XG4gICAgY2FzZSBcInJlZFwiOlxuICAgIGNhc2UgXCJvcmFuZ2VcIjpcbiAgICBjYXNlIFwicHVycGxlXCI6XG4gICAgY2FzZSBcInllbGxvd1wiOlxuICAgIGNhc2UgXCJ3aGl0ZVwiOlxuICAgICAgY2xhc3NOYW1lICs9IFwiIHN1aS1idXR0b24tXCIgKyBjb2xvcjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImdyYXlcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgY2xhc3NOYW1lICs9IFwiXCI7XG4gICAgICBicmVhaztcbiAgfSAvLyBTZXQgYnV0dG9uIHN0eWxlLlxuXG5cbiAgc3dpdGNoIChkZXNpZ24pIHtcbiAgICBjYXNlIFwiZ2hvc3RcIjpcbiAgICBjYXNlIFwib3V0bGluZWRcIjpcbiAgICAgIGNsYXNzTmFtZSArPSBcIiBzdWktYnV0dG9uLVwiICsgZGVzaWduO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwic29saWRcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgY2xhc3NOYW1lICs9IFwiXCI7XG4gICAgICBicmVhaztcbiAgfSAvLyBTZXQgbG9hZGluZyBjbGFzcy5cblxuXG4gIGlmIChsb2FkaW5nKSB7XG4gICAgY2xhc3NOYW1lICs9IFwiIHN1aS1idXR0b24tb25sb2FkXCI7XG4gIH1cblxuICB2YXIgaHRtbFRhZyA9ICdidXR0b24nO1xuXG4gIGlmIChwcm9wcy5ocmVmKSB7XG4gICAgaHRtbFRhZyA9ICdhJztcbiAgfSBlbHNlIGlmIChwcm9wcy5odG1sRm9yKSB7XG4gICAgaHRtbFRhZyA9ICdsYWJlbCc7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoaHRtbFRhZywgX29iamVjdFNwcmVhZDIoe1xuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCB8fCBsb2FkaW5nXG4gIH0sIHByb3BzKSwgbG9hZGluZyA/IGxvYWRlciA6IGNvbnRlbnQpO1xufTtcblxuZXhwb3J0IHsgQnV0dG9uIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad3BtdWRldi9yZWFjdC1idXR0b24vZGlzdC9yZWFjdC1idXR0b24uZXNtLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMiLCIvKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG52YXIgSTE4TiA9IHJlcXVpcmUoICcuL2xpYicgKSxcblx0aTE4biA9IG5ldyBJMThOKCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRudW1iZXJGb3JtYXQ6IGkxOG4ubnVtYmVyRm9ybWF0LmJpbmQoIGkxOG4gKSxcblx0dHJhbnNsYXRlOiBpMThuLnRyYW5zbGF0ZS5iaW5kKCBpMThuICksXG5cdGNvbmZpZ3VyZTogaTE4bi5jb25maWd1cmUuYmluZCggaTE4biApLFxuXHRzZXRMb2NhbGU6IGkxOG4uc2V0TG9jYWxlLmJpbmQoIGkxOG4gKSxcblx0Z2V0TG9jYWxlOiBpMThuLmdldExvY2FsZS5iaW5kKCBpMThuICksXG5cdGdldExvY2FsZVNsdWc6IGkxOG4uZ2V0TG9jYWxlU2x1Zy5iaW5kKCBpMThuICksXG5cdGFkZFRyYW5zbGF0aW9uczogaTE4bi5hZGRUcmFuc2xhdGlvbnMuYmluZCggaTE4biApLFxuXHRyZVJlbmRlclRyYW5zbGF0aW9uczogaTE4bi5yZVJlbmRlclRyYW5zbGF0aW9ucy5iaW5kKCBpMThuICksXG5cdHJlZ2lzdGVyQ29tcG9uZW50VXBkYXRlSG9vazogaTE4bi5yZWdpc3RlckNvbXBvbmVudFVwZGF0ZUhvb2suYmluZCggaTE4biApLFxuXHRyZWdpc3RlclRyYW5zbGF0ZUhvb2s6IGkxOG4ucmVnaXN0ZXJUcmFuc2xhdGVIb29rLmJpbmQoIGkxOG4gKSxcblx0c3RhdGU6IGkxOG4uc3RhdGUsXG5cdHN0YXRlT2JzZXJ2ZXI6IGkxOG4uc3RhdGVPYnNlcnZlcixcblx0b246IGkxOG4uc3RhdGVPYnNlcnZlci5vbi5iaW5kKGkxOG4uc3RhdGVPYnNlcnZlciksXG5cdG9mZjogaTE4bi5zdGF0ZU9ic2VydmVyLnJlbW92ZUxpc3RlbmVyLmJpbmQoaTE4bi5zdGF0ZU9ic2VydmVyKSxcblx0ZW1pdDogaTE4bi5zdGF0ZU9ic2VydmVyLmVtaXQuYmluZChpMThuLnN0YXRlT2JzZXJ2ZXIpLFxuXHRsb2NhbGl6ZTogcmVxdWlyZSggJy4vbGliL2xvY2FsaXplJyApKCBpMThuICksXG5cdCR0aGlzOiBpMThuLFxuXHRJMThOOiBJMThOXG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pMThuLXdwLXBsdWdpbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1aVRhZ3MgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdFx0dGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUuYmluZCggdGhpcyApO1xuXHRcdHRoaXMuY2xlYXJWYWx1ZSA9IHRoaXMuY2xlYXJWYWx1ZS5iaW5kKCB0aGlzICk7XG5cblx0XHRjb25zdCBkZWZhdWx0VmFsdWUgPSBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSApXG5cdFx0XHQ/ICcnXG5cdFx0XHQ6IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlO1xuXG5cdFx0Y29uc3QgdmFsdWUgPSBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF0gKVxuXHRcdFx0PyBkZWZhdWx0VmFsdWVcblx0XHRcdDogdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdO1xuXG5cdFx0dGhpcy5zdGF0ZSA9IHtcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHR9O1xuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0dGhpcy4kZWwgPSBqUXVlcnkoIHRoaXMuZWwgKTtcblx0XHRTVUkuc2VsZWN0LmluaXRWYXJzKCB0aGlzLiRlbCApO1xuXG5cdFx0dGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUuYmluZCggdGhpcyApO1xuXG5cdFx0Y29uc3QgaXNSZWRpcmVjdFVybCA9IHRoaXMuJGVsLmNsb3Nlc3QoICcuc3VpLWZvcm0tZmllbGQnICkuaGFzQ2xhc3MoICdyZWRpcmVjdC11cmwnICk7XG5cdFx0dGhpcy4kZWwub24oICdjaGFuZ2UnLCBlID0+IHtcblx0XHRcdGNvbnN0IHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZSArICggaXNSZWRpcmVjdFVybCA/ICcnIDogJyAnICkgKyBlLnRhcmdldC52YWx1ZTtcblx0XHRcdHRoaXMudXBkYXRlVmFsdWUoIHZhbHVlLnRyaW0oKSApO1xuXHRcdH0gKTtcblxuXHRcdHRoaXMuY2xlYXJWYWx1ZSggdGhpcy4kZWwgKTtcblxuXHRcdHRoaXMuJGVsLmNsb3Nlc3QoICcuc3VpLWZvcm0tZmllbGQnICkuaGFzQ2xhc3MoICdzdWktdmFyaWFibGVzLXNlbGVjdC10ZXh0JyApICYmICggdGhpcy5pbnNlcnRGb3JtRmllbGRzKCkgKTtcblx0fVxuXG5cdHVwZGF0ZVZhbHVlKCB2YWx1ZSApIHtcblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBvbiBmaWVsZCBzZXR0aW5nc1xuXHRcdGlmICggdHlwZW9mIHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHQvLyBVcGRhdGUgZmllbGQgc3RhdGVcblx0XHRcdHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkoIHRoaXMucHJvcHMucHJvcGVydHksIHZhbHVlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFVwZGF0ZSBzdG9yZVxuXHRcdFx0dGhpcy5wcm9wcy5hY3Rpb25zLnNldHRpbmdzQWN0aW9ucy51cGRhdGVTZXR0aW5nKCB0aGlzLnByb3BzLnByb3BlcnR5LCB2YWx1ZSApO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0aGlzLnByb3BzLnVwZGF0ZVZhbHVlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0dGhpcy5wcm9wcy51cGRhdGVWYWx1ZSggdGhpcy5wcm9wcy5jb3VudGVyLCB2YWx1ZSApO1xuXHRcdH1cblx0XHR0aGlzLnNldFN0YXRlKCB7IHZhbHVlOiB2YWx1ZSB9ICk7XG5cdH1cblxuXHRjbGVhclZhbHVlKCBlbGVtZW50ICkge1xuXHRcdGVsZW1lbnQudmFsKCBudWxsICkudHJpZ2dlciggJ2NoYW5nZScgKTtcblx0fVxuXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdHRoaXMuJGVsLm9mZiggJ2NoYW5nZScsIHRoaXMudXBkYXRlVmFsdWUgKTtcblx0XHR0aGlzLiRlbC51bmJpbmQoKS5yZW1vdmVEYXRhKCk7XG5cdH1cblxuXHRpc1ZhbGlkKCB2YWx1ZSApIHtcblx0XHRpZiAoIHRoaXMucHJvcHMuaXNSZXF1aXJlZCApIHtcblx0XHRcdHJldHVybiB0aGlzLnByb3BzLmlzUmVxdWlyZWQgJiYgISBfLmlzRW1wdHkoIHZhbHVlICk7XG5cdFx0fSBlbHNlIGlmICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmlzUG9zaXRpdmUgKSApIHtcblx0XHRcdHJldHVybiBfLmlzRW1wdHkoIHZhbHVlICkgfHwgdmFsdWUgPj0gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGluc2VydEZvcm1GaWVsZHMoKSB7XG5cdFx0dGhpcy4kZWwubmV4dCggJy5zZWxlY3QyLWNvbnRhaW5lcicgKS5maW5kKCAnLnNlbGVjdDItc2VsZWN0aW9uJyApLmh0bWwoIHRyYW5zbGF0ZSggJysgSW5zZXJ0IGZvcm0gZmllbGRzJyApICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgZGVmYXVsdFZhbHVlID0gXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWUgKVxuXHRcdFx0PyAnJ1xuXHRcdFx0OiB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZTtcblx0XHRjb25zdCB2YWx1ZSA9IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXSApXG5cdFx0XHQ/IGRlZmF1bHRWYWx1ZVxuXHRcdFx0OiB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF07XG5cdFx0Y29uc3QgcmVxdWlyZWRFcnJvciA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5yZXF1aXJlZEVycm9yICkgPyB0aGlzLnByb3BzLnJlcXVpcmVkRXJyb3IgOiB0cmFuc2xhdGUoICdUaGlzIGZpZWxkIGlzIHJlcXVpcmVkIScgKTtcblxuXHRcdGNvbnN0IGhhc0Vycm9yQ2xhc3MgPSAhIHRoaXMuaXNWYWxpZCggdmFsdWUgKSA/ICcgc3VpLWZvcm0tZmllbGQtZXJyb3InIDogJyc7XG5cdFx0Y29uc3QgaGFzQ3VzdG9tQ2xhc3MgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuY3VzdG9tQ2xhc3MgKSA/ICcgJyArIHRoaXMucHJvcHMuY3VzdG9tQ2xhc3MgOiAnJztcblxuXHRcdGxldCBmaWVsZExhYmVsID0gJyc7XG5cdFx0bGV0IHR5cGUgPSAnaW5wdXQnO1xuXHRcdGxldCB0ZXh0YXJlYUNsYXNzID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMudHlwZSA9PT0gJ3RleHRhcmVhJyApIHtcblx0XHRcdHR5cGUgPSAndGV4dGFyZWEnO1xuXHRcdFx0dGV4dGFyZWFDbGFzcyA9ICd0ZXh0YXJlYS10eXBlJztcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMucHJvcHMubGFiZWwgKSB7XG5cdFx0XHRmaWVsZExhYmVsID0gKFxuXHRcdFx0XHQ8bGFiZWwgaHRtbEZvcj17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHRoaXMucHJvcHMucHJvcGVydHkgfWAgfSBjbGFzc05hbWU9XCJzdWktbGFiZWxcIj5cblx0XHRcdFx0XHR7dGhpcy5wcm9wcy5sYWJlbH0mbmJzcDt7ICggdGhpcy5wcm9wcy5pc1JlcXVpcmVkIHx8IHRoaXMucHJvcHMucmVxdWlyZWQgKSAmJlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWVycm9yXCI+ICo8L3NwYW4+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHt0aGlzLnByb3BzLm5vdGUgJiYgPHNwYW4gY2xhc3NOYW1lPVwic3VpLWxhYmVsLW5vdGVcIj57dGhpcy5wcm9wcy5ub3RlfTwvc3Bhbj59XG5cdFx0XHRcdDwvbGFiZWw+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZpZWxkQ29udHJvbCA9IChcblx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0eyB0eXBlID09PSAnaW5wdXQnICYmXG5cdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0XHR2YWx1ZT17IHRoaXMuc3RhdGUudmFsdWUgfVxuXHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9eyB0aGlzLnByb3BzLnBsYWNlaG9sZGVyIH1cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1mb3JtLWNvbnRyb2xcIlxuXHRcdFx0XHRcdFx0b25DaGFuZ2U9eyBlID0+IHtcblx0XHRcdFx0XHRcdFx0dGhpcy51cGRhdGVWYWx1ZSggZS50YXJnZXQudmFsdWUgKTtcblx0XHRcdFx0XHRcdH0gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdH1cblx0XHRcdFx0eyB0eXBlID09PSAndGV4dGFyZWEnICYmXG5cdFx0XHRcdFx0PHRleHRhcmVhXG5cdFx0XHRcdFx0XHR2YWx1ZT17IHRoaXMuc3RhdGUudmFsdWUgfVxuXHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9eyB0aGlzLnByb3BzLnBsYWNlaG9sZGVyIH1cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1mb3JtLWNvbnRyb2xcIlxuXHRcdFx0XHRcdFx0b25DaGFuZ2U9eyBlID0+IHtcblx0XHRcdFx0XHRcdFx0dGhpcy51cGRhdGVWYWx1ZSggZS50YXJnZXQudmFsdWUgKTtcblx0XHRcdFx0XHRcdH0gfVxuXHRcdFx0XHRcdFx0cm93cz17IHRoaXMucHJvcHMucm93cyB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0fVxuXHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPXsgYHN1aS1mb3JtLWZpZWxkJHsgaGFzQ3VzdG9tQ2xhc3MgfSR7IGhhc0Vycm9yQ2xhc3MgfWAgfT5cblx0XHRcdFx0e2ZpZWxkTGFiZWx9XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9eyBgc3VpLWluc2VydC12YXJpYWJsZXMgJHsgdGV4dGFyZWFDbGFzcyB9YCB9PlxuXG5cdFx0XHRcdFx0eyBmaWVsZENvbnRyb2wgfVxuXG5cdFx0XHRcdFx0PHNlbGVjdCBjbGFzc05hbWU9XCJzdWktdmFyaWFibGVzXCIgcmVmPXsgZWwgPT4gKCB0aGlzLmVsID0gZWwgKSB9PlxuXHRcdFx0XHRcdFx0eyB0aGlzLnByb3BzLmNoaWxkcmVuLmxlbmd0aCA8PSAwICYmXG5cdFx0XHRcdFx0XHRcdDxvcHRncm91cCBsYWJlbD17IHRyYW5zbGF0ZSggJ05vIGF2YWlsYWJsZSBvcHRpb25zJyApIH0+PC9vcHRncm91cD5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5jaGlsZHJlbiB9XG5cdFx0XHRcdFx0PC9zZWxlY3Q+XG5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuaXNSZXF1aXJlZCAmJiAhIHRoaXMuaXNWYWxpZCggdmFsdWUgKSAmJiAoXG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZXJyb3ItbWVzc2FnZVwiPnsgcmVxdWlyZWRFcnJvciB9PC9zcGFuPlxuXHRcdFx0XHRcdCkgfVxuXG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmRlc2NyaXB0aW9uICYmIChcblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPnsgdGhpcy5wcm9wcy5kZXNjcmlwdGlvbiB9PC9zcGFuPlxuXHRcdFx0XHRcdCkgfVxuXG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MvaW5wdXRzL3N1aS12YXJpYWJsZXMuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGFzc2VydDtcblxuZnVuY3Rpb24gYXNzZXJ0KHZhbCwgbXNnKSB7XG4gIGlmICghdmFsKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbn1cblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gYXNzZXJ0RXF1YWwobCwgciwgbXNnKSB7XG4gIGlmIChsICE9IHIpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAoJ0Fzc2VydGlvbiBmYWlsZWQ6ICcgKyBsICsgJyAhPSAnICsgcikpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21pbmltYWxpc3RpYy1hc3NlcnQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUiLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUiLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqIERldGVjdCBpZiBwcm9wZXJ0aWVzIHNoYWRvd2luZyB0aG9zZSBvbiBgT2JqZWN0LnByb3RvdHlwZWAgYXJlIG5vbi1lbnVtZXJhYmxlLiAqL1xudmFyIG5vbkVudW1TaGFkb3dzID0gIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAndmFsdWVPZic6IDEgfSwgJ3ZhbHVlT2YnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIC8vIFNhZmFyaSA5IG1ha2VzIGBhcmd1bWVudHMubGVuZ3RoYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcbiAgICA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZylcbiAgICA6IFtdO1xuXG4gIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IGFycmF5O1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUgPT09IHVuZGVmaW5lZCA/IHNvdXJjZVtrZXldIDogbmV3VmFsdWUpO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gKiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHBzOi8vbWRuLmlvL09iamVjdC9hc3NpZ24pLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uYXNzaWduSW5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIGZ1bmN0aW9uIEJhcigpIHtcbiAqICAgdGhpcy5jID0gMztcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG52YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgaWYgKG5vbkVudW1TaGFkb3dzIHx8IGlzUHJvdG90eXBlKHNvdXJjZSkgfHwgaXNBcnJheUxpa2Uoc291cmNlKSkge1xuICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLmFzc2lnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgc3R5bGVkIGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcblxuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKHN0cmluZ3MsIHJhdykge1xuICBpZiAoIXJhdykge1xuICAgIHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJpbmdzLCB7XG4gICAgcmF3OiB7XG4gICAgICB2YWx1ZTogT2JqZWN0LmZyZWV6ZShyYXcpXG4gICAgfVxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdDMoKSB7XG4gIHZhciBkYXRhID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCJcXG4uc3VpLXdyYXAgJiYge1xcblxcdGRpc3BsYXk6IFwiLCBcIjtcXG5cXHRcIiwgXCJcXG5cXHRcIiwgXCJcXG5cXHRtYXJnaW46IDA7XFxuXFx0cGFkZGluZy10b3A6IFwiLCBcInB4O1xcblxcdHBhZGRpbmctcmlnaHQ6IFwiLCBcInB4O1xcblxcdHBhZGRpbmctYm90dG9tOiBcIiwgXCJweDtcXG5cXHRwYWRkaW5nLWxlZnQ6IFwiLCBcInB4O1xcblxcdGJvcmRlcjogMCBzb2xpZCAjRTZFNkU2O1xcblxcdGJvcmRlci10b3Atd2lkdGg6IFwiLCBcInB4O1xcblxcdFwiLCBcIlxcblxcblxcdFwiLCBcIlxcblxcdFwiLCBcIlxcblxcblxcdEBtZWRpYSBcIiwgXCIge1xcblxcdFxcdHBhZGRpbmctdG9wOiBcIiwgXCJweDtcXG5cXHRcXHRwYWRkaW5nLXJpZ2h0OiBcIiwgXCJweDtcXG5cXHRcXHRwYWRkaW5nLWJvdHRvbTogXCIsIFwicHg7XFxuXFx0XFx0cGFkZGluZy1sZWZ0OiBcIiwgXCJweDtcXG5cXHR9XFxufVxcblwiXSk7XG5cbiAgX3RlbXBsYXRlT2JqZWN0MyA9IGZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdDMoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdDIoKSB7XG4gIHZhciBkYXRhID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCJcXG4uc3VpLXdyYXAgJiYge1xcblxcdG1hcmdpbjogMDtcXG5cXHRwYWRkaW5nLXRvcDogXCIsIFwicHg7XFxuXFx0cGFkZGluZy1yaWdodDogXCIsIFwicHg7XFxuXFx0cGFkZGluZy1ib3R0b206IFwiLCBcInB4O1xcblxcdHBhZGRpbmctbGVmdDogXCIsIFwicHg7XFxuXFx0Ym9yZGVyOiAwIHNvbGlkICNFNkU2RTY7XFxuXFx0Ym9yZGVyLXRvcC13aWR0aDogXCIsIFwicHg7XFxuXFx0Ym9yZGVyLWJvdHRvbS13aWR0aDogXCIsIFwicHg7XFxuXFx0dGV4dC1hbGlnbjogXCIsIFwiO1xcblxcblxcdEBtZWRpYSBcIiwgXCIge1xcblxcdFxcdHBhZGRpbmctdG9wOiBcIiwgXCJweDtcXG5cXHRcXHRwYWRkaW5nLXJpZ2h0OiBcIiwgXCJweDtcXG5cXHRcXHRwYWRkaW5nLWJvdHRvbTogXCIsIFwicHg7XFxuXFx0XFx0cGFkZGluZy1sZWZ0OiBcIiwgXCJweDtcXG5cXHR9XFxufVxcblwiXSk7XG5cbiAgX3RlbXBsYXRlT2JqZWN0MiA9IGZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdDIoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdCgpIHtcbiAgdmFyIGRhdGEgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIlxcbi5zdWktd3JhcCAmJiB7XFxuXFx0ZGlzcGxheTogXCIsIFwiO1xcblxcdFwiLCBcIlxcblxcdFwiLCBcIlxcblxcdG1hcmdpbjogMDtcXG5cXHRwYWRkaW5nLXRvcDogXCIsIFwicHg7XFxuXFx0cGFkZGluZy1yaWdodDogXCIsIFwicHg7XFxuXFx0cGFkZGluZy1ib3R0b206IFwiLCBcInB4O1xcblxcdHBhZGRpbmctbGVmdDogXCIsIFwicHg7XFxuXFx0Ym9yZGVyOiAwIHNvbGlkICNFNkU2RTY7XFxuXFx0Ym9yZGVyLWJvdHRvbS13aWR0aDogXCIsIFwicHg7XFxuXFx0XCIsIFwiXFxuXFxuXFx0XCIsIFwiXFxuXFx0XCIsIFwiXFxuXFxuXFx0QG1lZGlhIFwiLCBcIiB7XFxuXFx0XFx0cGFkZGluZy10b3A6IFwiLCBcInB4O1xcblxcdFxcdHBhZGRpbmctcmlnaHQ6IFwiLCBcInB4O1xcblxcdFxcdHBhZGRpbmctYm90dG9tOiBcIiwgXCJweDtcXG5cXHRcXHRwYWRkaW5nLWxlZnQ6IFwiLCBcInB4O1xcblxcdH1cXG59XFxuXCJdKTtcblxuICBfdGVtcGxhdGVPYmplY3QgPSBmdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbnZhciB1dGlscyA9IHtcbiAgZ3V0dGVyOiAzMCxcbiAgZ3V0dGVyX21kOiAyMFxufTtcbnZhciBzY3JlZW4gPSB7XG4gIG1vYmlsZTogNDgwLFxuICB0YWJsZXQ6IDc4MyxcbiAgbGFwdG9wOiAxMjAwLFxuICBkZXNrdG9wOiAxNTAwXG59O1xudmFyIGRldmljZSA9IHtcbiAgbW9iaWxlOiBcIihtaW4td2lkdGg6IFwiLmNvbmNhdChzY3JlZW4ubW9iaWxlLCBcInB4KVwiKSxcbiAgdGFibGV0OiBcIihtaW4td2lkdGg6IFwiLmNvbmNhdChzY3JlZW4udGFibGV0LCBcInB4KVwiKSxcbiAgbGFwdG9wOiBcIihtaW4td2lkdGg6IFwiLmNvbmNhdChzY3JlZW4ubGFwdG9wLCBcInB4KVwiKSxcbiAgZGVza3RvcDogXCIobWluLXdpZHRoOiBcIi5jb25jYXQoc2NyZWVuLmRlc2t0b3AsIFwicHgpXCIpXG59O1xudmFyIEJveCA9IGZ1bmN0aW9uIEJveChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBjbGFzc05hbWUgJiYgJycgIT09IGNsYXNzTmFtZSA/IFwic3VpLWJveCBcIi5jb25jYXQoY2xhc3NOYW1lKSA6ICdzdWktYm94J1xuICB9LCBwcm9wcyksIGNoaWxkcmVuKTtcbn07XG52YXIgQm94VGl0bGUgPSBmdW5jdGlvbiBCb3hUaXRsZShfcmVmMikge1xuICB2YXIgaWNvbiA9IF9yZWYyLmljb24sXG4gICAgICB0YWdMYWJlbCA9IF9yZWYyLnRhZ0xhYmVsLFxuICAgICAgdGFnQ29sb3IgPSBfcmVmMi50YWdDb2xvcixcbiAgICAgIHRhZ1NpemUgPSBfcmVmMi50YWdTaXplLFxuICAgICAgdGFnRGVzaWduID0gX3JlZjIudGFnRGVzaWduLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmMi5jaGlsZHJlbixcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbXCJpY29uXCIsIFwidGFnTGFiZWxcIiwgXCJ0YWdDb2xvclwiLCBcInRhZ1NpemVcIiwgXCJ0YWdEZXNpZ25cIiwgXCJjbGFzc05hbWVcIiwgXCJjaGlsZHJlblwiXSk7XG5cbiAgdmFyIHRhZ0NsYXNzID0gJ3N1aS10YWcnO1xuXG4gIHN3aXRjaCAodGFnQ29sb3IpIHtcbiAgICBjYXNlICdyZWQnOlxuICAgIGNhc2UgJ3llbGxvdyc6XG4gICAgY2FzZSAnZ3JlZW4nOlxuICAgIGNhc2UgJ2JsdWUnOlxuICAgIGNhc2UgJ3B1cnBsZSc6XG4gICAgICB0YWdDbGFzcyArPSAnIHN1aS10YWctJyArIHRhZ0NvbG9yO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBzd2l0Y2ggKHRhZ1NpemUpIHtcbiAgICBjYXNlICdzbSc6XG4gICAgY2FzZSAnc21hbGwnOlxuICAgICAgdGFnQ2xhc3MgKz0gJyBzdWktdGFnLXNtJztcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3dpdGNoICh0YWdEZXNpZ24pIHtcbiAgICBjYXNlICdvdXRsaW5lZCc6XG4gICAgICB0YWdDbGFzcyArPSAnIHN1aS10YWctZ2hvc3QnO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoM1wiLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGNsYXNzTmFtZSAmJiAnJyAhPT0gY2xhc3NOYW1lID8gXCJzdWktYm94LXRpdGxlIFwiLmNvbmNhdChjbGFzc05hbWUpIDogJ3N1aS1ib3gtdGl0bGUnXG4gIH0sIHByb3BzKSwgaWNvbiAmJiBcIlwiICE9PSBpY29uICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInN1aS1pY29uLVwiLmNvbmNhdChpY29uLCBcIiBzdWktbWRcIiksXG4gICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICB9KSwgY2hpbGRyZW4sIHRhZ0xhYmVsICYmICcnICE9PSB0YWdMYWJlbCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogdGFnQ2xhc3MsXG4gICAgc3R5bGU6IHtcbiAgICAgIG1hcmdpbkxlZnQ6IDEwXG4gICAgfVxuICB9LCB0YWdMYWJlbCkpO1xufTtcbnZhciBIZWFkZXIgPSBzdHlsZWQuZGl2LmF0dHJzKGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4ge1xuICAgIHByb3BzOiBwcm9wc1xuICB9O1xufSkoX3RlbXBsYXRlT2JqZWN0KCksIGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gJ2Jsb2NrJyAhPT0gcHJvcHMuZGlzcGxheSA/ICdmbGV4JyA6ICdibG9jayc7XG59LCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuICdibG9jaycgIT09IHByb3BzLmRpc3BsYXkgJiYgJ2ZsZXgtZmxvdzogcm93IHdyYXA7Jztcbn0sIGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gJ2Jsb2NrJyAhPT0gcHJvcHMuZGlzcGxheSAmJiAoJ2xlZnQnID09PSBwcm9wcy5hbGlnbm1lbnQgfHwgJ3JpZ2h0JyA9PT0gcHJvcHMuYWxpZ25tZW50IHx8ICdjZW50ZXInID09PSBwcm9wcy5hbGlnbm1lbnQpID8gJ2xlZnQnID09PSBwcm9wcy5hbGlnbm1lbnQgPyAnanVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0OycgOiAncmlnaHQnID09PSBwcm9wcy5hbGlnbm1lbnQgPyAnanVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDsnIDogJ2p1c3RpZnktY29udGVudDogY2VudGVyOycgOiAnanVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOyc7XG59LCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzLnBhZGRpbmdUb3AgfHwgMCA9PT0gcHJvcHMucGFkZGluZ1RvcCA/IHByb3BzLnBhZGRpbmdUb3AgPiAyOSA/IHByb3BzLnBhZGRpbmdUb3AgLSAxMCA6IHByb3BzLnBhZGRpbmdUb3AgOiB1dGlscy5ndXR0ZXJfbWQgLyAyO1xufSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5wYWRkaW5nUmlnaHQgfHwgMCA9PT0gcHJvcHMucGFkZGluZ1JpZ2h0ID8gcHJvcHMucGFkZGluZ1JpZ2h0ID4gMjkgPyBwcm9wcy5wYWRkaW5nUmlnaHQgLSAxMCA6IHByb3BzLnBhZGRpbmdSaWdodCA6IHV0aWxzLmd1dHRlcl9tZDtcbn0sIGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gcHJvcHMucGFkZGluZ0JvdHRvbSB8fCAwID09PSBwcm9wcy5wYWRkaW5nQm90dG9tID8gcHJvcHMucGFkZGluZ0JvdHRvbSA+IDI5ID8gcHJvcHMucGFkZGluZ0JvdHRvbSAtIDEwIDogcHJvcHMucGFkZGluZ0JvdHRvbSA6IHV0aWxzLmd1dHRlcl9tZCAvIDI7XG59LCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzLnBhZGRpbmdMZWZ0IHx8IDAgPT09IHByb3BzLnBhZGRpbmdMZWZ0ID8gcHJvcHMucGFkZGluZ0xlZnQgPiAyOSA/IHByb3BzLnBhZGRpbmdMZWZ0IC0gMTAgOiBwcm9wcy5wYWRkaW5nTGVmdCA6IHV0aWxzLmd1dHRlcl9tZDtcbn0sIGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gcHJvcHMuYm9yZGVyIHx8IDAgPT09IHByb3BzLmJvcmRlciA/IHByb3BzLmJvcmRlciA6IDE7XG59LCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuICdibG9jaycgPT09IHByb3BzLmRpc3BsYXkgJiYgKCdyaWdodCcgPT09IHByb3BzLmFsaWdubWVudCB8fCAnY2VudGVyJyA9PT0gcHJvcHMuYWxpZ25tZW50KSAmJiAndGV4dC1hbGlnbjogJyArIHByb3BzLmFsaWdubWVudCArICc7Jztcbn0sIGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gJ2Jsb2NrJyAhPT0gcHJvcHMuZGlzcGxheSAmJiAnPiAqIHsgbWF4LXdpZHRoOiAxMDAlOyBmbGV4OiAwIDAgYXV0bzsgfSc7XG59LCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuICdibG9jaycgIT09IHByb3BzLmRpc3BsYXkgJiYgJz4gKiArICogeyBtYXJnaW4tbGVmdDogMTBweDsgfSc7XG59LCBkZXZpY2UudGFibGV0LCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzLnBhZGRpbmdUb3AgfHwgMCA9PT0gcHJvcHMucGFkZGluZ1RvcCA/IHByb3BzLnBhZGRpbmdUb3AgOiB1dGlscy5ndXR0ZXIgLyAyO1xufSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5wYWRkaW5nUmlnaHQgfHwgMCA9PT0gcHJvcHMucGFkZGluZ1JpZ2h0ID8gcHJvcHMucGFkZGluZ1JpZ2h0IDogdXRpbHMuZ3V0dGVyO1xufSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5wYWRkaW5nQm90dG9tIHx8IDAgPT09IHByb3BzLnBhZGRpbmdCb3R0b20gPyBwcm9wcy5wYWRkaW5nQm90dG9tIDogdXRpbHMuZ3V0dGVyIC8gMjtcbn0sIGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gcHJvcHMucGFkZGluZ0xlZnQgfHwgMCA9PT0gcHJvcHMucGFkZGluZ0xlZnQgPyBwcm9wcy5wYWRkaW5nTGVmdCA6IHV0aWxzLmd1dHRlcjtcbn0pO1xudmFyIEJveEhlYWRlciA9IGZ1bmN0aW9uIEJveEhlYWRlcihfcmVmMykge1xuICB2YXIgdGl0bGUgPSBfcmVmMy50aXRsZSxcbiAgICAgIHRpdGxlSWNvbiA9IF9yZWYzLnRpdGxlSWNvbixcbiAgICAgIHRhZ0xhYmVsID0gX3JlZjMudGFnTGFiZWwsXG4gICAgICB0YWdDb2xvciA9IF9yZWYzLnRhZ0NvbG9yLFxuICAgICAgdGFnU2l6ZSA9IF9yZWYzLnRhZ1NpemUsXG4gICAgICB0YWdEZXNpZ24gPSBfcmVmMy50YWdEZXNpZ24sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmMy5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYzLmNoaWxkcmVuLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjMsIFtcInRpdGxlXCIsIFwidGl0bGVJY29uXCIsIFwidGFnTGFiZWxcIiwgXCJ0YWdDb2xvclwiLCBcInRhZ1NpemVcIiwgXCJ0YWdEZXNpZ25cIiwgXCJjbGFzc05hbWVcIiwgXCJjaGlsZHJlblwiXSk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRlciwgcHJvcHMsIHRpdGxlICYmICcnICE9PSB0aXRsZSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChCb3hUaXRsZSwge1xuICAgIGljb246IHRpdGxlSWNvbixcbiAgICB0YWdMYWJlbDogdGFnTGFiZWwsXG4gICAgdGFnQ29sb3I6IHRhZ0NvbG9yLFxuICAgIHRhZ1NpemU6IHRhZ1NpemUsXG4gICAgdGFnRGVzaWduOiB0YWdEZXNpZ25cbiAgfSwgdGl0bGUpLCBjaGlsZHJlbik7XG59O1xudmFyIEJvZHkgPSBzdHlsZWQuZGl2LmF0dHJzKGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4ge1xuICAgIHByb3BzOiBwcm9wc1xuICB9O1xufSkoX3RlbXBsYXRlT2JqZWN0MigpLCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzLnBhZGRpbmdUb3AgfHwgMCA9PT0gcHJvcHMucGFkZGluZ1RvcCA/IHByb3BzLnBhZGRpbmdUb3AgPiAyOSA/IHByb3BzLnBhZGRpbmdUb3AgLSAxMCA6IHByb3BzLnBhZGRpbmdUb3AgOiB1dGlscy5ndXR0ZXJfbWQ7XG59LCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzLnBhZGRpbmdSaWdodCB8fCAwID09PSBwcm9wcy5wYWRkaW5nUmlnaHQgPyBwcm9wcy5wYWRkaW5nUmlnaHQgPiAyOSA/IHByb3BzLnBhZGRpbmdSaWdodCAtIDEwIDogcHJvcHMucGFkZGluZ1JpZ2h0IDogdXRpbHMuZ3V0dGVyX21kO1xufSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5wYWRkaW5nQm90dG9tIHx8IDAgPT09IHByb3BzLnBhZGRpbmdCb3R0b20gPyBwcm9wcy5wYWRkaW5nQm90dG9tID4gMjkgPyBwcm9wcy5wYWRkaW5nQm90dG9tIC0gMTAgOiBwcm9wcy5wYWRkaW5nQm90dG9tIDogdXRpbHMuZ3V0dGVyX21kO1xufSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5wYWRkaW5nTGVmdCB8fCAwID09PSBwcm9wcy5wYWRkaW5nTGVmdCA/IHByb3BzLnBhZGRpbmdMZWZ0ID4gMjkgPyBwcm9wcy5wYWRkaW5nTGVmdCAtIDEwIDogcHJvcHMucGFkZGluZ0xlZnQgOiB1dGlscy5ndXR0ZXJfbWQ7XG59LCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzLmJvcmRlclRvcCB8fCAwID09PSBwcm9wcy5ib3JkZXJUb3AgPyBwcm9wcy5ib3JkZXJUb3AgOiAwO1xufSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5ib3JkZXJCb3R0b20gfHwgMCA9PT0gcHJvcHMuYm9yZGVyQm90dG9tID8gcHJvcHMuYm9yZGVyQm90dG9tIDogMDtcbn0sIGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gcHJvcHMuYWxpZ25tZW50IHx8ICdsZWZ0Jztcbn0sIGRldmljZS50YWJsZXQsIGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gcHJvcHMucGFkZGluZ1RvcCB8fCAwID09PSBwcm9wcy5wYWRkaW5nVG9wID8gcHJvcHMucGFkZGluZ1RvcCA6IHV0aWxzLmd1dHRlcjtcbn0sIGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gcHJvcHMucGFkZGluZ1JpZ2h0IHx8IDAgPT09IHByb3BzLnBhZGRpbmdSaWdodCA/IHByb3BzLnBhZGRpbmdSaWdodCA6IHV0aWxzLmd1dHRlcjtcbn0sIGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gcHJvcHMucGFkZGluZ0JvdHRvbSB8fCAwID09PSBwcm9wcy5wYWRkaW5nQm90dG9tID8gcHJvcHMucGFkZGluZ0JvdHRvbSA6IHV0aWxzLmd1dHRlcjtcbn0sIGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gcHJvcHMucGFkZGluZ0xlZnQgfHwgMCA9PT0gcHJvcHMucGFkZGluZ0xlZnQgPyBwcm9wcy5wYWRkaW5nTGVmdCA6IHV0aWxzLmd1dHRlcjtcbn0pO1xudmFyIEJveEJvZHkgPSBmdW5jdGlvbiBCb3hCb2R5KF9yZWY0KSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmNC5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWY0LmNoaWxkcmVuLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjQsIFtcImNsYXNzTmFtZVwiLCBcImNoaWxkcmVuXCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQm9keSwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gIH0sIHByb3BzKSwgY2hpbGRyZW4pO1xufTtcbnZhciBGb290ZXIgPSBzdHlsZWQuZGl2LmF0dHJzKGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4ge1xuICAgIHByb3BzOiBwcm9wc1xuICB9O1xufSkoX3RlbXBsYXRlT2JqZWN0MygpLCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuICdibG9jaycgIT09IHByb3BzLmRpc3BsYXkgPyAnZmxleCcgOiAnYmxvY2snO1xufSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiAnYmxvY2snICE9PSBwcm9wcy5kaXNwbGF5ICYmICdmbGV4LWZsb3c6IHJvdyB3cmFwOyc7XG59LCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuICdibG9jaycgIT09IHByb3BzLmRpc3BsYXkgJiYgKCdsZWZ0JyA9PT0gcHJvcHMuYWxpZ25tZW50IHx8ICdyaWdodCcgPT09IHByb3BzLmFsaWdubWVudCB8fCAnY2VudGVyJyA9PT0gcHJvcHMuYWxpZ25tZW50KSA/ICdsZWZ0JyA9PT0gcHJvcHMuYWxpZ25tZW50ID8gJ2p1c3RpZnktY29udGVudDogZmxleC1zdGFydDsnIDogJ3JpZ2h0JyA9PT0gcHJvcHMuYWxpZ25tZW50ID8gJ2p1c3RpZnktY29udGVudDogZmxleC1lbmQ7JyA6ICdqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsnIDogJ2p1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjsnO1xufSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5wYWRkaW5nVG9wIHx8IDAgPT09IHByb3BzLnBhZGRpbmdUb3AgPyBwcm9wcy5wYWRkaW5nVG9wID4gMjkgPyBwcm9wcy5wYWRkaW5nVG9wIC0gMTAgOiBwcm9wcy5wYWRkaW5nVG9wIDogdXRpbHMuZ3V0dGVyX21kO1xufSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5wYWRkaW5nUmlnaHQgfHwgMCA9PT0gcHJvcHMucGFkZGluZ1JpZ2h0ID8gcHJvcHMucGFkZGluZ1JpZ2h0ID4gMjkgPyBwcm9wcy5wYWRkaW5nUmlnaHQgLSAxMCA6IHByb3BzLnBhZGRpbmdSaWdodCA6IHV0aWxzLmd1dHRlcl9tZDtcbn0sIGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gcHJvcHMucGFkZGluZ0JvdHRvbSB8fCAwID09PSBwcm9wcy5wYWRkaW5nQm90dG9tID8gcHJvcHMucGFkZGluZ0JvdHRvbSA+IDI5ID8gcHJvcHMucGFkZGluZ0JvdHRvbSAtIDEwIDogcHJvcHMucGFkZGluZ0JvdHRvbSA6IHV0aWxzLmd1dHRlcl9tZDtcbn0sIGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gcHJvcHMucGFkZGluZ0xlZnQgfHwgMCA9PT0gcHJvcHMucGFkZGluZ0xlZnQgPyBwcm9wcy5wYWRkaW5nTGVmdCA+IDI5ID8gcHJvcHMucGFkZGluZ0xlZnQgLSAxMCA6IHByb3BzLnBhZGRpbmdMZWZ0IDogdXRpbHMuZ3V0dGVyX21kO1xufSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5ib3JkZXIgfHwgMCA9PT0gcHJvcHMuYm9yZGVyIHx8ICcnID09PSBwcm9wcy5ib3JkZXIgPyBwcm9wcy5ib3JkZXIgOiAxO1xufSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiAnYmxvY2snID09PSBwcm9wcy5kaXNwbGF5ICYmICgncmlnaHQnID09PSBwcm9wcy5hbGlnbm1lbnQgfHwgJ2NlbnRlcicgPT09IHByb3BzLmFsaWdubWVudCkgJiYgJ3RleHQtYWxpZ246ICcgKyBwcm9wcy5hbGlnbm1lbnQgKyAnOyc7XG59LCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuICdibG9jaycgIT09IHByb3BzLmRpc3BsYXkgJiYgJz4gKiB7IG1heC13aWR0aDogMTAwJTsgZmxleDogMCAwIGF1dG87IH0nO1xufSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiAnYmxvY2snICE9PSBwcm9wcy5kaXNwbGF5ICYmICc+ICogKyAqIHsgbWFyZ2luLWxlZnQ6IDEwcHg7IH0nO1xufSwgZGV2aWNlLnRhYmxldCwgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5wYWRkaW5nVG9wIHx8IDAgPT09IHByb3BzLnBhZGRpbmdUb3AgPyBwcm9wcy5wYWRkaW5nVG9wIDogdXRpbHMuZ3V0dGVyO1xufSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5wYWRkaW5nUmlnaHQgfHwgMCA9PT0gcHJvcHMucGFkZGluZ1JpZ2h0ID8gcHJvcHMucGFkZGluZ1JpZ2h0IDogdXRpbHMuZ3V0dGVyO1xufSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5wYWRkaW5nQm90dG9tIHx8IDAgPT09IHByb3BzLnBhZGRpbmdCb3R0b20gPyBwcm9wcy5wYWRkaW5nQm90dG9tIDogdXRpbHMuZ3V0dGVyO1xufSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5wYWRkaW5nTGVmdCB8fCAwID09PSBwcm9wcy5wYWRkaW5nTGVmdCA/IHByb3BzLnBhZGRpbmdMZWZ0IDogdXRpbHMuZ3V0dGVyO1xufSk7XG52YXIgQm94Rm9vdGVyID0gZnVuY3Rpb24gQm94Rm9vdGVyKF9yZWY1KSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmNS5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWY1LmNoaWxkcmVuLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjUsIFtcImNsYXNzTmFtZVwiLCBcImNoaWxkcmVuXCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9vdGVyLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgfSwgcHJvcHMpLCBjaGlsZHJlbik7XG59O1xudmFyIEJveFNlY3Rpb24gPSBmdW5jdGlvbiBCb3hTZWN0aW9uKF9yZWY2KSB7XG4gIHZhciB0aXRsZSA9IF9yZWY2LnRpdGxlLFxuICAgICAgZGVzY3JpcHRpb24gPSBfcmVmNi5kZXNjcmlwdGlvbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWY2LmNsYXNzTmFtZSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZjYuY2hpbGRyZW4sXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNiwgW1widGl0bGVcIiwgXCJkZXNjcmlwdGlvblwiLCBcImNsYXNzTmFtZVwiLCBcImNoaWxkcmVuXCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBjbGFzc05hbWUgJiYgJycgIT09IGNsYXNzTmFtZSA/IFwic3VpLWJveC1zZXR0aW5ncy1yb3cgXCIuY29uY2F0KGNsYXNzTmFtZSkgOiAnc3VpLWJveC1zZXR0aW5ncy1yb3cnXG4gIH0sIHByb3BzKSwgKHRpdGxlICYmIFwiXCIgIT09IHRpdGxlIHx8IGRlc2NyaXB0aW9uICYmIFwiXCIgIT09IGRlc2NyaXB0aW9uKSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInN1aS1ib3gtc2V0dGluZ3MtY29sLTFcIlxuICB9LCBcIlwiICE9PSB0aXRsZSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtcbiAgICBjbGFzc05hbWU6IFwic3VpLXNldHRpbmdzLWxhYmVsXCJcbiAgfSwgdGl0bGUpLCBcIlwiICE9PSBkZXNjcmlwdGlvbiAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwge1xuICAgIGNsYXNzTmFtZTogXCJzdWktZGVzY3JpcHRpb25cIlxuICB9LCBkZXNjcmlwdGlvbikpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInN1aS1ib3gtc2V0dGluZ3MtY29sLTJcIlxuICB9LCBjaGlsZHJlbikpO1xufTtcblxuZXhwb3J0IHsgQm94LCBCb3hCb2R5LCBCb3hGb290ZXIsIEJveEhlYWRlciwgQm94U2VjdGlvbiwgQm94VGl0bGUgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B3cG11ZGV2L3JlYWN0LWJveC9kaXN0L3JlYWN0LWJveC5lc20uanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIDMiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVwbG9hZHMgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRjbGVhckltYWdlKCkge1xuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIG9uIGZpZWxkIHNldHRpbmdzXG5cdFx0aWYgKCAnYW5zd2VyX2ltYWdlJyA9PT0gdGhpcy5wcm9wcy5wcm9wZXJ0eSApIHtcblx0XHRcdGNvbnN0IGFuc3dlciAgID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMucHJvcHMuYW5zd2VyICk7XG5cdFx0XHRjb25zdCBwcm9wZXJ0eSA9IHRoaXMucHJvcHMucHJvcGVydHk7XG5cblx0XHRcdGFuc3dlcltwcm9wZXJ0eV0gXHRcdCAgXHQgICA9ICcnO1xuXHRcdFx0YW5zd2VyW3Byb3BlcnR5ICsgJ19maWxlbmFtZSddID0gJyc7XG5cdFx0XHRhbnN3ZXJbcHJvcGVydHkgKyAnX2FsdCddXHQgICA9ICcnO1xuXG5cdFx0XHR0aGlzLnByb3BzLmFjdGlvbnMuYnVpbGRlckFjdGlvbnMudXBkYXRlQW5zd2VyKCBhbnN3ZXIgKTtcblx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdGhpcy5wcm9wcy51cGRhdGVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkoIHRoaXMucHJvcHMucHJvcGVydHksICcnICk7XG5cdFx0XHR0aGlzLnByb3BzLnVwZGF0ZVByb3BlcnR5KCB0aGlzLnByb3BzLnByb3BlcnR5ICsgJ19maWxlbmFtZScsICcnICk7XG5cdFx0XHR0aGlzLnByb3BzLnVwZGF0ZVByb3BlcnR5KCB0aGlzLnByb3BzLnByb3BlcnR5ICsgJ19hbHQnLCAnJyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBDbGVhciBpbWFnZVxuXHRcdFx0dGhpcy5wcm9wcy5hY3Rpb25zLnNldHRpbmdzQWN0aW9ucy51cGRhdGVTZXR0aW5nKCB0aGlzLnByb3BzLnByb3BlcnR5LCAnJyApO1xuXHRcdFx0dGhpcy5wcm9wcy5hY3Rpb25zLnNldHRpbmdzQWN0aW9ucy51cGRhdGVTZXR0aW5nKCB0aGlzLnByb3BzLnByb3BlcnR5ICsgJ19maWxlbmFtZScsICcnICk7XG5cdFx0XHR0aGlzLnByb3BzLmFjdGlvbnMuc2V0dGluZ3NBY3Rpb25zLnVwZGF0ZVNldHRpbmcoIHRoaXMucHJvcHMucHJvcGVydHkgKyAnX2FsdCcsICcnICk7XG5cdFx0fVxuXHR9XG5cblx0b3Blbk1lZGlhKCkge1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdFx0Y29uc3QgbWVkaWEgPSB3cC5tZWRpYSgge1xuXHRcdFx0dGl0bGU6IHRyYW5zbGF0ZSggJ1NlbGVjdCBpbWFnZScgKSxcblx0XHRcdGJ1dHRvbjoge1xuXHRcdFx0XHR0ZXh0OiB0cmFuc2xhdGUoICdTZWxlY3QnICksXG5cdFx0XHR9LFxuXHRcdFx0bXVsdGlwbGU6IGZhbHNlLFxuXHRcdH0gKS5vbiggJ3NlbGVjdCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0bGV0IGltYWdlVXJsO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gbWVkaWEuc3RhdGUoKS5nZXQoICdzZWxlY3Rpb24nICkuZmlyc3QoKS50b0pTT04oKTtcblxuXHRcdFx0Ly8gV2UgY2FuIGhhdmUgMyB0eXBlcyBvZiBpbWFnZSBzaXplOiB0aHVtYm5haWwsIG1lZGl1bSwgbGFyZ2UsIGVsc2UgZnVsbCBpbWFnZSB3aWxsIGJlIHVzZWRcblx0XHRcdGlmICggISBfLmlzVW5kZWZpbmVkKCBzZWxmLnByb3BzLmltYWdlU2l6ZSApICkge1xuXHRcdFx0XHRpZiAoIHNlbGYucHJvcHMuaW1hZ2VTaXplID09PSAndGh1bWJuYWlsJyApIHtcblx0XHRcdFx0XHRpbWFnZVVybCA9IHJlc3VsdC5zaXplcy50aHVtYm5haWwudXJsO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBzZWxmLnByb3BzLmltYWdlU2l6ZSA9PT0gJ21lZGl1bScgKSB7XG5cdFx0XHRcdFx0aWYgKCBfLmlzVW5kZWZpbmVkKCByZXN1bHQuc2l6ZXMubWVkaXVtICkgKSB7XG5cdFx0XHRcdFx0XHRpbWFnZVVybCA9IHJlc3VsdC5zaXplcy5mdWxsLnVybDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aW1hZ2VVcmwgPSByZXN1bHQuc2l6ZXMubWVkaXVtLnVybDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHNlbGYucHJvcHMuaW1hZ2VTaXplID09PSAnbGFyZ2UnICkge1xuXHRcdFx0XHRcdGlmICggXy5pc1VuZGVmaW5lZCggcmVzdWx0LnNpemVzLmxhcmdlICkgKSB7XG5cdFx0XHRcdFx0XHRpbWFnZVVybCA9IHJlc3VsdC5zaXplcy5mdWxsLnVybDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aW1hZ2VVcmwgPSByZXN1bHQuc2l6ZXMubGFyZ2UudXJsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpbWFnZVVybCA9IHJlc3VsdC5zaXplcy5mdWxsLnVybDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gZnVsbCBpbWFnZVxuXHRcdFx0XHRpbWFnZVVybCA9IHJlc3VsdC51cmw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGlmIHdlJ3JlIG9uIGZpZWxkIHNldHRpbmdzXG5cdFx0XHRpZiAoIHR5cGVvZiBzZWxmLnByb3BzLnVwZGF0ZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRzZWxmLnByb3BzLnVwZGF0ZVByb3BlcnR5KCBzZWxmLnByb3BzLnByb3BlcnR5LCBpbWFnZVVybCApO1xuXHRcdFx0XHRzZWxmLnByb3BzLnVwZGF0ZVByb3BlcnR5KCBzZWxmLnByb3BzLnByb3BlcnR5ICsgJ19maWxlbmFtZScsIHJlc3VsdC5maWxlbmFtZSApO1xuXHRcdFx0XHRzZWxmLnByb3BzLnVwZGF0ZVByb3BlcnR5KCBzZWxmLnByb3BzLnByb3BlcnR5ICsgJ19hbHQnLCByZXN1bHQuYWx0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLnByb3BzLmFjdGlvbnMuc2V0dGluZ3NBY3Rpb25zLnVwZGF0ZVNldHRpbmcoIHNlbGYucHJvcHMucHJvcGVydHksIGltYWdlVXJsICk7XG5cdFx0XHRcdHNlbGYucHJvcHMuYWN0aW9ucy5zZXR0aW5nc0FjdGlvbnMudXBkYXRlU2V0dGluZyggc2VsZi5wcm9wcy5wcm9wZXJ0eSArICdfZmlsZW5hbWUnLCByZXN1bHQuZmlsZW5hbWUgKTtcblx0XHRcdFx0c2VsZi5wcm9wcy5hY3Rpb25zLnNldHRpbmdzQWN0aW9ucy51cGRhdGVTZXR0aW5nKCBzZWxmLnByb3BzLnByb3BlcnR5ICsgJ19hbHQnLCByZXN1bHQuYWx0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0bWVkaWEub3BlbigpO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IHZhbHVlID0gXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdIClcblx0XHRcdD8gdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWVcblx0XHRcdDogdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdO1xuXG5cdFx0Y29uc3QgaGFzVmFsdWVDbGFzcyA9ICEgXy5pc0VtcHR5KCB2YWx1ZSApID8gJ3N1aS1oYXNfZmlsZScgOiAnJztcblxuXHRcdGxldCBmaWxlbmFtZSA9IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgKyAnX2ZpbGVuYW1lJyBdIClcblx0XHRcdD8gdmFsdWVcblx0XHRcdDogXy5pc0VtcHR5KCB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5ICsgJ19maWxlbmFtZScgXSApICYmICEgXy5pc051bGwoIHZhbHVlIClcblx0XHRcdD8gdmFsdWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpXG5cdFx0XHQ6IHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgKyAnX2ZpbGVuYW1lJyBdO1xuXG5cdFx0bGV0IGZpZWxkTGFiZWwgPSAnJztcblxuXHRcdGlmICggdGhpcy5wcm9wcy5sYWJlbCApIHtcblx0XHRcdGZpZWxkTGFiZWwgPSAoXG5cdFx0XHRcdDxsYWJlbCBjbGFzc05hbWU9XCJzdWktbGFiZWxcIj57IHRoaXMucHJvcHMubGFiZWwgfTwvbGFiZWw+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGxldCBmaWVsZERlc2NyaXB0aW9uID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMuZGVzY3JpcHRpb24gKSB7XG5cdFx0XHRmaWVsZERlc2NyaXB0aW9uID0gKFxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj57IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gfTwvc3Bhbj5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0bGV0IHByZXZpZXcgPSAnJztcblxuXHRcdGlmICggJ2ltYWdlJyA9PT0gdGhpcy5wcm9wcy50eXBlICkge1xuXHRcdFx0bGV0IGJnSW1hZ2UgPSAnJztcblxuXHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0YmdJbWFnZSA9ICd1cmwoJyArIHZhbHVlICsgJyknO1xuXHRcdFx0fVxuXG5cdFx0XHRwcmV2aWV3ID0gKFxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS11cGxvYWQtaW1hZ2VcIlxuXHRcdFx0XHRcdGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWltYWdlLW1hc2tcIj48L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2IHJvbGU9XCJidXR0b25cIiBvbkNsaWNrPXsgdGhpcy5vcGVuTWVkaWEuYmluZCggdGhpcyApIH1cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1pbWFnZS1wcmV2aWV3XCJcblx0XHRcdFx0XHRcdHN0eWxlPXsgeyBiYWNrZ3JvdW5kSW1hZ2U6IGJnSW1hZ2UgfSB9PjwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZmllbGRDbGFzcyA9IHRoaXMucHJvcHMuZmllbGRDbGFzc1xuXHRcdFx0PyAnICcgKyB0aGlzLnByb3BzLmZpZWxkQ2xhc3Ncblx0XHRcdDogJydcblx0XHRcdDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT17IGBzdWktZm9ybS1maWVsZCR7IGZpZWxkQ2xhc3MgfWAgfT5cblx0XHRcdFx0eyBmaWVsZExhYmVsIH1cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9eyBgc3VpLXVwbG9hZCAkeyBoYXNWYWx1ZUNsYXNzIH1gIH0+XG5cdFx0XHRcdFx0PGlucHV0IHR5cGU9XCJmaWxlXCJcblx0XHRcdFx0XHRcdHZhbHVlPVwiXCJcblx0XHRcdFx0XHRcdHJlYWRPbmx5PVwicmVhZG9ubHlcIiAvPlxuXHRcdFx0XHRcdHsgcHJldmlldyB9XG5cdFx0XHRcdFx0PGJ1dHRvbiBjbGFzc05hbWU9XCJzdWktdXBsb2FkLWJ1dHRvblwiIG9uQ2xpY2s9eyB0aGlzLm9wZW5NZWRpYS5iaW5kKCB0aGlzICkgfT5cblx0XHRcdFx0XHRcdDxpIGNsYXNzTmFtZT1cInN1aS1pY29uLXVwbG9hZC1jbG91ZFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cblx0XHRcdFx0XHRcdHsgKCAnaW1hZ2UnID09PSB0aGlzLnByb3BzLnR5cGUgKVxuXHRcdFx0XHRcdFx0XHQ/IGAkeyB0cmFuc2xhdGUoICdVcGxvYWQgaW1hZ2UnICkgfWBcblx0XHRcdFx0XHRcdFx0OiBgJHsgdHJhbnNsYXRlKCAnVXBsb2FkIGZpbGUnICkgfWBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS11cGxvYWQtZmlsZVwiPlxuXHRcdFx0XHRcdFx0PHNwYW4gdGl0bGU9eyBmaWxlbmFtZSB9PnsgZmlsZW5hbWUgfTwvc3Bhbj5cblx0XHRcdFx0XHRcdDxidXR0b24gY2xhc3NOYW1lPVwic3VpLXVwbG9hZC1idXR0b24tLXJlbW92ZVwiIG9uQ2xpY2s9eyB0aGlzLmNsZWFySW1hZ2UuYmluZCggdGhpcyApIH0+XG5cdFx0XHRcdFx0XHRcdDxpIGNsYXNzTmFtZT1cInN1aS1pY29uLWNsb3NlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktc2NyZWVuLXJlYWRlci10ZXh0XCI+XG5cdFx0XHRcdFx0XHRcdFx0eyAoICdpbWFnZScgPT09IHRoaXMucHJvcHMudHlwZSApXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGAkeyB0cmFuc2xhdGUoICdSZW1vdmUgdXBsb2FkZWQgaW1hZ2UnICkgfWBcblx0XHRcdFx0XHRcdFx0XHRcdDogYCR7IHRyYW5zbGF0ZSggJ1JlbW92ZSB1cGxvYWRlZCBmaWxlJyApIH1gXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdHsgZmllbGREZXNjcmlwdGlvbiB9XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MvaW5wdXRzL3VwbG9hZHMuanMiLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5leHBvcnQgdmFyIHN1YnNjcmlwdGlvblNoYXBlID0gUHJvcFR5cGVzLnNoYXBlKHtcbiAgdHJ5U3Vic2NyaWJlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB0cnlVbnN1YnNjcmliZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgbm90aWZ5TmVzdGVkU3ViczogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgaXNTdWJzY3JpYmVkOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59KTtcblxuZXhwb3J0IHZhciBzdG9yZVNoYXBlID0gUHJvcFR5cGVzLnNoYXBlKHtcbiAgc3Vic2NyaWJlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBkaXNwYXRjaDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZ2V0U3RhdGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL1Byb3BUeXBlcy5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IGhvaXN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgeyBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBTdWJzY3JpcHRpb24gZnJvbSAnLi4vdXRpbHMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IHN0b3JlU2hhcGUsIHN1YnNjcmlwdGlvblNoYXBlIH0gZnJvbSAnLi4vdXRpbHMvUHJvcFR5cGVzJztcblxudmFyIGhvdFJlbG9hZGluZ1ZlcnNpb24gPSAwO1xudmFyIGR1bW15U3RhdGUgPSB7fTtcbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZnVuY3Rpb24gbWFrZVNlbGVjdG9yU3RhdGVmdWwoc291cmNlU2VsZWN0b3IsIHN0b3JlKSB7XG4gIC8vIHdyYXAgdGhlIHNlbGVjdG9yIGluIGFuIG9iamVjdCB0aGF0IHRyYWNrcyBpdHMgcmVzdWx0cyBiZXR3ZWVuIHJ1bnMuXG4gIHZhciBzZWxlY3RvciA9IHtcbiAgICBydW46IGZ1bmN0aW9uIHJ1bkNvbXBvbmVudFNlbGVjdG9yKHByb3BzKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmV4dFByb3BzID0gc291cmNlU2VsZWN0b3Ioc3RvcmUuZ2V0U3RhdGUoKSwgcHJvcHMpO1xuICAgICAgICBpZiAobmV4dFByb3BzICE9PSBzZWxlY3Rvci5wcm9wcyB8fCBzZWxlY3Rvci5lcnJvcikge1xuICAgICAgICAgIHNlbGVjdG9yLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgc2VsZWN0b3IucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICAgICAgc2VsZWN0b3IuZXJyb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSB0cnVlO1xuICAgICAgICBzZWxlY3Rvci5lcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZWN0b3I7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbm5lY3RBZHZhbmNlZChcbi8qXG4gIHNlbGVjdG9yRmFjdG9yeSBpcyBhIGZ1bmMgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgcmV0dXJuaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB1c2VkIHRvXG4gIGNvbXB1dGUgbmV3IHByb3BzIGZyb20gc3RhdGUsIHByb3BzLCBhbmQgZGlzcGF0Y2guIEZvciBleGFtcGxlOlxuICAgICBleHBvcnQgZGVmYXVsdCBjb25uZWN0QWR2YW5jZWQoKGRpc3BhdGNoLCBvcHRpb25zKSA9PiAoc3RhdGUsIHByb3BzKSA9PiAoe1xuICAgICAgdGhpbmc6IHN0YXRlLnRoaW5nc1twcm9wcy50aGluZ0lkXSxcbiAgICAgIHNhdmVUaGluZzogZmllbGRzID0+IGRpc3BhdGNoKGFjdGlvbkNyZWF0b3JzLnNhdmVUaGluZyhwcm9wcy50aGluZ0lkLCBmaWVsZHMpKSxcbiAgICB9KSkoWW91ckNvbXBvbmVudClcbiAgIEFjY2VzcyB0byBkaXNwYXRjaCBpcyBwcm92aWRlZCB0byB0aGUgZmFjdG9yeSBzbyBzZWxlY3RvckZhY3RvcmllcyBjYW4gYmluZCBhY3Rpb25DcmVhdG9yc1xuICBvdXRzaWRlIG9mIHRoZWlyIHNlbGVjdG9yIGFzIGFuIG9wdGltaXphdGlvbi4gT3B0aW9ucyBwYXNzZWQgdG8gY29ubmVjdEFkdmFuY2VkIGFyZSBwYXNzZWQgdG9cbiAgdGhlIHNlbGVjdG9yRmFjdG9yeSwgYWxvbmcgd2l0aCBkaXNwbGF5TmFtZSBhbmQgV3JhcHBlZENvbXBvbmVudCwgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgIE5vdGUgdGhhdCBzZWxlY3RvckZhY3RvcnkgaXMgcmVzcG9uc2libGUgZm9yIGFsbCBjYWNoaW5nL21lbW9pemF0aW9uIG9mIGluYm91bmQgYW5kIG91dGJvdW5kXG4gIHByb3BzLiBEbyBub3QgdXNlIGNvbm5lY3RBZHZhbmNlZCBkaXJlY3RseSB3aXRob3V0IG1lbW9pemluZyByZXN1bHRzIGJldHdlZW4gY2FsbHMgdG8geW91clxuICBzZWxlY3Rvciwgb3RoZXJ3aXNlIHRoZSBDb25uZWN0IGNvbXBvbmVudCB3aWxsIHJlLXJlbmRlciBvbiBldmVyeSBzdGF0ZSBvciBwcm9wcyBjaGFuZ2UuXG4qL1xuc2VsZWN0b3JGYWN0b3J5KSB7XG4gIHZhciBfY29udGV4dFR5cGVzLCBfY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgX3JlZiRnZXREaXNwbGF5TmFtZSA9IF9yZWYuZ2V0RGlzcGxheU5hbWUsXG4gICAgICBnZXREaXNwbGF5TmFtZSA9IF9yZWYkZ2V0RGlzcGxheU5hbWUgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICdDb25uZWN0QWR2YW5jZWQoJyArIG5hbWUgKyAnKSc7XG4gIH0gOiBfcmVmJGdldERpc3BsYXlOYW1lLFxuICAgICAgX3JlZiRtZXRob2ROYW1lID0gX3JlZi5tZXRob2ROYW1lLFxuICAgICAgbWV0aG9kTmFtZSA9IF9yZWYkbWV0aG9kTmFtZSA9PT0gdW5kZWZpbmVkID8gJ2Nvbm5lY3RBZHZhbmNlZCcgOiBfcmVmJG1ldGhvZE5hbWUsXG4gICAgICBfcmVmJHJlbmRlckNvdW50UHJvcCA9IF9yZWYucmVuZGVyQ291bnRQcm9wLFxuICAgICAgcmVuZGVyQ291bnRQcm9wID0gX3JlZiRyZW5kZXJDb3VudFByb3AgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF9yZWYkcmVuZGVyQ291bnRQcm9wLFxuICAgICAgX3JlZiRzaG91bGRIYW5kbGVTdGF0ID0gX3JlZi5zaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMgPSBfcmVmJHNob3VsZEhhbmRsZVN0YXQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmJHNob3VsZEhhbmRsZVN0YXQsXG4gICAgICBfcmVmJHN0b3JlS2V5ID0gX3JlZi5zdG9yZUtleSxcbiAgICAgIHN0b3JlS2V5ID0gX3JlZiRzdG9yZUtleSA9PT0gdW5kZWZpbmVkID8gJ3N0b3JlJyA6IF9yZWYkc3RvcmVLZXksXG4gICAgICBfcmVmJHdpdGhSZWYgPSBfcmVmLndpdGhSZWYsXG4gICAgICB3aXRoUmVmID0gX3JlZiR3aXRoUmVmID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkd2l0aFJlZixcbiAgICAgIGNvbm5lY3RPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnZ2V0RGlzcGxheU5hbWUnLCAnbWV0aG9kTmFtZScsICdyZW5kZXJDb3VudFByb3AnLCAnc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzJywgJ3N0b3JlS2V5JywgJ3dpdGhSZWYnXSk7XG5cbiAgdmFyIHN1YnNjcmlwdGlvbktleSA9IHN0b3JlS2V5ICsgJ1N1YnNjcmlwdGlvbic7XG4gIHZhciB2ZXJzaW9uID0gaG90UmVsb2FkaW5nVmVyc2lvbisrO1xuXG4gIHZhciBjb250ZXh0VHlwZXMgPSAoX2NvbnRleHRUeXBlcyA9IHt9LCBfY29udGV4dFR5cGVzW3N0b3JlS2V5XSA9IHN0b3JlU2hhcGUsIF9jb250ZXh0VHlwZXNbc3Vic2NyaXB0aW9uS2V5XSA9IHN1YnNjcmlwdGlvblNoYXBlLCBfY29udGV4dFR5cGVzKTtcbiAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gKF9jaGlsZENvbnRleHRUeXBlcyA9IHt9LCBfY2hpbGRDb250ZXh0VHlwZXNbc3Vic2NyaXB0aW9uS2V5XSA9IHN1YnNjcmlwdGlvblNoYXBlLCBfY2hpbGRDb250ZXh0VHlwZXMpO1xuXG4gIHJldHVybiBmdW5jdGlvbiB3cmFwV2l0aENvbm5lY3QoV3JhcHBlZENvbXBvbmVudCkge1xuICAgIGludmFyaWFudCh0eXBlb2YgV3JhcHBlZENvbXBvbmVudCA9PSAnZnVuY3Rpb24nLCAnWW91IG11c3QgcGFzcyBhIGNvbXBvbmVudCB0byB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgJyArIChtZXRob2ROYW1lICsgJy4gSW5zdGVhZCByZWNlaXZlZCAnICsgSlNPTi5zdHJpbmdpZnkoV3JhcHBlZENvbXBvbmVudCkpKTtcblxuICAgIHZhciB3cmFwcGVkQ29tcG9uZW50TmFtZSA9IFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xuXG4gICAgdmFyIGRpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWUod3JhcHBlZENvbXBvbmVudE5hbWUpO1xuXG4gICAgdmFyIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgY29ubmVjdE9wdGlvbnMsIHtcbiAgICAgIGdldERpc3BsYXlOYW1lOiBnZXREaXNwbGF5TmFtZSxcbiAgICAgIG1ldGhvZE5hbWU6IG1ldGhvZE5hbWUsXG4gICAgICByZW5kZXJDb3VudFByb3A6IHJlbmRlckNvdW50UHJvcCxcbiAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlczogc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgc3RvcmVLZXk6IHN0b3JlS2V5LFxuICAgICAgd2l0aFJlZjogd2l0aFJlZixcbiAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgIHdyYXBwZWRDb21wb25lbnROYW1lOiB3cmFwcGVkQ29tcG9uZW50TmFtZSxcbiAgICAgIFdyYXBwZWRDb21wb25lbnQ6IFdyYXBwZWRDb21wb25lbnRcbiAgICB9KTtcblxuICAgIHZhciBDb25uZWN0ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICAgIF9pbmhlcml0cyhDb25uZWN0LCBfQ29tcG9uZW50KTtcblxuICAgICAgZnVuY3Rpb24gQ29ubmVjdChwcm9wcywgY29udGV4dCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29ubmVjdCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSk7XG5cbiAgICAgICAgX3RoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIF90aGlzLnN0YXRlID0ge307XG4gICAgICAgIF90aGlzLnJlbmRlckNvdW50ID0gMDtcbiAgICAgICAgX3RoaXMuc3RvcmUgPSBwcm9wc1tzdG9yZUtleV0gfHwgY29udGV4dFtzdG9yZUtleV07XG4gICAgICAgIF90aGlzLnByb3BzTW9kZSA9IEJvb2xlYW4ocHJvcHNbc3RvcmVLZXldKTtcbiAgICAgICAgX3RoaXMuc2V0V3JhcHBlZEluc3RhbmNlID0gX3RoaXMuc2V0V3JhcHBlZEluc3RhbmNlLmJpbmQoX3RoaXMpO1xuXG4gICAgICAgIGludmFyaWFudChfdGhpcy5zdG9yZSwgJ0NvdWxkIG5vdCBmaW5kIFwiJyArIHN0b3JlS2V5ICsgJ1wiIGluIGVpdGhlciB0aGUgY29udGV4dCBvciBwcm9wcyBvZiAnICsgKCdcIicgKyBkaXNwbGF5TmFtZSArICdcIi4gRWl0aGVyIHdyYXAgdGhlIHJvb3QgY29tcG9uZW50IGluIGEgPFByb3ZpZGVyPiwgJykgKyAoJ29yIGV4cGxpY2l0bHkgcGFzcyBcIicgKyBzdG9yZUtleSArICdcIiBhcyBhIHByb3AgdG8gXCInICsgZGlzcGxheU5hbWUgKyAnXCIuJykpO1xuXG4gICAgICAgIF90aGlzLmluaXRTZWxlY3RvcigpO1xuICAgICAgICBfdGhpcy5pbml0U3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICB2YXIgX3JlZjI7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBjb21wb25lbnQgcmVjZWl2ZWQgc3RvcmUgZnJvbSBwcm9wcywgaXRzIHN1YnNjcmlwdGlvbiBzaG91bGQgYmUgdHJhbnNwYXJlbnRcbiAgICAgICAgLy8gdG8gYW55IGRlc2NlbmRhbnRzIHJlY2VpdmluZyBzdG9yZStzdWJzY3JpcHRpb24gZnJvbSBjb250ZXh0OyBpdCBwYXNzZXMgYWxvbmdcbiAgICAgICAgLy8gc3Vic2NyaXB0aW9uIHBhc3NlZCB0byBpdC4gT3RoZXJ3aXNlLCBpdCBzaGFkb3dzIHRoZSBwYXJlbnQgc3Vic2NyaXB0aW9uLCB3aGljaCBhbGxvd3NcbiAgICAgICAgLy8gQ29ubmVjdCB0byBjb250cm9sIG9yZGVyaW5nIG9mIG5vdGlmaWNhdGlvbnMgdG8gZmxvdyB0b3AtZG93bi5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMucHJvcHNNb2RlID8gbnVsbCA6IHRoaXMuc3Vic2NyaXB0aW9uO1xuICAgICAgICByZXR1cm4gX3JlZjIgPSB7fSwgX3JlZjJbc3Vic2NyaXB0aW9uS2V5XSA9IHN1YnNjcmlwdGlvbiB8fCB0aGlzLmNvbnRleHRbc3Vic2NyaXB0aW9uS2V5XSwgX3JlZjI7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuO1xuXG4gICAgICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBmaXJlcyBkdXJpbmcgc2VydmVyIHNpZGUgcmVuZGVyaW5nLCBidXQgY29tcG9uZW50RGlkTW91bnQgYW5kXG4gICAgICAgIC8vIGNvbXBvbmVudFdpbGxVbm1vdW50IGRvIG5vdC4gQmVjYXVzZSBvZiB0aGlzLCB0cnlTdWJzY3JpYmUgaGFwcGVucyBkdXJpbmcgLi4uZGlkTW91bnQuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdW5zdWJzY3JpcHRpb24gd291bGQgbmV2ZXIgdGFrZSBwbGFjZSBkdXJpbmcgU1NSLCBjYXVzaW5nIGEgbWVtb3J5IGxlYWsuXG4gICAgICAgIC8vIFRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhIGNoaWxkIGNvbXBvbmVudCBtYXkgaGF2ZSB0cmlnZ2VyZWQgYSBzdGF0ZSBjaGFuZ2UgYnlcbiAgICAgICAgLy8gZGlzcGF0Y2hpbmcgYW4gYWN0aW9uIGluIGl0cyBjb21wb25lbnRXaWxsTW91bnQsIHdlIGhhdmUgdG8gcmUtcnVuIHRoZSBzZWxlY3QgYW5kIG1heWJlXG4gICAgICAgIC8vIHJlLXJlbmRlci5cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IucnVuKHRoaXMucHJvcHMpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUpIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bihuZXh0UHJvcHMpO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGU7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHRoaXMuc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzID0gbm9vcDtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IucnVuID0gbm9vcDtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmdldFdyYXBwZWRJbnN0YW5jZSA9IGZ1bmN0aW9uIGdldFdyYXBwZWRJbnN0YW5jZSgpIHtcbiAgICAgICAgaW52YXJpYW50KHdpdGhSZWYsICdUbyBhY2Nlc3MgdGhlIHdyYXBwZWQgaW5zdGFuY2UsIHlvdSBuZWVkIHRvIHNwZWNpZnkgJyArICgneyB3aXRoUmVmOiB0cnVlIH0gaW4gdGhlIG9wdGlvbnMgYXJndW1lbnQgb2YgdGhlICcgKyBtZXRob2ROYW1lICsgJygpIGNhbGwuJykpO1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVkSW5zdGFuY2U7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5zZXRXcmFwcGVkSW5zdGFuY2UgPSBmdW5jdGlvbiBzZXRXcmFwcGVkSW5zdGFuY2UocmVmKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZEluc3RhbmNlID0gcmVmO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuaW5pdFNlbGVjdG9yID0gZnVuY3Rpb24gaW5pdFNlbGVjdG9yKCkge1xuICAgICAgICB2YXIgc291cmNlU2VsZWN0b3IgPSBzZWxlY3RvckZhY3RvcnkodGhpcy5zdG9yZS5kaXNwYXRjaCwgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBtYWtlU2VsZWN0b3JTdGF0ZWZ1bChzb3VyY2VTZWxlY3RvciwgdGhpcy5zdG9yZSk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IucnVuKHRoaXMucHJvcHMpO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuaW5pdFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIGluaXRTdWJzY3JpcHRpb24oKSB7XG4gICAgICAgIGlmICghc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSByZXR1cm47XG5cbiAgICAgICAgLy8gcGFyZW50U3ViJ3Mgc291cmNlIHNob3VsZCBtYXRjaCB3aGVyZSBzdG9yZSBjYW1lIGZyb206IHByb3BzIHZzLiBjb250ZXh0LiBBIGNvbXBvbmVudFxuICAgICAgICAvLyBjb25uZWN0ZWQgdG8gdGhlIHN0b3JlIHZpYSBwcm9wcyBzaG91bGRuJ3QgdXNlIHN1YnNjcmlwdGlvbiBmcm9tIGNvbnRleHQsIG9yIHZpY2UgdmVyc2EuXG4gICAgICAgIHZhciBwYXJlbnRTdWIgPSAodGhpcy5wcm9wc01vZGUgPyB0aGlzLnByb3BzIDogdGhpcy5jb250ZXh0KVtzdWJzY3JpcHRpb25LZXldO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGhpcy5zdG9yZSwgcGFyZW50U3ViLCB0aGlzLm9uU3RhdGVDaGFuZ2UuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gYG5vdGlmeU5lc3RlZFN1YnNgIGlzIGR1cGxpY2F0ZWQgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBjb21wb25lbnQgaXMgIHVubW91bnRlZCBpblxuICAgICAgICAvLyB0aGUgbWlkZGxlIG9mIHRoZSBub3RpZmljYXRpb24gbG9vcCwgd2hlcmUgYHRoaXMuc3Vic2NyaXB0aW9uYCB3aWxsIHRoZW4gYmUgbnVsbC4gQW5cbiAgICAgICAgLy8gZXh0cmEgbnVsbCBjaGVjayBldmVyeSBjaGFuZ2UgY2FuIGJlIGF2b2lkZWQgYnkgY29weWluZyB0aGUgbWV0aG9kIG9udG8gYHRoaXNgIGFuZCB0aGVuXG4gICAgICAgIC8vIHJlcGxhY2luZyBpdCB3aXRoIGEgbm8tb3Agb24gdW5tb3VudC4gVGhpcyBjYW4gcHJvYmFibHkgYmUgYXZvaWRlZCBpZiBTdWJzY3JpcHRpb24nc1xuICAgICAgICAvLyBsaXN0ZW5lcnMgbG9naWMgaXMgY2hhbmdlZCB0byBub3QgY2FsbCBsaXN0ZW5lcnMgdGhhdCBoYXZlIGJlZW4gdW5zdWJzY3JpYmVkIGluIHRoZVxuICAgICAgICAvLyBtaWRkbGUgb2YgdGhlIG5vdGlmaWNhdGlvbiBsb29wLlxuICAgICAgICB0aGlzLm5vdGlmeU5lc3RlZFN1YnMgPSB0aGlzLnN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzLmJpbmQodGhpcy5zdWJzY3JpcHRpb24pO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUub25TdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIG9uU3RhdGVDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IucnVuKHRoaXMucHJvcHMpO1xuXG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSA9IHRoaXMubm90aWZ5TmVzdGVkU3Vic09uQ29tcG9uZW50RGlkVXBkYXRlO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoZHVtbXlTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLm5vdGlmeU5lc3RlZFN1YnNPbkNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnNPbkNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgLy8gYGNvbXBvbmVudERpZFVwZGF0ZWAgaXMgY29uZGl0aW9uYWxseSBpbXBsZW1lbnRlZCB3aGVuIGBvblN0YXRlQ2hhbmdlYCBkZXRlcm1pbmVzIGl0XG4gICAgICAgIC8vIG5lZWRzIHRvIG5vdGlmeSBuZXN0ZWQgc3Vicy4gT25jZSBjYWxsZWQsIGl0IHVuaW1wbGVtZW50cyBpdHNlbGYgdW50aWwgZnVydGhlciBzdGF0ZVxuICAgICAgICAvLyBjaGFuZ2VzIG9jY3VyLiBEb2luZyBpdCB0aGlzIHdheSB2cyBoYXZpbmcgYSBwZXJtYW5lbnQgYGNvbXBvbmVudERpZFVwZGF0ZWAgdGhhdCBkb2VzXG4gICAgICAgIC8vIGEgYm9vbGVhbiBjaGVjayBldmVyeSB0aW1lIGF2b2lkcyBhbiBleHRyYSBtZXRob2QgY2FsbCBtb3N0IG9mIHRoZSB0aW1lLCByZXN1bHRpbmdcbiAgICAgICAgLy8gaW4gc29tZSBwZXJmIGJvb3N0LlxuICAgICAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5pc1N1YnNjcmliZWQgPSBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuc3Vic2NyaXB0aW9uKSAmJiB0aGlzLnN1YnNjcmlwdGlvbi5pc1N1YnNjcmliZWQoKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmFkZEV4dHJhUHJvcHMgPSBmdW5jdGlvbiBhZGRFeHRyYVByb3BzKHByb3BzKSB7XG4gICAgICAgIGlmICghd2l0aFJlZiAmJiAhcmVuZGVyQ291bnRQcm9wICYmICEodGhpcy5wcm9wc01vZGUgJiYgdGhpcy5zdWJzY3JpcHRpb24pKSByZXR1cm4gcHJvcHM7XG4gICAgICAgIC8vIG1ha2UgYSBzaGFsbG93IGNvcHkgc28gdGhhdCBmaWVsZHMgYWRkZWQgZG9uJ3QgbGVhayB0byB0aGUgb3JpZ2luYWwgc2VsZWN0b3IuXG4gICAgICAgIC8vIHRoaXMgaXMgZXNwZWNpYWxseSBpbXBvcnRhbnQgZm9yICdyZWYnIHNpbmNlIHRoYXQncyBhIHJlZmVyZW5jZSBiYWNrIHRvIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gaW5zdGFuY2UuIGEgc2luZ2xldG9uIG1lbW9pemVkIHNlbGVjdG9yIHdvdWxkIHRoZW4gYmUgaG9sZGluZyBhIHJlZmVyZW5jZSB0byB0aGVcbiAgICAgICAgLy8gaW5zdGFuY2UsIHByZXZlbnRpbmcgdGhlIGluc3RhbmNlIGZyb20gYmVpbmcgZ2FyYmFnZSBjb2xsZWN0ZWQsIGFuZCB0aGF0IHdvdWxkIGJlIGJhZFxuICAgICAgICB2YXIgd2l0aEV4dHJhcyA9IF9leHRlbmRzKHt9LCBwcm9wcyk7XG4gICAgICAgIGlmICh3aXRoUmVmKSB3aXRoRXh0cmFzLnJlZiA9IHRoaXMuc2V0V3JhcHBlZEluc3RhbmNlO1xuICAgICAgICBpZiAocmVuZGVyQ291bnRQcm9wKSB3aXRoRXh0cmFzW3JlbmRlckNvdW50UHJvcF0gPSB0aGlzLnJlbmRlckNvdW50Kys7XG4gICAgICAgIGlmICh0aGlzLnByb3BzTW9kZSAmJiB0aGlzLnN1YnNjcmlwdGlvbikgd2l0aEV4dHJhc1tzdWJzY3JpcHRpb25LZXldID0gdGhpcy5zdWJzY3JpcHRpb247XG4gICAgICAgIHJldHVybiB3aXRoRXh0cmFzO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuICAgICAgICBzZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc2VsZWN0b3IuZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBzZWxlY3Rvci5lcnJvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCB0aGlzLmFkZEV4dHJhUHJvcHMoc2VsZWN0b3IucHJvcHMpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbm5lY3Q7XG4gICAgfShDb21wb25lbnQpO1xuXG4gICAgQ29ubmVjdC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICBDb25uZWN0LmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgQ29ubmVjdC5jaGlsZENvbnRleHRUeXBlcyA9IGNoaWxkQ29udGV4dFR5cGVzO1xuICAgIENvbm5lY3QuY29udGV4dFR5cGVzID0gY29udGV4dFR5cGVzO1xuICAgIENvbm5lY3QucHJvcFR5cGVzID0gY29udGV4dFR5cGVzO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAvLyBXZSBhcmUgaG90IHJlbG9hZGluZyFcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbiAhPT0gdmVyc2lvbikge1xuICAgICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgdGhpcy5pbml0U2VsZWN0b3IoKTtcblxuICAgICAgICAgIC8vIElmIGFueSBjb25uZWN0ZWQgZGVzY2VuZGFudHMgZG9uJ3QgaG90IHJlbG9hZCAoYW5kIHJlc3Vic2NyaWJlIGluIHRoZSBwcm9jZXNzKSwgdGhlaXJcbiAgICAgICAgICAvLyBsaXN0ZW5lcnMgd2lsbCBiZSBsb3N0IHdoZW4gd2UgdW5zdWJzY3JpYmUuIFVuZm9ydHVuYXRlbHksIGJ5IGNvcHlpbmcgb3ZlciBhbGxcbiAgICAgICAgICAvLyBsaXN0ZW5lcnMsIHRoaXMgZG9lcyBtZWFuIHRoYXQgdGhlIG9sZCB2ZXJzaW9ucyBvZiBjb25uZWN0ZWQgZGVzY2VuZGFudHMgd2lsbCBzdGlsbCBiZVxuICAgICAgICAgIC8vIG5vdGlmaWVkIG9mIHN0YXRlIGNoYW5nZXM7IGhvd2V2ZXIsIHRoZWlyIG9uU3RhdGVDaGFuZ2UgZnVuY3Rpb24gaXMgYSBuby1vcCBzbyB0aGlzXG4gICAgICAgICAgLy8gaXNuJ3QgYSBodWdlIGRlYWwuXG4gICAgICAgICAgdmFyIG9sZExpc3RlbmVycyA9IFtdO1xuXG4gICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBvbGRMaXN0ZW5lcnMgPSB0aGlzLnN1YnNjcmlwdGlvbi5saXN0ZW5lcnMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmluaXRTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICBpZiAoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIG9sZExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLnN1YnNjcmlwdGlvbi5saXN0ZW5lcnMuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9pc3RTdGF0aWNzKENvbm5lY3QsIFdyYXBwZWRDb21wb25lbnQpO1xuICB9O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gICAgY29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gICAgbmFtZTogdHJ1ZSxcbiAgICBsZW5ndGg6IHRydWUsXG4gICAgcHJvdG90eXBlOiB0cnVlLFxuICAgIGNhbGxlcjogdHJ1ZSxcbiAgICBjYWxsZWU6IHRydWUsXG4gICAgYXJndW1lbnRzOiB0cnVlLFxuICAgIGFyaXR5OiB0cnVlXG59O1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiAmJiBnZXRQcm90b3R5cGVPZihPYmplY3QpO1xuXG5mdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgYmxhY2tsaXN0KSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG5cbiAgICAgICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQsIGJsYWNrbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghUkVBQ1RfU1RBVElDU1trZXldICYmICFLTk9XTl9TVEFUSUNTW2tleV0gJiYgKCFibGFja2xpc3QgfHwgIWJsYWNrbGlzdFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgICAgICAgICB0cnkgeyAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhvaXN0Tm9uUmVhY3RTdGF0aWNzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IHZlcmlmeVBsYWluT2JqZWN0IGZyb20gJy4uL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0JztcblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZ2V0Q29uc3RhbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRDb25zdGFudFNlbGVjdG9yKGRpc3BhdGNoLCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnN0YW50ID0gZ2V0Q29uc3RhbnQoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuXG4gICAgZnVuY3Rpb24gY29uc3RhbnRTZWxlY3RvcigpIHtcbiAgICAgIHJldHVybiBjb25zdGFudDtcbiAgICB9XG4gICAgY29uc3RhbnRTZWxlY3Rvci5kZXBlbmRzT25Pd25Qcm9wcyA9IGZhbHNlO1xuICAgIHJldHVybiBjb25zdGFudFNlbGVjdG9yO1xuICB9O1xufVxuXG4vLyBkZXBlbmRzT25Pd25Qcm9wcyBpcyB1c2VkIGJ5IGNyZWF0ZU1hcFRvUHJvcHNQcm94eSB0byBkZXRlcm1pbmUgd2hldGhlciB0byBwYXNzIHByb3BzIGFzIGFyZ3Ncbi8vIHRvIHRoZSBtYXBUb1Byb3BzIGZ1bmN0aW9uIGJlaW5nIHdyYXBwZWQuIEl0IGlzIGFsc28gdXNlZCBieSBtYWtlUHVyZVByb3BzU2VsZWN0b3IgdG8gZGV0ZXJtaW5lXG4vLyB3aGV0aGVyIG1hcFRvUHJvcHMgbmVlZHMgdG8gYmUgaW52b2tlZCB3aGVuIHByb3BzIGhhdmUgY2hhbmdlZC5cbi8vIFxuLy8gQSBsZW5ndGggb2Ygb25lIHNpZ25hbHMgdGhhdCBtYXBUb1Byb3BzIGRvZXMgbm90IGRlcGVuZCBvbiBwcm9wcyBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuLy8gQSBsZW5ndGggb2YgemVybyBpcyBhc3N1bWVkIHRvIG1lYW4gbWFwVG9Qcm9wcyBpcyBnZXR0aW5nIGFyZ3MgdmlhIGFyZ3VtZW50cyBvciAuLi5hcmdzIGFuZFxuLy8gdGhlcmVmb3JlIG5vdCByZXBvcnRpbmcgaXRzIGxlbmd0aCBhY2N1cmF0ZWx5Li5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZXBlbmRzT25Pd25Qcm9wcyhtYXBUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzICE9PSBudWxsICYmIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMgIT09IHVuZGVmaW5lZCA/IEJvb2xlYW4obWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgOiBtYXBUb1Byb3BzLmxlbmd0aCAhPT0gMTtcbn1cblxuLy8gVXNlZCBieSB3aGVuTWFwU3RhdGVUb1Byb3BzSXNGdW5jdGlvbiBhbmQgd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzRnVuY3Rpb24sXG4vLyB0aGlzIGZ1bmN0aW9uIHdyYXBzIG1hcFRvUHJvcHMgaW4gYSBwcm94eSBmdW5jdGlvbiB3aGljaCBkb2VzIHNldmVyYWwgdGhpbmdzOlxuLy8gXG4vLyAgKiBEZXRlY3RzIHdoZXRoZXIgdGhlIG1hcFRvUHJvcHMgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIGRlcGVuZHMgb24gcHJvcHMsIHdoaWNoXG4vLyAgICBpcyB1c2VkIGJ5IHNlbGVjdG9yRmFjdG9yeSB0byBkZWNpZGUgaWYgaXQgc2hvdWxkIHJlaW52b2tlIG9uIHByb3BzIGNoYW5nZXMuXG4vLyAgICBcbi8vICAqIE9uIGZpcnN0IGNhbGwsIGhhbmRsZXMgbWFwVG9Qcm9wcyBpZiByZXR1cm5zIGFub3RoZXIgZnVuY3Rpb24sIGFuZCB0cmVhdHMgdGhhdFxuLy8gICAgbmV3IGZ1bmN0aW9uIGFzIHRoZSB0cnVlIG1hcFRvUHJvcHMgZm9yIHN1YnNlcXVlbnQgY2FsbHMuXG4vLyAgICBcbi8vICAqIE9uIGZpcnN0IGNhbGwsIHZlcmlmaWVzIHRoZSBmaXJzdCByZXN1bHQgaXMgYSBwbGFpbiBvYmplY3QsIGluIG9yZGVyIHRvIHdhcm5cbi8vICAgIHRoZSBkZXZlbG9wZXIgdGhhdCB0aGVpciBtYXBUb1Byb3BzIGZ1bmN0aW9uIGlzIG5vdCByZXR1cm5pbmcgYSB2YWxpZCByZXN1bHQuXG4vLyAgICBcbmV4cG9ydCBmdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwVG9Qcm9wcywgbWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdFByb3h5U2VsZWN0b3IoZGlzcGF0Y2gsIF9yZWYpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBfcmVmLmRpc3BsYXlOYW1lO1xuXG4gICAgdmFyIHByb3h5ID0gZnVuY3Rpb24gbWFwVG9Qcm9wc1Byb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA/IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykgOiBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCk7XG4gICAgfTtcblxuICAgIC8vIGFsbG93IGRldGVjdEZhY3RvcnlBbmRWZXJpZnkgdG8gZ2V0IG93blByb3BzXG4gICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSB0cnVlO1xuXG4gICAgcHJveHkubWFwVG9Qcm9wcyA9IGZ1bmN0aW9uIGRldGVjdEZhY3RvcnlBbmRWZXJpZnkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IG1hcFRvUHJvcHM7XG4gICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpO1xuICAgICAgdmFyIHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IHByb3BzO1xuICAgICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKHByb3BzKTtcbiAgICAgICAgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHZlcmlmeVBsYWluT2JqZWN0KHByb3BzLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSk7XG5cbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvd3JhcE1hcFRvUHJvcHMuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi93YXJuaW5nJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmVyaWZ5UGxhaW5PYmplY3QodmFsdWUsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuaW5nKG1ldGhvZE5hbWUgKyAnKCkgaW4gJyArIGRpc3BsYXlOYW1lICsgJyBtdXN0IHJldHVybiBhIHBsYWluIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZCAnICsgdmFsdWUgKyAnLicpO1xuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJleHBvcnQgdmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbmV4cG9ydCB2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLmFkZEV2ZW50TGlzdGVuZXIgPyBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxuZXhwb3J0IHZhciByZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG5leHBvcnQgdmFyIGdldENvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uIGdldENvbmZpcm1hdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICByZXR1cm4gY2FsbGJhY2sod2luZG93LmNvbmZpcm0obWVzc2FnZSkpO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzSGlzdG9yeSA9IGZ1bmN0aW9uIHN1cHBvcnRzSGlzdG9yeSgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgaWYgKCh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJiB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJiB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYnJvd3NlciBmaXJlcyBwb3BzdGF0ZSBvbiBoYXNoIGNoYW5nZS5cbiAqIElFMTAgYW5kIElFMTEgZG8gbm90LlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiBwb3BzdGF0ZSBldmVudCBpcyBhbiBleHRyYW5lb3VzIFdlYktpdCBldmVudC5cbiAqIEFjY291bnRzIGZvciB0aGUgZmFjdCB0aGF0IENocm9tZSBvbiBpT1MgZmlyZXMgcmVhbCBwb3BzdGF0ZSBldmVudHNcbiAqIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHN0YXRlIHdoZW4gcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlxuICovXG5leHBvcnQgdmFyIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgPSBmdW5jdGlvbiBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5zdGF0ZSA9PT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ3JpT1MnKSA9PT0gLTE7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvRE9NVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSBcImludmFyaWFudFwiO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24gfSBmcm9tIFwiaGlzdG9yeVwiO1xuXG52YXIgaXNNb2RpZmllZEV2ZW50ID0gZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn07XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgPGE+LlxuICovXG5cbnZhciBMaW5rID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKExpbmssIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIExpbmsoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5rKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uQ2xpY2spIF90aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuXG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiYgLy8gb25DbGljayBwcmV2ZW50ZWQgZGVmYXVsdFxuICAgICAgZXZlbnQuYnV0dG9uID09PSAwICYmIC8vIGlnbm9yZSBldmVyeXRoaW5nIGJ1dCBsZWZ0IGNsaWNrc1xuICAgICAgIV90aGlzLnByb3BzLnRhcmdldCAmJiAvLyBsZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAgICAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gaWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgICAgICkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICB2YXIgaGlzdG9yeSA9IF90aGlzLmNvbnRleHQucm91dGVyLmhpc3Rvcnk7XG4gICAgICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgICAgIHJlcGxhY2UgPSBfdGhpcyRwcm9wcy5yZXBsYWNlLFxuICAgICAgICAgICAgICB0byA9IF90aGlzJHByb3BzLnRvO1xuXG5cbiAgICAgICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICAgICAgaGlzdG9yeS5yZXBsYWNlKHRvKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlzdG9yeS5wdXNoKHRvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIExpbmsucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgcmVwbGFjZSA9IF9wcm9wcy5yZXBsYWNlLFxuICAgICAgICB0byA9IF9wcm9wcy50byxcbiAgICAgICAgaW5uZXJSZWYgPSBfcHJvcHMuaW5uZXJSZWYsXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgW1wicmVwbGFjZVwiLCBcInRvXCIsIFwiaW5uZXJSZWZcIl0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICBpbnZhcmlhbnQodGhpcy5jb250ZXh0LnJvdXRlciwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPExpbms+IG91dHNpZGUgYSA8Um91dGVyPlwiKTtcblxuICAgIGludmFyaWFudCh0byAhPT0gdW5kZWZpbmVkLCAnWW91IG11c3Qgc3BlY2lmeSB0aGUgXCJ0b1wiIHByb3BlcnR5Jyk7XG5cbiAgICB2YXIgaGlzdG9yeSA9IHRoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeTtcblxuICAgIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IGNyZWF0ZUxvY2F0aW9uKHRvLCBudWxsLCBudWxsLCBoaXN0b3J5LmxvY2F0aW9uKSA6IHRvO1xuXG4gICAgdmFyIGhyZWYgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgb25DbGljazogdGhpcy5oYW5kbGVDbGljaywgaHJlZjogaHJlZiwgcmVmOiBpbm5lclJlZiB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIExpbms7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkxpbmsucHJvcFR5cGVzID0ge1xuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICByZXBsYWNlOiBQcm9wVHlwZXMuYm9vbCxcbiAgdG86IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKS5pc1JlcXVpcmVkLFxuICBpbm5lclJlZjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKVxufTtcbkxpbmsuZGVmYXVsdFByb3BzID0ge1xuICByZXBsYWNlOiBmYWxzZVxufTtcbkxpbmsuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIHB1c2g6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICByZXBsYWNlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgY3JlYXRlSHJlZjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBMaW5rO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTGluay5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFJvdXRlIGZyb20gXCJyZWFjdC1yb3V0ZXIvZXMvUm91dGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgUm91dGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gXCJ3YXJuaW5nXCI7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gXCJpbnZhcmlhbnRcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCBtYXRjaFBhdGggZnJvbSBcIi4vbWF0Y2hQYXRoXCI7XG5cbnZhciBpc0VtcHR5Q2hpbGRyZW4gPSBmdW5jdGlvbiBpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA9PT0gMDtcbn07XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIG1hdGNoaW5nIGEgc2luZ2xlIHBhdGggYW5kIHJlbmRlcmluZy5cbiAqL1xuXG52YXIgUm91dGUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUm91dGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJvdXRlKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuICAgICAgbWF0Y2g6IF90aGlzLmNvbXB1dGVNYXRjaChfdGhpcy5wcm9wcywgX3RoaXMuY29udGV4dC5yb3V0ZXIpXG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBSb3V0ZS5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IF9leHRlbmRzKHt9LCB0aGlzLmNvbnRleHQucm91dGVyLCB7XG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgbG9jYXRpb246IHRoaXMucHJvcHMubG9jYXRpb24gfHwgdGhpcy5jb250ZXh0LnJvdXRlci5yb3V0ZS5sb2NhdGlvbixcbiAgICAgICAgICBtYXRjaDogdGhpcy5zdGF0ZS5tYXRjaFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXB1dGVNYXRjaCA9IGZ1bmN0aW9uIGNvbXB1dGVNYXRjaChfcmVmLCByb3V0ZXIpIHtcbiAgICB2YXIgY29tcHV0ZWRNYXRjaCA9IF9yZWYuY29tcHV0ZWRNYXRjaCxcbiAgICAgICAgbG9jYXRpb24gPSBfcmVmLmxvY2F0aW9uLFxuICAgICAgICBwYXRoID0gX3JlZi5wYXRoLFxuICAgICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgICAgZXhhY3QgPSBfcmVmLmV4YWN0LFxuICAgICAgICBzZW5zaXRpdmUgPSBfcmVmLnNlbnNpdGl2ZTtcblxuICAgIGlmIChjb21wdXRlZE1hdGNoKSByZXR1cm4gY29tcHV0ZWRNYXRjaDsgLy8gPFN3aXRjaD4gYWxyZWFkeSBjb21wdXRlZCB0aGUgbWF0Y2ggZm9yIHVzXG5cbiAgICBpbnZhcmlhbnQocm91dGVyLCBcIllvdSBzaG91bGQgbm90IHVzZSA8Um91dGU+IG9yIHdpdGhSb3V0ZXIoKSBvdXRzaWRlIGEgPFJvdXRlcj5cIik7XG5cbiAgICB2YXIgcm91dGUgPSByb3V0ZXIucm91dGU7XG5cbiAgICB2YXIgcGF0aG5hbWUgPSAobG9jYXRpb24gfHwgcm91dGUubG9jYXRpb24pLnBhdGhuYW1lO1xuXG4gICAgcmV0dXJuIG1hdGNoUGF0aChwYXRobmFtZSwgeyBwYXRoOiBwYXRoLCBzdHJpY3Q6IHN0cmljdCwgZXhhY3Q6IGV4YWN0LCBzZW5zaXRpdmU6IHNlbnNpdGl2ZSB9LCByb3V0ZS5tYXRjaCk7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCEodGhpcy5wcm9wcy5jb21wb25lbnQgJiYgdGhpcy5wcm9wcy5yZW5kZXIpLCBcIllvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgY29tcG9uZW50PiBhbmQgPFJvdXRlIHJlbmRlcj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSByZW5kZXI+IHdpbGwgYmUgaWdub3JlZFwiKTtcblxuICAgIHdhcm5pbmcoISh0aGlzLnByb3BzLmNvbXBvbmVudCAmJiB0aGlzLnByb3BzLmNoaWxkcmVuICYmICFpc0VtcHR5Q2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbikpLCBcIllvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgY29tcG9uZW50PiBhbmQgPFJvdXRlIGNoaWxkcmVuPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIGNoaWxkcmVuPiB3aWxsIGJlIGlnbm9yZWRcIik7XG5cbiAgICB3YXJuaW5nKCEodGhpcy5wcm9wcy5yZW5kZXIgJiYgdGhpcy5wcm9wcy5jaGlsZHJlbiAmJiAhaXNFbXB0eUNoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4pKSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlIHJlbmRlcj4gYW5kIDxSb3V0ZSBjaGlsZHJlbj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSBjaGlsZHJlbj4gd2lsbCBiZSBpZ25vcmVkXCIpO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAgd2FybmluZyghKG5leHRQcm9wcy5sb2NhdGlvbiAmJiAhdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8Um91dGU+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgaW5pdGlhbGx5IHVzZWQgbm8gXCJsb2NhdGlvblwiIHByb3AgYW5kIHRoZW4gcHJvdmlkZWQgb25lIG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG5cbiAgICB3YXJuaW5nKCEoIW5leHRQcm9wcy5sb2NhdGlvbiAmJiB0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxSb3V0ZT4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBwcm92aWRlZCBhIFwibG9jYXRpb25cIiBwcm9wIGluaXRpYWxseSBidXQgb21pdHRlZCBpdCBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtYXRjaDogdGhpcy5jb21wdXRlTWF0Y2gobmV4dFByb3BzLCBuZXh0Q29udGV4dC5yb3V0ZXIpXG4gICAgfSk7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgbWF0Y2ggPSB0aGlzLnN0YXRlLm1hdGNoO1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgY29tcG9uZW50ID0gX3Byb3BzLmNvbXBvbmVudCxcbiAgICAgICAgcmVuZGVyID0gX3Byb3BzLnJlbmRlcjtcbiAgICB2YXIgX2NvbnRleHQkcm91dGVyID0gdGhpcy5jb250ZXh0LnJvdXRlcixcbiAgICAgICAgaGlzdG9yeSA9IF9jb250ZXh0JHJvdXRlci5oaXN0b3J5LFxuICAgICAgICByb3V0ZSA9IF9jb250ZXh0JHJvdXRlci5yb3V0ZSxcbiAgICAgICAgc3RhdGljQ29udGV4dCA9IF9jb250ZXh0JHJvdXRlci5zdGF0aWNDb250ZXh0O1xuXG4gICAgdmFyIGxvY2F0aW9uID0gdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbjtcbiAgICB2YXIgcHJvcHMgPSB7IG1hdGNoOiBtYXRjaCwgbG9jYXRpb246IGxvY2F0aW9uLCBoaXN0b3J5OiBoaXN0b3J5LCBzdGF0aWNDb250ZXh0OiBzdGF0aWNDb250ZXh0IH07XG5cbiAgICBpZiAoY29tcG9uZW50KSByZXR1cm4gbWF0Y2ggPyBSZWFjdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpIDogbnVsbDtcblxuICAgIGlmIChyZW5kZXIpIHJldHVybiBtYXRjaCA/IHJlbmRlcihwcm9wcykgOiBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY2hpbGRyZW4ocHJvcHMpO1xuXG4gICAgaWYgKGNoaWxkcmVuICYmICFpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pKSByZXR1cm4gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUm91dGU7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJvdXRlLnByb3BUeXBlcyA9IHtcbiAgY29tcHV0ZWRNYXRjaDogUHJvcFR5cGVzLm9iamVjdCwgLy8gcHJpdmF0ZSwgZnJvbSA8U3dpdGNoPlxuICBwYXRoOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBleGFjdDogUHJvcFR5cGVzLmJvb2wsXG4gIHN0cmljdDogUHJvcFR5cGVzLmJvb2wsXG4gIHNlbnNpdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIHJlbmRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm5vZGVdKSxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3Rcbn07XG5Sb3V0ZS5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgcm91dGU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICBzdGF0aWNDb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0XG4gIH0pXG59O1xuUm91dGUuY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFJvdXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgaXNhcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoVG9SZWdleHBcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2Vcbm1vZHVsZS5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvblxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cFxuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpXG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXVxuICB2YXIga2V5ID0gMFxuICB2YXIgaW5kZXggPSAwXG4gIHZhciBwYXRoID0gJydcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJ1xuICB2YXIgcmVzXG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICB2YXIgbSA9IHJlc1swXVxuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdXG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleFxuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aFxuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF1cbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdXG4gICAgdmFyIG5hbWUgPSByZXNbM11cbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XVxuICAgIHZhciBncm91cCA9IHJlc1s1XVxuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XVxuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XVxuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aClcbiAgICAgIHBhdGggPSAnJ1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJlZml4ICE9IG51bGwgJiYgbmV4dCAhPSBudWxsICYmIG5leHQgIT09IHByZWZpeFxuICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgZGVsaW1pdGVyID0gcmVzWzJdIHx8IGRlZmF1bHREZWxpbWl0ZXJcbiAgICB2YXIgcGF0dGVybiA9IGNhcHR1cmUgfHwgZ3JvdXBcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSlcbiAgfVxuXG4gIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHBhdGggKz0gc3RyLnN1YnN0cihpbmRleClcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXG4gIGlmIChwYXRoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aClcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKVxuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICB2YXIgcGF0aCA9ICcnXG4gICAgdmFyIGRhdGEgPSBvYmogfHwge31cbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge31cbiAgICB2YXIgZW5jb2RlID0gb3B0aW9ucy5wcmV0dHkgPyBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgOiBlbmNvZGVVUklDb21wb25lbnRcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCArPSB0b2tlblxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV1cbiAgICAgIHZhciBzZWdtZW50XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgIC8vIFByZXBlbmQgcGFydGlhbCBzZWdtZW50IHByZWZpeGVzLlxuICAgICAgICAgIGlmICh0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNhcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSlcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSB0b2tlbi5hc3RlcmlzayA/IGVuY29kZUFzdGVyaXNrKHZhbHVlKSA6IGVuY29kZSh2YWx1ZSlcblxuICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXG4gICAgICB9XG5cbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudFxuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXxcXC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzXG4gIHJldHVybiByZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZsYWdzIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKVxuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgcGFydGlhbDogZmFsc2UsXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcbiAgICAgICAgcGF0dGVybjogbnVsbFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpXG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpXG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3RcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZVxuICB2YXIgcm91dGUgPSAnJ1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeClcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknXG5cbiAgICAgIGtleXMucHVzaCh0b2tlbilcblxuICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuICAgICAgICBjYXB0dXJlICs9ICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKidcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyk/J1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJ1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlXG4gICAgfVxuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLycpXG4gIHZhciBlbmRzV2l0aERlbGltaXRlciA9IHJvdXRlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyXG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPydcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCdcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoRGVsaW1pdGVyID8gJycgOiAnKD89JyArIGRlbGltaXRlciArICd8JCknXG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucylcbiAgICBrZXlzID0gW11cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IHBhdGhUb1JlZ2V4cCBmcm9tIFwicGF0aC10by1yZWdleHBcIjtcblxudmFyIHBhdHRlcm5DYWNoZSA9IHt9O1xudmFyIGNhY2hlTGltaXQgPSAxMDAwMDtcbnZhciBjYWNoZUNvdW50ID0gMDtcblxudmFyIGNvbXBpbGVHZW5lcmF0b3IgPSBmdW5jdGlvbiBjb21waWxlR2VuZXJhdG9yKHBhdHRlcm4pIHtcbiAgdmFyIGNhY2hlS2V5ID0gcGF0dGVybjtcbiAgdmFyIGNhY2hlID0gcGF0dGVybkNhY2hlW2NhY2hlS2V5XSB8fCAocGF0dGVybkNhY2hlW2NhY2hlS2V5XSA9IHt9KTtcblxuICBpZiAoY2FjaGVbcGF0dGVybl0pIHJldHVybiBjYWNoZVtwYXR0ZXJuXTtcblxuICB2YXIgY29tcGlsZWRHZW5lcmF0b3IgPSBwYXRoVG9SZWdleHAuY29tcGlsZShwYXR0ZXJuKTtcblxuICBpZiAoY2FjaGVDb3VudCA8IGNhY2hlTGltaXQpIHtcbiAgICBjYWNoZVtwYXR0ZXJuXSA9IGNvbXBpbGVkR2VuZXJhdG9yO1xuICAgIGNhY2hlQ291bnQrKztcbiAgfVxuXG4gIHJldHVybiBjb21waWxlZEdlbmVyYXRvcjtcbn07XG5cbi8qKlxuICogUHVibGljIEFQSSBmb3IgZ2VuZXJhdGluZyBhIFVSTCBwYXRobmFtZSBmcm9tIGEgcGF0dGVybiBhbmQgcGFyYW1ldGVycy5cbiAqL1xudmFyIGdlbmVyYXRlUGF0aCA9IGZ1bmN0aW9uIGdlbmVyYXRlUGF0aCgpIHtcbiAgdmFyIHBhdHRlcm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwiL1wiO1xuICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICBpZiAocGF0dGVybiA9PT0gXCIvXCIpIHtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICB2YXIgZ2VuZXJhdG9yID0gY29tcGlsZUdlbmVyYXRvcihwYXR0ZXJuKTtcbiAgcmV0dXJuIGdlbmVyYXRvcihwYXJhbXMsIHsgcHJldHR5OiB0cnVlIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZ2VuZXJhdGVQYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9nZW5lcmF0ZVBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xudmFyIGJ0b2EgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmJ0b2EgJiYgd2luZG93LmJ0b2EuYmluZCh3aW5kb3cpKSB8fCByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnRvYScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHZhciBsb2FkRXZlbnQgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbiAgICB2YXIgeERvbWFpbiA9IGZhbHNlO1xuXG4gICAgLy8gRm9yIElFIDgvOSBDT1JTIHN1cHBvcnRcbiAgICAvLyBPbmx5IHN1cHBvcnRzIFBPU1QgYW5kIEdFVCBjYWxscyBhbmQgZG9lc24ndCByZXR1cm5zIHRoZSByZXNwb25zZSBoZWFkZXJzLlxuICAgIC8vIERPTidUIGRvIHRoaXMgZm9yIHRlc3RpbmcgYi9jIFhNTEh0dHBSZXF1ZXN0IGlzIG1vY2tlZCwgbm90IFhEb21haW5SZXF1ZXN0LlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXG4gICAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHdpbmRvdy5YRG9tYWluUmVxdWVzdCAmJiAhKCd3aXRoQ3JlZGVudGlhbHMnIGluIHJlcXVlc3QpICYmXG4gICAgICAgICFpc1VSTFNhbWVPcmlnaW4oY29uZmlnLnVybCkpIHtcbiAgICAgIHJlcXVlc3QgPSBuZXcgd2luZG93LlhEb21haW5SZXF1ZXN0KCk7XG4gICAgICBsb2FkRXZlbnQgPSAnb25sb2FkJztcbiAgICAgIHhEb21haW4gPSB0cnVlO1xuICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gZnVuY3Rpb24gaGFuZGxlUHJvZ3Jlc3MoKSB7fTtcbiAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHt9O1xuICAgIH1cblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgfHwgJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZVxuICAgIHJlcXVlc3RbbG9hZEV2ZW50XSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QgfHwgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCAmJiAheERvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhY29uZmlnLnJlc3BvbnNlVHlwZSB8fCBjb25maWcucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgLy8gSUUgc2VuZHMgMTIyMyBpbnN0ZWFkIG9mIDIwNCAoaHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9zL2lzc3Vlcy8yMDEpXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAnTm8gQ29udGVudCcgOiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIHZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcblxuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBoZXhUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICBhcnJheS5wdXNoKCclJyArICgoaSA8IDE2ID8gJzAnIDogJycpICsgaS50b1N0cmluZygxNikpLnRvVXBwZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbn0oKSk7XG5cbnZhciBjb21wYWN0UXVldWUgPSBmdW5jdGlvbiBjb21wYWN0UXVldWUocXVldWUpIHtcbiAgICB2YXIgb2JqO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgaXRlbSA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICBvYmogPSBpdGVtLm9ialtpdGVtLnByb3BdO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIHZhciBjb21wYWN0ZWQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmoubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ialtqXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFjdGVkLnB1c2gob2JqW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW0ub2JqW2l0ZW0ucHJvcF0gPSBjb21wYWN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIGFycmF5VG9PYmplY3QgPSBmdW5jdGlvbiBhcnJheVRvT2JqZWN0KHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHZhciBvYmogPSBvcHRpb25zICYmIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlW2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb2JqW2ldID0gc291cmNlW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goc291cmNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGxhaW5PYmplY3RzIHx8IG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzIHx8ICFoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3NvdXJjZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt0YXJnZXQsIHNvdXJjZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gW3RhcmdldF0uY29uY2F0KHNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIG1lcmdlVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgIUFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBtZXJnZVRhcmdldCA9IGFycmF5VG9PYmplY3QodGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgICAgaWYgKGhhcy5jYWxsKHRhcmdldCwgaSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W2ldICYmIHR5cGVvZiB0YXJnZXRbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IG1lcmdlKHRhcmdldFtpXSwgaXRlbSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICAgIGlmIChoYXMuY2FsbChhY2MsIGtleSkpIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gbWVyZ2UoYWNjW2tleV0sIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBtZXJnZVRhcmdldCk7XG59O1xuXG52YXIgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduU2luZ2xlU291cmNlKHRhcmdldCwgc291cmNlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICBhY2Nba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHRhcmdldCk7XG59O1xuXG52YXIgZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufTtcblxudmFyIGVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShzdHIpIHtcbiAgICAvLyBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBieSBCcmlhbiBXaGl0ZSAobXNjZGV4KSBmb3IgdGhlIGlvLmpzIGNvcmUgcXVlcnlzdHJpbmcgbGlicmFyeS5cbiAgICAvLyBJdCBoYXMgYmVlbiBhZGFwdGVkIGhlcmUgZm9yIHN0cmljdGVyIGFkaGVyZW5jZSB0byBSRkMgMzk4NlxuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgdmFyIHN0cmluZyA9IHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gc3RyIDogU3RyaW5nKHN0cik7XG5cbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjID09PSAweDJEIC8vIC1cbiAgICAgICAgICAgIHx8IGMgPT09IDB4MkUgLy8gLlxuICAgICAgICAgICAgfHwgYyA9PT0gMHg1RiAvLyBfXG4gICAgICAgICAgICB8fCBjID09PSAweDdFIC8vIH5cbiAgICAgICAgICAgIHx8IChjID49IDB4MzAgJiYgYyA8PSAweDM5KSAvLyAwLTlcbiAgICAgICAgICAgIHx8IChjID49IDB4NDEgJiYgYyA8PSAweDVBKSAvLyBhLXpcbiAgICAgICAgICAgIHx8IChjID49IDB4NjEgJiYgYyA8PSAweDdBKSAvLyBBLVpcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvdXQgKz0gc3RyaW5nLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyBoZXhUYWJsZVtjXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgKGhleFRhYmxlWzB4QzAgfCAoYyA+PiA2KV0gKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4RDgwMCB8fCBjID49IDB4RTAwMCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgKGhleFRhYmxlWzB4RTAgfCAoYyA+PiAxMildICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXSArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKChjICYgMHgzRkYpIDw8IDEwKSB8IChzdHJpbmcuY2hhckNvZGVBdChpKSAmIDB4M0ZGKSk7XG4gICAgICAgIG91dCArPSBoZXhUYWJsZVsweEYwIHwgKGMgPj4gMTgpXVxuICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKChjID4+IDEyKSAmIDB4M0YpXVxuICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKChjID4+IDYpICYgMHgzRildXG4gICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxudmFyIGNvbXBhY3QgPSBmdW5jdGlvbiBjb21wYWN0KHZhbHVlKSB7XG4gICAgdmFyIHF1ZXVlID0gW3sgb2JqOiB7IG86IHZhbHVlIH0sIHByb3A6ICdvJyB9XTtcbiAgICB2YXIgcmVmcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgaXRlbSA9IHF1ZXVlW2ldO1xuICAgICAgICB2YXIgb2JqID0gaXRlbS5vYmpbaXRlbS5wcm9wXTtcblxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbal07XG4gICAgICAgICAgICB2YXIgdmFsID0gb2JqW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsICYmIHJlZnMuaW5kZXhPZih2YWwpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goeyBvYmo6IG9iaiwgcHJvcDoga2V5IH0pO1xuICAgICAgICAgICAgICAgIHJlZnMucHVzaCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBhY3RRdWV1ZShxdWV1ZSk7XG59O1xuXG52YXIgaXNSZWdFeHAgPSBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxudmFyIGlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhKG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXJyYXlUb09iamVjdDogYXJyYXlUb09iamVjdCxcbiAgICBhc3NpZ246IGFzc2lnbixcbiAgICBjb21wYWN0OiBjb21wYWN0LFxuICAgIGRlY29kZTogZGVjb2RlLFxuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgICBpc1JlZ0V4cDogaXNSZWdFeHAsXG4gICAgbWVyZ2U6IG1lcmdlXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXMvbGliL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG52YXIgcGVyY2VudFR3ZW50aWVzID0gLyUyMC9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnZGVmYXVsdCc6ICdSRkMzOTg2JyxcbiAgICBmb3JtYXR0ZXJzOiB7XG4gICAgICAgIFJGQzE3Mzg6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2UuY2FsbCh2YWx1ZSwgcGVyY2VudFR3ZW50aWVzLCAnKycpO1xuICAgICAgICB9LFxuICAgICAgICBSRkMzOTg2OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgUkZDMTczODogJ1JGQzE3MzgnLFxuICAgIFJGQzM5ODY6ICdSRkMzOTg2J1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3FzL2xpYi9mb3JtYXRzLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImltcG9ydCB7IHJlbmRlciwgdmVyc2lvbiB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBjcmVhdGVSb290IH0gZnJvbSAncmVhY3QtZG9tL2NsaWVudCc7XG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5cbi8qKlxuICogcmVuZGVyIEJsb2NrXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyQmxvY2soIGNvbnRhaW5lcklkLCBlbGVtZW50ICkge1xuXHRjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggY29udGFpbmVySWQgKTtcblxuXHQvLyBJZiBjb250YWluZXIgaXMgaGlkZGVuIGluIFBIUC5cblx0aWYgKCBfLmlzTnVsbCggY29udGFpbmVyICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKHNlbXZlci5ndGUodmVyc2lvbiwgJzE4LjAuMCcpKSB7XG5cdFx0Ly8gUmVhY3QgMTggb3IgaGlnaGVyLlxuXHRcdGNvbnN0IHJvb3QgPSBjcmVhdGVSb290KCBjb250YWluZXIgKTtcblx0XHRyb290LnJlbmRlcihcblx0XHRcdGVsZW1lbnRcblx0XHQpO1xuXHR9IGVsc2Uge1xuXHRcdHJlbmRlcihcblx0XHRcdGVsZW1lbnQsXG5cdFx0XHRjb250YWluZXJcblx0XHQpO1xuXHR9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlckJsb2NrLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgZXhwb3J0cy5jcmVhdGVSb290ID0gbS5jcmVhdGVSb290O1xuICBleHBvcnRzLmh5ZHJhdGVSb290ID0gbS5oeWRyYXRlUm9vdDtcbn0gZWxzZSB7XG4gIHZhciBpID0gbS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgZXhwb3J0cy5jcmVhdGVSb290ID0gZnVuY3Rpb24oYywgbykge1xuICAgIGkudXNpbmdDbGllbnRFbnRyeVBvaW50ID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG0uY3JlYXRlUm9vdChjLCBvKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaS51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGV4cG9ydHMuaHlkcmF0ZVJvb3QgPSBmdW5jdGlvbihjLCBoLCBvKSB7XG4gICAgaS51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbS5oeWRyYXRlUm9vdChjLCBoLCBvKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaS51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2xpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU2VtVmVyO1xuXG4vLyBUaGUgZGVidWcgZnVuY3Rpb24gaXMgZXhjbHVkZWQgZW50aXJlbHkgZnJvbSB0aGUgbWluaWZpZWQgdmVyc2lvbi5cbi8qIG5vbWluICovIHZhciBkZWJ1Zztcbi8qIG5vbWluICovIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgICAvKiBub21pbiAqLyBwcm9jZXNzLmVudiAmJlxuICAgIC8qIG5vbWluICovIHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiZcbiAgICAvKiBub21pbiAqLyAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSlcbiAgLyogbm9taW4gKi8gZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBub21pbiAqLyB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgLyogbm9taW4gKi8gYXJncy51bnNoaWZ0KCdTRU1WRVInKTtcbiAgICAvKiBub21pbiAqLyBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICAvKiBub21pbiAqLyB9O1xuLyogbm9taW4gKi8gZWxzZVxuICAvKiBub21pbiAqLyBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5cbi8vIE5vdGU6IHRoaXMgaXMgdGhlIHNlbXZlci5vcmcgdmVyc2lvbiBvZiB0aGUgc3BlYyB0aGF0IGl0IGltcGxlbWVudHNcbi8vIE5vdCBuZWNlc3NhcmlseSB0aGUgcGFja2FnZSB2ZXJzaW9uIG9mIHRoaXMgY29kZS5cbmV4cG9ydHMuU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCc7XG5cbnZhciBNQVhfTEVOR1RIID0gMjU2O1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vLyBNYXggc2FmZSBzZWdtZW50IGxlbmd0aCBmb3IgY29lcmNpb24uXG52YXIgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCA9IDE2O1xuXG4vLyBUaGUgYWN0dWFsIHJlZ2V4cHMgZ28gb24gZXhwb3J0cy5yZVxudmFyIHJlID0gZXhwb3J0cy5yZSA9IFtdO1xudmFyIHNyYyA9IGV4cG9ydHMuc3JjID0gW107XG52YXIgUiA9IDA7XG5cbi8vIFRoZSBmb2xsb3dpbmcgUmVndWxhciBFeHByZXNzaW9ucyBjYW4gYmUgdXNlZCBmb3IgdG9rZW5pemluZyxcbi8vIHZhbGlkYXRpbmcsIGFuZCBwYXJzaW5nIFNlbVZlciB2ZXJzaW9uIHN0cmluZ3MuXG5cbi8vICMjIE51bWVyaWMgSWRlbnRpZmllclxuLy8gQSBzaW5nbGUgYDBgLCBvciBhIG5vbi16ZXJvIGRpZ2l0IGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBkaWdpdHMuXG5cbnZhciBOVU1FUklDSURFTlRJRklFUiA9IFIrKztcbnNyY1tOVU1FUklDSURFTlRJRklFUl0gPSAnMHxbMS05XVxcXFxkKic7XG52YXIgTlVNRVJJQ0lERU5USUZJRVJMT09TRSA9IFIrKztcbnNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSA9ICdbMC05XSsnO1xuXG5cbi8vICMjIE5vbi1udW1lcmljIElkZW50aWZpZXJcbi8vIFplcm8gb3IgbW9yZSBkaWdpdHMsIGZvbGxvd2VkIGJ5IGEgbGV0dGVyIG9yIGh5cGhlbiwgYW5kIHRoZW4gemVybyBvclxuLy8gbW9yZSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGh5cGhlbnMuXG5cbnZhciBOT05OVU1FUklDSURFTlRJRklFUiA9IFIrKztcbnNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gPSAnXFxcXGQqW2EtekEtWi1dW2EtekEtWjAtOS1dKic7XG5cblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbnZhciBNQUlOVkVSU0lPTiA9IFIrKztcbnNyY1tNQUlOVkVSU0lPTl0gPSAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArICcpJztcblxudmFyIE1BSU5WRVJTSU9OTE9PU0UgPSBSKys7XG5zcmNbTUFJTlZFUlNJT05MT09TRV0gPSAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKSc7XG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb24gSWRlbnRpZmllclxuLy8gQSBudW1lcmljIGlkZW50aWZpZXIsIG9yIGEgbm9uLW51bWVyaWMgaWRlbnRpZmllci5cblxudmFyIFBSRVJFTEVBU0VJREVOVElGSUVSID0gUisrO1xuc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSXSA9ICcoPzonICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3wnICsgc3JjW05PTk5VTUVSSUNJREVOVElGSUVSXSArICcpJztcblxudmFyIFBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0UgPSBSKys7XG5zcmNbUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gPSAnKD86JyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBzcmNbTk9OTlVNRVJJQ0lERU5USUZJRVJdICsgJyknO1xuXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxudmFyIFBSRVJFTEVBU0UgPSBSKys7XG5zcmNbUFJFUkVMRUFTRV0gPSAnKD86LSgnICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSXSArICcpKikpJztcblxudmFyIFBSRVJFTEVBU0VMT09TRSA9IFIrKztcbnNyY1tQUkVSRUxFQVNFTE9PU0VdID0gJyg/Oi0/KCcgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdICsgJykqKSknO1xuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YSBJZGVudGlmaWVyXG4vLyBBbnkgY29tYmluYXRpb24gb2YgZGlnaXRzLCBsZXR0ZXJzLCBvciBoeXBoZW5zLlxuXG52YXIgQlVJTERJREVOVElGSUVSID0gUisrO1xuc3JjW0JVSUxESURFTlRJRklFUl0gPSAnWzAtOUEtWmEtei1dKyc7XG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhXG4vLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGFcbi8vIGlkZW50aWZpZXJzLlxuXG52YXIgQlVJTEQgPSBSKys7XG5zcmNbQlVJTERdID0gJyg/OlxcXFwrKCcgKyBzcmNbQlVJTERJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgJyg/OlxcXFwuJyArIHNyY1tCVUlMRElERU5USUZJRVJdICsgJykqKSknO1xuXG5cbi8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbi8vIEEgbWFpbiB2ZXJzaW9uLCBmb2xsb3dlZCBvcHRpb25hbGx5IGJ5IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiBhbmRcbi8vIGJ1aWxkIG1ldGFkYXRhLlxuXG4vLyBOb3RlIHRoYXQgdGhlIG9ubHkgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIHByZS1yZWxlYXNlIHNlY3Rpb25zIG9mXG4vLyB0aGUgdmVyc2lvbiBzdHJpbmcgYXJlIGNhcHR1cmluZyBncm91cHMuICBUaGUgYnVpbGQgbWV0YWRhdGEgaXMgbm90IGFcbi8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4vLyBjb21wYXJpc29uLlxuXG52YXIgRlVMTCA9IFIrKztcbnZhciBGVUxMUExBSU4gPSAndj8nICsgc3JjW01BSU5WRVJTSU9OXSArXG4gICAgICAgICAgICAgICAgc3JjW1BSRVJFTEVBU0VdICsgJz8nICtcbiAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nO1xuXG5zcmNbRlVMTF0gPSAnXicgKyBGVUxMUExBSU4gKyAnJCc7XG5cbi8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbi8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5XG4vLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cbnZhciBMT09TRVBMQUlOID0gJ1t2PVxcXFxzXSonICsgc3JjW01BSU5WRVJTSU9OTE9PU0VdICtcbiAgICAgICAgICAgICAgICAgc3JjW1BSRVJFTEVBU0VMT09TRV0gKyAnPycgK1xuICAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nO1xuXG52YXIgTE9PU0UgPSBSKys7XG5zcmNbTE9PU0VdID0gJ14nICsgTE9PU0VQTEFJTiArICckJztcblxudmFyIEdUTFQgPSBSKys7XG5zcmNbR1RMVF0gPSAnKCg/Ojx8Pik/PT8pJztcblxuLy8gU29tZXRoaW5nIGxpa2UgXCIyLipcIiBvciBcIjEuMi54XCIuXG4vLyBOb3RlIHRoYXQgXCJ4LnhcIiBpcyBhIHZhbGlkIHhSYW5nZSBpZGVudGlmZXIsIG1lYW5pbmcgXCJhbnkgdmVyc2lvblwiXG4vLyBPbmx5IHRoZSBmaXJzdCBpdGVtIGlzIHN0cmljdGx5IHJlcXVpcmVkLlxudmFyIFhSQU5HRUlERU5USUZJRVJMT09TRSA9IFIrKztcbnNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdID0gc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJ3x4fFh8XFxcXConO1xudmFyIFhSQU5HRUlERU5USUZJRVIgPSBSKys7XG5zcmNbWFJBTkdFSURFTlRJRklFUl0gPSBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJ3x4fFh8XFxcXConO1xuXG52YXIgWFJBTkdFUExBSU4gPSBSKys7XG5zcmNbWFJBTkdFUExBSU5dID0gJ1t2PVxcXFxzXSooJyArIHNyY1tYUkFOR0VJREVOVElGSUVSXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnKD86JyArIHNyY1tQUkVSRUxFQVNFXSArICcpPycgK1xuICAgICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPycgK1xuICAgICAgICAgICAgICAgICAgICcpPyk/JztcblxudmFyIFhSQU5HRVBMQUlOTE9PU0UgPSBSKys7XG5zcmNbWFJBTkdFUExBSU5MT09TRV0gPSAnW3Y9XFxcXHNdKignICsgc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzonICsgc3JjW1BSRVJFTEVBU0VMT09TRV0gKyAnKT8nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyk/KT8nO1xuXG52YXIgWFJBTkdFID0gUisrO1xuc3JjW1hSQU5HRV0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxcXHMqJyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnJCc7XG52YXIgWFJBTkdFTE9PU0UgPSBSKys7XG5zcmNbWFJBTkdFTE9PU0VdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKicgKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7XG5cbi8vIENvZXJjaW9uLlxuLy8gRXh0cmFjdCBhbnl0aGluZyB0aGF0IGNvdWxkIGNvbmNlaXZhYmx5IGJlIGEgcGFydCBvZiBhIHZhbGlkIHNlbXZlclxudmFyIENPRVJDRSA9IFIrKztcbnNyY1tDT0VSQ0VdID0gJyg/Ol58W15cXFxcZF0pJyArXG4gICAgICAgICAgICAgICcoXFxcXGR7MSwnICsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCArICd9KScgK1xuICAgICAgICAgICAgICAnKD86XFxcXC4oXFxcXGR7MSwnICsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCArICd9KSk/JyArXG4gICAgICAgICAgICAgICcoPzpcXFxcLihcXFxcZHsxLCcgKyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIICsgJ30pKT8nICtcbiAgICAgICAgICAgICAgJyg/OiR8W15cXFxcZF0pJztcblxuLy8gVGlsZGUgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcInJlYXNvbmFibHkgYXQgb3IgZ3JlYXRlciB0aGFuXCJcbnZhciBMT05FVElMREUgPSBSKys7XG5zcmNbTE9ORVRJTERFXSA9ICcoPzp+Pj8pJztcblxudmFyIFRJTERFVFJJTSA9IFIrKztcbnNyY1tUSUxERVRSSU1dID0gJyhcXFxccyopJyArIHNyY1tMT05FVElMREVdICsgJ1xcXFxzKyc7XG5yZVtUSUxERVRSSU1dID0gbmV3IFJlZ0V4cChzcmNbVElMREVUUklNXSwgJ2cnKTtcbnZhciB0aWxkZVRyaW1SZXBsYWNlID0gJyQxfic7XG5cbnZhciBUSUxERSA9IFIrKztcbnNyY1tUSUxERV0gPSAnXicgKyBzcmNbTE9ORVRJTERFXSArIHNyY1tYUkFOR0VQTEFJTl0gKyAnJCc7XG52YXIgVElMREVMT09TRSA9IFIrKztcbnNyY1tUSUxERUxPT1NFXSA9ICdeJyArIHNyY1tMT05FVElMREVdICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyQnO1xuXG4vLyBDYXJldCByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwiYXQgbGVhc3QgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGhcIlxudmFyIExPTkVDQVJFVCA9IFIrKztcbnNyY1tMT05FQ0FSRVRdID0gJyg/OlxcXFxeKSc7XG5cbnZhciBDQVJFVFRSSU0gPSBSKys7XG5zcmNbQ0FSRVRUUklNXSA9ICcoXFxcXHMqKScgKyBzcmNbTE9ORUNBUkVUXSArICdcXFxccysnO1xucmVbQ0FSRVRUUklNXSA9IG5ldyBSZWdFeHAoc3JjW0NBUkVUVFJJTV0sICdnJyk7XG52YXIgY2FyZXRUcmltUmVwbGFjZSA9ICckMV4nO1xuXG52YXIgQ0FSRVQgPSBSKys7XG5zcmNbQ0FSRVRdID0gJ14nICsgc3JjW0xPTkVDQVJFVF0gKyBzcmNbWFJBTkdFUExBSU5dICsgJyQnO1xudmFyIENBUkVUTE9PU0UgPSBSKys7XG5zcmNbQ0FSRVRMT09TRV0gPSAnXicgKyBzcmNbTE9ORUNBUkVUXSArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICckJztcblxuLy8gQSBzaW1wbGUgZ3QvbHQvZXEgdGhpbmcsIG9yIGp1c3QgXCJcIiB0byBpbmRpY2F0ZSBcImFueSB2ZXJzaW9uXCJcbnZhciBDT01QQVJBVE9STE9PU0UgPSBSKys7XG5zcmNbQ09NUEFSQVRPUkxPT1NFXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyooJyArIExPT1NFUExBSU4gKyAnKSR8XiQnO1xudmFyIENPTVBBUkFUT1IgPSBSKys7XG5zcmNbQ09NUEFSQVRPUl0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxcXHMqKCcgKyBGVUxMUExBSU4gKyAnKSR8XiQnO1xuXG5cbi8vIEFuIGV4cHJlc3Npb24gdG8gc3RyaXAgYW55IHdoaXRlc3BhY2UgYmV0d2VlbiB0aGUgZ3RsdCBhbmQgdGhlIHRoaW5nXG4vLyBpdCBtb2RpZmllcywgc28gdGhhdCBgPiAxLjIuM2AgPT0+IGA+MS4yLjNgXG52YXIgQ09NUEFSQVRPUlRSSU0gPSBSKys7XG5zcmNbQ09NUEFSQVRPUlRSSU1dID0gJyhcXFxccyopJyArIHNyY1tHVExUXSArXG4gICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKignICsgTE9PU0VQTEFJTiArICd8JyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnKSc7XG5cbi8vIHRoaXMgb25lIGhhcyB0byB1c2UgdGhlIC9nIGZsYWdcbnJlW0NPTVBBUkFUT1JUUklNXSA9IG5ldyBSZWdFeHAoc3JjW0NPTVBBUkFUT1JUUklNXSwgJ2cnKTtcbnZhciBjb21wYXJhdG9yVHJpbVJlcGxhY2UgPSAnJDEkMiQzJztcblxuXG4vLyBTb21ldGhpbmcgbGlrZSBgMS4yLjMgLSAxLjIuNGBcbi8vIE5vdGUgdGhhdCB0aGVzZSBhbGwgdXNlIHRoZSBsb29zZSBmb3JtLCBiZWNhdXNlIHRoZXknbGwgYmVcbi8vIGNoZWNrZWQgYWdhaW5zdCBlaXRoZXIgdGhlIHN0cmljdCBvciBsb29zZSBjb21wYXJhdG9yIGZvcm1cbi8vIGxhdGVyLlxudmFyIEhZUEhFTlJBTkdFID0gUisrO1xuc3JjW0hZUEhFTlJBTkdFXSA9ICdeXFxcXHMqKCcgKyBzcmNbWFJBTkdFUExBSU5dICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnXFxcXHMrLVxcXFxzKycgK1xuICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICdcXFxccyokJztcblxudmFyIEhZUEhFTlJBTkdFTE9PU0UgPSBSKys7XG5zcmNbSFlQSEVOUkFOR0VMT09TRV0gPSAnXlxcXFxzKignICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXFxccystXFxcXHMrJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKiQnO1xuXG4vLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG52YXIgU1RBUiA9IFIrKztcbnNyY1tTVEFSXSA9ICcoPHw+KT89P1xcXFxzKlxcXFwqJztcblxuLy8gQ29tcGlsZSB0byBhY3R1YWwgcmVnZXhwIG9iamVjdHMuXG4vLyBBbGwgYXJlIGZsYWctZnJlZSwgdW5sZXNzIHRoZXkgd2VyZSBjcmVhdGVkIGFib3ZlIHdpdGggYSBmbGFnLlxuZm9yICh2YXIgaSA9IDA7IGkgPCBSOyBpKyspIHtcbiAgZGVidWcoaSwgc3JjW2ldKTtcbiAgaWYgKCFyZVtpXSlcbiAgICByZVtpXSA9IG5ldyBSZWdFeHAoc3JjW2ldKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZnVuY3Rpb24gcGFyc2UodmVyc2lvbiwgbG9vc2UpIHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpXG4gICAgcmV0dXJuIHZlcnNpb247XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJylcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciByID0gbG9vc2UgPyByZVtMT09TRV0gOiByZVtGVUxMXTtcbiAgaWYgKCFyLnRlc3QodmVyc2lvbikpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBsb29zZSk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0cy52YWxpZCA9IHZhbGlkO1xuZnVuY3Rpb24gdmFsaWQodmVyc2lvbiwgbG9vc2UpIHtcbiAgdmFyIHYgPSBwYXJzZSh2ZXJzaW9uLCBsb29zZSk7XG4gIHJldHVybiB2ID8gdi52ZXJzaW9uIDogbnVsbDtcbn1cblxuXG5leHBvcnRzLmNsZWFuID0gY2xlYW47XG5mdW5jdGlvbiBjbGVhbih2ZXJzaW9uLCBsb29zZSkge1xuICB2YXIgcyA9IHBhcnNlKHZlcnNpb24udHJpbSgpLnJlcGxhY2UoL15bPXZdKy8sICcnKSwgbG9vc2UpO1xuICByZXR1cm4gcyA/IHMudmVyc2lvbiA6IG51bGw7XG59XG5cbmV4cG9ydHMuU2VtVmVyID0gU2VtVmVyO1xuXG5mdW5jdGlvbiBTZW1WZXIodmVyc2lvbiwgbG9vc2UpIHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICBpZiAodmVyc2lvbi5sb29zZSA9PT0gbG9vc2UpXG4gICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICBlbHNlXG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbi52ZXJzaW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgVmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2ZXJzaW9uIGlzIGxvbmdlciB0aGFuICcgKyBNQVhfTEVOR1RIICsgJyBjaGFyYWN0ZXJzJylcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBsb29zZSk7XG5cbiAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIGxvb3NlKTtcbiAgdGhpcy5sb29zZSA9IGxvb3NlO1xuICB2YXIgbSA9IHZlcnNpb24udHJpbSgpLm1hdGNoKGxvb3NlID8gcmVbTE9PU0VdIDogcmVbRlVMTF0pO1xuXG4gIGlmICghbSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFZlcnNpb246ICcgKyB2ZXJzaW9uKTtcblxuICB0aGlzLnJhdyA9IHZlcnNpb247XG5cbiAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgdGhpcy5tYWpvciA9ICttWzFdO1xuICB0aGlzLm1pbm9yID0gK21bMl07XG4gIHRoaXMucGF0Y2ggPSArbVszXTtcblxuICBpZiAodGhpcy5tYWpvciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5tYWpvciA8IDApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcblxuICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtaW5vciB2ZXJzaW9uJylcblxuICBpZiAodGhpcy5wYXRjaCA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5wYXRjaCA8IDApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwYXRjaCB2ZXJzaW9uJylcblxuICAvLyBudW1iZXJpZnkgYW55IHByZXJlbGVhc2UgbnVtZXJpYyBpZHNcbiAgaWYgKCFtWzRdKVxuICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICBlbHNlXG4gICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcChmdW5jdGlvbihpZCkge1xuICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgdmFyIG51bSA9ICtpZDtcbiAgICAgICAgaWYgKG51bSA+PSAwICYmIG51bSA8IE1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpZDtcbiAgICB9KTtcblxuICB0aGlzLmJ1aWxkID0gbVs1XSA/IG1bNV0uc3BsaXQoJy4nKSA6IFtdO1xuICB0aGlzLmZvcm1hdCgpO1xufVxuXG5TZW1WZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnZlcnNpb24gPSB0aGlzLm1ham9yICsgJy4nICsgdGhpcy5taW5vciArICcuJyArIHRoaXMucGF0Y2g7XG4gIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHRoaXMudmVyc2lvbiArPSAnLScgKyB0aGlzLnByZXJlbGVhc2Uuam9pbignLicpO1xuICByZXR1cm4gdGhpcy52ZXJzaW9uO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy52ZXJzaW9uO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgZGVidWcoJ1NlbVZlci5jb21wYXJlJywgdGhpcy52ZXJzaW9uLCB0aGlzLmxvb3NlLCBvdGhlcik7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMubG9vc2UpO1xuXG4gIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlTWFpbiA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMubG9vc2UpO1xuXG4gIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlUHJlID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKVxuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5sb29zZSk7XG5cbiAgLy8gTk9UIGhhdmluZyBhIHByZXJlbGVhc2UgaXMgPiBoYXZpbmcgb25lXG4gIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aClcbiAgICByZXR1cm4gLTE7XG4gIGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmIG90aGVyLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHJldHVybiAxO1xuICBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpXG4gICAgcmV0dXJuIDA7XG5cbiAgdmFyIGkgPSAwO1xuICBkbyB7XG4gICAgdmFyIGEgPSB0aGlzLnByZXJlbGVhc2VbaV07XG4gICAgdmFyIGIgPSBvdGhlci5wcmVyZWxlYXNlW2ldO1xuICAgIGRlYnVnKCdwcmVyZWxlYXNlIGNvbXBhcmUnLCBpLCBhLCBiKTtcbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAwO1xuICAgIGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhID09PSBiKVxuICAgICAgY29udGludWU7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKTtcbiAgfSB3aGlsZSAoKytpKTtcbn07XG5cbi8vIHByZW1pbm9yIHdpbGwgYnVtcCB0aGUgdmVyc2lvbiB1cCB0byB0aGUgbmV4dCBtaW5vciByZWxlYXNlLCBhbmQgaW1tZWRpYXRlbHlcbi8vIGRvd24gdG8gcHJlLXJlbGVhc2UuIHByZW1ham9yIGFuZCBwcmVwYXRjaCB3b3JrIHRoZSBzYW1lIHdheS5cblNlbVZlci5wcm90b3R5cGUuaW5jID0gZnVuY3Rpb24ocmVsZWFzZSwgaWRlbnRpZmllcikge1xuICBzd2l0Y2ggKHJlbGVhc2UpIHtcbiAgICBjYXNlICdwcmVtYWpvcic6XG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5taW5vciA9IDA7XG4gICAgICB0aGlzLm1ham9yKys7XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5taW5vcisrO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHJlcGF0Y2gnOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb25cbiAgICAgIC8vIGRyb3AgYW55IHByZXJlbGVhc2VzIHRoYXQgbWlnaHQgYWxyZWFkeSBleGlzdCwgc2luY2UgdGhleSBhcmUgbm90XG4gICAgICAvLyByZWxldmFudCBhdCB0aGlzIHBvaW50LlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKTtcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhIG5vbi1wcmVyZWxlYXNlIHZlcnNpb24sIHRoaXMgYWN0cyB0aGUgc2FtZSBhc1xuICAgIC8vIHByZXBhdGNoLlxuICAgIGNhc2UgJ3ByZXJlbGVhc2UnOlxuICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdtYWpvcic6XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1ham9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWFqb3IgdmVyc2lvbi5cbiAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAvLyAxLjAuMC01IGJ1bXBzIHRvIDEuMC4wXG4gICAgICAvLyAxLjEuMCBidW1wcyB0byAyLjAuMFxuICAgICAgaWYgKHRoaXMubWlub3IgIT09IDAgfHwgdGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLm1ham9yKys7XG4gICAgICB0aGlzLm1pbm9yID0gMDtcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtaW5vcic6XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWlub3IuXG4gICAgICAvLyAxLjIuMC01IGJ1bXBzIHRvIDEuMi4wXG4gICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5taW5vcisrO1xuICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiwgaXQgd2lsbCBpbmNyZW1lbnQgdGhlIHBhdGNoLlxuICAgICAgLy8gSWYgaXQgaXMgYSBwcmUtcmVsZWFzZSBpdCB3aWxsIGJ1bXAgdXAgdG8gdGhlIHNhbWUgcGF0Y2ggdmVyc2lvbi5cbiAgICAgIC8vIDEuMi4wLTUgcGF0Y2hlcyB0byAxLjIuMFxuICAgICAgLy8gMS4yLjAgcGF0Y2hlcyB0byAxLjIuMVxuICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMucGF0Y2grKztcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZCBwdWJsaWNseS5cbiAgICAvLyAxLjAuMCBcInByZVwiIHdvdWxkIGJlY29tZSAxLjAuMC0wIHdoaWNoIGlzIHRoZSB3cm9uZyBkaXJlY3Rpb24uXG4gICAgY2FzZSAncHJlJzpcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbMF07XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnByZXJlbGVhc2UubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlcmVsZWFzZVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZVtpXSsrO1xuICAgICAgICAgICAgaSA9IC0yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gLTEpIC8vIGRpZG4ndCBpbmNyZW1lbnQgYW55dGhpbmdcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaCgwKTtcbiAgICAgIH1cbiAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2VbMF0gPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSlcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogJyArIHJlbGVhc2UpO1xuICB9XG4gIHRoaXMuZm9ybWF0KCk7XG4gIHRoaXMucmF3ID0gdGhpcy52ZXJzaW9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmV4cG9ydHMuaW5jID0gaW5jO1xuZnVuY3Rpb24gaW5jKHZlcnNpb24sIHJlbGVhc2UsIGxvb3NlLCBpZGVudGlmaWVyKSB7XG4gIGlmICh0eXBlb2YobG9vc2UpID09PSAnc3RyaW5nJykge1xuICAgIGlkZW50aWZpZXIgPSBsb29zZTtcbiAgICBsb29zZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpLmluYyhyZWxlYXNlLCBpZGVudGlmaWVyKS52ZXJzaW9uO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydHMuZGlmZiA9IGRpZmY7XG5mdW5jdGlvbiBkaWZmKHZlcnNpb24xLCB2ZXJzaW9uMikge1xuICBpZiAoZXEodmVyc2lvbjEsIHZlcnNpb24yKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHZhciB2MSA9IHBhcnNlKHZlcnNpb24xKTtcbiAgICB2YXIgdjIgPSBwYXJzZSh2ZXJzaW9uMik7XG4gICAgaWYgKHYxLnByZXJlbGVhc2UubGVuZ3RoIHx8IHYyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdjEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ21ham9yJyB8fCBrZXkgPT09ICdtaW5vcicgfHwga2V5ID09PSAncGF0Y2gnKSB7XG4gICAgICAgICAgaWYgKHYxW2tleV0gIT09IHYyW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiAncHJlJytrZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJ3ByZXJlbGVhc2UnO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gdjEpIHtcbiAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICBpZiAodjFba2V5XSAhPT0gdjJba2V5XSkge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5jb21wYXJlSWRlbnRpZmllcnMgPSBjb21wYXJlSWRlbnRpZmllcnM7XG5cbnZhciBudW1lcmljID0gL15bMC05XSskLztcbmZ1bmN0aW9uIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKSB7XG4gIHZhciBhbnVtID0gbnVtZXJpYy50ZXN0KGEpO1xuICB2YXIgYm51bSA9IG51bWVyaWMudGVzdChiKTtcblxuICBpZiAoYW51bSAmJiBibnVtKSB7XG4gICAgYSA9ICthO1xuICAgIGIgPSArYjtcbiAgfVxuXG4gIHJldHVybiAoYW51bSAmJiAhYm51bSkgPyAtMSA6XG4gICAgICAgICAoYm51bSAmJiAhYW51bSkgPyAxIDpcbiAgICAgICAgIGEgPCBiID8gLTEgOlxuICAgICAgICAgYSA+IGIgPyAxIDpcbiAgICAgICAgIDA7XG59XG5cbmV4cG9ydHMucmNvbXBhcmVJZGVudGlmaWVycyA9IHJjb21wYXJlSWRlbnRpZmllcnM7XG5mdW5jdGlvbiByY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhiLCBhKTtcbn1cblxuZXhwb3J0cy5tYWpvciA9IG1ham9yO1xuZnVuY3Rpb24gbWFqb3IoYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yO1xufVxuXG5leHBvcnRzLm1pbm9yID0gbWlub3I7XG5mdW5jdGlvbiBtaW5vcihhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkubWlub3I7XG59XG5cbmV4cG9ydHMucGF0Y2ggPSBwYXRjaDtcbmZ1bmN0aW9uIHBhdGNoKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaDtcbn1cblxuZXhwb3J0cy5jb21wYXJlID0gY29tcGFyZTtcbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpO1xufVxuXG5leHBvcnRzLmNvbXBhcmVMb29zZSA9IGNvbXBhcmVMb29zZTtcbmZ1bmN0aW9uIGNvbXBhcmVMb29zZShhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIHRydWUpO1xufVxuXG5leHBvcnRzLnJjb21wYXJlID0gcmNvbXBhcmU7XG5mdW5jdGlvbiByY29tcGFyZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShiLCBhLCBsb29zZSk7XG59XG5cbmV4cG9ydHMuc29ydCA9IHNvcnQ7XG5mdW5jdGlvbiBzb3J0KGxpc3QsIGxvb3NlKSB7XG4gIHJldHVybiBsaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBleHBvcnRzLmNvbXBhcmUoYSwgYiwgbG9vc2UpO1xuICB9KTtcbn1cblxuZXhwb3J0cy5yc29ydCA9IHJzb3J0O1xuZnVuY3Rpb24gcnNvcnQobGlzdCwgbG9vc2UpIHtcbiAgcmV0dXJuIGxpc3Quc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMucmNvbXBhcmUoYSwgYiwgbG9vc2UpO1xuICB9KTtcbn1cblxuZXhwb3J0cy5ndCA9IGd0O1xuZnVuY3Rpb24gZ3QoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMDtcbn1cblxuZXhwb3J0cy5sdCA9IGx0O1xuZnVuY3Rpb24gbHQoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpIDwgMDtcbn1cblxuZXhwb3J0cy5lcSA9IGVxO1xuZnVuY3Rpb24gZXEoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID09PSAwO1xufVxuXG5leHBvcnRzLm5lcSA9IG5lcTtcbmZ1bmN0aW9uIG5lcShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgIT09IDA7XG59XG5cbmV4cG9ydHMuZ3RlID0gZ3RlO1xuZnVuY3Rpb24gZ3RlKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+PSAwO1xufVxuXG5leHBvcnRzLmx0ZSA9IGx0ZTtcbmZ1bmN0aW9uIGx0ZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPD0gMDtcbn1cblxuZXhwb3J0cy5jbXAgPSBjbXA7XG5mdW5jdGlvbiBjbXAoYSwgb3AsIGIsIGxvb3NlKSB7XG4gIHZhciByZXQ7XG4gIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlICc9PT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JykgYSA9IGEudmVyc2lvbjtcbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIGIgPSBiLnZlcnNpb247XG4gICAgICByZXQgPSBhID09PSBiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnIT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIGEgPSBhLnZlcnNpb247XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKSBiID0gYi52ZXJzaW9uO1xuICAgICAgcmV0ID0gYSAhPT0gYjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyc6IGNhc2UgJz0nOiBjYXNlICc9PSc6IHJldCA9IGVxKGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnIT0nOiByZXQgPSBuZXEoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICc+JzogcmV0ID0gZ3QoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICc+PSc6IHJldCA9IGd0ZShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJzwnOiByZXQgPSBsdChhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJzw9JzogcmV0ID0gbHRlKGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvcGVyYXRvcjogJyArIG9wKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnRzLkNvbXBhcmF0b3IgPSBDb21wYXJhdG9yO1xuZnVuY3Rpb24gQ29tcGFyYXRvcihjb21wLCBsb29zZSkge1xuICBpZiAoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICBpZiAoY29tcC5sb29zZSA9PT0gbG9vc2UpXG4gICAgICByZXR1cm4gY29tcDtcbiAgICBlbHNlXG4gICAgICBjb21wID0gY29tcC52YWx1ZTtcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSlcbiAgICByZXR1cm4gbmV3IENvbXBhcmF0b3IoY29tcCwgbG9vc2UpO1xuXG4gIGRlYnVnKCdjb21wYXJhdG9yJywgY29tcCwgbG9vc2UpO1xuICB0aGlzLmxvb3NlID0gbG9vc2U7XG4gIHRoaXMucGFyc2UoY29tcCk7XG5cbiAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpXG4gICAgdGhpcy52YWx1ZSA9ICcnO1xuICBlbHNlXG4gICAgdGhpcy52YWx1ZSA9IHRoaXMub3BlcmF0b3IgKyB0aGlzLnNlbXZlci52ZXJzaW9uO1xuXG4gIGRlYnVnKCdjb21wJywgdGhpcyk7XG59XG5cbnZhciBBTlkgPSB7fTtcbkNvbXBhcmF0b3IucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oY29tcCkge1xuICB2YXIgciA9IHRoaXMubG9vc2UgPyByZVtDT01QQVJBVE9STE9PU0VdIDogcmVbQ09NUEFSQVRPUl07XG4gIHZhciBtID0gY29tcC5tYXRjaChyKTtcblxuICBpZiAoIW0pXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjb21wYXJhdG9yOiAnICsgY29tcCk7XG5cbiAgdGhpcy5vcGVyYXRvciA9IG1bMV07XG4gIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpXG4gICAgdGhpcy5vcGVyYXRvciA9ICcnO1xuXG4gIC8vIGlmIGl0IGxpdGVyYWxseSBpcyBqdXN0ICc+JyBvciAnJyB0aGVuIGFsbG93IGFueXRoaW5nLlxuICBpZiAoIW1bMl0pXG4gICAgdGhpcy5zZW12ZXIgPSBBTlk7XG4gIGVsc2VcbiAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5sb29zZSk7XG59O1xuXG5Db21wYXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbih2ZXJzaW9uKSB7XG4gIGRlYnVnKCdDb21wYXJhdG9yLnRlc3QnLCB2ZXJzaW9uLCB0aGlzLmxvb3NlKTtcblxuICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSlcbiAgICByZXR1cm4gdHJ1ZTtcblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKVxuICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMubG9vc2UpO1xuXG4gIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMubG9vc2UpO1xufTtcblxuQ29tcGFyYXRvci5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKGNvbXAsIGxvb3NlKSB7XG4gIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgQ29tcGFyYXRvciBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgdmFyIHJhbmdlVG1wO1xuXG4gIGlmICh0aGlzLm9wZXJhdG9yID09PSAnJykge1xuICAgIHJhbmdlVG1wID0gbmV3IFJhbmdlKGNvbXAudmFsdWUsIGxvb3NlKTtcbiAgICByZXR1cm4gc2F0aXNmaWVzKHRoaXMudmFsdWUsIHJhbmdlVG1wLCBsb29zZSk7XG4gIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHtcbiAgICByYW5nZVRtcCA9IG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBsb29zZSk7XG4gICAgcmV0dXJuIHNhdGlzZmllcyhjb21wLnNlbXZlciwgcmFuZ2VUbXAsIGxvb3NlKTtcbiAgfVxuXG4gIHZhciBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyA9XG4gICAgKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJz4nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+Jyk7XG4gIHZhciBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyA9XG4gICAgKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8Jyk7XG4gIHZhciBzYW1lU2VtVmVyID0gdGhpcy5zZW12ZXIudmVyc2lvbiA9PT0gY29tcC5zZW12ZXIudmVyc2lvbjtcbiAgdmFyIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8PScpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzw9Jyk7XG4gIHZhciBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiA9XG4gICAgY21wKHRoaXMuc2VtdmVyLCAnPCcsIGNvbXAuc2VtdmVyLCBsb29zZSkgJiZcbiAgICAoKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJz4nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8JykpO1xuICB2YXIgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW4gPVxuICAgIGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgbG9vc2UpICYmXG4gICAgKCh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpKTtcblxuICByZXR1cm4gc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgfHwgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgfHxcbiAgICAoc2FtZVNlbVZlciAmJiBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlKSB8fFxuICAgIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuIHx8IG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuO1xufTtcblxuXG5leHBvcnRzLlJhbmdlID0gUmFuZ2U7XG5mdW5jdGlvbiBSYW5nZShyYW5nZSwgbG9vc2UpIHtcbiAgaWYgKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICBpZiAocmFuZ2UubG9vc2UgPT09IGxvb3NlKSB7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UucmF3LCBsb29zZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJhbmdlIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UudmFsdWUsIGxvb3NlKTtcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5nZSkpXG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpO1xuXG4gIHRoaXMubG9vc2UgPSBsb29zZTtcblxuICAvLyBGaXJzdCwgc3BsaXQgYmFzZWQgb24gYm9vbGVhbiBvciB8fFxuICB0aGlzLnJhdyA9IHJhbmdlO1xuICB0aGlzLnNldCA9IHJhbmdlLnNwbGl0KC9cXHMqXFx8XFx8XFxzKi8pLm1hcChmdW5jdGlvbihyYW5nZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUmFuZ2UocmFuZ2UudHJpbSgpKTtcbiAgfSwgdGhpcykuZmlsdGVyKGZ1bmN0aW9uKGMpIHtcbiAgICAvLyB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCByZWxldmFudCBmb3Igd2hhdGV2ZXIgcmVhc29uXG4gICAgcmV0dXJuIGMubGVuZ3RoO1xuICB9KTtcblxuICBpZiAoIXRoaXMuc2V0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgU2VtVmVyIFJhbmdlOiAnICsgcmFuZ2UpO1xuICB9XG5cbiAgdGhpcy5mb3JtYXQoKTtcbn1cblxuUmFuZ2UucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJhbmdlID0gdGhpcy5zZXQubWFwKGZ1bmN0aW9uKGNvbXBzKSB7XG4gICAgcmV0dXJuIGNvbXBzLmpvaW4oJyAnKS50cmltKCk7XG4gIH0pLmpvaW4oJ3x8JykudHJpbSgpO1xuICByZXR1cm4gdGhpcy5yYW5nZTtcbn07XG5cblJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yYW5nZTtcbn07XG5cblJhbmdlLnByb3RvdHlwZS5wYXJzZVJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgdmFyIGxvb3NlID0gdGhpcy5sb29zZTtcbiAgcmFuZ2UgPSByYW5nZS50cmltKCk7XG4gIGRlYnVnKCdyYW5nZScsIHJhbmdlLCBsb29zZSk7XG4gIC8vIGAxLjIuMyAtIDEuMi40YCA9PiBgPj0xLjIuMyA8PTEuMi40YFxuICB2YXIgaHIgPSBsb29zZSA/IHJlW0hZUEhFTlJBTkdFTE9PU0VdIDogcmVbSFlQSEVOUkFOR0VdO1xuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UoaHIsIGh5cGhlblJlcGxhY2UpO1xuICBkZWJ1ZygnaHlwaGVuIHJlcGxhY2UnLCByYW5nZSk7XG4gIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbQ09NUEFSQVRPUlRSSU1dLCBjb21wYXJhdG9yVHJpbVJlcGxhY2UpO1xuICBkZWJ1ZygnY29tcGFyYXRvciB0cmltJywgcmFuZ2UsIHJlW0NPTVBBUkFUT1JUUklNXSk7XG5cbiAgLy8gYH4gMS4yLjNgID0+IGB+MS4yLjNgXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVtUSUxERVRSSU1dLCB0aWxkZVRyaW1SZXBsYWNlKTtcblxuICAvLyBgXiAxLjIuM2AgPT4gYF4xLjIuM2BcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW0NBUkVUVFJJTV0sIGNhcmV0VHJpbVJlcGxhY2UpO1xuXG4gIC8vIG5vcm1hbGl6ZSBzcGFjZXNcbiAgcmFuZ2UgPSByYW5nZS5zcGxpdCgvXFxzKy8pLmpvaW4oJyAnKTtcblxuICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSB0cmltbWVkIGFuZFxuICAvLyByZWFkeSB0byBiZSBzcGxpdCBpbnRvIGNvbXBhcmF0b3JzLlxuXG4gIHZhciBjb21wUmUgPSBsb29zZSA/IHJlW0NPTVBBUkFUT1JMT09TRV0gOiByZVtDT01QQVJBVE9SXTtcbiAgdmFyIHNldCA9IHJhbmdlLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gcGFyc2VDb21wYXJhdG9yKGNvbXAsIGxvb3NlKTtcbiAgfSkuam9pbignICcpLnNwbGl0KC9cXHMrLyk7XG4gIGlmICh0aGlzLmxvb3NlKSB7XG4gICAgLy8gaW4gbG9vc2UgbW9kZSwgdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgdmFsaWQgY29tcGFyYXRvcnNcbiAgICBzZXQgPSBzZXQuZmlsdGVyKGZ1bmN0aW9uKGNvbXApIHtcbiAgICAgIHJldHVybiAhIWNvbXAubWF0Y2goY29tcFJlKTtcbiAgICB9KTtcbiAgfVxuICBzZXQgPSBzZXQubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gbmV3IENvbXBhcmF0b3IoY29tcCwgbG9vc2UpO1xuICB9KTtcblxuICByZXR1cm4gc2V0O1xufTtcblxuUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbihyYW5nZSwgbG9vc2UpIHtcbiAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5zZXQuc29tZShmdW5jdGlvbih0aGlzQ29tcGFyYXRvcnMpIHtcbiAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KGZ1bmN0aW9uKHRoaXNDb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gcmFuZ2Uuc2V0LnNvbWUoZnVuY3Rpb24ocmFuZ2VDb21wYXJhdG9ycykge1xuICAgICAgICByZXR1cm4gcmFuZ2VDb21wYXJhdG9ycy5ldmVyeShmdW5jdGlvbihyYW5nZUNvbXBhcmF0b3IpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3IuaW50ZXJzZWN0cyhyYW5nZUNvbXBhcmF0b3IsIGxvb3NlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5leHBvcnRzLnRvQ29tcGFyYXRvcnMgPSB0b0NvbXBhcmF0b3JzO1xuZnVuY3Rpb24gdG9Db21wYXJhdG9ycyhyYW5nZSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpLnNldC5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiBjb21wLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICB9KS5qb2luKCcgJykudHJpbSgpLnNwbGl0KCcgJyk7XG4gIH0pO1xufVxuXG4vLyBjb21wcmlzZWQgb2YgeHJhbmdlcywgdGlsZGVzLCBzdGFycywgYW5kIGd0bHQncyBhdCB0aGlzIHBvaW50LlxuLy8gYWxyZWFkeSByZXBsYWNlZCB0aGUgaHlwaGVuIHJhbmdlc1xuLy8gdHVybiBpbnRvIGEgc2V0IG9mIEpVU1QgY29tcGFyYXRvcnMuXG5mdW5jdGlvbiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgbG9vc2UpIHtcbiAgZGVidWcoJ2NvbXAnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgbG9vc2UpO1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgbG9vc2UpO1xuICBkZWJ1ZygndGlsZGVzJywgY29tcCk7XG4gIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBsb29zZSk7XG4gIGRlYnVnKCd4cmFuZ2UnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBsb29zZSk7XG4gIGRlYnVnKCdzdGFycycsIGNvbXApO1xuICByZXR1cm4gY29tcDtcbn1cblxuZnVuY3Rpb24gaXNYKGlkKSB7XG4gIHJldHVybiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKic7XG59XG5cbi8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gfjIuMCwgfjIuMC54LCB+PjIuMCwgfj4yLjAueCAtLT4gPj0yLjAuMCA8Mi4xLjBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wXG4vLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wXG4vLyB+MS4yLjAsIH4+MS4yLjAgLS0+ID49MS4yLjAgPDEuMy4wXG5mdW5jdGlvbiByZXBsYWNlVGlsZGVzKGNvbXAsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VUaWxkZShjb21wLCBsb29zZSk7XG4gIH0pLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVRpbGRlKGNvbXAsIGxvb3NlKSB7XG4gIHZhciByID0gbG9vc2UgPyByZVtUSUxERUxPT1NFXSA6IHJlW1RJTERFXTtcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbihfLCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCd0aWxkZScsIGNvbXAsIF8sIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKGlzWChNKSlcbiAgICAgIHJldCA9ICcnO1xuICAgIGVsc2UgaWYgKGlzWChtKSlcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICBlbHNlIGlmIChpc1gocCkpXG4gICAgICAvLyB+MS4yID09ID49MS4yLjAgPDEuMy4wXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgIGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZVRpbGRlIHByJywgcHIpO1xuICAgICAgaWYgKHByLmNoYXJBdCgwKSAhPT0gJy0nKVxuICAgICAgICBwciA9ICctJyArIHByO1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgIH0gZWxzZVxuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuXG4gICAgZGVidWcoJ3RpbGRlIHJldHVybicsIHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG5cbi8vIF4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyBeMiwgXjIueCwgXjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gXjIuMCwgXjIuMC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gXjEuMiwgXjEuMi54IC0tPiA+PTEuMi4wIDwyLjAuMFxuLy8gXjEuMi4zIC0tPiA+PTEuMi4zIDwyLjAuMFxuLy8gXjEuMi4wIC0tPiA+PTEuMi4wIDwyLjAuMFxuZnVuY3Rpb24gcmVwbGFjZUNhcmV0cyhjb21wLCBsb29zZSkge1xuICByZXR1cm4gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlQ2FyZXQoY29tcCwgbG9vc2UpO1xuICB9KS5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VDYXJldChjb21wLCBsb29zZSkge1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBsb29zZSk7XG4gIHZhciByID0gbG9vc2UgPyByZVtDQVJFVExPT1NFXSA6IHJlW0NBUkVUXTtcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbihfLCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCdjYXJldCcsIGNvbXAsIF8sIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKGlzWChNKSlcbiAgICAgIHJldCA9ICcnO1xuICAgIGVsc2UgaWYgKGlzWChtKSlcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlQ2FyZXQgcHInLCBwcik7XG4gICAgICBpZiAocHIuY2hhckF0KDApICE9PSAnLScpXG4gICAgICAgIHByID0gJy0nICsgcHI7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpXG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArIG0gKyAnLicgKyAoK3AgKyAxKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICAgJyA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKTtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJylcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArIG0gKyAnLicgKyAoK3AgKyAxKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAnIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgfVxuXG4gICAgZGVidWcoJ2NhcmV0IHJldHVybicsIHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VYUmFuZ2VzKGNvbXAsIGxvb3NlKSB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIGxvb3NlKTtcbiAgcmV0dXJuIGNvbXAuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlWFJhbmdlKGNvbXAsIGxvb3NlKTtcbiAgfSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlWFJhbmdlKGNvbXAsIGxvb3NlKSB7XG4gIGNvbXAgPSBjb21wLnRyaW0oKTtcbiAgdmFyIHIgPSBsb29zZSA/IHJlW1hSQU5HRUxPT1NFXSA6IHJlW1hSQU5HRV07XG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24ocmV0LCBndGx0LCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCd4UmFuZ2UnLCBjb21wLCByZXQsIGd0bHQsIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgeE0gPSBpc1goTSk7XG4gICAgdmFyIHhtID0geE0gfHwgaXNYKG0pO1xuICAgIHZhciB4cCA9IHhtIHx8IGlzWChwKTtcbiAgICB2YXIgYW55WCA9IHhwO1xuXG4gICAgaWYgKGd0bHQgPT09ICc9JyAmJiBhbnlYKVxuICAgICAgZ3RsdCA9ICcnO1xuXG4gICAgaWYgKHhNKSB7XG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgcmV0ID0gJzwwLjAuMCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGZvcmJpZGRlblxuICAgICAgICByZXQgPSAnKic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSlcbiAgICAgICAgbSA9IDA7XG4gICAgICBpZiAoeHApXG4gICAgICAgIHAgPSAwO1xuXG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nKSB7XG4gICAgICAgIC8vID4xID0+ID49Mi4wLjBcbiAgICAgICAgLy8gPjEuMiA9PiA+PTEuMy4wXG4gICAgICAgIC8vID4xLjIuMyA9PiA+PSAxLjIuNFxuICAgICAgICBndGx0ID0gJz49JztcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMTtcbiAgICAgICAgICBtID0gMDtcbiAgICAgICAgICBwID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgICAgIG0gPSArbSArIDE7XG4gICAgICAgICAgcCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ3RsdCA9PT0gJzw9Jykge1xuICAgICAgICAvLyA8PTAuNy54IGlzIGFjdHVhbGx5IDwwLjguMCwgc2luY2UgYW55IDAuNy54IHNob3VsZFxuICAgICAgICAvLyBwYXNzLiAgU2ltaWxhcmx5LCA8PTcueCBpcyBhY3R1YWxseSA8OC4wLjAsIGV0Yy5cbiAgICAgICAgZ3RsdCA9ICc8JztcbiAgICAgICAgaWYgKHhtKVxuICAgICAgICAgIE0gPSArTSArIDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtID0gK20gKyAxO1xuICAgICAgfVxuXG4gICAgICByZXQgPSBndGx0ICsgTSArICcuJyArIG0gKyAnLicgKyBwO1xuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgIH1cblxuICAgIGRlYnVnKCd4UmFuZ2UgcmV0dXJuJywgcmV0KTtcblxuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuXG4vLyBCZWNhdXNlICogaXMgQU5ELWVkIHdpdGggZXZlcnl0aGluZyBlbHNlIGluIHRoZSBjb21wYXJhdG9yLFxuLy8gYW5kICcnIG1lYW5zIFwiYW55IHZlcnNpb25cIiwganVzdCByZW1vdmUgdGhlICpzIGVudGlyZWx5LlxuZnVuY3Rpb24gcmVwbGFjZVN0YXJzKGNvbXAsIGxvb3NlKSB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBsb29zZSk7XG4gIC8vIExvb3NlbmVzcyBpcyBpZ25vcmVkIGhlcmUuICBzdGFyIGlzIGFsd2F5cyBhcyBsb29zZSBhcyBpdCBnZXRzIVxuICByZXR1cm4gY29tcC50cmltKCkucmVwbGFjZShyZVtTVEFSXSwgJycpO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVtIWVBIRU5SQU5HRV0pXG4vLyBNLCBtLCBwYXRjaCwgcHJlcmVsZWFzZSwgYnVpbGRcbi8vIDEuMiAtIDMuNC41ID0+ID49MS4yLjAgPD0zLjQuNVxuLy8gMS4yLjMgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAgQW55IDMuNC54IHdpbGwgZG9cbi8vIDEuMiAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMFxuZnVuY3Rpb24gaHlwaGVuUmVwbGFjZSgkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgICAgICAgICAgICAgICAgICAgICAgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpIHtcblxuICBpZiAoaXNYKGZNKSlcbiAgICBmcm9tID0gJyc7XG4gIGVsc2UgaWYgKGlzWChmbSkpXG4gICAgZnJvbSA9ICc+PScgKyBmTSArICcuMC4wJztcbiAgZWxzZSBpZiAoaXNYKGZwKSlcbiAgICBmcm9tID0gJz49JyArIGZNICsgJy4nICsgZm0gKyAnLjAnO1xuICBlbHNlXG4gICAgZnJvbSA9ICc+PScgKyBmcm9tO1xuXG4gIGlmIChpc1godE0pKVxuICAgIHRvID0gJyc7XG4gIGVsc2UgaWYgKGlzWCh0bSkpXG4gICAgdG8gPSAnPCcgKyAoK3RNICsgMSkgKyAnLjAuMCc7XG4gIGVsc2UgaWYgKGlzWCh0cCkpXG4gICAgdG8gPSAnPCcgKyB0TSArICcuJyArICgrdG0gKyAxKSArICcuMCc7XG4gIGVsc2UgaWYgKHRwcilcbiAgICB0byA9ICc8PScgKyB0TSArICcuJyArIHRtICsgJy4nICsgdHAgKyAnLScgKyB0cHI7XG4gIGVsc2VcbiAgICB0byA9ICc8PScgKyB0bztcblxuICByZXR1cm4gKGZyb20gKyAnICcgKyB0bykudHJpbSgpO1xufVxuXG5cbi8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcblJhbmdlLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24odmVyc2lvbikge1xuICBpZiAoIXZlcnNpb24pXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpXG4gICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5sb29zZSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uKSlcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHRlc3RTZXQoc2V0LCB2ZXJzaW9uKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFzZXRbaV0udGVzdCh2ZXJzaW9uKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh2ZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgLy8gRmluZCB0aGUgc2V0IG9mIHZlcnNpb25zIHRoYXQgYXJlIGFsbG93ZWQgdG8gaGF2ZSBwcmVyZWxlYXNlc1xuICAgIC8vIEZvciBleGFtcGxlLCBeMS4yLjMtcHIuMSBkZXN1Z2FycyB0byA+PTEuMi4zLXByLjEgPDIuMC4wXG4gICAgLy8gVGhhdCBzaG91bGQgYWxsb3cgYDEuMi4zLXByLjJgIHRvIHBhc3MuXG4gICAgLy8gSG93ZXZlciwgYDEuMi40LWFscGhhLm5vdHJlYWR5YCBzaG91bGQgTk9UIGJlIGFsbG93ZWQsXG4gICAgLy8gZXZlbiB0aG91Z2ggaXQncyB3aXRoaW4gdGhlIHJhbmdlIHNldCBieSB0aGUgY29tcGFyYXRvcnMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYnVnKHNldFtpXS5zZW12ZXIpO1xuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IEFOWSlcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXI7XG4gICAgICAgIGlmIChhbGxvd2VkLm1ham9yID09PSB2ZXJzaW9uLm1ham9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLm1pbm9yID09PSB2ZXJzaW9uLm1pbm9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLnBhdGNoID09PSB2ZXJzaW9uLnBhdGNoKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZlcnNpb24gaGFzIGEgLXByZSwgYnV0IGl0J3Mgbm90IG9uZSBvZiB0aGUgb25lcyB3ZSBsaWtlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnRzLnNhdGlzZmllcyA9IHNhdGlzZmllcztcbmZ1bmN0aW9uIHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgbG9vc2UpIHtcbiAgdHJ5IHtcbiAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcmFuZ2UudGVzdCh2ZXJzaW9uKTtcbn1cblxuZXhwb3J0cy5tYXhTYXRpc2Z5aW5nID0gbWF4U2F0aXNmeWluZztcbmZ1bmN0aW9uIG1heFNhdGlzZnlpbmcodmVyc2lvbnMsIHJhbmdlLCBsb29zZSkge1xuICB2YXIgbWF4ID0gbnVsbDtcbiAgdmFyIG1heFNWID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB2YXIgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHsgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBsb29zZSlcbiAgICAgIGlmICghbWF4IHx8IG1heFNWLmNvbXBhcmUodikgPT09IC0xKSB7IC8vIGNvbXBhcmUobWF4LCB2LCB0cnVlKVxuICAgICAgICBtYXggPSB2O1xuICAgICAgICBtYXhTViA9IG5ldyBTZW1WZXIobWF4LCBsb29zZSk7XG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWF4O1xufVxuXG5leHBvcnRzLm1pblNhdGlzZnlpbmcgPSBtaW5TYXRpc2Z5aW5nO1xuZnVuY3Rpb24gbWluU2F0aXNmeWluZyh2ZXJzaW9ucywgcmFuZ2UsIGxvb3NlKSB7XG4gIHZhciBtaW4gPSBudWxsO1xuICB2YXIgbWluU1YgPSBudWxsO1xuICB0cnkge1xuICAgIHZhciByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkgeyAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIGxvb3NlKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkgeyAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdjtcbiAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgbG9vc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1pbjtcbn1cblxuZXhwb3J0cy52YWxpZFJhbmdlID0gdmFsaWRSYW5nZTtcbmZ1bmN0aW9uIHZhbGlkUmFuZ2UocmFuZ2UsIGxvb3NlKSB7XG4gIHRyeSB7XG4gICAgLy8gUmV0dXJuICcqJyBpbnN0ZWFkIG9mICcnIHNvIHRoYXQgdHJ1dGhpbmVzcyB3b3Jrcy5cbiAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgaXQncyBpbnZhbGlkIGFueXdheVxuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKS5yYW5nZSB8fCAnKic7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgbGVzcyB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlXG5leHBvcnRzLmx0ciA9IGx0cjtcbmZ1bmN0aW9uIGx0cih2ZXJzaW9uLCByYW5nZSwgbG9vc2UpIHtcbiAgcmV0dXJuIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc8JywgbG9vc2UpO1xufVxuXG4vLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5leHBvcnRzLmd0ciA9IGd0cjtcbmZ1bmN0aW9uIGd0cih2ZXJzaW9uLCByYW5nZSwgbG9vc2UpIHtcbiAgcmV0dXJuIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc+JywgbG9vc2UpO1xufVxuXG5leHBvcnRzLm91dHNpZGUgPSBvdXRzaWRlO1xuZnVuY3Rpb24gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgaGlsbywgbG9vc2UpIHtcbiAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpO1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpO1xuXG4gIHZhciBndGZuLCBsdGVmbiwgbHRmbiwgY29tcCwgZWNvbXA7XG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0O1xuICAgICAgbHRlZm4gPSBsdGU7XG4gICAgICBsdGZuID0gbHQ7XG4gICAgICBjb21wID0gJz4nO1xuICAgICAgZWNvbXAgPSAnPj0nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHQ7XG4gICAgICBsdGVmbiA9IGd0ZTtcbiAgICAgIGx0Zm4gPSBndDtcbiAgICAgIGNvbXAgPSAnPCc7XG4gICAgICBlY29tcCA9ICc8PSc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKTtcbiAgfVxuXG4gIC8vIElmIGl0IHNhdGlzaWZlcyB0aGUgcmFuZ2UgaXQgaXMgbm90IG91dHNpZGVcbiAgaWYgKHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgbG9vc2UpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXTtcblxuICAgIHZhciBoaWdoID0gbnVsbDtcbiAgICB2YXIgbG93ID0gbnVsbDtcblxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3I7XG4gICAgICBsb3cgPSBsb3cgfHwgY29tcGFyYXRvcjtcbiAgICAgIGlmIChndGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBoaWdoLnNlbXZlciwgbG9vc2UpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yO1xuICAgICAgfSBlbHNlIGlmIChsdGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBsb3cuc2VtdmVyLCBsb29zZSkpIHtcbiAgICAgICAgbG93ID0gY29tcGFyYXRvcjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIElmIHRoZSBlZGdlIHZlcnNpb24gY29tcGFyYXRvciBoYXMgYSBvcGVyYXRvciB0aGVuIG91ciB2ZXJzaW9uXG4gICAgLy8gaXNuJ3Qgb3V0c2lkZSBpdFxuICAgIGlmIChoaWdoLm9wZXJhdG9yID09PSBjb21wIHx8IGhpZ2gub3BlcmF0b3IgPT09IGVjb21wKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvd2VzdCB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGFuIG9wZXJhdG9yIGFuZCBvdXIgdmVyc2lvblxuICAgIC8vIGlzIGxlc3MgdGhhbiBpdCB0aGVuIGl0IGlzbid0IGhpZ2hlciB0aGFuIHRoZSByYW5nZVxuICAgIGlmICgoIWxvdy5vcGVyYXRvciB8fCBsb3cub3BlcmF0b3IgPT09IGNvbXApICYmXG4gICAgICAgIGx0ZWZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydHMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2U7XG5mdW5jdGlvbiBwcmVyZWxlYXNlKHZlcnNpb24sIGxvb3NlKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBsb29zZSk7XG4gIHJldHVybiAocGFyc2VkICYmIHBhcnNlZC5wcmVyZWxlYXNlLmxlbmd0aCkgPyBwYXJzZWQucHJlcmVsZWFzZSA6IG51bGw7XG59XG5cbmV4cG9ydHMuaW50ZXJzZWN0cyA9IGludGVyc2VjdHM7XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHIxLCByMiwgbG9vc2UpIHtcbiAgcjEgPSBuZXcgUmFuZ2UocjEsIGxvb3NlKVxuICByMiA9IG5ldyBSYW5nZShyMiwgbG9vc2UpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyKVxufVxuXG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmZ1bmN0aW9uIGNvZXJjZSh2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKVxuICAgIHJldHVybiB2ZXJzaW9uO1xuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIG1hdGNoID0gdmVyc2lvbi5tYXRjaChyZVtDT0VSQ0VdKTtcblxuICBpZiAobWF0Y2ggPT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICByZXR1cm4gcGFyc2UoKG1hdGNoWzFdIHx8ICcwJykgKyAnLicgKyAobWF0Y2hbMl0gfHwgJzAnKSArICcuJyArIChtYXRjaFszXSB8fCAnMCcpKTsgXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zZW12ZXIvc2VtdmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xudmFyIGRlYnVnID0gcmVxdWlyZSggJ2RlYnVnJyApKCAnaTE4bi13cC1wbHVnaW4nICksXG5cdEplZCA9IHJlcXVpcmUoICdqZWQnICksXG5cdHNoYTEgPSByZXF1aXJlKCAnaGFzaC5qcy9saWIvaGFzaC9zaGEvMScgKSxcblx0RXZlbnRFbWl0dGVyID0gcmVxdWlyZSggJ2V2ZW50cycgKS5FdmVudEVtaXR0ZXIsXG5cdGludGVycG9sYXRlQ29tcG9uZW50cyA9IHJlcXVpcmUoICdpbnRlcnBvbGF0ZS1jb21wb25lbnRzJyApLmRlZmF1bHQsXG5cdExSVSA9IHJlcXVpcmUoICdscnUnICksXG5cdGFzc2lnbiA9IHJlcXVpcmUoICdsb2Rhc2guYXNzaWduJyApO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG52YXIgbnVtYmVyRm9ybWF0UEhQSlMgPSByZXF1aXJlKCAnLi9udW1iZXItZm9ybWF0JyApO1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG52YXIgZGVjaW1hbF9wb2ludF90cmFuc2xhdGlvbl9rZXkgPSAnbnVtYmVyX2Zvcm1hdF9kZWNpbWFscycsXG5cdHRob3VzYW5kc19zZXBfdHJhbnNsYXRpb25fa2V5ID0gJ251bWJlcl9mb3JtYXRfdGhvdXNhbmRzX3NlcCc7XG5cbnZhciB0cmFuc2xhdGlvbkxvb2t1cCA9IFtcblx0Ly8gQnkgZGVmYXVsdCBkb24ndCBtb2RpZnkgdGhlIG9wdGlvbnMgd2hlbiBsb29raW5nIHVwIHRyYW5zbGF0aW9ucy5cblx0ZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH1cbl07XG5cbnZhciBoYXNoQ2FjaGUgPSB7fTtcblxuLy8gcmFpc2UgYSBjb25zb2xlIHdhcm5pbmdcbmZ1bmN0aW9uIHdhcm4oKSB7XG5cdGlmICggISBJMThOLnRocm93RXJyb3JzICkge1xuXHRcdHJldHVybjtcblx0fVxuXHRpZiAoICd1bmRlZmluZWQnICE9PSB0eXBlb2Ygd2luZG93ICYmIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2Fybi5hcHBseSggd2luZG93LmNvbnNvbGUsIGFyZ3VtZW50cyApO1xuXHR9XG59XG5cbi8vIHR1cm5zIEZ1bmN0aW9uLmFyZ3VtZW50cyBpbnRvIGFuIGFycmF5XG5mdW5jdGlvbiBzaW1wbGVBcmd1bWVudHMoIGFyZ3MgKSB7XG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJncyApO1xufVxuXG4vKipcbiAqIENvZXJjZSB0aGUgcG9zc2libGUgYXJndW1lbnRzIGFuZCBub3JtYWxpemUgdG8gYSBzaW5nbGUgb2JqZWN0XG4gKiBAcGFyYW0gIHthcmd1bWVudHN9IGFyZ3MgLSBhcmd1bWVudHMgcGFzc2VkIGluIGZyb20gYHRyYW5zbGF0ZSgpYFxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIC0gYSBzaW5nbGUgb2JqZWN0IGRlc2NyaWJpbmcgdHJhbnNsYXRpb24gbmVlZHNcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplVHJhbnNsYXRlQXJndW1lbnRzKCBhcmdzICkge1xuXHR2YXIgb3JpZ2luYWwgPSBhcmdzWyAwIF0sXG5cdFx0b3B0aW9ucyA9IHt9LFxuXHRcdGk7XG5cblx0Ly8gd2FybiBhYm91dCBvbGRlciBkZXByZWNhdGVkIHN5bnRheFxuXHRpZiAoIHR5cGVvZiBvcmlnaW5hbCAhPT0gJ3N0cmluZycgfHwgYXJncy5sZW5ndGggPiAzIHx8ICggYXJncy5sZW5ndGggPiAyICYmIHR5cGVvZiBhcmdzWyAxIF0gPT09ICdvYmplY3QnICYmIHR5cGVvZiBhcmdzWyAyIF0gPT09ICdvYmplY3QnICkgKSB7XG5cdFx0d2FybiggJ0RlcHJlY2F0ZWQgSW52b2NhdGlvbjogYHRyYW5zbGF0ZSgpYCBhY2NlcHRzICggc3RyaW5nLCBbc3RyaW5nXSwgW29iamVjdF0gKS4gVGhlc2UgYXJndW1lbnRzIHBhc3NlZDonLCBzaW1wbGVBcmd1bWVudHMoIGFyZ3MgKSwgJy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wZW50YXRvbmljZnVuay9pMThuLXdwLXBsdWdpbiN0cmFuc2xhdGUtbWV0aG9kJyApO1xuXHR9XG5cdGlmICggYXJncy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIG9yaWdpbmFsID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYXJnc1sgMSBdID09PSAnc3RyaW5nJyApIHtcblx0XHR3YXJuKCAnSW52YWxpZCBJbnZvY2F0aW9uOiBgdHJhbnNsYXRlKClgIHJlcXVpcmVzIGFuIG9wdGlvbnMgb2JqZWN0IGZvciBwbHVyYWwgdHJhbnNsYXRpb25zLCBidXQgcGFzc2VkOicsIHNpbXBsZUFyZ3VtZW50cyggYXJncyApICk7XG5cdH1cblxuXHQvLyBvcHRpb25zIGNvdWxkIGJlIGluIHBvc2l0aW9uIDAsIDEsIG9yIDJcblx0Ly8gc2VuZGluZyBvcHRpb25zIGFzIHRoZSBmaXJzdCBvYmplY3QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCByYWlzZSBhIHdhcm5pbmdcblx0Zm9yICggaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrICkge1xuXHRcdGlmICggdHlwZW9mIGFyZ3NbIGkgXSA9PT0gJ29iamVjdCcgKSB7XG5cdFx0XHRvcHRpb25zID0gYXJnc1sgaSBdO1xuXHRcdH1cblx0fVxuXG5cdC8vIGBvcmlnaW5hbGAgY2FuIGJlIHBhc3NlZCBhcyBmaXJzdCBwYXJhbWV0ZXIgb3IgYXMgcGFydCBvZiB0aGUgb3B0aW9ucyBvYmplY3Rcblx0Ly8gdGhvdWdoIHBhc3Npbmcgb3JpZ2luYWwgYXMgcGFydCBvZiB0aGUgb3B0aW9ucyBpcyBhIGRlcHJlY2F0ZWQgYXBwcm9hY2ggYW5kIHdpbGwgYmUgcmVtb3ZlZFxuXHRpZiAoIHR5cGVvZiBvcmlnaW5hbCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0b3B0aW9ucy5vcmlnaW5hbCA9IG9yaWdpbmFsO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2Ygb3B0aW9ucy5vcmlnaW5hbCA9PT0gJ29iamVjdCcgKSB7XG5cdFx0b3B0aW9ucy5wbHVyYWwgPSBvcHRpb25zLm9yaWdpbmFsLnBsdXJhbDtcblx0XHRvcHRpb25zLmNvdW50ID0gb3B0aW9ucy5vcmlnaW5hbC5jb3VudDtcblx0XHRvcHRpb25zLm9yaWdpbmFsID0gb3B0aW9ucy5vcmlnaW5hbC5zaW5nbGU7XG5cdH1cblx0aWYgKCB0eXBlb2YgYXJnc1sgMSBdID09PSAnc3RyaW5nJyApIHtcblx0XHRvcHRpb25zLnBsdXJhbCA9IGFyZ3NbIDEgXTtcblx0fVxuXG5cdGlmICggdHlwZW9mIG9wdGlvbnMub3JpZ2luYWwgPT09ICd1bmRlZmluZWQnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggJ1RyYW5zbGF0ZSBjYWxsZWQgd2l0aG91dCBhIGBzdHJpbmdgIHZhbHVlIGFzIGZpcnN0IGFyZ3VtZW50LicgKTtcblx0fVxuXG5cdHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIFB1bGwgdGhlIHJpZ2h0IHNldCBvZiBhcmd1bWVudHMgZm9yIHRoZSBKZWQgbWV0aG9kXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGplZE1ldGhvZCBOYW1lIG9mIGplZCBnZXR0ZXh0LXN0eWxlIG1ldGhvZC4gW1NlZSBkb2NzXShodHRwOi8vc2xleGF4dG9uLmdpdGh1Yi5pby9KZWQvKVxuICogQHBhcmFtICB7W29iamVjdF19IHByb3BzICAgICBwcm9wZXJ0aWVzIHBhc3NlZCBpbnRvIGB0cmFuc2xhdGUoKWAgbWV0aG9kXG4gKiBAcmV0dXJuIHtbYXJyYXldfSAgICAgICAgICAgYXJyYXkgb2YgcHJvcGVydGllcyB0byBwYXNzIGludG8gZ2V0dGV4dC1zdHlsZSBtZXRob2RcbiAqL1xuZnVuY3Rpb24gZ2V0SmVkQXJncyggamVkTWV0aG9kLCBwcm9wcyApIHtcblx0c3dpdGNoICggamVkTWV0aG9kICkge1xuXHRcdGNhc2UgJ2dldHRleHQnOlxuXHRcdFx0cmV0dXJuIFsgcHJvcHMub3JpZ2luYWwgXTtcblx0XHRjYXNlICduZ2V0dGV4dCc6XG5cdFx0XHRyZXR1cm4gWyBwcm9wcy5vcmlnaW5hbCwgcHJvcHMucGx1cmFsLCBwcm9wcy5jb3VudCBdO1xuXHRcdGNhc2UgJ25wZ2V0dGV4dCc6XG5cdFx0XHRyZXR1cm4gWyBwcm9wcy5jb250ZXh0LCBwcm9wcy5vcmlnaW5hbCwgcHJvcHMucGx1cmFsLCBwcm9wcy5jb3VudCBdO1xuXHRcdGNhc2UgJ3BnZXR0ZXh0Jzpcblx0XHRcdHJldHVybiBbIHByb3BzLmNvbnRleHQsIHByb3BzLm9yaWdpbmFsIF07XG5cdH1cblxuXHRyZXR1cm4gW107XG59XG5cbi8qKlxuICogVGFrZXMgdHJhbnNsYXRlIG9wdGlvbnMgb2JqZWN0IGFuZCBjb2VyY2VzIHRvIGEgSmVkIHJlcXVlc3QgdG8gcmV0cmlldmUgdHJhbnNsYXRpb25cbiAqIEBwYXJhbSAge29iamVjdH0gamVkICAgICAtIGplZCBkYXRhIG9iamVjdFxuICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIC0gb2JqZWN0IGRlc2NyaWJpbmcgdHJhbnNsYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAtIHRoZSByZXR1cm5lZCB0cmFuc2xhdGlvbiBmcm9tIEplZFxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGlvbkZyb21KZWQoIGplZCwgb3B0aW9ucyApIHtcblx0dmFyIGplZE1ldGhvZCA9ICdnZXR0ZXh0Jyxcblx0XHRqZWRBcmdzO1xuXG5cdGlmICggb3B0aW9ucy5jb250ZXh0ICkge1xuXHRcdGplZE1ldGhvZCA9ICdwJyArIGplZE1ldGhvZDtcblx0fVxuXG5cdGlmICggdHlwZW9mIG9wdGlvbnMub3JpZ2luYWwgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBvcHRpb25zLnBsdXJhbCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0amVkTWV0aG9kID0gJ24nICsgamVkTWV0aG9kO1xuXHR9XG5cblx0amVkQXJncyA9IGdldEplZEFyZ3MoIGplZE1ldGhvZCwgb3B0aW9ucyApO1xuXG5cdHJldHVybiBqZWRbIGplZE1ldGhvZCBdLmFwcGx5KCBqZWQsIGplZEFyZ3MgKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24oIGkxOG4sIG9wdGlvbnMgKSB7XG5cdHZhciBpLCBsb29rdXA7XG5cblx0Zm9yICggaSA9IHRyYW5zbGF0aW9uTG9va3VwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuXHRcdGxvb2t1cCA9IHRyYW5zbGF0aW9uTG9va3VwWyBpIF0oIGFzc2lnbigge30sIG9wdGlvbnMgKSApO1xuXHRcdC8vIE9ubHkgZ2V0IHRoZSB0cmFuc2xhdGlvbiBmcm9tIGplZCBpZiBpdCBleGlzdHMuXG5cdFx0aWYgKCBpMThuLnN0YXRlLmxvY2FsZVsgbG9va3VwLm9yaWdpbmFsIF0gKSB7XG5cdFx0XHRyZXR1cm4gZ2V0VHJhbnNsYXRpb25Gcm9tSmVkKCBpMThuLnN0YXRlLmplZCwgbG9va3VwICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG51bGw7XG59XG5cblxuZnVuY3Rpb24gSTE4TigpIHtcblx0aWYoICEgKCB0aGlzIGluc3RhbmNlb2YgSTE4TiApICkge1xuXHRcdHJldHVybiBuZXcgSTE4TigpO1xuXHR9XG5cdHRoaXMuZGVmYXVsdExvY2FsZVNsdWcgPSAnZW4nO1xuXHR0aGlzLnN0YXRlID0ge1xuXHRcdG51bWJlckZvcm1hdFNldHRpbmdzOiB7fSxcblx0XHRqZWQ6IHVuZGVmaW5lZCxcblx0XHRsb2NhbGU6IHVuZGVmaW5lZCxcblx0XHRsb2NhbGVTbHVnOiB1bmRlZmluZWQsXG5cdFx0dHJhbnNsYXRpb25zOiBMUlUoIHsgbWF4OiAxMDAgfSApXG5cdH07XG5cdHRoaXMuY29tcG9uZW50VXBkYXRlSG9va3MgPSBbXTtcblx0dGhpcy50cmFuc2xhdGVIb29rcyA9IFtdO1xuXHR0aGlzLnN0YXRlT2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cdC8vIEJlY2F1c2UgdGhlIGhpZ2hlci1vcmRlciBjb21wb25lbnQgY2FuIHdyYXAgYSB0b24gb2YgUmVhY3QgY29tcG9uZW50cyxcblx0Ly8gd2UgbmVlZCB0byBidW1wIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIHRvIGluZmluaXR5IGFuZCBiZXlvbmRcblx0Ly8gRklYTUU6IHN0aWxsIHZhbGlkP1xuXHR0aGlzLnN0YXRlT2JzZXJ2ZXIuc2V0TWF4TGlzdGVuZXJzKCAwICk7XG5cdC8vIGRlZmF1bHQgY29uZmlndXJhdGlvblxuXHR0aGlzLmNvbmZpZ3VyZSgpO1xufVxuXG5JMThOLnRocm93RXJyb3JzID0gZmFsc2U7XG5cbi8qKlxuICogRm9ybWF0cyBudW1iZXJzIHVzaW5nIGxvY2FsZSBzZXR0aW5ncyBhbmQvb3IgcGFzc2VkIG9wdGlvbnNcbiAqIEBwYXJhbSAge1N0cmluZ3xOdW1iZXJ8SW50fSAgbnVtYmVyIHRvIGZvcm1hdCAocmVxdWlyZWQpXG4gKiBAcGFyYW0gIHtJbnR8b2JqZWN0fSBvcHRpb25zICBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb3Igb3B0aW9ucyBvYmplY3QgKG9wdGlvbmFsKVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgIEZvcm1hdHRlZCBudW1iZXIgYXMgc3RyaW5nXG4gKi9cbkkxOE4ucHJvdG90eXBlLm51bWJlckZvcm1hdCA9IGZ1bmN0aW9uKCBudW1iZXIgKSB7XG5cdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAxIF0gfHwge30sXG5cdFx0ZGVjaW1hbHMgPSAoIHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJyApID8gb3B0aW9ucyA6IG9wdGlvbnMuZGVjaW1hbHMgfHwgMCxcblx0XHRkZWNQb2ludCA9IG9wdGlvbnMuZGVjUG9pbnQgfHwgdGhpcy5zdGF0ZS5udW1iZXJGb3JtYXRTZXR0aW5ncy5kZWNpbWFsX3BvaW50IHx8ICcuJyxcblx0XHR0aG91c2FuZHNTZXAgPSBvcHRpb25zLnRob3VzYW5kc1NlcCB8fCB0aGlzLnN0YXRlLm51bWJlckZvcm1hdFNldHRpbmdzLnRob3VzYW5kc19zZXAgfHwgJywnO1xuXG5cdHJldHVybiBudW1iZXJGb3JtYXRQSFBKUyggbnVtYmVyLCBkZWNpbWFscywgZGVjUG9pbnQsIHRob3VzYW5kc1NlcCApO1xufTtcblxuSTE4Ti5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdGFzc2lnbiggdGhpcywgb3B0aW9ucyB8fCB7fSApO1xuXHR0aGlzLnNldExvY2FsZSgpO1xufTtcblxuSTE4Ti5wcm90b3R5cGUuc2V0TG9jYWxlID0gZnVuY3Rpb24oIGxvY2FsZURhdGEgKSB7XG5cdGlmICggbG9jYWxlRGF0YSAmJiBsb2NhbGVEYXRhWyAnJyBdICYmIGxvY2FsZURhdGFbICcnIF1bICdrZXktaGFzaCcgXSApIHtcblx0XHR2YXIgaGFzaExlbmd0aCwgbWluSGFzaExlbmd0aCwgbWF4SGFzaExlbmd0aCwga2V5SGFzaCA9IGxvY2FsZURhdGFbICcnIF1bICdrZXktaGFzaCcgXTtcblxuXHRcdHZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbiggc3RyaW5nLCBoYXNoTGVuZ3RoICkge1xuXHRcdFx0Y29uc3QgbG9va3VwUHJlZml4ID0gaGFzaExlbmd0aCA9PT0gZmFsc2UgPyAnJyA6IFN0cmluZyggaGFzaExlbmd0aCApO1xuXHRcdFx0aWYgKCB0eXBlb2YgaGFzaENhY2hlWyBsb29rdXBQcmVmaXggKyBzdHJpbmcgXSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdHJldHVybiBoYXNoQ2FjaGVbIGxvb2t1cFByZWZpeCArIHN0cmluZyBdO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGhhc2ggPSBzaGExKCkudXBkYXRlKCBzdHJpbmcgKS5kaWdlc3QoJ2hleCcpO1xuXG5cdFx0XHRpZiAoIGhhc2hMZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiBoYXNoQ2FjaGVbIGxvb2t1cFByZWZpeCArIHN0cmluZyBdID0gaGFzaC5zdWJzdHIoIDAsIGhhc2hMZW5ndGggKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGhhc2hDYWNoZVsgbG9va3VwUHJlZml4ICsgc3RyaW5nIF0gPSBoYXNoO1xuXHRcdH07XG5cblx0XHR2YXIgZ2VuZXJhdGVMb29rdXAgPSBmdW5jdGlvbiggaGFzaExlbmd0aCApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmNvbnRleHQgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5vcmlnaW5hbCA9IHRyYW5zZm9ybSggb3B0aW9ucy5jb250ZXh0ICsgU3RyaW5nLmZyb21DaGFyQ29kZSggNCApICsgb3B0aW9ucy5vcmlnaW5hbCwgaGFzaExlbmd0aCApO1xuXHRcdFx0XHRcdGRlbGV0ZSBvcHRpb25zLmNvbnRleHQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5vcmlnaW5hbCA9IHRyYW5zZm9ybSggb3B0aW9ucy5vcmlnaW5hbCwgaGFzaExlbmd0aCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG9wdGlvbnM7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGlmICgga2V5SGFzaC5zdWJzdHIoIDAsIDQgKSA9PT0gJ3NoYTEnICkge1xuXHRcdFx0aWYgKCBrZXlIYXNoLmxlbmd0aCA9PT0gNCApIHtcblx0XHRcdFx0dHJhbnNsYXRpb25Mb29rdXAucHVzaCggZ2VuZXJhdGVMb29rdXAoIGZhbHNlICkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB2YXJpYWJsZUhhc2hMZW5ndGhQb3MgPSBrZXlIYXNoLnN1YnN0ciggNSApLmluZGV4T2YoICctJyApO1xuXHRcdFx0XHRpZiAoIHZhcmlhYmxlSGFzaExlbmd0aFBvcyA8IDAgKSB7XG5cdFx0XHRcdFx0aGFzaExlbmd0aCA9IE51bWJlcigga2V5SGFzaC5zdWJzdHIoIDUgKSApO1xuXHRcdFx0XHRcdHRyYW5zbGF0aW9uTG9va3VwLnB1c2goIGdlbmVyYXRlTG9va3VwKCBoYXNoTGVuZ3RoICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtaW5IYXNoTGVuZ3RoID0gTnVtYmVyKCBrZXlIYXNoLnN1YnN0ciggNSwgdmFyaWFibGVIYXNoTGVuZ3RoUG9zICkgKTtcblx0XHRcdFx0XHRtYXhIYXNoTGVuZ3RoID0gTnVtYmVyKCBrZXlIYXNoLnN1YnN0ciggNiArIHZhcmlhYmxlSGFzaExlbmd0aFBvcyApICk7XG5cblx0XHRcdFx0XHRmb3IgKCBoYXNoTGVuZ3RoID0gbWluSGFzaExlbmd0aDsgaGFzaExlbmd0aCA8PSBtYXhIYXNoTGVuZ3RoOyBoYXNoTGVuZ3RoKysgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc2xhdGlvbkxvb2t1cC5wdXNoKCBnZW5lcmF0ZUxvb2t1cCggaGFzaExlbmd0aCApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gaWYgbG9jYWxlRGF0YSBpcyBub3QgZ2l2ZW4sIGFzc3VtZXMgZGVmYXVsdCBsb2NhbGUgYW5kIHJlc2V0XG5cdGlmICggISBsb2NhbGVEYXRhIHx8ICEgbG9jYWxlRGF0YVsgJycgXS5sb2NhbGVTbHVnICkge1xuXHRcdHRoaXMuc3RhdGUubG9jYWxlID0geyAnJzogeyBsb2NhbGVTbHVnOiB0aGlzLmRlZmF1bHRMb2NhbGVTbHVnIH0gfTtcblx0fSBlbHNlIGlmICggbG9jYWxlRGF0YVsgJycgXS5sb2NhbGVTbHVnID09PSB0aGlzLnN0YXRlLmxvY2FsZVNsdWcgKSB7XG5cdFx0Ly8gRXhpdCBpZiBzYW1lIGRhdGEgYXMgY3VycmVudCAoY29tcGFyaW5nIHJlZmVyZW5jZXMgb25seSlcblx0XHRpZiAoIGxvY2FsZURhdGEgPT09IHRoaXMuc3RhdGUubG9jYWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIG1lcmdlIG5ldyBkYXRhIGludG8gZXhpc3Rpbmcgb25lXG5cdFx0YXNzaWduKCB0aGlzLnN0YXRlLmxvY2FsZSwgbG9jYWxlRGF0YSApO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuc3RhdGUubG9jYWxlID0gYXNzaWduKCB7fSwgbG9jYWxlRGF0YSApO1xuXHR9XG5cblx0dGhpcy5zdGF0ZS5sb2NhbGVTbHVnID0gdGhpcy5zdGF0ZS5sb2NhbGVbICcnIF0ubG9jYWxlU2x1ZztcblxuXHR0aGlzLnN0YXRlLmplZCA9IG5ldyBKZWQoIHtcblx0XHRsb2NhbGVfZGF0YToge1xuXHRcdFx0bWVzc2FnZXM6IHRoaXMuc3RhdGUubG9jYWxlXG5cdFx0fVxuXHR9ICk7XG5cblxuXHQvLyBVcGRhdGVzIG51bWJlckZvcm1hdCBwcmVmZXJlbmNlcyB3aXRoIHNldHRpbmdzIGZyb20gdHJhbnNsYXRpb25zXG5cdHRoaXMuc3RhdGUubnVtYmVyRm9ybWF0U2V0dGluZ3MuZGVjaW1hbF9wb2ludCA9IGdldFRyYW5zbGF0aW9uRnJvbUplZChcblx0XHR0aGlzLnN0YXRlLmplZCxcblx0XHRub3JtYWxpemVUcmFuc2xhdGVBcmd1bWVudHMoIFsgZGVjaW1hbF9wb2ludF90cmFuc2xhdGlvbl9rZXkgXSApXG5cdCk7XG5cdHRoaXMuc3RhdGUubnVtYmVyRm9ybWF0U2V0dGluZ3MudGhvdXNhbmRzX3NlcCA9IGdldFRyYW5zbGF0aW9uRnJvbUplZChcblx0XHR0aGlzLnN0YXRlLmplZCxcblx0XHRub3JtYWxpemVUcmFuc2xhdGVBcmd1bWVudHMoIFsgdGhvdXNhbmRzX3NlcF90cmFuc2xhdGlvbl9rZXkgXSApXG5cdCk7XG5cblx0Ly8gSWYgdHJhbnNsYXRpb24gaXNuJ3Qgc2V0LCBkZWZpbmUgZGVmYXVsdHMuXG5cdGlmICggdGhpcy5zdGF0ZS5udW1iZXJGb3JtYXRTZXR0aW5ncy5kZWNpbWFsX3BvaW50ID09PSBkZWNpbWFsX3BvaW50X3RyYW5zbGF0aW9uX2tleSApIHtcblx0XHR0aGlzLnN0YXRlLm51bWJlckZvcm1hdFNldHRpbmdzLmRlY2ltYWxfcG9pbnQgPSAnLic7XG5cdH1cblxuXHRpZiAoIHRoaXMuc3RhdGUubnVtYmVyRm9ybWF0U2V0dGluZ3MudGhvdXNhbmRzX3NlcCA9PT0gdGhvdXNhbmRzX3NlcF90cmFuc2xhdGlvbl9rZXkgKSB7XG5cdFx0dGhpcy5zdGF0ZS5udW1iZXJGb3JtYXRTZXR0aW5ncy50aG91c2FuZHNfc2VwID0gJywnO1xuXHR9XG5cblx0dGhpcy5zdGF0ZS50cmFuc2xhdGlvbnMuY2xlYXIoKTtcblx0dGhpcy5zdGF0ZU9ic2VydmVyLmVtaXQoICdjaGFuZ2UnICk7XG59O1xuXG5JMThOLnByb3RvdHlwZS5nZXRMb2NhbGUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc3RhdGUubG9jYWxlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgbG9jYWxlIHNsdWcuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudGx5IGxvYWRlZCBsb2NhbGVcbiAqKi9cbkkxOE4ucHJvdG90eXBlLmdldExvY2FsZVNsdWcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc3RhdGUubG9jYWxlU2x1Zztcbn07XG5cblxuLyoqXG4gKiBBZGRzIG5ldyB0cmFuc2xhdGlvbnMgdG8gdGhlIGxvY2FsZSBkYXRhLCBvdmVyd3JpdGluZyBhbnkgZXhpc3RpbmcgdHJhbnNsYXRpb25zIHdpdGggYSBtYXRjaGluZyBrZXlcbiAqKi9cbkkxOE4ucHJvdG90eXBlLmFkZFRyYW5zbGF0aW9ucyA9IGZ1bmN0aW9uKCBsb2NhbGVEYXRhICkge1xuXHRmb3IgKCB2YXIgcHJvcCBpbiBsb2NhbGVEYXRhICkge1xuXHRcdGlmICggcHJvcCAhPT0gJycgKSB7XG5cdFx0XHR0aGlzLnN0YXRlLmplZC5vcHRpb25zLmxvY2FsZV9kYXRhLm1lc3NhZ2VzW3Byb3BdID0gbG9jYWxlRGF0YVtwcm9wXTtcblx0XHR9XG5cdH1cblxuXHR0aGlzLnN0YXRlLnRyYW5zbGF0aW9ucy5jbGVhcigpO1xuXHR0aGlzLnN0YXRlT2JzZXJ2ZXIuZW1pdCggJ2NoYW5nZScgKTtcbn07XG5cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gb3JpZ2luYWwgaGFzIGEgdHJhbnNsYXRpb24uIFBhcmFtZXRlcnMgYXJlIHRoZSBzYW1lIGFzIGZvciB0cmFuc2xhdGUoKS5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG9yaWdpbmFsICB0aGUgc3RyaW5nIHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtICB7c3RyaW5nfSBwbHVyYWwgICAgdGhlIHBsdXJhbCBzdHJpbmcgdG8gdHJhbnNsYXRlIChpZiBhcHBsaWNhYmxlKSwgb3JpZ2luYWwgdXNlZCBhcyBzaW5ndWxhclxuICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zICAgcHJvcGVydGllcyBkZXNjcmliaW5nIHRyYW5zbGF0aW9uIHJlcXVpcmVtZW50cyBmb3IgZ2l2ZW4gdGV4dFxuICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciBhIHRyYW5zbGF0aW9uIGV4aXN0c1xuICovXG5JMThOLnByb3RvdHlwZS5oYXNUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gISEgZ2V0VHJhbnNsYXRpb24oIHRoaXMsIG5vcm1hbGl6ZVRyYW5zbGF0ZUFyZ3VtZW50cyggYXJndW1lbnRzICkgKTtcbn1cblxuLyoqXG4gKiBFeHBvc2VzIHNpbmdsZSB0cmFuc2xhdGlvbiBtZXRob2QsIHdoaWNoIGlzIGNvbnZlcnRlZCBpbnRvIGl0cyByZXNwZWN0aXZlIEplZCBtZXRob2QuXG4gKiBTZWUgc2libGluZyBSRUFETUVcbiAqIEBwYXJhbSAge3N0cmluZ30gb3JpZ2luYWwgIHRoZSBzdHJpbmcgdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBsdXJhbCAgICB0aGUgcGx1cmFsIHN0cmluZyB0byB0cmFuc2xhdGUgKGlmIGFwcGxpY2FibGUpLCBvcmlnaW5hbCB1c2VkIGFzIHNpbmd1bGFyXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgICBwcm9wZXJ0aWVzIGRlc2NyaWJpbmcgdHJhbnNsYXRpb24gcmVxdWlyZW1lbnRzIGZvciBnaXZlbiB0ZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd8UmVhY3QtY29tcG9uZW50c30gdHJhbnNsYXRlZCB0ZXh0IG9yIGFuIG9iamVjdCBjb250YWluaW5nIFJlYWN0IGNoaWxkcmVuIHRoYXQgY2FuIGJlIGluc2VydGVkIGludG8gYSBwYXJlbnQgY29tcG9uZW50XG4gKi9cbkkxOE4ucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgdHJhbnNsYXRpb24sIHNwcmludGZBcmdzLCBlcnJvck1ldGhvZCwgb3B0aW9uc1N0cmluZywgY2FjaGVhYmxlO1xuXG5cdG9wdGlvbnMgPSBub3JtYWxpemVUcmFuc2xhdGVBcmd1bWVudHMoIGFyZ3VtZW50cyApO1xuXG5cdGNhY2hlYWJsZSA9ICEgb3B0aW9ucy5jb21wb25lbnRzO1xuXHRpZiAoIGNhY2hlYWJsZSApIHtcblx0XHQvLyBTYWZlIEpTT04gc3RyaW5naWZpY2F0aW9uIGhlcmUgdG8gY2F0Y2ggQ2lyY3VsYXIgSlNPTiBlcnJvclxuXHRcdC8vIGNhdXNlZCBieSBwYXNzaW5nIGEgUmVhY3QgY29tcG9uZW50IGludG8gYXJncyB3aGVyZSBvbmx5IHNjYWxhcnMgYXJlIGFsbG93ZWRcblx0XHR0cnkge1xuXHRcdFx0b3B0aW9uc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KCBvcHRpb25zICk7XG5cdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRjYWNoZWFibGUgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnNTdHJpbmcgKSB7XG5cdFx0XHR0cmFuc2xhdGlvbiA9IHRoaXMuc3RhdGUudHJhbnNsYXRpb25zLmdldCggb3B0aW9uc1N0cmluZyApO1xuXHRcdFx0Ly8gUmV0dXJuIHRoZSBjYWNoZWQgdHJhbnNsYXRpb24uXG5cdFx0XHRpZiAoIHRyYW5zbGF0aW9uICkge1xuXHRcdFx0XHRyZXR1cm4gdHJhbnNsYXRpb247XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbiggdGhpcywgb3B0aW9ucyApO1xuXHRpZiAoICEgdHJhbnNsYXRpb24gKSB7XG5cdFx0Ly8gVGhpcyBwdXJwb3NlZnVsbHkgY2FsbHMgamVkIGZvciBhIGNhc2Ugd2hlcmUgdGhlcmUgaXMgbm8gdHJhbnNsYXRpb24sXG5cdFx0Ly8gc28gdGhhdCBqZWQgZ2l2ZXMgdXMgdGhlIGV4cGVjdGVkIG9iamVjdCB3aXRoIEVuZ2xpc2ggdGV4dC5cblx0XHR0cmFuc2xhdGlvbiA9IGdldFRyYW5zbGF0aW9uRnJvbUplZCggdGhpcy5zdGF0ZS5qZWQsIG9wdGlvbnMgKTtcblx0fVxuXG5cdC8vIGhhbmRsZSBhbnkgc3RyaW5nIHN1YnN0aXR1dGlvblxuXHRpZiAoIG9wdGlvbnMuYXJncyApIHtcblx0XHRzcHJpbnRmQXJncyA9ICggQXJyYXkuaXNBcnJheSggb3B0aW9ucy5hcmdzICkgKSA/IG9wdGlvbnMuYXJncy5zbGljZSggMCApIDogWyBvcHRpb25zLmFyZ3MgXTtcblx0XHRzcHJpbnRmQXJncy51bnNoaWZ0KCB0cmFuc2xhdGlvbiApO1xuXHRcdHRyeSB7XG5cdFx0XHR0cmFuc2xhdGlvbiA9IEplZC5zcHJpbnRmLmFwcGx5KCBKZWQsIHNwcmludGZBcmdzICk7XG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXHRcdFx0aWYgKCAhIHdpbmRvdyB8fCAhIHdpbmRvdy5jb25zb2xlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRlcnJvck1ldGhvZCA9IHRoaXMudGhyb3dFcnJvcnMgPyAnZXJyb3InIDogJ3dhcm4nO1xuXHRcdFx0aWYgKCB0eXBlb2YgZXJyb3IgIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHR3aW5kb3cuY29uc29sZVsgZXJyb3JNZXRob2QgXSggZXJyb3IgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvdy5jb25zb2xlWyBlcnJvck1ldGhvZCBdKCAnaTE4biBzcHJpbnRmIGVycm9yOicsIHNwcmludGZBcmdzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gaW50ZXJwb2xhdGUgYW55IGNvbXBvbmVudHNcblx0aWYgKCBvcHRpb25zLmNvbXBvbmVudHMgKSB7XG5cdFx0dHJhbnNsYXRpb24gPSBpbnRlcnBvbGF0ZUNvbXBvbmVudHMoIHtcblx0XHRcdG1peGVkU3RyaW5nOiB0cmFuc2xhdGlvbixcblx0XHRcdGNvbXBvbmVudHM6IG9wdGlvbnMuY29tcG9uZW50cyxcblx0XHRcdHRocm93RXJyb3JzOiB0aGlzLnRocm93RXJyb3JzXG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gcnVuIGFueSBuZWNlc3NhcnkgaG9va3Ncblx0dGhpcy50cmFuc2xhdGVIb29rcy5mb3JFYWNoKCBmdW5jdGlvbiggaG9vayApIHtcblx0XHR0cmFuc2xhdGlvbiA9IGhvb2soIHRyYW5zbGF0aW9uLCBvcHRpb25zICk7XG5cdH0gKTtcblxuXHRpZiAoIGNhY2hlYWJsZSApIHtcblx0XHR0aGlzLnN0YXRlLnRyYW5zbGF0aW9ucy5zZXQoIG9wdGlvbnNTdHJpbmcsIHRyYW5zbGF0aW9uICk7XG5cdH1cblxuXHRyZXR1cm4gdHJhbnNsYXRpb247XG59O1xuXG4vKipcbiAqIENhdXNlcyBpMThuIHRvIHJlLXJlbmRlciBhbGwgdHJhbnNsYXRpb25zLlxuICpcbiAqIFRoaXMgY2FuIGJlIG5lY2Vzc2FyeSBpZiBhbiBleHRlbnNpb24gbWFrZXMgY2hhbmdlcyB0aGF0IGkxOG4gaXMgdW5hd2FyZSBvZlxuICogYW5kIG5lZWRzIHRob3NlIGNoYW5nZXMgbWFuaWZlc3RlZCBpbW1lZGlhdGVseSAoZS5nLiBhZGRpbmcgYW4gaW1wb3J0YW50XG4gKiB0cmFuc2xhdGlvbiBob29rLCBvciBtb2RpZnlpbmcgdGhlIGJlaGF2aW91ciBvZiBhbiBleGlzdGluZyBob29rKS5cbiAqXG4gKiBJZiBhdCBhbGwgcG9zc2libGUsIHJlYWN0IGNvbXBvbmVudHMgc2hvdWxkIHRyeSB0byB1c2UgdGhlIG1vcmUgbG9jYWxcbiAqIHVwZGF0ZVRyYW5zbGF0aW9uKCkgZnVuY3Rpb24gaW5oZXJpdGVkIGZyb20gdGhlIG1peGluLlxuICovXG5JMThOLnByb3RvdHlwZS5yZVJlbmRlclRyYW5zbGF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXHRkZWJ1ZyggJ1JlLXJlbmRlcmluZyBhbGwgdHJhbnNsYXRpb25zIGR1ZSB0byBleHRlcm5hbCByZXF1ZXN0JyApO1xuXHR0aGlzLnN0YXRlLnRyYW5zbGF0aW9ucy5jbGVhcigpO1xuXHR0aGlzLnN0YXRlT2JzZXJ2ZXIuZW1pdCggJ2NoYW5nZScgKTtcbn07XG5cbkkxOE4ucHJvdG90eXBlLnJlZ2lzdGVyQ29tcG9uZW50VXBkYXRlSG9vayA9IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0dGhpcy5jb21wb25lbnRVcGRhdGVIb29rcy5wdXNoKCBjYWxsYmFjayApO1xufTtcblxuSTE4Ti5wcm90b3R5cGUucmVnaXN0ZXJUcmFuc2xhdGVIb29rID0gZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHR0aGlzLnRyYW5zbGF0ZUhvb2tzLnB1c2goIGNhbGxiYWNrICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEkxOE47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pMThuLXdwLXBsdWdpbi9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUiLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICcjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJyxcbiAgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLFxuICAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsXG4gICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJyxcbiAgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLFxuICAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsXG4gICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JyxcbiAgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLFxuICAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsXG4gICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJyxcbiAgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaTE4bi13cC1wbHVnaW4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICovXG5leHBvcnRzLmluc3RhbmNlcyA9IFtdO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICB2YXIgcHJldlRpbWU7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIGV4cG9ydHMuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIHZhciBpbmRleCA9IGV4cG9ydHMuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBpO1xuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBleHBvcnRzLmluc3RhbmNlc1tpXTtcbiAgICBpbnN0YW5jZS5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaTE4bi13cC1wbHVnaW4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiLyoqXG4gKiBAcHJlc2VydmUgamVkLmpzIHYwLjUuMGJldGEgaHR0cHM6Ly9naXRodWIuY29tL1NsZXhBeHRvbi9KZWRcbiAqL1xuLypcbi0tLS0tLS0tLS0tXG5BIGdldHRleHQgY29tcGF0aWJsZSBpMThuIGxpYnJhcnkgZm9yIG1vZGVybiBKYXZhU2NyaXB0IEFwcGxpY2F0aW9uc1xuXG5ieSBBbGV4IFNleHRvbiAtIEFsZXhTZXh0b24gW2F0XSBnbWFpbCAtIEBTbGV4QXh0b25cbldURlBMIGxpY2Vuc2UgZm9yIHVzZVxuRG9qbyBDTEEgZm9yIGNvbnRyaWJ1dGlvbnNcblxuSmVkIG9mZmVycyB0aGUgZW50aXJlIGFwcGxpY2FibGUgR05VIGdldHRleHQgc3BlYydkIHNldCBvZlxuZnVuY3Rpb25zLCBidXQgYWxzbyBvZmZlcnMgc29tZSBuaWNlciB3cmFwcGVycyBhcm91bmQgdGhlbS5cblRoZSBhcGkgZm9yIGdldHRleHQgd2FzIHdyaXR0ZW4gZm9yIGEgbGFuZ3VhZ2Ugd2l0aCBubyBmdW5jdGlvblxub3ZlcmxvYWRpbmcsIHNvIEplZCBhbGxvd3MgYSBsaXR0bGUgbW9yZSBvZiB0aGF0LlxuXG5NYW55IHRoYW5rcyB0byBKb3NodWEgSS4gTWlsbGVyIC0gdW5ydHN0QGNwYW4ub3JnIC0gd2hvIHdyb3RlXG5nZXR0ZXh0LmpzIGJhY2sgaW4gMjAwOC4gSSB3YXMgYWJsZSB0byB2ZXQgYSBsb3Qgb2YgbXkgaWRlYXNcbmFnYWluc3QgaGlzLiBJIGFsc28gbWFkZSBzdXJlIEplZCBwYXNzZWQgYWdhaW5zdCBoaXMgdGVzdHNcbmluIG9yZGVyIHRvIG9mZmVyIGVhc3kgdXBncmFkZXMgLS0ganNnZXR0ZXh0LmJlcmxpb3MuZGVcbiovXG4oZnVuY3Rpb24gKHJvb3QsIHVuZGVmKSB7XG5cbiAgLy8gU2V0IHVwIHNvbWUgdW5kZXJzY29yZS1zdHlsZSBmdW5jdGlvbnMsIGlmIHlvdSBhbHJlYWR5IGhhdmVcbiAgLy8gdW5kZXJzY29yZSwgZmVlbCBmcmVlIHRvIGRlbGV0ZSB0aGlzIHNlY3Rpb24sIGFuZCB1c2UgaXRcbiAgLy8gZGlyZWN0bHksIGhvd2V2ZXIsIHRoZSBhbW91bnQgb2YgZnVuY3Rpb25zIHVzZWQgZG9lc24ndFxuICAvLyB3YXJyYW50IGhhdmluZyB1bmRlcnNjb3JlIGFzIGEgZnVsbCBkZXBlbmRlbmN5LlxuICAvLyBVbmRlcnNjb3JlIDEuMy4wIHdhcyB1c2VkIHRvIHBvcnQgYW5kIGlzIGxpY2Vuc2VkXG4gIC8vIHVuZGVyIHRoZSBNSVQgTGljZW5zZSBieSBKZXJlbXkgQXNoa2VuYXMuXG4gIHZhciBBcnJheVByb3RvICAgID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgT2JqUHJvdG8gICAgICA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICBzbGljZSAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICAgIGhhc093blByb3AgICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIG5hdGl2ZUZvckVhY2ggPSBBcnJheVByb3RvLmZvckVhY2gsXG4gICAgICBicmVha2VyICAgICAgID0ge307XG5cbiAgLy8gV2UncmUgbm90IHVzaW5nIHRoZSBPT1Agc3R5bGUgXyBzbyB3ZSBkb24ndCBuZWVkIHRoZVxuICAvLyBleHRyYSBsZXZlbCBvZiBpbmRpcmVjdGlvbi4gVGhpcyBzdGlsbCBtZWFucyB0aGF0IHlvdVxuICAvLyBzdWIgb3V0IGZvciByZWFsIGBfYCB0aG91Z2guXG4gIHZhciBfID0ge1xuICAgIGZvckVhY2ggOiBmdW5jdGlvbiggb2JqLCBpdGVyYXRvciwgY29udGV4dCApIHtcbiAgICAgIHZhciBpLCBsLCBrZXk7XG4gICAgICBpZiAoIG9iaiA9PT0gbnVsbCApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIG5hdGl2ZUZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IG5hdGl2ZUZvckVhY2ggKSB7XG4gICAgICAgIG9iai5mb3JFYWNoKCBpdGVyYXRvciwgY29udGV4dCApO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoICkge1xuICAgICAgICBmb3IgKCBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgaWYgKCBpIGluIG9iaiAmJiBpdGVyYXRvci5jYWxsKCBjb250ZXh0LCBvYmpbaV0sIGksIG9iaiApID09PSBicmVha2VyICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAoIGtleSBpbiBvYmopIHtcbiAgICAgICAgICBpZiAoIGhhc093blByb3AuY2FsbCggb2JqLCBrZXkgKSApIHtcbiAgICAgICAgICAgIGlmICggaXRlcmF0b3IuY2FsbCAoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqICkgPT09IGJyZWFrZXIgKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGV4dGVuZCA6IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICB0aGlzLmZvckVhY2goIHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApLCBmdW5jdGlvbiAoIHNvdXJjZSApIHtcbiAgICAgICAgZm9yICggdmFyIHByb3AgaW4gc291cmNlICkge1xuICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfTtcbiAgLy8gRU5EIE1pbmlhdHVyZSB1bmRlcnNjb3JlIGltcGxcblxuICAvLyBKZWQgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICB2YXIgSmVkID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xuICAgIC8vIFNvbWUgbWluaW1hbCBkZWZhdWx0c1xuICAgIHRoaXMuZGVmYXVsdHMgPSB7XG4gICAgICBcImxvY2FsZV9kYXRhXCIgOiB7XG4gICAgICAgIFwibWVzc2FnZXNcIiA6IHtcbiAgICAgICAgICBcIlwiIDoge1xuICAgICAgICAgICAgXCJkb21haW5cIiAgICAgICA6IFwibWVzc2FnZXNcIixcbiAgICAgICAgICAgIFwibGFuZ1wiICAgICAgICAgOiBcImVuXCIsXG4gICAgICAgICAgICBcInBsdXJhbF9mb3Jtc1wiIDogXCJucGx1cmFscz0yOyBwbHVyYWw9KG4gIT0gMSk7XCJcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVGhlcmUgYXJlIG5vIGRlZmF1bHQga2V5cywgdGhvdWdoXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBUaGUgZGVmYXVsdCBkb21haW4gaWYgb25lIGlzIG1pc3NpbmdcbiAgICAgIFwiZG9tYWluXCIgOiBcIm1lc3NhZ2VzXCIsXG4gICAgICAvLyBlbmFibGUgZGVidWcgbW9kZSB0byBsb2cgdW50cmFuc2xhdGVkIHN0cmluZ3MgdG8gdGhlIGNvbnNvbGVcbiAgICAgIFwiZGVidWdcIiA6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIE1peCBpbiB0aGUgc2VudCBvcHRpb25zIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKCB7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyApO1xuICAgIHRoaXMudGV4dGRvbWFpbiggdGhpcy5vcHRpb25zLmRvbWFpbiApO1xuXG4gICAgaWYgKCBvcHRpb25zLmRvbWFpbiAmJiAhIHRoaXMub3B0aW9ucy5sb2NhbGVfZGF0YVsgdGhpcy5vcHRpb25zLmRvbWFpbiBdICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0IGRvbWFpbiBzZXQgdG8gbm9uLWV4aXN0ZW50IGRvbWFpbjogYCcgKyBvcHRpb25zLmRvbWFpbiArICdgJyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoZSBnZXR0ZXh0IHNwZWMgc2V0cyB0aGlzIGNoYXJhY3RlciBhcyB0aGUgZGVmYXVsdFxuICAvLyBkZWxpbWl0ZXIgZm9yIGNvbnRleHQgbG9va3Vwcy5cbiAgLy8gZS5nLjogY29udGV4dFxcdTAwMDRrZXlcbiAgLy8gSWYgeW91ciB0cmFuc2xhdGlvbiBjb21wYW55IHVzZXMgc29tZXRoaW5nIGRpZmZlcmVudCxcbiAgLy8ganVzdCBjaGFuZ2UgdGhpcyBhdCBhbnkgdGltZSBhbmQgaXQgd2lsbCB1c2UgdGhhdCBpbnN0ZWFkLlxuICBKZWQuY29udGV4dF9kZWxpbWl0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCA0ICk7XG5cbiAgZnVuY3Rpb24gZ2V0UGx1cmFsRm9ybUZ1bmMgKCBwbHVyYWxfZm9ybV9zdHJpbmcgKSB7XG4gICAgcmV0dXJuIEplZC5QRi5jb21waWxlKCBwbHVyYWxfZm9ybV9zdHJpbmcgfHwgXCJucGx1cmFscz0yOyBwbHVyYWw9KG4gIT0gMSk7XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gQ2hhaW4oIGtleSwgaTE4biApe1xuICAgIHRoaXMuX2tleSA9IGtleTtcbiAgICB0aGlzLl9pMThuID0gaTE4bjtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIGNoYWluYWJsZSBhcGkgZm9yIGFkZGluZyBhcmdzIHByZXR0aWx5XG4gIF8uZXh0ZW5kKCBDaGFpbi5wcm90b3R5cGUsIHtcbiAgICBvbkRvbWFpbiA6IGZ1bmN0aW9uICggZG9tYWluICkge1xuICAgICAgdGhpcy5fZG9tYWluID0gZG9tYWluO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB3aXRoQ29udGV4dCA6IGZ1bmN0aW9uICggY29udGV4dCApIHtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBpZlBsdXJhbCA6IGZ1bmN0aW9uICggbnVtLCBwa2V5ICkge1xuICAgICAgdGhpcy5fdmFsID0gbnVtO1xuICAgICAgdGhpcy5fcGtleSA9IHBrZXk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZldGNoIDogZnVuY3Rpb24gKCBzQXJyICkge1xuICAgICAgaWYgKCB7fS50b1N0cmluZy5jYWxsKCBzQXJyICkgIT0gJ1tvYmplY3QgQXJyYXldJyApIHtcbiAgICAgICAgc0FyciA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoIHNBcnIgJiYgc0Fyci5sZW5ndGggPyBKZWQuc3ByaW50ZiA6IGZ1bmN0aW9uKHgpeyByZXR1cm4geDsgfSApKFxuICAgICAgICB0aGlzLl9pMThuLmRjbnBnZXR0ZXh0KHRoaXMuX2RvbWFpbiwgdGhpcy5fY29udGV4dCwgdGhpcy5fa2V5LCB0aGlzLl9wa2V5LCB0aGlzLl92YWwpLFxuICAgICAgICBzQXJyXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQWRkIGZ1bmN0aW9ucyB0byB0aGUgSmVkIHByb3RvdHlwZS5cbiAgLy8gVGhlc2Ugd2lsbCBiZSB0aGUgZnVuY3Rpb25zIG9uIHRoZSBvYmplY3QgdGhhdCdzIHJldHVybmVkXG4gIC8vIGZyb20gY3JlYXRpbmcgYSBgbmV3IEplZCgpYFxuICAvLyBUaGVzZSBzZWVtIHJlZHVuZGFudCwgYnV0IHRoZXkgZ3ppcCBwcmV0dHkgd2VsbC5cbiAgXy5leHRlbmQoIEplZC5wcm90b3R5cGUsIHtcbiAgICAvLyBUaGUgc2V4aWVyIGFwaSBzdGFydCBwb2ludFxuICAgIHRyYW5zbGF0ZSA6IGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgcmV0dXJuIG5ldyBDaGFpbigga2V5LCB0aGlzICk7XG4gICAgfSxcblxuICAgIHRleHRkb21haW4gOiBmdW5jdGlvbiAoIGRvbWFpbiApIHtcbiAgICAgIGlmICggISBkb21haW4gKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0ZG9tYWluO1xuICAgICAgfVxuICAgICAgdGhpcy5fdGV4dGRvbWFpbiA9IGRvbWFpbjtcbiAgICB9LFxuXG4gICAgZ2V0dGV4dCA6IGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgcmV0dXJuIHRoaXMuZGNucGdldHRleHQuY2FsbCggdGhpcywgdW5kZWYsIHVuZGVmLCBrZXkgKTtcbiAgICB9LFxuXG4gICAgZGdldHRleHQgOiBmdW5jdGlvbiAoIGRvbWFpbiwga2V5ICkge1xuICAgICByZXR1cm4gdGhpcy5kY25wZ2V0dGV4dC5jYWxsKCB0aGlzLCBkb21haW4sIHVuZGVmLCBrZXkgKTtcbiAgICB9LFxuXG4gICAgZGNnZXR0ZXh0IDogZnVuY3Rpb24gKCBkb21haW4gLCBrZXkgLyosIGNhdGVnb3J5ICovICkge1xuICAgICAgLy8gSWdub3JlcyB0aGUgY2F0ZWdvcnkgYW55d2F5c1xuICAgICAgcmV0dXJuIHRoaXMuZGNucGdldHRleHQuY2FsbCggdGhpcywgZG9tYWluLCB1bmRlZiwga2V5ICk7XG4gICAgfSxcblxuICAgIG5nZXR0ZXh0IDogZnVuY3Rpb24gKCBza2V5LCBwa2V5LCB2YWwgKSB7XG4gICAgICByZXR1cm4gdGhpcy5kY25wZ2V0dGV4dC5jYWxsKCB0aGlzLCB1bmRlZiwgdW5kZWYsIHNrZXksIHBrZXksIHZhbCApO1xuICAgIH0sXG5cbiAgICBkbmdldHRleHQgOiBmdW5jdGlvbiAoIGRvbWFpbiwgc2tleSwgcGtleSwgdmFsICkge1xuICAgICAgcmV0dXJuIHRoaXMuZGNucGdldHRleHQuY2FsbCggdGhpcywgZG9tYWluLCB1bmRlZiwgc2tleSwgcGtleSwgdmFsICk7XG4gICAgfSxcblxuICAgIGRjbmdldHRleHQgOiBmdW5jdGlvbiAoIGRvbWFpbiwgc2tleSwgcGtleSwgdmFsLyosIGNhdGVnb3J5ICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5kY25wZ2V0dGV4dC5jYWxsKCB0aGlzLCBkb21haW4sIHVuZGVmLCBza2V5LCBwa2V5LCB2YWwgKTtcbiAgICB9LFxuXG4gICAgcGdldHRleHQgOiBmdW5jdGlvbiAoIGNvbnRleHQsIGtleSApIHtcbiAgICAgIHJldHVybiB0aGlzLmRjbnBnZXR0ZXh0LmNhbGwoIHRoaXMsIHVuZGVmLCBjb250ZXh0LCBrZXkgKTtcbiAgICB9LFxuXG4gICAgZHBnZXR0ZXh0IDogZnVuY3Rpb24gKCBkb21haW4sIGNvbnRleHQsIGtleSApIHtcbiAgICAgIHJldHVybiB0aGlzLmRjbnBnZXR0ZXh0LmNhbGwoIHRoaXMsIGRvbWFpbiwgY29udGV4dCwga2V5ICk7XG4gICAgfSxcblxuICAgIGRjcGdldHRleHQgOiBmdW5jdGlvbiAoIGRvbWFpbiwgY29udGV4dCwga2V5LyosIGNhdGVnb3J5ICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5kY25wZ2V0dGV4dC5jYWxsKCB0aGlzLCBkb21haW4sIGNvbnRleHQsIGtleSApO1xuICAgIH0sXG5cbiAgICBucGdldHRleHQgOiBmdW5jdGlvbiAoIGNvbnRleHQsIHNrZXksIHBrZXksIHZhbCApIHtcbiAgICAgIHJldHVybiB0aGlzLmRjbnBnZXR0ZXh0LmNhbGwoIHRoaXMsIHVuZGVmLCBjb250ZXh0LCBza2V5LCBwa2V5LCB2YWwgKTtcbiAgICB9LFxuXG4gICAgZG5wZ2V0dGV4dCA6IGZ1bmN0aW9uICggZG9tYWluLCBjb250ZXh0LCBza2V5LCBwa2V5LCB2YWwgKSB7XG4gICAgICByZXR1cm4gdGhpcy5kY25wZ2V0dGV4dC5jYWxsKCB0aGlzLCBkb21haW4sIGNvbnRleHQsIHNrZXksIHBrZXksIHZhbCApO1xuICAgIH0sXG5cbiAgICAvLyBUaGUgbW9zdCBmdWxseSBxdWFsaWZpZWQgZ2V0dGV4dCBmdW5jdGlvbi4gSXQgaGFzIGV2ZXJ5IG9wdGlvbi5cbiAgICAvLyBTaW5jZSBpdCBoYXMgZXZlcnkgb3B0aW9uLCB3ZSBjYW4gdXNlIGl0IGZyb20gZXZlcnkgb3RoZXIgbWV0aG9kLlxuICAgIC8vIFRoaXMgaXMgdGhlIGJyZWFkIGFuZCBidXR0ZXIuXG4gICAgLy8gVGVjaG5pY2FsbHkgdGhlcmUgc2hvdWxkIGJlIG9uZSBtb3JlIGFyZ3VtZW50IGluIHRoaXMgZnVuY3Rpb24gZm9yICdDYXRlZ29yeScsXG4gICAgLy8gYnV0IHNpbmNlIHdlIG5ldmVyIHVzZSBpdCwgd2UgbWlnaHQgYXMgd2VsbCBub3Qgd2FzdGUgdGhlIGJ5dGVzIHRvIGRlZmluZSBpdC5cbiAgICBkY25wZ2V0dGV4dCA6IGZ1bmN0aW9uICggZG9tYWluLCBjb250ZXh0LCBzaW5ndWxhcl9rZXksIHBsdXJhbF9rZXksIHZhbCApIHtcbiAgICAgIC8vIFNldCBzb21lIGRlZmF1bHRzXG5cbiAgICAgIHBsdXJhbF9rZXkgPSBwbHVyYWxfa2V5IHx8IHNpbmd1bGFyX2tleTtcblxuICAgICAgLy8gVXNlIHRoZSBnbG9iYWwgZG9tYWluIGRlZmF1bHQgaWYgb25lXG4gICAgICAvLyBpc24ndCBleHBsaWNpdGx5IHBhc3NlZCBpblxuICAgICAgZG9tYWluID0gZG9tYWluIHx8IHRoaXMuX3RleHRkb21haW47XG5cbiAgICAgIHZhciBmYWxsYmFjaztcblxuICAgICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZXNcblxuICAgICAgLy8gTm8gb3B0aW9ucyBmb3VuZFxuICAgICAgaWYgKCAhIHRoaXMub3B0aW9ucyApIHtcbiAgICAgICAgLy8gVGhlcmUncyBsaWtlbHkgc29tZXRoaW5nIHdyb25nLCBidXQgd2UnbGwgcmV0dXJuIHRoZSBjb3JyZWN0IGtleSBmb3IgZW5nbGlzaFxuICAgICAgICAvLyBXZSBkbyB0aGlzIGJ5IGluc3RhbnRpYXRpbmcgYSBicmFuZCBuZXcgSmVkIGluc3RhbmNlIHdpdGggdGhlIGRlZmF1bHQgc2V0XG4gICAgICAgIC8vIGZvciBldmVyeXRoaW5nIHRoYXQgY291bGQgYmUgYnJva2VuLlxuICAgICAgICBmYWxsYmFjayA9IG5ldyBKZWQoKTtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrLmRjbnBnZXR0ZXh0LmNhbGwoIGZhbGxiYWNrLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgc2luZ3VsYXJfa2V5LCBwbHVyYWxfa2V5LCB2YWwgKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm8gdHJhbnNsYXRpb24gZGF0YSBwcm92aWRlZFxuICAgICAgaWYgKCAhIHRoaXMub3B0aW9ucy5sb2NhbGVfZGF0YSApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBsb2NhbGUgZGF0YSBwcm92aWRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCAhIHRoaXMub3B0aW9ucy5sb2NhbGVfZGF0YVsgZG9tYWluIF0gKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRG9tYWluIGAnICsgZG9tYWluICsgJ2Agd2FzIG5vdCBmb3VuZC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCAhIHRoaXMub3B0aW9ucy5sb2NhbGVfZGF0YVsgZG9tYWluIF1bIFwiXCIgXSApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBsb2NhbGUgbWV0YSBpbmZvcm1hdGlvbiBwcm92aWRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSB0cnV0aHkga2V5LiBPdGhlcndpc2Ugd2UgbWlnaHQgc3RhcnQgbG9va2luZ1xuICAgICAgLy8gaW50byB0aGUgZW1wdHkgc3RyaW5nIGtleSwgd2hpY2ggaXMgdGhlIG9wdGlvbnMgZm9yIHRoZSBsb2NhbGVcbiAgICAgIC8vIGRhdGEuXG4gICAgICBpZiAoICEgc2luZ3VsYXJfa2V5ICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRyYW5zbGF0aW9uIGtleSBmb3VuZC4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleSAgPSBjb250ZXh0ID8gY29udGV4dCArIEplZC5jb250ZXh0X2RlbGltaXRlciArIHNpbmd1bGFyX2tleSA6IHNpbmd1bGFyX2tleSxcbiAgICAgICAgICBsb2NhbGVfZGF0YSA9IHRoaXMub3B0aW9ucy5sb2NhbGVfZGF0YSxcbiAgICAgICAgICBkaWN0ID0gbG9jYWxlX2RhdGFbIGRvbWFpbiBdLFxuICAgICAgICAgIGRlZmF1bHRDb25mID0gKGxvY2FsZV9kYXRhLm1lc3NhZ2VzIHx8IHRoaXMuZGVmYXVsdHMubG9jYWxlX2RhdGEubWVzc2FnZXMpW1wiXCJdLFxuICAgICAgICAgIHBsdXJhbEZvcm1zID0gZGljdFtcIlwiXS5wbHVyYWxfZm9ybXMgfHwgZGljdFtcIlwiXVtcIlBsdXJhbC1Gb3Jtc1wiXSB8fCBkaWN0W1wiXCJdW1wicGx1cmFsLWZvcm1zXCJdIHx8IGRlZmF1bHRDb25mLnBsdXJhbF9mb3JtcyB8fCBkZWZhdWx0Q29uZltcIlBsdXJhbC1Gb3Jtc1wiXSB8fCBkZWZhdWx0Q29uZltcInBsdXJhbC1mb3Jtc1wiXSxcbiAgICAgICAgICB2YWxfbGlzdCxcbiAgICAgICAgICByZXM7XG5cbiAgICAgIHZhciB2YWxfaWR4O1xuICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE5vIHZhbHVlIHBhc3NlZCBpbjsgYXNzdW1lIHNpbmd1bGFyIGtleSBsb29rdXAuXG4gICAgICAgIHZhbF9pZHggPSAxO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBWYWx1ZSBoYXMgYmVlbiBwYXNzZWQgaW47IHVzZSBwbHVyYWwtZm9ybXMgY2FsY3VsYXRpb25zLlxuXG4gICAgICAgIC8vIEhhbmRsZSBpbnZhbGlkIG51bWJlcnMsIGJ1dCB0cnkgY2FzdGluZyBzdHJpbmdzIGZvciBnb29kIG1lYXN1cmVcbiAgICAgICAgaWYgKCB0eXBlb2YgdmFsICE9ICdudW1iZXInICkge1xuICAgICAgICAgIHZhbCA9IHBhcnNlSW50KCB2YWwsIDEwICk7XG5cbiAgICAgICAgICBpZiAoIGlzTmFOKCB2YWwgKSApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIG51bWJlciB0aGF0IHdhcyBwYXNzZWQgaW4gaXMgbm90IGEgbnVtYmVyLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhbF9pZHggPSBnZXRQbHVyYWxGb3JtRnVuYyhwbHVyYWxGb3JtcykodmFsKSArIDE7XG4gICAgICB9XG5cbiAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIGEgZG9tYWluIGlzbid0IGZvdW5kXG4gICAgICBpZiAoICEgZGljdCApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkb21haW4gbmFtZWQgYCcgKyBkb21haW4gKyAnYCBjb3VsZCBiZSBmb3VuZC4nKTtcbiAgICAgIH1cblxuICAgICAgdmFsX2xpc3QgPSBkaWN0WyBrZXkgXTtcblxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbWF0Y2gsIHRoZW4gcmV2ZXJ0IGJhY2sgdG9cbiAgICAgIC8vIGVuZ2xpc2ggc3R5bGUgc2luZ3VsYXIvcGx1cmFsIHdpdGggdGhlIGtleXMgcGFzc2VkIGluLlxuICAgICAgaWYgKCAhIHZhbF9saXN0IHx8IHZhbF9pZHggPj0gdmFsX2xpc3QubGVuZ3RoICkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1pc3Npbmdfa2V5X2NhbGxiYWNrKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm1pc3Npbmdfa2V5X2NhbGxiYWNrKGtleSwgZG9tYWluKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBbIG51bGwsIHNpbmd1bGFyX2tleSwgcGx1cmFsX2tleSBdO1xuXG4gICAgICAgIC8vIGNvbGxlY3QgdW50cmFuc2xhdGVkIHN0cmluZ3NcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zz09PXRydWUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhyZXNbIGdldFBsdXJhbEZvcm1GdW5jKHBsdXJhbEZvcm1zKSggdmFsICkgKyAxIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNbIGdldFBsdXJhbEZvcm1GdW5jKCkoIHZhbCApICsgMSBdO1xuICAgICAgfVxuXG4gICAgICByZXMgPSB2YWxfbGlzdFsgdmFsX2lkeCBdO1xuXG4gICAgICAvLyBUaGlzIGluY2x1ZGVzIGVtcHR5IHN0cmluZ3Mgb24gcHVycG9zZVxuICAgICAgaWYgKCAhIHJlcyAgKSB7XG4gICAgICAgIHJlcyA9IFsgbnVsbCwgc2luZ3VsYXJfa2V5LCBwbHVyYWxfa2V5IF07XG4gICAgICAgIHJldHVybiByZXNbIGdldFBsdXJhbEZvcm1GdW5jKCkoIHZhbCApICsgMSBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH0pO1xuXG5cbiAgLy8gV2UgYWRkIGluIHNwcmludGYgY2FwYWJpbGl0aWVzIGZvciBwb3N0IHRyYW5zbGF0aW9uIHZhbHVlIGludGVyb2xhdGlvblxuICAvLyBUaGlzIGlzIG5vdCBpbnRlcm5hbGx5IHVzZWQsIHNvIHlvdSBjYW4gcmVtb3ZlIGl0IGlmIHlvdSBoYXZlIHRoaXNcbiAgLy8gYXZhaWxhYmxlIHNvbWV3aGVyZSBlbHNlLCBvciB3YW50IHRvIHVzZSBhIGRpZmZlcmVudCBzeXN0ZW0uXG5cbiAgLy8gV2UgX3NsaWdodGx5XyBtb2RpZnkgdGhlIG5vcm1hbCBzcHJpbnRmIGJlaGF2aW9yIHRvIG1vcmUgZ3JhY2VmdWxseSBoYW5kbGVcbiAgLy8gdW5kZWZpbmVkIHZhbHVlcy5cblxuICAvKipcbiAgIHNwcmludGYoKSBmb3IgSmF2YVNjcmlwdCAwLjctYmV0YTFcbiAgIGh0dHA6Ly93d3cuZGl2ZWludG9qYXZhc2NyaXB0LmNvbS9wcm9qZWN0cy9qYXZhc2NyaXB0LXNwcmludGZcblxuICAgQ29weXJpZ2h0IChjKSBBbGV4YW5kcnUgTWFyYXN0ZWFudSA8YWxleGFob2xpYyBbYXQpIGdtYWlsIChkb3RdIGNvbT5cbiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gICAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHNwcmludGYoKSBmb3IgSmF2YVNjcmlwdCBub3IgdGhlXG4gICAgICAgICBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuICAgICAgICAgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuICAgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAgIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEFsZXhhbmRydSBNYXJhc3RlYW51IEJFIExJQUJMRSBGT1IgQU5ZXG4gICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAgIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAqL1xuICB2YXIgc3ByaW50ZiA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBnZXRfdHlwZSh2YXJpYWJsZSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YXJpYWJsZSkuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cl9yZXBlYXQoaW5wdXQsIG11bHRpcGxpZXIpIHtcbiAgICAgIGZvciAodmFyIG91dHB1dCA9IFtdOyBtdWx0aXBsaWVyID4gMDsgb3V0cHV0Wy0tbXVsdGlwbGllcl0gPSBpbnB1dCkgey8qIGRvIG5vdGhpbmcgKi99XG4gICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuICAgIH1cblxuICAgIHZhciBzdHJfZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXN0cl9mb3JtYXQuY2FjaGUuaGFzT3duUHJvcGVydHkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICBzdHJfZm9ybWF0LmNhY2hlW2FyZ3VtZW50c1swXV0gPSBzdHJfZm9ybWF0LnBhcnNlKGFyZ3VtZW50c1swXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyX2Zvcm1hdC5mb3JtYXQuY2FsbChudWxsLCBzdHJfZm9ybWF0LmNhY2hlW2FyZ3VtZW50c1swXV0sIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHN0cl9mb3JtYXQuZm9ybWF0ID0gZnVuY3Rpb24ocGFyc2VfdHJlZSwgYXJndikge1xuICAgICAgdmFyIGN1cnNvciA9IDEsIHRyZWVfbGVuZ3RoID0gcGFyc2VfdHJlZS5sZW5ndGgsIG5vZGVfdHlwZSA9ICcnLCBhcmcsIG91dHB1dCA9IFtdLCBpLCBrLCBtYXRjaCwgcGFkLCBwYWRfY2hhcmFjdGVyLCBwYWRfbGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRyZWVfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZV90eXBlID0gZ2V0X3R5cGUocGFyc2VfdHJlZVtpXSk7XG4gICAgICAgIGlmIChub2RlX3R5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2gocGFyc2VfdHJlZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZV90eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgbWF0Y2ggPSBwYXJzZV90cmVlW2ldOyAvLyBjb252ZW5pZW5jZSBwdXJwb3NlcyBvbmx5XG4gICAgICAgICAgaWYgKG1hdGNoWzJdKSB7IC8vIGtleXdvcmQgYXJndW1lbnRcbiAgICAgICAgICAgIGFyZyA9IGFyZ3ZbY3Vyc29yXTtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBtYXRjaFsyXS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICBpZiAoIWFyZy5oYXNPd25Qcm9wZXJ0eShtYXRjaFsyXVtrXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyhzcHJpbnRmKCdbc3ByaW50Zl0gcHJvcGVydHkgXCIlc1wiIGRvZXMgbm90IGV4aXN0JywgbWF0Y2hbMl1ba10pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhcmcgPSBhcmdbbWF0Y2hbMl1ba11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChtYXRjaFsxXSkgeyAvLyBwb3NpdGlvbmFsIGFyZ3VtZW50IChleHBsaWNpdClcbiAgICAgICAgICAgIGFyZyA9IGFyZ3ZbbWF0Y2hbMV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHsgLy8gcG9zaXRpb25hbCBhcmd1bWVudCAoaW1wbGljaXQpXG4gICAgICAgICAgICBhcmcgPSBhcmd2W2N1cnNvcisrXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoL1tec10vLnRlc3QobWF0Y2hbOF0pICYmIChnZXRfdHlwZShhcmcpICE9ICdudW1iZXInKSkge1xuICAgICAgICAgICAgdGhyb3coc3ByaW50ZignW3NwcmludGZdIGV4cGVjdGluZyBudW1iZXIgYnV0IGZvdW5kICVzJywgZ2V0X3R5cGUoYXJnKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEplZCBFRElUXG4gICAgICAgICAgaWYgKCB0eXBlb2YgYXJnID09ICd1bmRlZmluZWQnIHx8IGFyZyA9PT0gbnVsbCApIHtcbiAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBKZWQgRURJVFxuXG4gICAgICAgICAgc3dpdGNoIChtYXRjaFs4XSkge1xuICAgICAgICAgICAgY2FzZSAnYic6IGFyZyA9IGFyZy50b1N0cmluZygyKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjJzogYXJnID0gU3RyaW5nLmZyb21DaGFyQ29kZShhcmcpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2QnOiBhcmcgPSBwYXJzZUludChhcmcsIDEwKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlJzogYXJnID0gbWF0Y2hbN10gPyBhcmcudG9FeHBvbmVudGlhbChtYXRjaFs3XSkgOiBhcmcudG9FeHBvbmVudGlhbCgpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2YnOiBhcmcgPSBtYXRjaFs3XSA/IHBhcnNlRmxvYXQoYXJnKS50b0ZpeGVkKG1hdGNoWzddKSA6IHBhcnNlRmxvYXQoYXJnKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvJzogYXJnID0gYXJnLnRvU3RyaW5nKDgpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3MnOiBhcmcgPSAoKGFyZyA9IFN0cmluZyhhcmcpKSAmJiBtYXRjaFs3XSA/IGFyZy5zdWJzdHJpbmcoMCwgbWF0Y2hbN10pIDogYXJnKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1JzogYXJnID0gTWF0aC5hYnMoYXJnKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd4JzogYXJnID0gYXJnLnRvU3RyaW5nKDE2KTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdYJzogYXJnID0gYXJnLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJnID0gKC9bZGVmXS8udGVzdChtYXRjaFs4XSkgJiYgbWF0Y2hbM10gJiYgYXJnID49IDAgPyAnKycrIGFyZyA6IGFyZyk7XG4gICAgICAgICAgcGFkX2NoYXJhY3RlciA9IG1hdGNoWzRdID8gbWF0Y2hbNF0gPT0gJzAnID8gJzAnIDogbWF0Y2hbNF0uY2hhckF0KDEpIDogJyAnO1xuICAgICAgICAgIHBhZF9sZW5ndGggPSBtYXRjaFs2XSAtIFN0cmluZyhhcmcpLmxlbmd0aDtcbiAgICAgICAgICBwYWQgPSBtYXRjaFs2XSA/IHN0cl9yZXBlYXQocGFkX2NoYXJhY3RlciwgcGFkX2xlbmd0aCkgOiAnJztcbiAgICAgICAgICBvdXRwdXQucHVzaChtYXRjaFs1XSA/IGFyZyArIHBhZCA6IHBhZCArIGFyZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gICAgfTtcblxuICAgIHN0cl9mb3JtYXQuY2FjaGUgPSB7fTtcblxuICAgIHN0cl9mb3JtYXQucGFyc2UgPSBmdW5jdGlvbihmbXQpIHtcbiAgICAgIHZhciBfZm10ID0gZm10LCBtYXRjaCA9IFtdLCBwYXJzZV90cmVlID0gW10sIGFyZ19uYW1lcyA9IDA7XG4gICAgICB3aGlsZSAoX2ZtdCkge1xuICAgICAgICBpZiAoKG1hdGNoID0gL15bXlxceDI1XSsvLmV4ZWMoX2ZtdCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgcGFyc2VfdHJlZS5wdXNoKG1hdGNoWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobWF0Y2ggPSAvXlxceDI1ezJ9Ly5leGVjKF9mbXQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIHBhcnNlX3RyZWUucHVzaCgnJScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtYXRjaCA9IC9eXFx4MjUoPzooWzEtOV1cXGQqKVxcJHxcXCgoW15cXCldKylcXCkpPyhcXCspPygwfCdbXiRdKT8oLSk/KFxcZCspPyg/OlxcLihcXGQrKSk/KFtiLWZvc3V4WF0pLy5leGVjKF9mbXQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAgICAgYXJnX25hbWVzIHw9IDE7XG4gICAgICAgICAgICB2YXIgZmllbGRfbGlzdCA9IFtdLCByZXBsYWNlbWVudF9maWVsZCA9IG1hdGNoWzJdLCBmaWVsZF9tYXRjaCA9IFtdO1xuICAgICAgICAgICAgaWYgKChmaWVsZF9tYXRjaCA9IC9eKFthLXpfXVthLXpfXFxkXSopL2kuZXhlYyhyZXBsYWNlbWVudF9maWVsZCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGZpZWxkX2xpc3QucHVzaChmaWVsZF9tYXRjaFsxXSk7XG4gICAgICAgICAgICAgIHdoaWxlICgocmVwbGFjZW1lbnRfZmllbGQgPSByZXBsYWNlbWVudF9maWVsZC5zdWJzdHJpbmcoZmllbGRfbWF0Y2hbMF0ubGVuZ3RoKSkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKChmaWVsZF9tYXRjaCA9IC9eXFwuKFthLXpfXVthLXpfXFxkXSopL2kuZXhlYyhyZXBsYWNlbWVudF9maWVsZCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBmaWVsZF9saXN0LnB1c2goZmllbGRfbWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoZmllbGRfbWF0Y2ggPSAvXlxcWyhcXGQrKVxcXS8uZXhlYyhyZXBsYWNlbWVudF9maWVsZCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBmaWVsZF9saXN0LnB1c2goZmllbGRfbWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRocm93KCdbc3ByaW50Zl0gaHVoPycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93KCdbc3ByaW50Zl0gaHVoPycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0Y2hbMl0gPSBmaWVsZF9saXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFyZ19uYW1lcyB8PSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXJnX25hbWVzID09PSAzKSB7XG4gICAgICAgICAgICB0aHJvdygnW3NwcmludGZdIG1peGluZyBwb3NpdGlvbmFsIGFuZCBuYW1lZCBwbGFjZWhvbGRlcnMgaXMgbm90ICh5ZXQpIHN1cHBvcnRlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJzZV90cmVlLnB1c2gobWF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRocm93KCdbc3ByaW50Zl0gaHVoPycpO1xuICAgICAgICB9XG4gICAgICAgIF9mbXQgPSBfZm10LnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlX3RyZWU7XG4gICAgfTtcblxuICAgIHJldHVybiBzdHJfZm9ybWF0O1xuICB9KSgpO1xuXG4gIHZhciB2c3ByaW50ZiA9IGZ1bmN0aW9uKGZtdCwgYXJndikge1xuICAgIGFyZ3YudW5zaGlmdChmbXQpO1xuICAgIHJldHVybiBzcHJpbnRmLmFwcGx5KG51bGwsIGFyZ3YpO1xuICB9O1xuXG4gIEplZC5wYXJzZV9wbHVyYWwgPSBmdW5jdGlvbiAoIHBsdXJhbF9mb3JtcywgbiApIHtcbiAgICBwbHVyYWxfZm9ybXMgPSBwbHVyYWxfZm9ybXMucmVwbGFjZSgvbi9nLCBuKTtcbiAgICByZXR1cm4gSmVkLnBhcnNlX2V4cHJlc3Npb24ocGx1cmFsX2Zvcm1zKTtcbiAgfTtcblxuICBKZWQuc3ByaW50ZiA9IGZ1bmN0aW9uICggZm10LCBhcmdzICkge1xuICAgIGlmICgge30udG9TdHJpbmcuY2FsbCggYXJncyApID09ICdbb2JqZWN0IEFycmF5XScgKSB7XG4gICAgICByZXR1cm4gdnNwcmludGYoIGZtdCwgW10uc2xpY2UuY2FsbChhcmdzKSApO1xuICAgIH1cbiAgICByZXR1cm4gc3ByaW50Zi5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykgKTtcbiAgfTtcblxuICBKZWQucHJvdG90eXBlLnNwcmludGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEplZC5zcHJpbnRmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIC8vIEVORCBzcHJpbnRmIEltcGxlbWVudGF0aW9uXG5cbiAgLy8gU3RhcnQgdGhlIFBsdXJhbCBmb3JtcyBzZWN0aW9uXG4gIC8vIFRoaXMgaXMgYSBmdWxsIHBsdXJhbCBmb3JtIGV4cHJlc3Npb24gcGFyc2VyLiBJdCBpcyB1c2VkIHRvIGF2b2lkXG4gIC8vIHJ1bm5pbmcgJ2V2YWwnIG9yICduZXcgRnVuY3Rpb24nIGRpcmVjdGx5IGFnYWluc3QgdGhlIHBsdXJhbFxuICAvLyBmb3Jtcy5cbiAgLy9cbiAgLy8gVGhpcyBjYW4gYmUgaW1wb3J0YW50IGlmIHlvdSBnZXQgdHJhbnNsYXRpb25zIGRvbmUgdGhyb3VnaCBhIDNyZFxuICAvLyBwYXJ0eSB2ZW5kb3IuIEkgZW5jb3VyYWdlIHlvdSB0byB1c2UgdGhpcyBpbnN0ZWFkLCBob3dldmVyLCBJXG4gIC8vIGFsc28gd2lsbCBwcm92aWRlIGEgJ3ByZWNvbXBpbGVyJyB0aGF0IHlvdSBjYW4gdXNlIGF0IGJ1aWxkIHRpbWVcbiAgLy8gdG8gb3V0cHV0IHZhbGlkL3NhZmUgZnVuY3Rpb24gcmVwcmVzZW50YXRpb25zIG9mIHRoZSBwbHVyYWwgZm9ybVxuICAvLyBleHByZXNzaW9ucy4gVGhpcyBtZWFucyB5b3UgY2FuIGJ1aWxkIHRoaXMgY29kZSBvdXQgZm9yIHRoZSBtb3N0XG4gIC8vIHBhcnQuXG4gIEplZC5QRiA9IHt9O1xuXG4gIEplZC5QRi5wYXJzZSA9IGZ1bmN0aW9uICggcCApIHtcbiAgICB2YXIgcGx1cmFsX3N0ciA9IEplZC5QRi5leHRyYWN0UGx1cmFsRXhwciggcCApO1xuICAgIHJldHVybiBKZWQuUEYucGFyc2VyLnBhcnNlLmNhbGwoSmVkLlBGLnBhcnNlciwgcGx1cmFsX3N0cik7XG4gIH07XG5cbiAgSmVkLlBGLmNvbXBpbGUgPSBmdW5jdGlvbiAoIHAgKSB7XG4gICAgLy8gSGFuZGxlIHRydWVzIGFuZCBmYWxzZXMgYXMgMCBhbmQgMVxuICAgIGZ1bmN0aW9uIGltcGx5KCB2YWwgKSB7XG4gICAgICByZXR1cm4gKHZhbCA9PT0gdHJ1ZSA/IDEgOiB2YWwgPyB2YWwgOiAwKTtcbiAgICB9XG5cbiAgICB2YXIgYXN0ID0gSmVkLlBGLnBhcnNlKCBwICk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICggbiApIHtcbiAgICAgIHJldHVybiBpbXBseSggSmVkLlBGLmludGVycHJldGVyKCBhc3QgKSggbiApICk7XG4gICAgfTtcbiAgfTtcblxuICBKZWQuUEYuaW50ZXJwcmV0ZXIgPSBmdW5jdGlvbiAoIGFzdCApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCBuICkge1xuICAgICAgdmFyIHJlcztcbiAgICAgIHN3aXRjaCAoIGFzdC50eXBlICkge1xuICAgICAgICBjYXNlICdHUk9VUCc6XG4gICAgICAgICAgcmV0dXJuIEplZC5QRi5pbnRlcnByZXRlciggYXN0LmV4cHIgKSggbiApO1xuICAgICAgICBjYXNlICdURVJOQVJZJzpcbiAgICAgICAgICBpZiAoIEplZC5QRi5pbnRlcnByZXRlciggYXN0LmV4cHIgKSggbiApICkge1xuICAgICAgICAgICAgcmV0dXJuIEplZC5QRi5pbnRlcnByZXRlciggYXN0LnRydXRoeSApKCBuICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKZWQuUEYuaW50ZXJwcmV0ZXIoIGFzdC5mYWxzZXkgKSggbiApO1xuICAgICAgICBjYXNlICdPUic6XG4gICAgICAgICAgcmV0dXJuIEplZC5QRi5pbnRlcnByZXRlciggYXN0LmxlZnQgKSggbiApIHx8IEplZC5QRi5pbnRlcnByZXRlciggYXN0LnJpZ2h0ICkoIG4gKTtcbiAgICAgICAgY2FzZSAnQU5EJzpcbiAgICAgICAgICByZXR1cm4gSmVkLlBGLmludGVycHJldGVyKCBhc3QubGVmdCApKCBuICkgJiYgSmVkLlBGLmludGVycHJldGVyKCBhc3QucmlnaHQgKSggbiApO1xuICAgICAgICBjYXNlICdMVCc6XG4gICAgICAgICAgcmV0dXJuIEplZC5QRi5pbnRlcnByZXRlciggYXN0LmxlZnQgKSggbiApIDwgSmVkLlBGLmludGVycHJldGVyKCBhc3QucmlnaHQgKSggbiApO1xuICAgICAgICBjYXNlICdHVCc6XG4gICAgICAgICAgcmV0dXJuIEplZC5QRi5pbnRlcnByZXRlciggYXN0LmxlZnQgKSggbiApID4gSmVkLlBGLmludGVycHJldGVyKCBhc3QucmlnaHQgKSggbiApO1xuICAgICAgICBjYXNlICdMVEUnOlxuICAgICAgICAgIHJldHVybiBKZWQuUEYuaW50ZXJwcmV0ZXIoIGFzdC5sZWZ0ICkoIG4gKSA8PSBKZWQuUEYuaW50ZXJwcmV0ZXIoIGFzdC5yaWdodCApKCBuICk7XG4gICAgICAgIGNhc2UgJ0dURSc6XG4gICAgICAgICAgcmV0dXJuIEplZC5QRi5pbnRlcnByZXRlciggYXN0LmxlZnQgKSggbiApID49IEplZC5QRi5pbnRlcnByZXRlciggYXN0LnJpZ2h0ICkoIG4gKTtcbiAgICAgICAgY2FzZSAnRVEnOlxuICAgICAgICAgIHJldHVybiBKZWQuUEYuaW50ZXJwcmV0ZXIoIGFzdC5sZWZ0ICkoIG4gKSA9PSBKZWQuUEYuaW50ZXJwcmV0ZXIoIGFzdC5yaWdodCApKCBuICk7XG4gICAgICAgIGNhc2UgJ05FUSc6XG4gICAgICAgICAgcmV0dXJuIEplZC5QRi5pbnRlcnByZXRlciggYXN0LmxlZnQgKSggbiApICE9IEplZC5QRi5pbnRlcnByZXRlciggYXN0LnJpZ2h0ICkoIG4gKTtcbiAgICAgICAgY2FzZSAnTU9EJzpcbiAgICAgICAgICByZXR1cm4gSmVkLlBGLmludGVycHJldGVyKCBhc3QubGVmdCApKCBuICkgJSBKZWQuUEYuaW50ZXJwcmV0ZXIoIGFzdC5yaWdodCApKCBuICk7XG4gICAgICAgIGNhc2UgJ1ZBUic6XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIGNhc2UgJ05VTSc6XG4gICAgICAgICAgcmV0dXJuIGFzdC52YWw7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBUb2tlbiBmb3VuZC5cIik7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBKZWQuUEYuZXh0cmFjdFBsdXJhbEV4cHIgPSBmdW5jdGlvbiAoIHAgKSB7XG4gICAgLy8gdHJpbSBmaXJzdFxuICAgIHAgPSBwLnJlcGxhY2UoL15cXHNcXHMqLywgJycpLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xuXG4gICAgaWYgKCEgLztcXHMqJC8udGVzdChwKSkge1xuICAgICAgcCA9IHAuY29uY2F0KCc7Jyk7XG4gICAgfVxuXG4gICAgdmFyIG5wbHVyYWxzX3JlID0gL25wbHVyYWxzXFw9KFxcZCspOy8sXG4gICAgICAgIHBsdXJhbF9yZSA9IC9wbHVyYWxcXD0oLiopOy8sXG4gICAgICAgIG5wbHVyYWxzX21hdGNoZXMgPSBwLm1hdGNoKCBucGx1cmFsc19yZSApLFxuICAgICAgICByZXMgPSB7fSxcbiAgICAgICAgcGx1cmFsX21hdGNoZXM7XG5cbiAgICAvLyBGaW5kIHRoZSBucGx1cmFscyBudW1iZXJcbiAgICBpZiAoIG5wbHVyYWxzX21hdGNoZXMubGVuZ3RoID4gMSApIHtcbiAgICAgIHJlcy5ucGx1cmFscyA9IG5wbHVyYWxzX21hdGNoZXNbMV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCducGx1cmFscyBub3QgZm91bmQgaW4gcGx1cmFsX2Zvcm1zIHN0cmluZzogJyArIHAgKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdGhhdCBkYXRhIHRvIGdldCB0byB0aGUgZm9ybXVsYVxuICAgIHAgPSBwLnJlcGxhY2UoIG5wbHVyYWxzX3JlLCBcIlwiICk7XG4gICAgcGx1cmFsX21hdGNoZXMgPSBwLm1hdGNoKCBwbHVyYWxfcmUgKTtcblxuICAgIGlmICghKCBwbHVyYWxfbWF0Y2hlcyAmJiBwbHVyYWxfbWF0Y2hlcy5sZW5ndGggPiAxICkgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BwbHVyYWxgIGV4cHJlc3Npb24gbm90IGZvdW5kOiAnICsgcCk7XG4gICAgfVxuICAgIHJldHVybiBwbHVyYWxfbWF0Y2hlc1sgMSBdO1xuICB9O1xuXG4gIC8qIEppc29uIGdlbmVyYXRlZCBwYXJzZXIgKi9cbiAgSmVkLlBGLnBhcnNlciA9IChmdW5jdGlvbigpe1xuXG52YXIgcGFyc2VyID0ge3RyYWNlOiBmdW5jdGlvbiB0cmFjZSgpIHsgfSxcbnl5OiB7fSxcbnN5bWJvbHNfOiB7XCJlcnJvclwiOjIsXCJleHByZXNzaW9uc1wiOjMsXCJlXCI6NCxcIkVPRlwiOjUsXCI/XCI6NixcIjpcIjo3LFwifHxcIjo4LFwiJiZcIjo5LFwiPFwiOjEwLFwiPD1cIjoxMSxcIj5cIjoxMixcIj49XCI6MTMsXCIhPVwiOjE0LFwiPT1cIjoxNSxcIiVcIjoxNixcIihcIjoxNyxcIilcIjoxOCxcIm5cIjoxOSxcIk5VTUJFUlwiOjIwLFwiJGFjY2VwdFwiOjAsXCIkZW5kXCI6MX0sXG50ZXJtaW5hbHNfOiB7MjpcImVycm9yXCIsNTpcIkVPRlwiLDY6XCI/XCIsNzpcIjpcIiw4OlwifHxcIiw5OlwiJiZcIiwxMDpcIjxcIiwxMTpcIjw9XCIsMTI6XCI+XCIsMTM6XCI+PVwiLDE0OlwiIT1cIiwxNTpcIj09XCIsMTY6XCIlXCIsMTc6XCIoXCIsMTg6XCIpXCIsMTk6XCJuXCIsMjA6XCJOVU1CRVJcIn0sXG5wcm9kdWN0aW9uc186IFswLFszLDJdLFs0LDVdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDFdLFs0LDFdXSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eXRleHQseXlsZW5nLHl5bGluZW5vLHl5LHl5c3RhdGUsJCQsXyQpIHtcblxudmFyICQwID0gJCQubGVuZ3RoIC0gMTtcbnN3aXRjaCAoeXlzdGF0ZSkge1xuY2FzZSAxOiByZXR1cm4geyB0eXBlIDogJ0dST1VQJywgZXhwcjogJCRbJDAtMV0gfTtcbmJyZWFrO1xuY2FzZSAyOnRoaXMuJCA9IHsgdHlwZTogJ1RFUk5BUlknLCBleHByOiAkJFskMC00XSwgdHJ1dGh5IDogJCRbJDAtMl0sIGZhbHNleTogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgMzp0aGlzLiQgPSB7IHR5cGU6IFwiT1JcIiwgbGVmdDogJCRbJDAtMl0sIHJpZ2h0OiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSA0OnRoaXMuJCA9IHsgdHlwZTogXCJBTkRcIiwgbGVmdDogJCRbJDAtMl0sIHJpZ2h0OiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSA1OnRoaXMuJCA9IHsgdHlwZTogJ0xUJywgbGVmdDogJCRbJDAtMl0sIHJpZ2h0OiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSA2OnRoaXMuJCA9IHsgdHlwZTogJ0xURScsIGxlZnQ6ICQkWyQwLTJdLCByaWdodDogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgNzp0aGlzLiQgPSB7IHR5cGU6ICdHVCcsIGxlZnQ6ICQkWyQwLTJdLCByaWdodDogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgODp0aGlzLiQgPSB7IHR5cGU6ICdHVEUnLCBsZWZ0OiAkJFskMC0yXSwgcmlnaHQ6ICQkWyQwXSB9O1xuYnJlYWs7XG5jYXNlIDk6dGhpcy4kID0geyB0eXBlOiAnTkVRJywgbGVmdDogJCRbJDAtMl0sIHJpZ2h0OiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSAxMDp0aGlzLiQgPSB7IHR5cGU6ICdFUScsIGxlZnQ6ICQkWyQwLTJdLCByaWdodDogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgMTE6dGhpcy4kID0geyB0eXBlOiAnTU9EJywgbGVmdDogJCRbJDAtMl0sIHJpZ2h0OiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSAxMjp0aGlzLiQgPSB7IHR5cGU6ICdHUk9VUCcsIGV4cHI6ICQkWyQwLTFdIH07XG5icmVhaztcbmNhc2UgMTM6dGhpcy4kID0geyB0eXBlOiAnVkFSJyB9O1xuYnJlYWs7XG5jYXNlIDE0OnRoaXMuJCA9IHsgdHlwZTogJ05VTScsIHZhbDogTnVtYmVyKHl5dGV4dCkgfTtcbmJyZWFrO1xufVxufSxcbnRhYmxlOiBbezM6MSw0OjIsMTc6WzEsM10sMTk6WzEsNF0sMjA6WzEsNV19LHsxOlszXX0sezU6WzEsNl0sNjpbMSw3XSw4OlsxLDhdLDk6WzEsOV0sMTA6WzEsMTBdLDExOlsxLDExXSwxMjpbMSwxMl0sMTM6WzEsMTNdLDE0OlsxLDE0XSwxNTpbMSwxNV0sMTY6WzEsMTZdfSx7NDoxNywxNzpbMSwzXSwxOTpbMSw0XSwyMDpbMSw1XX0sezU6WzIsMTNdLDY6WzIsMTNdLDc6WzIsMTNdLDg6WzIsMTNdLDk6WzIsMTNdLDEwOlsyLDEzXSwxMTpbMiwxM10sMTI6WzIsMTNdLDEzOlsyLDEzXSwxNDpbMiwxM10sMTU6WzIsMTNdLDE2OlsyLDEzXSwxODpbMiwxM119LHs1OlsyLDE0XSw2OlsyLDE0XSw3OlsyLDE0XSw4OlsyLDE0XSw5OlsyLDE0XSwxMDpbMiwxNF0sMTE6WzIsMTRdLDEyOlsyLDE0XSwxMzpbMiwxNF0sMTQ6WzIsMTRdLDE1OlsyLDE0XSwxNjpbMiwxNF0sMTg6WzIsMTRdfSx7MTpbMiwxXX0sezQ6MTgsMTc6WzEsM10sMTk6WzEsNF0sMjA6WzEsNV19LHs0OjE5LDE3OlsxLDNdLDE5OlsxLDRdLDIwOlsxLDVdfSx7NDoyMCwxNzpbMSwzXSwxOTpbMSw0XSwyMDpbMSw1XX0sezQ6MjEsMTc6WzEsM10sMTk6WzEsNF0sMjA6WzEsNV19LHs0OjIyLDE3OlsxLDNdLDE5OlsxLDRdLDIwOlsxLDVdfSx7NDoyMywxNzpbMSwzXSwxOTpbMSw0XSwyMDpbMSw1XX0sezQ6MjQsMTc6WzEsM10sMTk6WzEsNF0sMjA6WzEsNV19LHs0OjI1LDE3OlsxLDNdLDE5OlsxLDRdLDIwOlsxLDVdfSx7NDoyNiwxNzpbMSwzXSwxOTpbMSw0XSwyMDpbMSw1XX0sezQ6MjcsMTc6WzEsM10sMTk6WzEsNF0sMjA6WzEsNV19LHs2OlsxLDddLDg6WzEsOF0sOTpbMSw5XSwxMDpbMSwxMF0sMTE6WzEsMTFdLDEyOlsxLDEyXSwxMzpbMSwxM10sMTQ6WzEsMTRdLDE1OlsxLDE1XSwxNjpbMSwxNl0sMTg6WzEsMjhdfSx7NjpbMSw3XSw3OlsxLDI5XSw4OlsxLDhdLDk6WzEsOV0sMTA6WzEsMTBdLDExOlsxLDExXSwxMjpbMSwxMl0sMTM6WzEsMTNdLDE0OlsxLDE0XSwxNTpbMSwxNV0sMTY6WzEsMTZdfSx7NTpbMiwzXSw2OlsyLDNdLDc6WzIsM10sODpbMiwzXSw5OlsxLDldLDEwOlsxLDEwXSwxMTpbMSwxMV0sMTI6WzEsMTJdLDEzOlsxLDEzXSwxNDpbMSwxNF0sMTU6WzEsMTVdLDE2OlsxLDE2XSwxODpbMiwzXX0sezU6WzIsNF0sNjpbMiw0XSw3OlsyLDRdLDg6WzIsNF0sOTpbMiw0XSwxMDpbMSwxMF0sMTE6WzEsMTFdLDEyOlsxLDEyXSwxMzpbMSwxM10sMTQ6WzEsMTRdLDE1OlsxLDE1XSwxNjpbMSwxNl0sMTg6WzIsNF19LHs1OlsyLDVdLDY6WzIsNV0sNzpbMiw1XSw4OlsyLDVdLDk6WzIsNV0sMTA6WzIsNV0sMTE6WzIsNV0sMTI6WzIsNV0sMTM6WzIsNV0sMTQ6WzIsNV0sMTU6WzIsNV0sMTY6WzEsMTZdLDE4OlsyLDVdfSx7NTpbMiw2XSw2OlsyLDZdLDc6WzIsNl0sODpbMiw2XSw5OlsyLDZdLDEwOlsyLDZdLDExOlsyLDZdLDEyOlsyLDZdLDEzOlsyLDZdLDE0OlsyLDZdLDE1OlsyLDZdLDE2OlsxLDE2XSwxODpbMiw2XX0sezU6WzIsN10sNjpbMiw3XSw3OlsyLDddLDg6WzIsN10sOTpbMiw3XSwxMDpbMiw3XSwxMTpbMiw3XSwxMjpbMiw3XSwxMzpbMiw3XSwxNDpbMiw3XSwxNTpbMiw3XSwxNjpbMSwxNl0sMTg6WzIsN119LHs1OlsyLDhdLDY6WzIsOF0sNzpbMiw4XSw4OlsyLDhdLDk6WzIsOF0sMTA6WzIsOF0sMTE6WzIsOF0sMTI6WzIsOF0sMTM6WzIsOF0sMTQ6WzIsOF0sMTU6WzIsOF0sMTY6WzEsMTZdLDE4OlsyLDhdfSx7NTpbMiw5XSw2OlsyLDldLDc6WzIsOV0sODpbMiw5XSw5OlsyLDldLDEwOlsyLDldLDExOlsyLDldLDEyOlsyLDldLDEzOlsyLDldLDE0OlsyLDldLDE1OlsyLDldLDE2OlsxLDE2XSwxODpbMiw5XX0sezU6WzIsMTBdLDY6WzIsMTBdLDc6WzIsMTBdLDg6WzIsMTBdLDk6WzIsMTBdLDEwOlsyLDEwXSwxMTpbMiwxMF0sMTI6WzIsMTBdLDEzOlsyLDEwXSwxNDpbMiwxMF0sMTU6WzIsMTBdLDE2OlsxLDE2XSwxODpbMiwxMF19LHs1OlsyLDExXSw2OlsyLDExXSw3OlsyLDExXSw4OlsyLDExXSw5OlsyLDExXSwxMDpbMiwxMV0sMTE6WzIsMTFdLDEyOlsyLDExXSwxMzpbMiwxMV0sMTQ6WzIsMTFdLDE1OlsyLDExXSwxNjpbMiwxMV0sMTg6WzIsMTFdfSx7NTpbMiwxMl0sNjpbMiwxMl0sNzpbMiwxMl0sODpbMiwxMl0sOTpbMiwxMl0sMTA6WzIsMTJdLDExOlsyLDEyXSwxMjpbMiwxMl0sMTM6WzIsMTJdLDE0OlsyLDEyXSwxNTpbMiwxMl0sMTY6WzIsMTJdLDE4OlsyLDEyXX0sezQ6MzAsMTc6WzEsM10sMTk6WzEsNF0sMjA6WzEsNV19LHs1OlsyLDJdLDY6WzEsN10sNzpbMiwyXSw4OlsxLDhdLDk6WzEsOV0sMTA6WzEsMTBdLDExOlsxLDExXSwxMjpbMSwxMl0sMTM6WzEsMTNdLDE0OlsxLDE0XSwxNTpbMSwxNV0sMTY6WzEsMTZdLDE4OlsyLDJdfV0sXG5kZWZhdWx0QWN0aW9uczogezY6WzIsMV19LFxucGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbn0sXG5wYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHN0YWNrID0gWzBdLFxuICAgICAgICB2c3RhY2sgPSBbbnVsbF0sIC8vIHNlbWFudGljIHZhbHVlIHN0YWNrXG4gICAgICAgIGxzdGFjayA9IFtdLCAvLyBsb2NhdGlvbiBzdGFja1xuICAgICAgICB0YWJsZSA9IHRoaXMudGFibGUsXG4gICAgICAgIHl5dGV4dCA9ICcnLFxuICAgICAgICB5eWxpbmVubyA9IDAsXG4gICAgICAgIHl5bGVuZyA9IDAsXG4gICAgICAgIHJlY292ZXJpbmcgPSAwLFxuICAgICAgICBURVJST1IgPSAyLFxuICAgICAgICBFT0YgPSAxO1xuXG4gICAgLy90aGlzLnJlZHVjdGlvbkNvdW50ID0gdGhpcy5zaGlmdENvdW50ID0gMDtcblxuICAgIHRoaXMubGV4ZXIuc2V0SW5wdXQoaW5wdXQpO1xuICAgIHRoaXMubGV4ZXIueXkgPSB0aGlzLnl5O1xuICAgIHRoaXMueXkubGV4ZXIgPSB0aGlzLmxleGVyO1xuICAgIGlmICh0eXBlb2YgdGhpcy5sZXhlci55eWxsb2MgPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRoaXMubGV4ZXIueXlsbG9jID0ge307XG4gICAgdmFyIHl5bG9jID0gdGhpcy5sZXhlci55eWxsb2M7XG4gICAgbHN0YWNrLnB1c2goeXlsb2MpO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLnl5LnBhcnNlRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHRoaXMueXkucGFyc2VFcnJvcjtcblxuICAgIGZ1bmN0aW9uIHBvcFN0YWNrIChuKSB7XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IHN0YWNrLmxlbmd0aCAtIDIqbjtcbiAgICAgICAgdnN0YWNrLmxlbmd0aCA9IHZzdGFjay5sZW5ndGggLSBuO1xuICAgICAgICBsc3RhY2subGVuZ3RoID0gbHN0YWNrLmxlbmd0aCAtIG47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHRva2VuID0gc2VsZi5sZXhlci5sZXgoKSB8fCAxOyAvLyAkZW5kID0gMVxuICAgICAgICAvLyBpZiB0b2tlbiBpc24ndCBpdHMgbnVtZXJpYyB2YWx1ZSwgY29udmVydFxuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgdmFyIHN5bWJvbCwgcHJlRXJyb3JTeW1ib2wsIHN0YXRlLCBhY3Rpb24sIGEsIHIsIHl5dmFsPXt9LHAsbGVuLG5ld1N0YXRlLCBleHBlY3RlZDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAvLyByZXRyZWl2ZSBzdGF0ZSBudW1iZXIgZnJvbSB0b3Agb2Ygc3RhY2tcbiAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGgtMV07XG5cbiAgICAgICAgLy8gdXNlIGRlZmF1bHQgYWN0aW9ucyBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSB0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzeW1ib2wgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTtcbiAgICAgICAgICAgIC8vIHJlYWQgYWN0aW9uIGZvciBjdXJyZW50IHN0YXRlIGFuZCBmaXJzdCBpbnB1dFxuICAgICAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtzeW1ib2xdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIHBhcnNlIGVycm9yXG4gICAgICAgIF9oYW5kbGVfZXJyb3I6XG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAndW5kZWZpbmVkJyB8fCAhYWN0aW9uLmxlbmd0aCB8fCAhYWN0aW9uWzBdKSB7XG5cbiAgICAgICAgICAgIGlmICghcmVjb3ZlcmluZykge1xuICAgICAgICAgICAgICAgIC8vIFJlcG9ydCBlcnJvclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChwIGluIHRhYmxlW3N0YXRlXSkgaWYgKHRoaXMudGVybWluYWxzX1twXSAmJiBwID4gMikge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZC5wdXNoKFwiJ1wiK3RoaXMudGVybWluYWxzX1twXStcIidcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlcnJTdHIgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZXhlci5zaG93UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJysoeXlsaW5lbm8rMSkrXCI6XFxuXCIrdGhpcy5sZXhlci5zaG93UG9zaXRpb24oKStcIlxcbkV4cGVjdGluZyBcIitleHBlY3RlZC5qb2luKCcsICcpICsgXCIsIGdvdCAnXCIgKyB0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSsgXCInXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJysoeXlsaW5lbm8rMSkrXCI6IFVuZXhwZWN0ZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzeW1ib2wgPT0gMSAvKkVPRiovID8gXCJlbmQgb2YgaW5wdXRcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiJ1wiKyh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpK1wiJ1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VFcnJvcihlcnJTdHIsXG4gICAgICAgICAgICAgICAgICAgIHt0ZXh0OiB0aGlzLmxleGVyLm1hdGNoLCB0b2tlbjogdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sLCBsaW5lOiB0aGlzLmxleGVyLnl5bGluZW5vLCBsb2M6IHl5bG9jLCBleHBlY3RlZDogZXhwZWN0ZWR9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8ganVzdCByZWNvdmVyZWQgZnJvbSBhbm90aGVyIGVycm9yXG4gICAgICAgICAgICBpZiAocmVjb3ZlcmluZyA9PSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbCA9PSBFT0YpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyclN0ciB8fCAnUGFyc2luZyBoYWx0ZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZGlzY2FyZCBjdXJyZW50IGxvb2thaGVhZCBhbmQgZ3JhYiBhbm90aGVyXG4gICAgICAgICAgICAgICAgeXlsZW5nID0gdGhpcy5sZXhlci55eWxlbmc7XG4gICAgICAgICAgICAgICAgeXl0ZXh0ID0gdGhpcy5sZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgeXlsaW5lbm8gPSB0aGlzLmxleGVyLnl5bGluZW5vO1xuICAgICAgICAgICAgICAgIHl5bG9jID0gdGhpcy5sZXhlci55eWxsb2M7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbGV4KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRyeSB0byByZWNvdmVyIGZyb20gZXJyb3JcbiAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGVycm9yIHJlY292ZXJ5IHJ1bGUgaW4gdGhpcyBzdGF0ZVxuICAgICAgICAgICAgICAgIGlmICgoVEVSUk9SLnRvU3RyaW5nKCkpIGluIHRhYmxlW3N0YXRlXSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyclN0ciB8fCAnUGFyc2luZyBoYWx0ZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcFN0YWNrKDEpO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmVFcnJvclN5bWJvbCA9IHN5bWJvbDsgLy8gc2F2ZSB0aGUgbG9va2FoZWFkIHRva2VuXG4gICAgICAgICAgICBzeW1ib2wgPSBURVJST1I7ICAgICAgICAgLy8gaW5zZXJ0IGdlbmVyaWMgZXJyb3Igc3ltYm9sIGFzIG5ldyBsb29rYWhlYWRcbiAgICAgICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdO1xuICAgICAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtURVJST1JdO1xuICAgICAgICAgICAgcmVjb3ZlcmluZyA9IDM7IC8vIGFsbG93IDMgcmVhbCBzeW1ib2xzIHRvIGJlIHNoaWZ0ZWQgYmVmb3JlIHJlcG9ydGluZyBhIG5ldyBlcnJvclxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcyBzaG91bGRuJ3QgaGFwcGVuLCB1bmxlc3MgcmVzb2x2ZSBkZWZhdWx0cyBhcmUgb2ZmXG4gICAgICAgIGlmIChhY3Rpb25bMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBhY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZSBFcnJvcjogbXVsdGlwbGUgYWN0aW9ucyBwb3NzaWJsZSBhdCBzdGF0ZTogJytzdGF0ZSsnLCB0b2tlbjogJytzeW1ib2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChhY3Rpb25bMF0pIHtcblxuICAgICAgICAgICAgY2FzZSAxOiAvLyBzaGlmdFxuICAgICAgICAgICAgICAgIC8vdGhpcy5zaGlmdENvdW50Kys7XG5cbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgdnN0YWNrLnB1c2godGhpcy5sZXhlci55eXRleHQpO1xuICAgICAgICAgICAgICAgIGxzdGFjay5wdXNoKHRoaXMubGV4ZXIueXlsbG9jKTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGFjdGlvblsxXSk7IC8vIHB1c2ggc3RhdGVcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghcHJlRXJyb3JTeW1ib2wpIHsgLy8gbm9ybWFsIGV4ZWN1dGlvbi9ubyBlcnJvclxuICAgICAgICAgICAgICAgICAgICB5eWxlbmcgPSB0aGlzLmxleGVyLnl5bGVuZztcbiAgICAgICAgICAgICAgICAgICAgeXl0ZXh0ID0gdGhpcy5sZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHl5bGluZW5vID0gdGhpcy5sZXhlci55eWxpbmVubztcbiAgICAgICAgICAgICAgICAgICAgeXlsb2MgPSB0aGlzLmxleGVyLnl5bGxvYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY292ZXJpbmcgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcmluZy0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGVycm9yIGp1c3Qgb2NjdXJyZWQsIHJlc3VtZSBvbGQgbG9va2FoZWFkIGYvIGJlZm9yZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBwcmVFcnJvclN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgcHJlRXJyb3JTeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyOiAvLyByZWR1Y2VcbiAgICAgICAgICAgICAgICAvL3RoaXMucmVkdWN0aW9uQ291bnQrKztcblxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMV07XG5cbiAgICAgICAgICAgICAgICAvLyBwZXJmb3JtIHNlbWFudGljIGFjdGlvblxuICAgICAgICAgICAgICAgIHl5dmFsLiQgPSB2c3RhY2tbdnN0YWNrLmxlbmd0aC1sZW5dOyAvLyBkZWZhdWx0IHRvICQkID0gJDFcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGxvY2F0aW9uLCB1c2VzIGZpcnN0IHRva2VuIGZvciBmaXJzdHMsIGxhc3QgZm9yIGxhc3RzXG4gICAgICAgICAgICAgICAgeXl2YWwuXyQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoLShsZW58fDEpXS5maXJzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoLTFdLmxhc3RfbGluZSxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aC0obGVufHwxKV0uZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGgtMV0ubGFzdF9jb2x1bW5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbCh5eXZhbCwgeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB0aGlzLnl5LCBhY3Rpb25bMV0sIHZzdGFjaywgbHN0YWNrKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcG9wIG9mZiBzdGFja1xuICAgICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZSgwLC0xKmxlbioyKTtcbiAgICAgICAgICAgICAgICAgICAgdnN0YWNrID0gdnN0YWNrLnNsaWNlKDAsIC0xKmxlbik7XG4gICAgICAgICAgICAgICAgICAgIGxzdGFjayA9IGxzdGFjay5zbGljZSgwLCAtMSpsZW4pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVswXSk7ICAgIC8vIHB1c2ggbm9udGVybWluYWwgKHJlZHVjZSlcbiAgICAgICAgICAgICAgICB2c3RhY2sucHVzaCh5eXZhbC4kKTtcbiAgICAgICAgICAgICAgICBsc3RhY2sucHVzaCh5eXZhbC5fJCk7XG4gICAgICAgICAgICAgICAgLy8gZ290byBuZXcgc3RhdGUgPSB0YWJsZVtTVEFURV1bTk9OVEVSTUlOQUxdXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0YWJsZVtzdGFja1tzdGFjay5sZW5ndGgtMl1dW3N0YWNrW3N0YWNrLmxlbmd0aC0xXV07XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzogLy8gYWNjZXB0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufX07LyogSmlzb24gZ2VuZXJhdGVkIGxleGVyICovXG52YXIgbGV4ZXIgPSAoZnVuY3Rpb24oKXtcblxudmFyIGxleGVyID0gKHtFT0Y6MSxcbnBhcnNlRXJyb3I6ZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICAgICAgaWYgKHRoaXMueXkucGFyc2VFcnJvcikge1xuICAgICAgICAgICAgdGhpcy55eS5wYXJzZUVycm9yKHN0ciwgaGFzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbiAgICAgICAgfVxuICAgIH0sXG5zZXRJbnB1dDpmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRoaXMuX2xlc3MgPSB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsZW5nID0gMDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbJ0lOSVRJQUwnXTtcbiAgICAgICAgdGhpcy55eWxsb2MgPSB7Zmlyc3RfbGluZToxLGZpcnN0X2NvbHVtbjowLGxhc3RfbGluZToxLGxhc3RfY29sdW1uOjB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuaW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFswXTtcbiAgICAgICAgdGhpcy55eXRleHQrPWNoO1xuICAgICAgICB0aGlzLnl5bGVuZysrO1xuICAgICAgICB0aGlzLm1hdGNoKz1jaDtcbiAgICAgICAgdGhpcy5tYXRjaGVkKz1jaDtcbiAgICAgICAgdmFyIGxpbmVzID0gY2gubWF0Y2goL1xcbi8pO1xuICAgICAgICBpZiAobGluZXMpIHRoaXMueXlsaW5lbm8rKztcbiAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG51bnB1dDpmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBjaCArIHRoaXMuX2lucHV0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxubW9yZTpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21vcmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxucGFzdElucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiAocGFzdC5sZW5ndGggPiAyMCA/ICcuLi4nOicnKSArIHBhc3Quc3Vic3RyKC0yMCkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgIH0sXG51cGNvbWluZ0lucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm1hdGNoO1xuICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkge1xuICAgICAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5zdWJzdHIoMCwgMjAtbmV4dC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwyMCkrKG5leHQubGVuZ3RoID4gMjAgPyAnLi4uJzonJykpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICB9LFxuc2hvd1Bvc2l0aW9uOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KCk7XG4gICAgICAgIHZhciBjID0gbmV3IEFycmF5KHByZS5sZW5ndGggKyAxKS5qb2luKFwiLVwiKTtcbiAgICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dCgpICsgXCJcXG5cIiArIGMrXCJeXCI7XG4gICAgfSxcbm5leHQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbnB1dCkgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIGNvbCxcbiAgICAgICAgICAgIGxpbmVzO1xuICAgICAgICBpZiAoIXRoaXMuX21vcmUpIHtcbiAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XG4gICAgICAgICAgICB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XG4gICAgICAgIGZvciAodmFyIGk9MDtpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1hdGNoID0gdGhpcy5faW5wdXQubWF0Y2godGhpcy5ydWxlc1tydWxlc1tpXV0pO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbGluZXMgPSBtYXRjaFswXS5tYXRjaCgvXFxuLiovZyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzKSB0aGlzLnl5bGluZW5vICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYyA9IHtmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vKzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgPyBsaW5lc1tsaW5lcy5sZW5ndGgtMV0ubGVuZ3RoLTEgOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiArIG1hdGNoWzBdLmxlbmd0aH1cbiAgICAgICAgICAgICAgICB0aGlzLnl5dGV4dCArPSBtYXRjaFswXTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoICs9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcyA9IG1hdGNoO1xuICAgICAgICAgICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vcmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVkICs9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwodGhpcywgdGhpcy55eSwgdGhpcywgcnVsZXNbaV0sdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aC0xXSk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuKSByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgZWxzZSByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lucHV0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlRXJyb3IoJ0xleGljYWwgZXJyb3Igb24gbGluZSAnKyh0aGlzLnl5bGluZW5vKzEpKycuIFVucmVjb2duaXplZCB0ZXh0LlxcbicrdGhpcy5zaG93UG9zaXRpb24oKSxcbiAgICAgICAgICAgICAgICAgICAge3RleHQ6IFwiXCIsIHRva2VuOiBudWxsLCBsaW5lOiB0aGlzLnl5bGluZW5vfSk7XG4gICAgICAgIH1cbiAgICB9LFxubGV4OmZ1bmN0aW9uIGxleCgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZXgoKTtcbiAgICAgICAgfVxuICAgIH0sXG5iZWdpbjpmdW5jdGlvbiBiZWdpbihjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjay5wdXNoKGNvbmRpdGlvbik7XG4gICAgfSxcbnBvcFN0YXRlOmZ1bmN0aW9uIHBvcFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTtcbiAgICB9LFxuX2N1cnJlbnRSdWxlczpmdW5jdGlvbiBfY3VycmVudFJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW3RoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGgtMV1dLnJ1bGVzO1xuICAgIH0sXG50b3BTdGF0ZTpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoLTJdO1xuICAgIH0sXG5wdXNoU3RhdGU6ZnVuY3Rpb24gYmVnaW4oY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuYmVnaW4oY29uZGl0aW9uKTtcbiAgICB9fSk7XG5sZXhlci5wZXJmb3JtQWN0aW9uID0gZnVuY3Rpb24gYW5vbnltb3VzKHl5LHl5XywkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zLFlZX1NUQVJUKSB7XG5cbnZhciBZWVNUQVRFPVlZX1NUQVJUO1xuc3dpdGNoKCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMpIHtcbmNhc2UgMDovKiBza2lwIHdoaXRlc3BhY2UgKi9cbmJyZWFrO1xuY2FzZSAxOnJldHVybiAyMFxuYnJlYWs7XG5jYXNlIDI6cmV0dXJuIDE5XG5icmVhaztcbmNhc2UgMzpyZXR1cm4gOFxuYnJlYWs7XG5jYXNlIDQ6cmV0dXJuIDlcbmJyZWFrO1xuY2FzZSA1OnJldHVybiA2XG5icmVhaztcbmNhc2UgNjpyZXR1cm4gN1xuYnJlYWs7XG5jYXNlIDc6cmV0dXJuIDExXG5icmVhaztcbmNhc2UgODpyZXR1cm4gMTNcbmJyZWFrO1xuY2FzZSA5OnJldHVybiAxMFxuYnJlYWs7XG5jYXNlIDEwOnJldHVybiAxMlxuYnJlYWs7XG5jYXNlIDExOnJldHVybiAxNFxuYnJlYWs7XG5jYXNlIDEyOnJldHVybiAxNVxuYnJlYWs7XG5jYXNlIDEzOnJldHVybiAxNlxuYnJlYWs7XG5jYXNlIDE0OnJldHVybiAxN1xuYnJlYWs7XG5jYXNlIDE1OnJldHVybiAxOFxuYnJlYWs7XG5jYXNlIDE2OnJldHVybiA1XG5icmVhaztcbmNhc2UgMTc6cmV0dXJuICdJTlZBTElEJ1xuYnJlYWs7XG59XG59O1xubGV4ZXIucnVsZXMgPSBbL15cXHMrLywvXlswLTldKyhcXC5bMC05XSspP1xcYi8sL15uXFxiLywvXlxcfFxcfC8sL14mJi8sL15cXD8vLC9eOi8sL148PS8sL14+PS8sL148LywvXj4vLC9eIT0vLC9ePT0vLC9eJS8sL15cXCgvLC9eXFwpLywvXiQvLC9eLi9dO1xubGV4ZXIuY29uZGl0aW9ucyA9IHtcIklOSVRJQUxcIjp7XCJydWxlc1wiOlswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3XSxcImluY2x1c2l2ZVwiOnRydWV9fTtyZXR1cm4gbGV4ZXI7fSkoKVxucGFyc2VyLmxleGVyID0gbGV4ZXI7XG5yZXR1cm4gcGFyc2VyO1xufSkoKTtcbi8vIEVuZCBwYXJzZXJcblxuICAvLyBIYW5kbGUgbm9kZSwgYW1kLCBhbmQgZ2xvYmFsIHN5c3RlbXNcbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gSmVkO1xuICAgIH1cbiAgICBleHBvcnRzLkplZCA9IEplZDtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoJ2plZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSmVkO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIExlYWsgYSBnbG9iYWwgcmVnYXJkbGVzcyBvZiBtb2R1bGUgc3lzdGVtXG4gICAgcm9vdFsnSmVkJ10gPSBKZWQ7XG4gIH1cblxufSkodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qZWQvamVkLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIHNoYUNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbnZhciByb3RsMzIgPSB1dGlscy5yb3RsMzI7XG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl81ID0gdXRpbHMuc3VtMzJfNTtcbnZhciBmdF8xID0gc2hhQ29tbW9uLmZ0XzE7XG52YXIgQmxvY2tIYXNoID0gY29tbW9uLkJsb2NrSGFzaDtcblxudmFyIHNoYTFfSyA9IFtcbiAgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSxcbiAgMHg4RjFCQkNEQywgMHhDQTYyQzFENlxuXTtcblxuZnVuY3Rpb24gU0hBMSgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTEpKVxuICAgIHJldHVybiBuZXcgU0hBMSgpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSxcbiAgICAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG4gIHRoaXMuVyA9IG5ldyBBcnJheSg4MCk7XG59XG5cbnV0aWxzLmluaGVyaXRzKFNIQTEsIEJsb2NrSGFzaCk7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTE7XG5cblNIQTEuYmxvY2tTaXplID0gNTEyO1xuU0hBMS5vdXRTaXplID0gMTYwO1xuU0hBMS5obWFjU3RyZW5ndGggPSA4MDtcblNIQTEucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcblxuICBmb3IoOyBpIDwgVy5sZW5ndGg7IGkrKylcbiAgICBXW2ldID0gcm90bDMyKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0sIDEpO1xuXG4gIHZhciBhID0gdGhpcy5oWzBdO1xuICB2YXIgYiA9IHRoaXMuaFsxXTtcbiAgdmFyIGMgPSB0aGlzLmhbMl07XG4gIHZhciBkID0gdGhpcy5oWzNdO1xuICB2YXIgZSA9IHRoaXMuaFs0XTtcblxuICBmb3IgKGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzID0gfn4oaSAvIDIwKTtcbiAgICB2YXIgdCA9IHN1bTMyXzUocm90bDMyKGEsIDUpLCBmdF8xKHMsIGIsIGMsIGQpLCBlLCBXW2ldLCBzaGExX0tbc10pO1xuICAgIGUgPSBkO1xuICAgIGQgPSBjO1xuICAgIGMgPSByb3RsMzIoYiwgMzApO1xuICAgIGIgPSBhO1xuICAgIGEgPSB0O1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbn07XG5cblNIQTEucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMS5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuZnVuY3Rpb24gQmxvY2tIYXNoKCkge1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdUb3RhbCA9IDA7XG4gIHRoaXMuYmxvY2tTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5ibG9ja1NpemU7XG4gIHRoaXMub3V0U2l6ZSA9IHRoaXMuY29uc3RydWN0b3Iub3V0U2l6ZTtcbiAgdGhpcy5obWFjU3RyZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLmhtYWNTdHJlbmd0aDtcbiAgdGhpcy5wYWRMZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLnBhZExlbmd0aCAvIDg7XG4gIHRoaXMuZW5kaWFuID0gJ2JpZyc7XG5cbiAgdGhpcy5fZGVsdGE4ID0gdGhpcy5ibG9ja1NpemUgLyA4O1xuICB0aGlzLl9kZWx0YTMyID0gdGhpcy5ibG9ja1NpemUgLyAzMjtcbn1cbmV4cG9ydHMuQmxvY2tIYXNoID0gQmxvY2tIYXNoO1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuICAvLyBDb252ZXJ0IG1lc3NhZ2UgdG8gYXJyYXksIHBhZCBpdCwgYW5kIGpvaW4gaW50byAzMmJpdCBibG9ja3NcbiAgbXNnID0gdXRpbHMudG9BcnJheShtc2csIGVuYyk7XG4gIGlmICghdGhpcy5wZW5kaW5nKVxuICAgIHRoaXMucGVuZGluZyA9IG1zZztcbiAgZWxzZVxuICAgIHRoaXMucGVuZGluZyA9IHRoaXMucGVuZGluZy5jb25jYXQobXNnKTtcbiAgdGhpcy5wZW5kaW5nVG90YWwgKz0gbXNnLmxlbmd0aDtcblxuICAvLyBFbm91Z2ggZGF0YSwgdHJ5IHVwZGF0aW5nXG4gIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID49IHRoaXMuX2RlbHRhOCkge1xuICAgIG1zZyA9IHRoaXMucGVuZGluZztcblxuICAgIC8vIFByb2Nlc3MgcGVuZGluZyBkYXRhIGluIGJsb2Nrc1xuICAgIHZhciByID0gbXNnLmxlbmd0aCAlIHRoaXMuX2RlbHRhODtcbiAgICB0aGlzLnBlbmRpbmcgPSBtc2cuc2xpY2UobXNnLmxlbmd0aCAtIHIsIG1zZy5sZW5ndGgpO1xuICAgIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcblxuICAgIG1zZyA9IHV0aWxzLmpvaW4zMihtc2csIDAsIG1zZy5sZW5ndGggLSByLCB0aGlzLmVuZGlhbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IHRoaXMuX2RlbHRhMzIpXG4gICAgICB0aGlzLl91cGRhdGUobXNnLCBpLCBpICsgdGhpcy5fZGVsdGEzMik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICB0aGlzLnVwZGF0ZSh0aGlzLl9wYWQoKSk7XG4gIGFzc2VydCh0aGlzLnBlbmRpbmcgPT09IG51bGwpO1xuXG4gIHJldHVybiB0aGlzLl9kaWdlc3QoZW5jKTtcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIHBhZCgpIHtcbiAgdmFyIGxlbiA9IHRoaXMucGVuZGluZ1RvdGFsO1xuICB2YXIgYnl0ZXMgPSB0aGlzLl9kZWx0YTg7XG4gIHZhciBrID0gYnl0ZXMgLSAoKGxlbiArIHRoaXMucGFkTGVuZ3RoKSAlIGJ5dGVzKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShrICsgdGhpcy5wYWRMZW5ndGgpO1xuICByZXNbMF0gPSAweDgwO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGs7IGkrKylcbiAgICByZXNbaV0gPSAwO1xuXG4gIC8vIEFwcGVuZCBsZW5ndGhcbiAgbGVuIDw8PSAzO1xuICBpZiAodGhpcy5lbmRpYW4gPT09ICdiaWcnKSB7XG4gICAgZm9yICh2YXIgdCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgcmVzW2krK10gPSAwO1xuXG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiA4KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuICB9IGVsc2Uge1xuICAgIHJlc1tpKytdID0gbGVuICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAyNCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcblxuICAgIGZvciAodCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgcmVzW2krK10gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL2NvbW1vbi5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciByb3RyMzIgPSB1dGlscy5yb3RyMzI7XG5cbmZ1bmN0aW9uIGZ0XzEocywgeCwgeSwgeikge1xuICBpZiAocyA9PT0gMClcbiAgICByZXR1cm4gY2gzMih4LCB5LCB6KTtcbiAgaWYgKHMgPT09IDEgfHwgcyA9PT0gMylcbiAgICByZXR1cm4gcDMyKHgsIHksIHopO1xuICBpZiAocyA9PT0gMilcbiAgICByZXR1cm4gbWFqMzIoeCwgeSwgeik7XG59XG5leHBvcnRzLmZ0XzEgPSBmdF8xO1xuXG5mdW5jdGlvbiBjaDMyKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgXiAoKH54KSAmIHopO1xufVxuZXhwb3J0cy5jaDMyID0gY2gzMjtcblxuZnVuY3Rpb24gbWFqMzIoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSBeICh4ICYgeikgXiAoeSAmIHopO1xufVxuZXhwb3J0cy5tYWozMiA9IG1hajMyO1xuXG5mdW5jdGlvbiBwMzIoeCwgeSwgeikge1xuICByZXR1cm4geCBeIHkgXiB6O1xufVxuZXhwb3J0cy5wMzIgPSBwMzI7XG5cbmZ1bmN0aW9uIHMwXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgMikgXiByb3RyMzIoeCwgMTMpIF4gcm90cjMyKHgsIDIyKTtcbn1cbmV4cG9ydHMuczBfMjU2ID0gczBfMjU2O1xuXG5mdW5jdGlvbiBzMV8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDYpIF4gcm90cjMyKHgsIDExKSBeIHJvdHIzMih4LCAyNSk7XG59XG5leHBvcnRzLnMxXzI1NiA9IHMxXzI1NjtcblxuZnVuY3Rpb24gZzBfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCA3KSBeIHJvdHIzMih4LCAxOCkgXiAoeCA+Pj4gMyk7XG59XG5leHBvcnRzLmcwXzI1NiA9IGcwXzI1NjtcblxuZnVuY3Rpb24gZzFfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCAxNykgXiByb3RyMzIoeCwgMTkpIF4gKHggPj4+IDEwKTtcbn1cbmV4cG9ydHMuZzFfMjU2ID0gZzFfMjU2O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvY29tbW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRXh0ZXJuYWwgRGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuXG4vKipcbiAqIEludGVybmFsIERlcGVuZGVuY2llc1xuICovXG5cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0QWRkb25zQ3JlYXRlRnJhZ21lbnQgPSByZXF1aXJlKCdyZWFjdC1hZGRvbnMtY3JlYXRlLWZyYWdtZW50Jyk7XG5cbnZhciBfcmVhY3RBZGRvbnNDcmVhdGVGcmFnbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdEFkZG9uc0NyZWF0ZUZyYWdtZW50KTtcblxudmFyIF90b2tlbml6ZSA9IHJlcXVpcmUoJy4vdG9rZW5pemUnKTtcblxudmFyIF90b2tlbml6ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b2tlbml6ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjdXJyZW50TWl4ZWRTdHJpbmcgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIGdldENsb3NlSW5kZXgob3BlbkluZGV4LCB0b2tlbnMpIHtcblx0dmFyIG9wZW5Ub2tlbiA9IHRva2Vuc1tvcGVuSW5kZXhdLFxuXHQgICAgbmVzdExldmVsID0gMCxcblx0ICAgIHRva2VuLFxuXHQgICAgaTtcblx0Zm9yIChpID0gb3BlbkluZGV4ICsgMTsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuXHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXHRcdGlmICh0b2tlbi52YWx1ZSA9PT0gb3BlblRva2VuLnZhbHVlKSB7XG5cdFx0XHRpZiAodG9rZW4udHlwZSA9PT0gJ2NvbXBvbmVudE9wZW4nKSB7XG5cdFx0XHRcdG5lc3RMZXZlbCsrO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmICh0b2tlbi50eXBlID09PSAnY29tcG9uZW50Q2xvc2UnKSB7XG5cdFx0XHRcdGlmIChuZXN0TGV2ZWwgPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXN0TGV2ZWwtLTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly8gaWYgd2UgZ2V0IHRoaXMgZmFyLCB0aGVyZSB3YXMgbm8gbWF0Y2hpbmcgY2xvc2UgdG9rZW5cblx0dGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNsb3NpbmcgY29tcG9uZW50IHRva2VuIGAnICsgb3BlblRva2VuLnZhbHVlICsgJ2AnKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRDaGlsZHJlbih0b2tlbnMsIGNvbXBvbmVudHMpIHtcblx0dmFyIGNoaWxkcmVuID0gW10sXG5cdCAgICBjaGlsZHJlbk9iamVjdCA9IHt9LFxuXHQgICAgb3BlbkNvbXBvbmVudCxcblx0ICAgIGNsb25lZE9wZW5Db21wb25lbnQsXG5cdCAgICBvcGVuSW5kZXgsXG5cdCAgICBjbG9zZUluZGV4LFxuXHQgICAgdG9rZW4sXG5cdCAgICBpLFxuXHQgICAgZ3JhbmRDaGlsZFRva2Vucyxcblx0ICAgIGdyYW5kQ2hpbGRyZW4sXG5cdCAgICBzaWJsaW5nVG9rZW5zLFxuXHQgICAgc2libGluZ3M7XG5cblx0Zm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuXHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXHRcdGlmICh0b2tlbi50eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0Y2hpbGRyZW4ucHVzaCh0b2tlbi52YWx1ZSk7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0Ly8gY29tcG9uZW50IG5vZGUgc2hvdWxkIGF0IGxlYXN0IGJlIHNldFxuXHRcdGlmICghY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eSh0b2tlbi52YWx1ZSkgfHwgdHlwZW9mIGNvbXBvbmVudHNbdG9rZW4udmFsdWVdID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVycG9sYXRpb24sIG1pc3NpbmcgY29tcG9uZW50IG5vZGU6IGAnICsgdG9rZW4udmFsdWUgKyAnYCcpO1xuXHRcdH1cblx0XHQvLyBzaG91bGQgYmUgZWl0aGVyIFJlYWN0RWxlbWVudCBvciBudWxsIChib3RoIHR5cGUgXCJvYmplY3RcIiksIGFsbCBvdGhlciB0eXBlcyBkZXByZWNhdGVkXG5cdFx0aWYgKF90eXBlb2YoY29tcG9uZW50c1t0b2tlbi52YWx1ZV0pICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVycG9sYXRpb24sIGNvbXBvbmVudCBub2RlIG11c3QgYmUgYSBSZWFjdEVsZW1lbnQgb3IgbnVsbDogYCcgKyB0b2tlbi52YWx1ZSArICdgJywgJ1xcbj4gJyArIGN1cnJlbnRNaXhlZFN0cmluZyk7XG5cdFx0fVxuXHRcdC8vIHdlIHNob3VsZCBuZXZlciBzZWUgYSBjb21wb25lbnRDbG9zZSB0b2tlbiBpbiB0aGlzIGxvb3Bcblx0XHRpZiAodG9rZW4udHlwZSA9PT0gJ2NvbXBvbmVudENsb3NlJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIG9wZW5pbmcgY29tcG9uZW50IHRva2VuOiBgJyArIHRva2VuLnZhbHVlICsgJ2AnKTtcblx0XHR9XG5cdFx0aWYgKHRva2VuLnR5cGUgPT09ICdjb21wb25lbnRPcGVuJykge1xuXHRcdFx0b3BlbkNvbXBvbmVudCA9IGNvbXBvbmVudHNbdG9rZW4udmFsdWVdO1xuXHRcdFx0b3BlbkluZGV4ID0gaTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHQvLyBjb21wb25lbnRTZWxmQ2xvc2luZyB0b2tlblxuXHRcdGNoaWxkcmVuLnB1c2goY29tcG9uZW50c1t0b2tlbi52YWx1ZV0pO1xuXHRcdGNvbnRpbnVlO1xuXHR9XG5cblx0aWYgKG9wZW5Db21wb25lbnQpIHtcblx0XHRjbG9zZUluZGV4ID0gZ2V0Q2xvc2VJbmRleChvcGVuSW5kZXgsIHRva2Vucyk7XG5cdFx0Z3JhbmRDaGlsZFRva2VucyA9IHRva2Vucy5zbGljZShvcGVuSW5kZXggKyAxLCBjbG9zZUluZGV4KTtcblx0XHRncmFuZENoaWxkcmVuID0gYnVpbGRDaGlsZHJlbihncmFuZENoaWxkVG9rZW5zLCBjb21wb25lbnRzKTtcblx0XHRjbG9uZWRPcGVuQ29tcG9uZW50ID0gX3JlYWN0Mi5kZWZhdWx0LmNsb25lRWxlbWVudChvcGVuQ29tcG9uZW50LCB7fSwgZ3JhbmRDaGlsZHJlbik7XG5cdFx0Y2hpbGRyZW4ucHVzaChjbG9uZWRPcGVuQ29tcG9uZW50KTtcblxuXHRcdGlmIChjbG9zZUluZGV4IDwgdG9rZW5zLmxlbmd0aCAtIDEpIHtcblx0XHRcdHNpYmxpbmdUb2tlbnMgPSB0b2tlbnMuc2xpY2UoY2xvc2VJbmRleCArIDEpO1xuXHRcdFx0c2libGluZ3MgPSBidWlsZENoaWxkcmVuKHNpYmxpbmdUb2tlbnMsIGNvbXBvbmVudHMpO1xuXHRcdFx0Y2hpbGRyZW4gPSBjaGlsZHJlbi5jb25jYXQoc2libGluZ3MpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcblx0XHRyZXR1cm4gY2hpbGRyZW5bMF07XG5cdH1cblxuXHRjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcblx0XHRpZiAoY2hpbGQpIHtcblx0XHRcdGNoaWxkcmVuT2JqZWN0WydpbnRlcnBvbGF0aW9uLWNoaWxkLScgKyBpbmRleF0gPSBjaGlsZDtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiAoMCwgX3JlYWN0QWRkb25zQ3JlYXRlRnJhZ21lbnQyLmRlZmF1bHQpKGNoaWxkcmVuT2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUob3B0aW9ucykge1xuXHR2YXIgbWl4ZWRTdHJpbmcgPSBvcHRpb25zLm1peGVkU3RyaW5nLFxuXHQgICAgY29tcG9uZW50cyA9IG9wdGlvbnMuY29tcG9uZW50cyxcblx0ICAgIHRocm93RXJyb3JzID0gb3B0aW9ucy50aHJvd0Vycm9ycztcblxuXG5cdGN1cnJlbnRNaXhlZFN0cmluZyA9IG1peGVkU3RyaW5nO1xuXG5cdGlmICghY29tcG9uZW50cykge1xuXHRcdHJldHVybiBtaXhlZFN0cmluZztcblx0fVxuXG5cdGlmICgodHlwZW9mIGNvbXBvbmVudHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbXBvbmVudHMpKSAhPT0gJ29iamVjdCcpIHtcblx0XHRpZiAodGhyb3dFcnJvcnMpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW50ZXJwb2xhdGlvbiBFcnJvcjogdW5hYmxlIHRvIHByb2Nlc3MgYCcgKyBtaXhlZFN0cmluZyArICdgIGJlY2F1c2UgY29tcG9uZW50cyBpcyBub3QgYW4gb2JqZWN0Jyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1peGVkU3RyaW5nO1xuXHR9XG5cblx0dmFyIHRva2VucyA9ICgwLCBfdG9rZW5pemUyLmRlZmF1bHQpKG1peGVkU3RyaW5nKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiBidWlsZENoaWxkcmVuKHRva2VucywgY29tcG9uZW50cyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0aWYgKHRocm93RXJyb3JzKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludGVycG9sYXRpb24gRXJyb3I6IHVuYWJsZSB0byBwcm9jZXNzIGAnICsgbWl4ZWRTdHJpbmcgKyAnYCBiZWNhdXNlIG9mIGVycm9yIGAnICsgZXJyb3IubWVzc2FnZSArICdgJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1peGVkU3RyaW5nO1xuXHR9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBpbnRlcnBvbGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ludGVycG9sYXRlLWNvbXBvbmVudHMvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvciAmJiBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gIDB4ZWFjNztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgdmFyIGl0ZXJhdG9yRm4gPVxuICAgIG1heWJlSXRlcmFibGUgJiZcbiAgICAoKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKFxuICBjaGlsZHJlbixcbiAgbmFtZVNvRmFyLFxuICBjYWxsYmFjayxcbiAgdHJhdmVyc2VDb250ZXh0XG4pIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGlmIChcbiAgICBjaGlsZHJlbiA9PT0gbnVsbCB8fFxuICAgIHR5cGUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQuIFRoaXMgbWVhbnMgd2UgY2FuIG9wdGltaXplXG4gICAgLy8gc29tZSBjaGVja3MuIFJlYWN0IEZpYmVyIGFsc28gaW5saW5lcyB0aGlzIGxvZ2ljIGZvciBzaW1pbGFyIHB1cnBvc2VzLlxuICAgICh0eXBlID09PSAnb2JqZWN0JyAmJiBjaGlsZHJlbi4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKVxuICApIHtcbiAgICBjYWxsYmFjayhcbiAgICAgIHRyYXZlcnNlQ29udGV4dCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0ZhclxuICAgICk7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgbmV4dE5hbWUsXG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICB0cmF2ZXJzZUNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzLFxuICAgICAgICAgICAgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgK1xuICAgICAgICAgICAgICAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArXG4gICAgICAgICAgICAgICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIG5leHROYW1lLFxuICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgIHRyYXZlcnNlQ29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYWRkZW5kdW0gPVxuICAgICAgICAgICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICtcbiAgICAgICAgICAnUmVhY3QgYWRkLW9ucy4nO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gJycgKyBjaGlsZHJlbjtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsXG4gICAgICAgIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJ1xuICAgICAgICAgID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9J1xuICAgICAgICAgIDogY2hpbGRyZW5TdHJpbmcsXG4gICAgICAgIGFkZGVuZHVtXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KFxuICAgIG9sZEVsZW1lbnQsXG4gICAge2tleTogbmV3S2V5fSxcbiAgICBvbGRFbGVtZW50LnByb3BzICE9PSB1bmRlZmluZWQgPyBvbGRFbGVtZW50LnByb3BzLmNoaWxkcmVuIDogdW5kZWZpbmVkXG4gICk7XG59XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uKGNvcHlGaWVsZHNGcm9tKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGNvcHlGaWVsZHNGcm9tKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhjb3B5RmllbGRzRnJvbSk7XG4gIH1cbn07XG5cbnZhciBhZGRQb29saW5nVG8gPSBmdW5jdGlvbiBhZGRQb29saW5nVG8oQ29weUNvbnN0cnVjdG9yLCBwb29sZXIpIHtcbiAgLy8gQ2FzdGluZyBhcyBhbnkgc28gdGhhdCBmbG93IGlnbm9yZXMgdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiBhbmQgdHJ1c3RzXG4gIC8vIGl0IHRvIG1hdGNoIHRoZSB0eXBlIHdlIGRlY2xhcmVkXG4gIHZhciBOZXdLbGFzcyA9IENvcHlDb25zdHJ1Y3RvcjtcbiAgTmV3S2xhc3MuaW5zdGFuY2VQb29sID0gW107XG4gIE5ld0tsYXNzLmdldFBvb2xlZCA9IHBvb2xlciB8fCBERUZBVUxUX1BPT0xFUjtcbiAgaWYgKCFOZXdLbGFzcy5wb29sU2l6ZSkge1xuICAgIE5ld0tsYXNzLnBvb2xTaXplID0gREVGQVVMVF9QT09MX1NJWkU7XG4gIH1cbiAgTmV3S2xhc3MucmVsZWFzZSA9IHN0YW5kYXJkUmVsZWFzZXI7XG4gIHJldHVybiBOZXdLbGFzcztcbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gc3RhbmRhcmRSZWxlYXNlcihpbnN0YW5jZSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpbnZhcmlhbnQoXG4gICAgaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcyxcbiAgICAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nXG4gICk7XG4gIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGggPCBLbGFzcy5wb29sU2l6ZSkge1xuICAgIEtsYXNzLmluc3RhbmNlUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIGZvdXJBcmd1bWVudFBvb2xlcihhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBNYXBCb29rS2VlcGluZyhtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgdGhpcy5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICB0aGlzLmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5NYXBCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gIHRoaXMua2V5UHJlZml4ID0gbnVsbDtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuYWRkUG9vbGluZ1RvKE1hcEJvb2tLZWVwaW5nLCBmb3VyQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdDtcbiAgdmFyIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeDtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jO1xuICB2YXIgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChcbiAgICAgIG1hcHBlZENoaWxkLFxuICAgICAgcmVzdWx0LFxuICAgICAgY2hpbGRLZXksXG4gICAgICBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnRcbiAgICApO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShcbiAgICAgICAgbWFwcGVkQ2hpbGQsXG4gICAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICBrZXlQcmVmaXggK1xuICAgICAgICAgIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSlcbiAgICAgICAgICAgID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLydcbiAgICAgICAgICAgIDogJycpICtcbiAgICAgICAgICBjaGlsZEtleVxuICAgICAgKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBNYXBCb29rS2VlcGluZy5nZXRQb29sZWQoXG4gICAgYXJyYXksXG4gICAgZXNjYXBlZFByZWZpeCxcbiAgICBmdW5jLFxuICAgIGNvbnRleHRcbiAgKTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgTWFwQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG52YXIgbnVtZXJpY1Byb3BlcnR5UmVnZXggPSAvXlxcZCskLztcblxudmFyIHdhcm5lZEFib3V0TnVtZXJpYyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjcmVhdGVSZWFjdEZyYWdtZW50KG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcgfHwgIW9iamVjdCB8fCBBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICAnUmVhY3QuYWRkb25zLmNyZWF0ZUZyYWdtZW50IG9ubHkgYWNjZXB0cyBhIHNpbmdsZSBvYmplY3QuIEdvdDogJXMnLFxuICAgICAgb2JqZWN0XG4gICAgKTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChvYmplY3QpKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgJ1JlYWN0LmFkZG9ucy5jcmVhdGVGcmFnbWVudCBkb2VzIG5vdCBhY2NlcHQgYSBSZWFjdEVsZW1lbnQgJyArXG4gICAgICAgICd3aXRob3V0IGEgd3JhcHBlciBvYmplY3QuJ1xuICAgICk7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIGludmFyaWFudChcbiAgICBvYmplY3Qubm9kZVR5cGUgIT09IDEsXG4gICAgJ1JlYWN0LmFkZG9ucy5jcmVhdGVGcmFnbWVudCguLi4pOiBFbmNvdW50ZXJlZCBhbiBpbnZhbGlkIGNoaWxkOyBET00gJyArXG4gICAgICAnZWxlbWVudHMgYXJlIG5vdCB2YWxpZCBjaGlsZHJlbiBvZiBSZWFjdCBjb21wb25lbnRzLidcbiAgKTtcblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIXdhcm5lZEFib3V0TnVtZXJpYyAmJiBudW1lcmljUHJvcGVydHlSZWdleC50ZXN0KGtleSkpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnUmVhY3QuYWRkb25zLmNyZWF0ZUZyYWdtZW50KC4uLik6IENoaWxkIG9iamVjdHMgc2hvdWxkIGhhdmUgJyArXG4gICAgICAgICAgICAnbm9uLW51bWVyaWMga2V5cyBzbyBvcmRlcmluZyBpcyBwcmVzZXJ2ZWQuJ1xuICAgICAgICApO1xuICAgICAgICB3YXJuZWRBYm91dE51bWVyaWMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKFxuICAgICAgb2JqZWN0W2tleV0sXG4gICAgICByZXN1bHQsXG4gICAgICBrZXksXG4gICAgICBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnRcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZWFjdEZyYWdtZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtYWRkb25zLWNyZWF0ZS1mcmFnbWVudC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGlkZW50aWZ5VG9rZW4oaXRlbSkge1xuXHQvLyB7ey9leGFtcGxlfX1cblx0aWYgKGl0ZW0ubWF0Y2goL15cXHtcXHtcXC8vKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiAnY29tcG9uZW50Q2xvc2UnLFxuXHRcdFx0dmFsdWU6IGl0ZW0ucmVwbGFjZSgvXFxXL2csICcnKVxuXHRcdH07XG5cdH1cblx0Ly8ge3tleGFtcGxlIC99fVxuXHRpZiAoaXRlbS5tYXRjaCgvXFwvXFx9XFx9JC8pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6ICdjb21wb25lbnRTZWxmQ2xvc2luZycsXG5cdFx0XHR2YWx1ZTogaXRlbS5yZXBsYWNlKC9cXFcvZywgJycpXG5cdFx0fTtcblx0fVxuXHQvLyB7e2V4YW1wbGV9fVxuXHRpZiAoaXRlbS5tYXRjaCgvXlxce1xcey8pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6ICdjb21wb25lbnRPcGVuJyxcblx0XHRcdHZhbHVlOiBpdGVtLnJlcGxhY2UoL1xcVy9nLCAnJylcblx0XHR9O1xuXHR9XG5cdHJldHVybiB7XG5cdFx0dHlwZTogJ3N0cmluZycsXG5cdFx0dmFsdWU6IGl0ZW1cblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWl4ZWRTdHJpbmcpIHtcblx0dmFyIHRva2VuU3RyaW5ncyA9IG1peGVkU3RyaW5nLnNwbGl0KC8oXFx7XFx7XFwvP1xccypcXHcrXFxzKlxcLz9cXH1cXH0pL2cpOyAvLyBzcGxpdCB0byBjb21wb25lbnRzIGFuZCBzdHJpbmdzXG5cdHJldHVybiB0b2tlblN0cmluZ3MubWFwKGlkZW50aWZ5VG9rZW4pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRva2VuaXplLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ludGVycG9sYXRlLWNvbXBvbmVudHMvbGliL3Rva2VuaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsInZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IExSVVxuXG5mdW5jdGlvbiBMUlUgKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExSVSkpIHJldHVybiBuZXcgTFJVKG9wdHMpXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ251bWJlcicpIG9wdHMgPSB7bWF4OiBvcHRzfVxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICBldmVudHMuRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcbiAgdGhpcy5jYWNoZSA9IHt9XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGxcbiAgdGhpcy5sZW5ndGggPSAwXG4gIHRoaXMubWF4ID0gb3B0cy5tYXggfHwgMTAwMFxuICB0aGlzLm1heEFnZSA9IG9wdHMubWF4QWdlIHx8IDBcbn1cblxuaW5oZXJpdHMoTFJVLCBldmVudHMuRXZlbnRFbWl0dGVyKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVLnByb3RvdHlwZSwgJ2tleXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jYWNoZSkgfVxufSlcblxuTFJVLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jYWNoZSA9IHt9XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGxcbiAgdGhpcy5sZW5ndGggPSAwXG59XG5cbkxSVS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIGtleSA9ICcnICsga2V5XG4gIGlmICghdGhpcy5jYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm5cblxuICB2YXIgZWxlbWVudCA9IHRoaXMuY2FjaGVba2V5XVxuICBkZWxldGUgdGhpcy5jYWNoZVtrZXldXG4gIHRoaXMuX3VubGluayhrZXksIGVsZW1lbnQucHJldiwgZWxlbWVudC5uZXh0KVxuICByZXR1cm4gZWxlbWVudC52YWx1ZVxufVxuXG5MUlUucHJvdG90eXBlLl91bmxpbmsgPSBmdW5jdGlvbiAoa2V5LCBwcmV2LCBuZXh0KSB7XG4gIHRoaXMubGVuZ3RoLS1cblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuaGVhZCA9PT0ga2V5KSB7XG4gICAgICB0aGlzLmhlYWQgPSBwcmV2XG4gICAgICB0aGlzLmNhY2hlW3RoaXMuaGVhZF0ubmV4dCA9IG51bGxcbiAgICB9IGVsc2UgaWYgKHRoaXMudGFpbCA9PT0ga2V5KSB7XG4gICAgICB0aGlzLnRhaWwgPSBuZXh0XG4gICAgICB0aGlzLmNhY2hlW3RoaXMudGFpbF0ucHJldiA9IG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYWNoZVtwcmV2XS5uZXh0ID0gbmV4dFxuICAgICAgdGhpcy5jYWNoZVtuZXh0XS5wcmV2ID0gcHJldlxuICAgIH1cbiAgfVxufVxuXG5MUlUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICghdGhpcy5jYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm5cblxuICB2YXIgZWxlbWVudCA9IHRoaXMuY2FjaGVba2V5XVxuXG4gIGlmICghdGhpcy5fY2hlY2tBZ2Uoa2V5LCBlbGVtZW50KSkgcmV0dXJuXG4gIHJldHVybiBlbGVtZW50LnZhbHVlXG59XG5cbkxSVS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSBrZXkgPSAnJyArIGtleVxuXG4gIHZhciBlbGVtZW50XG5cbiAgaWYgKHRoaXMuY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIGVsZW1lbnQgPSB0aGlzLmNhY2hlW2tleV1cbiAgICBlbGVtZW50LnZhbHVlID0gdmFsdWVcbiAgICBpZiAodGhpcy5tYXhBZ2UpIGVsZW1lbnQubW9kaWZpZWQgPSBEYXRlLm5vdygpXG5cbiAgICAvLyBJZiBpdCdzIGFscmVhZHkgdGhlIGhlYWQsIHRoZXJlJ3Mgbm90aGluZyBtb3JlIHRvIGRvOlxuICAgIGlmIChrZXkgPT09IHRoaXMuaGVhZCkgcmV0dXJuIHZhbHVlXG4gICAgdGhpcy5fdW5saW5rKGtleSwgZWxlbWVudC5wcmV2LCBlbGVtZW50Lm5leHQpXG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudCA9IHt2YWx1ZTogdmFsdWUsIG1vZGlmaWVkOiAwLCBuZXh0OiBudWxsLCBwcmV2OiBudWxsfVxuICAgIGlmICh0aGlzLm1heEFnZSkgZWxlbWVudC5tb2RpZmllZCA9IERhdGUubm93KClcbiAgICB0aGlzLmNhY2hlW2tleV0gPSBlbGVtZW50XG5cbiAgICAvLyBFdmljdGlvbiBpcyBvbmx5IHBvc3NpYmxlIGlmIHRoZSBrZXkgZGlkbid0IGFscmVhZHkgZXhpc3Q6XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSB0aGlzLm1heCkgdGhpcy5ldmljdCgpXG4gIH1cblxuICB0aGlzLmxlbmd0aCsrXG4gIGVsZW1lbnQubmV4dCA9IG51bGxcbiAgZWxlbWVudC5wcmV2ID0gdGhpcy5oZWFkXG5cbiAgaWYgKHRoaXMuaGVhZCkgdGhpcy5jYWNoZVt0aGlzLmhlYWRdLm5leHQgPSBrZXlcbiAgdGhpcy5oZWFkID0ga2V5XG5cbiAgaWYgKCF0aGlzLnRhaWwpIHRoaXMudGFpbCA9IGtleVxuICByZXR1cm4gdmFsdWVcbn1cblxuTFJVLnByb3RvdHlwZS5fY2hlY2tBZ2UgPSBmdW5jdGlvbiAoa2V5LCBlbGVtZW50KSB7XG4gIGlmICh0aGlzLm1heEFnZSAmJiAoRGF0ZS5ub3coKSAtIGVsZW1lbnQubW9kaWZpZWQpID4gdGhpcy5tYXhBZ2UpIHtcbiAgICB0aGlzLnJlbW92ZShrZXkpXG4gICAgdGhpcy5lbWl0KCdldmljdCcsIHtrZXk6IGtleSwgdmFsdWU6IGVsZW1lbnQudmFsdWV9KVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbkxSVS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIGtleSA9ICcnICsga2V5XG4gIGlmICghdGhpcy5jYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm5cblxuICB2YXIgZWxlbWVudCA9IHRoaXMuY2FjaGVba2V5XVxuXG4gIGlmICghdGhpcy5fY2hlY2tBZ2Uoa2V5LCBlbGVtZW50KSkgcmV0dXJuXG5cbiAgaWYgKHRoaXMuaGVhZCAhPT0ga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gdGhpcy50YWlsKSB7XG4gICAgICB0aGlzLnRhaWwgPSBlbGVtZW50Lm5leHRcbiAgICAgIHRoaXMuY2FjaGVbdGhpcy50YWlsXS5wcmV2ID0gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXQgcHJldi5uZXh0IC0+IGVsZW1lbnQubmV4dDpcbiAgICAgIHRoaXMuY2FjaGVbZWxlbWVudC5wcmV2XS5uZXh0ID0gZWxlbWVudC5uZXh0XG4gICAgfVxuXG4gICAgLy8gU2V0IGVsZW1lbnQubmV4dC5wcmV2IC0+IGVsZW1lbnQucHJldjpcbiAgICB0aGlzLmNhY2hlW2VsZW1lbnQubmV4dF0ucHJldiA9IGVsZW1lbnQucHJldlxuXG4gICAgLy8gRWxlbWVudCBpcyB0aGUgbmV3IGhlYWRcbiAgICB0aGlzLmNhY2hlW3RoaXMuaGVhZF0ubmV4dCA9IGtleVxuICAgIGVsZW1lbnQucHJldiA9IHRoaXMuaGVhZFxuICAgIGVsZW1lbnQubmV4dCA9IG51bGxcbiAgICB0aGlzLmhlYWQgPSBrZXlcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50LnZhbHVlXG59XG5cbkxSVS5wcm90b3R5cGUuZXZpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy50YWlsKSByZXR1cm5cbiAgdmFyIGtleSA9IHRoaXMudGFpbFxuICB2YXIgdmFsdWUgPSB0aGlzLnJlbW92ZSh0aGlzLnRhaWwpXG4gIHRoaXMuZW1pdCgnZXZpY3QnLCB7a2V5OiBrZXksIHZhbHVlOiB2YWx1ZX0pXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9scnUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiLyoqXG4gKiBFeHBvc2VzIG51bWJlciBmb3JtYXQgY2FwYWJpbGl0eVxuICpcbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDEzIEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rdnouaW8pIGFuZCBDb250cmlidXRvcnMgKGh0dHA6Ly9waHBqcy5vcmcvYXV0aG9ycykuXG4gKiBAbGljZW5zZSBTZWUgQ1JFRElUUy5tZFxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20va3Z6L3BocGpzL2Jsb2IvZmZlMTM1NmFmMjNhNmYyNTEyYzg0Yzk1NGRkNGU4MjhlOTI1NzlmYS9mdW5jdGlvbnMvc3RyaW5ncy9udW1iZXJfZm9ybWF0LmpzXG4gKi9cbmZ1bmN0aW9uIG51bWJlcl9mb3JtYXQoIG51bWJlciwgZGVjaW1hbHMsIGRlY19wb2ludCwgdGhvdXNhbmRzX3NlcCApIHtcbiAgbnVtYmVyID0gKCBudW1iZXIgKyAnJyApXG4gICAgLnJlcGxhY2UoIC9bXjAtOStcXC1FZS5dL2csICcnICk7XG4gIHZhciBuID0gISBpc0Zpbml0ZSggK251bWJlciApID8gMCA6ICtudW1iZXIsXG4gICAgcHJlYyA9ICEgaXNGaW5pdGUoICtkZWNpbWFscyApID8gMCA6IE1hdGguYWJzKCBkZWNpbWFscyApLFxuICAgIHNlcCA9ICggdHlwZW9mIHRob3VzYW5kc19zZXAgPT09ICd1bmRlZmluZWQnICkgPyAnLCcgOiB0aG91c2FuZHNfc2VwLFxuICAgIGRlYyA9ICggdHlwZW9mIGRlY19wb2ludCA9PT0gJ3VuZGVmaW5lZCcgKSA/ICcuJyA6IGRlY19wb2ludCxcbiAgICBzID0gJycsXG4gICAgdG9GaXhlZEZpeCA9IGZ1bmN0aW9uKCBuLCBwcmVjICkge1xuICAgICAgdmFyIGsgPSBNYXRoLnBvdyggMTAsIHByZWMgKTtcbiAgICAgIHJldHVybiAnJyArICggTWF0aC5yb3VuZCggbiAqIGsgKSAvIGsgKVxuICAgICAgICAgIC50b0ZpeGVkKCBwcmVjICk7XG4gICAgfTtcbiAgLy8gRml4IGZvciBJRSBwYXJzZUZsb2F0KDAuNTUpLnRvRml4ZWQoMCkgPSAwO1xuICBzID0gKCBwcmVjID8gdG9GaXhlZEZpeCggbiwgcHJlYyApIDogJycgKyBNYXRoLnJvdW5kKCBuICkgKVxuICAgIC5zcGxpdCggJy4nICk7XG4gIGlmICggc1sgMCBdLmxlbmd0aCA+IDMgKSB7XG4gICAgc1sgMCBdID0gc1sgMCBdLnJlcGxhY2UoIC9cXEIoPz0oPzpcXGR7M30pKyg/IVxcZCkpL2csIHNlcCApO1xuICB9XG4gIGlmICggKCBzWyAxIF0gfHwgJycgKVxuICAgICAgICAubGVuZ3RoIDwgcHJlYyApIHtcbiAgICBzWyAxIF0gPSBzWyAxIF0gfHwgJyc7XG4gICAgc1sgMSBdICs9IG5ldyBBcnJheSggcHJlYyAtIHNbIDEgXS5sZW5ndGggKyAxIClcbiAgICAgIC5qb2luKCAnMCcgKTtcbiAgfVxuICByZXR1cm4gcy5qb2luKCBkZWMgKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBudW1iZXJfZm9ybWF0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaTE4bi13cC1wbHVnaW4vbGliL251bWJlci1mb3JtYXQuanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwidmFyIFJlYWN0ID0gcmVxdWlyZSggJ3JlYWN0JyApLFxuXHRhc3NpZ24gPSByZXF1aXJlKCAnbG9kYXNoLmFzc2lnbicgKSxcblx0Y3JlYXRlQ2xhc3MgPSByZXF1aXJlKCAnY3JlYXRlLXJlYWN0LWNsYXNzJyApO1xuXG4vKipcbiAqIExvY2FsaXplIGEgUmVhY3QgY29tcG9uZW50XG4gKiBAcGFyYW0gQ29tcG9zZWRDb21wb25lbnRcbiAqIEByZXR1cm5zIEEgbmV3IExvY2FsaXplZCBSZWFjdCBDb21wb25lbnRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggaTE4biApIHtcblx0dmFyIGkxOG5Qcm9wcyA9IHtcblx0XHRudW1iZXJGb3JtYXQ6IGkxOG4ubnVtYmVyRm9ybWF0LmJpbmQoIGkxOG4gKSxcblx0XHR0cmFuc2xhdGU6IGkxOG4udHJhbnNsYXRlLmJpbmQoIGkxOG4gKVxuXHR9O1xuXG5cdHJldHVybiBmdW5jdGlvbiggQ29tcG9zZWRDb21wb25lbnQgKSB7XG5cdFx0dmFyIGNvbXBvbmVudE5hbWUgPSBDb21wb3NlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb3NlZENvbXBvbmVudC5uYW1lIHx8ICcnO1xuXG5cdFx0dmFyIGNvbXBvbmVudCA9IGNyZWF0ZUNsYXNzKHtcblx0XHRcdGRpc3BsYXlOYW1lOiAnTG9jYWxpemVkKCcgKyBjb21wb25lbnROYW1lICsgJyknLFxuXG5cdFx0XHRjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuYm91bmRGb3JjZVVwZGF0ZSA9IHRoaXMuZm9yY2VVcGRhdGUuYmluZCggdGhpcyApO1xuXHRcdFx0XHRpMThuLnN0YXRlT2JzZXJ2ZXIuYWRkTGlzdGVuZXIoICdjaGFuZ2UnLCB0aGlzLmJvdW5kRm9yY2VVcGRhdGUgKTtcblx0XHRcdH0sXG5cblx0XHRcdGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gaW4gc29tZSBjYXNlcywgY29tcG9uZW50V2lsbFVubW91bnQgaXMgY2FsbGVkIGJlZm9yZSBjb21wb25lbnREaWRNb3VudFxuXHRcdFx0XHQvLyBTdXBwb3NlZGx5IGZpeGVkIGluIFJlYWN0IDE1LjEuMDogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yNDEwXG5cdFx0XHRcdGlmICggdGhpcy5ib3VuZEZvcmNlVXBkYXRlICkge1xuXHRcdFx0XHRcdGkxOG4uc3RhdGVPYnNlcnZlci5yZW1vdmVMaXN0ZW5lciggJ2NoYW5nZScsIHRoaXMuYm91bmRGb3JjZVVwZGF0ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcHJvcHMgPSBhc3NpZ24oIHt9LCB0aGlzLnByb3BzLCBpMThuUHJvcHMgKTtcblx0XHRcdFx0cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoIENvbXBvc2VkQ29tcG9uZW50LCBwcm9wcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRjb21wb25lbnQuX2NvbXBvc2VkQ29tcG9uZW50ID0gQ29tcG9zZWRDb21wb25lbnQ7XG5cdFx0cmV0dXJuIGNvbXBvbmVudDtcblx0fTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pMThuLXdwLXBsdWdpbi9saWIvbG9jYWxpemUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGZhY3RvcnkgPSByZXF1aXJlKCcuL2ZhY3RvcnknKTtcblxuaWYgKHR5cGVvZiBSZWFjdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdGhyb3cgRXJyb3IoXG4gICAgJ2NyZWF0ZS1yZWFjdC1jbGFzcyBjb3VsZCBub3QgZmluZCB0aGUgUmVhY3Qgb2JqZWN0LiBJZiB5b3UgYXJlIHVzaW5nIHNjcmlwdCB0YWdzLCAnICtcbiAgICAgICdtYWtlIHN1cmUgdGhhdCBSZWFjdCBpcyBiZWluZyBsb2FkZWQgYmVmb3JlIGNyZWF0ZS1yZWFjdC1jbGFzcy4nXG4gICk7XG59XG5cbi8vIEhhY2sgdG8gZ3JhYiBOb29wVXBkYXRlUXVldWUgZnJvbSBpc29tb3JwaGljIFJlYWN0XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSBuZXcgUmVhY3QuQ29tcG9uZW50KCkudXBkYXRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICBSZWFjdC5Db21wb25lbnQsXG4gIFJlYWN0LmlzVmFsaWRFbGVtZW50LFxuICBSZWFjdE5vb3BVcGRhdGVRdWV1ZVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1yZWFjdC1jbGFzcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG59XG5cbnZhciBNSVhJTlNfS0VZID0gJ21peGlucyc7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBhbGxvdyB0aGUgY3JlYXRpb24gb2YgYW5vbnltb3VzIGZ1bmN0aW9ucyB3aGljaCBkbyBub3Rcbi8vIGhhdmUgLm5hbWUgc2V0IHRvIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSBiZWluZyBhc3NpZ25lZCB0by5cbmZ1bmN0aW9uIGlkZW50aXR5KGZuKSB7XG4gIHJldHVybiBmbjtcbn1cblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7XG4gICAgcHJvcDogJ3Byb3AnLFxuICAgIGNvbnRleHQ6ICdjb250ZXh0JyxcbiAgICBjaGlsZENvbnRleHQ6ICdjaGlsZCBjb250ZXh0J1xuICB9O1xufSBlbHNlIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7fTtcbn1cblxuZnVuY3Rpb24gZmFjdG9yeShSZWFjdENvbXBvbmVudCwgaXNWYWxpZEVsZW1lbnQsIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlKSB7XG4gIC8qKlxuICAgKiBQb2xpY2llcyB0aGF0IGRlc2NyaWJlIG1ldGhvZHMgaW4gYFJlYWN0Q2xhc3NJbnRlcmZhY2VgLlxuICAgKi9cblxuICB2YXIgaW5qZWN0ZWRNaXhpbnMgPSBbXTtcblxuICAvKipcbiAgICogQ29tcG9zaXRlIGNvbXBvbmVudHMgYXJlIGhpZ2hlci1sZXZlbCBjb21wb25lbnRzIHRoYXQgY29tcG9zZSBvdGhlciBjb21wb3NpdGVcbiAgICogb3IgaG9zdCBjb21wb25lbnRzLlxuICAgKlxuICAgKiBUbyBjcmVhdGUgYSBuZXcgdHlwZSBvZiBgUmVhY3RDbGFzc2AsIHBhc3MgYSBzcGVjaWZpY2F0aW9uIG9mXG4gICAqIHlvdXIgbmV3IGNsYXNzIHRvIGBSZWFjdC5jcmVhdGVDbGFzc2AuIFRoZSBvbmx5IHJlcXVpcmVtZW50IG9mIHlvdXIgY2xhc3NcbiAgICogc3BlY2lmaWNhdGlvbiBpcyB0aGF0IHlvdSBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuXG4gICAqXG4gICAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICogICAgICAgcmV0dXJuIDxkaXY+SGVsbG8gV29ybGQ8L2Rpdj47XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIFRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIHN1cHBvcnRzIGEgc3BlY2lmaWMgcHJvdG9jb2wgb2YgbWV0aG9kcyB0aGF0IGhhdmVcbiAgICogc3BlY2lhbCBtZWFuaW5nIChlLmcuIGByZW5kZXJgKS4gU2VlIGBSZWFjdENsYXNzSW50ZXJmYWNlYCBmb3JcbiAgICogbW9yZSB0aGUgY29tcHJlaGVuc2l2ZSBwcm90b2NvbC4gQW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlXG4gICAqIGNsYXNzIHNwZWNpZmljYXRpb24gd2lsbCBiZSBhdmFpbGFibGUgb24gdGhlIHByb3RvdHlwZS5cbiAgICpcbiAgICogQGludGVyZmFjZSBSZWFjdENsYXNzSW50ZXJmYWNlXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdmFyIFJlYWN0Q2xhc3NJbnRlcmZhY2UgPSB7XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgTWl4aW4gb2JqZWN0cyB0byBpbmNsdWRlIHdoZW4gZGVmaW5pbmcgeW91ciBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7YXJyYXl9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgbWl4aW5zOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0aGF0IHNob3VsZCBiZSBkZWZpbmVkIG9uXG4gICAgICogdGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgaXRzIHByb3RvdHlwZSAoc3RhdGljIG1ldGhvZHMpLlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBzdGF0aWNzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5pdGlvbiBvZiBwcm9wIHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgcHJvcFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29udGV4dFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIHRoaXMgY29tcG9uZW50IHNldHMgZm9yIGl0cyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY2hpbGRDb250ZXh0VHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvLyA9PT09IERlZmluaXRpb24gbWV0aG9kcyA9PT09XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBWYWx1ZXMgaW4gdGhlIG1hcHBpbmcgd2lsbCBiZSBzZXQgb25cbiAgICAgKiBgdGhpcy5wcm9wc2AgaWYgdGhhdCBwcm9wIGlzIG5vdCBzcGVjaWZpZWQgKGkuZS4gdXNpbmcgYW4gYGluYCBjaGVjaykuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGJlZm9yZSBgZ2V0SW5pdGlhbFN0YXRlYCBhbmQgdGhlcmVmb3JlIGNhbm5vdCByZWx5XG4gICAgICogb24gYHRoaXMuc3RhdGVgIG9yIHVzZSBgdGhpcy5zZXRTdGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFByb3BzOiAnREVGSU5FX01BTllfTUVSR0VEJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgICAqIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIGB0aGlzLnN0YXRlYC5cbiAgICAgKlxuICAgICAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgcmV0dXJuIHtcbiAgICAgKiAgICAgICBpc09uOiBmYWxzZSxcbiAgICAgKiAgICAgICBmb29CYXo6IG5ldyBCYXpGb28oKVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiAnREVGSU5FX01BTllfTUVSR0VEJyxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBnZXRDaGlsZENvbnRleHQ6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gICAgLyoqXG4gICAgICogVXNlcyBwcm9wcyBmcm9tIGB0aGlzLnByb3BzYCBhbmQgc3RhdGUgZnJvbSBgdGhpcy5zdGF0ZWAgdG8gcmVuZGVyIHRoZVxuICAgICAqIHN0cnVjdHVyZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogTm8gZ3VhcmFudGVlcyBhcmUgbWFkZSBhYm91dCB3aGVuIG9yIGhvdyBvZnRlbiB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLCBzb1xuICAgICAqIGl0IG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLlxuICAgICAqXG4gICAgICogICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICAgKiAgICAgcmV0dXJuIDxkaXY+SGVsbG8sIHtuYW1lfSE8L2Rpdj47XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAgICAgKiBAcmVxdWlyZWRcbiAgICAgKi9cbiAgICByZW5kZXI6ICdERUZJTkVfT05DRScsXG5cbiAgICAvLyA9PT09IERlbGVnYXRlIG1ldGhvZHMgPT09PVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGx5IGNyZWF0ZWQgYW5kIGFib3V0IHRvIGJlIG1vdW50ZWQuXG4gICAgICogVGhpcyBtYXkgaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBhbnkgZXh0ZXJuYWwgc3Vic2NyaXB0aW9ucyBvciBkYXRhIGNyZWF0ZWRcbiAgICAgKiBieSB0aGlzIG1ldGhvZCBtdXN0IGJlIGNsZWFuZWQgdXAgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YC5cbiAgICAgKlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgYW5kIGhhcyBhIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBIb3dldmVyLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgRE9NIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICAgKiBiZWVuIG1vdW50ZWQgKGluaXRpYWxpemVkIGFuZCByZW5kZXJlZCkgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVhY3QgdG8gYSBwcm9wIHRyYW5zaXRpb24gYnkgdXBkYXRpbmcgdGhlXG4gICAgICogc3RhdGUgdXNpbmcgYHRoaXMuc2V0U3RhdGVgLiBDdXJyZW50IHByb3BzIGFyZSBhY2Nlc3NlZCB2aWEgYHRoaXMucHJvcHNgLlxuICAgICAqXG4gICAgICogICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAgICogICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAqICAgICAgIGxpa2VzSW5jcmVhc2luZzogbmV4dFByb3BzLmxpa2VDb3VudCA+IHRoaXMucHJvcHMubGlrZUNvdW50XG4gICAgICogICAgIH0pO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogTk9URTogVGhlcmUgaXMgbm8gZXF1aXZhbGVudCBgY29tcG9uZW50V2lsbFJlY2VpdmVTdGF0ZWAuIEFuIGluY29taW5nIHByb3BcbiAgICAgKiB0cmFuc2l0aW9uIG1heSBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgYnV0IHRoZSBvcHBvc2l0ZSBpcyBub3QgdHJ1ZS4gSWYgeW91XG4gICAgICogbmVlZCBpdCwgeW91IGFyZSBwcm9iYWJseSBsb29raW5nIGZvciBgY29tcG9uZW50V2lsbFVwZGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hpbGUgZGVjaWRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZlxuICAgICAqIHJlY2VpdmluZyBuZXcgcHJvcHMsIHN0YXRlIGFuZC9vciBjb250ZXh0LlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gYHJldHVybiBmYWxzZWAgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHRoZVxuICAgICAqIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcy9zdGF0ZS9jb250ZXh0IHdpbGwgbm90IHJlcXVpcmUgYSBjb21wb25lbnRcbiAgICAgKiB1cGRhdGUuXG4gICAgICpcbiAgICAgKiAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAgICogICAgIHJldHVybiAhZXF1YWwobmV4dFByb3BzLCB0aGlzLnByb3BzKSB8fFxuICAgICAqICAgICAgICFlcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpIHx8XG4gICAgICogICAgICAgIWVxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgdXBkYXRlLlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogJ0RFRklORV9PTkNFJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIHVwZGF0ZSBkdWUgdG8gYSB0cmFuc2l0aW9uIGZyb21cbiAgICAgKiBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAgdG8gYG5leHRQcm9wc2AsIGBuZXh0U3RhdGVgXG4gICAgICogYW5kIGBuZXh0Q29udGV4dGAuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBwZXJmb3JtIHByZXBhcmF0aW9uIGJlZm9yZSBhbiB1cGRhdGUgb2NjdXJzLlxuICAgICAqXG4gICAgICogTk9URTogWW91ICoqY2Fubm90KiogdXNlIGB0aGlzLnNldFN0YXRlKClgIGluIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQncyBET00gcmVwcmVzZW50YXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAgICogYmVlbiB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByZXZQcm9wc1xuICAgICAqIEBwYXJhbSB7P29iamVjdH0gcHJldlN0YXRlXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q29udGV4dFxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50RGlkVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgYW5kIGhhdmVcbiAgICAgKiBpdHMgRE9NIHJlcHJlc2VudGF0aW9uIGRlc3Ryb3llZC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGRlYWxsb2NhdGUgYW55IGV4dGVybmFsIHJlc291cmNlcy5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoZXJlIGlzIG5vIGBjb21wb25lbnREaWRVbm1vdW50YCBzaW5jZSB5b3VyIGNvbXBvbmVudCB3aWxsIGhhdmUgYmVlblxuICAgICAqIGRlc3Ryb3llZCBieSB0aGF0IHBvaW50LlxuICAgICAqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlbWVudCBmb3IgKGRlcHJlY2F0ZWQpIGBjb21wb25lbnRXaWxsTW91bnRgLlxuICAgICAqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VtZW50IGZvciAoZGVwcmVjYXRlZCkgYGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNgLlxuICAgICAqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlbWVudCBmb3IgKGRlcHJlY2F0ZWQpIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gICAgLy8gPT09PSBBZHZhbmNlZCBtZXRob2RzID09PT1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGN1cnJlbnRseSBtb3VudGVkIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBvdmVycmlkYWJsZVxuICAgICAqL1xuICAgIHVwZGF0ZUNvbXBvbmVudDogJ09WRVJSSURFX0JBU0UnXG4gIH07XG5cbiAgLyoqXG4gICAqIFNpbWlsYXIgdG8gUmVhY3RDbGFzc0ludGVyZmFjZSBidXQgZm9yIHN0YXRpYyBtZXRob2RzLlxuICAgKi9cbiAgdmFyIFJlYWN0Q2xhc3NTdGF0aWNJbnRlcmZhY2UgPSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBhZnRlciBhIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgYW5kIHdoZW4gaXRcbiAgICAgKiByZWNlaXZlcyBuZXcgcHJvcHMuIFJldHVybiBhbiBvYmplY3QgdG8gdXBkYXRlIHN0YXRlIGluIHJlc3BvbnNlIHRvXG4gICAgICogcHJvcCBjaGFuZ2VzLiBSZXR1cm4gbnVsbCB0byBpbmRpY2F0ZSBubyBjaGFuZ2UgdG8gc3RhdGUuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcmV0dXJuZWQsIGl0cyBrZXlzIHdpbGwgYmUgbWVyZ2VkIGludG8gdGhlIGV4aXN0aW5nIHN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7b2JqZWN0IHx8IG51bGx9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiAnREVGSU5FX01BTllfTUVSR0VEJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gICAqXG4gICAqIEFsdGhvdWdoIHRoZXNlIGFyZSBkZWNsYXJlZCBsaWtlIGluc3RhbmNlIHByb3BlcnRpZXMgaW4gdGhlIHNwZWNpZmljYXRpb25cbiAgICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICAgKiBhbmQgYXJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZS4gRGVzcGl0ZVxuICAgKiBiZWluZyBzdGF0aWMsIHRoZXkgbXVzdCBiZSBkZWZpbmVkIG91dHNpZGUgb2YgdGhlIFwic3RhdGljc1wiIGtleSB1bmRlclxuICAgKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gICAqL1xuICB2YXIgUkVTRVJWRURfU1BFQ19LRVlTID0ge1xuICAgIGRpc3BsYXlOYW1lOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgfSxcbiAgICBtaXhpbnM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBtaXhpbnMpIHtcbiAgICAgIGlmIChtaXhpbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgbWl4aW5zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcywgJ2NoaWxkQ29udGV4dCcpO1xuICAgICAgfVxuICAgICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBfYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsXG4gICAgICAgIGNoaWxkQ29udGV4dFR5cGVzXG4gICAgICApO1xuICAgIH0sXG4gICAgY29udGV4dFR5cGVzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcywgJ2NvbnRleHQnKTtcbiAgICAgIH1cbiAgICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IF9hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMsXG4gICAgICAgIGNvbnRleHRUeXBlc1xuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgICAqIGF1dG9tYXRpYyBtZXJnaW5nLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGdldERlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihcbiAgICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsXG4gICAgICAgICAgZ2V0RGVmYXVsdFByb3BzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHM7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wVHlwZXM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzLCAncHJvcCcpO1xuICAgICAgfVxuICAgICAgQ29uc3RydWN0b3IucHJvcFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IucHJvcFR5cGVzLCBwcm9wVHlwZXMpO1xuICAgIH0sXG4gICAgc3RhdGljczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICAgIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKTtcbiAgICB9LFxuICAgIGF1dG9iaW5kOiBmdW5jdGlvbigpIHt9XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHR5cGVEZWYpIHtcbiAgICAgIGlmICh0eXBlRGVmLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gX2ludmFyaWFudCBzbyBjb21wb25lbnRzXG4gICAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgb25seSBpbiBfX0RFVl9fXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgIHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgK1xuICAgICAgICAgICAgICAnUmVhY3QuUHJvcFR5cGVzLicsXG4gICAgICAgICAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsXG4gICAgICAgICAgICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sXG4gICAgICAgICAgICBwcm9wTmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpIHtcbiAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgID8gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXVxuICAgICAgOiBudWxsO1xuXG4gICAgLy8gRGlzYWxsb3cgb3ZlcnJpZGluZyBvZiBiYXNlIGNsYXNzIG1ldGhvZHMgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgICBpZiAoUmVhY3RDbGFzc01peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBfaW52YXJpYW50KFxuICAgICAgICBzcGVjUG9saWN5ID09PSAnT1ZFUlJJREVfQkFTRScsXG4gICAgICAgICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgJyArXG4gICAgICAgICAgJ2Alc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzICcgK1xuICAgICAgICAgICdkbyBub3Qgb3ZlcmxhcCB3aXRoIFJlYWN0IG1ldGhvZHMuJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEaXNhbGxvdyBkZWZpbmluZyBtZXRob2RzIG1vcmUgdGhhbiBvbmNlIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgIHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScgfHwgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcsXG4gICAgICAgICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgK1xuICAgICAgICAgICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgJyArXG4gICAgICAgICAgJ3RvIGEgbWl4aW4uJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWl4aW4gaGVscGVyIHdoaWNoIGhhbmRsZXMgcG9saWN5IHZhbGlkYXRpb24gYW5kIHJlc2VydmVkXG4gICAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzZXMuXG4gICAqL1xuICBmdW5jdGlvbiBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYykge1xuICAgIGlmICghc3BlYykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHR5cGVvZlNwZWMgPSB0eXBlb2Ygc3BlYztcbiAgICAgICAgdmFyIGlzTWl4aW5WYWxpZCA9IHR5cGVvZlNwZWMgPT09ICdvYmplY3QnICYmIHNwZWMgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgaXNNaXhpblZhbGlkLFxuICAgICAgICAgICAgXCIlczogWW91J3JlIGF0dGVtcHRpbmcgdG8gaW5jbHVkZSBhIG1peGluIHRoYXQgaXMgZWl0aGVyIG51bGwgXCIgK1xuICAgICAgICAgICAgICAnb3Igbm90IGFuIG9iamVjdC4gQ2hlY2sgdGhlIG1peGlucyBpbmNsdWRlZCBieSB0aGUgY29tcG9uZW50LCAnICtcbiAgICAgICAgICAgICAgJ2FzIHdlbGwgYXMgYW55IG1peGlucyB0aGV5IGluY2x1ZGUgdGhlbXNlbHZlcy4gJyArXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBvYmplY3QgYnV0IGdvdCAlcy4nLFxuICAgICAgICAgICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLFxuICAgICAgICAgICAgc3BlYyA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2ZTcGVjXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX2ludmFyaWFudChcbiAgICAgIHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nLFxuICAgICAgXCJSZWFjdENsYXNzOiBZb3UncmUgYXR0ZW1wdGluZyB0byBcIiArXG4gICAgICAgICd1c2UgYSBjb21wb25lbnQgY2xhc3Mgb3IgZnVuY3Rpb24gYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSAnICtcbiAgICAgICAgJ3JlZ3VsYXIgb2JqZWN0LidcbiAgICApO1xuICAgIF9pbnZhcmlhbnQoXG4gICAgICAhaXNWYWxpZEVsZW1lbnQoc3BlYyksXG4gICAgICBcIlJlYWN0Q2xhc3M6IFlvdSdyZSBhdHRlbXB0aW5nIHRvIFwiICtcbiAgICAgICAgJ3VzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LidcbiAgICApO1xuXG4gICAgdmFyIHByb3RvID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHZhciBhdXRvQmluZFBhaXJzID0gcHJvdG8uX19yZWFjdEF1dG9CaW5kUGFpcnM7XG5cbiAgICAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcbiAgICAvLyBjaGFpbmluZyBvcmRlciBpcyBhcHBsaWVkIHRvIG1ldGhvZHMgd2l0aCBERUZJTkVfTUFOWSBwb2xpY3ksIHdoZXRoZXJcbiAgICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cbiAgICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShNSVhJTlNfS0VZKSkge1xuICAgICAgUkVTRVJWRURfU1BFQ19LRVlTLm1peGlucyhDb25zdHJ1Y3Rvciwgc3BlYy5taXhpbnMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgICAgaWYgKCFzcGVjLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gTUlYSU5TX0tFWSkge1xuICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBtaXhpbnMgaW4gYSBzcGVjaWFsIGNhc2UgYWJvdmUuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xuICAgICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSk7XG5cbiAgICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgUkVTRVJWRURfU1BFQ19LRVlTW25hbWVdKENvbnN0cnVjdG9yLCBwcm9wZXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBtZW1iZXIgbWV0aG9kcyBzaG91bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgYm91bmQ6XG4gICAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q2xhc3MgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxuICAgICAgICAvLyAyLiBPdmVycmlkZGVuIG1ldGhvZHMgKHRoYXQgd2VyZSBtaXhlZCBpbikuXG4gICAgICAgIHZhciBpc1JlYWN0Q2xhc3NNZXRob2QgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID1cbiAgICAgICAgICBpc0Z1bmN0aW9uICYmXG4gICAgICAgICAgIWlzUmVhY3RDbGFzc01ldGhvZCAmJlxuICAgICAgICAgICFpc0FscmVhZHlEZWZpbmVkICYmXG4gICAgICAgICAgc3BlYy5hdXRvYmluZCAhPT0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNob3VsZEF1dG9CaW5kKSB7XG4gICAgICAgICAgYXV0b0JpbmRQYWlycy5wdXNoKG5hbWUsIHByb3BlcnR5KTtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07XG5cbiAgICAgICAgICAgIC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlLlxuICAgICAgICAgICAgX2ludmFyaWFudChcbiAgICAgICAgICAgICAgaXNSZWFjdENsYXNzTWV0aG9kICYmXG4gICAgICAgICAgICAgICAgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnIHx8XG4gICAgICAgICAgICAgICAgICBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknKSxcbiAgICAgICAgICAgICAgJ1JlYWN0Q2xhc3M6IFVuZXhwZWN0ZWQgc3BlYyBwb2xpY3kgJXMgZm9yIGtleSAlcyAnICtcbiAgICAgICAgICAgICAgICAnd2hlbiBtaXhpbmcgaW4gY29tcG9uZW50IHNwZWNzLicsXG4gICAgICAgICAgICAgIHNwZWNQb2xpY3ksXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEZvciBtZXRob2RzIHdoaWNoIGFyZSBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLCBjYWxsIHRoZSBleGlzdGluZ1xuICAgICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJykge1xuICAgICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gQWRkIHZlcmJvc2UgZGlzcGxheU5hbWUgdG8gdGhlIGZ1bmN0aW9uLCB3aGljaCBoZWxwcyB3aGVuIGxvb2tpbmdcbiAgICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgICBwcm90b1tuYW1lXS5kaXNwbGF5TmFtZSA9IHNwZWMuZGlzcGxheU5hbWUgKyAnXycgKyBuYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICBpZiAoIXN0YXRpY3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICAgIHZhciBwcm9wZXJ0eSA9IHN0YXRpY3NbbmFtZV07XG4gICAgICBpZiAoIXN0YXRpY3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc1Jlc2VydmVkID0gbmFtZSBpbiBSRVNFUlZFRF9TUEVDX0tFWVM7XG4gICAgICBfaW52YXJpYW50KFxuICAgICAgICAhaXNSZXNlcnZlZCxcbiAgICAgICAgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYSByZXNlcnZlZCAnICtcbiAgICAgICAgICAncHJvcGVydHksIGAlc2AsIHRoYXQgc2hvdWxkblxcJ3QgYmUgb24gdGhlIFwic3RhdGljc1wiIGtleS4gRGVmaW5lIGl0ICcgK1xuICAgICAgICAgICdhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBpbnN0ZWFkOyBpdCB3aWxsIHN0aWxsIGJlIGFjY2Vzc2libGUgb24gdGhlICcgK1xuICAgICAgICAgICdjb25zdHJ1Y3Rvci4nLFxuICAgICAgICBuYW1lXG4gICAgICApO1xuXG4gICAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IG5hbWUgaW4gQ29uc3RydWN0b3I7XG4gICAgICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NTdGF0aWNJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICA/IFJlYWN0Q2xhc3NTdGF0aWNJbnRlcmZhY2VbbmFtZV1cbiAgICAgICAgICA6IG51bGw7XG5cbiAgICAgICAgX2ludmFyaWFudChcbiAgICAgICAgICBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJyxcbiAgICAgICAgICAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSAnICtcbiAgICAgICAgICAgICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSAnICtcbiAgICAgICAgICAgICdkdWUgdG8gYSBtaXhpbi4nLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgKTtcblxuICAgICAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKENvbnN0cnVjdG9yW25hbWVdLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IHByb3BlcnR5O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSB0d28gb2JqZWN0cywgYnV0IHRocm93IGlmIGJvdGggY29udGFpbiB0aGUgc2FtZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvbmUgVGhlIGZpcnN0IG9iamVjdCwgd2hpY2ggaXMgbXV0YXRlZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHR3byBUaGUgc2Vjb25kIG9iamVjdFxuICAgKiBAcmV0dXJuIHtvYmplY3R9IG9uZSBhZnRlciBpdCBoYXMgYmVlbiBtdXRhdGVkIHRvIGNvbnRhaW4gZXZlcnl0aGluZyBpbiB0d28uXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKG9uZSwgdHdvKSB7XG4gICAgX2ludmFyaWFudChcbiAgICAgIG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcsXG4gICAgICAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBDYW5ub3QgbWVyZ2Ugbm9uLW9iamVjdHMuJ1xuICAgICk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdHdvKSB7XG4gICAgICBpZiAodHdvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgX2ludmFyaWFudChcbiAgICAgICAgICBvbmVba2V5XSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6ICcgK1xuICAgICAgICAgICAgJ1RyaWVkIHRvIG1lcmdlIHR3byBvYmplY3RzIHdpdGggdGhlIHNhbWUga2V5OiBgJXNgLiBUaGlzIGNvbmZsaWN0ICcgK1xuICAgICAgICAgICAgJ21heSBiZSBkdWUgdG8gYSBtaXhpbjsgaW4gcGFydGljdWxhciwgdGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHR3byAnICtcbiAgICAgICAgICAgICdnZXRJbml0aWFsU3RhdGUoKSBvciBnZXREZWZhdWx0UHJvcHMoKSBtZXRob2RzIHJldHVybmluZyBvYmplY3RzICcgK1xuICAgICAgICAgICAgJ3dpdGggY2xhc2hpbmcga2V5cy4nLFxuICAgICAgICAgIGtleVxuICAgICAgICApO1xuICAgICAgICBvbmVba2V5XSA9IHR3b1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb25lO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgbWVyZ2VzIHRoZWlyIHJldHVybiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ob25lLCB0d28pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkUmVzdWx0KCkge1xuICAgICAgdmFyIGEgPSBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHZhciBiID0gdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG4gICAgICB2YXIgYyA9IHt9O1xuICAgICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBhKTtcbiAgICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYik7XG4gICAgICByZXR1cm4gYztcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgaWdub3JlcyB0aGVpciByZXR1cm4gdmFsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICAgIG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgYm91bmQgbWV0aG9kLlxuICAgKi9cbiAgZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XG4gICAgdmFyIGJvdW5kTWV0aG9kID0gbWV0aG9kLmJpbmQoY29tcG9uZW50KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IG51bGw7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICAgIHZhciBfYmluZCA9IGJvdW5kTWV0aG9kLmJpbmQ7XG4gICAgICBib3VuZE1ldGhvZC5iaW5kID0gZnVuY3Rpb24obmV3VGhpcykge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksXG4gICAgICAgICAgICBfa2V5ID0gMTtcbiAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICBfa2V5KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxuICAgICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgICAgLy8gbGV0J3Mgd2Fybi5cbiAgICAgICAgaWYgKG5ld1RoaXMgIT09IGNvbXBvbmVudCAmJiBuZXdUaGlzICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAnYmluZCgpOiBSZWFjdCBjb21wb25lbnQgbWV0aG9kcyBtYXkgb25seSBiZSBib3VuZCB0byB0aGUgJyArXG4gICAgICAgICAgICAgICAgJ2NvbXBvbmVudCBpbnN0YW5jZS4gU2VlICVzJyxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAnYmluZCgpOiBZb3UgYXJlIGJpbmRpbmcgYSBjb21wb25lbnQgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuICcgK1xuICAgICAgICAgICAgICAgICdSZWFjdCBkb2VzIHRoaXMgZm9yIHlvdSBhdXRvbWF0aWNhbGx5IGluIGEgaGlnaC1wZXJmb3JtYW5jZSAnICtcbiAgICAgICAgICAgICAgICAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuICAgICAgICByZXR1cm4gcmVib3VuZE1ldGhvZDtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBhbGwgYXV0by1ib3VuZCBtZXRob2RzIGluIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gICAqL1xuICBmdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2RzKGNvbXBvbmVudCkge1xuICAgIHZhciBwYWlycyA9IGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2YXIgYXV0b0JpbmRLZXkgPSBwYWlyc1tpXTtcbiAgICAgIHZhciBtZXRob2QgPSBwYWlyc1tpICsgMV07XG4gICAgICBjb21wb25lbnRbYXV0b0JpbmRLZXldID0gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKTtcbiAgICB9XG4gIH1cblxuICB2YXIgSXNNb3VudGVkUHJlTWl4aW4gPSB7XG4gICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fX2lzTW91bnRlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIHZhciBJc01vdW50ZWRQb3N0TWl4aW4gPSB7XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIG1vcmUgdG8gdGhlIFJlYWN0Q2xhc3MgYmFzZSBjbGFzcy4gVGhlc2UgYXJlIGFsbCBsZWdhY3kgZmVhdHVyZXMgYW5kXG4gICAqIHRoZXJlZm9yZSBub3QgYWxyZWFkeSBwYXJ0IG9mIHRoZSBtb2Rlcm4gUmVhY3RDb21wb25lbnQuXG4gICAqL1xuICB2YXIgUmVhY3RDbGFzc01peGluID0ge1xuICAgIC8qKlxuICAgICAqIFRPRE86IFRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGJlY2F1c2Ugc3RhdGUgc2hvdWxkIGFsd2F5cyBrZWVwIGEgY29uc2lzdGVudFxuICAgICAqIHR5cGUgc2lnbmF0dXJlIGFuZCB0aGUgb25seSB1c2UgY2FzZSBmb3IgdGhpcywgaXMgdG8gYXZvaWQgdGhhdC5cbiAgICAgKi9cbiAgICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uKG5ld1N0YXRlLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUodGhpcywgbmV3U3RhdGUsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAZmluYWxcbiAgICAgKi9cbiAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICB0aGlzLl9fZGlkV2FybklzTW91bnRlZCxcbiAgICAgICAgICAnJXM6IGlzTW91bnRlZCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgJyArXG4gICAgICAgICAgICAnc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiBjb21wb25lbnRXaWxsVW5tb3VudCB0byAnICtcbiAgICAgICAgICAgICdwcmV2ZW50IG1lbW9yeSBsZWFrcy4nLFxuICAgICAgICAgICh0aGlzLmNvbnN0cnVjdG9yICYmIHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWUpIHx8XG4gICAgICAgICAgICB0aGlzLm5hbWUgfHxcbiAgICAgICAgICAgICdDb21wb25lbnQnXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX19kaWRXYXJuSXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIXRoaXMuX19pc01vdW50ZWQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBSZWFjdENsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24oKSB7fTtcbiAgX2Fzc2lnbihcbiAgICBSZWFjdENsYXNzQ29tcG9uZW50LnByb3RvdHlwZSxcbiAgICBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsXG4gICAgUmVhY3RDbGFzc01peGluXG4gICk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgY29tcG9uZW50IGNsYXNzIGdpdmVuIGEgY2xhc3Mgc3BlY2lmaWNhdGlvbi5cbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzcGVjIENsYXNzIHNwZWNpZmljYXRpb24gKHdoaWNoIG11c3QgZGVmaW5lIGByZW5kZXJgKS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IENvbXBvbmVudCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2xhc3Moc3BlYykge1xuICAgIC8vIFRvIGtlZXAgb3VyIHdhcm5pbmdzIG1vcmUgdW5kZXJzdGFuZGFibGUsIHdlJ2xsIHVzZSBhIGxpdHRsZSBoYWNrIGhlcmUgdG9cbiAgICAvLyBlbnN1cmUgdGhhdCBDb25zdHJ1Y3Rvci5uYW1lICE9PSAnQ29uc3RydWN0b3InLiBUaGlzIG1ha2VzIHN1cmUgd2UgZG9uJ3RcbiAgICAvLyB1bm5lY2Vzc2FyaWx5IGlkZW50aWZ5IGEgY2xhc3Mgd2l0aG91dCBkaXNwbGF5TmFtZSBhcyAnQ29uc3RydWN0b3InLlxuICAgIHZhciBDb25zdHJ1Y3RvciA9IGlkZW50aXR5KGZ1bmN0aW9uKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICAvLyBUaGlzIGNvbnN0cnVjdG9yIGdldHMgb3ZlcnJpZGRlbiBieSBtb2Nrcy4gVGhlIGFyZ3VtZW50IGlzIHVzZWRcbiAgICAgIC8vIGJ5IG1vY2tzIHRvIGFzc2VydCBvbiB3aGF0IGdldHMgbW91bnRlZC5cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICB0aGlzIGluc3RhbmNlb2YgQ29uc3RydWN0b3IsXG4gICAgICAgICAgJ1NvbWV0aGluZyBpcyBjYWxsaW5nIGEgUmVhY3QgY29tcG9uZW50IGRpcmVjdGx5LiBVc2UgYSBmYWN0b3J5IG9yICcgK1xuICAgICAgICAgICAgJ0pTWCBpbnN0ZWFkLiBTZWU6IGh0dHBzOi8vZmIubWUvcmVhY3QtbGVnYWN5ZmFjdG9yeSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2lyZSB1cCBhdXRvLWJpbmRpbmdcbiAgICAgIGlmICh0aGlzLl9fcmVhY3RBdXRvQmluZFBhaXJzLmxlbmd0aCkge1xuICAgICAgICBiaW5kQXV0b0JpbmRNZXRob2RzKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG4gICAgICB0aGlzLnN0YXRlID0gbnVsbDtcblxuICAgICAgLy8gUmVhY3RDbGFzc2VzIGRvZXNuJ3QgaGF2ZSBjb25zdHJ1Y3RvcnMuIEluc3RlYWQsIHRoZXkgdXNlIHRoZVxuICAgICAgLy8gZ2V0SW5pdGlhbFN0YXRlIGFuZCBjb21wb25lbnRXaWxsTW91bnQgbWV0aG9kcyBmb3IgaW5pdGlhbGl6YXRpb24uXG5cbiAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSA/IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkgOiBudWxsO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIHRoaXMuZ2V0SW5pdGlhbFN0YXRlLl9pc01vY2tGdW5jdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX2ludmFyaWFudChcbiAgICAgICAgdHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSxcbiAgICAgICAgJyVzLmdldEluaXRpYWxTdGF0ZSgpOiBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgbnVsbCcsXG4gICAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgfSk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3IFJlYWN0Q2xhc3NDb21wb25lbnQoKTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX19yZWFjdEF1dG9CaW5kUGFpcnMgPSBbXTtcblxuICAgIGluamVjdGVkTWl4aW5zLmZvckVhY2gobWl4U3BlY0ludG9Db21wb25lbnQuYmluZChudWxsLCBDb25zdHJ1Y3RvcikpO1xuXG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIElzTW91bnRlZFByZU1peGluKTtcbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYyk7XG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIElzTW91bnRlZFBvc3RNaXhpbik7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0UHJvcHMgcHJvcGVydHkgYWZ0ZXIgYWxsIG1peGlucyBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcyA9IENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcygpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZSBvZiB0aGVzZSBtZXRob2QgbmFtZXMgaXMgb2ssXG4gICAgICAvLyBzaW5jZSBpdCdzIHVzZWQgd2l0aCBjcmVhdGVDbGFzcy4gSWYgaXQncyBub3QsIHRoZW4gaXQncyBsaWtlbHkgYVxuICAgICAgLy8gbWlzdGFrZSBzbyB3ZSdsbCB3YXJuIHlvdSB0byB1c2UgdGhlIHN0YXRpYyBwcm9wZXJ0eSwgcHJvcGVydHlcbiAgICAgIC8vIGluaXRpYWxpemVyIG9yIGNvbnN0cnVjdG9yIHJlc3BlY3RpdmVseS5cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2ludmFyaWFudChcbiAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIsXG4gICAgICAnY3JlYXRlQ2xhc3MoLi4uKTogQ2xhc3Mgc3BlY2lmaWNhdGlvbiBtdXN0IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC4nXG4gICAgKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSxcbiAgICAgICAgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArXG4gICAgICAgICAgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgK1xuICAgICAgICAgICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArXG4gICAgICAgICAgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsXG4gICAgICAgIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50J1xuICAgICAgKTtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgICFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyxcbiAgICAgICAgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArXG4gICAgICAgICAgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLFxuICAgICAgICBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCdcbiAgICAgICk7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLFxuICAgICAgICAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiAnICtcbiAgICAgICAgICAnRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JyxcbiAgICAgICAgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlQ2xhc3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1yZWFjdC1jbGFzcy9mYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGVQaWNrZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cblx0XHR0aGlzLnVwZGF0ZVZhbHVlID0gdGhpcy51cGRhdGVWYWx1ZS5iaW5kKCB0aGlzICk7XG5cdFx0Ly8gUHJvcGVyeSB0byBzZXQgaWYgZGF0ZUZvcm1hdCBoYXMgd29yZHMgaW4gaXQgbGlrZSBtb250aCBuYW1lc1xuXHRcdHRoaXMuaGFzV29yZEZvcm1hdCA9IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuaGFzV29yZEZvcm1hdCApID8gZmFsc2UgOiB0aGlzLnByb3BzLmhhc1dvcmRGb3JtYXQ7XG5cdH1cblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLiRlbCA9IGpRdWVyeSggdGhpcy5lbCApO1xuXG5cdFx0bGV0IHZhbHVlID0gXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdIClcblx0XHRcdD8gdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWVcblx0XHRcdDogdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdO1xuXHRcdGNvbnN0IGRhdGVGb3JtYXQgPSB0aGlzLnByb3BzLmRhdGVGb3JtYXQgPyB0aGlzLnByb3BzLmRhdGVGb3JtYXQgOiAnZCBNTSB5eSc7XG5cdFx0Y29uc3QgaW5wdXRJZCA9IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuaWQgKVxuXHRcdFx0PyBgZm9ybWluYXRvci1maWVsZC0keyB0aGlzLnByb3BzLnByb3BlcnR5IH1gXG5cdFx0XHQ6IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHRoaXMucHJvcHMuaWQgfWA7XG5cblx0XHRpZiAoICEgdGhpcy5oYXNXb3JkRm9ybWF0ICkge1xuXHRcdFx0dGhpcy4kZWwudmFsKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdHRoaXMuJGVsLmRhdGVwaWNrZXIoIHtcblx0XHRcdGJlZm9yZVNob3c6ICggaW5wdXQsIGluc3QgKSA9PiB7XG5cdFx0XHRcdGpRdWVyeSggJyN1aS1kYXRlcGlja2VyLWRpdicgKS5hZGRDbGFzcyggJ3N1aS1jYWxlbmRhcicgKTtcblx0XHRcdFx0aWYgKCAnZm9ybWluYXRvci1maWVsZC1kYXRlJyA9PT0gdGhpcy4kZWwuYXR0ciggJ2lkJyApICkge1xuXHRcdFx0XHRcdGlmICggJ2Rpc2FibGUnID09PSB0aGlzLnByb3BzLnN0YXRlLnBhc3RfZGF0ZXMgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLiRlbC5kYXRlcGlja2VyKCAnb3B0aW9uJywgJ21pbkRhdGUnLCB0aGlzLiRlbC5kYXRlcGlja2VyKCAnZ2V0RGF0ZScgKSApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICdlbmFibGUnID09PSB0aGlzLnByb3BzLnN0YXRlLnBhc3RfZGF0ZXMgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLiRlbC5kYXRlcGlja2VyKCAnb3B0aW9uJywgJ21pbkRhdGUnLCBudWxsICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGF0ZUZvcm1hdDogZGF0ZUZvcm1hdCxcblx0XHRcdGRheU5hbWVzTWluOiBmb3JtaW5hdG9ybDEwbi5jYWxlbmRhci5kYXlfbmFtZXNfbWluLFxuXHRcdFx0bW9udGhOYW1lczogZm9ybWluYXRvcmwxMG4uY2FsZW5kYXIubW9udGhfbmFtZXMsXG5cdFx0XHRvblNlbGVjdDogZGF0ZSA9PiB7XG5cdFx0XHRcdHRoaXMudXBkYXRlVmFsdWUoIGRhdGUgKTtcblx0XHRcdH0sXG5cdFx0fSApO1xuXG5cdFx0aWYgKCB0aGlzLmhhc1dvcmRGb3JtYXQgKSB7XG5cdFx0XHR0aGlzLiRlbC5kYXRlcGlja2VyKCAnb3B0aW9uJywgJ2FsdEZpZWxkJywgJyMnICtcdGlucHV0SWQgKyAnLWFsdGZpZWxkJyApO1xuXHRcdFx0dGhpcy4kZWwuZGF0ZXBpY2tlciggJ29wdGlvbicsICdhbHRGb3JtYXQnLCAnQCcgKTtcblxuXHRcdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIHZhbHVlICkgKSB7XG5cdFx0XHRcdGlmICggaXNOYU4oIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBuZXcgRGF0ZSggdmFsdWUgKS5nZXRUaW1lKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRqUXVlcnkoICcjJyArIGlucHV0SWQgKyAnLWFsdGZpZWxkJyApLnZhbCggdmFsdWUgKTtcblx0XHRcdFx0dGhpcy4kZWwuZGF0ZXBpY2tlciggJ3NldERhdGUnLCBuZXcgRGF0ZSggcGFyc2VJbnQoIHZhbHVlICkgKSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlLmJpbmQoIHRoaXMgKTtcblx0fVxuXG5cdHVwZGF0ZVZhbHVlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5oYXNXb3JkRm9ybWF0ICkge1xuXHRcdFx0dmFsdWUgPSBqUXVlcnkoIHRoaXMuJGVsLmRhdGVwaWNrZXIoIFwib3B0aW9uXCIsIFwiYWx0RmllbGRcIiApICkudmFsKCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgb24gZmllbGQgc2V0dGluZ3Ncblx0XHRpZiAoIHR5cGVvZiB0aGlzLnByb3BzLnVwZGF0ZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0Ly8gVXBkYXRlIGZpZWxkIHN0YXRlXG5cdFx0XHR0aGlzLnByb3BzLnVwZGF0ZVByb3BlcnR5KCB0aGlzLnByb3BzLnByb3BlcnR5LCB2YWx1ZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBVcGRhdGUgc3RvcmVcblx0XHRcdHRoaXMucHJvcHMuYWN0aW9ucy5zZXR0aW5nc0FjdGlvbnMudXBkYXRlU2V0dGluZyggdGhpcy5wcm9wcy5wcm9wZXJ0eSwgdmFsdWUgKTtcblx0XHR9XG5cdH1cblxuXHRjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0XHR0aGlzLiRlbC5kYXRlcGlja2VyKCAnZGVzdHJveScgKTtcblx0XHR0aGlzLiRlbC51bmJpbmQoKS5yZW1vdmVEYXRhKCk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3VzdG9tQ2xhc3MgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuY3VzdG9tQ2xhc3MgKVxuXHRcdFx0PyB0aGlzLnByb3BzLmN1c3RvbUNsYXNzXG5cdFx0XHQ6ICdzdWktZm9ybS1jb250cm9sJztcblxuXHRcdGNvbnN0IGNhbGVuZGFySWNvbiA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5jYWxlbmRhckljb24gKVxuXHRcdFx0PyB0aGlzLnByb3BzLmNhbGVuZGFySWNvblxuXHRcdFx0OiAncmlnaHQnO1xuXG5cdFx0bGV0IGZpZWxkQ2xhc3MgPSAnc3VpLWZvcm0tZmllbGQnO1xuXHRcdGlmICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmZpZWxkQ2xhc3MgKSApIHtcblx0XHRcdGZpZWxkQ2xhc3MgKz0gJyAnICsgdGhpcy5wcm9wcy5maWVsZENsYXNzO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMucHJvcHMubWVkaXVtU2l6ZSApIHtcblx0XHRcdGZpZWxkQ2xhc3MgKz0gJyBzdWktaW5wdXQtbWQnO1xuXHRcdH1cblxuXHRcdGxldCBmaWVsZExhYmVsO1xuXHRcdGxldCBpY29uQnV0dG9uO1xuXG5cdFx0aWYgKCB0aGlzLnByb3BzLmxhYmVsICkge1xuXHRcdFx0ZmllbGRMYWJlbCA9IChcblx0XHRcdFx0PGxhYmVsIGh0bWxGb3I9eyBgZm9ybWluYXRvci1maWVsZC0keyB0aGlzLnByb3BzLnByb3BlcnR5IH1gIH0gY2xhc3NOYW1lPVwic3VpLWxhYmVsXCI+XG5cdFx0XHRcdFx0e3RoaXMucHJvcHMubGFiZWx9XG5cdFx0XHRcdFx0e3RoaXMucHJvcHMubm90ZSAmJiA8c3BhbiBjbGFzc05hbWU9XCJzdWktbGFiZWwtbm90ZVwiPnt0aGlzLnByb3BzLm5vdGV9PC9zcGFuPn1cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnByb3BzLmNhblRyYXNoICkge1xuXHRcdFx0aWNvbkJ1dHRvbiA9IChcblx0XHRcdFx0PGJ1dHRvbiBjbGFzc05hbWU9XCJzdWktYnV0dG9uLWljb25cIj5cblx0XHRcdFx0XHQ8aSBjbGFzc05hbWU9XCJzdWktaWNvbi10cmFzaFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXNjcmVlbi1yZWFkZXItdGV4dFwiPnsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0J1JlbW92ZSB0aGlzIGRhdGUgcmFuZ2UnXG5cdFx0XHRcdFx0KSB9PC9zcGFuPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnByb3BzLmNhbkFkZCApIHtcblx0XHRcdGljb25CdXR0b24gPSAoXG5cdFx0XHRcdDxidXR0b24gY2xhc3NOYW1lPVwic3VpLWJ1dHRvbi1pY29uXCI+XG5cdFx0XHRcdFx0PGkgY2xhc3NOYW1lPVwic3VpLWljb24tcGx1c1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXNjcmVlbi1yZWFkZXItdGV4dFwiPnsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0J0FkZCBzZWxlY3RlZCBkYXRlJ1xuXHRcdFx0XHRcdCkgfTwvc3Bhbj5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQpO1xuXHRcdH1cblx0XHRjb25zdCBpbnB1dElkID0gXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5pZCApXG5cdFx0XHQ/IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHRoaXMucHJvcHMucHJvcGVydHkgfWBcblx0XHRcdDogYGZvcm1pbmF0b3ItZmllbGQtJHsgdGhpcy5wcm9wcy5pZCB9YDtcblxuXHRcdGNvbnN0IGRhdGVJbnB1dCA9IChcblx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0cmVmPXsgZWwgPT4gKCB0aGlzLmVsID0gZWwgKSB9XG5cdFx0XHRcdFx0aWQ9eyBpbnB1dElkIH1cblx0XHRcdFx0XHRjbGFzc05hbWU9eyBjdXN0b21DbGFzcyB9XG5cdFx0XHRcdFx0cGxhY2Vob2xkZXI9eyB0aGlzLnByb3BzLnBsYWNlaG9sZGVyIH1cblx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0YXV0b0NvbXBsZXRlPVwib2ZmXCJcblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMub25seVJlYWQgJiYgeyAncmVhZG9ubHk9XCJyZWFkb25seVwiJyA6ICcnIH0gfVxuXHRcdFx0XHQvPlxuXHRcdFx0XHR7IHRoaXMuaGFzV29yZEZvcm1hdCAmJlxuXHRcdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdFx0aWQ9eyBpbnB1dElkICsgJy1hbHRmaWVsZCcgfVxuXHRcdFx0XHRcdFx0c3R5bGU9eyB7IGRpc3BsYXk6ICdub25lJyB9IH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHR9XG5cdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdCk7XG5cblx0XHRsZXQgZGF0ZUZpZWxkID0gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9eyBmaWVsZENsYXNzIH0+XG5cdFx0XHRcdHsgZmllbGRMYWJlbCB9XG5cblx0XHRcdFx0eyB0aGlzLnByb3BzLm5vQ2FsZW5kYXJcblx0XHRcdFx0XHQ/IGRhdGVJbnB1dFxuXHRcdFx0XHRcdDogKFxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktZGF0ZVwiPlxuXHRcdFx0XHRcdFx0XHR7ICdsZWZ0JyA9PT0gY2FsZW5kYXJJY29uICYmXG5cdFx0XHRcdFx0XHRcdFx0PGkgY2xhc3NOYW1lPVwic3VpLWljb24tY2FsZW5kYXJcIiBhcmlhLWhpZGRlbj1cInRydWVcIi8+XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0eyBkYXRlSW5wdXQgfVxuXHRcdFx0XHRcdFx0XHR7ICdyaWdodCcgPT09IGNhbGVuZGFySWNvbiAmJlxuXHRcdFx0XHRcdFx0XHRcdDxpIGNsYXNzTmFtZT1cInN1aS1pY29uLWNhbGVuZGFyXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIvPlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQpXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ8ZGl2IGlkPXsgaW5wdXRJZCArICctY2FsZW5kYXInIH0gY2xhc3NOYW1lPVwic3VpLWRhdGUtY2FsZW5kYXJcIj48L2Rpdj5cblxuXHRcdFx0XHR7dGhpcy5wcm9wcy5kZXNjcmlwdGlvbiAmJiAoXG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCI+e3RoaXMucHJvcHMuZGVzY3JpcHRpb259PC9zcGFuPlxuXHRcdFx0XHQpfVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblxuXHRcdGlmICggdGhpcy5wcm9wcy5tdWx0aURhdGUgKSB7XG5cdFx0XHRkYXRlRmllbGQgPSAoXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLW11bHRpLWRhdGVcIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17IGZpZWxkQ2xhc3MgfT5cblx0XHRcdFx0XHRcdHsgZmllbGRMYWJlbCB9XG5cdFx0XHRcdFx0XHR7ICggdGhpcy5wcm9wcy5ub0NhbGVuZGFyID9cblx0XHRcdFx0XHRcdFx0ZGF0ZUlucHV0IDpcblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktZGF0ZVwiPlxuXHRcdFx0XHRcdFx0XHRcdHsgZGF0ZUlucHV0IH1cblx0XHRcdFx0XHRcdFx0XHQ8aSBjbGFzc05hbWU9XCJzdWktaWNvbi1jYWxlbmRhclwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0XHR7dGhpcy5wcm9wcy5kZXNjcmlwdGlvbiAmJiAoXG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPnt0aGlzLnByb3BzLmRlc2NyaXB0aW9ufTwvc3Bhbj5cblx0XHRcdFx0XHRcdCl9XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0eyBpY29uQnV0dG9uIH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRlRmllbGQ7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9pbnB1dHMvZGF0ZS1waWNrZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlZC1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIDMgNSIsImZ1bmN0aW9uIGNyZWF0ZVRodW5rTWlkZGxld2FyZShleHRyYUFyZ3VtZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBkaXNwYXRjaCA9IF9yZWYuZGlzcGF0Y2gsXG4gICAgICAgIGdldFN0YXRlID0gX3JlZi5nZXRTdGF0ZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGlvbihkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhQXJndW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn1cblxudmFyIHRodW5rID0gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKCk7XG50aHVuay53aXRoRXh0cmFBcmd1bWVudCA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZTtcblxuZXhwb3J0IGRlZmF1bHQgdGh1bms7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVkdXgtdGh1bmsvZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGlvT3B0aW9ucyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHVwZGF0ZVZhbHVlKCB2YWx1ZSApIHtcblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBvbiBmaWVsZCBzZXR0aW5nc1xuXHRcdGlmICggdHlwZW9mIHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHQvLyBVcGRhdGUgZmllbGQgc3RhdGVcblx0XHRcdHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkoXG5cdFx0XHRcdHRoaXMucHJvcHMucHJvcGVydHksXG5cdFx0XHRcdHZhbHVlXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBVcGRhdGUgc3RvcmVcblx0XHRcdHRoaXMucHJvcHMuYWN0aW9ucy5zZXR0aW5nc0FjdGlvbnMudXBkYXRlU2V0dGluZyggdGhpcy5wcm9wcy5wcm9wZXJ0eSwgdmFsdWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgcmFkaW9DbGFzcyA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5yYWRpb0NsYXNzIClcblx0XHRcdD8gJ3N1aS1yYWRpbyAnICsgdGhpcy5wcm9wcy5yYWRpb0NsYXNzXG5cdFx0XHQ6ICdzdWktcmFkaW8nO1xuXG5cdFx0Y29uc3QgdmFsdWUgPSBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF0gKVxuXHRcdFx0PyB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZVxuXHRcdFx0OiB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF07XG5cblx0XHRjb25zdCByYWRpb09wdGlvbnMgPSBSZWFjdC5DaGlsZHJlbi5tYXAoIHRoaXMucHJvcHMuY2hpbGRyZW4sIHRhYiA9PiB7XG5cdFx0XHRsZXQgb3B0aW9uSW1hZ2UgPSAnJztcblx0XHRcdGNvbnN0IG9wdGlvbkxhYmVsID0gISBfLmlzVW5kZWZpbmVkKCB0YWIucHJvcHMubGFiZWwgKVxuXHRcdFx0XHQ/IHRhYi5wcm9wcy5sYWJlbFxuXHRcdFx0XHQ6IHRhYi5wcm9wcy5jaGlsZHJlbjtcblxuXHRcdFx0aWYgKCB0YWIucHJvcHMuaW1hZ2UxeCAmJiB0YWIucHJvcHMuaW1hZ2UyeCApIHtcblx0XHRcdFx0b3B0aW9uSW1hZ2UgPSAoXG5cdFx0XHRcdFx0PGltZyBzcmM9eyBgJHsgZm9ybWluYXRvckRhdGEuaW1hZ2VzVXJsIH0vJHsgdGFiLnByb3BzLmltYWdlMXggfWAgfVxuXHRcdFx0XHRcdFx0c3JjU2V0PXtcblx0XHRcdFx0XHRcdFx0YCR7IGZvcm1pbmF0b3JEYXRhLmltYWdlc1VybCB9LyR7IHRhYi5wcm9wcy5pbWFnZTF4IH0gMXgsXG5cdFx0XHRcdFx0XHRcdCR7IGZvcm1pbmF0b3JEYXRhLmltYWdlc1VybCB9LyR7IHRhYi5wcm9wcy5pbWFnZTJ4IH0gMnhgXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRhYi5wcm9wcy5pbWFnZTF4ICYmICEgdGFiLnByb3BzLmltYWdlMnggKSB7XG5cdFx0XHRcdG9wdGlvbkltYWdlID0gKFxuXHRcdFx0XHRcdDxpbWcgc3JjPXsgYCR7IGZvcm1pbmF0b3JEYXRhLmltYWdlc1VybCB9LyR7IHRhYi5wcm9wcy5pbWFnZTF4IH1gIH1cblx0XHRcdFx0XHRcdGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGFiLnByb3BzLmltYWdlMnggJiYgISB0YWIucHJvcHMuaW1hZ2UxeCApIHtcblx0XHRcdFx0b3B0aW9uSW1hZ2UgPSAoXG5cdFx0XHRcdFx0PGltZyBzcmM9eyBgJHsgZm9ybWluYXRvckRhdGEuaW1hZ2VzVXJsIH0vJHsgdGFiLnByb3BzLmltYWdlMnggfWAgfVxuXHRcdFx0XHRcdFx0c3JjU2V0PXtcblx0XHRcdFx0XHRcdFx0YCR7IGZvcm1pbmF0b3JEYXRhLmltYWdlc1VybCB9LyR7IHRhYi5wcm9wcy5pbWFnZTJ4IH0gMnhgXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRhYi5wcm9wcy5oYXNJbWFnZSApIHtcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHQ8bGFiZWwgaHRtbEZvcj17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHRhYi5wcm9wcy52YWx1ZSB9YCB9XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktcmFkaW8taW1hZ2VcIj5cblxuXHRcdFx0XHRcdFx0eyBvcHRpb25JbWFnZSB9XG5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT17IHJhZGlvQ2xhc3MgfT5cblx0XHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9XCJyYWRpb1wiXG5cdFx0XHRcdFx0XHRcdFx0bmFtZT17IGBmb3JtaW5hdG9yLSR7IHRoaXMucHJvcHMucHJvcGVydHkgfWAgfVxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlPXsgdGFiLnByb3BzLnZhbHVlIH1cblx0XHRcdFx0XHRcdFx0XHRpZD17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHRhYi5wcm9wcy52YWx1ZSB9YCB9XG5cdFx0XHRcdFx0XHRcdFx0Y2hlY2tlZD17IHZhbHVlID09PSB0YWIucHJvcHMudmFsdWUgfVxuXHRcdFx0XHRcdFx0XHRcdG9uQ2hhbmdlPXsgdGhpcy51cGRhdGVWYWx1ZS5iaW5kKCB0aGlzLCB0YWIucHJvcHMudmFsdWUgKSB9XG5cdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4+eyBvcHRpb25MYWJlbCB9PC9zcGFuPlxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXG5cdFx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIHRhYi5wcm9wcy5oYXNJbWFnZSApIHtcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHQ8bGFiZWwgaHRtbEZvcj17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHRhYi5wcm9wcy52YWx1ZSB9YCB9XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9eyByYWRpb0NsYXNzIH0+XG5cdFx0XHRcdFx0XHQ8aW5wdXQgdHlwZT1cInJhZGlvXCJcblx0XHRcdFx0XHRcdFx0bmFtZT17IGBmb3JtaW5hdG9yLSR7IHRoaXMucHJvcHMucHJvcGVydHkgfWAgfVxuXHRcdFx0XHRcdFx0XHRpZD17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHRhYi5wcm9wcy52YWx1ZSB9YCB9XG5cdFx0XHRcdFx0XHRcdHZhbHVlPXsgdGFiLnByb3BzLnZhbHVlIH1cblx0XHRcdFx0XHRcdFx0Y2hlY2tlZD17IHZhbHVlID09PSB0YWIucHJvcHMudmFsdWUgfVxuXHRcdFx0XHRcdFx0XHRvbkNoYW5nZT17IHRoaXMudXBkYXRlVmFsdWUuYmluZCggdGhpcywgdGFiLnByb3BzLnZhbHVlICkgfVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cblx0XHRcdFx0XHRcdDxzcGFuPnsgb3B0aW9uTGFiZWwgfTwvc3Bhbj5cblx0XHRcdFx0XHQ8L2xhYmVsPlxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IHJhZGlvQ29udGVudCA9IFJlYWN0LkNoaWxkcmVuLm1hcCggdGhpcy5wcm9wcy5jaGlsZHJlbiwgdGFiID0+IHtcblx0XHRcdGlmICggJ3RydWUnID09PSB0aGlzLnByb3BzLnJhZGlvQ29udGVudCAmJiAhIF8uaXNVbmRlZmluZWQoIHRhYi5wcm9wcy5jaGlsZHJlbiApICkge1xuXHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRcdGNsYXNzTmFtZT17XG5cdFx0XHRcdFx0XHRcdCdzdWktYm9yZGVyLWZyYW1lJyArICggdGFiLnByb3BzLnZhbHVlID09PSB2YWx1ZSA/ICcnIDogJyBzdWktaGlkZGVuJyApXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzdHlsZT17IHsgbWFyZ2luTGVmdDogJzAnIH0gfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdGFiLnByb3BzLnZhbHVlID09PSB2YWx1ZSAmJiB0YWIgfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8UmVhY3QuRnJhZ21lbnQgLz5cblx0XHRcdCk7XG5cdFx0fSApO1xuXG5cdFx0bGV0IGxhYmVsID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMubGFiZWwgJiYgJycgIT09IHRoaXMucHJvcHMubGFiZWwgKSB7XG5cdFx0XHRsYWJlbCA9IChcblx0XHRcdFx0PGxhYmVsIGNsYXNzTmFtZT1cInN1aS1sYWJlbFwiPlxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5sYWJlbCB9XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLm5vdGUgJiZcblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1sYWJlbC1ub3RlXCI+eyB0aGlzLnByb3BzLm5vdGUgfTwvc3Bhbj5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdDwvbGFiZWw+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGxldCBkZXNjcmlwdGlvbiA9ICcnO1xuXG5cdFx0aWYgKCB0aGlzLnByb3BzLmRlc2NyaXB0aW9uICYmICcnICE9PSB0aGlzLnByb3BzLmRlc2NyaXB0aW9uICkge1xuXHRcdFx0ZGVzY3JpcHRpb24gPSAoXG5cdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCJcblx0XHRcdFx0XHRzdHlsZT17IHsgbWFyZ2luQm90dG9tOiAnMTBweCcgfSB9XG5cdFx0XHRcdD57IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gfTwvc3Bhbj5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0bGV0IHNldHRpbmdzTGFiZWwgPSAnJztcblxuXHRcdGlmICggdGhpcy5wcm9wcy5zZXR0aW5nc0xhYmVsICYmICcnICE9PSB0aGlzLnByb3BzLnNldHRpbmdzTGFiZWwgKSB7XG5cdFx0XHRzZXR0aW5nc0xhYmVsID0gKFxuXHRcdFx0XHQ8bGFiZWwgY2xhc3NOYW1lPVwic3VpLXNldHRpbmdzLWxhYmVsXCI+eyB0aGlzLnByb3BzLnNldHRpbmdzTGFiZWwgfTwvbGFiZWw+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGxldCBzZXR0aW5nc0Rlc2NyaXB0aW9uID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMuc2V0dGluZ3NEZXNjICYmICcnICE9PSB0aGlzLnByb3BzLnNldHRpbmdzRGVzYyApIHtcblx0XHRcdHNldHRpbmdzRGVzY3JpcHRpb24gPSAoXG5cdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCJcblx0XHRcdFx0XHRzdHlsZT17IHsgbWFyZ2luQm90dG9tOiAnMTBweCcgfSB9XG5cdFx0XHRcdD57IHRoaXMucHJvcHMuc2V0dGluZ3NEZXNjIH08L3NwYW4+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmICggISB0aGlzLnByb3BzLm5vV3JhcHBlciApIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0XHQ8ZGl2IHJvbGU9XCJyYWRpb2dyb3VwXCIgY2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGRcIj5cblx0XHRcdFx0XHRcdHsgbGFiZWwgfVxuXHRcdFx0XHRcdFx0eyBzZXR0aW5nc0xhYmVsIH1cblx0XHRcdFx0XHRcdHsgZGVzY3JpcHRpb24gfVxuXHRcdFx0XHRcdFx0eyBzZXR0aW5nc0Rlc2NyaXB0aW9uIH1cblx0XHRcdFx0XHRcdHsgcmFkaW9PcHRpb25zIH1cblx0XHRcdFx0XHRcdHsgcmFkaW9Db250ZW50IH1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJhZGlvT3B0aW9ucztcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzL2lucHV0cy9yYWRpby1vcHRpb25zLmpzIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgeyBDb21wb25lbnQsIENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IHN0b3JlU2hhcGUsIHN1YnNjcmlwdGlvblNoYXBlIH0gZnJvbSAnLi4vdXRpbHMvUHJvcFR5cGVzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4uL3V0aWxzL3dhcm5pbmcnO1xuXG52YXIgZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUgPSBmYWxzZTtcbmZ1bmN0aW9uIHdhcm5BYm91dFJlY2VpdmluZ1N0b3JlKCkge1xuICBpZiAoZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUgPSB0cnVlO1xuXG4gIHdhcm5pbmcoJzxQcm92aWRlcj4gZG9lcyBub3Qgc3VwcG9ydCBjaGFuZ2luZyBgc3RvcmVgIG9uIHRoZSBmbHkuICcgKyAnSXQgaXMgbW9zdCBsaWtlbHkgdGhhdCB5b3Ugc2VlIHRoaXMgZXJyb3IgYmVjYXVzZSB5b3UgdXBkYXRlZCB0byAnICsgJ1JlZHV4IDIueCBhbmQgUmVhY3QgUmVkdXggMi54IHdoaWNoIG5vIGxvbmdlciBob3QgcmVsb2FkIHJlZHVjZXJzICcgKyAnYXV0b21hdGljYWxseS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXJlZHV4L3JlbGVhc2VzLycgKyAndGFnL3YyLjAuMCBmb3IgdGhlIG1pZ3JhdGlvbiBpbnN0cnVjdGlvbnMuJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm92aWRlcigpIHtcbiAgdmFyIF9Qcm92aWRlciRjaGlsZENvbnRleDtcblxuICB2YXIgc3RvcmVLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdzdG9yZSc7XG4gIHZhciBzdWJLZXkgPSBhcmd1bWVudHNbMV07XG5cbiAgdmFyIHN1YnNjcmlwdGlvbktleSA9IHN1YktleSB8fCBzdG9yZUtleSArICdTdWJzY3JpcHRpb24nO1xuXG4gIHZhciBQcm92aWRlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFByb3ZpZGVyLCBfQ29tcG9uZW50KTtcblxuICAgIFByb3ZpZGVyLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltzdG9yZUtleV0gPSB0aGlzW3N0b3JlS2V5XSwgX3JlZltzdWJzY3JpcHRpb25LZXldID0gbnVsbCwgX3JlZjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUHJvdmlkZXIocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm92aWRlcik7XG5cbiAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkpO1xuXG4gICAgICBfdGhpc1tzdG9yZUtleV0gPSBwcm9wcy5zdG9yZTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBQcm92aWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIENoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgfTtcblxuICAgIHJldHVybiBQcm92aWRlcjtcbiAgfShDb21wb25lbnQpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUHJvdmlkZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgICBpZiAodGhpc1tzdG9yZUtleV0gIT09IG5leHRQcm9wcy5zdG9yZSkge1xuICAgICAgICB3YXJuQWJvdXRSZWNlaXZpbmdTdG9yZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBQcm92aWRlci5wcm9wVHlwZXMgPSB7XG4gICAgc3RvcmU6IHN0b3JlU2hhcGUuaXNSZXF1aXJlZCxcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmVsZW1lbnQuaXNSZXF1aXJlZFxuICB9O1xuICBQcm92aWRlci5jaGlsZENvbnRleHRUeXBlcyA9IChfUHJvdmlkZXIkY2hpbGRDb250ZXggPSB7fSwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4W3N0b3JlS2V5XSA9IHN0b3JlU2hhcGUuaXNSZXF1aXJlZCwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4W3N1YnNjcmlwdGlvbktleV0gPSBzdWJzY3JpcHRpb25TaGFwZSwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4KTtcblxuICByZXR1cm4gUHJvdmlkZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVByb3ZpZGVyKCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9Qcm92aWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAnICsgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpICsgJyBhdCBpbmRleCAnICsgaSArICcuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKVxuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgJ1VzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgKTtcbiAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB0aHJvdyBlcnI7XG4gIH07XG4gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH07XG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltLFxuICAgIGV4YWN0OiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8vIGVuY2Fwc3VsYXRlcyB0aGUgc3Vic2NyaXB0aW9uIGxvZ2ljIGZvciBjb25uZWN0aW5nIGEgY29tcG9uZW50IHRvIHRoZSByZWR1eCBzdG9yZSwgYXNcbi8vIHdlbGwgYXMgbmVzdGluZyBzdWJzY3JpcHRpb25zIG9mIGRlc2NlbmRhbnQgY29tcG9uZW50cywgc28gdGhhdCB3ZSBjYW4gZW5zdXJlIHRoZVxuLy8gYW5jZXN0b3IgY29tcG9uZW50cyByZS1yZW5kZXIgYmVmb3JlIGRlc2NlbmRhbnRzXG5cbnZhciBDTEVBUkVEID0gbnVsbDtcbnZhciBudWxsTGlzdGVuZXJzID0ge1xuICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeSgpIHt9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKSB7XG4gIC8vIHRoZSBjdXJyZW50L25leHQgcGF0dGVybiBpcyBjb3BpZWQgZnJvbSByZWR1eCdzIGNyZWF0ZVN0b3JlIGNvZGUuXG4gIC8vIFRPRE86IHJlZmFjdG9yK2V4cG9zZSB0aGF0IGNvZGUgdG8gYmUgcmV1c2FibGUgaGVyZT9cbiAgdmFyIGN1cnJlbnQgPSBbXTtcbiAgdmFyIG5leHQgPSBbXTtcblxuICByZXR1cm4ge1xuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIG5leHQgPSBDTEVBUkVEO1xuICAgICAgY3VycmVudCA9IENMRUFSRUQ7XG4gICAgfSxcbiAgICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50ID0gbmV4dDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpc3RlbmVyc1tpXSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9LFxuICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgICB2YXIgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgIGlmIChuZXh0ID09PSBjdXJyZW50KSBuZXh0ID0gY3VycmVudC5zbGljZSgpO1xuICAgICAgbmV4dC5wdXNoKGxpc3RlbmVyKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoIWlzU3Vic2NyaWJlZCB8fCBjdXJyZW50ID09PSBDTEVBUkVEKSByZXR1cm47XG4gICAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChuZXh0ID09PSBjdXJyZW50KSBuZXh0ID0gY3VycmVudC5zbGljZSgpO1xuICAgICAgICBuZXh0LnNwbGljZShuZXh0LmluZGV4T2YobGlzdGVuZXIpLCAxKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG52YXIgU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdWJzY3JpcHRpb24oc3RvcmUsIHBhcmVudFN1Yiwgb25TdGF0ZUNoYW5nZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJzY3JpcHRpb24pO1xuXG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIHRoaXMucGFyZW50U3ViID0gcGFyZW50U3ViO1xuICAgIHRoaXMub25TdGF0ZUNoYW5nZSA9IG9uU3RhdGVDaGFuZ2U7XG4gICAgdGhpcy51bnN1YnNjcmliZSA9IG51bGw7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xuICB9XG5cbiAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5hZGROZXN0ZWRTdWIgPSBmdW5jdGlvbiBhZGROZXN0ZWRTdWIobGlzdGVuZXIpIHtcbiAgICB0aGlzLnRyeVN1YnNjcmliZSgpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICB9O1xuXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUubm90aWZ5TmVzdGVkU3VicyA9IGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnMoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMubm90aWZ5KCk7XG4gIH07XG5cbiAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5pc1N1YnNjcmliZWQgPSBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy51bnN1YnNjcmliZSk7XG4gIH07XG5cbiAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS50cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiB0cnlTdWJzY3JpYmUoKSB7XG4gICAgaWYgKCF0aGlzLnVuc3Vic2NyaWJlKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlID0gdGhpcy5wYXJlbnRTdWIgPyB0aGlzLnBhcmVudFN1Yi5hZGROZXN0ZWRTdWIodGhpcy5vblN0YXRlQ2hhbmdlKSA6IHRoaXMuc3RvcmUuc3Vic2NyaWJlKHRoaXMub25TdGF0ZUNoYW5nZSk7XG5cbiAgICAgIHRoaXMubGlzdGVuZXJzID0gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCk7XG4gICAgfVxuICB9O1xuXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudHJ5VW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZSgpIHtcbiAgICBpZiAodGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgdGhpcy51bnN1YnNjcmliZSA9IG51bGw7XG4gICAgICB0aGlzLmxpc3RlbmVycy5jbGVhcigpO1xuICAgICAgdGhpcy5saXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpO1xuXG5leHBvcnQgeyBTdWJzY3JpcHRpb24gYXMgZGVmYXVsdCB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL1N1YnNjcmlwdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgY29ubmVjdEFkdmFuY2VkIGZyb20gJy4uL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkJztcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnLi4vdXRpbHMvc2hhbGxvd0VxdWFsJztcbmltcG9ydCBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzIGZyb20gJy4vbWFwRGlzcGF0Y2hUb1Byb3BzJztcbmltcG9ydCBkZWZhdWx0TWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzIGZyb20gJy4vbWFwU3RhdGVUb1Byb3BzJztcbmltcG9ydCBkZWZhdWx0TWVyZ2VQcm9wc0ZhY3RvcmllcyBmcm9tICcuL21lcmdlUHJvcHMnO1xuaW1wb3J0IGRlZmF1bHRTZWxlY3RvckZhY3RvcnkgZnJvbSAnLi9zZWxlY3RvckZhY3RvcnknO1xuXG4vKlxuICBjb25uZWN0IGlzIGEgZmFjYWRlIG92ZXIgY29ubmVjdEFkdmFuY2VkLiBJdCB0dXJucyBpdHMgYXJncyBpbnRvIGEgY29tcGF0aWJsZVxuICBzZWxlY3RvckZhY3RvcnksIHdoaWNoIGhhcyB0aGUgc2lnbmF0dXJlOlxuXG4gICAgKGRpc3BhdGNoLCBvcHRpb25zKSA9PiAobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpID0+IG5leHRGaW5hbFByb3BzXG4gIFxuICBjb25uZWN0IHBhc3NlcyBpdHMgYXJncyB0byBjb25uZWN0QWR2YW5jZWQgYXMgb3B0aW9ucywgd2hpY2ggd2lsbCBpbiB0dXJuIHBhc3MgdGhlbSB0b1xuICBzZWxlY3RvckZhY3RvcnkgZWFjaCB0aW1lIGEgQ29ubmVjdCBjb21wb25lbnQgaW5zdGFuY2UgaXMgaW5zdGFudGlhdGVkIG9yIGhvdCByZWxvYWRlZC5cblxuICBzZWxlY3RvckZhY3RvcnkgcmV0dXJucyBhIGZpbmFsIHByb3BzIHNlbGVjdG9yIGZyb20gaXRzIG1hcFN0YXRlVG9Qcm9wcyxcbiAgbWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcywgbWVyZ2VQcm9wcyxcbiAgbWVyZ2VQcm9wc0ZhY3RvcmllcywgYW5kIHB1cmUgYXJncy5cblxuICBUaGUgcmVzdWx0aW5nIGZpbmFsIHByb3BzIHNlbGVjdG9yIGlzIGNhbGxlZCBieSB0aGUgQ29ubmVjdCBjb21wb25lbnQgaW5zdGFuY2Ugd2hlbmV2ZXJcbiAgaXQgcmVjZWl2ZXMgbmV3IHByb3BzIG9yIHN0b3JlIHN0YXRlLlxuICovXG5cbmZ1bmN0aW9uIG1hdGNoKGFyZywgZmFjdG9yaWVzLCBuYW1lKSB7XG4gIGZvciAodmFyIGkgPSBmYWN0b3JpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcmVzdWx0ID0gZmFjdG9yaWVzW2ldKGFyZyk7XG4gICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gsIG9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgb2YgdHlwZSAnICsgdHlwZW9mIGFyZyArICcgZm9yICcgKyBuYW1lICsgJyBhcmd1bWVudCB3aGVuIGNvbm5lY3RpbmcgY29tcG9uZW50ICcgKyBvcHRpb25zLndyYXBwZWRDb21wb25lbnROYW1lICsgJy4nKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaWN0RXF1YWwoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cblxuLy8gY3JlYXRlQ29ubmVjdCB3aXRoIGRlZmF1bHQgYXJncyBidWlsZHMgdGhlICdvZmZpY2lhbCcgY29ubmVjdCBiZWhhdmlvci4gQ2FsbGluZyBpdCB3aXRoXG4vLyBkaWZmZXJlbnQgb3B0aW9ucyBvcGVucyB1cCBzb21lIHRlc3RpbmcgYW5kIGV4dGVuc2liaWxpdHkgc2NlbmFyaW9zXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29ubmVjdCgpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgX3JlZiRjb25uZWN0SE9DID0gX3JlZi5jb25uZWN0SE9DLFxuICAgICAgY29ubmVjdEhPQyA9IF9yZWYkY29ubmVjdEhPQyA9PT0gdW5kZWZpbmVkID8gY29ubmVjdEFkdmFuY2VkIDogX3JlZiRjb25uZWN0SE9DLFxuICAgICAgX3JlZiRtYXBTdGF0ZVRvUHJvcHNGID0gX3JlZi5tYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMsXG4gICAgICBtYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMgPSBfcmVmJG1hcFN0YXRlVG9Qcm9wc0YgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMgOiBfcmVmJG1hcFN0YXRlVG9Qcm9wc0YsXG4gICAgICBfcmVmJG1hcERpc3BhdGNoVG9Qcm8gPSBfcmVmLm1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyxcbiAgICAgIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyA9IF9yZWYkbWFwRGlzcGF0Y2hUb1BybyA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyA6IF9yZWYkbWFwRGlzcGF0Y2hUb1BybyxcbiAgICAgIF9yZWYkbWVyZ2VQcm9wc0ZhY3RvciA9IF9yZWYubWVyZ2VQcm9wc0ZhY3RvcmllcyxcbiAgICAgIG1lcmdlUHJvcHNGYWN0b3JpZXMgPSBfcmVmJG1lcmdlUHJvcHNGYWN0b3IgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRNZXJnZVByb3BzRmFjdG9yaWVzIDogX3JlZiRtZXJnZVByb3BzRmFjdG9yLFxuICAgICAgX3JlZiRzZWxlY3RvckZhY3RvcnkgPSBfcmVmLnNlbGVjdG9yRmFjdG9yeSxcbiAgICAgIHNlbGVjdG9yRmFjdG9yeSA9IF9yZWYkc2VsZWN0b3JGYWN0b3J5ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0U2VsZWN0b3JGYWN0b3J5IDogX3JlZiRzZWxlY3RvckZhY3Rvcnk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpIHtcbiAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9LFxuICAgICAgICBfcmVmMiRwdXJlID0gX3JlZjIucHVyZSxcbiAgICAgICAgcHVyZSA9IF9yZWYyJHB1cmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmMiRwdXJlLFxuICAgICAgICBfcmVmMiRhcmVTdGF0ZXNFcXVhbCA9IF9yZWYyLmFyZVN0YXRlc0VxdWFsLFxuICAgICAgICBhcmVTdGF0ZXNFcXVhbCA9IF9yZWYyJGFyZVN0YXRlc0VxdWFsID09PSB1bmRlZmluZWQgPyBzdHJpY3RFcXVhbCA6IF9yZWYyJGFyZVN0YXRlc0VxdWFsLFxuICAgICAgICBfcmVmMiRhcmVPd25Qcm9wc0VxdWEgPSBfcmVmMi5hcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgICBhcmVPd25Qcm9wc0VxdWFsID0gX3JlZjIkYXJlT3duUHJvcHNFcXVhID09PSB1bmRlZmluZWQgPyBzaGFsbG93RXF1YWwgOiBfcmVmMiRhcmVPd25Qcm9wc0VxdWEsXG4gICAgICAgIF9yZWYyJGFyZVN0YXRlUHJvcHNFcSA9IF9yZWYyLmFyZVN0YXRlUHJvcHNFcXVhbCxcbiAgICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsID0gX3JlZjIkYXJlU3RhdGVQcm9wc0VxID09PSB1bmRlZmluZWQgPyBzaGFsbG93RXF1YWwgOiBfcmVmMiRhcmVTdGF0ZVByb3BzRXEsXG4gICAgICAgIF9yZWYyJGFyZU1lcmdlZFByb3BzRSA9IF9yZWYyLmFyZU1lcmdlZFByb3BzRXF1YWwsXG4gICAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBfcmVmMiRhcmVNZXJnZWRQcm9wc0UgPT09IHVuZGVmaW5lZCA/IHNoYWxsb3dFcXVhbCA6IF9yZWYyJGFyZU1lcmdlZFByb3BzRSxcbiAgICAgICAgZXh0cmFPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ3B1cmUnLCAnYXJlU3RhdGVzRXF1YWwnLCAnYXJlT3duUHJvcHNFcXVhbCcsICdhcmVTdGF0ZVByb3BzRXF1YWwnLCAnYXJlTWVyZ2VkUHJvcHNFcXVhbCddKTtcblxuICAgIHZhciBpbml0TWFwU3RhdGVUb1Byb3BzID0gbWF0Y2gobWFwU3RhdGVUb1Byb3BzLCBtYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMsICdtYXBTdGF0ZVRvUHJvcHMnKTtcbiAgICB2YXIgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyA9IG1hdGNoKG1hcERpc3BhdGNoVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJyk7XG4gICAgdmFyIGluaXRNZXJnZVByb3BzID0gbWF0Y2gobWVyZ2VQcm9wcywgbWVyZ2VQcm9wc0ZhY3RvcmllcywgJ21lcmdlUHJvcHMnKTtcblxuICAgIHJldHVybiBjb25uZWN0SE9DKHNlbGVjdG9yRmFjdG9yeSwgX2V4dGVuZHMoe1xuICAgICAgLy8gdXNlZCBpbiBlcnJvciBtZXNzYWdlc1xuICAgICAgbWV0aG9kTmFtZTogJ2Nvbm5lY3QnLFxuXG4gICAgICAvLyB1c2VkIHRvIGNvbXB1dGUgQ29ubmVjdCdzIGRpc3BsYXlOYW1lIGZyb20gdGhlIHdyYXBwZWQgY29tcG9uZW50J3MgZGlzcGxheU5hbWUuXG4gICAgICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gJ0Nvbm5lY3QoJyArIG5hbWUgKyAnKSc7XG4gICAgICB9LFxuXG4gICAgICAvLyBpZiBtYXBTdGF0ZVRvUHJvcHMgaXMgZmFsc3ksIHRoZSBDb25uZWN0IGNvbXBvbmVudCBkb2Vzbid0IHN1YnNjcmliZSB0byBzdG9yZSBzdGF0ZSBjaGFuZ2VzXG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXM6IEJvb2xlYW4obWFwU3RhdGVUb1Byb3BzKSxcblxuICAgICAgLy8gcGFzc2VkIHRocm91Z2ggdG8gc2VsZWN0b3JGYWN0b3J5XG4gICAgICBpbml0TWFwU3RhdGVUb1Byb3BzOiBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICAgICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wczogaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICAgIGluaXRNZXJnZVByb3BzOiBpbml0TWVyZ2VQcm9wcyxcbiAgICAgIHB1cmU6IHB1cmUsXG4gICAgICBhcmVTdGF0ZXNFcXVhbDogYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsOiBhcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsOiBhcmVTdGF0ZVByb3BzRXF1YWwsXG4gICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsOiBhcmVNZXJnZWRQcm9wc0VxdWFsXG5cbiAgICB9LCBleHRyYU9wdGlvbnMpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQ29ubmVjdCgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvY29ubmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwidmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkgcmV0dXJuIHRydWU7XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093bi5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3NoYWxsb3dFcXVhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgd3JhcE1hcFRvUHJvcHNDb25zdGFudCwgd3JhcE1hcFRvUHJvcHNGdW5jIH0gZnJvbSAnLi93cmFwTWFwVG9Qcm9wcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNGdW5jdGlvbihtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09ICdmdW5jdGlvbicgPyB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwRGlzcGF0Y2hUb1Byb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJykgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNNaXNzaW5nKG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gIW1hcERpc3BhdGNoVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZnVuY3Rpb24gKGRpc3BhdGNoKSB7XG4gICAgcmV0dXJuIHsgZGlzcGF0Y2g6IGRpc3BhdGNoIH07XG4gIH0pIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzT2JqZWN0KG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gbWFwRGlzcGF0Y2hUb1Byb3BzICYmIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09ICdvYmplY3QnID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3JzKG1hcERpc3BhdGNoVG9Qcm9wcywgZGlzcGF0Y2gpO1xuICB9KSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgW3doZW5NYXBEaXNwYXRjaFRvUHJvcHNJc0Z1bmN0aW9uLCB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNNaXNzaW5nLCB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNPYmplY3RdO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWFwRGlzcGF0Y2hUb1Byb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgcG9ueWZpbGwgZnJvbSAnLi9wb255ZmlsbC5qcyc7XG5cbnZhciByb290O1xuXG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gbW9kdWxlO1xufSBlbHNlIHtcbiAgcm9vdCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG5cbnZhciByZXN1bHQgPSBwb255ZmlsbChyb290KTtcbmV4cG9ydCBkZWZhdWx0IHJlc3VsdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2VzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XHJcblx0aWYoIW9yaWdpbmFsTW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiZXhwb3J0c1wiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9oYXJtb255LW1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRTeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2VzL3BvbnlmaWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBnZXRQcm90b3R5cGUgZnJvbSAnLi9fZ2V0UHJvdG90eXBlLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUGxhaW5PYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNQbGFpbk9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRUYWcuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBnZXRQcm90b3R5cGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFByb3RvdHlwZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXJBcmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanNcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdExpa2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJpbXBvcnQgeyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50LCB3cmFwTWFwVG9Qcm9wc0Z1bmMgfSBmcm9tICcuL3dyYXBNYXBUb1Byb3BzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBTdGF0ZVRvUHJvcHNJc0Z1bmN0aW9uKG1hcFN0YXRlVG9Qcm9wcykge1xuICByZXR1cm4gdHlwZW9mIG1hcFN0YXRlVG9Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBTdGF0ZVRvUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnKSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBTdGF0ZVRvUHJvcHNJc01pc3NpbmcobWFwU3RhdGVUb1Byb3BzKSB7XG4gIHJldHVybiAhbWFwU3RhdGVUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9KSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgW3doZW5NYXBTdGF0ZVRvUHJvcHNJc0Z1bmN0aW9uLCB3aGVuTWFwU3RhdGVUb1Byb3BzSXNNaXNzaW5nXTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy5qc1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHZlcmlmeVBsYWluT2JqZWN0IGZyb20gJy4uL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRNZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgb3duUHJvcHMsIHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRNZXJnZVByb3BzUHJveHkoZGlzcGF0Y2gsIF9yZWYpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBfcmVmLmRpc3BsYXlOYW1lLFxuICAgICAgICBwdXJlID0gX3JlZi5wdXJlLFxuICAgICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsID0gX3JlZi5hcmVNZXJnZWRQcm9wc0VxdWFsO1xuXG4gICAgdmFyIGhhc1J1bk9uY2UgPSBmYWxzZTtcbiAgICB2YXIgbWVyZ2VkUHJvcHMgPSB2b2lkIDA7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VQcm9wc1Byb3h5KHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gICAgICB2YXIgbmV4dE1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG5cbiAgICAgIGlmIChoYXNSdW5PbmNlKSB7XG4gICAgICAgIGlmICghcHVyZSB8fCAhYXJlTWVyZ2VkUHJvcHNFcXVhbChuZXh0TWVyZ2VkUHJvcHMsIG1lcmdlZFByb3BzKSkgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNSdW5PbmNlID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHZlcmlmeVBsYWluT2JqZWN0KG1lcmdlZFByb3BzLCBkaXNwbGF5TmFtZSwgJ21lcmdlUHJvcHMnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWVyZ2VQcm9wc0lzRnVuY3Rpb24obWVyZ2VQcm9wcykge1xuICByZXR1cm4gdHlwZW9mIG1lcmdlUHJvcHMgPT09ICdmdW5jdGlvbicgPyB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWVyZ2VQcm9wc0lzT21pdHRlZChtZXJnZVByb3BzKSB7XG4gIHJldHVybiAhbWVyZ2VQcm9wcyA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1lcmdlUHJvcHM7XG4gIH0gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFt3aGVuTWVyZ2VQcm9wc0lzRnVuY3Rpb24sIHdoZW5NZXJnZVByb3BzSXNPbWl0dGVkXTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21lcmdlUHJvcHMuanNcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IHZlcmlmeVN1YnNlbGVjdG9ycyBmcm9tICcuL3ZlcmlmeVN1YnNlbGVjdG9ycyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbXB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gaW1wdXJlRmluYWxQcm9wc1NlbGVjdG9yKHN0YXRlLCBvd25Qcm9wcykge1xuICAgIHJldHVybiBtZXJnZVByb3BzKG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpLCBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKSwgb3duUHJvcHMpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBfcmVmKSB7XG4gIHZhciBhcmVTdGF0ZXNFcXVhbCA9IF9yZWYuYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsID0gX3JlZi5hcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsID0gX3JlZi5hcmVTdGF0ZVByb3BzRXF1YWw7XG5cbiAgdmFyIGhhc1J1bkF0TGVhc3RPbmNlID0gZmFsc2U7XG4gIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgdmFyIG93blByb3BzID0gdm9pZCAwO1xuICB2YXIgc3RhdGVQcm9wcyA9IHZvaWQgMDtcbiAgdmFyIGRpc3BhdGNoUHJvcHMgPSB2b2lkIDA7XG4gIHZhciBtZXJnZWRQcm9wcyA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBoYW5kbGVGaXJzdENhbGwoZmlyc3RTdGF0ZSwgZmlyc3RPd25Qcm9wcykge1xuICAgIHN0YXRlID0gZmlyc3RTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IGZpcnN0T3duUHJvcHM7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIGhhc1J1bkF0TGVhc3RPbmNlID0gdHJ1ZTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCkge1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcblxuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcblxuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHMoKSB7XG4gICAgaWYgKG1hcFN0YXRlVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuXG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuXG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdTdGF0ZSgpIHtcbiAgICB2YXIgbmV4dFN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICB2YXIgc3RhdGVQcm9wc0NoYW5nZWQgPSAhYXJlU3RhdGVQcm9wc0VxdWFsKG5leHRTdGF0ZVByb3BzLCBzdGF0ZVByb3BzKTtcbiAgICBzdGF0ZVByb3BzID0gbmV4dFN0YXRlUHJvcHM7XG5cbiAgICBpZiAoc3RhdGVQcm9wc0NoYW5nZWQpIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG5cbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICB2YXIgcHJvcHNDaGFuZ2VkID0gIWFyZU93blByb3BzRXF1YWwobmV4dE93blByb3BzLCBvd25Qcm9wcyk7XG4gICAgdmFyIHN0YXRlQ2hhbmdlZCA9ICFhcmVTdGF0ZXNFcXVhbChuZXh0U3RhdGUsIHN0YXRlKTtcbiAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IG5leHRPd25Qcm9wcztcblxuICAgIGlmIChwcm9wc0NoYW5nZWQgJiYgc3RhdGVDaGFuZ2VkKSByZXR1cm4gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpO1xuICAgIGlmIChwcm9wc0NoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wcygpO1xuICAgIGlmIChzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdTdGF0ZSgpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSB7XG4gICAgcmV0dXJuIGhhc1J1bkF0TGVhc3RPbmNlID8gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSA6IGhhbmRsZUZpcnN0Q2FsbChuZXh0U3RhdGUsIG5leHRPd25Qcm9wcyk7XG4gIH07XG59XG5cbi8vIFRPRE86IEFkZCBtb3JlIGNvbW1lbnRzXG5cbi8vIElmIHB1cmUgaXMgdHJ1ZSwgdGhlIHNlbGVjdG9yIHJldHVybmVkIGJ5IHNlbGVjdG9yRmFjdG9yeSB3aWxsIG1lbW9pemUgaXRzIHJlc3VsdHMsXG4vLyBhbGxvd2luZyBjb25uZWN0QWR2YW5jZWQncyBzaG91bGRDb21wb25lbnRVcGRhdGUgdG8gcmV0dXJuIGZhbHNlIGlmIGZpbmFsXG4vLyBwcm9wcyBoYXZlIG5vdCBjaGFuZ2VkLiBJZiBmYWxzZSwgdGhlIHNlbGVjdG9yIHdpbGwgYWx3YXlzIHJldHVybiBhIG5ld1xuLy8gb2JqZWN0IGFuZCBzaG91bGRDb21wb25lbnRVcGRhdGUgd2lsbCBhbHdheXMgcmV0dXJuIHRydWUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkoZGlzcGF0Y2gsIF9yZWYyKSB7XG4gIHZhciBpbml0TWFwU3RhdGVUb1Byb3BzID0gX3JlZjIuaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBfcmVmMi5pbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHMgPSBfcmVmMi5pbml0TWVyZ2VQcm9wcyxcbiAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnaW5pdE1hcFN0YXRlVG9Qcm9wcycsICdpbml0TWFwRGlzcGF0Y2hUb1Byb3BzJywgJ2luaXRNZXJnZVByb3BzJ10pO1xuXG4gIHZhciBtYXBTdGF0ZVRvUHJvcHMgPSBpbml0TWFwU3RhdGVUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgdmFyIG1hcERpc3BhdGNoVG9Qcm9wcyA9IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICB2YXIgbWVyZ2VQcm9wcyA9IGluaXRNZXJnZVByb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgb3B0aW9ucy5kaXNwbGF5TmFtZSk7XG4gIH1cblxuICB2YXIgc2VsZWN0b3JGYWN0b3J5ID0gb3B0aW9ucy5wdXJlID8gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkgOiBpbXB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5O1xuXG4gIHJldHVybiBzZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3NlbGVjdG9yRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi4vdXRpbHMvd2FybmluZyc7XG5cbmZ1bmN0aW9uIHZlcmlmeShzZWxlY3RvciwgbWV0aG9kTmFtZSwgZGlzcGxheU5hbWUpIHtcbiAgaWYgKCFzZWxlY3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB2YWx1ZSBmb3IgJyArIG1ldGhvZE5hbWUgKyAnIGluICcgKyBkaXNwbGF5TmFtZSArICcuJyk7XG4gIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gJ21hcFN0YXRlVG9Qcm9wcycgfHwgbWV0aG9kTmFtZSA9PT0gJ21hcERpc3BhdGNoVG9Qcm9wcycpIHtcbiAgICBpZiAoIXNlbGVjdG9yLmhhc093blByb3BlcnR5KCdkZXBlbmRzT25Pd25Qcm9wcycpKSB7XG4gICAgICB3YXJuaW5nKCdUaGUgc2VsZWN0b3IgZm9yICcgKyBtZXRob2ROYW1lICsgJyBvZiAnICsgZGlzcGxheU5hbWUgKyAnIGRpZCBub3Qgc3BlY2lmeSBhIHZhbHVlIGZvciBkZXBlbmRzT25Pd25Qcm9wcy4nKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2ZXJpZnkobWFwU3RhdGVUb1Byb3BzLCAnbWFwU3RhdGVUb1Byb3BzJywgZGlzcGxheU5hbWUpO1xuICB2ZXJpZnkobWFwRGlzcGF0Y2hUb1Byb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJywgZGlzcGxheU5hbWUpO1xuICB2ZXJpZnkobWVyZ2VQcm9wcywgJ21lcmdlUHJvcHMnLCBkaXNwbGF5TmFtZSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC92ZXJpZnlTdWJzZWxlY3RvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSBcIndhcm5pbmdcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCB7IGNyZWF0ZUJyb3dzZXJIaXN0b3J5IGFzIGNyZWF0ZUhpc3RvcnkgfSBmcm9tIFwiaGlzdG9yeVwiO1xuaW1wb3J0IFJvdXRlciBmcm9tIFwiLi9Sb3V0ZXJcIjtcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHVzZXMgSFRNTDUgaGlzdG9yeS5cbiAqL1xuXG52YXIgQnJvd3NlclJvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhCcm93c2VyUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBCcm93c2VyUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJvd3NlclJvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGlzdG9yeSA9IGNyZWF0ZUhpc3RvcnkoX3RoaXMucHJvcHMpLCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIEJyb3dzZXJSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksIFwiPEJyb3dzZXJSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksIFwiICsgXCJ1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBCcm93c2VyUm91dGVyIGFzIFJvdXRlciB9YC5cIik7XG4gIH07XG5cbiAgQnJvd3NlclJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBCcm93c2VyUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Ccm93c2VyUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGZvcmNlUmVmcmVzaDogUHJvcFR5cGVzLmJvb2wsXG4gIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICBrZXlMZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBCcm93c2VyUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvQnJvd3NlclJvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmltcG9ydCB7IGFkZExlYWRpbmdTbGFzaCwgc3RyaXBUcmFpbGluZ1NsYXNoLCBoYXNCYXNlbmFtZSwgc3RyaXBCYXNlbmFtZSwgY3JlYXRlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcbmltcG9ydCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciBmcm9tICcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJztcbmltcG9ydCB7IGNhblVzZURPTSwgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgZ2V0Q29uZmlybWF0aW9uLCBzdXBwb3J0c0hpc3RvcnksIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UsIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgfSBmcm9tICcuL0RPTVV0aWxzJztcblxudmFyIFBvcFN0YXRlRXZlbnQgPSAncG9wc3RhdGUnO1xudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIGdldEhpc3RvcnlTdGF0ZSA9IGZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwge307XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJRSAxMSBzb21ldGltZXMgdGhyb3dzIHdoZW4gYWNjZXNzaW5nIHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdFRyYWluaW5nL2hpc3RvcnkvcHVsbC8yODlcbiAgICByZXR1cm4ge307XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgdXNlcyB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaW5jbHVkaW5nXG4gKiBwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudC5cbiAqL1xudmFyIGNyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgaW52YXJpYW50KGNhblVzZURPTSwgJ0Jyb3dzZXIgaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Vc2VIaXN0b3J5ID0gc3VwcG9ydHNIaXN0b3J5KCk7XG4gIHZhciBuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lciA9ICFzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCk7XG5cbiAgdmFyIF9wcm9wcyRmb3JjZVJlZnJlc2ggPSBwcm9wcy5mb3JjZVJlZnJlc2gsXG4gICAgICBmb3JjZVJlZnJlc2ggPSBfcHJvcHMkZm9yY2VSZWZyZXNoID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9wcm9wcyRmb3JjZVJlZnJlc2gsXG4gICAgICBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gc3RyaXBUcmFpbGluZ1NsYXNoKGFkZExlYWRpbmdTbGFzaChwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG5cbiAgdmFyIGdldERPTUxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oaGlzdG9yeVN0YXRlKSB7XG4gICAgdmFyIF9yZWYgPSBoaXN0b3J5U3RhdGUgfHwge30sXG4gICAgICAgIGtleSA9IF9yZWYua2V5LFxuICAgICAgICBzdGF0ZSA9IF9yZWYuc3RhdGU7XG5cbiAgICB2YXIgX3dpbmRvdyRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbixcbiAgICAgICAgcGF0aG5hbWUgPSBfd2luZG93JGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2ggPSBfd2luZG93JGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzaCA9IF93aW5kb3ckbG9jYXRpb24uaGFzaDtcblxuXG4gICAgdmFyIHBhdGggPSBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG5cbiAgICB3YXJuaW5nKCFiYXNlbmFtZSB8fCBoYXNCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gc3RyaXBCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGtleSk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcFN0YXRlID0gZnVuY3Rpb24gaGFuZGxlUG9wU3RhdGUoZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0LlxuICAgIGlmIChpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGV2ZW50LnN0YXRlKSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSkpO1xuICB9O1xuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIGtleXMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3Iga2V5cyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxLZXlzLmluZGV4T2YodG9Mb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxLZXlzLmluZGV4T2YoZnJvbUxvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSk7XG4gIHZhciBhbGxLZXlzID0gW2luaXRpYWxMb2NhdGlvbi5rZXldO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gYmFzZW5hbWUgKyBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIHZhciBuZXh0S2V5cyA9IGFsbEtleXMuc2xpY2UoMCwgcHJldkluZGV4ID09PSAtMSA/IDAgOiBwcmV2SW5kZXggKyAxKTtcblxuICAgICAgICAgIG5leHRLZXlzLnB1c2gobG9jYXRpb24ua2V5KTtcbiAgICAgICAgICBhbGxLZXlzID0gbmV4dEtleXM7XG5cbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKTtcblxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleToga2V5LCBzdGF0ZTogc3RhdGUgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuXG4gICAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbEtleXNbcHJldkluZGV4XSA9IGxvY2F0aW9uLmtleTtcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgdmFyIGNoZWNrRE9NTGlzdGVuZXJzID0gZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuXG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpIHJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQnJvd3Nlckhpc3Rvcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVCcm93c2VySGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiZnVuY3Rpb24gaXNBYnNvbHV0ZShwYXRobmFtZSkge1xuICByZXR1cm4gcGF0aG5hbWUuY2hhckF0KDApID09PSAnLyc7XG59XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKVxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSkge1xuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICB9XG5cbiAgbGlzdC5wb3AoKTtcbn1cblxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBoZWF2aWx5IG9uIG5vZGUncyB1cmwucGFyc2VcbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZSh0bykge1xuICB2YXIgZnJvbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG5cbiAgdmFyIHRvUGFydHMgPSB0byAmJiB0by5zcGxpdCgnLycpIHx8IFtdO1xuICB2YXIgZnJvbVBhcnRzID0gZnJvbSAmJiBmcm9tLnNwbGl0KCcvJykgfHwgW107XG5cbiAgdmFyIGlzVG9BYnMgPSB0byAmJiBpc0Fic29sdXRlKHRvKTtcbiAgdmFyIGlzRnJvbUFicyA9IGZyb20gJiYgaXNBYnNvbHV0ZShmcm9tKTtcbiAgdmFyIG11c3RFbmRBYnMgPSBpc1RvQWJzIHx8IGlzRnJvbUFicztcblxuICBpZiAodG8gJiYgaXNBYnNvbHV0ZSh0bykpIHtcbiAgICAvLyB0byBpcyBhYnNvbHV0ZVxuICAgIGZyb21QYXJ0cyA9IHRvUGFydHM7XG4gIH0gZWxzZSBpZiAodG9QYXJ0cy5sZW5ndGgpIHtcbiAgICAvLyB0byBpcyByZWxhdGl2ZSwgZHJvcCB0aGUgZmlsZW5hbWVcbiAgICBmcm9tUGFydHMucG9wKCk7XG4gICAgZnJvbVBhcnRzID0gZnJvbVBhcnRzLmNvbmNhdCh0b1BhcnRzKTtcbiAgfVxuXG4gIGlmICghZnJvbVBhcnRzLmxlbmd0aCkgcmV0dXJuICcvJztcblxuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IHZvaWQgMDtcbiAgaWYgKGZyb21QYXJ0cy5sZW5ndGgpIHtcbiAgICB2YXIgbGFzdCA9IGZyb21QYXJ0c1tmcm9tUGFydHMubGVuZ3RoIC0gMV07XG4gICAgaGFzVHJhaWxpbmdTbGFzaCA9IGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nIHx8IGxhc3QgPT09ICcnO1xuICB9IGVsc2Uge1xuICAgIGhhc1RyYWlsaW5nU2xhc2ggPSBmYWxzZTtcbiAgfVxuXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBmcm9tUGFydHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIHZhciBwYXJ0ID0gZnJvbVBhcnRzW2ldO1xuXG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbXVzdEVuZEFicykgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgZnJvbVBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gIH1pZiAobXVzdEVuZEFicyAmJiBmcm9tUGFydHNbMF0gIT09ICcnICYmICghZnJvbVBhcnRzWzBdIHx8ICFpc0Fic29sdXRlKGZyb21QYXJ0c1swXSkpKSBmcm9tUGFydHMudW5zaGlmdCgnJyk7XG5cbiAgdmFyIHJlc3VsdCA9IGZyb21QYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgcmVzdWx0LnN1YnN0cigtMSkgIT09ICcvJykgcmVzdWx0ICs9ICcvJztcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCByZXNvbHZlUGF0aG5hbWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVzb2x2ZS1wYXRobmFtZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiB2YWx1ZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiB2YWx1ZUVxdWFsKGl0ZW0sIGJbaW5kZXhdKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBhVHlwZSA9IHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhKTtcbiAgdmFyIGJUeXBlID0gdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGIpO1xuXG4gIGlmIChhVHlwZSAhPT0gYlR5cGUpIHJldHVybiBmYWxzZTtcblxuICBpZiAoYVR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGFWYWx1ZSA9IGEudmFsdWVPZigpO1xuICAgIHZhciBiVmFsdWUgPSBiLnZhbHVlT2YoKTtcblxuICAgIGlmIChhVmFsdWUgIT09IGEgfHwgYlZhbHVlICE9PSBiKSByZXR1cm4gdmFsdWVFcXVhbChhVmFsdWUsIGJWYWx1ZSk7XG5cbiAgICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcblxuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIGFLZXlzLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiB2YWx1ZUVxdWFsKGFba2V5XSwgYltrZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsdWVFcXVhbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92YWx1ZS1lcXVhbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgeyBjcmVhdGVMb2NhdGlvbiwgbG9jYXRpb25zQXJlRXF1YWwgfSBmcm9tICcuL0xvY2F0aW9uVXRpbHMnO1xuaW1wb3J0IHsgYWRkTGVhZGluZ1NsYXNoLCBzdHJpcExlYWRpbmdTbGFzaCwgc3RyaXBUcmFpbGluZ1NsYXNoLCBoYXNCYXNlbmFtZSwgc3RyaXBCYXNlbmFtZSwgY3JlYXRlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcbmltcG9ydCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciBmcm9tICcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJztcbmltcG9ydCB7IGNhblVzZURPTSwgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgZ2V0Q29uZmlybWF0aW9uLCBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCB9IGZyb20gJy4vRE9NVXRpbHMnO1xuXG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgSGFzaFBhdGhDb2RlcnMgPSB7XG4gIGhhc2hiYW5nOiB7XG4gICAgZW5jb2RlUGF0aDogZnVuY3Rpb24gZW5jb2RlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICchJyA/IHBhdGggOiAnIS8nICsgc3RyaXBMZWFkaW5nU2xhc2gocGF0aCk7XG4gICAgfSxcbiAgICBkZWNvZGVQYXRoOiBmdW5jdGlvbiBkZWNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xuICAgIH1cbiAgfSxcbiAgbm9zbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IHN0cmlwTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaFxuICB9LFxuICBzbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2hcbiAgfVxufTtcblxudmFyIGdldEhhc2hQYXRoID0gZnVuY3Rpb24gZ2V0SGFzaFBhdGgoKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcbiAgLy8gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgLSBGaXJlZm94IHdpbGwgcHJlLWRlY29kZSBpdCFcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGhhc2hJbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICByZXR1cm4gaGFzaEluZGV4ID09PSAtMSA/ICcnIDogaHJlZi5zdWJzdHJpbmcoaGFzaEluZGV4ICsgMSk7XG59O1xuXG52YXIgcHVzaEhhc2hQYXRoID0gZnVuY3Rpb24gcHVzaEhhc2hQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbn07XG5cbnZhciByZXBsYWNlSGFzaFBhdGggPSBmdW5jdGlvbiByZXBsYWNlSGFzaFBhdGgocGF0aCkge1xuICB2YXIgaGFzaEluZGV4ID0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZignIycpO1xuXG4gIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNsaWNlKDAsIGhhc2hJbmRleCA+PSAwID8gaGFzaEluZGV4IDogMCkgKyAnIycgKyBwYXRoKTtcbn07XG5cbnZhciBjcmVhdGVIYXNoSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIGludmFyaWFudChjYW5Vc2VET00sICdIYXNoIGhpc3RvcnkgbmVlZHMgYSBET00nKTtcblxuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuR29XaXRob3V0UmVsb2FkID0gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKTtcblxuICB2YXIgX3Byb3BzJGdldFVzZXJDb25maXJtID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHVuZGVmaW5lZCA/IGdldENvbmZpcm1hdGlvbiA6IF9wcm9wcyRnZXRVc2VyQ29uZmlybSxcbiAgICAgIF9wcm9wcyRoYXNoVHlwZSA9IHByb3BzLmhhc2hUeXBlLFxuICAgICAgaGFzaFR5cGUgPSBfcHJvcHMkaGFzaFR5cGUgPT09IHVuZGVmaW5lZCA/ICdzbGFzaCcgOiBfcHJvcHMkaGFzaFR5cGU7XG5cbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyBzdHJpcFRyYWlsaW5nU2xhc2goYWRkTGVhZGluZ1NsYXNoKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgX0hhc2hQYXRoQ29kZXJzJGhhc2hUID0gSGFzaFBhdGhDb2RlcnNbaGFzaFR5cGVdLFxuICAgICAgZW5jb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5lbmNvZGVQYXRoLFxuICAgICAgZGVjb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5kZWNvZGVQYXRoO1xuXG5cbiAgdmFyIGdldERPTUxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oKSB7XG4gICAgdmFyIHBhdGggPSBkZWNvZGVQYXRoKGdldEhhc2hQYXRoKCkpO1xuXG4gICAgd2FybmluZyghYmFzZW5hbWUgfHwgaGFzQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpLCAnWW91IGFyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGJhc2VuYW1lIG9uIGEgcGFnZSB3aG9zZSBVUkwgcGF0aCBkb2VzIG5vdCBiZWdpbiAnICsgJ3dpdGggdGhlIGJhc2VuYW1lLiBFeHBlY3RlZCBwYXRoIFwiJyArIHBhdGggKyAnXCIgdG8gYmVnaW4gd2l0aCBcIicgKyBiYXNlbmFtZSArICdcIi4nKTtcblxuICAgIGlmIChiYXNlbmFtZSkgcGF0aCA9IHN0cmlwQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKHBhdGgpO1xuICB9O1xuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gZ2xvYmFsSGlzdG9yeS5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgdmFyIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gIHZhciBoYW5kbGVIYXNoQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICAgIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkge1xuICAgICAgLy8gRW5zdXJlIHdlIGFsd2F5cyBoYXZlIGEgcHJvcGVybHktZW5jb2RlZCBoYXNoLlxuICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oKTtcbiAgICAgIHZhciBwcmV2TG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgICBpZiAoIWZvcmNlTmV4dFBvcCAmJiBsb2NhdGlvbnNBcmVFcXVhbChwcmV2TG9jYXRpb24sIGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBBIGhhc2hjaGFuZ2UgZG9lc24ndCBhbHdheXMgPT0gbG9jYXRpb24gY2hhbmdlLlxuXG4gICAgICBpZiAoaWdub3JlUGF0aCA9PT0gY3JlYXRlUGF0aChsb2NhdGlvbikpIHJldHVybjsgLy8gSWdub3JlIHRoaXMgY2hhbmdlOyB3ZSBhbHJlYWR5IHNldFN0YXRlIGluIHB1c2gvcmVwbGFjZS5cblxuICAgICAgaWdub3JlUGF0aCA9IG51bGw7XG5cbiAgICAgIGhhbmRsZVBvcChsb2NhdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVQb3AgPSBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcblxuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmV2ZXJ0UG9wID0gZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgIC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2YgcGF0aHMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3IgcGF0aHMgd2UgZG9uJ3Qga25vdy5cblxuICAgIHZhciB0b0luZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aCh0b0xvY2F0aW9uKSk7XG5cbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuXG4gICAgdmFyIGZyb21JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgoZnJvbUxvY2F0aW9uKSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVuc3VyZSB0aGUgaGFzaCBpcyBlbmNvZGVkIHByb3Blcmx5IGJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlLlxuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICB2YXIgYWxsUGF0aHMgPSBbY3JlYXRlUGF0aChpbml0aWFsTG9jYXRpb24pXTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuICcjJyArIGVuY29kZVBhdGgoYmFzZW5hbWUgKyBjcmVhdGVQYXRoKGxvY2F0aW9uKSk7XG4gIH07XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwYXRoID0gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gICAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKGJhc2VuYW1lICsgcGF0aCk7XG4gICAgICB2YXIgaGFzaENoYW5nZWQgPSBnZXRIYXNoUGF0aCgpICE9PSBlbmNvZGVkUGF0aDtcblxuICAgICAgaWYgKGhhc2hDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB0ZWxsIGlmIGEgaGFzaGNoYW5nZSB3YXMgY2F1c2VkIGJ5IGEgUFVTSCwgc28gd2UnZFxuICAgICAgICAvLyByYXRoZXIgc2V0U3RhdGUgaGVyZSBhbmQgaWdub3JlIHRoZSBoYXNoY2hhbmdlLiBUaGUgY2F2ZWF0IGhlcmVcbiAgICAgICAgLy8gaXMgdGhhdCBvdGhlciBoYXNoIGhpc3RvcmllcyBpbiB0aGUgcGFnZSB3aWxsIGNvbnNpZGVyIGl0IGEgUE9QLlxuICAgICAgICBpZ25vcmVQYXRoID0gcGF0aDtcbiAgICAgICAgcHVzaEhhc2hQYXRoKGVuY29kZWRQYXRoKTtcblxuICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aChoaXN0b3J5LmxvY2F0aW9uKSk7XG4gICAgICAgIHZhciBuZXh0UGF0aHMgPSBhbGxQYXRocy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgIG5leHRQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICBhbGxQYXRocyA9IG5leHRQYXRocztcblxuICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGg7IGEgbmV3IGVudHJ5IHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrJyk7XG5cbiAgICAgICAgc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHBhdGggPSBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBSRVBMQUNFLCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMuaW5kZXhPZihjcmVhdGVQYXRoKGhpc3RvcnkubG9jYXRpb24pKTtcblxuICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbFBhdGhzW3ByZXZJbmRleF0gPSBwYXRoO1xuXG4gICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIHdhcm5pbmcoY2FuR29XaXRob3V0UmVsb2FkLCAnSGFzaCBoaXN0b3J5IGdvKG4pIGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQgaW4gdGhpcyBicm93c2VyJyk7XG5cbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgdmFyIGNoZWNrRE9NTGlzdGVuZXJzID0gZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJDb3VudCA9PT0gMCkge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVIYXNoSGlzdG9yeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUhhc2hIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IHsgY3JlYXRlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmltcG9ydCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciBmcm9tICcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJztcblxudmFyIGNsYW1wID0gZnVuY3Rpb24gY2xhbXAobiwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCBzdG9yZXMgbG9jYXRpb25zIGluIG1lbW9yeS5cbiAqL1xudmFyIGNyZWF0ZU1lbW9yeUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPSBwcm9wcy5pbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxFbnRyaWVzID0gX3Byb3BzJGluaXRpYWxFbnRyaWVzID09PSB1bmRlZmluZWQgPyBbJy8nXSA6IF9wcm9wcyRpbml0aWFsRW50cmllcyxcbiAgICAgIF9wcm9wcyRpbml0aWFsSW5kZXggPSBwcm9wcy5pbml0aWFsSW5kZXgsXG4gICAgICBpbml0aWFsSW5kZXggPSBfcHJvcHMkaW5pdGlhbEluZGV4ID09PSB1bmRlZmluZWQgPyAwIDogX3Byb3BzJGluaXRpYWxJbmRleCxcbiAgICAgIF9wcm9wcyRrZXlMZW5ndGggPSBwcm9wcy5rZXlMZW5ndGgsXG4gICAgICBrZXlMZW5ndGggPSBfcHJvcHMka2V5TGVuZ3RoID09PSB1bmRlZmluZWQgPyA2IDogX3Byb3BzJGtleUxlbmd0aDtcblxuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gaGlzdG9yeS5lbnRyaWVzLmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIGluZGV4ID0gY2xhbXAoaW5pdGlhbEluZGV4LCAwLCBpbml0aWFsRW50cmllcy5sZW5ndGggLSAxKTtcbiAgdmFyIGVudHJpZXMgPSBpbml0aWFsRW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycgPyBjcmVhdGVMb2NhdGlvbihlbnRyeSwgdW5kZWZpbmVkLCBjcmVhdGVLZXkoKSkgOiBjcmVhdGVMb2NhdGlvbihlbnRyeSwgdW5kZWZpbmVkLCBlbnRyeS5rZXkgfHwgY3JlYXRlS2V5KCkpO1xuICB9KTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBjcmVhdGVQYXRoO1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBoaXN0b3J5LmluZGV4O1xuICAgICAgdmFyIG5leHRJbmRleCA9IHByZXZJbmRleCArIDE7XG5cbiAgICAgIHZhciBuZXh0RW50cmllcyA9IGhpc3RvcnkuZW50cmllcy5zbGljZSgwKTtcbiAgICAgIGlmIChuZXh0RW50cmllcy5sZW5ndGggPiBuZXh0SW5kZXgpIHtcbiAgICAgICAgbmV4dEVudHJpZXMuc3BsaWNlKG5leHRJbmRleCwgbmV4dEVudHJpZXMubGVuZ3RoIC0gbmV4dEluZGV4LCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0RW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICBlbnRyaWVzOiBuZXh0RW50cmllc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgaGlzdG9yeS5lbnRyaWVzW2hpc3RvcnkuaW5kZXhdID0gbG9jYXRpb247XG5cbiAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGNsYW1wKGhpc3RvcnkuaW5kZXggKyBuLCAwLCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoIC0gMSk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG4gICAgdmFyIGxvY2F0aW9uID0gaGlzdG9yeS5lbnRyaWVzW25leHRJbmRleF07XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKG9rKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgaW5kZXg6IG5leHRJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1pbWljIHRoZSBiZWhhdmlvciBvZiBET00gaGlzdG9yaWVzIGJ5XG4gICAgICAgIC8vIGNhdXNpbmcgYSByZW5kZXIgYWZ0ZXIgYSBjYW5jZWxsZWQgUE9QLlxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgY2FuR28gPSBmdW5jdGlvbiBjYW5HbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGhpc3RvcnkuaW5kZXggKyBuO1xuICAgIHJldHVybiBuZXh0SW5kZXggPj0gMCAmJiBuZXh0SW5kZXggPCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuICB9O1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGVudHJpZXMubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGVudHJpZXNbaW5kZXhdLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBlbnRyaWVzOiBlbnRyaWVzLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBjYW5HbzogY2FuR28sXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVNZW1vcnlIaXN0b3J5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlTWVtb3J5SGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tIFwid2FybmluZ1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IHsgY3JlYXRlSGFzaEhpc3RvcnkgYXMgY3JlYXRlSGlzdG9yeSB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQgUm91dGVyIGZyb20gXCIuL1JvdXRlclwiO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgdXNlcyB3aW5kb3cubG9jYXRpb24uaGFzaC5cbiAqL1xuXG52YXIgSGFzaFJvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhIYXNoUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBIYXNoUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGFzaFJvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGlzdG9yeSA9IGNyZWF0ZUhpc3RvcnkoX3RoaXMucHJvcHMpLCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIEhhc2hSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksIFwiPEhhc2hSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksIFwiICsgXCJ1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBIYXNoUm91dGVyIGFzIFJvdXRlciB9YC5cIik7XG4gIH07XG5cbiAgSGFzaFJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBIYXNoUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5IYXNoUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICBoYXNoVHlwZTogUHJvcFR5cGVzLm9uZU9mKFtcImhhc2hiYW5nXCIsIFwibm9zbGFzaFwiLCBcInNsYXNoXCJdKSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IEhhc2hSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9IYXNoUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IE1lbW9yeVJvdXRlciBmcm9tIFwicmVhY3Qtcm91dGVyL2VzL01lbW9yeVJvdXRlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBNZW1vcnlSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9NZW1vcnlSb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSBcIndhcm5pbmdcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCB7IGNyZWF0ZU1lbW9yeUhpc3RvcnkgYXMgY3JlYXRlSGlzdG9yeSB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQgUm91dGVyIGZyb20gXCIuL1JvdXRlclwiO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgc3RvcmVzIGxvY2F0aW9uIGluIG1lbW9yeS5cbiAqL1xuXG52YXIgTWVtb3J5Um91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1lbW9yeVJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTWVtb3J5Um91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVtb3J5Um91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShfdGhpcy5wcm9wcyksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgTWVtb3J5Um91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCBcIjxNZW1vcnlSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksIFwiICsgXCJ1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBNZW1vcnlSb3V0ZXIgYXMgUm91dGVyIH1gLlwiKTtcbiAgfTtcblxuICBNZW1vcnlSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHsgaGlzdG9yeTogdGhpcy5oaXN0b3J5LCBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlbiB9KTtcbiAgfTtcblxuICByZXR1cm4gTWVtb3J5Um91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5NZW1vcnlSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBpbml0aWFsRW50cmllczogUHJvcFR5cGVzLmFycmF5LFxuICBpbml0aWFsSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICBrZXlMZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBNZW1vcnlSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL01lbW9yeVJvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCBSb3V0ZSBmcm9tIFwiLi9Sb3V0ZVwiO1xuaW1wb3J0IExpbmsgZnJvbSBcIi4vTGlua1wiO1xuXG4vKipcbiAqIEEgPExpbms+IHdyYXBwZXIgdGhhdCBrbm93cyBpZiBpdCdzIFwiYWN0aXZlXCIgb3Igbm90LlxuICovXG52YXIgTmF2TGluayA9IGZ1bmN0aW9uIE5hdkxpbmsoX3JlZikge1xuICB2YXIgdG8gPSBfcmVmLnRvLFxuICAgICAgZXhhY3QgPSBfcmVmLmV4YWN0LFxuICAgICAgc3RyaWN0ID0gX3JlZi5zdHJpY3QsXG4gICAgICBsb2NhdGlvbiA9IF9yZWYubG9jYXRpb24sXG4gICAgICBhY3RpdmVDbGFzc05hbWUgPSBfcmVmLmFjdGl2ZUNsYXNzTmFtZSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgYWN0aXZlU3R5bGUgPSBfcmVmLmFjdGl2ZVN0eWxlLFxuICAgICAgc3R5bGUgPSBfcmVmLnN0eWxlLFxuICAgICAgZ2V0SXNBY3RpdmUgPSBfcmVmLmlzQWN0aXZlLFxuICAgICAgYXJpYUN1cnJlbnQgPSBfcmVmW1wiYXJpYS1jdXJyZW50XCJdLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJ0b1wiLCBcImV4YWN0XCIsIFwic3RyaWN0XCIsIFwibG9jYXRpb25cIiwgXCJhY3RpdmVDbGFzc05hbWVcIiwgXCJjbGFzc05hbWVcIiwgXCJhY3RpdmVTdHlsZVwiLCBcInN0eWxlXCIsIFwiaXNBY3RpdmVcIiwgXCJhcmlhLWN1cnJlbnRcIl0pO1xuXG4gIHZhciBwYXRoID0gKHR5cGVvZiB0byA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHRvKSkgPT09IFwib2JqZWN0XCIgPyB0by5wYXRobmFtZSA6IHRvO1xuXG4gIC8vIFJlZ2V4IHRha2VuIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9waWxsYXJqcy9wYXRoLXRvLXJlZ2V4cC9ibG9iL21hc3Rlci9pbmRleC5qcyNMMjAyXG4gIHZhciBlc2NhcGVkUGF0aCA9IHBhdGggJiYgcGF0aC5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfC9cXFxcXSkvZywgXCJcXFxcJDFcIik7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHtcbiAgICBwYXRoOiBlc2NhcGVkUGF0aCxcbiAgICBleGFjdDogZXhhY3QsXG4gICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIGNoaWxkcmVuOiBmdW5jdGlvbiBjaGlsZHJlbihfcmVmMikge1xuICAgICAgdmFyIGxvY2F0aW9uID0gX3JlZjIubG9jYXRpb24sXG4gICAgICAgICAgbWF0Y2ggPSBfcmVmMi5tYXRjaDtcblxuICAgICAgdmFyIGlzQWN0aXZlID0gISEoZ2V0SXNBY3RpdmUgPyBnZXRJc0FjdGl2ZShtYXRjaCwgbG9jYXRpb24pIDogbWF0Y2gpO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChMaW5rLCBfZXh0ZW5kcyh7XG4gICAgICAgIHRvOiB0byxcbiAgICAgICAgY2xhc3NOYW1lOiBpc0FjdGl2ZSA/IFtjbGFzc05hbWUsIGFjdGl2ZUNsYXNzTmFtZV0uZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0pLmpvaW4oXCIgXCIpIDogY2xhc3NOYW1lLFxuICAgICAgICBzdHlsZTogaXNBY3RpdmUgPyBfZXh0ZW5kcyh7fSwgc3R5bGUsIGFjdGl2ZVN0eWxlKSA6IHN0eWxlLFxuICAgICAgICBcImFyaWEtY3VycmVudFwiOiBpc0FjdGl2ZSAmJiBhcmlhQ3VycmVudCB8fCBudWxsXG4gICAgICB9LCByZXN0KSk7XG4gICAgfVxuICB9KTtcbn07XG5cbk5hdkxpbmsucHJvcFR5cGVzID0ge1xuICB0bzogTGluay5wcm9wVHlwZXMudG8sXG4gIGV4YWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgc3RyaWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3QsXG4gIGFjdGl2ZUNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBhY3RpdmVTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIGlzQWN0aXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgXCJhcmlhLWN1cnJlbnRcIjogUHJvcFR5cGVzLm9uZU9mKFtcInBhZ2VcIiwgXCJzdGVwXCIsIFwibG9jYXRpb25cIiwgXCJkYXRlXCIsIFwidGltZVwiLCBcInRydWVcIl0pXG59O1xuXG5OYXZMaW5rLmRlZmF1bHRQcm9wcyA9IHtcbiAgYWN0aXZlQ2xhc3NOYW1lOiBcImFjdGl2ZVwiLFxuICBcImFyaWEtY3VycmVudFwiOiBcInBhZ2VcIlxufTtcblxuZXhwb3J0IGRlZmF1bHQgTmF2TGluaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL05hdkxpbmsuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgUHJvbXB0IGZyb20gXCJyZWFjdC1yb3V0ZXIvZXMvUHJvbXB0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IFByb21wdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1Byb21wdC5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gXCJwcm9wLXR5cGVzXCI7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gXCJpbnZhcmlhbnRcIjtcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcHJvbXB0aW5nIHRoZSB1c2VyIGJlZm9yZSBuYXZpZ2F0aW5nIGF3YXlcbiAqIGZyb20gYSBzY3JlZW4gd2l0aCBhIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgUHJvbXB0ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFByb21wdCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUHJvbXB0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9tcHQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBQcm9tcHQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZShtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMudW5ibG9jaykgdGhpcy51bmJsb2NrKCk7XG5cbiAgICB0aGlzLnVuYmxvY2sgPSB0aGlzLmNvbnRleHQucm91dGVyLmhpc3RvcnkuYmxvY2sobWVzc2FnZSk7XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy51bmJsb2NrKSB7XG4gICAgICB0aGlzLnVuYmxvY2soKTtcbiAgICAgIHRoaXMudW5ibG9jayA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCBcIllvdSBzaG91bGQgbm90IHVzZSA8UHJvbXB0PiBvdXRzaWRlIGEgPFJvdXRlcj5cIik7XG5cbiAgICBpZiAodGhpcy5wcm9wcy53aGVuKSB0aGlzLmVuYWJsZSh0aGlzLnByb3BzLm1lc3NhZ2UpO1xuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy53aGVuKSB7XG4gICAgICBpZiAoIXRoaXMucHJvcHMud2hlbiB8fCB0aGlzLnByb3BzLm1lc3NhZ2UgIT09IG5leHRQcm9wcy5tZXNzYWdlKSB0aGlzLmVuYWJsZShuZXh0UHJvcHMubWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH1cbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5kaXNhYmxlKCk7XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFByb21wdDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUHJvbXB0LnByb3BUeXBlcyA9IHtcbiAgd2hlbjogUHJvcFR5cGVzLmJvb2wsXG4gIG1lc3NhZ2U6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuc3RyaW5nXSkuaXNSZXF1aXJlZFxufTtcblByb21wdC5kZWZhdWx0UHJvcHMgPSB7XG4gIHdoZW46IHRydWVcbn07XG5Qcm9tcHQuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIGJsb2NrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gICAgfSkuaXNSZXF1aXJlZFxuICB9KS5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFByb21wdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUHJvbXB0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFJlZGlyZWN0IGZyb20gXCJyZWFjdC1yb3V0ZXIvZXMvUmVkaXJlY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgUmVkaXJlY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9SZWRpcmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gXCJwcm9wLXR5cGVzXCI7XG5pbXBvcnQgd2FybmluZyBmcm9tIFwid2FybmluZ1wiO1xuaW1wb3J0IGludmFyaWFudCBmcm9tIFwiaW52YXJpYW50XCI7XG5pbXBvcnQgeyBjcmVhdGVMb2NhdGlvbiwgbG9jYXRpb25zQXJlRXF1YWwgfSBmcm9tIFwiaGlzdG9yeVwiO1xuaW1wb3J0IGdlbmVyYXRlUGF0aCBmcm9tIFwiLi9nZW5lcmF0ZVBhdGhcIjtcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgdXBkYXRpbmcgdGhlIGxvY2F0aW9uIHByb2dyYW1tYXRpY2FsbHlcbiAqIHdpdGggYSBjb21wb25lbnQuXG4gKi9cblxudmFyIFJlZGlyZWN0ID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJlZGlyZWN0LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSZWRpcmVjdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVkaXJlY3QpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBSZWRpcmVjdC5wcm90b3R5cGUuaXNTdGF0aWMgPSBmdW5jdGlvbiBpc1N0YXRpYygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnJvdXRlciAmJiB0aGlzLmNvbnRleHQucm91dGVyLnN0YXRpY0NvbnRleHQ7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBpbnZhcmlhbnQodGhpcy5jb250ZXh0LnJvdXRlciwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFJlZGlyZWN0PiBvdXRzaWRlIGEgPFJvdXRlcj5cIik7XG5cbiAgICBpZiAodGhpcy5pc1N0YXRpYygpKSB0aGlzLnBlcmZvcm0oKTtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdGF0aWMoKSkgdGhpcy5wZXJmb3JtKCk7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICB2YXIgcHJldlRvID0gY3JlYXRlTG9jYXRpb24ocHJldlByb3BzLnRvKTtcbiAgICB2YXIgbmV4dFRvID0gY3JlYXRlTG9jYXRpb24odGhpcy5wcm9wcy50byk7XG5cbiAgICBpZiAobG9jYXRpb25zQXJlRXF1YWwocHJldlRvLCBuZXh0VG8pKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCBcIllvdSB0cmllZCB0byByZWRpcmVjdCB0byB0aGUgc2FtZSByb3V0ZSB5b3UncmUgY3VycmVudGx5IG9uOiBcIiArIChcIlxcXCJcIiArIG5leHRUby5wYXRobmFtZSArIG5leHRUby5zZWFyY2ggKyBcIlxcXCJcIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGVyZm9ybSgpO1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5jb21wdXRlVG8gPSBmdW5jdGlvbiBjb21wdXRlVG8oX3JlZikge1xuICAgIHZhciBjb21wdXRlZE1hdGNoID0gX3JlZi5jb21wdXRlZE1hdGNoLFxuICAgICAgICB0byA9IF9yZWYudG87XG5cbiAgICBpZiAoY29tcHV0ZWRNYXRjaCkge1xuICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGVQYXRoKHRvLCBjb21wdXRlZE1hdGNoLnBhcmFtcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHRvLCB7XG4gICAgICAgICAgcGF0aG5hbWU6IGdlbmVyYXRlUGF0aCh0by5wYXRobmFtZSwgY29tcHV0ZWRNYXRjaC5wYXJhbXMpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0bztcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uIHBlcmZvcm0oKSB7XG4gICAgdmFyIGhpc3RvcnkgPSB0aGlzLmNvbnRleHQucm91dGVyLmhpc3Rvcnk7XG4gICAgdmFyIHB1c2ggPSB0aGlzLnByb3BzLnB1c2g7XG5cbiAgICB2YXIgdG8gPSB0aGlzLmNvbXB1dGVUbyh0aGlzLnByb3BzKTtcblxuICAgIGlmIChwdXNoKSB7XG4gICAgICBoaXN0b3J5LnB1c2godG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2UodG8pO1xuICAgIH1cbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSZWRpcmVjdDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUmVkaXJlY3QucHJvcFR5cGVzID0ge1xuICBjb21wdXRlZE1hdGNoOiBQcm9wVHlwZXMub2JqZWN0LCAvLyBwcml2YXRlLCBmcm9tIDxTd2l0Y2g+XG4gIHB1c2g6IFByb3BUeXBlcy5ib29sLFxuICBmcm9tOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0bzogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pLmlzUmVxdWlyZWRcbn07XG5SZWRpcmVjdC5kZWZhdWx0UHJvcHMgPSB7XG4gIHB1c2g6IGZhbHNlXG59O1xuUmVkaXJlY3QuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIHB1c2g6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICByZXBsYWNlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gICAgfSkuaXNSZXF1aXJlZCxcbiAgICBzdGF0aWNDb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0XG4gIH0pLmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUmVkaXJlY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JlZGlyZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFN0YXRpY1JvdXRlciBmcm9tIFwicmVhY3Qtcm91dGVyL2VzL1N0YXRpY1JvdXRlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBTdGF0aWNSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9TdGF0aWNSb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tIFwid2FybmluZ1wiO1xuaW1wb3J0IGludmFyaWFudCBmcm9tIFwiaW52YXJpYW50XCI7XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gXCJwcm9wLXR5cGVzXCI7XG5pbXBvcnQgeyBjcmVhdGVMb2NhdGlvbiwgY3JlYXRlUGF0aCB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQgUm91dGVyIGZyb20gXCIuL1JvdXRlclwiO1xuXG52YXIgYWRkTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gYWRkTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSBcIi9cIiA/IHBhdGggOiBcIi9cIiArIHBhdGg7XG59O1xuXG52YXIgYWRkQmFzZW5hbWUgPSBmdW5jdGlvbiBhZGRCYXNlbmFtZShiYXNlbmFtZSwgbG9jYXRpb24pIHtcbiAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICBwYXRobmFtZTogYWRkTGVhZGluZ1NsYXNoKGJhc2VuYW1lKSArIGxvY2F0aW9uLnBhdGhuYW1lXG4gIH0pO1xufTtcblxudmFyIHN0cmlwQmFzZW5hbWUgPSBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKGJhc2VuYW1lLCBsb2NhdGlvbikge1xuICBpZiAoIWJhc2VuYW1lKSByZXR1cm4gbG9jYXRpb247XG5cbiAgdmFyIGJhc2UgPSBhZGRMZWFkaW5nU2xhc2goYmFzZW5hbWUpO1xuXG4gIGlmIChsb2NhdGlvbi5wYXRobmFtZS5pbmRleE9mKGJhc2UpICE9PSAwKSByZXR1cm4gbG9jYXRpb247XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZS5zdWJzdHIoYmFzZS5sZW5ndGgpXG4gIH0pO1xufTtcblxudmFyIGNyZWF0ZVVSTCA9IGZ1bmN0aW9uIGNyZWF0ZVVSTChsb2NhdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGxvY2F0aW9uID09PSBcInN0cmluZ1wiID8gbG9jYXRpb24gOiBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbn07XG5cbnZhciBzdGF0aWNIYW5kbGVyID0gZnVuY3Rpb24gc3RhdGljSGFuZGxlcihtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCBcIllvdSBjYW5ub3QgJXMgd2l0aCA8U3RhdGljUm91dGVyPlwiLCBtZXRob2ROYW1lKTtcbiAgfTtcbn07XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgdG9wLWxldmVsIEFQSSBmb3IgYSBcInN0YXRpY1wiIDxSb3V0ZXI+LCBzby1jYWxsZWQgYmVjYXVzZSBpdFxuICogY2FuJ3QgYWN0dWFsbHkgY2hhbmdlIHRoZSBjdXJyZW50IGxvY2F0aW9uLiBJbnN0ZWFkLCBpdCBqdXN0IHJlY29yZHNcbiAqIGxvY2F0aW9uIGNoYW5nZXMgaW4gYSBjb250ZXh0IG9iamVjdC4gVXNlZnVsIG1haW5seSBpbiB0ZXN0aW5nIGFuZFxuICogc2VydmVyLXJlbmRlcmluZyBzY2VuYXJpb3MuXG4gKi9cblxudmFyIFN0YXRpY1JvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTdGF0aWNSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN0YXRpY1JvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YXRpY1JvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICByZXR1cm4gYWRkTGVhZGluZ1NsYXNoKF90aGlzLnByb3BzLmJhc2VuYW1lICsgY3JlYXRlVVJMKHBhdGgpKTtcbiAgICB9LCBfdGhpcy5oYW5kbGVQdXNoID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBiYXNlbmFtZSA9IF90aGlzJHByb3BzLmJhc2VuYW1lLFxuICAgICAgICAgIGNvbnRleHQgPSBfdGhpcyRwcm9wcy5jb250ZXh0O1xuXG4gICAgICBjb250ZXh0LmFjdGlvbiA9IFwiUFVTSFwiO1xuICAgICAgY29udGV4dC5sb2NhdGlvbiA9IGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpO1xuICAgICAgY29udGV4dC51cmwgPSBjcmVhdGVVUkwoY29udGV4dC5sb2NhdGlvbik7XG4gICAgfSwgX3RoaXMuaGFuZGxlUmVwbGFjZSA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGJhc2VuYW1lID0gX3RoaXMkcHJvcHMyLmJhc2VuYW1lLFxuICAgICAgICAgIGNvbnRleHQgPSBfdGhpcyRwcm9wczIuY29udGV4dDtcblxuICAgICAgY29udGV4dC5hY3Rpb24gPSBcIlJFUExBQ0VcIjtcbiAgICAgIGNvbnRleHQubG9jYXRpb24gPSBhZGRCYXNlbmFtZShiYXNlbmFtZSwgY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKTtcbiAgICAgIGNvbnRleHQudXJsID0gY3JlYXRlVVJMKGNvbnRleHQubG9jYXRpb24pO1xuICAgIH0sIF90aGlzLmhhbmRsZUxpc3RlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH0sIF90aGlzLmhhbmRsZUJsb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBTdGF0aWNSb3V0ZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGVyOiB7XG4gICAgICAgIHN0YXRpY0NvbnRleHQ6IHRoaXMucHJvcHMuY29udGV4dFxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgU3RhdGljUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCBcIjxTdGF0aWNSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksIFwiICsgXCJ1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBTdGF0aWNSb3V0ZXIgYXMgUm91dGVyIH1gLlwiKTtcbiAgfTtcblxuICBTdGF0aWNSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYmFzZW5hbWUgPSBfcHJvcHMuYmFzZW5hbWUsXG4gICAgICAgIGNvbnRleHQgPSBfcHJvcHMuY29udGV4dCxcbiAgICAgICAgbG9jYXRpb24gPSBfcHJvcHMubG9jYXRpb24sXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgW1wiYmFzZW5hbWVcIiwgXCJjb250ZXh0XCIsIFwibG9jYXRpb25cIl0pO1xuXG4gICAgdmFyIGhpc3RvcnkgPSB7XG4gICAgICBjcmVhdGVIcmVmOiB0aGlzLmNyZWF0ZUhyZWYsXG4gICAgICBhY3Rpb246IFwiUE9QXCIsXG4gICAgICBsb2NhdGlvbjogc3RyaXBCYXNlbmFtZShiYXNlbmFtZSwgY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKSxcbiAgICAgIHB1c2g6IHRoaXMuaGFuZGxlUHVzaCxcbiAgICAgIHJlcGxhY2U6IHRoaXMuaGFuZGxlUmVwbGFjZSxcbiAgICAgIGdvOiBzdGF0aWNIYW5kbGVyKFwiZ29cIiksXG4gICAgICBnb0JhY2s6IHN0YXRpY0hhbmRsZXIoXCJnb0JhY2tcIiksXG4gICAgICBnb0ZvcndhcmQ6IHN0YXRpY0hhbmRsZXIoXCJnb0ZvcndhcmRcIiksXG4gICAgICBsaXN0ZW46IHRoaXMuaGFuZGxlTGlzdGVuLFxuICAgICAgYmxvY2s6IHRoaXMuaGFuZGxlQmxvY2tcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgaGlzdG9yeTogaGlzdG9yeSB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIFN0YXRpY1JvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuU3RhdGljUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNvbnRleHQ6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKVxufTtcblN0YXRpY1JvdXRlci5kZWZhdWx0UHJvcHMgPSB7XG4gIGJhc2VuYW1lOiBcIlwiLFxuICBsb2NhdGlvbjogXCIvXCJcbn07XG5TdGF0aWNSb3V0ZXIuY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFN0YXRpY1JvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3RhdGljUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFN3aXRjaCBmcm9tIFwicmVhY3Qtcm91dGVyL2VzL1N3aXRjaFwiO1xuXG5leHBvcnQgZGVmYXVsdCBTd2l0Y2g7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Td2l0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSBcIndhcm5pbmdcIjtcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSBcImludmFyaWFudFwiO1xuaW1wb3J0IG1hdGNoUGF0aCBmcm9tIFwiLi9tYXRjaFBhdGhcIjtcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcmVuZGVyaW5nIHRoZSBmaXJzdCA8Um91dGU+IHRoYXQgbWF0Y2hlcy5cbiAqL1xuXG52YXIgU3dpdGNoID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFN3aXRjaCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3dpdGNoKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTd2l0Y2gpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBTd2l0Y2gucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBpbnZhcmlhbnQodGhpcy5jb250ZXh0LnJvdXRlciwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFN3aXRjaD4gb3V0c2lkZSBhIDxSb3V0ZXI+XCIpO1xuICB9O1xuXG4gIFN3aXRjaC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgd2FybmluZyghKG5leHRQcm9wcy5sb2NhdGlvbiAmJiAhdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8U3dpdGNoPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IGluaXRpYWxseSB1c2VkIG5vIFwibG9jYXRpb25cIiBwcm9wIGFuZCB0aGVuIHByb3ZpZGVkIG9uZSBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuXG4gICAgd2FybmluZyghKCFuZXh0UHJvcHMubG9jYXRpb24gJiYgdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8U3dpdGNoPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IHByb3ZpZGVkIGEgXCJsb2NhdGlvblwiIHByb3AgaW5pdGlhbGx5IGJ1dCBvbWl0dGVkIGl0IG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG4gIH07XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHJvdXRlID0gdGhpcy5jb250ZXh0LnJvdXRlci5yb3V0ZTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuXG4gICAgdmFyIGxvY2F0aW9uID0gdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbjtcblxuICAgIHZhciBtYXRjaCA9IHZvaWQgMCxcbiAgICAgICAgY2hpbGQgPSB2b2lkIDA7XG4gICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIGlmIChtYXRjaCA9PSBudWxsICYmIFJlYWN0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgIHZhciBfZWxlbWVudCRwcm9wcyA9IGVsZW1lbnQucHJvcHMsXG4gICAgICAgICAgICBwYXRoUHJvcCA9IF9lbGVtZW50JHByb3BzLnBhdGgsXG4gICAgICAgICAgICBleGFjdCA9IF9lbGVtZW50JHByb3BzLmV4YWN0LFxuICAgICAgICAgICAgc3RyaWN0ID0gX2VsZW1lbnQkcHJvcHMuc3RyaWN0LFxuICAgICAgICAgICAgc2Vuc2l0aXZlID0gX2VsZW1lbnQkcHJvcHMuc2Vuc2l0aXZlLFxuICAgICAgICAgICAgZnJvbSA9IF9lbGVtZW50JHByb3BzLmZyb207XG5cbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUHJvcCB8fCBmcm9tO1xuXG4gICAgICAgIGNoaWxkID0gZWxlbWVudDtcbiAgICAgICAgbWF0Y2ggPSBtYXRjaFBhdGgobG9jYXRpb24ucGF0aG5hbWUsIHsgcGF0aDogcGF0aCwgZXhhY3Q6IGV4YWN0LCBzdHJpY3Q6IHN0cmljdCwgc2Vuc2l0aXZlOiBzZW5zaXRpdmUgfSwgcm91dGUubWF0Y2gpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1hdGNoID8gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7IGxvY2F0aW9uOiBsb2NhdGlvbiwgY29tcHV0ZWRNYXRjaDogbWF0Y2ggfSkgOiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBTd2l0Y2g7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblN3aXRjaC5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICByb3V0ZTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG4gIH0pLmlzUmVxdWlyZWRcbn07XG5Td2l0Y2gucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFN3aXRjaDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3dpdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IGdlbmVyYXRlUGF0aCBmcm9tIFwicmVhY3Qtcm91dGVyL2VzL2dlbmVyYXRlUGF0aFwiO1xuXG5leHBvcnQgZGVmYXVsdCBnZW5lcmF0ZVBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9nZW5lcmF0ZVBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDE1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgbWF0Y2hQYXRoIGZyb20gXCJyZWFjdC1yb3V0ZXIvZXMvbWF0Y2hQYXRoXCI7XG5cbmV4cG9ydCBkZWZhdWx0IG1hdGNoUGF0aDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL21hdGNoUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCB3aXRoUm91dGVyIGZyb20gXCJyZWFjdC1yb3V0ZXIvZXMvd2l0aFJvdXRlclwiO1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvd2l0aFJvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gXCJwcm9wLXR5cGVzXCI7XG5pbXBvcnQgaG9pc3RTdGF0aWNzIGZyb20gXCJob2lzdC1ub24tcmVhY3Qtc3RhdGljc1wiO1xuaW1wb3J0IFJvdXRlIGZyb20gXCIuL1JvdXRlXCI7XG5cbi8qKlxuICogQSBwdWJsaWMgaGlnaGVyLW9yZGVyIGNvbXBvbmVudCB0byBhY2Nlc3MgdGhlIGltcGVyYXRpdmUgQVBJXG4gKi9cbnZhciB3aXRoUm91dGVyID0gZnVuY3Rpb24gd2l0aFJvdXRlcihDb21wb25lbnQpIHtcbiAgdmFyIEMgPSBmdW5jdGlvbiBDKHByb3BzKSB7XG4gICAgdmFyIHdyYXBwZWRDb21wb25lbnRSZWYgPSBwcm9wcy53cmFwcGVkQ29tcG9uZW50UmVmLFxuICAgICAgICByZW1haW5pbmdQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wid3JhcHBlZENvbXBvbmVudFJlZlwiXSk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZSwge1xuICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKHJvdXRlQ29tcG9uZW50UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7fSwgcmVtYWluaW5nUHJvcHMsIHJvdXRlQ29tcG9uZW50UHJvcHMsIHtcbiAgICAgICAgICByZWY6IHdyYXBwZWRDb21wb25lbnRSZWZcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIEMuZGlzcGxheU5hbWUgPSBcIndpdGhSb3V0ZXIoXCIgKyAoQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lKSArIFwiKVwiO1xuICBDLldyYXBwZWRDb21wb25lbnQgPSBDb21wb25lbnQ7XG4gIEMucHJvcFR5cGVzID0ge1xuICAgIHdyYXBwZWRDb21wb25lbnRSZWY6IFByb3BUeXBlcy5mdW5jXG4gIH07XG5cbiAgcmV0dXJuIGhvaXN0U3RhdGljcyhDLCBDb21wb25lbnQpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFJvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvd2l0aFJvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgQXhpb3MgPSByZXF1aXJlKCcuL2NvcmUvQXhpb3MnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UodXRpbHMubWVyZ2UoZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi8uLi9kZWZhdWx0cycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IHV0aWxzLm1lcmdlKHtcbiAgICAgIHVybDogYXJndW1lbnRzWzBdXG4gICAgfSwgYXJndW1lbnRzWzFdKTtcbiAgfVxuXG4gIGNvbmZpZyA9IHV0aWxzLm1lcmdlKGRlZmF1bHRzLCB7bWV0aG9kOiAnZ2V0J30sIHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIGNvbmZpZy5tZXRob2QgPSBjb25maWcubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gSG9vayB1cCBpbnRlcmNlcHRvcnMgbWlkZGxld2FyZVxuICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgd2hpbGUgKGNoYWluLmxlbmd0aCkge1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybFxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1dGlscy5tZXJnZShjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpb3M7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xuICBpZiAoY29kZSkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICB9XG4gIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICByZXR1cm4gZXJyb3I7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTQwL2dpLCAnQCcpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanNcbi8vIG1vZHVsZSBpZCA9IDE2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xudmFyIGlnbm9yZUR1cGxpY2F0ZU9mID0gW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl07XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuICB2YXIgaTtcblxuICBpZiAoIWhlYWRlcnMpIHsgcmV0dXJuIHBhcnNlZDsgfVxuXG4gIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoMCwgaSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICBwYXJzZWRba2V5XSA9IChwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldIDogW10pLmNvbmNhdChbdmFsXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDE2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgdmFyIG9yaWdpblVSTDtcblxuICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICB9XG5cbiAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0pKClcbik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxuLy8gYnRvYSBwb2x5ZmlsbCBmb3IgSUU8MTAgY291cnRlc3kgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkY2hhbWJlcnMvQmFzZTY0LmpzXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmZ1bmN0aW9uIEUoKSB7XG4gIHRoaXMubWVzc2FnZSA9ICdTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXInO1xufVxuRS5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG5FLnByb3RvdHlwZS5jb2RlID0gNTtcbkUucHJvdG90eXBlLm5hbWUgPSAnSW52YWxpZENoYXJhY3RlckVycm9yJztcblxuZnVuY3Rpb24gYnRvYShpbnB1dCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGlucHV0KTtcbiAgdmFyIG91dHB1dCA9ICcnO1xuICBmb3IgKFxuICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnM7XG4gICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgLy8gICBjaGVjayBpZiBkIGhhcyBubyBmcmFjdGlvbmFsIGRpZ2l0c1xuICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgKSB7XG4gICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHggKz0gMyAvIDQpO1xuICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgIHRocm93IG5ldyBFKCk7XG4gICAgfVxuICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnRvYTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J0b2EuanNcbi8vIG1vZHVsZSBpZCA9IDE3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xuICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgfSxcblxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgICB9LFxuXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgIH07XG4gIH0pKClcbik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICB0aGlzLmhhbmRsZXJzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkXG4gIH0pO1xuICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZWplY3QgPSBmdW5jdGlvbiBlamVjdChpZCkge1xuICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgZm4oaCk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBTdXBwb3J0IGJhc2VVUkwgY29uZmlnXG4gIGlmIChjb25maWcuYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChjb25maWcudXJsKSkge1xuICAgIGNvbmZpZy51cmwgPSBjb21iaW5lVVJMcyhjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gIH1cblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzIHx8IHt9XG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbihkYXRhLCBoZWFkZXJzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qc1xuLy8gbW9kdWxlIGlkID0gMTc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qc1xuLy8gbW9kdWxlIGlkID0gMTc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xuXG52YXIgYXJyYXlQcmVmaXhHZW5lcmF0b3JzID0ge1xuICAgIGJyYWNrZXRzOiBmdW5jdGlvbiBicmFja2V0cyhwcmVmaXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbXSc7XG4gICAgfSxcbiAgICBpbmRpY2VzOiBmdW5jdGlvbiBpbmRpY2VzKHByZWZpeCwga2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnWycgKyBrZXkgKyAnXSc7XG4gICAgfSxcbiAgICByZXBlYXQ6IGZ1bmN0aW9uIHJlcGVhdChwcmVmaXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICB9XG59O1xuXG52YXIgdG9JU08gPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGRlZmF1bHRzID0ge1xuICAgIGRlbGltaXRlcjogJyYnLFxuICAgIGVuY29kZTogdHJ1ZSxcbiAgICBlbmNvZGVyOiB1dGlscy5lbmNvZGUsXG4gICAgZW5jb2RlVmFsdWVzT25seTogZmFsc2UsXG4gICAgc2VyaWFsaXplRGF0ZTogZnVuY3Rpb24gc2VyaWFsaXplRGF0ZShkYXRlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gICAgICAgIHJldHVybiB0b0lTTy5jYWxsKGRhdGUpO1xuICAgIH0sXG4gICAgc2tpcE51bGxzOiBmYWxzZSxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IGZhbHNlXG59O1xuXG52YXIgc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICAgIG9iamVjdCxcbiAgICBwcmVmaXgsXG4gICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgc2tpcE51bGxzLFxuICAgIGVuY29kZXIsXG4gICAgZmlsdGVyLFxuICAgIHNvcnQsXG4gICAgYWxsb3dEb3RzLFxuICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgZm9ybWF0dGVyLFxuICAgIGVuY29kZVZhbHVlc09ubHlcbikge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqID0gZmlsdGVyKHByZWZpeCwgb2JqKTtcbiAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgb2JqID0gc2VyaWFsaXplRGF0ZShvYmopO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIGlmIChzdHJpY3ROdWxsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVyICYmICFlbmNvZGVWYWx1ZXNPbmx5ID8gZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIpIDogcHJlZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8IHR5cGVvZiBvYmogPT09ICdib29sZWFuJyB8fCB1dGlscy5pc0J1ZmZlcihvYmopKSB7XG4gICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICB2YXIga2V5VmFsdWUgPSBlbmNvZGVWYWx1ZXNPbmx5ID8gcHJlZml4IDogZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIpO1xuICAgICAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIoa2V5VmFsdWUpICsgJz0nICsgZm9ybWF0dGVyKGVuY29kZXIob2JqLCBkZWZhdWx0cy5lbmNvZGVyKSldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZm9ybWF0dGVyKHByZWZpeCkgKyAnPScgKyBmb3JtYXR0ZXIoU3RyaW5nKG9iaikpXTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICB2YXIgb2JqS2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIpKSB7XG4gICAgICAgIG9iaktleXMgPSBmaWx0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBvYmpLZXlzID0gc29ydCA/IGtleXMuc29ydChzb3J0KSA6IGtleXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmpLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpLZXlzW2ldO1xuXG4gICAgICAgIGlmIChza2lwTnVsbHMgJiYgb2JqW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChzdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgb2JqW2tleV0sXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeChwcmVmaXgsIGtleSksXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICAgICAgICAgIGVuY29kZXIsXG4gICAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICAgIHNvcnQsXG4gICAgICAgICAgICAgICAgYWxsb3dEb3RzLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyLFxuICAgICAgICAgICAgICAgIGVuY29kZVZhbHVlc09ubHlcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChzdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgb2JqW2tleV0sXG4gICAgICAgICAgICAgICAgcHJlZml4ICsgKGFsbG93RG90cyA/ICcuJyArIGtleSA6ICdbJyArIGtleSArICddJyksXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICAgICAgICAgIGVuY29kZXIsXG4gICAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICAgIHNvcnQsXG4gICAgICAgICAgICAgICAgYWxsb3dEb3RzLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyLFxuICAgICAgICAgICAgICAgIGVuY29kZVZhbHVlc09ubHlcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgb3B0cykge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzID8gdXRpbHMuYXNzaWduKHt9LCBvcHRzKSA6IHt9O1xuXG4gICAgaWYgKG9wdGlvbnMuZW5jb2RlciAhPT0gbnVsbCAmJiBvcHRpb25zLmVuY29kZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5lbmNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuY29kZXIgaGFzIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlbGltaXRlciA9IHR5cGVvZiBvcHRpb25zLmRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5kZWxpbWl0ZXIgOiBvcHRpb25zLmRlbGltaXRlcjtcbiAgICB2YXIgc3RyaWN0TnVsbEhhbmRsaW5nID0gdHlwZW9mIG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZztcbiAgICB2YXIgc2tpcE51bGxzID0gdHlwZW9mIG9wdGlvbnMuc2tpcE51bGxzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnNraXBOdWxscyA6IGRlZmF1bHRzLnNraXBOdWxscztcbiAgICB2YXIgZW5jb2RlID0gdHlwZW9mIG9wdGlvbnMuZW5jb2RlID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmVuY29kZSA6IGRlZmF1bHRzLmVuY29kZTtcbiAgICB2YXIgZW5jb2RlciA9IHR5cGVvZiBvcHRpb25zLmVuY29kZXIgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmVuY29kZXIgOiBkZWZhdWx0cy5lbmNvZGVyO1xuICAgIHZhciBzb3J0ID0gdHlwZW9mIG9wdGlvbnMuc29ydCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuc29ydCA6IG51bGw7XG4gICAgdmFyIGFsbG93RG90cyA9IHR5cGVvZiBvcHRpb25zLmFsbG93RG90cyA9PT0gJ3VuZGVmaW5lZCcgPyBmYWxzZSA6IG9wdGlvbnMuYWxsb3dEb3RzO1xuICAgIHZhciBzZXJpYWxpemVEYXRlID0gdHlwZW9mIG9wdGlvbnMuc2VyaWFsaXplRGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuc2VyaWFsaXplRGF0ZSA6IGRlZmF1bHRzLnNlcmlhbGl6ZURhdGU7XG4gICAgdmFyIGVuY29kZVZhbHVlc09ubHkgPSB0eXBlb2Ygb3B0aW9ucy5lbmNvZGVWYWx1ZXNPbmx5ID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmVuY29kZVZhbHVlc09ubHkgOiBkZWZhdWx0cy5lbmNvZGVWYWx1ZXNPbmx5O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mb3JtYXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnMuZm9ybWF0ID0gZm9ybWF0c1snZGVmYXVsdCddO1xuICAgIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb3JtYXRzLmZvcm1hdHRlcnMsIG9wdGlvbnMuZm9ybWF0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGZvcm1hdCBvcHRpb24gcHJvdmlkZWQuJyk7XG4gICAgfVxuICAgIHZhciBmb3JtYXR0ZXIgPSBmb3JtYXRzLmZvcm1hdHRlcnNbb3B0aW9ucy5mb3JtYXRdO1xuICAgIHZhciBvYmpLZXlzO1xuICAgIHZhciBmaWx0ZXI7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmogPSBmaWx0ZXIoJycsIG9iaik7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuZmlsdGVyKSkge1xuICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgb2JqS2V5cyA9IGZpbHRlcjtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgdmFyIGFycmF5Rm9ybWF0O1xuICAgIGlmIChvcHRpb25zLmFycmF5Rm9ybWF0IGluIGFycmF5UHJlZml4R2VuZXJhdG9ycykge1xuICAgICAgICBhcnJheUZvcm1hdCA9IG9wdGlvbnMuYXJyYXlGb3JtYXQ7XG4gICAgfSBlbHNlIGlmICgnaW5kaWNlcycgaW4gb3B0aW9ucykge1xuICAgICAgICBhcnJheUZvcm1hdCA9IG9wdGlvbnMuaW5kaWNlcyA/ICdpbmRpY2VzJyA6ICdyZXBlYXQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gJ2luZGljZXMnO1xuICAgIH1cblxuICAgIHZhciBnZW5lcmF0ZUFycmF5UHJlZml4ID0gYXJyYXlQcmVmaXhHZW5lcmF0b3JzW2FycmF5Rm9ybWF0XTtcblxuICAgIGlmICghb2JqS2V5cykge1xuICAgICAgICBvYmpLZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB9XG5cbiAgICBpZiAoc29ydCkge1xuICAgICAgICBvYmpLZXlzLnNvcnQoc29ydCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmpLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpLZXlzW2ldO1xuXG4gICAgICAgIGlmIChza2lwTnVsbHMgJiYgb2JqW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KHN0cmluZ2lmeShcbiAgICAgICAgICAgIG9ialtrZXldLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgIHNraXBOdWxscyxcbiAgICAgICAgICAgIGVuY29kZSA/IGVuY29kZXIgOiBudWxsLFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgIGFsbG93RG90cyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5XG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIHZhciBqb2luZWQgPSBrZXlzLmpvaW4oZGVsaW1pdGVyKTtcbiAgICB2YXIgcHJlZml4ID0gb3B0aW9ucy5hZGRRdWVyeVByZWZpeCA9PT0gdHJ1ZSA/ICc/JyA6ICcnO1xuXG4gICAgcmV0dXJuIGpvaW5lZC5sZW5ndGggPiAwID8gcHJlZml4ICsgam9pbmVkIDogJyc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXMvbGliL3N0cmluZ2lmeS5qc1xuLy8gbW9kdWxlIGlkID0gMTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gICAgYWxsb3dEb3RzOiBmYWxzZSxcbiAgICBhbGxvd1Byb3RvdHlwZXM6IGZhbHNlLFxuICAgIGFycmF5TGltaXQ6IDIwLFxuICAgIGRlY29kZXI6IHV0aWxzLmRlY29kZSxcbiAgICBkZWxpbWl0ZXI6ICcmJyxcbiAgICBkZXB0aDogNSxcbiAgICBwYXJhbWV0ZXJMaW1pdDogMTAwMCxcbiAgICBwbGFpbk9iamVjdHM6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2Vcbn07XG5cbnZhciBwYXJzZVZhbHVlcyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdWYWx1ZXMoc3RyLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciBjbGVhblN0ciA9IG9wdGlvbnMuaWdub3JlUXVlcnlQcmVmaXggPyBzdHIucmVwbGFjZSgvXlxcPy8sICcnKSA6IHN0cjtcbiAgICB2YXIgbGltaXQgPSBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG9wdGlvbnMucGFyYW1ldGVyTGltaXQ7XG4gICAgdmFyIHBhcnRzID0gY2xlYW5TdHIuc3BsaXQob3B0aW9ucy5kZWxpbWl0ZXIsIGxpbWl0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICB2YXIgYnJhY2tldEVxdWFsc1BvcyA9IHBhcnQuaW5kZXhPZignXT0nKTtcbiAgICAgICAgdmFyIHBvcyA9IGJyYWNrZXRFcXVhbHNQb3MgPT09IC0xID8gcGFydC5pbmRleE9mKCc9JykgOiBicmFja2V0RXF1YWxzUG9zICsgMTtcblxuICAgICAgICB2YXIga2V5LCB2YWw7XG4gICAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgICAgICBrZXkgPSBvcHRpb25zLmRlY29kZXIocGFydCwgZGVmYXVsdHMuZGVjb2Rlcik7XG4gICAgICAgICAgICB2YWwgPSBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA/IG51bGwgOiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IG9wdGlvbnMuZGVjb2RlcihwYXJ0LnNsaWNlKDAsIHBvcyksIGRlZmF1bHRzLmRlY29kZXIpO1xuICAgICAgICAgICAgdmFsID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQuc2xpY2UocG9zICsgMSksIGRlZmF1bHRzLmRlY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gW10uY29uY2F0KG9ialtrZXldKS5jb25jYXQodmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBwYXJzZU9iamVjdCA9IGZ1bmN0aW9uIChjaGFpbiwgdmFsLCBvcHRpb25zKSB7XG4gICAgdmFyIGxlYWYgPSB2YWw7XG5cbiAgICBmb3IgKHZhciBpID0gY2hhaW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIG9iajtcbiAgICAgICAgdmFyIHJvb3QgPSBjaGFpbltpXTtcblxuICAgICAgICBpZiAocm9vdCA9PT0gJ1tdJykge1xuICAgICAgICAgICAgb2JqID0gW107XG4gICAgICAgICAgICBvYmogPSBvYmouY29uY2F0KGxlYWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqID0gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgICAgICAgICB2YXIgY2xlYW5Sb290ID0gcm9vdC5jaGFyQXQoMCkgPT09ICdbJyAmJiByb290LmNoYXJBdChyb290Lmxlbmd0aCAtIDEpID09PSAnXScgPyByb290LnNsaWNlKDEsIC0xKSA6IHJvb3Q7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChjbGVhblJvb3QsIDEwKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhaXNOYU4oaW5kZXgpXG4gICAgICAgICAgICAgICAgJiYgcm9vdCAhPT0gY2xlYW5Sb290XG4gICAgICAgICAgICAgICAgJiYgU3RyaW5nKGluZGV4KSA9PT0gY2xlYW5Sb290XG4gICAgICAgICAgICAgICAgJiYgaW5kZXggPj0gMFxuICAgICAgICAgICAgICAgICYmIChvcHRpb25zLnBhcnNlQXJyYXlzICYmIGluZGV4IDw9IG9wdGlvbnMuYXJyYXlMaW1pdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9iaiA9IFtdO1xuICAgICAgICAgICAgICAgIG9ialtpbmRleF0gPSBsZWFmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmpbY2xlYW5Sb290XSA9IGxlYWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZWFmID0gb2JqO1xuICAgIH1cblxuICAgIHJldHVybiBsZWFmO1xufTtcblxudmFyIHBhcnNlS2V5cyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdLZXlzKGdpdmVuS2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWdpdmVuS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2Zvcm0gZG90IG5vdGF0aW9uIHRvIGJyYWNrZXQgbm90YXRpb25cbiAgICB2YXIga2V5ID0gb3B0aW9ucy5hbGxvd0RvdHMgPyBnaXZlbktleS5yZXBsYWNlKC9cXC4oW14uW10rKS9nLCAnWyQxXScpIDogZ2l2ZW5LZXk7XG5cbiAgICAvLyBUaGUgcmVnZXggY2h1bmtzXG5cbiAgICB2YXIgYnJhY2tldHMgPSAvKFxcW1teW1xcXV0qXSkvO1xuICAgIHZhciBjaGlsZCA9IC8oXFxbW15bXFxdXSpdKS9nO1xuXG4gICAgLy8gR2V0IHRoZSBwYXJlbnRcblxuICAgIHZhciBzZWdtZW50ID0gYnJhY2tldHMuZXhlYyhrZXkpO1xuICAgIHZhciBwYXJlbnQgPSBzZWdtZW50ID8ga2V5LnNsaWNlKDAsIHNlZ21lbnQuaW5kZXgpIDoga2V5O1xuXG4gICAgLy8gU3Rhc2ggdGhlIHBhcmVudCBpZiBpdCBleGlzdHNcblxuICAgIHZhciBrZXlzID0gW107XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgdXNpbmcgcGxhaW4gb2JqZWN0cywgb3B0aW9uYWxseSBwcmVmaXgga2V5c1xuICAgICAgICAvLyB0aGF0IHdvdWxkIG92ZXJ3cml0ZSBvYmplY3QgcHJvdG90eXBlIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKCFvcHRpb25zLnBsYWluT2JqZWN0cyAmJiBoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBwYXJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5wdXNoKHBhcmVudCk7XG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGNoaWxkcmVuIGFwcGVuZGluZyB0byB0aGUgYXJyYXkgdW50aWwgd2UgaGl0IGRlcHRoXG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKChzZWdtZW50ID0gY2hpbGQuZXhlYyhrZXkpKSAhPT0gbnVsbCAmJiBpIDwgb3B0aW9ucy5kZXB0aCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIGlmICghb3B0aW9ucy5wbGFpbk9iamVjdHMgJiYgaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgc2VnbWVudFsxXS5zbGljZSgxLCAtMSkpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSdzIGEgcmVtYWluZGVyLCBqdXN0IGFkZCB3aGF0ZXZlciBpcyBsZWZ0XG5cbiAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBrZXlzLnB1c2goJ1snICsga2V5LnNsaWNlKHNlZ21lbnQuaW5kZXgpICsgJ10nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VPYmplY3Qoa2V5cywgdmFsLCBvcHRpb25zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0ciwgb3B0cykge1xuICAgIHZhciBvcHRpb25zID0gb3B0cyA/IHV0aWxzLmFzc2lnbih7fSwgb3B0cykgOiB7fTtcblxuICAgIGlmIChvcHRpb25zLmRlY29kZXIgIT09IG51bGwgJiYgb3B0aW9ucy5kZWNvZGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMuZGVjb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEZWNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuaWdub3JlUXVlcnlQcmVmaXggPSBvcHRpb25zLmlnbm9yZVF1ZXJ5UHJlZml4ID09PSB0cnVlO1xuICAgIG9wdGlvbnMuZGVsaW1pdGVyID0gdHlwZW9mIG9wdGlvbnMuZGVsaW1pdGVyID09PSAnc3RyaW5nJyB8fCB1dGlscy5pc1JlZ0V4cChvcHRpb25zLmRlbGltaXRlcikgPyBvcHRpb25zLmRlbGltaXRlciA6IGRlZmF1bHRzLmRlbGltaXRlcjtcbiAgICBvcHRpb25zLmRlcHRoID0gdHlwZW9mIG9wdGlvbnMuZGVwdGggPT09ICdudW1iZXInID8gb3B0aW9ucy5kZXB0aCA6IGRlZmF1bHRzLmRlcHRoO1xuICAgIG9wdGlvbnMuYXJyYXlMaW1pdCA9IHR5cGVvZiBvcHRpb25zLmFycmF5TGltaXQgPT09ICdudW1iZXInID8gb3B0aW9ucy5hcnJheUxpbWl0IDogZGVmYXVsdHMuYXJyYXlMaW1pdDtcbiAgICBvcHRpb25zLnBhcnNlQXJyYXlzID0gb3B0aW9ucy5wYXJzZUFycmF5cyAhPT0gZmFsc2U7XG4gICAgb3B0aW9ucy5kZWNvZGVyID0gdHlwZW9mIG9wdGlvbnMuZGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZGVjb2RlciA6IGRlZmF1bHRzLmRlY29kZXI7XG4gICAgb3B0aW9ucy5hbGxvd0RvdHMgPSB0eXBlb2Ygb3B0aW9ucy5hbGxvd0RvdHMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuYWxsb3dEb3RzIDogZGVmYXVsdHMuYWxsb3dEb3RzO1xuICAgIG9wdGlvbnMucGxhaW5PYmplY3RzID0gdHlwZW9mIG9wdGlvbnMucGxhaW5PYmplY3RzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnBsYWluT2JqZWN0cyA6IGRlZmF1bHRzLnBsYWluT2JqZWN0cztcbiAgICBvcHRpb25zLmFsbG93UHJvdG90eXBlcyA9IHR5cGVvZiBvcHRpb25zLmFsbG93UHJvdG90eXBlcyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMgOiBkZWZhdWx0cy5hbGxvd1Byb3RvdHlwZXM7XG4gICAgb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9IHR5cGVvZiBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMucGFyYW1ldGVyTGltaXQgOiBkZWZhdWx0cy5wYXJhbWV0ZXJMaW1pdDtcbiAgICBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA9IHR5cGVvZiBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgOiBkZWZhdWx0cy5zdHJpY3ROdWxsSGFuZGxpbmc7XG5cbiAgICBpZiAoc3RyID09PSAnJyB8fCBzdHIgPT09IG51bGwgfHwgdHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgIH1cblxuICAgIHZhciB0ZW1wT2JqID0gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBwYXJzZVZhbHVlcyhzdHIsIG9wdGlvbnMpIDogc3RyO1xuICAgIHZhciBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUga2V5cyBhbmQgc2V0dXAgdGhlIG5ldyBvYmplY3RcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGVtcE9iaik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgbmV3T2JqID0gcGFyc2VLZXlzKGtleSwgdGVtcE9ialtrZXldLCBvcHRpb25zKTtcbiAgICAgICAgb2JqID0gdXRpbHMubWVyZ2Uob2JqLCBuZXdPYmosIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5jb21wYWN0KG9iaik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG4vLyBSZWFjdCAxNisgc3VwcG9ydHMgUG9ydGFscy5cbnZhciBjYW5Vc2VQb3J0YWxzID0gISFSZWFjdERPTS5jcmVhdGVQb3J0YWw7XG5cbmZ1bmN0aW9uIGRpc3BsYWNlKFdyYXBwZWRDb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICAgIF9pbmhlcml0cyhFbXB0eURpc3BsYWNlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgICAgZnVuY3Rpb24gRW1wdHlEaXNwbGFjZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVtcHR5RGlzcGxhY2UpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRW1wdHlEaXNwbGFjZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEVtcHR5RGlzcGxhY2UpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIH1cblxuICAgICAgX2NyZWF0ZUNsYXNzKEVtcHR5RGlzcGxhY2UsIFt7XG4gICAgICAgIGtleTogJ3JlbmRlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBFbXB0eURpc3BsYWNlO1xuICAgIH0oUmVhY3QuQ29tcG9uZW50KTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBEaXNwbGFjZWQgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudDIpIHtcbiAgICBfaW5oZXJpdHMoRGlzcGxhY2VkLCBfUmVhY3QkQ29tcG9uZW50Mik7XG5cbiAgICBmdW5jdGlvbiBEaXNwbGFjZWQoKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgdmFyIF90ZW1wLCBfdGhpczIsIF9yZXQ7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaXNwbGFjZWQpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IERpc3BsYWNlZC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERpc3BsYWNlZCkpLmNhbGwuYXBwbHkoX3JlZiwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpczIpLCBfdGhpczIucmVuZGVyRGlzcGxhY2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBSZWFjdERPTS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihfdGhpczIsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgX3RoaXMyLnByb3BzLCBfdGhpczIucHJvcHMuY2hpbGRyZW4pLCBfdGhpczIuY29udGFpbmVyKTtcbiAgICAgIH0sIF90aGlzMi5yZW1vdmVEaXNwbGFjZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUoX3RoaXMyLmNvbnRhaW5lcik7XG4gICAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzMiwgX3JldCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKERpc3BsYWNlZCwgW3tcbiAgICAgIGtleTogJ2NvbXBvbmVudFdpbGxNb3VudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMucmVuZGVyVG8pIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5yZW5kZXJUbyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9wdGlvbnMucmVuZGVyVG8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5yZW5kZXJUbztcbiAgICAgICAgICB9XG4gICAgICAgIH0oKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGlmIChjYW5Vc2VQb3J0YWxzKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm1vdW50ZWQpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlckRpc3BsYWNlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnY29tcG9uZW50RGlkVXBkYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGlmIChjYW5Vc2VQb3J0YWxzKSByZXR1cm47XG4gICAgICAgIGlmIChwcmV2UHJvcHMubW91bnRlZCAmJiAhdGhpcy5wcm9wcy5tb3VudGVkKSB7XG4gICAgICAgICAgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5tb3VudGVkKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJEaXNwbGFjZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKCFjYW5Vc2VQb3J0YWxzKSB7XG4gICAgICAgICAgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLnJlbmRlclRvKSB7XG4gICAgICAgICAgdGhpcy5jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZW5kZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKCFjYW5Vc2VQb3J0YWxzIHx8IHRoaXMucHJvcHMubW91bnRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhY3RET00uY3JlYXRlUG9ydGFsKFJlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgdGhpcy5wcm9wcywgdGhpcy5wcm9wcy5jaGlsZHJlbiksIHRoaXMuY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRGlzcGxhY2VkO1xuICB9KFJlYWN0LkNvbXBvbmVudCk7XG5cbiAgRGlzcGxhY2VkLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBtb3VudGVkOiB0cnVlXG4gIH07XG4gIERpc3BsYWNlZC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcblxuXG4gIHJldHVybiBEaXNwbGFjZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGlzcGxhY2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZGlzcGxhY2UvZGlzdC9kaXNwbGFjZS5qc1xuLy8gbW9kdWxlIGlkID0gMTgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWNlRWRpdG9yIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUuYmluZCggdGhpcyApO1xuXHRcdHRoaXMuaW5zZXJ0U2VsZWN0b3IgPSB0aGlzLmluc2VydFNlbGVjdG9yLmJpbmQoIHRoaXMgKTtcblx0fVxuXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHRcdHRoaXMuZWRpdG9yID0gYWNlLmVkaXQoIGBmb3JtaW5hdG9yLWZpZWxkLSR7IHRoaXMucHJvcHMucHJvcGVydHkgfWAgKTtcblxuXHRcdHRoaXMuc2Vzc2lvbiA9IHRoaXMuZWRpdG9yLmdldFNlc3Npb24oKTtcblx0XHR0aGlzLnNlc3Npb24uc2V0VXNlV29ya2VyKCBmYWxzZSApO1xuXHRcdHRoaXMuZWRpdG9yLnNldFNob3dQcmludE1hcmdpbiggZmFsc2UgKTtcblxuXHRcdHRoaXMuc2Vzc2lvbi5zZXRNb2RlKCAnYWNlL21vZGUvY3NzJyApO1xuXHRcdHRoaXMuZWRpdG9yLnNldFRoZW1lKCAnYWNlL3RoZW1lL3N1aScgKTtcblx0XHR0aGlzLmVkaXRvci5yZW5kZXJlci5zZXRTaG93R3V0dGVyKCB0cnVlICk7XG5cdFx0dGhpcy5lZGl0b3Iuc2V0SGlnaGxpZ2h0QWN0aXZlTGluZSggdHJ1ZSApO1xuXHRcdHRoaXMuZWRpdG9yLmZvY3VzKCk7XG5cblx0XHR0aGlzLmVkaXRvci5vbiggJ2NoYW5nZScsIHRoaXMudXBkYXRlVmFsdWUgKTtcblx0fVxuXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdHRoaXMuZWRpdG9yLmRlc3Ryb3koKTtcblx0XHR0aGlzLmVkaXRvciA9IG51bGw7XG5cdH1cblxuXHRpbnNlcnRTZWxlY3Rvciggc2VsZWN0b3IgKSB7XG5cdFx0Y29uc3Qgc2VsZWN0Q2xhc3MgPSBzZWxlY3RvciArICd7fSc7XG5cblx0XHR0aGlzLmVkaXRvci5uYXZpZ2F0ZUZpbGVFbmQoKTtcblx0XHR0aGlzLmVkaXRvci5pbnNlcnQoIHNlbGVjdENsYXNzICk7XG5cdFx0dGhpcy5lZGl0b3IubmF2aWdhdGVMZWZ0KCAxICk7XG5cdFx0dGhpcy5lZGl0b3IuZm9jdXMoKTtcblx0fVxuXG5cdHNob3VsZENvbXBvbmVudFVwZGF0ZSgpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR1cGRhdGVWYWx1ZSgpIHtcblx0XHR0aGlzLnByb3BzLmFjdGlvbnMuc2V0dGluZ3NBY3Rpb25zLnVwZGF0ZVNldHRpbmcoXG5cdFx0XHR0aGlzLnByb3BzLnByb3BlcnR5LFxuXHRcdFx0dGhpcy5lZGl0b3IuZ2V0VmFsdWUoKVxuXHRcdCk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF0gKVxuXHRcdFx0PyAnJ1xuXHRcdFx0OiB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF07XG5cblx0XHRsZXQgdHlwZSA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy50eXBlICkgPyB0aGlzLnByb3BzLnR5cGUgOiAnZm9ybSc7XG5cblx0XHRpZiAoICdwZGYtZm9ybScgPT09IHRoaXMucHJvcHMuZm9ybVR5cGUgKSB7XG5cdFx0XHR0eXBlID0gdGhpcy5wcm9wcy5mb3JtVHlwZTtcblx0XHR9XG5cblx0XHRjb25zdCBiYXNpY1NlbGVjdG9ycyA9IChcblx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0PGxhYmVsIGNsYXNzTmFtZT1cInN1aS1sYWJlbFwiPnsgdHJhbnNsYXRlKCAnQmFzaWMgc2VsZWN0b3JzJyApIH08L2xhYmVsPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1hY2Utc2VsZWN0b3JzXCI+XG5cdFx0XHRcdFx0PGEgY2xhc3NOYW1lPVwic3VpLXNlbGVjdG9yIHN1aS1pbnNlcnQtc2VsZWN0b3JcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMuaW5zZXJ0U2VsZWN0b3IoICcgJyApIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0Zvcm0nICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3Rvcihcblx0XHRcdFx0XHRcdFx0JyAuZm9ybWluYXRvci10aXRsZSAnXG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1NlY3Rpb24gVGl0bGUnICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3Rvcihcblx0XHRcdFx0XHRcdFx0JyAuZm9ybWluYXRvci1zdWJ0aXRsZSAnXG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1NlY3Rpb24gU3VidGl0bGUnICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3Rvcihcblx0XHRcdFx0XHRcdFx0JyAuZm9ybWluYXRvci1sYWJlbCAnXG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0ZpZWxkIExhYmVsJyApIH1cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0PGEgY2xhc3NOYW1lPVwic3VpLXNlbGVjdG9yIHN1aS1pbnNlcnQtc2VsZWN0b3JcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMuaW5zZXJ0U2VsZWN0b3IoXG5cdFx0XHRcdFx0XHRcdCcgLmZvcm1pbmF0b3ItZGVzY3JpcHRpb24gJ1xuXHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdGaWVsZCBEZXNjcmlwdGlvbicgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKFxuXHRcdFx0XHRcdFx0XHQnIC5mb3JtaW5hdG9yLWlucHV0ICdcblx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnSW5wdXQnICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3Rvcihcblx0XHRcdFx0XHRcdFx0JyAuZm9ybWluYXRvci10ZXh0YXJlYSAnXG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1RleHRhcmVhJyApIH1cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHQpO1xuXG5cdFx0Y29uc3QgcG9sbFNlbGVjdG9ycyA9IChcblx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0PGxhYmVsIGNsYXNzTmFtZT1cInN1aS1sYWJlbFwiPnsgdHJhbnNsYXRlKCAnQmFzaWMgc2VsZWN0b3JzJyApIH08L2xhYmVsPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1hY2Utc2VsZWN0b3JzXCI+XG5cdFx0XHRcdFx0PGEgY2xhc3NOYW1lPVwic3VpLXNlbGVjdG9yIHN1aS1pbnNlcnQtc2VsZWN0b3JcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMuaW5zZXJ0U2VsZWN0b3IoICcgJyApIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1BvbGwnICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3RvciggJyAuZm9ybWluYXRvci1wb2xsLS1xdWVzdGlvbiAnICkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnUXVlc3Rpb24nICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3RvciggJyAuZm9ybWluYXRvci1yYWRpbyAuZm9ybWluYXRvci1yYWRpby1idWxsZXQgJyApIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0Fuc3dlciBJbnB1dCcgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKCAnLmZvcm1pbmF0b3ItcmFkaW8gLmZvcm1pbmF0b3ItcmFkaW8tbGFiZWwgJyApIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0Fuc3dlciBMYWJlbCcgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKCAnIC5mb3JtaW5hdG9yLWJ1dHRvbiAnICkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnU3VibWl0IEJ1dHRvbicgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKFxuXHRcdFx0XHRcdFx0XHQnIC5mb3JtaW5hdG9yLXBvbGwtZm9vdGVyIGEuZm9ybWluYXRvci1saW5rLCAnICtcblx0XHRcdFx0XHRcdFx0Jy5mb3JtaW5hdG9yLXBvbGwtZm9vdGVyIGEuZm9ybWluYXRvci1saW5rOnZpc2l0ZWQgJ1xuXHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdWaWV3IFJlc3VsdHMgTGluaycgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblxuXHRcdGNvbnN0IHF1aXpTZWxlY3RvcnMgPSAoXG5cdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdDxsYWJlbCBjbGFzc05hbWU9XCJzdWktbGFiZWxcIj57IHRyYW5zbGF0ZSggJ0Jhc2ljIHNlbGVjdG9ycycgKSB9PC9sYWJlbD5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYWNlLXNlbGVjdG9yc1wiPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKCAnICcgKSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdRdWl6JyApIH1cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0PGEgY2xhc3NOYW1lPVwic3VpLXNlbGVjdG9yIHN1aS1pbnNlcnQtc2VsZWN0b3JcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMuaW5zZXJ0U2VsZWN0b3IoICcuZm9ybWluYXRvci1xdWl6LS10aXRsZSAnICkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnVGl0bGUnICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3RvciggJy5mb3JtaW5hdG9yLXF1aXotLWRlc2NyaXB0aW9uIHAgJyApIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0Rlc2NyaXB0aW9uJyApIH1cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0PGEgY2xhc3NOYW1lPVwic3VpLXNlbGVjdG9yIHN1aS1pbnNlcnQtc2VsZWN0b3JcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMuaW5zZXJ0U2VsZWN0b3IoICcuZm9ybWluYXRvci1xdWVzdGlvbiAuZm9ybWluYXRvci1sZWdlbmQgJyApIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1F1ZXN0aW9uJyApIH1cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0PGEgY2xhc3NOYW1lPVwic3VpLXNlbGVjdG9yIHN1aS1pbnNlcnQtc2VsZWN0b3JcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMuaW5zZXJ0U2VsZWN0b3IoICcuZm9ybWluYXRvci1hbnN3ZXIgLmZvcm1pbmF0b3ItYW5zd2VyLS1kZXNpZ24gJyApIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0Fuc3dlciBDb250YWluZXInICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3Rvcihcblx0XHRcdFx0XHRcdFx0Jy5mb3JtaW5hdG9yLWFuc3dlciAuZm9ybWluYXRvci1hbnN3ZXItLW5hbWUgJ1xuXHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdBbnN3ZXIgVGV4dCcgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblxuXHRcdGNvbnN0IHBkZlNlbGVjdG9ycyA9IChcblx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0PGxhYmVsIGNsYXNzTmFtZT1cInN1aS1sYWJlbFwiPnsgdHJhbnNsYXRlKCAnUERGIHNlbGVjdG9ycycgKSB9PC9sYWJlbD5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYWNlLXNlbGVjdG9yc1wiPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKCAnYm9keScgKSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdCb2R5JyApIH1cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0PGEgY2xhc3NOYW1lPVwic3VpLXNlbGVjdG9yIHN1aS1pbnNlcnQtc2VsZWN0b3JcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMuaW5zZXJ0U2VsZWN0b3IoXG5cdFx0XHRcdFx0XHRcdCcuZm9ybWluYXRvci1wZGYtaGVhZGVyJ1xuXHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdQREYgSGVhZGVyJyApIH1cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0PGEgY2xhc3NOYW1lPVwic3VpLXNlbGVjdG9yIHN1aS1pbnNlcnQtc2VsZWN0b3JcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMuaW5zZXJ0U2VsZWN0b3IoXG5cdFx0XHRcdFx0XHRcdCcucGRmLWxvZ28nXG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0xvZ28nICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3Rvcihcblx0XHRcdFx0XHRcdFx0Jy5wZGYtdGl0bGUnXG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1RpdGxlJyApIH1cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0PGEgY2xhc3NOYW1lPVwic3VpLXNlbGVjdG9yIHN1aS1pbnNlcnQtc2VsZWN0b3JcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMuaW5zZXJ0U2VsZWN0b3IoXG5cdFx0XHRcdFx0XHRcdCcuZm9ybWluYXRvci1yb3ctaGVhZGluZyB0ZCdcblx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnRmllbGQgTGFiZWwnICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3Rvcihcblx0XHRcdFx0XHRcdFx0Jy5mb3JtaW5hdG9yLXJvdy1jb250ZW50IHRkJ1xuXHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdGaWVsZCBWYWx1ZScgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKFxuXHRcdFx0XHRcdFx0XHQnLmZvcm1pbmF0b3ItcGRmLWZvb3Rlci10ZXh0IHRkJ1xuXHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdGb290ZXInICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3Rvcihcblx0XHRcdFx0XHRcdFx0Jy5mb3JtaW5hdG9yLXBkZi1wYWdpbmF0aW9uIHRkJ1xuXHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdQYWdpbmF0aW9uJyApIH1cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0eyB0eXBlID09PSAnZm9ybScgJiYgYmFzaWNTZWxlY3RvcnMgfVxuXHRcdFx0XHR7IHR5cGUgPT09ICdwb2xsJyAmJiBwb2xsU2VsZWN0b3JzIH1cblx0XHRcdFx0eyB0eXBlID09PSAncXVpeicgJiYgcXVpelNlbGVjdG9ycyB9XG5cdFx0XHRcdHsgdHlwZSA9PT0gJ3BkZi1mb3JtJyAmJiBwZGZTZWxlY3RvcnMgfVxuXHRcdFx0XHQ8ZGl2IGlkPXsgYGZvcm1pbmF0b3ItZmllbGQtJHsgdGhpcy5wcm9wcy5wcm9wZXJ0eSB9YCB9XG5cdFx0XHRcdFx0ZGF0YS12YWx1ZT17IHZhbHVlIH1cblx0XHRcdFx0XHRzdHlsZT17IHsgaGVpZ2h0OiAnMjEwcHgnIH0gfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0eyB2YWx1ZSB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MvaW5wdXRzL2FjZS1lZGl0b3IuanMiLCJleHBvcnQgY29uc3Qgc2hvd01vZGFsID0gKCBtb2RhbFByb3BzLCBtb2RhbFR5cGUgKSA9PiBkaXNwYXRjaCA9PiB7XG5cdGRpc3BhdGNoKCB7XG5cdFx0dHlwZTogJ1NIT1dfTU9EQUwnLFxuXHRcdG1vZGFsUHJvcHMsXG5cdFx0bW9kYWxUeXBlLFxuXHR9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgaGlkZU1vZGFsID0gKCkgPT4gZGlzcGF0Y2ggPT4ge1xuXHRkaXNwYXRjaCgge1xuXHRcdHR5cGU6ICdISURFX01PREFMJyxcblx0fSApO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2FjdGlvbnMvbW9kYWwuanMiLCJleHBvcnQgY29uc3QgdXBkYXRlU2V0dGluZyA9ICggc2V0dGluZywgdmFsdWUgKSA9PiBkaXNwYXRjaCA9PiB7XG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGUgd2l0aCBDaGFuZ2VzXG5cdHdpbmRvdy5mb3JtaW5hdG9yQ2hhbmdlcy5zZXR0aW5ncyA9IHRydWU7XG5cblx0ZGlzcGF0Y2goIHtcblx0XHR0eXBlOiAnVVBEQVRFX1NFVFRJTkcnLFxuXHRcdHNldHRpbmc6IHNldHRpbmcsXG5cdFx0dmFsdWU6IHZhbHVlXG5cdH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVTZXR0aW5ncyA9ICggc2V0dGluZ3MgKSA9PiBkaXNwYXRjaCA9PiB7XG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGUgd2l0aCBDaGFuZ2VzXG5cdHdpbmRvdy5mb3JtaW5hdG9yQ2hhbmdlcy5zZXR0aW5ncyA9IHRydWU7XG5cblx0ZGlzcGF0Y2goIHtcblx0XHR0eXBlOiAnVVBEQVRFX1NFVFRJTkdTJyxcblx0XHRzZXR0aW5nczogc2V0dGluZ3MsXG5cdH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzYXZlQnVpbGRlciA9ICggc2V0dGluZywgdmFsdWUgKSA9PiBkaXNwYXRjaCA9PiB7XG5cdC8vIEVtcHR5IGdsb2JhbCBjaGFuZ2VkIHZhcmlhYmxlXG5cdHdpbmRvdy5mb3JtaW5hdG9yQ2hhbmdlcyA9IHtcblx0XHRhbnN3ZXJzOiBbXSxcblx0XHRzZXR0aW5nczogZmFsc2UsXG5cdFx0c2F2ZWQ6IHRydWUsXG5cdH07XG5cblx0ZGlzcGF0Y2goIHtcblx0XHR0eXBlOiAnVVBEQVRFX1NFVFRJTkcnLFxuXHRcdHNldHRpbmc6IHNldHRpbmcsXG5cdFx0dmFsdWU6IHZhbHVlXG5cdH0gKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9hY3Rpb25zL3NldHRpbmdzLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzJztcbmltcG9ydCBOb3RpZmljYXRpb24gZnJvbSAnLi4vLi4vLi4vbm90aWZpY2F0aW9ucyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ldGFEcm9wZG93biBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblxuXHRcdGNvbnN0IE1ldGFEYXRhID0ge1xuXHRcdFx0Zm9ybToge1xuXHRcdFx0XHRzaG9ydGNvZGU6ICdmb3JtaW5hdG9yX2Zvcm0nLFxuXHRcdFx0XHR0eXBlOiAnZm9ybScsXG5cdFx0XHRcdHByb2Nlc3NBY3Rpb246IGZvcm1pbmF0b3JEYXRhLmFkbWluVXJsICsgJ2FkbWluLnBocD9wYWdlPWZvcm1pbmF0b3ItY2Zvcm0nLFxuXHRcdFx0XHRwcm9jZXNzTm9uY2U6IGZvcm1pbmF0b3JEYXRhLmZvcm1Qcm9jZXNzTm9uY2UsXG5cdFx0XHRcdGV4cG9ydE5vbmNlOiBmb3JtaW5hdG9yRGF0YS5mb3JtRXhwb3J0Tm9uY2UsXG5cdFx0XHRcdHN1Ym1pc3Npb25zOiBmb3JtaW5hdG9yRGF0YS5hZG1pblVybCArXG5cdFx0XHRcdFx0J2FkbWluLnBocD9wYWdlPWZvcm1pbmF0b3ItZW50cmllcyZmb3JtX3R5cGU9Zm9ybWluYXRvcl9mb3JtcyZmb3JtX2lkPScgK1xuXHRcdFx0XHRcdHRoaXMucHJvcHMuaWQsXG5cdFx0XHRcdGRyb3Bkb3duTGFiZWw6IHRyYW5zbGF0ZSggJ09wZW4gZm9ybSBvcHRpb25zJyApLFxuXHRcdFx0fSxcblx0XHRcdHBvbGw6IHtcblx0XHRcdFx0c2hvcnRjb2RlOiAnZm9ybWluYXRvcl9wb2xsJyxcblx0XHRcdFx0dHlwZTogJ3BvbGwnLFxuXHRcdFx0XHRwcm9jZXNzQWN0aW9uOiBmb3JtaW5hdG9yRGF0YS5hZG1pblVybCArICdhZG1pbi5waHA/cGFnZT1mb3JtaW5hdG9yLXBvbGwnLFxuXHRcdFx0XHRwcm9jZXNzTm9uY2U6IGZvcm1pbmF0b3JEYXRhLnBvbGxQcm9jZXNzTm9uY2UsXG5cdFx0XHRcdGV4cG9ydE5vbmNlOiBmb3JtaW5hdG9yRGF0YS5wb2xsRXhwb3J0Tm9uY2UsXG5cdFx0XHRcdHN1Ym1pc3Npb25zOiBmb3JtaW5hdG9yRGF0YS5hZG1pblVybCArXG5cdFx0XHRcdFx0J2FkbWluLnBocD9wYWdlPWZvcm1pbmF0b3ItZW50cmllcyZmb3JtX3R5cGU9Zm9ybWluYXRvcl9wb2xscyZmb3JtX2lkPScgK1xuXHRcdFx0XHRcdHRoaXMucHJvcHMuaWQsXG5cdFx0XHRcdGRyb3Bkb3duTGFiZWw6IHRyYW5zbGF0ZSggJ09wZW4gcG9sbCBvcHRpb25zJyApLFxuXHRcdFx0fSxcblx0XHRcdHF1aXo6IHtcblx0XHRcdFx0c2hvcnRjb2RlOiAnZm9ybWluYXRvcl9xdWl6Jyxcblx0XHRcdFx0dHlwZTogJ3F1aXonLFxuXHRcdFx0XHRwcm9jZXNzQWN0aW9uOiBmb3JtaW5hdG9yRGF0YS5hZG1pblVybCArICdhZG1pbi5waHA/cGFnZT1mb3JtaW5hdG9yLXF1aXonLFxuXHRcdFx0XHRwcm9jZXNzTm9uY2U6IGZvcm1pbmF0b3JEYXRhLnF1aXpQcm9jZXNzTm9uY2UsXG5cdFx0XHRcdGV4cG9ydE5vbmNlOiBmb3JtaW5hdG9yRGF0YS5xdWl6RXhwb3J0Tm9uY2UsXG5cdFx0XHRcdHN1Ym1pc3Npb25zOiBmb3JtaW5hdG9yRGF0YS5hZG1pblVybCArXG5cdFx0XHRcdFx0J2FkbWluLnBocD9wYWdlPWZvcm1pbmF0b3ItZW50cmllcyZmb3JtX3R5cGU9Zm9ybWluYXRvcl9xdWl6emVzJmZvcm1faWQ9JyArXG5cdFx0XHRcdFx0dGhpcy5wcm9wcy5pZCxcblx0XHRcdFx0ZHJvcGRvd25MYWJlbDogdHJhbnNsYXRlKCAnT3BlbiBxdWl6IG9wdGlvbnMnICksXG5cdFx0XHR9LFxuXHRcdH07XG5cblx0XHR0aGlzLmNvcHlUb0NsaXBib2FyZCA9IHRoaXMuY29weVRvQ2xpcGJvYXJkLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLnJlc2V0VHJhY2tpbmdEYXRhID0gdGhpcy5yZXNldFRyYWNraW5nRGF0YS5iaW5kKCB0aGlzICk7XG5cdFx0dGhpcy5kYXRhID0gTWV0YURhdGFbIHRoaXMucHJvcHMudHlwZSBdO1xuXHR9XG5cblx0Y29weVRvQ2xpcGJvYXJkKCkge1xuXHRcdHRoaXMuaW5wdXQuc2VsZWN0KCk7XG5cblx0XHRkb2N1bWVudC5leGVjQ29tbWFuZCggJ2NvcHknICk7XG5cblx0XHRjb25zdCBjdXN0b20gPSBuZXcgTm90aWZpY2F0aW9uKCB7XG5cdFx0XHR0eXBlOiAnc3VjY2VzcycsXG5cdFx0XHR0ZXh0OiB0cmFuc2xhdGUoICdTaG9ydGNvZGUgaGFzIGJlZW4gY29waWVkIHN1Y2Nlc3NmdWxseS4nICksXG5cdFx0XHR0aW1lOiA0MDAwLFxuXHRcdH0gKTtcblx0XHRjdXN0b20ub3BlbigpO1xuXHR9XG5cblx0cmVzZXRUcmFja2luZ0RhdGEoKSB7XG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdGFjdGlvbjogJ2Zvcm1pbmF0b3JfcmVzZXRfdHJhY2tpbmdfZGF0YScsXG5cdFx0XHRfYWpheF9ub25jZTogZm9ybWluYXRvckRhdGEucmVzZXRUcmFja2luZ0RhdGFOb25jZSxcblx0XHRcdGlkOiB0aGlzLnByb3BzLmlkLFxuXG5cdFx0fTtcblxuXHRcdHRoaXMuYWpheCA9IGpRdWVyeVxuXHRcdFx0LnBvc3QoIHtcblx0XHRcdFx0dXJsOiBmb3JtaW5hdG9yRGF0YS5hamF4VXJsLFxuXHRcdFx0XHR0eXBlOiAncG9zdCcsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHR9IClcblx0XHRcdC5kb25lKCBmdW5jdGlvbiggcmVzdWx0ICkge1xuXHRcdFx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdFx0XHRsZXQgdHlwZSA9IHJlc3VsdC5zdWNjZXNzID8gJ3N1Y2Nlc3MnIDogJ2Vycm9yJyxcblx0XHRcdFx0XHRcdHRleHQgPSByZXN1bHQuZGF0YSB8fCB0cmFuc2xhdGUoICdTb21ldGhpbmcgd2VudCB3cm9uZy4nIClcblxuXHRcdFx0XHRcdGNvbnN0IGN1c3RvbSA9IG5ldyBOb3RpZmljYXRpb24oIHtcblx0XHRcdFx0XHRcdHR5cGUsXG5cdFx0XHRcdFx0XHR0ZXh0LFxuXHRcdFx0XHRcdFx0dGltZTogNDAwMCxcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0Y3VzdG9tLm9wZW4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGV4cG9ydFVybCA9IHRoaXMuZGF0YS5wcm9jZXNzQWN0aW9uICsgJyZleHBvcnQ9dHJ1ZSZtb2R1bGVfaWQ9JyArXG5cdFx0XHR0aGlzLnByb3BzLmlkICsgJyZleHBvcnRub25jZT0nICsgdGhpcy5kYXRhLmV4cG9ydE5vbmNlICtcblx0XHRcdCcmbW9kdWxlX3R5cGU9JyArIHRoaXMuZGF0YS50eXBlXG5cdFx0O1xuXG5cdFx0Y29uc3QgZGVsZXRlVXJsID0gdGhpcy5kYXRhLnByb2Nlc3NBY3Rpb24gKyAnJmRlbGV0ZT10cnVlJm1vZHVsZV9pZD0nICtcblx0XHRcdHRoaXMucHJvcHMuaWQgKyAnJm5vbmNlPScgKyB0aGlzLmRhdGEucHJvY2Vzc05vbmNlICtcblx0XHRcdCcmbW9kdWxlX3R5cGU9JyArIHRoaXMuZGF0YS50eXBlXG5cdFx0O1xuXG5cdFx0bGV0IHRvb2x0aXAgPSB0cmFuc2xhdGUoICdDcmVhdGUgTmV3IEZvcm0nICk7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMudHlwZSA9PT0gJ3BvbGwnICkge1xuXHRcdFx0dG9vbHRpcCA9IHRyYW5zbGF0ZSggJ0NyZWF0ZSBOZXcgUG9sbCcgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMucHJvcHMudHlwZSA9PT0gJ3F1aXonICkge1xuXHRcdFx0dG9vbHRpcCA9IHRyYW5zbGF0ZSggJ0NyZWF0ZSBOZXcgUXVpeicgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXG5cdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdHR5cGU9XCJ0ZXh0XCJcblx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9eyBgWyR7IHRoaXMuZGF0YS5zaG9ydGNvZGUgfSBpZD1cIiR7IHRoaXMucHJvcHMuaWQgfVwiXWAgfVxuXHRcdFx0XHRcdGlkPVwiZm9ybWluYXRvci1mb3JtLXNob3J0Y29kZVwiXG5cdFx0XHRcdFx0c3R5bGU9eyB7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB0b3A6ICctMTUwMHB4JyB9IH1cblx0XHRcdFx0XHRhcmlhLWhpZGRlbj1cInRydWVcIlxuXHRcdFx0XHRcdHJlZj17ICggaW5wdXQgKSA9PiB0aGlzLmlucHV0ID0gaW5wdXQgfVxuXHRcdFx0XHQvPlxuXG5cdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRjbGFzc05hbWU9e1xuXHRcdFx0XHRcdFx0dGhpcy5wcm9wcy5oYXNMZWFkXG5cdFx0XHRcdFx0XHRcdD8gJ3N1aS1kcm9wZG93biBmdWktZHJvcGRvd24tc29vbidcblx0XHRcdFx0XHRcdFx0OiAnc3VpLWRyb3Bkb3duJ1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0PlxuXG5cdFx0XHRcdFx0PGJ1dHRvbiBjbGFzc05hbWU9XCJzdWktYnV0dG9uLWljb24gc3VpLWRyb3Bkb3duLWFuY2hvclwiIGFyaWEtbGFiZWw9XCJEcm9wZG93blwiPlxuXHRcdFx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWljb24td2lkZ2V0LXNldHRpbmdzLWNvbmZpZyBzdWktbWRcIlxuXHRcdFx0XHRcdFx0XHRhcmlhLWhpZGRlbj1cInRydWVcIlxuXHRcdFx0XHRcdFx0Pjwvc3Bhbj5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1zY3JlZW4tcmVhZGVyLXRleHRcIj57IHRoaXMuZGF0YS5kcm9wZG93bkxhYmVsIH08L3NwYW4+XG5cdFx0XHRcdFx0PC9idXR0b24+XG5cblx0XHRcdFx0XHQ8dWw+XG5cblx0XHRcdFx0XHRcdHsvKiogQ29weSBTaG9ydGNvZGUgKi99XG5cdFx0XHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJmb3JtaW5hdG9yLWZpZWxkLWVkaXRcIlxuXHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLmNvcHlUb0NsaXBib2FyZCB9XG5cdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktaWNvbi1jb2RlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnQ29weSBTaG9ydGNvZGUnICkgfVxuXHRcdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHRcdDwvbGk+XG5cblx0XHRcdFx0XHRcdHsvKiogVmlldyBTdWJtaXNzaW9ucyAqL31cblx0XHRcdFx0XHRcdDxsaT5cblx0XHRcdFx0XHRcdFx0PGFcblx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJmb3JtaW5hdG9yLWZpZWxkLWVkaXRcIlxuXHRcdFx0XHRcdFx0XHRcdGhyZWY9eyB0aGlzLmRhdGEuc3VibWlzc2lvbnMgfVxuXHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1pY29uLWNvbW11bml0eS1wZW9wbGVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0YXJpYS1oaWRkZW49XCJ0cnVlXCJcblx0XHRcdFx0XHRcdFx0XHQ+PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnVmlldyBTdWJtaXNzaW9ucycgKSB9XG5cdFx0XHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHRcdDwvbGk+XG5cblx0XHRcdFx0XHRcdHsvKiogRHVwbGljYXRlICovfVxuXHRcdFx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdFx0XHQ8Zm9ybSBtZXRob2Q9XCJwb3N0XCIgYWN0aW9uPXsgdGhpcy5kYXRhLnByb2Nlc3NBY3Rpb24gfT5cblx0XHRcdFx0XHRcdFx0XHQ8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9XCJmb3JtaW5hdG9yX2FjdGlvblwiIHZhbHVlPVwiY2xvbmVcIiAvPlxuXHRcdFx0XHRcdFx0XHRcdDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cImlkXCIgdmFsdWU9eyB0aGlzLnByb3BzLmlkIH0gLz5cblx0XHRcdFx0XHRcdFx0XHQ8aW5wdXQgdHlwZT1cImhpZGRlblwiIGlkPVwiZm9ybWluYXRvck5vbmNlXCJcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWU9XCJmb3JtaW5hdG9yTm9uY2VcIlxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWU9eyBmb3JtaW5hdG9yRGF0YS5jbG9uZU5vbmNlIH1cblx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHRcdDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cImZvcm1pbmF0b3JSZWRpcmVjdFwiIHZhbHVlPVwiZmFsc2VcIiAvPlxuXG5cdFx0XHRcdFx0XHRcdFx0eyB0aGlzLnByb3BzLmhhc0xlYWQgJiZcblx0XHRcdFx0XHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZT1cInN1Ym1pdFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRpc2FibGVkPVwiZGlzYWJsZWRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJmdWktYnV0dG9uLXdpdGgtdGFnIHN1aS10b29sdGlwIHN1aS10b29sdGlwLWxlZnQgc3VpLWNvbnN0cmFpbmVkXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS10b29sdGlwPXsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiRHVwbGljYXRlIGlzbid0IHN1cHBvcnRlZCBhdCB0aGUgbW9tZW50IFwiICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQnZm9yIHRoZSBxdWl6emVzIHdpdGggbGVhZCBjYXB0dXJpbmcgZW5hYmxlZC4nXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3BhblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1pY29uLXBhZ2UtbXVsdGlwbGVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cImZ1aS1idXR0b24tbGFiZWxcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0R1cGxpY2F0ZScgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXRhZyBzdWktdGFnLWJsdWUgc3VpLXRhZy1zbVwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnQ29taW5nIHNvb24nICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0eyAhIHRoaXMucHJvcHMuaGFzTGVhZCAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0PGJ1dHRvbiB0eXBlPVwic3VibWl0XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWljb24tcGFnZS1tdWx0aXBsZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJpYS1oaWRkZW49XCJ0cnVlXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Pjwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdEdXBsaWNhdGUnICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQ8L2Zvcm0+XG5cdFx0XHRcdFx0XHQ8L2xpPlxuXG5cdFx0XHRcdFx0XHR7LyoqIFJlc2V0IFRyYWNraW5nIERhdGEgKi99XG5cdFx0XHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cImZvcm1pbmF0b3ItZmllbGQtZWRpdFwiXG5cdFx0XHRcdFx0XHRcdFx0b25DbGljaz17IHRoaXMucmVzZXRUcmFja2luZ0RhdGEgfT5cblx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktaWNvbi11cGRhdGVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdSZXNldCBUcmFja2luZyBEYXRhJyApIH1cblx0XHRcdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdFx0PC9saT5cblxuXHRcdFx0XHRcdFx0ey8qKiBFeHBvcnQgKi99XG5cdFx0XHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5oYXNMZWFkICYmXG5cdFx0XHRcdFx0XHRcdFx0PGFcblx0XHRcdFx0XHRcdFx0XHRcdGhyZWY9XCIjXCJcblx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cImZ1aS1idXR0b24td2l0aC10YWcgc3VpLXRvb2x0aXAgc3VpLXRvb2x0aXAtbGVmdFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhLXRvb2x0aXA9eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFwiRXhwb3J0IGlzbid0IHN1cHBvcnRlZCBhdCB0aGUgbW9tZW50IGZvciBcIiArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCd0aGUgcXVpenplcyB3aXRoIGxlYWQgY2FwdHVyaW5nIGVuYWJsZWQuJ1xuXHRcdFx0XHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWljb24tY2xvdWQtbWlncmF0aW9uXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cImZ1aS1idXR0b24tbGFiZWxcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdFeHBvcnQnICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXRhZyBzdWktdGFnLWJsdWUgc3VpLXRhZy1zbVwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0NvbWluZyBzb29uJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0eyAhIHRoaXMucHJvcHMuaGFzTGVhZCAmJlxuXHRcdFx0XHRcdFx0XHRcdDxhXG5cdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJmb3JtaW5hdG9yLWZpZWxkLWVkaXRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0aHJlZj17IGV4cG9ydFVybCB9XG5cdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWljb24tY2xvdWQtbWlncmF0aW9uXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YXJpYS1oaWRkZW49XCJ0cnVlXCJcblx0XHRcdFx0XHRcdFx0XHRcdD48L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0V4cG9ydCcgKSB9XG5cdFx0XHRcdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQ8L2xpPlxuXG5cdFx0XHRcdFx0XHR7LyoqIERlbGV0ZSAqL31cblx0XHRcdFx0XHRcdDxsaT5cblx0XHRcdFx0XHRcdFx0PGFcblx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJmb3JtaW5hdG9yLWZpZWxkLWVkaXQgc3VpLW9wdGlvbi1yZWRcIlxuXHRcdFx0XHRcdFx0XHRcdGhyZWY9eyBkZWxldGVVcmwgfVxuXHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWljb24tdHJhc2hcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdEZWxldGUnICkgfVxuXHRcdFx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0XHQ8L2xpPlxuXG5cdFx0XHRcdFx0PC91bD5cblxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8YVxuXHRcdFx0XHRcdGhyZWY9eyBmb3JtaW5hdG9yRGF0YS5kYXNoYm9hcmRVcmwgKyAnJmNyZWF0ZW5ldz0nICsgdGhpcy5wcm9wcy50eXBlIH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktYnV0dG9uLWljb24gc3VpLXRvb2x0aXAgc3VpLXRvb2x0aXAtYm90dG9tXCJcblx0XHRcdFx0XHRkYXRhLXRvb2x0aXA9eyB0b29sdGlwIH1cblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1pY29uLXBsdXMgc3VpLW1kXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuXHRcdFx0XHQ8L2E+XG5cdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9jb250YWluZXJzL2xheW91dC9tZXRhLWRyb3Bkb3duLmpzIiwiLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggZ3JlYXRlci10aGFuIHNpZ24gcmVwbGFjZWQuXG4gKlxuICogTm90ZSB0aGF0IGlmIGEgcmVzb2x1dGlvbiBmb3IgVHJhYyM0NTM4NyBjb21lcyB0byBmcnVpdGlvbiwgaXQgaXMgbm8gbG9uZ2VyXG4gKiBuZWNlc3NhcnkgZm9yIGBfX3Vuc3RhYmxlRXNjYXBlR3JlYXRlclRoYW5gIHRvIGV4aXN0LlxuICpcbiAqIFNlZTogaHR0cHM6Ly9jb3JlLnRyYWMud29yZHByZXNzLm9yZy90aWNrZXQvNDUzODdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgT3JpZ2luYWwgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gRXNjYXBlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9fdW5zdGFibGVFc2NhcGVHcmVhdGVyVGhhbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXNjYXBlLWdyZWF0ZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdvcmRwcmVzcy9lc2NhcGUtaHRtbC9idWlsZC1tb2R1bGUvZXNjYXBlLWdyZWF0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMiLCIvKiEgQGxpY2Vuc2UgRE9NUHVyaWZ5IDMuMC4xIHwgKGMpIEN1cmU1MyBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHwgUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBsaWNlbnNlIDIuMCBhbmQgTW96aWxsYSBQdWJsaWMgTGljZW5zZSAyLjAgfCBnaXRodWIuY29tL2N1cmU1My9ET01QdXJpZnkvYmxvYi8zLjAuMS9MSUNFTlNFICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLkRPTVB1cmlmeSA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH0sIF90eXBlb2Yob2JqKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICAgIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICAgIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuXG4gICAgdmFyIF9zLCBfZTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gICAgaWYgKCFvKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cblxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkge1xuICAgIHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdO1xuXG4gICAgaWYgKCFpdCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIHZhciBGID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzOiBGLFxuICAgICAgICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGY6IEZcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICAgIH1cblxuICAgIHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSxcbiAgICAgICAgZGlkRXJyID0gZmFsc2UsXG4gICAgICAgIGVycjtcbiAgICByZXR1cm4ge1xuICAgICAgczogZnVuY3Rpb24gKCkge1xuICAgICAgICBpdCA9IGl0LmNhbGwobyk7XG4gICAgICB9LFxuICAgICAgbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTtcbiAgICAgICAgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTtcbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICB9LFxuICAgICAgZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZGlkRXJyID0gdHJ1ZTtcbiAgICAgICAgZXJyID0gZTtcbiAgICAgIH0sXG4gICAgICBmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGVudHJpZXMgPSBPYmplY3QuZW50cmllcyxcbiAgICAgIHNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mLFxuICAgICAgaXNGcm96ZW4gPSBPYmplY3QuaXNGcm96ZW4sXG4gICAgICBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gIHZhciBmcmVlemUgPSBPYmplY3QuZnJlZXplLFxuICAgICAgc2VhbCA9IE9iamVjdC5zZWFsLFxuICAgICAgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbXBvcnQvbm8tbXV0YWJsZS1leHBvcnRzXG5cbiAgdmFyIF9yZWYgPSB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdCxcbiAgICAgIGFwcGx5ID0gX3JlZi5hcHBseSxcbiAgICAgIGNvbnN0cnVjdCA9IF9yZWYuY29uc3RydWN0O1xuXG4gIGlmICghYXBwbHkpIHtcbiAgICBhcHBseSA9IGZ1bmN0aW9uIGFwcGx5KGZ1biwgdGhpc1ZhbHVlLCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuLmFwcGx5KHRoaXNWYWx1ZSwgYXJncyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghZnJlZXplKSB7XG4gICAgZnJlZXplID0gZnVuY3Rpb24gZnJlZXplKHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gIH1cblxuICBpZiAoIXNlYWwpIHtcbiAgICBzZWFsID0gZnVuY3Rpb24gc2VhbCh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFjb25zdHJ1Y3QpIHtcbiAgICBjb25zdHJ1Y3QgPSBmdW5jdGlvbiBjb25zdHJ1Y3QoRnVuYywgYXJncykge1xuICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoRnVuYywgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGFycmF5Rm9yRWFjaCA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLmZvckVhY2gpO1xuICB2YXIgYXJyYXlQb3AgPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5wb3ApO1xuICB2YXIgYXJyYXlQdXNoID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gIHZhciBzdHJpbmdUb0xvd2VyQ2FzZSA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS50b0xvd2VyQ2FzZSk7XG4gIHZhciBzdHJpbmdUb1N0cmluZyA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyk7XG4gIHZhciBzdHJpbmdNYXRjaCA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5tYXRjaCk7XG4gIHZhciBzdHJpbmdSZXBsYWNlID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xuICB2YXIgc3RyaW5nSW5kZXhPZiA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mKTtcbiAgdmFyIHN0cmluZ1RyaW0gPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudHJpbSk7XG4gIHZhciByZWdFeHBUZXN0ID0gdW5hcHBseShSZWdFeHAucHJvdG90eXBlLnRlc3QpO1xuICB2YXIgdHlwZUVycm9yQ3JlYXRlID0gdW5jb25zdHJ1Y3QoVHlwZUVycm9yKTtcbiAgZnVuY3Rpb24gdW5hcHBseShmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0aGlzQXJnKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncyk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB1bmNvbnN0cnVjdChmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb25zdHJ1Y3QoZnVuYywgYXJncyk7XG4gICAgfTtcbiAgfVxuICAvKiBBZGQgcHJvcGVydGllcyB0byBhIGxvb2t1cCB0YWJsZSAqL1xuXG4gIGZ1bmN0aW9uIGFkZFRvU2V0KHNldCwgYXJyYXksIHRyYW5zZm9ybUNhc2VGdW5jKSB7XG4gICAgdHJhbnNmb3JtQ2FzZUZ1bmMgPSB0cmFuc2Zvcm1DYXNlRnVuYyA/IHRyYW5zZm9ybUNhc2VGdW5jIDogc3RyaW5nVG9Mb3dlckNhc2U7XG5cbiAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIC8vIE1ha2UgJ2luJyBhbmQgdHJ1dGh5IGNoZWNrcyBsaWtlIEJvb2xlYW4oc2V0LmNvbnN0cnVjdG9yKVxuICAgICAgLy8gaW5kZXBlbmRlbnQgb2YgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiBPYmplY3QucHJvdG90eXBlLlxuICAgICAgLy8gUHJldmVudCBwcm90b3R5cGUgc2V0dGVycyBmcm9tIGludGVyY2VwdGluZyBzZXQgYXMgYSB0aGlzIHZhbHVlLlxuICAgICAgc2V0UHJvdG90eXBlT2Yoc2V0LCBudWxsKTtcbiAgICB9XG5cbiAgICB2YXIgbCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlIChsLS0pIHtcbiAgICAgIHZhciBlbGVtZW50ID0gYXJyYXlbbF07XG5cbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGxjRWxlbWVudCA9IHRyYW5zZm9ybUNhc2VGdW5jKGVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChsY0VsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBDb25maWcgcHJlc2V0cyAoZS5nLiB0YWdzLmpzLCBhdHRycy5qcykgYXJlIGltbXV0YWJsZS5cbiAgICAgICAgICBpZiAoIWlzRnJvemVuKGFycmF5KSkge1xuICAgICAgICAgICAgYXJyYXlbbF0gPSBsY0VsZW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudCA9IGxjRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXRbZWxlbWVudF0gPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBzZXQ7XG4gIH1cbiAgLyogU2hhbGxvdyBjbG9uZSBhbiBvYmplY3QgKi9cblxuICBmdW5jdGlvbiBjbG9uZShvYmplY3QpIHtcbiAgICB2YXIgbmV3T2JqZWN0ID0gY3JlYXRlKG51bGwpO1xuXG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGVudHJpZXMob2JqZWN0KSksXG4gICAgICAgIF9zdGVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgIHByb3BlcnR5ID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgICB2YWx1ZSA9IF9zdGVwJHZhbHVlWzFdO1xuXG4gICAgICAgIG5ld09iamVjdFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld09iamVjdDtcbiAgfVxuICAvKiBUaGlzIG1ldGhvZCBhdXRvbWF0aWNhbGx5IGNoZWNrcyBpZiB0aGUgcHJvcCBpcyBmdW5jdGlvblxuICAgKiBvciBnZXR0ZXIgYW5kIGJlaGF2ZXMgYWNjb3JkaW5nbHkuICovXG5cbiAgZnVuY3Rpb24gbG9va3VwR2V0dGVyKG9iamVjdCwgcHJvcCkge1xuICAgIHdoaWxlIChvYmplY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcCk7XG5cbiAgICAgIGlmIChkZXNjKSB7XG4gICAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICAgIHJldHVybiB1bmFwcGx5KGRlc2MuZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGVzYy52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB1bmFwcGx5KGRlc2MudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmFsbGJhY2tWYWx1ZShlbGVtZW50KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2ZhbGxiYWNrIHZhbHVlIGZvcicsIGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbGxiYWNrVmFsdWU7XG4gIH1cblxuICB2YXIgaHRtbCQxID0gZnJlZXplKFsnYScsICdhYmJyJywgJ2Fjcm9ueW0nLCAnYWRkcmVzcycsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYXVkaW8nLCAnYicsICdiZGknLCAnYmRvJywgJ2JpZycsICdibGluaycsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhbnZhcycsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjaXRlJywgJ2NvZGUnLCAnY29sJywgJ2NvbGdyb3VwJywgJ2NvbnRlbnQnLCAnZGF0YScsICdkYXRhbGlzdCcsICdkZCcsICdkZWNvcmF0b3InLCAnZGVsJywgJ2RldGFpbHMnLCAnZGZuJywgJ2RpYWxvZycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VsZW1lbnQnLCAnZW0nLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9udCcsICdmb290ZXInLCAnZm9ybScsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpJywgJ2ltZycsICdpbnB1dCcsICdpbnMnLCAna2JkJywgJ2xhYmVsJywgJ2xlZ2VuZCcsICdsaScsICdtYWluJywgJ21hcCcsICdtYXJrJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRlcicsICduYXYnLCAnbm9icicsICdvbCcsICdvcHRncm91cCcsICdvcHRpb24nLCAnb3V0cHV0JywgJ3AnLCAncGljdHVyZScsICdwcmUnLCAncHJvZ3Jlc3MnLCAncScsICdycCcsICdydCcsICdydWJ5JywgJ3MnLCAnc2FtcCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzaGFkb3cnLCAnc21hbGwnLCAnc291cmNlJywgJ3NwYWNlcicsICdzcGFuJywgJ3N0cmlrZScsICdzdHJvbmcnLCAnc3R5bGUnLCAnc3ViJywgJ3N1bW1hcnknLCAnc3VwJywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpbWUnLCAndHInLCAndHJhY2snLCAndHQnLCAndScsICd1bCcsICd2YXInLCAndmlkZW8nLCAnd2JyJ10pOyAvLyBTVkdcblxuICB2YXIgc3ZnJDEgPSBmcmVlemUoWydzdmcnLCAnYScsICdhbHRnbHlwaCcsICdhbHRnbHlwaGRlZicsICdhbHRnbHlwaGl0ZW0nLCAnYW5pbWF0ZWNvbG9yJywgJ2FuaW1hdGVtb3Rpb24nLCAnYW5pbWF0ZXRyYW5zZm9ybScsICdjaXJjbGUnLCAnY2xpcHBhdGgnLCAnZGVmcycsICdkZXNjJywgJ2VsbGlwc2UnLCAnZmlsdGVyJywgJ2ZvbnQnLCAnZycsICdnbHlwaCcsICdnbHlwaHJlZicsICdoa2VybicsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhcmdyYWRpZW50JywgJ21hcmtlcicsICdtYXNrJywgJ21ldGFkYXRhJywgJ21wYXRoJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbGdyYWRpZW50JywgJ3JlY3QnLCAnc3RvcCcsICdzdHlsZScsICdzd2l0Y2gnLCAnc3ltYm9sJywgJ3RleHQnLCAndGV4dHBhdGgnLCAndGl0bGUnLCAndHJlZicsICd0c3BhbicsICd2aWV3JywgJ3ZrZXJuJ10pO1xuICB2YXIgc3ZnRmlsdGVycyA9IGZyZWV6ZShbJ2ZlQmxlbmQnLCAnZmVDb2xvck1hdHJpeCcsICdmZUNvbXBvbmVudFRyYW5zZmVyJywgJ2ZlQ29tcG9zaXRlJywgJ2ZlQ29udm9sdmVNYXRyaXgnLCAnZmVEaWZmdXNlTGlnaHRpbmcnLCAnZmVEaXNwbGFjZW1lbnRNYXAnLCAnZmVEaXN0YW50TGlnaHQnLCAnZmVGbG9vZCcsICdmZUZ1bmNBJywgJ2ZlRnVuY0InLCAnZmVGdW5jRycsICdmZUZ1bmNSJywgJ2ZlR2F1c3NpYW5CbHVyJywgJ2ZlSW1hZ2UnLCAnZmVNZXJnZScsICdmZU1lcmdlTm9kZScsICdmZU1vcnBob2xvZ3knLCAnZmVPZmZzZXQnLCAnZmVQb2ludExpZ2h0JywgJ2ZlU3BlY3VsYXJMaWdodGluZycsICdmZVNwb3RMaWdodCcsICdmZVRpbGUnLCAnZmVUdXJidWxlbmNlJ10pOyAvLyBMaXN0IG9mIFNWRyBlbGVtZW50cyB0aGF0IGFyZSBkaXNhbGxvd2VkIGJ5IGRlZmF1bHQuXG4gIC8vIFdlIHN0aWxsIG5lZWQgdG8ga25vdyB0aGVtIHNvIHRoYXQgd2UgY2FuIGRvIG5hbWVzcGFjZVxuICAvLyBjaGVja3MgcHJvcGVybHkgaW4gY2FzZSBvbmUgd2FudHMgdG8gYWRkIHRoZW0gdG9cbiAgLy8gYWxsb3ctbGlzdC5cblxuICB2YXIgc3ZnRGlzYWxsb3dlZCA9IGZyZWV6ZShbJ2FuaW1hdGUnLCAnY29sb3ItcHJvZmlsZScsICdjdXJzb3InLCAnZGlzY2FyZCcsICdmZWRyb3BzaGFkb3cnLCAnZm9udC1mYWNlJywgJ2ZvbnQtZmFjZS1mb3JtYXQnLCAnZm9udC1mYWNlLW5hbWUnLCAnZm9udC1mYWNlLXNyYycsICdmb250LWZhY2UtdXJpJywgJ2ZvcmVpZ25vYmplY3QnLCAnaGF0Y2gnLCAnaGF0Y2hwYXRoJywgJ21lc2gnLCAnbWVzaGdyYWRpZW50JywgJ21lc2hwYXRjaCcsICdtZXNocm93JywgJ21pc3NpbmctZ2x5cGgnLCAnc2NyaXB0JywgJ3NldCcsICdzb2xpZGNvbG9yJywgJ3Vua25vd24nLCAndXNlJ10pO1xuICB2YXIgbWF0aE1sJDEgPSBmcmVlemUoWydtYXRoJywgJ21lbmNsb3NlJywgJ21lcnJvcicsICdtZmVuY2VkJywgJ21mcmFjJywgJ21nbHlwaCcsICdtaScsICdtbGFiZWxlZHRyJywgJ21tdWx0aXNjcmlwdHMnLCAnbW4nLCAnbW8nLCAnbW92ZXInLCAnbXBhZGRlZCcsICdtcGhhbnRvbScsICdtcm9vdCcsICdtcm93JywgJ21zJywgJ21zcGFjZScsICdtc3FydCcsICdtc3R5bGUnLCAnbXN1YicsICdtc3VwJywgJ21zdWJzdXAnLCAnbXRhYmxlJywgJ210ZCcsICdtdGV4dCcsICdtdHInLCAnbXVuZGVyJywgJ211bmRlcm92ZXInXSk7IC8vIFNpbWlsYXJseSB0byBTVkcsIHdlIHdhbnQgdG8ga25vdyBhbGwgTWF0aE1MIGVsZW1lbnRzLFxuICAvLyBldmVuIHRob3NlIHRoYXQgd2UgZGlzYWxsb3cgYnkgZGVmYXVsdC5cblxuICB2YXIgbWF0aE1sRGlzYWxsb3dlZCA9IGZyZWV6ZShbJ21hY3Rpb24nLCAnbWFsaWduZ3JvdXAnLCAnbWFsaWdubWFyaycsICdtbG9uZ2RpdicsICdtc2NhcnJpZXMnLCAnbXNjYXJyeScsICdtc2dyb3VwJywgJ21zdGFjaycsICdtc2xpbmUnLCAnbXNyb3cnLCAnc2VtYW50aWNzJywgJ2Fubm90YXRpb24nLCAnYW5ub3RhdGlvbi14bWwnLCAnbXByZXNjcmlwdHMnLCAnbm9uZSddKTtcbiAgdmFyIHRleHQgPSBmcmVlemUoWycjdGV4dCddKTtcblxuICB2YXIgaHRtbCA9IGZyZWV6ZShbJ2FjY2VwdCcsICdhY3Rpb24nLCAnYWxpZ24nLCAnYWx0JywgJ2F1dG9jYXBpdGFsaXplJywgJ2F1dG9jb21wbGV0ZScsICdhdXRvcGljdHVyZWlucGljdHVyZScsICdhdXRvcGxheScsICdiYWNrZ3JvdW5kJywgJ2JnY29sb3InLCAnYm9yZGVyJywgJ2NhcHR1cmUnLCAnY2VsbHBhZGRpbmcnLCAnY2VsbHNwYWNpbmcnLCAnY2hlY2tlZCcsICdjaXRlJywgJ2NsYXNzJywgJ2NsZWFyJywgJ2NvbG9yJywgJ2NvbHMnLCAnY29sc3BhbicsICdjb250cm9scycsICdjb250cm9sc2xpc3QnLCAnY29vcmRzJywgJ2Nyb3Nzb3JpZ2luJywgJ2RhdGV0aW1lJywgJ2RlY29kaW5nJywgJ2RlZmF1bHQnLCAnZGlyJywgJ2Rpc2FibGVkJywgJ2Rpc2FibGVwaWN0dXJlaW5waWN0dXJlJywgJ2Rpc2FibGVyZW1vdGVwbGF5YmFjaycsICdkb3dubG9hZCcsICdkcmFnZ2FibGUnLCAnZW5jdHlwZScsICdlbnRlcmtleWhpbnQnLCAnZmFjZScsICdmb3InLCAnaGVhZGVycycsICdoZWlnaHQnLCAnaGlkZGVuJywgJ2hpZ2gnLCAnaHJlZicsICdocmVmbGFuZycsICdpZCcsICdpbnB1dG1vZGUnLCAnaW50ZWdyaXR5JywgJ2lzbWFwJywgJ2tpbmQnLCAnbGFiZWwnLCAnbGFuZycsICdsaXN0JywgJ2xvYWRpbmcnLCAnbG9vcCcsICdsb3cnLCAnbWF4JywgJ21heGxlbmd0aCcsICdtZWRpYScsICdtZXRob2QnLCAnbWluJywgJ21pbmxlbmd0aCcsICdtdWx0aXBsZScsICdtdXRlZCcsICduYW1lJywgJ25vbmNlJywgJ25vc2hhZGUnLCAnbm92YWxpZGF0ZScsICdub3dyYXAnLCAnb3BlbicsICdvcHRpbXVtJywgJ3BhdHRlcm4nLCAncGxhY2Vob2xkZXInLCAncGxheXNpbmxpbmUnLCAncG9zdGVyJywgJ3ByZWxvYWQnLCAncHViZGF0ZScsICdyYWRpb2dyb3VwJywgJ3JlYWRvbmx5JywgJ3JlbCcsICdyZXF1aXJlZCcsICdyZXYnLCAncmV2ZXJzZWQnLCAncm9sZScsICdyb3dzJywgJ3Jvd3NwYW4nLCAnc3BlbGxjaGVjaycsICdzY29wZScsICdzZWxlY3RlZCcsICdzaGFwZScsICdzaXplJywgJ3NpemVzJywgJ3NwYW4nLCAnc3JjbGFuZycsICdzdGFydCcsICdzcmMnLCAnc3Jjc2V0JywgJ3N0ZXAnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJpbmRleCcsICd0aXRsZScsICd0cmFuc2xhdGUnLCAndHlwZScsICd1c2VtYXAnLCAndmFsaWduJywgJ3ZhbHVlJywgJ3dpZHRoJywgJ3htbG5zJywgJ3Nsb3QnXSk7XG4gIHZhciBzdmcgPSBmcmVlemUoWydhY2NlbnQtaGVpZ2h0JywgJ2FjY3VtdWxhdGUnLCAnYWRkaXRpdmUnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FzY2VudCcsICdhdHRyaWJ1dGVuYW1lJywgJ2F0dHJpYnV0ZXR5cGUnLCAnYXppbXV0aCcsICdiYXNlZnJlcXVlbmN5JywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2JlZ2luJywgJ2JpYXMnLCAnYnknLCAnY2xhc3MnLCAnY2xpcCcsICdjbGlwcGF0aHVuaXRzJywgJ2NsaXAtcGF0aCcsICdjbGlwLXJ1bGUnLCAnY29sb3InLCAnY29sb3ItaW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnY29sb3ItcHJvZmlsZScsICdjb2xvci1yZW5kZXJpbmcnLCAnY3gnLCAnY3knLCAnZCcsICdkeCcsICdkeScsICdkaWZmdXNlY29uc3RhbnQnLCAnZGlyZWN0aW9uJywgJ2Rpc3BsYXknLCAnZGl2aXNvcicsICdkdXInLCAnZWRnZW1vZGUnLCAnZWxldmF0aW9uJywgJ2VuZCcsICdmaWxsJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmlsdGVyJywgJ2ZpbHRlcnVuaXRzJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2Z4JywgJ2Z5JywgJ2cxJywgJ2cyJywgJ2dseXBoLW5hbWUnLCAnZ2x5cGhyZWYnLCAnZ3JhZGllbnR1bml0cycsICdncmFkaWVudHRyYW5zZm9ybScsICdoZWlnaHQnLCAnaHJlZicsICdpZCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnaW4nLCAnaW4yJywgJ2snLCAnazEnLCAnazInLCAnazMnLCAnazQnLCAna2VybmluZycsICdrZXlwb2ludHMnLCAna2V5c3BsaW5lcycsICdrZXl0aW1lcycsICdsYW5nJywgJ2xlbmd0aGFkanVzdCcsICdsZXR0ZXItc3BhY2luZycsICdrZXJuZWxtYXRyaXgnLCAna2VybmVsdW5pdGxlbmd0aCcsICdsaWdodGluZy1jb2xvcicsICdsb2NhbCcsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ21hcmtlcmhlaWdodCcsICdtYXJrZXJ1bml0cycsICdtYXJrZXJ3aWR0aCcsICdtYXNrY29udGVudHVuaXRzJywgJ21hc2t1bml0cycsICdtYXgnLCAnbWFzaycsICdtZWRpYScsICdtZXRob2QnLCAnbW9kZScsICdtaW4nLCAnbmFtZScsICdudW1vY3RhdmVzJywgJ29mZnNldCcsICdvcGVyYXRvcicsICdvcGFjaXR5JywgJ29yZGVyJywgJ29yaWVudCcsICdvcmllbnRhdGlvbicsICdvcmlnaW4nLCAnb3ZlcmZsb3cnLCAncGFpbnQtb3JkZXInLCAncGF0aCcsICdwYXRobGVuZ3RoJywgJ3BhdHRlcm5jb250ZW50dW5pdHMnLCAncGF0dGVybnRyYW5zZm9ybScsICdwYXR0ZXJudW5pdHMnLCAncG9pbnRzJywgJ3ByZXNlcnZlYWxwaGEnLCAncHJlc2VydmVhc3BlY3RyYXRpbycsICdwcmltaXRpdmV1bml0cycsICdyJywgJ3J4JywgJ3J5JywgJ3JhZGl1cycsICdyZWZ4JywgJ3JlZnknLCAncmVwZWF0Y291bnQnLCAncmVwZWF0ZHVyJywgJ3Jlc3RhcnQnLCAncmVzdWx0JywgJ3JvdGF0ZScsICdzY2FsZScsICdzZWVkJywgJ3NoYXBlLXJlbmRlcmluZycsICdzcGVjdWxhcmNvbnN0YW50JywgJ3NwZWN1bGFyZXhwb25lbnQnLCAnc3ByZWFkbWV0aG9kJywgJ3N0YXJ0b2Zmc2V0JywgJ3N0ZGRldmlhdGlvbicsICdzdGl0Y2h0aWxlcycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2UnLCAnc3Ryb2tlLXdpZHRoJywgJ3N0eWxlJywgJ3N1cmZhY2VzY2FsZScsICdzeXN0ZW1sYW5ndWFnZScsICd0YWJpbmRleCcsICd0YXJnZXR4JywgJ3RhcmdldHknLCAndHJhbnNmb3JtJywgJ3RyYW5zZm9ybS1vcmlnaW4nLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3RleHRsZW5ndGgnLCAndHlwZScsICd1MScsICd1MicsICd1bmljb2RlJywgJ3ZhbHVlcycsICd2aWV3Ym94JywgJ3Zpc2liaWxpdHknLCAndmVyc2lvbicsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3aWR0aCcsICd3b3JkLXNwYWNpbmcnLCAnd3JhcCcsICd3cml0aW5nLW1vZGUnLCAneGNoYW5uZWxzZWxlY3RvcicsICd5Y2hhbm5lbHNlbGVjdG9yJywgJ3gnLCAneDEnLCAneDInLCAneG1sbnMnLCAneScsICd5MScsICd5MicsICd6JywgJ3pvb21hbmRwYW4nXSk7XG4gIHZhciBtYXRoTWwgPSBmcmVlemUoWydhY2NlbnQnLCAnYWNjZW50dW5kZXInLCAnYWxpZ24nLCAnYmV2ZWxsZWQnLCAnY2xvc2UnLCAnY29sdW1uc2FsaWduJywgJ2NvbHVtbmxpbmVzJywgJ2NvbHVtbnNwYW4nLCAnZGVub21hbGlnbicsICdkZXB0aCcsICdkaXInLCAnZGlzcGxheScsICdkaXNwbGF5c3R5bGUnLCAnZW5jb2RpbmcnLCAnZmVuY2UnLCAnZnJhbWUnLCAnaGVpZ2h0JywgJ2hyZWYnLCAnaWQnLCAnbGFyZ2VvcCcsICdsZW5ndGgnLCAnbGluZXRoaWNrbmVzcycsICdsc3BhY2UnLCAnbHF1b3RlJywgJ21hdGhiYWNrZ3JvdW5kJywgJ21hdGhjb2xvcicsICdtYXRoc2l6ZScsICdtYXRodmFyaWFudCcsICdtYXhzaXplJywgJ21pbnNpemUnLCAnbW92YWJsZWxpbWl0cycsICdub3RhdGlvbicsICdudW1hbGlnbicsICdvcGVuJywgJ3Jvd2FsaWduJywgJ3Jvd2xpbmVzJywgJ3Jvd3NwYWNpbmcnLCAncm93c3BhbicsICdyc3BhY2UnLCAncnF1b3RlJywgJ3NjcmlwdGxldmVsJywgJ3NjcmlwdG1pbnNpemUnLCAnc2NyaXB0c2l6ZW11bHRpcGxpZXInLCAnc2VsZWN0aW9uJywgJ3NlcGFyYXRvcicsICdzZXBhcmF0b3JzJywgJ3N0cmV0Y2h5JywgJ3N1YnNjcmlwdHNoaWZ0JywgJ3N1cHNjcmlwdHNoaWZ0JywgJ3N5bW1ldHJpYycsICd2b2Zmc2V0JywgJ3dpZHRoJywgJ3htbG5zJ10pO1xuICB2YXIgeG1sID0gZnJlZXplKFsneGxpbms6aHJlZicsICd4bWw6aWQnLCAneGxpbms6dGl0bGUnLCAneG1sOnNwYWNlJywgJ3htbG5zOnhsaW5rJ10pO1xuXG4gIHZhciBNVVNUQUNIRV9FWFBSID0gc2VhbCgvXFx7XFx7W1xcd1xcV10qfFtcXHdcXFddKlxcfVxcfS9nbSk7IC8vIFNwZWNpZnkgdGVtcGxhdGUgZGV0ZWN0aW9uIHJlZ2V4IGZvciBTQUZFX0ZPUl9URU1QTEFURVMgbW9kZVxuXG4gIHZhciBFUkJfRVhQUiA9IHNlYWwoLzwlW1xcd1xcV10qfFtcXHdcXFddKiU+L2dtKTtcbiAgdmFyIFRNUExJVF9FWFBSID0gc2VhbCgvXFwke1tcXHdcXFddKn0vZ20pO1xuICB2YXIgREFUQV9BVFRSID0gc2VhbCgvXmRhdGEtW1xcLVxcdy5cXHUwMEI3LVxcdUZGRkZdLyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcblxuICB2YXIgQVJJQV9BVFRSID0gc2VhbCgvXmFyaWEtW1xcLVxcd10rJC8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5cbiAgdmFyIElTX0FMTE9XRURfVVJJID0gc2VhbCgvXig/Oig/Oig/OmZ8aHQpdHBzP3xtYWlsdG98dGVsfGNhbGx0b3xjaWR8eG1wcCk6fFteYS16XXxbYS16Ky5cXC1dKyg/OlteYS16Ky5cXC06XXwkKSkvaSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICk7XG4gIHZhciBJU19TQ1JJUFRfT1JfREFUQSA9IHNlYWwoL14oPzpcXHcrc2NyaXB0fGRhdGEpOi9pKTtcbiAgdmFyIEFUVFJfV0hJVEVTUEFDRSA9IHNlYWwoL1tcXHUwMDAwLVxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwLVxcdTIwMjlcXHUyMDVGXFx1MzAwMF0vZyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgKTtcbiAgdmFyIERPQ1RZUEVfTkFNRSA9IHNlYWwoL15odG1sJC9pKTtcblxuICB2YXIgZ2V0R2xvYmFsID0gZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3c7XG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbm8tb3AgcG9saWN5IGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAgICogRG9uJ3QgZXhwb3J0IHRoaXMgZnVuY3Rpb24gb3V0c2lkZSB0aGlzIG1vZHVsZSFcbiAgICogQHBhcmFtIHs/VHJ1c3RlZFR5cGVQb2xpY3lGYWN0b3J5fSB0cnVzdGVkVHlwZXMgVGhlIHBvbGljeSBmYWN0b3J5LlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgb2JqZWN0ICh0byBkZXRlcm1pbmUgcG9saWN5IG5hbWUgc3VmZml4KVxuICAgKiBAcmV0dXJuIHs/VHJ1c3RlZFR5cGVQb2xpY3l9IFRoZSBwb2xpY3kgY3JlYXRlZCAob3IgbnVsbCwgaWYgVHJ1c3RlZCBUeXBlc1xuICAgKiBhcmUgbm90IHN1cHBvcnRlZCkuXG4gICAqL1xuXG5cbiAgdmFyIF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kgPSBmdW5jdGlvbiBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5KHRydXN0ZWRUeXBlcywgZG9jdW1lbnQpIHtcbiAgICBpZiAoX3R5cGVvZih0cnVzdGVkVHlwZXMpICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBBbGxvdyB0aGUgY2FsbGVycyB0byBjb250cm9sIHRoZSB1bmlxdWUgcG9saWN5IG5hbWVcbiAgICAvLyBieSBhZGRpbmcgYSBkYXRhLXR0LXBvbGljeS1zdWZmaXggdG8gdGhlIHNjcmlwdCBlbGVtZW50IHdpdGggdGhlIERPTVB1cmlmeS5cbiAgICAvLyBQb2xpY3kgY3JlYXRpb24gd2l0aCBkdXBsaWNhdGUgbmFtZXMgdGhyb3dzIGluIFRydXN0ZWQgVHlwZXMuXG5cblxuICAgIHZhciBzdWZmaXggPSBudWxsO1xuICAgIHZhciBBVFRSX05BTUUgPSAnZGF0YS10dC1wb2xpY3ktc3VmZml4JztcblxuICAgIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0ICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuaGFzQXR0cmlidXRlKEFUVFJfTkFNRSkpIHtcbiAgICAgIHN1ZmZpeCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSk7XG4gICAgfVxuXG4gICAgdmFyIHBvbGljeU5hbWUgPSAnZG9tcHVyaWZ5JyArIChzdWZmaXggPyAnIycgKyBzdWZmaXggOiAnJyk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kocG9saWN5TmFtZSwge1xuICAgICAgICBjcmVhdGVIVE1MOiBmdW5jdGlvbiBjcmVhdGVIVE1MKGh0bWwpIHtcbiAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlU2NyaXB0VVJMOiBmdW5jdGlvbiBjcmVhdGVTY3JpcHRVUkwoc2NyaXB0VXJsKSB7XG4gICAgICAgICAgcmV0dXJuIHNjcmlwdFVybDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgLy8gUG9saWN5IGNyZWF0aW9uIGZhaWxlZCAobW9zdCBsaWtlbHkgYW5vdGhlciBET01QdXJpZnkgc2NyaXB0IGhhc1xuICAgICAgLy8gYWxyZWFkeSBydW4pLiBTa2lwIGNyZWF0aW5nIHRoZSBwb2xpY3ksIGFzIHRoaXMgd2lsbCBvbmx5IGNhdXNlIGVycm9yc1xuICAgICAgLy8gaWYgVFQgYXJlIGVuZm9yY2VkLlxuICAgICAgY29uc29sZS53YXJuKCdUcnVzdGVkVHlwZXMgcG9saWN5ICcgKyBwb2xpY3lOYW1lICsgJyBjb3VsZCBub3QgYmUgY3JlYXRlZC4nKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVET01QdXJpZnkoKSB7XG4gICAgdmFyIHdpbmRvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZ2V0R2xvYmFsKCk7XG5cbiAgICB2YXIgRE9NUHVyaWZ5ID0gZnVuY3Rpb24gRE9NUHVyaWZ5KHJvb3QpIHtcbiAgICAgIHJldHVybiBjcmVhdGVET01QdXJpZnkocm9vdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBWZXJzaW9uIGxhYmVsLCBleHBvc2VkIGZvciBlYXNpZXIgY2hlY2tzXG4gICAgICogaWYgRE9NUHVyaWZ5IGlzIHVwIHRvIGRhdGUgb3Igbm90XG4gICAgICovXG5cblxuICAgIERPTVB1cmlmeS52ZXJzaW9uID0gJzMuMC4xJztcbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBlbGVtZW50cyB0aGF0IERPTVB1cmlmeSByZW1vdmVkIGR1cmluZyBzYW5pdGF0aW9uLlxuICAgICAqIEVtcHR5IGlmIG5vdGhpbmcgd2FzIHJlbW92ZWQuXG4gICAgICovXG5cbiAgICBET01QdXJpZnkucmVtb3ZlZCA9IFtdO1xuXG4gICAgaWYgKCF3aW5kb3cgfHwgIXdpbmRvdy5kb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQubm9kZVR5cGUgIT09IDkpIHtcbiAgICAgIC8vIE5vdCBydW5uaW5nIGluIGEgYnJvd3NlciwgcHJvdmlkZSBhIGZhY3RvcnkgZnVuY3Rpb25cbiAgICAgIC8vIHNvIHRoYXQgeW91IGNhbiBwYXNzIHlvdXIgb3duIFdpbmRvd1xuICAgICAgRE9NUHVyaWZ5LmlzU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gRE9NUHVyaWZ5O1xuICAgIH1cblxuICAgIHZhciBvcmlnaW5hbERvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICB2YXIgRG9jdW1lbnRGcmFnbWVudCA9IHdpbmRvdy5Eb2N1bWVudEZyYWdtZW50LFxuICAgICAgICBIVE1MVGVtcGxhdGVFbGVtZW50ID0gd2luZG93LkhUTUxUZW1wbGF0ZUVsZW1lbnQsXG4gICAgICAgIE5vZGUgPSB3aW5kb3cuTm9kZSxcbiAgICAgICAgRWxlbWVudCA9IHdpbmRvdy5FbGVtZW50LFxuICAgICAgICBOb2RlRmlsdGVyID0gd2luZG93Lk5vZGVGaWx0ZXIsXG4gICAgICAgIF93aW5kb3ckTmFtZWROb2RlTWFwID0gd2luZG93Lk5hbWVkTm9kZU1hcCxcbiAgICAgICAgTmFtZWROb2RlTWFwID0gX3dpbmRvdyROYW1lZE5vZGVNYXAgPT09IHZvaWQgMCA/IHdpbmRvdy5OYW1lZE5vZGVNYXAgfHwgd2luZG93Lk1vek5hbWVkQXR0ck1hcCA6IF93aW5kb3ckTmFtZWROb2RlTWFwLFxuICAgICAgICBIVE1MRm9ybUVsZW1lbnQgPSB3aW5kb3cuSFRNTEZvcm1FbGVtZW50LFxuICAgICAgICBET01QYXJzZXIgPSB3aW5kb3cuRE9NUGFyc2VyLFxuICAgICAgICB0cnVzdGVkVHlwZXMgPSB3aW5kb3cudHJ1c3RlZFR5cGVzO1xuICAgIHZhciBFbGVtZW50UHJvdG90eXBlID0gRWxlbWVudC5wcm90b3R5cGU7XG4gICAgdmFyIGNsb25lTm9kZSA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnY2xvbmVOb2RlJyk7XG4gICAgdmFyIGdldE5leHRTaWJsaW5nID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICduZXh0U2libGluZycpO1xuICAgIHZhciBnZXRDaGlsZE5vZGVzID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdjaGlsZE5vZGVzJyk7XG4gICAgdmFyIGdldFBhcmVudE5vZGUgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ3BhcmVudE5vZGUnKTsgLy8gQXMgcGVyIGlzc3VlICM0NywgdGhlIHdlYi1jb21wb25lbnRzIHJlZ2lzdHJ5IGlzIGluaGVyaXRlZCBieSBhXG4gICAgLy8gbmV3IGRvY3VtZW50IGNyZWF0ZWQgdmlhIGNyZWF0ZUhUTUxEb2N1bWVudC4gQXMgcGVyIHRoZSBzcGVjXG4gICAgLy8gKGh0dHA6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2NyZWF0aW5nLWFuZC1wYXNzaW5nLXJlZ2lzdHJpZXMpXG4gICAgLy8gYSBuZXcgZW1wdHkgcmVnaXN0cnkgaXMgdXNlZCB3aGVuIGNyZWF0aW5nIGEgdGVtcGxhdGUgY29udGVudHMgb3duZXJcbiAgICAvLyBkb2N1bWVudCwgc28gd2UgdXNlIHRoYXQgYXMgb3VyIHBhcmVudCBkb2N1bWVudCB0byBlbnN1cmUgbm90aGluZ1xuICAgIC8vIGlzIGluaGVyaXRlZC5cblxuICAgIGlmICh0eXBlb2YgSFRNTFRlbXBsYXRlRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcblxuICAgICAgaWYgKHRlbXBsYXRlLmNvbnRlbnQgJiYgdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50KSB7XG4gICAgICAgIGRvY3VtZW50ID0gdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cnVzdGVkVHlwZXNQb2xpY3kgPSBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5KHRydXN0ZWRUeXBlcywgb3JpZ2luYWxEb2N1bWVudCk7XG5cbiAgICB2YXIgZW1wdHlIVE1MID0gdHJ1c3RlZFR5cGVzUG9saWN5ID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoJycpIDogJyc7XG4gICAgdmFyIF9kb2N1bWVudCA9IGRvY3VtZW50LFxuICAgICAgICBpbXBsZW1lbnRhdGlvbiA9IF9kb2N1bWVudC5pbXBsZW1lbnRhdGlvbixcbiAgICAgICAgY3JlYXRlTm9kZUl0ZXJhdG9yID0gX2RvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvcixcbiAgICAgICAgY3JlYXRlRG9jdW1lbnRGcmFnbWVudCA9IF9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50LFxuICAgICAgICBnZXRFbGVtZW50c0J5VGFnTmFtZSA9IF9kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZTtcbiAgICB2YXIgaW1wb3J0Tm9kZSA9IG9yaWdpbmFsRG9jdW1lbnQuaW1wb3J0Tm9kZTtcbiAgICB2YXIgaG9va3MgPSB7fTtcbiAgICAvKipcbiAgICAgKiBFeHBvc2Ugd2hldGhlciB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgcnVubmluZyB0aGUgZnVsbCBET01QdXJpZnkuXG4gICAgICovXG5cbiAgICBET01QdXJpZnkuaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZW50cmllcyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZ2V0UGFyZW50Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbXBsZW1lbnRhdGlvbiAmJiB0eXBlb2YgaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbiAgICB2YXIgTVVTVEFDSEVfRVhQUiQxID0gTVVTVEFDSEVfRVhQUixcbiAgICAgICAgRVJCX0VYUFIkMSA9IEVSQl9FWFBSLFxuICAgICAgICBUTVBMSVRfRVhQUiQxID0gVE1QTElUX0VYUFIsXG4gICAgICAgIERBVEFfQVRUUiQxID0gREFUQV9BVFRSLFxuICAgICAgICBBUklBX0FUVFIkMSA9IEFSSUFfQVRUUixcbiAgICAgICAgSVNfU0NSSVBUX09SX0RBVEEkMSA9IElTX1NDUklQVF9PUl9EQVRBLFxuICAgICAgICBBVFRSX1dISVRFU1BBQ0UkMSA9IEFUVFJfV0hJVEVTUEFDRTtcbiAgICB2YXIgSVNfQUxMT1dFRF9VUkkkMSA9IElTX0FMTE9XRURfVVJJO1xuICAgIC8qKlxuICAgICAqIFdlIGNvbnNpZGVyIHRoZSBlbGVtZW50cyBhbmQgYXR0cmlidXRlcyBiZWxvdyB0byBiZSBzYWZlLiBJZGVhbGx5XG4gICAgICogZG9uJ3QgYWRkIGFueSBuZXcgb25lcyBidXQgZmVlbCBmcmVlIHRvIHJlbW92ZSB1bndhbnRlZCBvbmVzLlxuICAgICAqL1xuXG4gICAgLyogYWxsb3dlZCBlbGVtZW50IG5hbWVzICovXG5cbiAgICB2YXIgQUxMT1dFRF9UQUdTID0gbnVsbDtcbiAgICB2YXIgREVGQVVMVF9BTExPV0VEX1RBR1MgPSBhZGRUb1NldCh7fSwgW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShodG1sJDEpLCBfdG9Db25zdW1hYmxlQXJyYXkoc3ZnJDEpLCBfdG9Db25zdW1hYmxlQXJyYXkoc3ZnRmlsdGVycyksIF90b0NvbnN1bWFibGVBcnJheShtYXRoTWwkMSksIF90b0NvbnN1bWFibGVBcnJheSh0ZXh0KSkpO1xuICAgIC8qIEFsbG93ZWQgYXR0cmlidXRlIG5hbWVzICovXG5cbiAgICB2YXIgQUxMT1dFRF9BVFRSID0gbnVsbDtcbiAgICB2YXIgREVGQVVMVF9BTExPV0VEX0FUVFIgPSBhZGRUb1NldCh7fSwgW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShodG1sKSwgX3RvQ29uc3VtYWJsZUFycmF5KHN2ZyksIF90b0NvbnN1bWFibGVBcnJheShtYXRoTWwpLCBfdG9Db25zdW1hYmxlQXJyYXkoeG1sKSkpO1xuICAgIC8qXG4gICAgICogQ29uZmlndXJlIGhvdyBET01QVXJpZnkgc2hvdWxkIGhhbmRsZSBjdXN0b20gZWxlbWVudHMgYW5kIHRoZWlyIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBjdXN0b21pemVkIGJ1aWx0LWluIGVsZW1lbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7UmVnRXhwfEZ1bmN0aW9ufG51bGx9IHRhZ05hbWVDaGVjayBvbmUgb2YgW251bGwsIHJlZ2V4UGF0dGVybiwgcHJlZGljYXRlXS4gRGVmYXVsdDogYG51bGxgIChkaXNhbGxvdyBhbnkgY3VzdG9tIGVsZW1lbnRzKVxuICAgICAqIEBwcm9wZXJ0eSB7UmVnRXhwfEZ1bmN0aW9ufG51bGx9IGF0dHJpYnV0ZU5hbWVDaGVjayBvbmUgb2YgW251bGwsIHJlZ2V4UGF0dGVybiwgcHJlZGljYXRlXS4gRGVmYXVsdDogYG51bGxgIChkaXNhbGxvdyBhbnkgYXR0cmlidXRlcyBub3Qgb24gdGhlIGFsbG93IGxpc3QpXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBhbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHMgYWxsb3cgY3VzdG9tIGVsZW1lbnRzIGRlcml2ZWQgZnJvbSBidWlsdC1pbnMgaWYgdGhleSBwYXNzIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjay4gRGVmYXVsdDogYGZhbHNlYC5cbiAgICAgKi9cblxuICAgIHZhciBDVVNUT01fRUxFTUVOVF9IQU5ETElORyA9IE9iamVjdC5zZWFsKE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgdGFnTmFtZUNoZWNrOiB7XG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZU5hbWVDaGVjazoge1xuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0sXG4gICAgICBhbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHM6IHtcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfVxuICAgIH0pKTtcbiAgICAvKiBFeHBsaWNpdGx5IGZvcmJpZGRlbiB0YWdzIChvdmVycmlkZXMgQUxMT1dFRF9UQUdTL0FERF9UQUdTKSAqL1xuXG4gICAgdmFyIEZPUkJJRF9UQUdTID0gbnVsbDtcbiAgICAvKiBFeHBsaWNpdGx5IGZvcmJpZGRlbiBhdHRyaWJ1dGVzIChvdmVycmlkZXMgQUxMT1dFRF9BVFRSL0FERF9BVFRSKSAqL1xuXG4gICAgdmFyIEZPUkJJRF9BVFRSID0gbnVsbDtcbiAgICAvKiBEZWNpZGUgaWYgQVJJQSBhdHRyaWJ1dGVzIGFyZSBva2F5ICovXG5cbiAgICB2YXIgQUxMT1dfQVJJQV9BVFRSID0gdHJ1ZTtcbiAgICAvKiBEZWNpZGUgaWYgY3VzdG9tIGRhdGEgYXR0cmlidXRlcyBhcmUgb2theSAqL1xuXG4gICAgdmFyIEFMTE9XX0RBVEFfQVRUUiA9IHRydWU7XG4gICAgLyogRGVjaWRlIGlmIHVua25vd24gcHJvdG9jb2xzIGFyZSBva2F5ICovXG5cbiAgICB2YXIgQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgPSBmYWxzZTtcbiAgICAvKiBEZWNpZGUgaWYgc2VsZi1jbG9zaW5nIHRhZ3MgaW4gYXR0cmlidXRlcyBhcmUgYWxsb3dlZC5cbiAgICAgKiBVc3VhbGx5IHJlbW92ZWQgZHVlIHRvIGEgbVhTUyBpc3N1ZSBpbiBqUXVlcnkgMy4wICovXG5cbiAgICB2YXIgQUxMT1dfU0VMRl9DTE9TRV9JTl9BVFRSID0gdHJ1ZTtcbiAgICAvKiBPdXRwdXQgc2hvdWxkIGJlIHNhZmUgZm9yIGNvbW1vbiB0ZW1wbGF0ZSBlbmdpbmVzLlxuICAgICAqIFRoaXMgbWVhbnMsIERPTVB1cmlmeSByZW1vdmVzIGRhdGEgYXR0cmlidXRlcywgbXVzdGFjaGVzIGFuZCBFUkJcbiAgICAgKi9cblxuICAgIHZhciBTQUZFX0ZPUl9URU1QTEFURVMgPSBmYWxzZTtcbiAgICAvKiBEZWNpZGUgaWYgZG9jdW1lbnQgd2l0aCA8aHRtbD4uLi4gc2hvdWxkIGJlIHJldHVybmVkICovXG5cbiAgICB2YXIgV0hPTEVfRE9DVU1FTlQgPSBmYWxzZTtcbiAgICAvKiBUcmFjayB3aGV0aGVyIGNvbmZpZyBpcyBhbHJlYWR5IHNldCBvbiB0aGlzIGluc3RhbmNlIG9mIERPTVB1cmlmeS4gKi9cblxuICAgIHZhciBTRVRfQ09ORklHID0gZmFsc2U7XG4gICAgLyogRGVjaWRlIGlmIGFsbCBlbGVtZW50cyAoZS5nLiBzdHlsZSwgc2NyaXB0KSBtdXN0IGJlIGNoaWxkcmVuIG9mXG4gICAgICogZG9jdW1lbnQuYm9keS4gQnkgZGVmYXVsdCwgYnJvd3NlcnMgbWlnaHQgbW92ZSB0aGVtIHRvIGRvY3VtZW50LmhlYWQgKi9cblxuICAgIHZhciBGT1JDRV9CT0RZID0gZmFsc2U7XG4gICAgLyogRGVjaWRlIGlmIGEgRE9NIGBIVE1MQm9keUVsZW1lbnRgIHNob3VsZCBiZSByZXR1cm5lZCwgaW5zdGVhZCBvZiBhIGh0bWxcbiAgICAgKiBzdHJpbmcgKG9yIGEgVHJ1c3RlZEhUTUwgb2JqZWN0IGlmIFRydXN0ZWQgVHlwZXMgYXJlIHN1cHBvcnRlZCkuXG4gICAgICogSWYgYFdIT0xFX0RPQ1VNRU5UYCBpcyBlbmFibGVkIGEgYEhUTUxIdG1sRWxlbWVudGAgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkXG4gICAgICovXG5cbiAgICB2YXIgUkVUVVJOX0RPTSA9IGZhbHNlO1xuICAgIC8qIERlY2lkZSBpZiBhIERPTSBgRG9jdW1lbnRGcmFnbWVudGAgc2hvdWxkIGJlIHJldHVybmVkLCBpbnN0ZWFkIG9mIGEgaHRtbFxuICAgICAqIHN0cmluZyAgKG9yIGEgVHJ1c3RlZEhUTUwgb2JqZWN0IGlmIFRydXN0ZWQgVHlwZXMgYXJlIHN1cHBvcnRlZCkgKi9cblxuICAgIHZhciBSRVRVUk5fRE9NX0ZSQUdNRU5UID0gZmFsc2U7XG4gICAgLyogVHJ5IHRvIHJldHVybiBhIFRydXN0ZWQgVHlwZSBvYmplY3QgaW5zdGVhZCBvZiBhIHN0cmluZywgcmV0dXJuIGEgc3RyaW5nIGluXG4gICAgICogY2FzZSBUcnVzdGVkIFR5cGVzIGFyZSBub3Qgc3VwcG9ydGVkICAqL1xuXG4gICAgdmFyIFJFVFVSTl9UUlVTVEVEX1RZUEUgPSBmYWxzZTtcbiAgICAvKiBPdXRwdXQgc2hvdWxkIGJlIGZyZWUgZnJvbSBET00gY2xvYmJlcmluZyBhdHRhY2tzP1xuICAgICAqIFRoaXMgc2FuaXRpemVzIG1hcmt1cHMgbmFtZWQgd2l0aCBjb2xsaWRpbmcsIGNsb2JiZXJhYmxlIGJ1aWx0LWluIERPTSBBUElzLlxuICAgICAqL1xuXG4gICAgdmFyIFNBTklUSVpFX0RPTSA9IHRydWU7XG4gICAgLyogQWNoaWV2ZSBmdWxsIERPTSBDbG9iYmVyaW5nIHByb3RlY3Rpb24gYnkgaXNvbGF0aW5nIHRoZSBuYW1lc3BhY2Ugb2YgbmFtZWRcbiAgICAgKiBwcm9wZXJ0aWVzIGFuZCBKUyB2YXJpYWJsZXMsIG1pdGlnYXRpbmcgYXR0YWNrcyB0aGF0IGFidXNlIHRoZSBIVE1ML0RPTSBzcGVjIHJ1bGVzLlxuICAgICAqXG4gICAgICogSFRNTC9ET00gc3BlYyBydWxlcyB0aGF0IGVuYWJsZSBET00gQ2xvYmJlcmluZzpcbiAgICAgKiAgIC0gTmFtZWQgQWNjZXNzIG9uIFdpbmRvdyAowqc3LjMuMylcbiAgICAgKiAgIC0gRE9NIFRyZWUgQWNjZXNzb3JzICjCpzMuMS41KVxuICAgICAqICAgLSBGb3JtIEVsZW1lbnQgUGFyZW50LUNoaWxkIFJlbGF0aW9ucyAowqc0LjEwLjMpXG4gICAgICogICAtIElmcmFtZSBzcmNkb2MgLyBOZXN0ZWQgV2luZG93UHJveGllcyAowqc0LjguNSlcbiAgICAgKiAgIC0gSFRNTENvbGxlY3Rpb24gKMKnNC4yLjEwLjIpXG4gICAgICpcbiAgICAgKiBOYW1lc3BhY2UgaXNvbGF0aW9uIGlzIGltcGxlbWVudGVkIGJ5IHByZWZpeGluZyBgaWRgIGFuZCBgbmFtZWAgYXR0cmlidXRlc1xuICAgICAqIHdpdGggYSBjb25zdGFudCBzdHJpbmcsIGkuZS4sIGB1c2VyLWNvbnRlbnQtYFxuICAgICAqL1xuXG4gICAgdmFyIFNBTklUSVpFX05BTUVEX1BST1BTID0gZmFsc2U7XG4gICAgdmFyIFNBTklUSVpFX05BTUVEX1BST1BTX1BSRUZJWCA9ICd1c2VyLWNvbnRlbnQtJztcbiAgICAvKiBLZWVwIGVsZW1lbnQgY29udGVudCB3aGVuIHJlbW92aW5nIGVsZW1lbnQ/ICovXG5cbiAgICB2YXIgS0VFUF9DT05URU5UID0gdHJ1ZTtcbiAgICAvKiBJZiBhIGBOb2RlYCBpcyBwYXNzZWQgdG8gc2FuaXRpemUoKSwgdGhlbiBwZXJmb3JtcyBzYW5pdGl6YXRpb24gaW4tcGxhY2UgaW5zdGVhZFxuICAgICAqIG9mIGltcG9ydGluZyBpdCBpbnRvIGEgbmV3IERvY3VtZW50IGFuZCByZXR1cm5pbmcgYSBzYW5pdGl6ZWQgY29weSAqL1xuXG4gICAgdmFyIElOX1BMQUNFID0gZmFsc2U7XG4gICAgLyogQWxsb3cgdXNhZ2Ugb2YgcHJvZmlsZXMgbGlrZSBodG1sLCBzdmcgYW5kIG1hdGhNbCAqL1xuXG4gICAgdmFyIFVTRV9QUk9GSUxFUyA9IHt9O1xuICAgIC8qIFRhZ3MgdG8gaWdub3JlIGNvbnRlbnQgb2Ygd2hlbiBLRUVQX0NPTlRFTlQgaXMgdHJ1ZSAqL1xuXG4gICAgdmFyIEZPUkJJRF9DT05URU5UUyA9IG51bGw7XG4gICAgdmFyIERFRkFVTFRfRk9SQklEX0NPTlRFTlRTID0gYWRkVG9TZXQoe30sIFsnYW5ub3RhdGlvbi14bWwnLCAnYXVkaW8nLCAnY29sZ3JvdXAnLCAnZGVzYycsICdmb3JlaWdub2JqZWN0JywgJ2hlYWQnLCAnaWZyYW1lJywgJ21hdGgnLCAnbWknLCAnbW4nLCAnbW8nLCAnbXMnLCAnbXRleHQnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdwbGFpbnRleHQnLCAnc2NyaXB0JywgJ3N0eWxlJywgJ3N2ZycsICd0ZW1wbGF0ZScsICd0aGVhZCcsICd0aXRsZScsICd2aWRlbycsICd4bXAnXSk7XG4gICAgLyogVGFncyB0aGF0IGFyZSBzYWZlIGZvciBkYXRhOiBVUklzICovXG5cbiAgICB2YXIgREFUQV9VUklfVEFHUyA9IG51bGw7XG4gICAgdmFyIERFRkFVTFRfREFUQV9VUklfVEFHUyA9IGFkZFRvU2V0KHt9LCBbJ2F1ZGlvJywgJ3ZpZGVvJywgJ2ltZycsICdzb3VyY2UnLCAnaW1hZ2UnLCAndHJhY2snXSk7XG4gICAgLyogQXR0cmlidXRlcyBzYWZlIGZvciB2YWx1ZXMgbGlrZSBcImphdmFzY3JpcHQ6XCIgKi9cblxuICAgIHZhciBVUklfU0FGRV9BVFRSSUJVVEVTID0gbnVsbDtcbiAgICB2YXIgREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTID0gYWRkVG9TZXQoe30sIFsnYWx0JywgJ2NsYXNzJywgJ2ZvcicsICdpZCcsICdsYWJlbCcsICduYW1lJywgJ3BhdHRlcm4nLCAncGxhY2Vob2xkZXInLCAncm9sZScsICdzdW1tYXJ5JywgJ3RpdGxlJywgJ3ZhbHVlJywgJ3N0eWxlJywgJ3htbG5zJ10pO1xuICAgIHZhciBNQVRITUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xuICAgIHZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgICB2YXIgSFRNTF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG4gICAgLyogRG9jdW1lbnQgbmFtZXNwYWNlICovXG5cbiAgICB2YXIgTkFNRVNQQUNFID0gSFRNTF9OQU1FU1BBQ0U7XG4gICAgdmFyIElTX0VNUFRZX0lOUFVUID0gZmFsc2U7XG4gICAgLyogQWxsb3dlZCBYSFRNTCtYTUwgbmFtZXNwYWNlcyAqL1xuXG4gICAgdmFyIEFMTE9XRURfTkFNRVNQQUNFUyA9IG51bGw7XG4gICAgdmFyIERFRkFVTFRfQUxMT1dFRF9OQU1FU1BBQ0VTID0gYWRkVG9TZXQoe30sIFtNQVRITUxfTkFNRVNQQUNFLCBTVkdfTkFNRVNQQUNFLCBIVE1MX05BTUVTUEFDRV0sIHN0cmluZ1RvU3RyaW5nKTtcbiAgICAvKiBQYXJzaW5nIG9mIHN0cmljdCBYSFRNTCBkb2N1bWVudHMgKi9cblxuICAgIHZhciBQQVJTRVJfTUVESUFfVFlQRTtcbiAgICB2YXIgU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUyA9IFsnYXBwbGljYXRpb24veGh0bWwreG1sJywgJ3RleHQvaHRtbCddO1xuICAgIHZhciBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFID0gJ3RleHQvaHRtbCc7XG4gICAgdmFyIHRyYW5zZm9ybUNhc2VGdW5jO1xuICAgIC8qIEtlZXAgYSByZWZlcmVuY2UgdG8gY29uZmlnIHRvIHBhc3MgdG8gaG9va3MgKi9cblxuICAgIHZhciBDT05GSUcgPSBudWxsO1xuICAgIC8qIElkZWFsbHksIGRvIG5vdCB0b3VjaCBhbnl0aGluZyBiZWxvdyB0aGlzIGxpbmUgKi9cblxuICAgIC8qIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18gKi9cblxuICAgIHZhciBmb3JtRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcblxuICAgIHZhciBpc1JlZ2V4T3JGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzUmVnZXhPckZ1bmN0aW9uKHRlc3RWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRlc3RWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCB0ZXN0VmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIF9wYXJzZUNvbmZpZ1xuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBjZmcgb3B0aW9uYWwgY29uZmlnIGxpdGVyYWxcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG5cbiAgICB2YXIgX3BhcnNlQ29uZmlnID0gZnVuY3Rpb24gX3BhcnNlQ29uZmlnKGNmZykge1xuICAgICAgaWYgKENPTkZJRyAmJiBDT05GSUcgPT09IGNmZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvKiBTaGllbGQgY29uZmlndXJhdGlvbiBvYmplY3QgZnJvbSB0YW1wZXJpbmcgKi9cblxuXG4gICAgICBpZiAoIWNmZyB8fCBfdHlwZW9mKGNmZykgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNmZyA9IHt9O1xuICAgICAgfVxuICAgICAgLyogU2hpZWxkIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZyb20gcHJvdG90eXBlIHBvbGx1dGlvbiAqL1xuXG5cbiAgICAgIGNmZyA9IGNsb25lKGNmZyk7XG4gICAgICBQQVJTRVJfTUVESUFfVFlQRSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgICAgU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUy5pbmRleE9mKGNmZy5QQVJTRVJfTUVESUFfVFlQRSkgPT09IC0xID8gUEFSU0VSX01FRElBX1RZUEUgPSBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFIDogUEFSU0VSX01FRElBX1RZUEUgPSBjZmcuUEFSU0VSX01FRElBX1RZUEU7IC8vIEhUTUwgdGFncyBhbmQgYXR0cmlidXRlcyBhcmUgbm90IGNhc2Utc2Vuc2l0aXZlLCBjb252ZXJ0aW5nIHRvIGxvd2VyY2FzZS4gS2VlcGluZyBYSFRNTCBhcyBpcy5cblxuICAgICAgdHJhbnNmb3JtQ2FzZUZ1bmMgPSBQQVJTRVJfTUVESUFfVFlQRSA9PT0gJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcgPyBzdHJpbmdUb1N0cmluZyA6IHN0cmluZ1RvTG93ZXJDYXNlO1xuICAgICAgLyogU2V0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyAqL1xuXG4gICAgICBBTExPV0VEX1RBR1MgPSAnQUxMT1dFRF9UQUdTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfVEFHUywgdHJhbnNmb3JtQ2FzZUZ1bmMpIDogREVGQVVMVF9BTExPV0VEX1RBR1M7XG4gICAgICBBTExPV0VEX0FUVFIgPSAnQUxMT1dFRF9BVFRSJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfQVRUUiwgdHJhbnNmb3JtQ2FzZUZ1bmMpIDogREVGQVVMVF9BTExPV0VEX0FUVFI7XG4gICAgICBBTExPV0VEX05BTUVTUEFDRVMgPSAnQUxMT1dFRF9OQU1FU1BBQ0VTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfTkFNRVNQQUNFUywgc3RyaW5nVG9TdHJpbmcpIDogREVGQVVMVF9BTExPV0VEX05BTUVTUEFDRVM7XG4gICAgICBVUklfU0FGRV9BVFRSSUJVVEVTID0gJ0FERF9VUklfU0FGRV9BVFRSJyBpbiBjZmcgPyBhZGRUb1NldChjbG9uZShERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMpLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGluZGVudFxuICAgICAgY2ZnLkFERF9VUklfU0FGRV9BVFRSLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGluZGVudFxuICAgICAgdHJhbnNmb3JtQ2FzZUZ1bmMgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbmRlbnRcbiAgICAgICkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbmRlbnRcbiAgICAgIDogREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTO1xuICAgICAgREFUQV9VUklfVEFHUyA9ICdBRERfREFUQV9VUklfVEFHUycgaW4gY2ZnID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9EQVRBX1VSSV9UQUdTKSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbmRlbnRcbiAgICAgIGNmZy5BRERfREFUQV9VUklfVEFHUywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbmRlbnRcbiAgICAgIHRyYW5zZm9ybUNhc2VGdW5jIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW5kZW50XG4gICAgICApIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW5kZW50XG4gICAgICA6IERFRkFVTFRfREFUQV9VUklfVEFHUztcbiAgICAgIEZPUkJJRF9DT05URU5UUyA9ICdGT1JCSURfQ09OVEVOVFMnIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX0NPTlRFTlRTLCB0cmFuc2Zvcm1DYXNlRnVuYykgOiBERUZBVUxUX0ZPUkJJRF9DT05URU5UUztcbiAgICAgIEZPUkJJRF9UQUdTID0gJ0ZPUkJJRF9UQUdTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9UQUdTLCB0cmFuc2Zvcm1DYXNlRnVuYykgOiB7fTtcbiAgICAgIEZPUkJJRF9BVFRSID0gJ0ZPUkJJRF9BVFRSJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9BVFRSLCB0cmFuc2Zvcm1DYXNlRnVuYykgOiB7fTtcbiAgICAgIFVTRV9QUk9GSUxFUyA9ICdVU0VfUFJPRklMRVMnIGluIGNmZyA/IGNmZy5VU0VfUFJPRklMRVMgOiBmYWxzZTtcbiAgICAgIEFMTE9XX0FSSUFfQVRUUiA9IGNmZy5BTExPV19BUklBX0FUVFIgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcblxuICAgICAgQUxMT1dfREFUQV9BVFRSID0gY2ZnLkFMTE9XX0RBVEFfQVRUUiAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuXG4gICAgICBBTExPV19VTktOT1dOX1BST1RPQ09MUyA9IGNmZy5BTExPV19VTktOT1dOX1BST1RPQ09MUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuXG4gICAgICBBTExPV19TRUxGX0NMT1NFX0lOX0FUVFIgPSBjZmcuQUxMT1dfU0VMRl9DTE9TRV9JTl9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG5cbiAgICAgIFNBRkVfRk9SX1RFTVBMQVRFUyA9IGNmZy5TQUZFX0ZPUl9URU1QTEFURVMgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcblxuICAgICAgV0hPTEVfRE9DVU1FTlQgPSBjZmcuV0hPTEVfRE9DVU1FTlQgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcblxuICAgICAgUkVUVVJOX0RPTSA9IGNmZy5SRVRVUk5fRE9NIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG5cbiAgICAgIFJFVFVSTl9ET01fRlJBR01FTlQgPSBjZmcuUkVUVVJOX0RPTV9GUkFHTUVOVCB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuXG4gICAgICBSRVRVUk5fVFJVU1RFRF9UWVBFID0gY2ZnLlJFVFVSTl9UUlVTVEVEX1RZUEUgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcblxuICAgICAgRk9SQ0VfQk9EWSA9IGNmZy5GT1JDRV9CT0RZIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG5cbiAgICAgIFNBTklUSVpFX0RPTSA9IGNmZy5TQU5JVElaRV9ET00gIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcblxuICAgICAgU0FOSVRJWkVfTkFNRURfUFJPUFMgPSBjZmcuU0FOSVRJWkVfTkFNRURfUFJPUFMgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcblxuICAgICAgS0VFUF9DT05URU5UID0gY2ZnLktFRVBfQ09OVEVOVCAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuXG4gICAgICBJTl9QTEFDRSA9IGNmZy5JTl9QTEFDRSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuXG4gICAgICBJU19BTExPV0VEX1VSSSQxID0gY2ZnLkFMTE9XRURfVVJJX1JFR0VYUCB8fCBJU19BTExPV0VEX1VSSSQxO1xuICAgICAgTkFNRVNQQUNFID0gY2ZnLk5BTUVTUEFDRSB8fCBIVE1MX05BTUVTUEFDRTtcbiAgICAgIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HIHx8IHt9O1xuXG4gICAgICBpZiAoY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HICYmIGlzUmVnZXhPckZ1bmN0aW9uKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2spKSB7XG4gICAgICAgIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayA9IGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2s7XG4gICAgICB9XG5cbiAgICAgIGlmIChjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgJiYgaXNSZWdleE9yRnVuY3Rpb24oY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjaykpIHtcbiAgICAgICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjaztcbiAgICAgIH1cblxuICAgICAgaWYgKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyAmJiB0eXBlb2YgY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cyA9IGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy5hbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHM7XG4gICAgICB9XG5cbiAgICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgICAgQUxMT1dfREFUQV9BVFRSID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7XG4gICAgICAgIFJFVFVSTl9ET00gPSB0cnVlO1xuICAgICAgfVxuICAgICAgLyogUGFyc2UgcHJvZmlsZSBpbmZvICovXG5cblxuICAgICAgaWYgKFVTRV9QUk9GSUxFUykge1xuICAgICAgICBBTExPV0VEX1RBR1MgPSBhZGRUb1NldCh7fSwgX3RvQ29uc3VtYWJsZUFycmF5KHRleHQpKTtcbiAgICAgICAgQUxMT1dFRF9BVFRSID0gW107XG5cbiAgICAgICAgaWYgKFVTRV9QUk9GSUxFUy5odG1sID09PSB0cnVlKSB7XG4gICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBodG1sJDEpO1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgaHRtbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVVNFX1BST0ZJTEVTLnN2ZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgc3ZnJDEpO1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgc3ZnKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVVNFX1BST0ZJTEVTLnN2Z0ZpbHRlcnMgPT09IHRydWUpIHtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2Z0ZpbHRlcnMpO1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgc3ZnKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVVNFX1BST0ZJTEVTLm1hdGhNbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgbWF0aE1sJDEpO1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgbWF0aE1sKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIE1lcmdlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyAqL1xuXG5cbiAgICAgIGlmIChjZmcuQUREX1RBR1MpIHtcbiAgICAgICAgaWYgKEFMTE9XRURfVEFHUyA9PT0gREVGQVVMVF9BTExPV0VEX1RBR1MpIHtcbiAgICAgICAgICBBTExPV0VEX1RBR1MgPSBjbG9uZShBTExPV0VEX1RBR1MpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBjZmcuQUREX1RBR1MsIHRyYW5zZm9ybUNhc2VGdW5jKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNmZy5BRERfQVRUUikge1xuICAgICAgICBpZiAoQUxMT1dFRF9BVFRSID09PSBERUZBVUxUX0FMTE9XRURfQVRUUikge1xuICAgICAgICAgIEFMTE9XRURfQVRUUiA9IGNsb25lKEFMTE9XRURfQVRUUik7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIGNmZy5BRERfQVRUUiwgdHJhbnNmb3JtQ2FzZUZ1bmMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ZnLkFERF9VUklfU0FGRV9BVFRSKSB7XG4gICAgICAgIGFkZFRvU2V0KFVSSV9TQUZFX0FUVFJJQlVURVMsIGNmZy5BRERfVVJJX1NBRkVfQVRUUiwgdHJhbnNmb3JtQ2FzZUZ1bmMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ZnLkZPUkJJRF9DT05URU5UUykge1xuICAgICAgICBpZiAoRk9SQklEX0NPTlRFTlRTID09PSBERUZBVUxUX0ZPUkJJRF9DT05URU5UUykge1xuICAgICAgICAgIEZPUkJJRF9DT05URU5UUyA9IGNsb25lKEZPUkJJRF9DT05URU5UUyk7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRUb1NldChGT1JCSURfQ09OVEVOVFMsIGNmZy5GT1JCSURfQ09OVEVOVFMsIHRyYW5zZm9ybUNhc2VGdW5jKTtcbiAgICAgIH1cbiAgICAgIC8qIEFkZCAjdGV4dCBpbiBjYXNlIEtFRVBfQ09OVEVOVCBpcyBzZXQgdG8gdHJ1ZSAqL1xuXG5cbiAgICAgIGlmIChLRUVQX0NPTlRFTlQpIHtcbiAgICAgICAgQUxMT1dFRF9UQUdTWycjdGV4dCddID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8qIEFkZCBodG1sLCBoZWFkIGFuZCBib2R5IHRvIEFMTE9XRURfVEFHUyBpbiBjYXNlIFdIT0xFX0RPQ1VNRU5UIGlzIHRydWUgKi9cblxuXG4gICAgICBpZiAoV0hPTEVfRE9DVU1FTlQpIHtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBbJ2h0bWwnLCAnaGVhZCcsICdib2R5J10pO1xuICAgICAgfVxuICAgICAgLyogQWRkIHRib2R5IHRvIEFMTE9XRURfVEFHUyBpbiBjYXNlIHRhYmxlcyBhcmUgcGVybWl0dGVkLCBzZWUgIzI4NiwgIzM2NSAqL1xuXG5cbiAgICAgIGlmIChBTExPV0VEX1RBR1MudGFibGUpIHtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBbJ3Rib2R5J10pO1xuICAgICAgICBkZWxldGUgRk9SQklEX1RBR1MudGJvZHk7XG4gICAgICB9IC8vIFByZXZlbnQgZnVydGhlciBtYW5pcHVsYXRpb24gb2YgY29uZmlndXJhdGlvbi5cbiAgICAgIC8vIE5vdCBhdmFpbGFibGUgaW4gSUU4LCBTYWZhcmkgNSwgZXRjLlxuXG5cbiAgICAgIGlmIChmcmVlemUpIHtcbiAgICAgICAgZnJlZXplKGNmZyk7XG4gICAgICB9XG5cbiAgICAgIENPTkZJRyA9IGNmZztcbiAgICB9O1xuXG4gICAgdmFyIE1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UUyA9IGFkZFRvU2V0KHt9LCBbJ21pJywgJ21vJywgJ21uJywgJ21zJywgJ210ZXh0J10pO1xuICAgIHZhciBIVE1MX0lOVEVHUkFUSU9OX1BPSU5UUyA9IGFkZFRvU2V0KHt9LCBbJ2ZvcmVpZ25vYmplY3QnLCAnZGVzYycsICd0aXRsZScsICdhbm5vdGF0aW9uLXhtbCddKTsgLy8gQ2VydGFpbiBlbGVtZW50cyBhcmUgYWxsb3dlZCBpbiBib3RoIFNWRyBhbmQgSFRNTFxuICAgIC8vIG5hbWVzcGFjZS4gV2UgbmVlZCB0byBzcGVjaWZ5IHRoZW0gZXhwbGljaXRseVxuICAgIC8vIHNvIHRoYXQgdGhleSBkb24ndCBnZXQgZXJyb25lb3VzbHkgZGVsZXRlZCBmcm9tXG4gICAgLy8gSFRNTCBuYW1lc3BhY2UuXG5cbiAgICB2YXIgQ09NTU9OX1NWR19BTkRfSFRNTF9FTEVNRU5UUyA9IGFkZFRvU2V0KHt9LCBbJ3RpdGxlJywgJ3N0eWxlJywgJ2ZvbnQnLCAnYScsICdzY3JpcHQnXSk7XG4gICAgLyogS2VlcCB0cmFjayBvZiBhbGwgcG9zc2libGUgU1ZHIGFuZCBNYXRoTUwgdGFnc1xuICAgICAqIHNvIHRoYXQgd2UgY2FuIHBlcmZvcm0gdGhlIG5hbWVzcGFjZSBjaGVja3NcbiAgICAgKiBjb3JyZWN0bHkuICovXG5cbiAgICB2YXIgQUxMX1NWR19UQUdTID0gYWRkVG9TZXQoe30sIHN2ZyQxKTtcbiAgICBhZGRUb1NldChBTExfU1ZHX1RBR1MsIHN2Z0ZpbHRlcnMpO1xuICAgIGFkZFRvU2V0KEFMTF9TVkdfVEFHUywgc3ZnRGlzYWxsb3dlZCk7XG4gICAgdmFyIEFMTF9NQVRITUxfVEFHUyA9IGFkZFRvU2V0KHt9LCBtYXRoTWwkMSk7XG4gICAgYWRkVG9TZXQoQUxMX01BVEhNTF9UQUdTLCBtYXRoTWxEaXNhbGxvd2VkKTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtICB7RWxlbWVudH0gZWxlbWVudCBhIERPTSBlbGVtZW50IHdob3NlIG5hbWVzcGFjZSBpcyBiZWluZyBjaGVja2VkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybiBmYWxzZSBpZiB0aGUgZWxlbWVudCBoYXMgYVxuICAgICAqICBuYW1lc3BhY2UgdGhhdCBhIHNwZWMtY29tcGxpYW50IHBhcnNlciB3b3VsZCBuZXZlclxuICAgICAqICByZXR1cm4uIFJldHVybiB0cnVlIG90aGVyd2lzZS5cbiAgICAgKi9cblxuICAgIHZhciBfY2hlY2tWYWxpZE5hbWVzcGFjZSA9IGZ1bmN0aW9uIF9jaGVja1ZhbGlkTmFtZXNwYWNlKGVsZW1lbnQpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpOyAvLyBJbiBKU0RPTSwgaWYgd2UncmUgaW5zaWRlIHNoYWRvdyBET00sIHRoZW4gcGFyZW50Tm9kZVxuICAgICAgLy8gY2FuIGJlIG51bGwuIFdlIGp1c3Qgc2ltdWxhdGUgcGFyZW50IGluIHRoaXMgY2FzZS5cblxuICAgICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC50YWdOYW1lKSB7XG4gICAgICAgIHBhcmVudCA9IHtcbiAgICAgICAgICBuYW1lc3BhY2VVUkk6IE5BTUVTUEFDRSxcbiAgICAgICAgICB0YWdOYW1lOiAndGVtcGxhdGUnXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciB0YWdOYW1lID0gc3RyaW5nVG9Mb3dlckNhc2UoZWxlbWVudC50YWdOYW1lKTtcbiAgICAgIHZhciBwYXJlbnRUYWdOYW1lID0gc3RyaW5nVG9Mb3dlckNhc2UocGFyZW50LnRhZ05hbWUpO1xuXG4gICAgICBpZiAoIUFMTE9XRURfTkFNRVNQQUNFU1tlbGVtZW50Lm5hbWVzcGFjZVVSSV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OQU1FU1BBQ0UpIHtcbiAgICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIEhUTUwgbmFtZXNwYWNlIHRvIFNWR1xuICAgICAgICAvLyBpcyB2aWEgPHN2Zz4uIElmIGl0IGhhcHBlbnMgdmlhIGFueSBvdGhlciB0YWcsIHRoZW5cbiAgICAgICAgLy8gaXQgc2hvdWxkIGJlIGtpbGxlZC5cbiAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdzdmcnO1xuICAgICAgICB9IC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBNYXRoTUwgdG8gU1ZHIGlzIHZpYWBcbiAgICAgICAgLy8gc3ZnIGlmIHBhcmVudCBpcyBlaXRoZXIgPGFubm90YXRpb24teG1sPiBvciBNYXRoTUxcbiAgICAgICAgLy8gdGV4dCBpbnRlZ3JhdGlvbiBwb2ludHMuXG5cblxuICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnc3ZnJyAmJiAocGFyZW50VGFnTmFtZSA9PT0gJ2Fubm90YXRpb24teG1sJyB8fCBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pO1xuICAgICAgICB9IC8vIFdlIG9ubHkgYWxsb3cgZWxlbWVudHMgdGhhdCBhcmUgZGVmaW5lZCBpbiBTVkdcbiAgICAgICAgLy8gc3BlYy4gQWxsIG90aGVycyBhcmUgZGlzYWxsb3dlZCBpbiBTVkcgbmFtZXNwYWNlLlxuXG5cbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oQUxMX1NWR19UQUdTW3RhZ05hbWVdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBIVE1MIG5hbWVzcGFjZSB0byBNYXRoTUxcbiAgICAgICAgLy8gaXMgdmlhIDxtYXRoPi4gSWYgaXQgaGFwcGVucyB2aWEgYW55IG90aGVyIHRhZywgdGhlblxuICAgICAgICAvLyBpdCBzaG91bGQgYmUga2lsbGVkLlxuICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ21hdGgnO1xuICAgICAgICB9IC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBTVkcgdG8gTWF0aE1MIGlzIHZpYVxuICAgICAgICAvLyA8bWF0aD4gYW5kIEhUTUwgaW50ZWdyYXRpb24gcG9pbnRzXG5cblxuICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnbWF0aCcgJiYgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV07XG4gICAgICAgIH0gLy8gV2Ugb25seSBhbGxvdyBlbGVtZW50cyB0aGF0IGFyZSBkZWZpbmVkIGluIE1hdGhNTFxuICAgICAgICAvLyBzcGVjLiBBbGwgb3RoZXJzIGFyZSBkaXNhbGxvd2VkIGluIE1hdGhNTCBuYW1lc3BhY2UuXG5cblxuICAgICAgICByZXR1cm4gQm9vbGVhbihBTExfTUFUSE1MX1RBR1NbdGFnTmFtZV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBTVkcgdG8gSFRNTCBpcyB2aWFcbiAgICAgICAgLy8gSFRNTCBpbnRlZ3JhdGlvbiBwb2ludHMsIGFuZCBmcm9tIE1hdGhNTCB0byBIVE1MXG4gICAgICAgIC8vIGlzIHZpYSBNYXRoTUwgdGV4dCBpbnRlZ3JhdGlvbiBwb2ludHNcbiAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OQU1FU1BBQ0UgJiYgIUhUTUxfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IE1BVEhNTF9OQU1FU1BBQ0UgJiYgIU1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSAvLyBXZSBkaXNhbGxvdyB0YWdzIHRoYXQgYXJlIHNwZWNpZmljIGZvciBNYXRoTUxcbiAgICAgICAgLy8gb3IgU1ZHIGFuZCBzaG91bGQgbmV2ZXIgYXBwZWFyIGluIEhUTUwgbmFtZXNwYWNlXG5cblxuICAgICAgICByZXR1cm4gIUFMTF9NQVRITUxfVEFHU1t0YWdOYW1lXSAmJiAoQ09NTU9OX1NWR19BTkRfSFRNTF9FTEVNRU5UU1t0YWdOYW1lXSB8fCAhQUxMX1NWR19UQUdTW3RhZ05hbWVdKTtcbiAgICAgIH0gLy8gRm9yIFhIVE1MIGFuZCBYTUwgZG9jdW1lbnRzIHRoYXQgc3VwcG9ydCBjdXN0b20gbmFtZXNwYWNlc1xuXG5cbiAgICAgIGlmIChQQVJTRVJfTUVESUFfVFlQRSA9PT0gJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcgJiYgQUxMT1dFRF9OQU1FU1BBQ0VTW2VsZW1lbnQubmFtZXNwYWNlVVJJXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gVGhlIGNvZGUgc2hvdWxkIG5ldmVyIHJlYWNoIHRoaXMgcGxhY2UgKHRoaXMgbWVhbnNcbiAgICAgIC8vIHRoYXQgdGhlIGVsZW1lbnQgc29tZWhvdyBnb3QgbmFtZXNwYWNlIHRoYXQgaXMgbm90XG4gICAgICAvLyBIVE1MLCBTVkcsIE1hdGhNTCBvciBhbGxvd2VkIHZpYSBBTExPV0VEX05BTUVTUEFDRVMpLlxuICAgICAgLy8gUmV0dXJuIGZhbHNlIGp1c3QgaW4gY2FzZS5cblxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBfZm9yY2VSZW1vdmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge05vZGV9IG5vZGUgYSBET00gbm9kZVxuICAgICAqL1xuXG5cbiAgICB2YXIgX2ZvcmNlUmVtb3ZlID0gZnVuY3Rpb24gX2ZvcmNlUmVtb3ZlKG5vZGUpIHtcbiAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICBlbGVtZW50OiBub2RlXG4gICAgICB9KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLXJlbW92ZVxuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBfcmVtb3ZlQXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgYW4gQXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0gIHtOb2RlfSBub2RlIGEgRE9NIG5vZGVcbiAgICAgKi9cblxuXG4gICAgdmFyIF9yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIG5vZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICAgIGF0dHJpYnV0ZTogbm9kZS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpLFxuICAgICAgICAgIGZyb206IG5vZGVcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICAgIGF0dHJpYnV0ZTogbnVsbCxcbiAgICAgICAgICBmcm9tOiBub2RlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTsgLy8gV2Ugdm9pZCBhdHRyaWJ1dGUgdmFsdWVzIGZvciB1bnJlbW92YWJsZSBcImlzXCJcIiBhdHRyaWJ1dGVzXG5cbiAgICAgIGlmIChuYW1lID09PSAnaXMnICYmICFBTExPV0VEX0FUVFJbbmFtZV0pIHtcbiAgICAgICAgaWYgKFJFVFVSTl9ET00gfHwgUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfZm9yY2VSZW1vdmUobm9kZSk7XG4gICAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIF9pbml0RG9jdW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZGlydHkgYSBzdHJpbmcgb2YgZGlydHkgbWFya3VwXG4gICAgICogQHJldHVybiB7RG9jdW1lbnR9IGEgRE9NLCBmaWxsZWQgd2l0aCB0aGUgZGlydHkgbWFya3VwXG4gICAgICovXG5cblxuICAgIHZhciBfaW5pdERvY3VtZW50ID0gZnVuY3Rpb24gX2luaXREb2N1bWVudChkaXJ0eSkge1xuICAgICAgLyogQ3JlYXRlIGEgSFRNTCBkb2N1bWVudCAqL1xuICAgICAgdmFyIGRvYztcbiAgICAgIHZhciBsZWFkaW5nV2hpdGVzcGFjZTtcblxuICAgICAgaWYgKEZPUkNFX0JPRFkpIHtcbiAgICAgICAgZGlydHkgPSAnPHJlbW92ZT48L3JlbW92ZT4nICsgZGlydHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBJZiBGT1JDRV9CT0RZIGlzbid0IHVzZWQsIGxlYWRpbmcgd2hpdGVzcGFjZSBuZWVkcyB0byBiZSBwcmVzZXJ2ZWQgbWFudWFsbHkgKi9cbiAgICAgICAgdmFyIG1hdGNoZXMgPSBzdHJpbmdNYXRjaChkaXJ0eSwgL15bXFxyXFxuXFx0IF0rLyk7XG4gICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoUEFSU0VSX01FRElBX1RZUEUgPT09ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnICYmIE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgLy8gUm9vdCBvZiBYSFRNTCBkb2MgbXVzdCBjb250YWluIHhtbG5zIGRlY2xhcmF0aW9uIChzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3hodG1sMS9ub3JtYXRpdmUuaHRtbCNzdHJpY3QpXG4gICAgICAgIGRpcnR5ID0gJzxodG1sIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPjxoZWFkPjwvaGVhZD48Ym9keT4nICsgZGlydHkgKyAnPC9ib2R5PjwvaHRtbD4nO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlydHlQYXlsb2FkID0gdHJ1c3RlZFR5cGVzUG9saWN5ID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoZGlydHkpIDogZGlydHk7XG4gICAgICAvKlxuICAgICAgICogVXNlIHRoZSBET01QYXJzZXIgQVBJIGJ5IGRlZmF1bHQsIGZhbGxiYWNrIGxhdGVyIGlmIG5lZWRzIGJlXG4gICAgICAgKiBET01QYXJzZXIgbm90IHdvcmsgZm9yIHN2ZyB3aGVuIGhhcyBtdWx0aXBsZSByb290IGVsZW1lbnQuXG4gICAgICAgKi9cblxuICAgICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGRpcnR5UGF5bG9hZCwgUEFSU0VSX01FRElBX1RZUEUpO1xuICAgICAgICB9IGNhdGNoIChfKSB7fVxuICAgICAgfVxuICAgICAgLyogVXNlIGNyZWF0ZUhUTUxEb2N1bWVudCBpbiBjYXNlIERPTVBhcnNlciBpcyBub3QgYXZhaWxhYmxlICovXG5cblxuICAgICAgaWYgKCFkb2MgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgZG9jID0gaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoTkFNRVNQQUNFLCAndGVtcGxhdGUnLCBudWxsKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGRvYy5kb2N1bWVudEVsZW1lbnQuaW5uZXJIVE1MID0gSVNfRU1QVFlfSU5QVVQgPyBlbXB0eUhUTUwgOiBkaXJ0eVBheWxvYWQ7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHsvLyBTeW50YXggZXJyb3IgaWYgZGlydHlQYXlsb2FkIGlzIGludmFsaWQgeG1sXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGJvZHkgPSBkb2MuYm9keSB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICBpZiAoZGlydHkgJiYgbGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgICAgYm9keS5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGVhZGluZ1doaXRlc3BhY2UpLCBib2R5LmNoaWxkTm9kZXNbMF0gfHwgbnVsbCk7XG4gICAgICB9XG4gICAgICAvKiBXb3JrIG9uIHdob2xlIGRvY3VtZW50IG9yIGp1c3QgaXRzIGJvZHkgKi9cblxuXG4gICAgICBpZiAoTkFNRVNQQUNFID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICByZXR1cm4gZ2V0RWxlbWVudHNCeVRhZ05hbWUuY2FsbChkb2MsIFdIT0xFX0RPQ1VNRU5UID8gJ2h0bWwnIDogJ2JvZHknKVswXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFdIT0xFX0RPQ1VNRU5UID8gZG9jLmRvY3VtZW50RWxlbWVudCA6IGJvZHk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBfY3JlYXRlSXRlcmF0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0RvY3VtZW50fSByb290IGRvY3VtZW50L2ZyYWdtZW50IHRvIGNyZWF0ZSBpdGVyYXRvciBmb3JcbiAgICAgKiBAcmV0dXJuIHtJdGVyYXRvcn0gaXRlcmF0b3IgaW5zdGFuY2VcbiAgICAgKi9cblxuXG4gICAgdmFyIF9jcmVhdGVJdGVyYXRvciA9IGZ1bmN0aW9uIF9jcmVhdGVJdGVyYXRvcihyb290KSB7XG4gICAgICByZXR1cm4gY3JlYXRlTm9kZUl0ZXJhdG9yLmNhbGwocm9vdC5vd25lckRvY3VtZW50IHx8IHJvb3QsIHJvb3QsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCB8IE5vZGVGaWx0ZXIuU0hPV19DT01NRU5UIHwgTm9kZUZpbHRlci5TSE9XX1RFWFQsIG51bGwsIGZhbHNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIF9pc0Nsb2JiZXJlZFxuICAgICAqXG4gICAgICogQHBhcmFtICB7Tm9kZX0gZWxtIGVsZW1lbnQgdG8gY2hlY2sgZm9yIGNsb2JiZXJpbmcgYXR0YWNrc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgY2xvYmJlcmVkLCBmYWxzZSBpZiBzYWZlXG4gICAgICovXG5cblxuICAgIHZhciBfaXNDbG9iYmVyZWQgPSBmdW5jdGlvbiBfaXNDbG9iYmVyZWQoZWxtKSB7XG4gICAgICByZXR1cm4gZWxtIGluc3RhbmNlb2YgSFRNTEZvcm1FbGVtZW50ICYmICh0eXBlb2YgZWxtLm5vZGVOYW1lICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxtLnRleHRDb250ZW50ICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxtLnJlbW92ZUNoaWxkICE9PSAnZnVuY3Rpb24nIHx8ICEoZWxtLmF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBOYW1lZE5vZGVNYXApIHx8IHR5cGVvZiBlbG0ucmVtb3ZlQXR0cmlidXRlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbG0uc2V0QXR0cmlidXRlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbG0ubmFtZXNwYWNlVVJJICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxtLmluc2VydEJlZm9yZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxtLmhhc0NoaWxkTm9kZXMgIT09ICdmdW5jdGlvbicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogX2lzTm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtICB7Tm9kZX0gb2JqIG9iamVjdCB0byBjaGVjayB3aGV0aGVyIGl0J3MgYSBET00gbm9kZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaXMgb2JqZWN0IGlzIGEgRE9NIG5vZGVcbiAgICAgKi9cblxuXG4gICAgdmFyIF9pc05vZGUgPSBmdW5jdGlvbiBfaXNOb2RlKG9iamVjdCkge1xuICAgICAgcmV0dXJuIF90eXBlb2YoTm9kZSkgPT09ICdvYmplY3QnID8gb2JqZWN0IGluc3RhbmNlb2YgTm9kZSA6IG9iamVjdCAmJiBfdHlwZW9mKG9iamVjdCkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogX2V4ZWN1dGVIb29rXG4gICAgICogRXhlY3V0ZSB1c2VyIGNvbmZpZ3VyYWJsZSBob29rc1xuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBlbnRyeVBvaW50ICBOYW1lIG9mIHRoZSBob29rJ3MgZW50cnkgcG9pbnRcbiAgICAgKiBAcGFyYW0gIHtOb2RlfSBjdXJyZW50Tm9kZSBub2RlIHRvIHdvcmsgb24gd2l0aCB0aGUgaG9va1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBhZGRpdGlvbmFsIGhvb2sgcGFyYW1ldGVyc1xuICAgICAqL1xuXG5cbiAgICB2YXIgX2V4ZWN1dGVIb29rID0gZnVuY3Rpb24gX2V4ZWN1dGVIb29rKGVudHJ5UG9pbnQsIGN1cnJlbnROb2RlLCBkYXRhKSB7XG4gICAgICBpZiAoIWhvb2tzW2VudHJ5UG9pbnRdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXJyYXlGb3JFYWNoKGhvb2tzW2VudHJ5UG9pbnRdLCBmdW5jdGlvbiAoaG9vaykge1xuICAgICAgICBob29rLmNhbGwoRE9NUHVyaWZ5LCBjdXJyZW50Tm9kZSwgZGF0YSwgQ09ORklHKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogX3Nhbml0aXplRWxlbWVudHNcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0IG5vZGVOYW1lXG4gICAgICogQHByb3RlY3QgdGV4dENvbnRlbnRcbiAgICAgKiBAcHJvdGVjdCByZW1vdmVDaGlsZFxuICAgICAqXG4gICAgICogQHBhcmFtICAge05vZGV9IGN1cnJlbnROb2RlIHRvIGNoZWNrIGZvciBwZXJtaXNzaW9uIHRvIGV4aXN0XG4gICAgICogQHJldHVybiAge0Jvb2xlYW59IHRydWUgaWYgbm9kZSB3YXMga2lsbGVkLCBmYWxzZSBpZiBsZWZ0IGFsaXZlXG4gICAgICovXG5cblxuICAgIHZhciBfc2FuaXRpemVFbGVtZW50cyA9IGZ1bmN0aW9uIF9zYW5pdGl6ZUVsZW1lbnRzKGN1cnJlbnROb2RlKSB7XG4gICAgICB2YXIgY29udGVudDtcbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cblxuICAgICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZUVsZW1lbnRzJywgY3VycmVudE5vZGUsIG51bGwpO1xuICAgICAgLyogQ2hlY2sgaWYgZWxlbWVudCBpcyBjbG9iYmVyZWQgb3IgY2FuIGNsb2JiZXIgKi9cblxuXG4gICAgICBpZiAoX2lzQ2xvYmJlcmVkKGN1cnJlbnROb2RlKSkge1xuICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLyogTm93IGxldCdzIGNoZWNrIHRoZSBlbGVtZW50J3MgdHlwZSBhbmQgbmFtZSAqL1xuXG5cbiAgICAgIHZhciB0YWdOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoY3VycmVudE5vZGUubm9kZU5hbWUpO1xuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuXG4gICAgICBfZXhlY3V0ZUhvb2soJ3Vwb25TYW5pdGl6ZUVsZW1lbnQnLCBjdXJyZW50Tm9kZSwge1xuICAgICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgICBhbGxvd2VkVGFnczogQUxMT1dFRF9UQUdTXG4gICAgICB9KTtcbiAgICAgIC8qIERldGVjdCBtWFNTIGF0dGVtcHRzIGFidXNpbmcgbmFtZXNwYWNlIGNvbmZ1c2lvbiAqL1xuXG5cbiAgICAgIGlmIChjdXJyZW50Tm9kZS5oYXNDaGlsZE5vZGVzKCkgJiYgIV9pc05vZGUoY3VycmVudE5vZGUuZmlyc3RFbGVtZW50Q2hpbGQpICYmICghX2lzTm9kZShjdXJyZW50Tm9kZS5jb250ZW50KSB8fCAhX2lzTm9kZShjdXJyZW50Tm9kZS5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkKSkgJiYgcmVnRXhwVGVzdCgvPFsvXFx3XS9nLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpICYmIHJlZ0V4cFRlc3QoLzxbL1xcd10vZywgY3VycmVudE5vZGUudGV4dENvbnRlbnQpKSB7XG4gICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvKiBSZW1vdmUgZWxlbWVudCBpZiBhbnl0aGluZyBmb3JiaWRzIGl0cyBwcmVzZW5jZSAqL1xuXG5cbiAgICAgIGlmICghQUxMT1dFRF9UQUdTW3RhZ05hbWVdIHx8IEZPUkJJRF9UQUdTW3RhZ05hbWVdKSB7XG4gICAgICAgIC8qIENoZWNrIGlmIHdlIGhhdmUgYSBjdXN0b20gZWxlbWVudCB0byBoYW5kbGUgKi9cbiAgICAgICAgaWYgKCFGT1JCSURfVEFHU1t0YWdOYW1lXSAmJiBfYmFzaWNDdXN0b21FbGVtZW50VGVzdCh0YWdOYW1lKSkge1xuICAgICAgICAgIGlmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIHRhZ05hbWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgaWYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayh0YWdOYW1lKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qIEtlZXAgY29udGVudCBleGNlcHQgZm9yIGJhZC1saXN0ZWQgZWxlbWVudHMgKi9cblxuXG4gICAgICAgIGlmIChLRUVQX0NPTlRFTlQgJiYgIUZPUkJJRF9DT05URU5UU1t0YWdOYW1lXSkge1xuICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSkgfHwgY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IGdldENoaWxkTm9kZXMoY3VycmVudE5vZGUpIHx8IGN1cnJlbnROb2RlLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgICBpZiAoY2hpbGROb2RlcyAmJiBwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRDb3VudCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRDb3VudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNsb25lTm9kZShjaGlsZE5vZGVzW2ldLCB0cnVlKSwgZ2V0TmV4dFNpYmxpbmcoY3VycmVudE5vZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLyogQ2hlY2sgd2hldGhlciBlbGVtZW50IGhhcyBhIHZhbGlkIG5hbWVzcGFjZSAqL1xuXG5cbiAgICAgIGlmIChjdXJyZW50Tm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgIV9jaGVja1ZhbGlkTmFtZXNwYWNlKGN1cnJlbnROb2RlKSkge1xuICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLyogTWFrZSBzdXJlIHRoYXQgb2xkZXIgYnJvd3NlcnMgZG9uJ3QgZ2V0IG5vc2NyaXB0IG1YU1MgKi9cblxuXG4gICAgICBpZiAoKHRhZ05hbWUgPT09ICdub3NjcmlwdCcgfHwgdGFnTmFtZSA9PT0gJ25vZW1iZWQnKSAmJiByZWdFeHBUZXN0KC88XFwvbm8oc2NyaXB0fGVtYmVkKS9pLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpKSB7XG4gICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvKiBTYW5pdGl6ZSBlbGVtZW50IGNvbnRlbnQgdG8gYmUgdGVtcGxhdGUtc2FmZSAqL1xuXG5cbiAgICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMgJiYgY3VycmVudE5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgLyogR2V0IHRoZSBlbGVtZW50J3MgdGV4dCBjb250ZW50ICovXG4gICAgICAgIGNvbnRlbnQgPSBjdXJyZW50Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgY29udGVudCA9IHN0cmluZ1JlcGxhY2UoY29udGVudCwgTVVTVEFDSEVfRVhQUiQxLCAnICcpO1xuICAgICAgICBjb250ZW50ID0gc3RyaW5nUmVwbGFjZShjb250ZW50LCBFUkJfRVhQUiQxLCAnICcpO1xuICAgICAgICBjb250ZW50ID0gc3RyaW5nUmVwbGFjZShjb250ZW50LCBUTVBMSVRfRVhQUiQxLCAnICcpO1xuXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS50ZXh0Q29udGVudCAhPT0gY29udGVudCkge1xuICAgICAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICAgICAgZWxlbWVudDogY3VycmVudE5vZGUuY2xvbmVOb2RlKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjdXJyZW50Tm9kZS50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cblxuXG4gICAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVFbGVtZW50cycsIGN1cnJlbnROb2RlLCBudWxsKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogX2lzVmFsaWRBdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gbGNUYWcgTG93ZXJjYXNlIHRhZyBuYW1lIG9mIGNvbnRhaW5pbmcgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGxjTmFtZSBMb3dlcmNhc2UgYXR0cmlidXRlIG5hbWUuXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG5cbiAgICB2YXIgX2lzVmFsaWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSkge1xuICAgICAgLyogTWFrZSBzdXJlIGF0dHJpYnV0ZSBjYW5ub3QgY2xvYmJlciAqL1xuICAgICAgaWYgKFNBTklUSVpFX0RPTSAmJiAobGNOYW1lID09PSAnaWQnIHx8IGxjTmFtZSA9PT0gJ25hbWUnKSAmJiAodmFsdWUgaW4gZG9jdW1lbnQgfHwgdmFsdWUgaW4gZm9ybUVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8qIEFsbG93IHZhbGlkIGRhdGEtKiBhdHRyaWJ1dGVzOiBBdCBsZWFzdCBvbmUgY2hhcmFjdGVyIGFmdGVyIFwiLVwiXG4gICAgICAgICAgKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI2VtYmVkZGluZy1jdXN0b20tbm9uLXZpc2libGUtZGF0YS13aXRoLXRoZS1kYXRhLSotYXR0cmlidXRlcylcbiAgICAgICAgICBYTUwtY29tcGF0aWJsZSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCN4bWwtY29tcGF0aWJsZSBhbmQgaHR0cDovL3d3dy53My5vcmcvVFIveG1sLyNkMGU4MDQpXG4gICAgICAgICAgV2UgZG9uJ3QgbmVlZCB0byBjaGVjayB0aGUgdmFsdWU7IGl0J3MgYWx3YXlzIFVSSSBzYWZlLiAqL1xuXG5cbiAgICAgIGlmIChBTExPV19EQVRBX0FUVFIgJiYgIUZPUkJJRF9BVFRSW2xjTmFtZV0gJiYgcmVnRXhwVGVzdChEQVRBX0FUVFIkMSwgbGNOYW1lKSkgOyBlbHNlIGlmIChBTExPV19BUklBX0FUVFIgJiYgcmVnRXhwVGVzdChBUklBX0FUVFIkMSwgbGNOYW1lKSkgOyBlbHNlIGlmICghQUxMT1dFRF9BVFRSW2xjTmFtZV0gfHwgRk9SQklEX0FUVFJbbGNOYW1lXSkge1xuICAgICAgICBpZiAoIC8vIEZpcnN0IGNvbmRpdGlvbiBkb2VzIGEgdmVyeSBiYXNpYyBjaGVjayBpZiBhKSBpdCdzIGJhc2ljYWxseSBhIHZhbGlkIGN1c3RvbSBlbGVtZW50IHRhZ25hbWUgQU5EXG4gICAgICAgIC8vIGIpIGlmIHRoZSB0YWdOYW1lIHBhc3NlcyB3aGF0ZXZlciB0aGUgdXNlciBoYXMgY29uZmlndXJlZCBmb3IgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrXG4gICAgICAgIC8vIGFuZCBjKSBpZiB0aGUgYXR0cmlidXRlIG5hbWUgcGFzc2VzIHdoYXRldmVyIHRoZSB1c2VyIGhhcyBjb25maWd1cmVkIGZvciBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2tcbiAgICAgICAgX2Jhc2ljQ3VzdG9tRWxlbWVudFRlc3QobGNUYWcpICYmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIGxjVGFnKSB8fCBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sobGNUYWcpKSAmJiAoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrIGluc3RhbmNlb2YgUmVnRXhwICYmIHJlZ0V4cFRlc3QoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrLCBsY05hbWUpIHx8IENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayhsY05hbWUpKSB8fCAvLyBBbHRlcm5hdGl2ZSwgc2Vjb25kIGNvbmRpdGlvbiBjaGVja3MgaWYgaXQncyBhbiBgaXNgLWF0dHJpYnV0ZSwgQU5EXG4gICAgICAgIC8vIHRoZSB2YWx1ZSBwYXNzZXMgd2hhdGV2ZXIgdGhlIHVzZXIgaGFzIGNvbmZpZ3VyZWQgZm9yIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVja1xuICAgICAgICBsY05hbWUgPT09ICdpcycgJiYgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzICYmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIHZhbHVlKSB8fCBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sodmFsdWUpKSkgOyBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyogQ2hlY2sgdmFsdWUgaXMgc2FmZS4gRmlyc3QsIGlzIGF0dHIgaW5lcnQ/IElmIHNvLCBpcyBzYWZlICovXG5cbiAgICAgIH0gZWxzZSBpZiAoVVJJX1NBRkVfQVRUUklCVVRFU1tsY05hbWVdKSA7IGVsc2UgaWYgKHJlZ0V4cFRlc3QoSVNfQUxMT1dFRF9VUkkkMSwgc3RyaW5nUmVwbGFjZSh2YWx1ZSwgQVRUUl9XSElURVNQQUNFJDEsICcnKSkpIDsgZWxzZSBpZiAoKGxjTmFtZSA9PT0gJ3NyYycgfHwgbGNOYW1lID09PSAneGxpbms6aHJlZicgfHwgbGNOYW1lID09PSAnaHJlZicpICYmIGxjVGFnICE9PSAnc2NyaXB0JyAmJiBzdHJpbmdJbmRleE9mKHZhbHVlLCAnZGF0YTonKSA9PT0gMCAmJiBEQVRBX1VSSV9UQUdTW2xjVGFnXSkgOyBlbHNlIGlmIChBTExPV19VTktOT1dOX1BST1RPQ09MUyAmJiAhcmVnRXhwVGVzdChJU19TQ1JJUFRfT1JfREFUQSQxLCBzdHJpbmdSZXBsYWNlKHZhbHVlLCBBVFRSX1dISVRFU1BBQ0UkMSwgJycpKSkgOyBlbHNlIGlmICghdmFsdWUpIDsgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBfYmFzaWNDdXN0b21FbGVtZW50Q2hlY2tcbiAgICAgKiBjaGVja3MgaWYgYXQgbGVhc3Qgb25lIGRhc2ggaXMgaW5jbHVkZWQgaW4gdGFnTmFtZSwgYW5kIGl0J3Mgbm90IHRoZSBmaXJzdCBjaGFyXG4gICAgICogZm9yIG1vcmUgc29waGlzdGljYXRlZCBjaGVja2luZyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy92YWxpZGF0ZS1lbGVtZW50LW5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSBuYW1lIG9mIHRoZSB0YWcgb2YgdGhlIG5vZGUgdG8gc2FuaXRpemVcbiAgICAgKi9cblxuXG4gICAgdmFyIF9iYXNpY0N1c3RvbUVsZW1lbnRUZXN0ID0gZnVuY3Rpb24gX2Jhc2ljQ3VzdG9tRWxlbWVudFRlc3QodGFnTmFtZSkge1xuICAgICAgcmV0dXJuIHRhZ05hbWUuaW5kZXhPZignLScpID4gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIF9zYW5pdGl6ZUF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0IGF0dHJpYnV0ZXNcbiAgICAgKiBAcHJvdGVjdCBub2RlTmFtZVxuICAgICAqIEBwcm90ZWN0IHJlbW92ZUF0dHJpYnV0ZVxuICAgICAqIEBwcm90ZWN0IHNldEF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQHBhcmFtICB7Tm9kZX0gY3VycmVudE5vZGUgdG8gc2FuaXRpemVcbiAgICAgKi9cblxuXG4gICAgdmFyIF9zYW5pdGl6ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBfc2FuaXRpemVBdHRyaWJ1dGVzKGN1cnJlbnROb2RlKSB7XG4gICAgICB2YXIgYXR0cjtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHZhciBsY05hbWU7XG4gICAgICB2YXIgbDtcbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cblxuICAgICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZUF0dHJpYnV0ZXMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gY3VycmVudE5vZGUuYXR0cmlidXRlcztcbiAgICAgIC8qIENoZWNrIGlmIHdlIGhhdmUgYXR0cmlidXRlczsgaWYgbm90IHdlIG1pZ2h0IGhhdmUgYSB0ZXh0IG5vZGUgKi9cblxuICAgICAgaWYgKCFhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhvb2tFdmVudCA9IHtcbiAgICAgICAgYXR0ck5hbWU6ICcnLFxuICAgICAgICBhdHRyVmFsdWU6ICcnLFxuICAgICAgICBrZWVwQXR0cjogdHJ1ZSxcbiAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IEFMTE9XRURfQVRUUlxuICAgICAgfTtcbiAgICAgIGwgPSBhdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAgIC8qIEdvIGJhY2t3YXJkcyBvdmVyIGFsbCBhdHRyaWJ1dGVzOyBzYWZlbHkgcmVtb3ZlIGJhZCBvbmVzICovXG5cbiAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgYXR0ciA9IGF0dHJpYnV0ZXNbbF07XG4gICAgICAgIHZhciBfYXR0ciA9IGF0dHIsXG4gICAgICAgICAgICBuYW1lID0gX2F0dHIubmFtZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZVVSSSA9IF9hdHRyLm5hbWVzcGFjZVVSSTtcbiAgICAgICAgdmFsdWUgPSBuYW1lID09PSAndmFsdWUnID8gYXR0ci52YWx1ZSA6IHN0cmluZ1RyaW0oYXR0ci52YWx1ZSk7XG4gICAgICAgIGxjTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKG5hbWUpO1xuICAgICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG5cbiAgICAgICAgaG9va0V2ZW50LmF0dHJOYW1lID0gbGNOYW1lO1xuICAgICAgICBob29rRXZlbnQuYXR0clZhbHVlID0gdmFsdWU7XG4gICAgICAgIGhvb2tFdmVudC5rZWVwQXR0ciA9IHRydWU7XG4gICAgICAgIGhvb2tFdmVudC5mb3JjZUtlZXBBdHRyID0gdW5kZWZpbmVkOyAvLyBBbGxvd3MgZGV2ZWxvcGVycyB0byBzZWUgdGhpcyBpcyBhIHByb3BlcnR5IHRoZXkgY2FuIHNldFxuXG4gICAgICAgIF9leGVjdXRlSG9vaygndXBvblNhbml0aXplQXR0cmlidXRlJywgY3VycmVudE5vZGUsIGhvb2tFdmVudCk7XG5cbiAgICAgICAgdmFsdWUgPSBob29rRXZlbnQuYXR0clZhbHVlO1xuICAgICAgICAvKiBEaWQgdGhlIGhvb2tzIGFwcHJvdmUgb2YgdGhlIGF0dHJpYnV0ZT8gKi9cblxuICAgICAgICBpZiAoaG9va0V2ZW50LmZvcmNlS2VlcEF0dHIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvKiBSZW1vdmUgYXR0cmlidXRlICovXG5cblxuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgLyogRGlkIHRoZSBob29rcyBhcHByb3ZlIG9mIHRoZSBhdHRyaWJ1dGU/ICovXG5cblxuICAgICAgICBpZiAoIWhvb2tFdmVudC5rZWVwQXR0cikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qIFdvcmsgYXJvdW5kIGEgc2VjdXJpdHkgaXNzdWUgaW4galF1ZXJ5IDMuMCAqL1xuXG5cbiAgICAgICAgaWYgKCFBTExPV19TRUxGX0NMT1NFX0lOX0FUVFIgJiYgcmVnRXhwVGVzdCgvXFwvPi9pLCB2YWx1ZSkpIHtcbiAgICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qIFNhbml0aXplIGF0dHJpYnV0ZSBjb250ZW50IHRvIGJlIHRlbXBsYXRlLXNhZmUgKi9cblxuXG4gICAgICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgICAgICB2YWx1ZSA9IHN0cmluZ1JlcGxhY2UodmFsdWUsIE1VU1RBQ0hFX0VYUFIkMSwgJyAnKTtcbiAgICAgICAgICB2YWx1ZSA9IHN0cmluZ1JlcGxhY2UodmFsdWUsIEVSQl9FWFBSJDEsICcgJyk7XG4gICAgICAgICAgdmFsdWUgPSBzdHJpbmdSZXBsYWNlKHZhbHVlLCBUTVBMSVRfRVhQUiQxLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIC8qIElzIGB2YWx1ZWAgdmFsaWQgZm9yIHRoaXMgYXR0cmlidXRlPyAqL1xuXG5cbiAgICAgICAgdmFyIGxjVGFnID0gdHJhbnNmb3JtQ2FzZUZ1bmMoY3VycmVudE5vZGUubm9kZU5hbWUpO1xuXG4gICAgICAgIGlmICghX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLyogRnVsbCBET00gQ2xvYmJlcmluZyBwcm90ZWN0aW9uIHZpYSBuYW1lc3BhY2UgaXNvbGF0aW9uLFxuICAgICAgICAgKiBQcmVmaXggaWQgYW5kIG5hbWUgYXR0cmlidXRlcyB3aXRoIGB1c2VyLWNvbnRlbnQtYFxuICAgICAgICAgKi9cblxuXG4gICAgICAgIGlmIChTQU5JVElaRV9OQU1FRF9QUk9QUyAmJiAobGNOYW1lID09PSAnaWQnIHx8IGxjTmFtZSA9PT0gJ25hbWUnKSkge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgYXR0cmlidXRlIHdpdGggdGhpcyB2YWx1ZVxuICAgICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpOyAvLyBQcmVmaXggdGhlIHZhbHVlIGFuZCBsYXRlciByZS1jcmVhdGUgdGhlIGF0dHJpYnV0ZSB3aXRoIHRoZSBzYW5pdGl6ZWQgdmFsdWVcblxuXG4gICAgICAgICAgdmFsdWUgPSBTQU5JVElaRV9OQU1FRF9QUk9QU19QUkVGSVggKyB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKiBIYW5kbGUgYXR0cmlidXRlcyB0aGF0IHJlcXVpcmUgVHJ1c3RlZCBUeXBlcyAqL1xuXG5cbiAgICAgICAgaWYgKHRydXN0ZWRUeXBlc1BvbGljeSAmJiBfdHlwZW9mKHRydXN0ZWRUeXBlcykgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0cnVzdGVkVHlwZXMuZ2V0QXR0cmlidXRlVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGlmIChuYW1lc3BhY2VVUkkpIDsgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRydXN0ZWRUeXBlcy5nZXRBdHRyaWJ1dGVUeXBlKGxjVGFnLCBsY05hbWUpKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ1RydXN0ZWRIVE1MJzpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdUcnVzdGVkU2NyaXB0VVJMJzpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVTY3JpcHRVUkwodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBIYW5kbGUgaW52YWxpZCBkYXRhLSogYXR0cmlidXRlIHNldCBieSB0cnktY2F0Y2hpbmcgaXQgKi9cblxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKG5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgY3VycmVudE5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlVVJJLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIEZhbGxiYWNrIHRvIHNldEF0dHJpYnV0ZSgpIGZvciBicm93c2VyLXVucmVjb2duaXplZCBuYW1lc3BhY2VzIGUuZy4gXCJ4LXNjaGVtYVwiLiAqL1xuICAgICAgICAgICAgY3VycmVudE5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnJheVBvcChET01QdXJpZnkucmVtb3ZlZCk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICB9XG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG5cblxuICAgICAgX2V4ZWN1dGVIb29rKCdhZnRlclNhbml0aXplQXR0cmlidXRlcycsIGN1cnJlbnROb2RlLCBudWxsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIF9zYW5pdGl6ZVNoYWRvd0RPTVxuICAgICAqXG4gICAgICogQHBhcmFtICB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ21lbnQgdG8gaXRlcmF0ZSBvdmVyIHJlY3Vyc2l2ZWx5XG4gICAgICovXG5cblxuICAgIHZhciBfc2FuaXRpemVTaGFkb3dET00gPSBmdW5jdGlvbiBfc2FuaXRpemVTaGFkb3dET00oZnJhZ21lbnQpIHtcbiAgICAgIHZhciBzaGFkb3dOb2RlO1xuXG4gICAgICB2YXIgc2hhZG93SXRlcmF0b3IgPSBfY3JlYXRlSXRlcmF0b3IoZnJhZ21lbnQpO1xuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuXG5cbiAgICAgIF9leGVjdXRlSG9vaygnYmVmb3JlU2FuaXRpemVTaGFkb3dET00nLCBmcmFnbWVudCwgbnVsbCk7XG5cbiAgICAgIHdoaWxlIChzaGFkb3dOb2RlID0gc2hhZG93SXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICAgIF9leGVjdXRlSG9vaygndXBvblNhbml0aXplU2hhZG93Tm9kZScsIHNoYWRvd05vZGUsIG51bGwpO1xuICAgICAgICAvKiBTYW5pdGl6ZSB0YWdzIGFuZCBlbGVtZW50cyAqL1xuXG5cbiAgICAgICAgaWYgKF9zYW5pdGl6ZUVsZW1lbnRzKHNoYWRvd05vZGUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLyogRGVlcCBzaGFkb3cgRE9NIGRldGVjdGVkICovXG5cblxuICAgICAgICBpZiAoc2hhZG93Tm9kZS5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICAgIF9zYW5pdGl6ZVNoYWRvd0RPTShzaGFkb3dOb2RlLmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qIENoZWNrIGF0dHJpYnV0ZXMsIHNhbml0aXplIGlmIG5lY2Vzc2FyeSAqL1xuXG5cbiAgICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhzaGFkb3dOb2RlKTtcbiAgICAgIH1cbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cblxuXG4gICAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVTaGFkb3dET00nLCBmcmFnbWVudCwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTYW5pdGl6ZVxuICAgICAqIFB1YmxpYyBtZXRob2QgcHJvdmlkaW5nIGNvcmUgc2FuaXRhdGlvbiBmdW5jdGlvbmFsaXR5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xOb2RlfSBkaXJ0eSBzdHJpbmcgb3IgRE9NIG5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG5cbiAgICBET01QdXJpZnkuc2FuaXRpemUgPSBmdW5jdGlvbiAoZGlydHkpIHtcbiAgICAgIHZhciBjZmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGJvZHk7XG4gICAgICB2YXIgaW1wb3J0ZWROb2RlO1xuICAgICAgdmFyIGN1cnJlbnROb2RlO1xuICAgICAgdmFyIHJldHVybk5vZGU7XG4gICAgICAvKiBNYWtlIHN1cmUgd2UgaGF2ZSBhIHN0cmluZyB0byBzYW5pdGl6ZS5cbiAgICAgICAgRE8gTk9UIHJldHVybiBlYXJseSwgYXMgdGhpcyB3aWxsIHJldHVybiB0aGUgd3JvbmcgdHlwZSBpZlxuICAgICAgICB0aGUgdXNlciBoYXMgcmVxdWVzdGVkIGEgRE9NIG9iamVjdCByYXRoZXIgdGhhbiBhIHN0cmluZyAqL1xuXG4gICAgICBJU19FTVBUWV9JTlBVVCA9ICFkaXJ0eTtcblxuICAgICAgaWYgKElTX0VNUFRZX0lOUFVUKSB7XG4gICAgICAgIGRpcnR5ID0gJzwhLS0+JztcbiAgICAgIH1cbiAgICAgIC8qIFN0cmluZ2lmeSwgaW4gY2FzZSBkaXJ0eSBpcyBhbiBvYmplY3QgKi9cblxuXG4gICAgICBpZiAodHlwZW9mIGRpcnR5ICE9PSAnc3RyaW5nJyAmJiAhX2lzTm9kZShkaXJ0eSkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lZ2F0ZWQtY29uZGl0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgZGlydHkudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ3RvU3RyaW5nIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlydHkgPSBkaXJ0eS50b1N0cmluZygpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBkaXJ0eSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgnZGlydHkgaXMgbm90IGEgc3RyaW5nLCBhYm9ydGluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogUmV0dXJuIGRpcnR5IEhUTUwgaWYgRE9NUHVyaWZ5IGNhbm5vdCBydW4gKi9cblxuXG4gICAgICBpZiAoIURPTVB1cmlmeS5pc1N1cHBvcnRlZCkge1xuICAgICAgICByZXR1cm4gZGlydHk7XG4gICAgICB9XG4gICAgICAvKiBBc3NpZ24gY29uZmlnIHZhcnMgKi9cblxuXG4gICAgICBpZiAoIVNFVF9DT05GSUcpIHtcbiAgICAgICAgX3BhcnNlQ29uZmlnKGNmZyk7XG4gICAgICB9XG4gICAgICAvKiBDbGVhbiB1cCByZW1vdmVkIGVsZW1lbnRzICovXG5cblxuICAgICAgRE9NUHVyaWZ5LnJlbW92ZWQgPSBbXTtcbiAgICAgIC8qIENoZWNrIGlmIGRpcnR5IGlzIGNvcnJlY3RseSB0eXBlZCBmb3IgSU5fUExBQ0UgKi9cblxuICAgICAgaWYgKHR5cGVvZiBkaXJ0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgSU5fUExBQ0UgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKElOX1BMQUNFKSB7XG4gICAgICAgIC8qIERvIHNvbWUgZWFybHkgcHJlLXNhbml0aXphdGlvbiB0byBhdm9pZCB1bnNhZmUgcm9vdCBub2RlcyAqL1xuICAgICAgICBpZiAoZGlydHkubm9kZU5hbWUpIHtcbiAgICAgICAgICB2YXIgdGFnTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKGRpcnR5Lm5vZGVOYW1lKTtcblxuICAgICAgICAgIGlmICghQUxMT1dFRF9UQUdTW3RhZ05hbWVdIHx8IEZPUkJJRF9UQUdTW3RhZ05hbWVdKSB7XG4gICAgICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ3Jvb3Qgbm9kZSBpcyBmb3JiaWRkZW4gYW5kIGNhbm5vdCBiZSBzYW5pdGl6ZWQgaW4tcGxhY2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGlydHkgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIC8qIElmIGRpcnR5IGlzIGEgRE9NIGVsZW1lbnQsIGFwcGVuZCB0byBhbiBlbXB0eSBkb2N1bWVudCB0byBhdm9pZFxuICAgICAgICAgICBlbGVtZW50cyBiZWluZyBzdHJpcHBlZCBieSB0aGUgcGFyc2VyICovXG4gICAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KCc8IS0tLS0+Jyk7XG4gICAgICAgIGltcG9ydGVkTm9kZSA9IGJvZHkub3duZXJEb2N1bWVudC5pbXBvcnROb2RlKGRpcnR5LCB0cnVlKTtcblxuICAgICAgICBpZiAoaW1wb3J0ZWROb2RlLm5vZGVUeXBlID09PSAxICYmIGltcG9ydGVkTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgICAgLyogTm9kZSBpcyBhbHJlYWR5IGEgYm9keSwgdXNlIGFzIGlzICovXG4gICAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbXBvcnRlZE5vZGUubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgICAgIGJvZHkgPSBpbXBvcnRlZE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLWFwcGVuZFxuICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoaW1wb3J0ZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogRXhpdCBkaXJlY3RseSBpZiB3ZSBoYXZlIG5vdGhpbmcgdG8gZG8gKi9cbiAgICAgICAgaWYgKCFSRVRVUk5fRE9NICYmICFTQUZFX0ZPUl9URU1QTEFURVMgJiYgIVdIT0xFX0RPQ1VNRU5UICYmIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgICAgICBkaXJ0eS5pbmRleE9mKCc8JykgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoZGlydHkpIDogZGlydHk7XG4gICAgICAgIH1cbiAgICAgICAgLyogSW5pdGlhbGl6ZSB0aGUgZG9jdW1lbnQgdG8gd29yayBvbiAqL1xuXG5cbiAgICAgICAgYm9keSA9IF9pbml0RG9jdW1lbnQoZGlydHkpO1xuICAgICAgICAvKiBDaGVjayB3ZSBoYXZlIGEgRE9NIG5vZGUgZnJvbSB0aGUgZGF0YSAqL1xuXG4gICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgIHJldHVybiBSRVRVUk5fRE9NID8gbnVsbCA6IFJFVFVSTl9UUlVTVEVEX1RZUEUgPyBlbXB0eUhUTUwgOiAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogUmVtb3ZlIGZpcnN0IGVsZW1lbnQgbm9kZSAob3VycykgaWYgRk9SQ0VfQk9EWSBpcyBzZXQgKi9cblxuXG4gICAgICBpZiAoYm9keSAmJiBGT1JDRV9CT0RZKSB7XG4gICAgICAgIF9mb3JjZVJlbW92ZShib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgLyogR2V0IG5vZGUgaXRlcmF0b3IgKi9cblxuXG4gICAgICB2YXIgbm9kZUl0ZXJhdG9yID0gX2NyZWF0ZUl0ZXJhdG9yKElOX1BMQUNFID8gZGlydHkgOiBib2R5KTtcbiAgICAgIC8qIE5vdyBzdGFydCBpdGVyYXRpbmcgb3ZlciB0aGUgY3JlYXRlZCBkb2N1bWVudCAqL1xuXG5cbiAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSA9IG5vZGVJdGVyYXRvci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgIC8qIFNhbml0aXplIHRhZ3MgYW5kIGVsZW1lbnRzICovXG4gICAgICAgIGlmIChfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvKiBTaGFkb3cgRE9NIGRldGVjdGVkLCBzYW5pdGl6ZSBpdCAqL1xuXG5cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLmNvbnRlbnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgICAgX3Nhbml0aXplU2hhZG93RE9NKGN1cnJlbnROb2RlLmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qIENoZWNrIGF0dHJpYnV0ZXMsIHNhbml0aXplIGlmIG5lY2Vzc2FyeSAqL1xuXG5cbiAgICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhjdXJyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgICAvKiBJZiB3ZSBzYW5pdGl6ZWQgYGRpcnR5YCBpbi1wbGFjZSwgcmV0dXJuIGl0LiAqL1xuXG5cbiAgICAgIGlmIChJTl9QTEFDRSkge1xuICAgICAgICByZXR1cm4gZGlydHk7XG4gICAgICB9XG4gICAgICAvKiBSZXR1cm4gc2FuaXRpemVkIHN0cmluZyBvciBET00gKi9cblxuXG4gICAgICBpZiAoUkVUVVJOX0RPTSkge1xuICAgICAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICAgIHJldHVybk5vZGUgPSBjcmVhdGVEb2N1bWVudEZyYWdtZW50LmNhbGwoYm9keS5vd25lckRvY3VtZW50KTtcblxuICAgICAgICAgIHdoaWxlIChib2R5LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1hcHBlbmRcbiAgICAgICAgICAgIHJldHVybk5vZGUuYXBwZW5kQ2hpbGQoYm9keS5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuTm9kZSA9IGJvZHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQUxMT1dFRF9BVFRSLnNoYWRvd3Jvb3QgfHwgQUxMT1dFRF9BVFRSLnNoYWRvd3Jvb3Rtb2QpIHtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAgQWRvcHROb2RlKCkgaXMgbm90IHVzZWQgYmVjYXVzZSBpbnRlcm5hbCBzdGF0ZSBpcyBub3QgcmVzZXRcbiAgICAgICAgICAgIChlLmcuIHRoZSBwYXN0IG5hbWVzIG1hcCBvZiBhIEhUTUxGb3JtRWxlbWVudCksIHRoaXMgaXMgc2FmZVxuICAgICAgICAgICAgaW4gdGhlb3J5IGJ1dCB3ZSB3b3VsZCByYXRoZXIgbm90IHJpc2sgYW5vdGhlciBhdHRhY2sgdmVjdG9yLlxuICAgICAgICAgICAgVGhlIHN0YXRlIHRoYXQgaXMgY2xvbmVkIGJ5IGltcG9ydE5vZGUoKSBpcyBleHBsaWNpdGx5IGRlZmluZWRcbiAgICAgICAgICAgIGJ5IHRoZSBzcGVjcy5cbiAgICAgICAgICAqL1xuICAgICAgICAgIHJldHVybk5vZGUgPSBpbXBvcnROb2RlLmNhbGwob3JpZ2luYWxEb2N1bWVudCwgcmV0dXJuTm9kZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0dXJuTm9kZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlcmlhbGl6ZWRIVE1MID0gV0hPTEVfRE9DVU1FTlQgPyBib2R5Lm91dGVySFRNTCA6IGJvZHkuaW5uZXJIVE1MO1xuICAgICAgLyogU2VyaWFsaXplIGRvY3R5cGUgaWYgYWxsb3dlZCAqL1xuXG4gICAgICBpZiAoV0hPTEVfRE9DVU1FTlQgJiYgQUxMT1dFRF9UQUdTWychZG9jdHlwZSddICYmIGJvZHkub3duZXJEb2N1bWVudCAmJiBib2R5Lm93bmVyRG9jdW1lbnQuZG9jdHlwZSAmJiBib2R5Lm93bmVyRG9jdW1lbnQuZG9jdHlwZS5uYW1lICYmIHJlZ0V4cFRlc3QoRE9DVFlQRV9OQU1FLCBib2R5Lm93bmVyRG9jdW1lbnQuZG9jdHlwZS5uYW1lKSkge1xuICAgICAgICBzZXJpYWxpemVkSFRNTCA9ICc8IURPQ1RZUEUgJyArIGJvZHkub3duZXJEb2N1bWVudC5kb2N0eXBlLm5hbWUgKyAnPlxcbicgKyBzZXJpYWxpemVkSFRNTDtcbiAgICAgIH1cbiAgICAgIC8qIFNhbml0aXplIGZpbmFsIHN0cmluZyB0ZW1wbGF0ZS1zYWZlICovXG5cblxuICAgICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgICBzZXJpYWxpemVkSFRNTCA9IHN0cmluZ1JlcGxhY2Uoc2VyaWFsaXplZEhUTUwsIE1VU1RBQ0hFX0VYUFIkMSwgJyAnKTtcbiAgICAgICAgc2VyaWFsaXplZEhUTUwgPSBzdHJpbmdSZXBsYWNlKHNlcmlhbGl6ZWRIVE1MLCBFUkJfRVhQUiQxLCAnICcpO1xuICAgICAgICBzZXJpYWxpemVkSFRNTCA9IHN0cmluZ1JlcGxhY2Uoc2VyaWFsaXplZEhUTUwsIFRNUExJVF9FWFBSJDEsICcgJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVzdGVkVHlwZXNQb2xpY3kgJiYgUkVUVVJOX1RSVVNURURfVFlQRSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKHNlcmlhbGl6ZWRIVE1MKSA6IHNlcmlhbGl6ZWRIVE1MO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVibGljIG1ldGhvZCB0byBzZXQgdGhlIGNvbmZpZ3VyYXRpb24gb25jZVxuICAgICAqIHNldENvbmZpZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAqL1xuXG5cbiAgICBET01QdXJpZnkuc2V0Q29uZmlnID0gZnVuY3Rpb24gKGNmZykge1xuICAgICAgX3BhcnNlQ29uZmlnKGNmZyk7XG5cbiAgICAgIFNFVF9DT05GSUcgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgdGhlIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBjbGVhckNvbmZpZ1xuICAgICAqXG4gICAgICovXG5cblxuICAgIERPTVB1cmlmeS5jbGVhckNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIENPTkZJRyA9IG51bGw7XG4gICAgICBTRVRfQ09ORklHID0gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdWJsaWMgbWV0aG9kIHRvIGNoZWNrIGlmIGFuIGF0dHJpYnV0ZSB2YWx1ZSBpcyB2YWxpZC5cbiAgICAgKiBVc2VzIGxhc3Qgc2V0IGNvbmZpZywgaWYgYW55LiBPdGhlcndpc2UsIHVzZXMgY29uZmlnIGRlZmF1bHRzLlxuICAgICAqIGlzVmFsaWRBdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGFnIFRhZyBuYW1lIG9mIGNvbnRhaW5pbmcgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGF0dHIgQXR0cmlidXRlIG5hbWUuXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQuIE90aGVyd2lzZSwgcmV0dXJucyBmYWxzZS5cbiAgICAgKi9cblxuXG4gICAgRE9NUHVyaWZ5LmlzVmFsaWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodGFnLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgLyogSW5pdGlhbGl6ZSBzaGFyZWQgY29uZmlnIHZhcnMgaWYgbmVjZXNzYXJ5LiAqL1xuICAgICAgaWYgKCFDT05GSUcpIHtcbiAgICAgICAgX3BhcnNlQ29uZmlnKHt9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxjVGFnID0gdHJhbnNmb3JtQ2FzZUZ1bmModGFnKTtcbiAgICAgIHZhciBsY05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhhdHRyKTtcbiAgICAgIHJldHVybiBfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRIb29rXG4gICAgICogUHVibGljIG1ldGhvZCB0byBhZGQgRE9NUHVyaWZ5IGhvb2tzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW50cnlQb2ludCBlbnRyeSBwb2ludCBmb3IgdGhlIGhvb2sgdG8gYWRkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va0Z1bmN0aW9uIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICAgKi9cblxuXG4gICAgRE9NUHVyaWZ5LmFkZEhvb2sgPSBmdW5jdGlvbiAoZW50cnlQb2ludCwgaG9va0Z1bmN0aW9uKSB7XG4gICAgICBpZiAodHlwZW9mIGhvb2tGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGhvb2tzW2VudHJ5UG9pbnRdID0gaG9va3NbZW50cnlQb2ludF0gfHwgW107XG4gICAgICBhcnJheVB1c2goaG9va3NbZW50cnlQb2ludF0sIGhvb2tGdW5jdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVIb29rXG4gICAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgYSBET01QdXJpZnkgaG9vayBhdCBhIGdpdmVuIGVudHJ5UG9pbnRcbiAgICAgKiAocG9wcyBpdCBmcm9tIHRoZSBzdGFjayBvZiBob29rcyBpZiBtb3JlIGFyZSBwcmVzZW50KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVudHJ5UG9pbnQgZW50cnkgcG9pbnQgZm9yIHRoZSBob29rIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZW1vdmVkKHBvcHBlZCkgaG9va1xuICAgICAqL1xuXG5cbiAgICBET01QdXJpZnkucmVtb3ZlSG9vayA9IGZ1bmN0aW9uIChlbnRyeVBvaW50KSB7XG4gICAgICBpZiAoaG9va3NbZW50cnlQb2ludF0pIHtcbiAgICAgICAgcmV0dXJuIGFycmF5UG9wKGhvb2tzW2VudHJ5UG9pbnRdKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZUhvb2tzXG4gICAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgYWxsIERPTVB1cmlmeSBob29rcyBhdCBhIGdpdmVuIGVudHJ5UG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZW50cnlQb2ludCBlbnRyeSBwb2ludCBmb3IgdGhlIGhvb2tzIHRvIHJlbW92ZVxuICAgICAqL1xuXG5cbiAgICBET01QdXJpZnkucmVtb3ZlSG9va3MgPSBmdW5jdGlvbiAoZW50cnlQb2ludCkge1xuICAgICAgaWYgKGhvb2tzW2VudHJ5UG9pbnRdKSB7XG4gICAgICAgIGhvb2tzW2VudHJ5UG9pbnRdID0gW107XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVBbGxIb29rc1xuICAgICAqIFB1YmxpYyBtZXRob2QgdG8gcmVtb3ZlIGFsbCBET01QdXJpZnkgaG9va3NcbiAgICAgKlxuICAgICAqL1xuXG5cbiAgICBET01QdXJpZnkucmVtb3ZlQWxsSG9va3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBob29rcyA9IHt9O1xuICAgIH07XG5cbiAgICByZXR1cm4gRE9NUHVyaWZ5O1xuICB9XG5cbiAgdmFyIHB1cmlmeSA9IGNyZWF0ZURPTVB1cmlmeSgpO1xuXG4gIHJldHVybiBwdXJpZnk7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1cmlmeS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RvbXB1cmlmeS9kaXN0L3B1cmlmeS5qc1xuLy8gbW9kdWxlIGlkID0gMTkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyIsIi8vIGZvY3VzLXRyYXAtcmVhY3QgYnkgZGF2aWR0aGVjbGFyaywgVVJMOiBodHRwczovL2dpdGh1Yi5jb20vZGF2aWR0aGVjbGFyay9mb2N1cy10cmFwLXJlYWN0XG5cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBjcmVhdGVGb2N1c1RyYXAgZnJvbSAnZm9jdXMtdHJhcCc7XG5cbmNsYXNzIEZvY3VzVHJhcCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKVxuXG5cdFx0aWYgKCB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0dGhpcy5wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHRcdH1cblx0fVxuXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdC8vIFdlIG5lZWQgdG8gaGlqYWNrIHRoZSByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSBvcHRpb24sXG5cdFx0Ly8gYmVjYXVzZSBSZWFjdCBjYW4gbW92ZSBmb2N1cyBpbnRvIHRoZSBlbGVtZW50IGJlZm9yZSB3ZSBhcnJpdmVkIGF0XG5cdFx0Ly8gdGhpcyBsaWZlY3ljbGUgaG9vayAoZS5nLiB3aXRoIGF1dG9Gb2N1cyBpbnB1dHMpLiBTbyB0aGUgY29tcG9uZW50XG5cdFx0Ly8gY2FwdHVyZXMgdGhlIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCBpbiBjb21wb25lbnRXaWxsTW91bnQsXG5cdFx0Ly8gdGhlbiAob3B0aW9uYWxseSkgcmV0dXJucyBmb2N1cyB0byBpdCBpbiBjb21wb25lbnRXaWxsVW5tb3VudC5cblx0XHRjb25zdCBzcGVjaWZpZWRGb2N1c1RyYXBPcHRpb25zID0gdGhpcy5wcm9wcy5mb2N1c1RyYXBPcHRpb25zO1xuXG5cdFx0Y29uc3QgdGFpbG9yZWRGb2N1c1RyYXBPcHRpb25zID0ge1xuXHRcdFx0cmV0dXJuRm9jdXNPbkRlYWN0aXZhdGU6IGZhbHNlLFxuXHRcdFx0ZmFsbGJhY2tGb2N1czogJ2JvZHknLFxuXHRcdH07XG5cblx0XHRmb3IgKCBjb25zdCBvcHRpb25OYW1lIGluIHNwZWNpZmllZEZvY3VzVHJhcE9wdGlvbnMgKSB7XG5cdFx0XHRpZiAoICEgc3BlY2lmaWVkRm9jdXNUcmFwT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSggb3B0aW9uTmFtZSApICkgY29udGludWU7XG5cblx0XHRcdGlmICggb3B0aW9uTmFtZSA9PT0gJ3JldHVybkZvY3VzT25EZWFjdGl2YXRlJyApIGNvbnRpbnVlO1xuXG5cdFx0XHR0YWlsb3JlZEZvY3VzVHJhcE9wdGlvbnNbb3B0aW9uTmFtZV0gPSBzcGVjaWZpZWRGb2N1c1RyYXBPcHRpb25zW29wdGlvbk5hbWVdO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZvY3VzVHJhcEVsZW1lbnRET01Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUoIHRoaXMuZm9jdXNUcmFwRWxlbWVudCApO1xuXG5cdFx0dGhpcy5mb2N1c1RyYXAgPSB0aGlzLnByb3BzLl9jcmVhdGVGb2N1c1RyYXAoXG5cdFx0XHRmb2N1c1RyYXBFbGVtZW50RE9NTm9kZSxcblx0XHRcdHRhaWxvcmVkRm9jdXNUcmFwT3B0aW9uc1xuXHRcdCk7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMuYWN0aXZlICkge1xuXHRcdFx0dGhpcy5mb2N1c1RyYXAuYWN0aXZhdGUoKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMucHJvcHMucGF1c2VkICkge1xuXHRcdFx0dGhpcy5mb2N1c1RyYXAucGF1c2UoKTtcblx0XHR9XG5cdH1cblxuXHRjb21wb25lbnREaWRVcGRhdGUoIHByZXZQcm9wcyApIHtcblx0XHRpZiAoIHByZXZQcm9wcy5hY3RpdmUgJiYgIXRoaXMucHJvcHMuYWN0aXZlICkge1xuXHRcdFx0Y29uc3QgeyByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSB9ID0gdGhpcy5wcm9wcy5mb2N1c1RyYXBPcHRpb25zO1xuXHRcdFx0Y29uc3QgcmV0dXJuRm9jdXMgPSByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSB8fCBmYWxzZTtcblx0XHRcdGNvbnN0IGNvbmZpZyA9IHsgcmV0dXJuRm9jdXMgfTtcblx0XHRcdHRoaXMuZm9jdXNUcmFwLmRlYWN0aXZhdGUoIGNvbmZpZyApO1xuXHRcdH0gZWxzZSBpZiAoICEgcHJldlByb3BzLmFjdGl2ZSAmJiB0aGlzLnByb3BzLmFjdGl2ZSApIHtcblx0XHRcdHRoaXMuZm9jdXNUcmFwLmFjdGl2YXRlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCBwcmV2UHJvcHMucGF1c2VkICYmICF0aGlzLnByb3BzLnBhdXNlZCApIHtcblx0XHRcdHRoaXMuZm9jdXNUcmFwLnVucGF1c2UoKTtcblx0XHR9IGVsc2UgaWYgKCAhIHByZXZQcm9wcy5wYXVzZWQgJiYgdGhpcy5wcm9wcy5wYXVzZWQgKSB7XG5cdFx0XHR0aGlzLmZvY3VzVHJhcC5wYXVzZSgpO1xuXHRcdH1cblx0fVxuXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdHRoaXMuZm9jdXNUcmFwLmRlYWN0aXZhdGUoKTtcblx0XHRpZiAoXG5cdFx0XHR0aGlzLnByb3BzLmZvY3VzVHJhcE9wdGlvbnMucmV0dXJuRm9jdXNPbkRlYWN0aXZhdGUgIT09IGZhbHNlICYmXG5cdFx0XHR0aGlzLnByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCAmJlxuXHRcdFx0dGhpcy5wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQuZm9jdXNcblx0XHQpIHtcblx0XHRcdHRoaXMucHJldmlvdXNseUZvY3VzZWRFbGVtZW50LmZvY3VzKCk7XG5cdFx0fVxuXHR9XG5cblx0c2V0Rm9jdXNUcmFwRWxlbWVudCggZWxlbWVudCApIHtcblx0XHR0aGlzLmZvY3VzVHJhcEVsZW1lbnQgPSBlbGVtZW50O1xuXHR9O1xuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjaGlsZCA9IFJlYWN0LkNoaWxkcmVuLm9ubHkoIHRoaXMucHJvcHMuY2hpbGRyZW4gKTtcblxuXHRcdGNvbnN0IGNvbXBvc2VkUmVmQ2FsbGJhY2sgPSBlbGVtZW50ID0+IHtcblx0XHRcdHRoaXMuc2V0Rm9jdXNUcmFwRWxlbWVudCggZWxlbWVudCApO1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBjaGlsZC5yZWYgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdGNoaWxkLnJlZiggZWxlbWVudCApO1xuXHRcdFx0fVxuXHRcdH1cblxuICAgIGNvbnN0IGNoaWxkV2l0aFJlZiA9IFJlYWN0LmNsb25lRWxlbWVudCggY2hpbGQsIHsgcmVmOiBjb21wb3NlZFJlZkNhbGxiYWNrIH0gKTtcblxuXHQgcmV0dXJuIGNoaWxkV2l0aFJlZjtcblx0fVxufVxuXG5Gb2N1c1RyYXAuZGVmYXVsdFByb3BzID0ge1xuXHRhY3RpdmU6IHRydWUsXG5cdHBhdXNlZDogZmFsc2UsXG5cdGZvY3VzVHJhcE9wdGlvbnM6IHt9LFxuXHRfY3JlYXRlRm9jdXNUcmFwOiBjcmVhdGVGb2N1c1RyYXBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRm9jdXNUcmFwO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Zvcm0vY29tcG9uZW50cy9tb2RhbHMvcGFydGlhbHMvZm9jdXMtdHJhcC5qcyIsInZhciB0YWJiYWJsZSA9IHJlcXVpcmUoJ3RhYmJhYmxlJyk7XG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpO1xuXG52YXIgYWN0aXZlRm9jdXNEZWxheTtcblxudmFyIGFjdGl2ZUZvY3VzVHJhcHMgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB0cmFwUXVldWUgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBhY3RpdmF0ZVRyYXA6IGZ1bmN0aW9uKHRyYXApIHtcbiAgICAgIGlmICh0cmFwUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgYWN0aXZlVHJhcCA9IHRyYXBRdWV1ZVt0cmFwUXVldWUubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChhY3RpdmVUcmFwICE9PSB0cmFwKSB7XG4gICAgICAgICAgYWN0aXZlVHJhcC5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmFwSW5kZXggPSB0cmFwUXVldWUuaW5kZXhPZih0cmFwKTtcbiAgICAgIGlmICh0cmFwSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRyYXBRdWV1ZS5wdXNoKHRyYXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbW92ZSB0aGlzIGV4aXN0aW5nIHRyYXAgdG8gdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxuICAgICAgICB0cmFwUXVldWUuc3BsaWNlKHRyYXBJbmRleCwgMSk7XG4gICAgICAgIHRyYXBRdWV1ZS5wdXNoKHRyYXApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZWFjdGl2YXRlVHJhcDogZnVuY3Rpb24odHJhcCkge1xuICAgICAgdmFyIHRyYXBJbmRleCA9IHRyYXBRdWV1ZS5pbmRleE9mKHRyYXApO1xuICAgICAgaWYgKHRyYXBJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdHJhcFF1ZXVlLnNwbGljZSh0cmFwSW5kZXgsIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhcFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJhcFF1ZXVlW3RyYXBRdWV1ZS5sZW5ndGggLSAxXS51bnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSkoKTtcblxuZnVuY3Rpb24gZm9jdXNUcmFwKGVsZW1lbnQsIHVzZXJPcHRpb25zKSB7XG4gIHZhciBkb2MgPSBkb2N1bWVudDtcbiAgdmFyIGNvbnRhaW5lciA9XG4gICAgdHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnID8gZG9jLnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIHZhciBjb25maWcgPSB4dGVuZChcbiAgICB7XG4gICAgICByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZTogdHJ1ZSxcbiAgICAgIGVzY2FwZURlYWN0aXZhdGVzOiB0cnVlXG4gICAgfSxcbiAgICB1c2VyT3B0aW9uc1xuICApO1xuXG4gIHZhciBzdGF0ZSA9IHtcbiAgICBmaXJzdFRhYmJhYmxlTm9kZTogbnVsbCxcbiAgICBsYXN0VGFiYmFibGVOb2RlOiBudWxsLFxuICAgIG5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbjogbnVsbCxcbiAgICBtb3N0UmVjZW50bHlGb2N1c2VkTm9kZTogbnVsbCxcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIHBhdXNlZDogZmFsc2VcbiAgfTtcblxuICB2YXIgdHJhcCA9IHtcbiAgICBhY3RpdmF0ZTogYWN0aXZhdGUsXG4gICAgZGVhY3RpdmF0ZTogZGVhY3RpdmF0ZSxcbiAgICBwYXVzZTogcGF1c2UsXG4gICAgdW5wYXVzZTogdW5wYXVzZVxuICB9O1xuXG4gIHJldHVybiB0cmFwO1xuXG4gIGZ1bmN0aW9uIGFjdGl2YXRlKGFjdGl2YXRlT3B0aW9ucykge1xuICAgIGlmIChzdGF0ZS5hY3RpdmUpIHJldHVybjtcblxuICAgIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcblxuICAgIHN0YXRlLmFjdGl2ZSA9IHRydWU7XG4gICAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gICAgc3RhdGUubm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICB2YXIgb25BY3RpdmF0ZSA9XG4gICAgICBhY3RpdmF0ZU9wdGlvbnMgJiYgYWN0aXZhdGVPcHRpb25zLm9uQWN0aXZhdGVcbiAgICAgICAgPyBhY3RpdmF0ZU9wdGlvbnMub25BY3RpdmF0ZVxuICAgICAgICA6IGNvbmZpZy5vbkFjdGl2YXRlO1xuICAgIGlmIChvbkFjdGl2YXRlKSB7XG4gICAgICBvbkFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgYWRkTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiBkZWFjdGl2YXRlKGRlYWN0aXZhdGVPcHRpb25zKSB7XG4gICAgaWYgKCFzdGF0ZS5hY3RpdmUpIHJldHVybjtcblxuICAgIGNsZWFyVGltZW91dChhY3RpdmVGb2N1c0RlbGF5KTtcblxuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgIHN0YXRlLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuXG4gICAgYWN0aXZlRm9jdXNUcmFwcy5kZWFjdGl2YXRlVHJhcCh0cmFwKTtcblxuICAgIHZhciBvbkRlYWN0aXZhdGUgPVxuICAgICAgZGVhY3RpdmF0ZU9wdGlvbnMgJiYgZGVhY3RpdmF0ZU9wdGlvbnMub25EZWFjdGl2YXRlICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBkZWFjdGl2YXRlT3B0aW9ucy5vbkRlYWN0aXZhdGVcbiAgICAgICAgOiBjb25maWcub25EZWFjdGl2YXRlO1xuICAgIGlmIChvbkRlYWN0aXZhdGUpIHtcbiAgICAgIG9uRGVhY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIHZhciByZXR1cm5Gb2N1cyA9XG4gICAgICBkZWFjdGl2YXRlT3B0aW9ucyAmJiBkZWFjdGl2YXRlT3B0aW9ucy5yZXR1cm5Gb2N1cyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gZGVhY3RpdmF0ZU9wdGlvbnMucmV0dXJuRm9jdXNcbiAgICAgICAgOiBjb25maWcucmV0dXJuRm9jdXNPbkRlYWN0aXZhdGU7XG4gICAgaWYgKHJldHVybkZvY3VzKSB7XG4gICAgICBkZWxheShmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5Rm9jdXMoZ2V0UmV0dXJuRm9jdXNOb2RlKHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbikpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBpZiAoc3RhdGUucGF1c2VkIHx8ICFzdGF0ZS5hY3RpdmUpIHJldHVybjtcbiAgICBzdGF0ZS5wYXVzZWQgPSB0cnVlO1xuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5wYXVzZSgpIHtcbiAgICBpZiAoIXN0YXRlLnBhdXNlZCB8fCAhc3RhdGUuYWN0aXZlKSByZXR1cm47XG4gICAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgIGFkZExpc3RlbmVycygpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuICAgIGlmICghc3RhdGUuYWN0aXZlKSByZXR1cm47XG5cbiAgICAvLyBUaGVyZSBjYW4gYmUgb25seSBvbmUgbGlzdGVuaW5nIGZvY3VzIHRyYXAgYXQgYSB0aW1lXG4gICAgYWN0aXZlRm9jdXNUcmFwcy5hY3RpdmF0ZVRyYXAodHJhcCk7XG5cbiAgICAvLyBEZWxheSBlbnN1cmVzIHRoYXQgdGhlIGZvY3VzZWQgZWxlbWVudCBkb2Vzbid0IGNhcHR1cmUgdGhlIGV2ZW50XG4gICAgLy8gdGhhdCBjYXVzZWQgdGhlIGZvY3VzIHRyYXAgYWN0aXZhdGlvbi5cbiAgICBhY3RpdmVGb2N1c0RlbGF5ID0gZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICB0cnlGb2N1cyhnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgIH0pO1xuXG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBjaGVja0ZvY3VzSW4sIHRydWUpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBjaGVja1BvaW50ZXJEb3duLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGNoZWNrUG9pbnRlckRvd24sIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNoZWNrQ2xpY2ssIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgY2hlY2tLZXksIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKCFzdGF0ZS5hY3RpdmUpIHJldHVybjtcblxuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgY2hlY2tGb2N1c0luLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjaGVja0NsaWNrLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNoZWNrS2V5LCB0cnVlKTtcblxuICAgIHJldHVybiB0cmFwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Tm9kZUZvck9wdGlvbihvcHRpb25OYW1lKSB7XG4gICAgdmFyIG9wdGlvblZhbHVlID0gY29uZmlnW29wdGlvbk5hbWVdO1xuICAgIHZhciBub2RlID0gb3B0aW9uVmFsdWU7XG4gICAgaWYgKCFvcHRpb25WYWx1ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBub2RlID0gZG9jLnF1ZXJ5U2VsZWN0b3Iob3B0aW9uVmFsdWUpO1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYCcgKyBvcHRpb25OYW1lICsgJ2AgcmVmZXJzIHRvIG5vIGtub3duIG5vZGUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbm9kZSA9IG9wdGlvblZhbHVlKCk7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgJyArIG9wdGlvbk5hbWUgKyAnYCBkaWQgbm90IHJldHVybiBhIG5vZGUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbml0aWFsRm9jdXNOb2RlKCkge1xuICAgIHZhciBub2RlO1xuICAgIGlmIChnZXROb2RlRm9yT3B0aW9uKCdpbml0aWFsRm9jdXMnKSAhPT0gbnVsbCkge1xuICAgICAgbm9kZSA9IGdldE5vZGVGb3JPcHRpb24oJ2luaXRpYWxGb2N1cycpO1xuICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLmNvbnRhaW5zKGRvYy5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgbm9kZSA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gc3RhdGUuZmlyc3RUYWJiYWJsZU5vZGUgfHwgZ2V0Tm9kZUZvck9wdGlvbignZmFsbGJhY2tGb2N1cycpO1xuICAgIH1cblxuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnWW91ciBmb2N1cy10cmFwIG5lZWRzIHRvIGhhdmUgYXQgbGVhc3Qgb25lIGZvY3VzYWJsZSBlbGVtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJldHVybkZvY3VzTm9kZShwcmV2aW91c0FjdGl2ZUVsZW1lbnQpIHtcbiAgICB2YXIgbm9kZSA9IGdldE5vZGVGb3JPcHRpb24oJ3NldFJldHVybkZvY3VzJyk7XG4gICAgcmV0dXJuIG5vZGUgPyBub2RlIDogcHJldmlvdXNBY3RpdmVFbGVtZW50O1xuICB9XG5cbiAgLy8gVGhpcyBuZWVkcyB0byBiZSBkb25lIG9uIG1vdXNlZG93biBhbmQgdG91Y2hzdGFydCBpbnN0ZWFkIG9mIGNsaWNrXG4gIC8vIHNvIHRoYXQgaXQgcHJlY2VkZXMgdGhlIGZvY3VzIGV2ZW50LlxuICBmdW5jdGlvbiBjaGVja1BvaW50ZXJEb3duKGUpIHtcbiAgICBpZiAoY29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgIGlmIChjb25maWcuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMpIHtcbiAgICAgIGRlYWN0aXZhdGUoe1xuICAgICAgICByZXR1cm5Gb2N1czogIXRhYmJhYmxlLmlzRm9jdXNhYmxlKGUudGFyZ2V0KVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgbmVlZGVkIGZvciBtb2JpbGUgZGV2aWNlcy5cbiAgICAvLyAoSWYgd2UnbGwgb25seSBsZXQgYGNsaWNrYCBldmVudHMgdGhyb3VnaCxcbiAgICAvLyB0aGVuIG9uIG1vYmlsZSB0aGV5IHdpbGwgYmUgYmxvY2tlZCBhbnl3YXlzIGlmIGB0b3VjaHN0YXJ0YCBpcyBibG9ja2VkLilcbiAgICBpZiAoY29uZmlnLmFsbG93T3V0c2lkZUNsaWNrICYmIGNvbmZpZy5hbGxvd091dHNpZGVDbGljayhlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICAvLyBJbiBjYXNlIGZvY3VzIGVzY2FwZXMgdGhlIHRyYXAgZm9yIHNvbWUgc3RyYW5nZSByZWFzb24sIHB1bGwgaXQgYmFjayBpbi5cbiAgZnVuY3Rpb24gY2hlY2tGb2N1c0luKGUpIHtcbiAgICAvLyBJbiBGaXJlZm94IHdoZW4geW91IFRhYiBvdXQgb2YgYW4gaWZyYW1lIHRoZSBEb2N1bWVudCBpcyBicmllZmx5IGZvY3VzZWQuXG4gICAgaWYgKGNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkgfHwgZS50YXJnZXQgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIHRyeUZvY3VzKHN0YXRlLm1vc3RSZWNlbnRseUZvY3VzZWROb2RlIHx8IGdldEluaXRpYWxGb2N1c05vZGUoKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0tleShlKSB7XG4gICAgaWYgKGNvbmZpZy5lc2NhcGVEZWFjdGl2YXRlcyAhPT0gZmFsc2UgJiYgaXNFc2NhcGVFdmVudChlKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZGVhY3RpdmF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNUYWJFdmVudChlKSkge1xuICAgICAgY2hlY2tUYWIoZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLy8gSGlqYWNrIFRhYiBldmVudHMgb24gdGhlIGZpcnN0IGFuZCBsYXN0IGZvY3VzYWJsZSBub2RlcyBvZiB0aGUgdHJhcCxcbiAgLy8gaW4gb3JkZXIgdG8gcHJldmVudCBmb2N1cyBmcm9tIGVzY2FwaW5nLiBJZiBpdCBlc2NhcGVzIGZvciBldmVuIGFcbiAgLy8gbW9tZW50IGl0IGNhbiBlbmQgdXAgc2Nyb2xsaW5nIHRoZSBwYWdlIGFuZCBjYXVzaW5nIGNvbmZ1c2lvbiBzbyB3ZVxuICAvLyBraW5kIG9mIG5lZWQgdG8gY2FwdHVyZSB0aGUgYWN0aW9uIGF0IHRoZSBrZXlkb3duIHBoYXNlLlxuICBmdW5jdGlvbiBjaGVja1RhYihlKSB7XG4gICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgIGlmIChlLnNoaWZ0S2V5ICYmIGUudGFyZ2V0ID09PSBzdGF0ZS5maXJzdFRhYmJhYmxlTm9kZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdHJ5Rm9jdXMoc3RhdGUubGFzdFRhYmJhYmxlTm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZS5zaGlmdEtleSAmJiBlLnRhcmdldCA9PT0gc3RhdGUubGFzdFRhYmJhYmxlTm9kZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdHJ5Rm9jdXMoc3RhdGUuZmlyc3RUYWJiYWJsZU5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrQ2xpY2soZSkge1xuICAgIGlmIChjb25maWcuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMpIHJldHVybjtcbiAgICBpZiAoY29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgIGlmIChjb25maWcuYWxsb3dPdXRzaWRlQ2xpY2sgJiYgY29uZmlnLmFsbG93T3V0c2lkZUNsaWNrKGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGFiYmFibGVOb2RlcygpIHtcbiAgICB2YXIgdGFiYmFibGVOb2RlcyA9IHRhYmJhYmxlKGNvbnRhaW5lcik7XG4gICAgc3RhdGUuZmlyc3RUYWJiYWJsZU5vZGUgPSB0YWJiYWJsZU5vZGVzWzBdIHx8IGdldEluaXRpYWxGb2N1c05vZGUoKTtcbiAgICBzdGF0ZS5sYXN0VGFiYmFibGVOb2RlID1cbiAgICAgIHRhYmJhYmxlTm9kZXNbdGFiYmFibGVOb2Rlcy5sZW5ndGggLSAxXSB8fCBnZXRJbml0aWFsRm9jdXNOb2RlKCk7XG4gIH1cblxuICBmdW5jdGlvbiB0cnlGb2N1cyhub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm47XG4gICAgaWYgKCFub2RlIHx8ICFub2RlLmZvY3VzKSB7XG4gICAgICB0cnlGb2N1cyhnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBub2RlLmZvY3VzKCk7XG4gICAgc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUgPSBub2RlO1xuICAgIGlmIChpc1NlbGVjdGFibGVJbnB1dChub2RlKSkge1xuICAgICAgbm9kZS5zZWxlY3QoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTZWxlY3RhYmxlSW5wdXQobm9kZSkge1xuICByZXR1cm4gKFxuICAgIG5vZGUudGFnTmFtZSAmJlxuICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmXG4gICAgdHlwZW9mIG5vZGUuc2VsZWN0ID09PSAnZnVuY3Rpb24nXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzRXNjYXBlRXZlbnQoZSkge1xuICByZXR1cm4gZS5rZXkgPT09ICdFc2NhcGUnIHx8IGUua2V5ID09PSAnRXNjJyB8fCBlLmtleUNvZGUgPT09IDI3O1xufVxuXG5mdW5jdGlvbiBpc1RhYkV2ZW50KGUpIHtcbiAgcmV0dXJuIGUua2V5ID09PSAnVGFiJyB8fCBlLmtleUNvZGUgPT09IDk7XG59XG5cbmZ1bmN0aW9uIGRlbGF5KGZuKSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZuLCAwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c1RyYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mb2N1cy10cmFwL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIiwidmFyIGNhbmRpZGF0ZVNlbGVjdG9ycyA9IFtcbiAgJ2lucHV0JyxcbiAgJ3NlbGVjdCcsXG4gICd0ZXh0YXJlYScsXG4gICdhW2hyZWZdJyxcbiAgJ2J1dHRvbicsXG4gICdbdGFiaW5kZXhdJyxcbiAgJ2F1ZGlvW2NvbnRyb2xzXScsXG4gICd2aWRlb1tjb250cm9sc10nLFxuICAnW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSknLFxuXTtcbnZhciBjYW5kaWRhdGVTZWxlY3RvciA9IGNhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKCcsJyk7XG5cbnZhciBtYXRjaGVzID0gdHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnXG4gID8gZnVuY3Rpb24gKCkge31cbiAgOiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcblxuZnVuY3Rpb24gdGFiYmFibGUoZWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHJlZ3VsYXJUYWJiYWJsZXMgPSBbXTtcbiAgdmFyIG9yZGVyZWRUYWJiYWJsZXMgPSBbXTtcblxuICB2YXIgY2FuZGlkYXRlcyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoY2FuZGlkYXRlU2VsZWN0b3IpO1xuXG4gIGlmIChvcHRpb25zLmluY2x1ZGVDb250YWluZXIpIHtcbiAgICBpZiAobWF0Y2hlcy5jYWxsKGVsLCBjYW5kaWRhdGVTZWxlY3RvcikpIHtcbiAgICAgIGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoY2FuZGlkYXRlcyk7XG4gICAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZVRhYmluZGV4O1xuICBmb3IgKGkgPSAwOyBpIDwgY2FuZGlkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbaV07XG5cbiAgICBpZiAoIWlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShjYW5kaWRhdGUpKSBjb250aW51ZTtcblxuICAgIGNhbmRpZGF0ZVRhYmluZGV4ID0gZ2V0VGFiaW5kZXgoY2FuZGlkYXRlKTtcbiAgICBpZiAoY2FuZGlkYXRlVGFiaW5kZXggPT09IDApIHtcbiAgICAgIHJlZ3VsYXJUYWJiYWJsZXMucHVzaChjYW5kaWRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmRlcmVkVGFiYmFibGVzLnB1c2goe1xuICAgICAgICBkb2N1bWVudE9yZGVyOiBpLFxuICAgICAgICB0YWJJbmRleDogY2FuZGlkYXRlVGFiaW5kZXgsXG4gICAgICAgIG5vZGU6IGNhbmRpZGF0ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0YWJiYWJsZU5vZGVzID0gb3JkZXJlZFRhYmJhYmxlc1xuICAgIC5zb3J0KHNvcnRPcmRlcmVkVGFiYmFibGVzKVxuICAgIC5tYXAoZnVuY3Rpb24oYSkgeyByZXR1cm4gYS5ub2RlIH0pXG4gICAgLmNvbmNhdChyZWd1bGFyVGFiYmFibGVzKTtcblxuICByZXR1cm4gdGFiYmFibGVOb2Rlcztcbn1cblxudGFiYmFibGUuaXNUYWJiYWJsZSA9IGlzVGFiYmFibGU7XG50YWJiYWJsZS5pc0ZvY3VzYWJsZSA9IGlzRm9jdXNhYmxlO1xuXG5mdW5jdGlvbiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUobm9kZSkge1xuICBpZiAoXG4gICAgIWlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUobm9kZSlcbiAgICB8fCBpc05vblRhYmJhYmxlUmFkaW8obm9kZSlcbiAgICB8fCBnZXRUYWJpbmRleChub2RlKSA8IDBcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1RhYmJhYmxlKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCBjYW5kaWRhdGVTZWxlY3RvcikgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUobm9kZSkge1xuICBpZiAoXG4gICAgbm9kZS5kaXNhYmxlZFxuICAgIHx8IGlzSGlkZGVuSW5wdXQobm9kZSlcbiAgICB8fCBpc0hpZGRlbihub2RlKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvciA9IGNhbmRpZGF0ZVNlbGVjdG9ycy5jb25jYXQoJ2lmcmFtZScpLmpvaW4oJywnKTtcbmZ1bmN0aW9uIGlzRm9jdXNhYmxlKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCBmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvcikgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBnZXRUYWJpbmRleChub2RlKSB7XG4gIHZhciB0YWJpbmRleEF0dHIgPSBwYXJzZUludChub2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApO1xuICBpZiAoIWlzTmFOKHRhYmluZGV4QXR0cikpIHJldHVybiB0YWJpbmRleEF0dHI7XG4gIC8vIEJyb3dzZXJzIGRvIG5vdCByZXR1cm4gYHRhYkluZGV4YCBjb3JyZWN0bHkgZm9yIGNvbnRlbnRFZGl0YWJsZSBub2RlcztcbiAgLy8gc28gaWYgdGhleSBkb24ndCBoYXZlIGEgdGFiaW5kZXggYXR0cmlidXRlIHNwZWNpZmljYWxseSBzZXQsIGFzc3VtZSBpdCdzIDAuXG4gIGlmIChpc0NvbnRlbnRFZGl0YWJsZShub2RlKSkgcmV0dXJuIDA7XG4gIHJldHVybiBub2RlLnRhYkluZGV4O1xufVxuXG5mdW5jdGlvbiBzb3J0T3JkZXJlZFRhYmJhYmxlcyhhLCBiKSB7XG4gIHJldHVybiBhLnRhYkluZGV4ID09PSBiLnRhYkluZGV4ID8gYS5kb2N1bWVudE9yZGVyIC0gYi5kb2N1bWVudE9yZGVyIDogYS50YWJJbmRleCAtIGIudGFiSW5kZXg7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGVudEVkaXRhYmxlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZSc7XG59XG5cbmZ1bmN0aW9uIGlzSW5wdXQobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnSU5QVVQnO1xufVxuXG5mdW5jdGlvbiBpc0hpZGRlbklucHV0KG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAnaGlkZGVuJztcbn1cblxuZnVuY3Rpb24gaXNSYWRpbyhub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ3JhZGlvJztcbn1cblxuZnVuY3Rpb24gaXNOb25UYWJiYWJsZVJhZGlvKG5vZGUpIHtcbiAgcmV0dXJuIGlzUmFkaW8obm9kZSkgJiYgIWlzVGFiYmFibGVSYWRpbyhub2RlKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hlY2tlZFJhZGlvKG5vZGVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobm9kZXNbaV0uY2hlY2tlZCkge1xuICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1RhYmJhYmxlUmFkaW8obm9kZSkge1xuICBpZiAoIW5vZGUubmFtZSkgcmV0dXJuIHRydWU7XG4gIC8vIFRoaXMgd29uJ3QgYWNjb3VudCBmb3IgdGhlIGVkZ2UgY2FzZSB3aGVyZSB5b3UgaGF2ZSByYWRpbyBncm91cHMgd2l0aCB0aGUgc2FtZVxuICAvLyBpbiBzZXBhcmF0ZSBmb3JtcyBvbiB0aGUgc2FtZSBwYWdlLlxuICB2YXIgcmFkaW9TZXQgPSBub2RlLm93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCInICsgbm9kZS5uYW1lICsgJ1wiXScpO1xuICB2YXIgY2hlY2tlZCA9IGdldENoZWNrZWRSYWRpbyhyYWRpb1NldCk7XG4gIHJldHVybiAhY2hlY2tlZCB8fCBjaGVja2VkID09PSBub2RlO1xufVxuXG5mdW5jdGlvbiBpc0hpZGRlbihub2RlKSB7XG4gIC8vIG9mZnNldFBhcmVudCBiZWluZyBudWxsIHdpbGwgYWxsb3cgZGV0ZWN0aW5nIGNhc2VzIHdoZXJlIGFuIGVsZW1lbnQgaXMgaW52aXNpYmxlIG9yIGluc2lkZSBhbiBpbnZpc2libGUgZWxlbWVudCxcbiAgLy8gYXMgbG9uZyBhcyB0aGUgZWxlbWVudCBkb2VzIG5vdCB1c2UgcG9zaXRpb246IGZpeGVkLiBGb3IgdGhlbSwgdGhlaXIgdmlzaWJpbGl0eSBoYXMgdG8gYmUgY2hlY2tlZCBkaXJlY3RseSBhcyB3ZWxsLlxuICByZXR1cm4gbm9kZS5vZmZzZXRQYXJlbnQgPT09IG51bGwgfHwgZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS52aXNpYmlsaXR5ID09PSAnaGlkZGVuJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0YWJiYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RhYmJhYmxlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyIsIi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbmltcG9ydCBGb3JtaW5hdG9ySW50ZWdyYXRpb25zIGZyb20gJy4vaW50ZWdyYXRpb25zJzsgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkTG9jYWxTeW1ib2xzXG5cbi8vIHRoZSBzZW1pLWNvbG9uIGJlZm9yZSBmdW5jdGlvbiBpbnZvY2F0aW9uIGlzIGEgc2FmZXR5IG5ldCBhZ2FpbnN0IGNvbmNhdGVuYXRlZFxuLy8gc2NyaXB0cyBhbmQvb3Igb3RoZXIgcGx1Z2lucyB3aGljaCBtYXkgbm90IGJlIGNsb3NlZCBwcm9wZXJseS5cbiggZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcblx0Ly8gQ3JlYXRlIHRoZSBkZWZhdWx0cyBvbmNlXG5cdGNvbnN0IHBsdWdpbk5hbWUgPSAnRm9ybWluYXRvckludGVncmF0aW9uc01vZGFsJztcblx0Y29uc3QgZGVmYXVsdHMgPSB7XG5cdFx0dHlwZTogJ2Zvcm0nLFxuXHR9O1xuXG5cdGZ1bmN0aW9uIEZvcm1pbmF0b3JJbnRlZ3JhdGlvbnNNb2RhbCggYWRkb25zLCBvcHRpb25zICkge1xuXHRcdHRoaXMuJHBvcHVwID0ge307XG5cdFx0dGhpcy5fZGVmZXJyZWQgPSB7fTtcblx0XHR0aGlzLmVsID0gYWRkb25zO1xuXHRcdHRoaXMuJGVsID0galF1ZXJ5KCB0aGlzLmVsICk7XG5cdFx0dGhpcy5vcHRpb25zID0gXy5leHRlbmQoIGRlZmF1bHRzLCBvcHRpb25zICk7XG5cdFx0dGhpcy5pbml0KCk7XG5cdH1cblxuXHQvLyBBdm9pZCBQbHVnaW4ucHJvdG90eXBlIGNvbmZsaWN0c1xuXHRqUXVlcnkuZXh0ZW5kKCBGb3JtaW5hdG9ySW50ZWdyYXRpb25zTW9kYWwucHJvdG90eXBlLCB7XG5cdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zdCBtZSA9IHRoaXM7XG5cblx0XHRcdHRoaXMuJGVsLmZpbmQoICcuY29ubmVjdC1pbnRlZ3JhdGlvbicgKS5vbiggJ2NsaWNrJywgZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRcdG1lLm9wZW4oIGUgKTtcblx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0b3BlbjogZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRjb25zdCBzZWxmID0gdGhpcztcblxuXHRcdFx0Ly8gUmVtb3ZlIHBvcHVwXG5cdFx0XHRqUXVlcnkoICcjZm9ybWluYXRvci1pbnRlZ3JhdGlvbi1wb3B1cCcgKS5yZW1vdmUoKTtcblxuXHRcdFx0bGV0ICR0YXJnZXQgPSBqUXVlcnkoIGUudGFyZ2V0ICk7XG5cblx0XHRcdGlmICggISAkdGFyZ2V0Lmhhc0NsYXNzKCAnY29ubmVjdC1pbnRlZ3JhdGlvbicgKSApIHtcblx0XHRcdFx0JHRhcmdldCA9ICR0YXJnZXQuY2xvc2VzdCggJy5jb25uZWN0LWludGVncmF0aW9uJyApO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjbG9zZUNsaWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3Qgbm9uY2UgPSAkdGFyZ2V0LmRhdGEoICdub25jZScgKSxcblx0XHRcdFx0c2x1ZyA9ICR0YXJnZXQuZGF0YSggJ3NsdWcnICksXG5cdFx0XHRcdGdsb2JhbF9pZCA9ICR0YXJnZXQuZGF0YSggJ211bHRpLWdsb2JhbC1pZCcgKSxcblx0XHRcdFx0dGl0bGUgPSAkdGFyZ2V0LmRhdGEoICd0aXRsZScgKSxcblx0XHRcdFx0aW1hZ2UgPSAkdGFyZ2V0LmRhdGEoICdpbWFnZScgKSxcblx0XHRcdFx0aW1hZ2UyeCA9ICR0YXJnZXQuZGF0YSggJ2ltYWdleDInICksXG5cdFx0XHRcdGFjdGlvbiA9ICR0YXJnZXQuZGF0YSggJ2FjdGlvbicgKSxcblx0XHRcdFx0Zm9ybV9pZCA9ICR0YXJnZXQuZGF0YSggJ2Zvcm0taWQnICksXG5cdFx0XHRcdG11bHRpX2lkID0gJHRhcmdldC5kYXRhKCAnbXVsdGktaWQnICksXG5cdFx0XHRcdHBvbGxfaWQgPSAkdGFyZ2V0LmRhdGEoICdwb2xsLWlkJyApLFxuXHRcdFx0XHRxdWl6X2lkID0gJHRhcmdldC5kYXRhKCAncXVpei1pZCcgKTtcblxuXHRcdFx0Y29uc3QgdHBsID0gXy50ZW1wbGF0ZShcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCJzdWktbW9kYWwgc3VpLW1vZGFsLWxnXCI+JyArXG5cdFx0XHRcdFx0Ly8gTW9kYWwgY29udGVudC5cblx0XHRcdFx0XHQnPGRpdiByb2xlPVwiZGlhbG9nXCIgaWQ9XCJmb3JtaW5hdG9yLWludGVncmF0aW9uLXBvcHVwXCIgY2xhc3M9XCJzdWktbW9kYWwtY29udGVudFwiIGFyaWEtbW9kYWw9XCJ0cnVlXCIgYXJpYS1sYWJlbGxlZGJ5PVwiZm9ybWluYXRvci1pbnRlZ3JhdGlvbi1wb3B1cF9fdGl0bGVcIiBhcmlhLWRlc2NyaWJlZGJ5PVwiZm9ybWluYXRvci1pbnRlZ3JhdGlvbi1wb3B1cF9fZGVzY3JpcHRpb25cIj4nICtcblx0XHRcdFx0XHRcdC8vIEJveC5cblx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwic3VpLWJveFwiIHN0eWxlPVwibWFyZ2luLWJvdHRvbTogMDtcIj4nICtcblx0XHRcdFx0XHRcdFx0Ly8gQm94IEhlYWRlci5cblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJzdWktYm94LWhlYWRlciBzdWktZmxhdHRlbiBzdWktY29udGVudC1jZW50ZXIgc3VpLXNwYWNpbmctdG9wLS02MFwiPicgK1xuXHRcdFx0XHRcdFx0XHRcdC8vIEJ1dHRvbiBcIkNsb3NlXCIuXG5cdFx0XHRcdFx0XHRcdFx0JzxidXR0b24gY2xhc3M9XCJzdWktYnV0dG9uLWljb24gc3VpLWJ1dHRvbi1mbG9hdC0tcmlnaHQgZm9ybWluYXRvci1wb3B1cC1jbG9zZVwiPicgK1xuXHRcdFx0XHRcdFx0XHRcdFx0JzxzcGFuIGNsYXNzPVwic3VpLWljb24tY2xvc2Ugc3VpLW1kXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPicgK1xuXHRcdFx0XHRcdFx0XHRcdFx0JzxzcGFuIGNsYXNzPVwic3VpLXNjcmVlbi1yZWFkZXItdGV4dFwiPkNsb3NlPC9zcGFuPicgK1xuXHRcdFx0XHRcdFx0XHRcdCc8L2J1dHRvbj4nICtcblx0XHRcdFx0XHRcdFx0XHQvLyBCdXR0b24gXCJCYWNrXCIuXG5cdFx0XHRcdFx0XHRcdFx0JzxidXR0b24gY2xhc3M9XCJzdWktYnV0dG9uLWljb24gc3VpLWJ1dHRvbi1mbG9hdC0tbGVmdCBmb3JtaW5hdG9yLWFkZG9uLWJhY2tcIj4nICtcblx0XHRcdFx0XHRcdFx0XHRcdCc8c3BhbiBjbGFzcz1cInN1aS1pY29uLWNoZXZyb24tbGVmdCBzdWktbWRcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+JyArXG5cdFx0XHRcdFx0XHRcdFx0XHQnPHNwYW4gY2xhc3M9XCJzdWktc2NyZWVuLXJlYWRlci10ZXh0XCI+QmFjazwvc3Bhbj4nICtcblx0XHRcdFx0XHRcdFx0XHQnPC9idXR0b24+JyArXG5cdFx0XHRcdFx0XHRcdFx0Ly8gTG9nby5cblx0XHRcdFx0XHRcdFx0XHQnPGZpZ3VyZSBjbGFzcz1cInN1aS1ib3gtbG9nb1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPicgK1xuXHRcdFx0XHRcdFx0XHRcdFx0JzxpbWcgc3JjPVwiPCU9IGltYWdlICU+XCIgc3Jjc2V0PVwiPCU9IGltYWdlICU+IDF4LCA8JT0gaW1hZ2UyeCAlPiAyeFwiIGFsdD1cIjwlPSB0aXRsZSAlPlwiIC8+JyArXG5cdFx0XHRcdFx0XHRcdFx0JzwvZmlndXJlPicgK1xuXHRcdFx0XHRcdFx0XHRcdC8vIEhlYWRlciBjb250ZW50LlxuXHRcdFx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZm9ybWluYXRvci1pbnRlZ3JhdGlvbi1wb3B1cF9faGVhZGVyXCI+PC9kaXY+JyArXG5cdFx0XHRcdFx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdFx0XHRcdFx0Ly8gQm94IEJvZHkuXG5cdFx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwic3VpLWJveC1ib2R5XCI+PC9kaXY+JyArXG5cdFx0XHRcdFx0XHRcdC8vIEJveCBGb290ZXIuXG5cdFx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwic3VpLWJveC1mb290ZXIgc3VpLWZsYXR0ZW4gc3VpLWNvbnRlbnQtY2VudGVyXCI+PC9kaXY+JyArXG5cdFx0XHRcdFx0XHQnPC9kaXY+JyArXG5cdFx0XHRcdFx0JzwvZGl2PicgK1xuXHRcdFx0XHQnPC9kaXY+J1xuXHRcdFx0KTtcblxuXHRcdFx0alF1ZXJ5KCAnbWFpbi5zdWktd3JhcCcgKS5hcHBlbmQoXG5cdFx0XHRcdHRwbCgge1xuXHRcdFx0XHRcdGltYWdlOiBpbWFnZSxcblx0XHRcdFx0XHRpbWFnZTJ4OiBpbWFnZTJ4LFxuXHRcdFx0XHRcdHRpdGxlOiB0aXRsZSxcblx0XHRcdFx0fSApXG5cdFx0XHQpO1xuXG5cdFx0XHR0aGlzLiRwb3B1cCA9IGpRdWVyeSggJyNmb3JtaW5hdG9yLWludGVncmF0aW9uLXBvcHVwJyApO1xuXG5cdFx0XHRjb25zdCB2aWV3T3B0aW9ucyA9IHtcblx0XHRcdFx0c2x1Zzogc2x1Zyxcblx0XHRcdFx0bm9uY2U6IG5vbmNlLFxuXHRcdFx0XHRhY3Rpb246IGFjdGlvbixcblx0XHRcdFx0bXVsdGlfaWQ6IG11bHRpX2lkLFxuXHRcdFx0XHRnbG9iYWxfaWQ6IGdsb2JhbF9pZCxcblx0XHRcdFx0ZWw6IHRoaXMuJHBvcHVwLFxuXHRcdFx0XHR0eXBlOiBzZWxmLm9wdGlvbnMudHlwZSxcblx0XHRcdH07XG5cblx0XHRcdGlmICggc2VsZi5vcHRpb25zLnR5cGUgPT09ICdmb3JtJyApIHtcblx0XHRcdFx0dmlld09wdGlvbnMuZm9ybV9pZCA9IGZvcm1faWQ7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWxmLm9wdGlvbnMudHlwZSA9PT0gJ3BvbGwnICkge1xuXHRcdFx0XHR2aWV3T3B0aW9ucy5wb2xsX2lkID0gcG9sbF9pZDtcblx0XHRcdH0gZWxzZSBpZiAoIHNlbGYub3B0aW9ucy50eXBlID09PSAncXVpeicgKSB7XG5cdFx0XHRcdHZpZXdPcHRpb25zLnF1aXpfaWQgPSBxdWl6X2lkO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB2aWV3ID0gbmV3IEZvcm1pbmF0b3JJbnRlZ3JhdGlvbnMoIHZpZXdPcHRpb25zICk7XG5cblx0XHRcdHZpZXcub24oICdtb2RhbDpjbG9zZWQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5jbG9zZSgpO1xuXHRcdFx0fSApO1xuXG5cdFx0XHR0aGlzLiRwb3B1cC5maW5kKCAnLmZvcm1pbmF0b3ItcG9wdXAtYWN0aW9uJyApLnJlbW92ZSgpO1xuXG5cdFx0XHQvLyBBZGQgY2xvc2luZyBldmVudFxuXHRcdFx0dGhpcy4kcG9wdXAuZmluZCggJy5mb3JtaW5hdG9yLXBvcHVwLWNsb3NlJyApLm9uKCAnY2xpY2snLCBjbG9zZUNsaWNrICk7XG5cdFx0XHR0aGlzLiRwb3B1cC5vbiggJ2NsaWNrJywgJy5mb3JtaW5hdG9yLXBvcHVwLWNhbmNlbCcsIGNsb3NlQ2xpY2sgKTtcblxuXHRcdFx0Ly8gb3BlblxuXHRcdFx0U1VJLm9wZW5Nb2RhbChcblx0XHRcdFx0J2Zvcm1pbmF0b3ItaW50ZWdyYXRpb24tcG9wdXAnLFxuXHRcdFx0XHQnZm9ybWluYXRvci1mb3JtLWFwcGVhcmFuY2UnLFxuXHRcdFx0XHR1bmRlZmluZWQsXG5cdFx0XHRcdHRydWUsXG5cdFx0XHRcdHRydWVcblx0XHRcdCk7XG5cblx0XHRcdHRoaXMuX2RlZmVycmVkID0gbmV3IGpRdWVyeS5EZWZlcnJlZCgpO1xuXHRcdFx0cmV0dXJuIHRoaXMuX2RlZmVycmVkLnByb21pc2UoKTtcblx0XHR9LFxuXG5cdFx0Y2xvc2U6IGZ1bmN0aW9uKCByZXN1bHQgKSB7XG5cdFx0XHRTVUkuY2xvc2VNb2RhbCgpO1xuXHRcdFx0dGhpcy4kZWwudHJpZ2dlciggJ3JlbG9hZCcgKTtcblx0XHRcdHRoaXMuX2RlZmVycmVkLnJlc29sdmUoIHRoaXMuJHBvcHVwLCByZXN1bHQgKTtcblx0XHR9LFxuXHR9ICk7XG5cblx0Ly8gQSByZWFsbHkgbGlnaHR3ZWlnaHQgcGx1Z2luIHdyYXBwZXIgYXJvdW5kIHRoZSBjb25zdHJ1Y3Rvcixcblx0Ly8gcHJldmVudGluZyBhZ2FpbnN0IG11bHRpcGxlIGluc3RhbnRpYXRpb25zXG5cdGpRdWVyeS5mblsgcGx1Z2luTmFtZSBdID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3XG5cdFx0XHRuZXcgRm9ybWluYXRvckludGVncmF0aW9uc01vZGFsKCB0aGlzLCBvcHRpb25zICk7XG5cdFx0fSApO1xuXHR9O1xufSApKCBqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQgKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9saWIvaW50ZWdyYXRpb25zLW1vZGFsLmpzIiwiaW1wb3J0IE5vdGlmaWNhdGlvbiBmcm9tICcuLi9ub3RpZmljYXRpb25zJztcbmltcG9ydCB7IHN1aURlbGVnYXRlRXZlbnRzLCBzZWxlY3QyVGFncyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9ybWluYXRvckludGVncmF0aW9ucyBleHRlbmRzIEJhY2tib25lLlZpZXcge1xuXHRjb25zdHJ1Y3Rvciggb3B0aW9ucyApIHtcblx0XHRzdXBlcigge1xuXHRcdFx0ZWw6IG9wdGlvbnMuZWwsXG5cblx0XHRcdHRhZ05hbWU6ICdkaXYnLFxuXG5cdFx0XHRldmVudHM6IHtcblx0XHRcdFx0J2NsaWNrIC5mb3JtaW5hdG9yLWFkZG9uLWNvbm5lY3QnOiAnY29ubmVjdEFkZG9uJyxcblx0XHRcdFx0J2NsaWNrIC5mb3JtaW5hdG9yLWFkZG9uLWRpc2Nvbm5lY3QnOiAnZGlzY29ubmVjdEFkZG9uJyxcblx0XHRcdFx0J2NsaWNrIC5mb3JtaW5hdG9yLWFkZG9uLWZvcm0tZGlzY29ubmVjdCc6ICdmb3JtRGlzY29ubmVjdEFkZG9uJyxcblx0XHRcdFx0J2NsaWNrIC5mb3JtaW5hdG9yLWFkZG9uLW5leHQnOiAnc3VibWl0TmV4dFN0ZXAnLFxuXHRcdFx0XHQnY2xpY2sgLmZvcm1pbmF0b3ItYWRkb24tYmFjayc6ICdnb1ByZXZTdGVwJyxcblx0XHRcdFx0J2NsaWNrIC5mb3JtaW5hdG9yLWFkZG9uLWZpbmlzaCc6ICdmaW5pc2hTdGVwcycsXG5cdFx0XHRcdCdjbGljayAuZm9ybWluYXRvci1yZWZyZXNoLWVtYWlsLWxpc3RzJzogJ3JlZnJlc2hMaXN0cycsXG5cdFx0XHRcdCdjaGFuZ2Ugc2VsZWN0I2dyb3VwJzogJ3Nob3dJbnRlcmVzdHMnLFxuXHRcdFx0fSxcblx0XHR9ICk7XG5cblx0XHR0aGlzLnNsdWcgPSBvcHRpb25zLnNsdWc7XG5cdFx0dGhpcy5ub25jZSA9IG9wdGlvbnMubm9uY2U7XG5cdFx0dGhpcy5hY3Rpb24gPSBvcHRpb25zLmFjdGlvbjtcblx0XHR0aGlzLm11bHRpX2lkID0gb3B0aW9ucy5tdWx0aV9pZDtcblx0XHR0aGlzLmdsb2JhbF9pZCA9IG9wdGlvbnMuZ2xvYmFsX2lkO1xuXHRcdHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblx0XHR0aGlzLnN0ZXAgPSAwO1xuXHRcdHRoaXMubmV4dF9zdGVwID0gZmFsc2U7XG5cdFx0dGhpcy5wcmV2X3N0ZXAgPSBmYWxzZTtcblx0XHR0aGlzLnNjcm9sbGJhcl93aWR0aCA9IHRoaXMuZ2V0U2Nyb2xsYmFyV2lkdGgoKTtcblxuXHRcdGlmICggdGhpcy50eXBlID09PSAnZm9ybScgKSB7XG5cdFx0XHR0aGlzLm1vZHVsZV9pZCA9IG9wdGlvbnMuZm9ybV9pZDtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnR5cGUgPT09ICdwb2xsJyApIHtcblx0XHRcdHRoaXMubW9kdWxlX2lkID0gb3B0aW9ucy5wb2xsX2lkO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMudHlwZSA9PT0gJ3F1aXonICkge1xuXHRcdFx0dGhpcy5tb2R1bGVfaWQgPSBvcHRpb25zLnF1aXpfaWQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucmVuZGVyKCk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgZGF0YSA9IHt9O1xuXG5cdFx0ZGF0YS5hY3Rpb24gPSB0aGlzLmFjdGlvbjtcblx0XHRkYXRhLl9hamF4X25vbmNlID0gdGhpcy5ub25jZTtcblx0XHRkYXRhLmRhdGEgPSB7fTtcblx0XHRkYXRhLmRhdGEuc2x1ZyA9IHRoaXMuc2x1Zztcblx0XHRkYXRhLmRhdGEuc3RlcCA9IHRoaXMuc3RlcDtcblx0XHRkYXRhLmRhdGEuY3VycmVudF9zdGVwID0gdGhpcy5zdGVwO1xuXHRcdGRhdGEuZGF0YS5nbG9iYWxfaWQgPSB0aGlzLmdsb2JhbF9pZDtcblx0XHRkYXRhLmRhdGEgPSB0aGlzLmdldEFqYXhNb2R1bGVEYXRhKCBkYXRhLmRhdGEsIHRydWUgKTtcblxuXHRcdHRoaXMucmVxdWVzdCggZGF0YSwgZmFsc2UsIHRydWUgKTtcblx0fVxuXG5cblx0YXBwbHlMb2FkZXIoICRlbGVtZW50ICkge1xuXHRcdCRlbGVtZW50LmZpbmQoICcuc3VpLWJ1dHRvbjpub3QoLmRpc2FibGUtbG9hZGVyKScgKS5hZGRDbGFzcyggJ3N1aS1idXR0b24tb25sb2FkJyApO1xuXHR9XG5cblx0cmVzZXRMb2FkZXIoICRlbGVtZW50ICkge1xuXHRcdCRlbGVtZW50LmZpbmQoICcuc3VpLWJ1dHRvbicgKS5yZW1vdmVDbGFzcyggJ3N1aS1idXR0b24tb25sb2FkJyApO1xuXHR9XG5cblx0cmVxdWVzdCggZGF0YSwgY2xvc2UsIGxvYWRlciApIHtcblx0XHRsZXQgc2VsZiA9IHRoaXMsXG5cdFx0XHRmdW5jdGlvbl9wYXJhbXMgPSB7XG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGNsb3NlOiBjbG9zZSxcblx0XHRcdFx0bG9hZGVyOiBsb2FkZXIsXG5cdFx0XHR9O1xuXG5cdFx0aWYgKCBsb2FkZXIgKSB7XG5cdFx0XHR0aGlzLiRlbFxuXHRcdFx0XHQuZmluZCggJy5zdWktYm94LWJvZHknIClcblx0XHRcdFx0Lmh0bWwoICc8cCBjbGFzcz1cImZ1aS1sb2FkaW5nLWRpYWxvZ1wiIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyO1wiIGFyaWEtbGFiZWw9XCJMb2FkaW5nIGNvbnRlbnRcIj4nICtcblx0XHRcdFx0XHQnPHNwYW4gY2xhc3M9XCJzdWktaWNvbi1sb2FkZXIgc3VpLW1kIHN1aS1sb2FkaW5nXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPicgK1xuXHRcdFx0XHQnPC9wPicgKTtcblx0XHRcdHRoaXMuJGVsLmZpbmQoICcuc3VpLWJveC1mb290ZXInICkuaHRtbCggJycgKTtcblx0XHRcdHRoaXMuJGVsLmZpbmQoICcuZm9ybWluYXRvci1pbnRlZ3JhdGlvbi1wb3B1cF9faGVhZGVyJyApLmh0bWwoICcnICk7XG5cdFx0fVxuXG5cdFx0c2VsZi5hcHBseUxvYWRlciggc2VsZi4kZWwgKTtcblxuXHRcdHRoaXMuYWpheCA9IGpRdWVyeVxuXHRcdFx0LnBvc3QoIHtcblx0XHRcdFx0dXJsOiBmb3JtaW5hdG9yRGF0YS5hamF4VXJsLFxuXHRcdFx0XHR0eXBlOiAncG9zdCcsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHR9IClcblx0XHRcdC5kb25lKCBmdW5jdGlvbiggcmVzdWx0ICkge1xuXHRcdFx0XHRpZiAoIHJlc3VsdCAmJiByZXN1bHQuc3VjY2VzcyApIHtcblx0XHRcdFx0XHQvLyBSZW5kZXIgcG9wdXAgYm9keVxuXHRcdFx0XHRcdHNlbGYucmVuZGVyQm9keSggcmVzdWx0ICk7XG5cblx0XHRcdFx0XHQvLyBSZW5kZXIgcG9wdXAgZm9vdGVyXG5cdFx0XHRcdFx0c2VsZi5yZW5kZXJGb290ZXIoIHJlc3VsdCApO1xuXG5cdFx0XHRcdFx0Ly8gU2hvcnRlbiByZXN1bHQgZGF0YVxuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdERhdGEgPSByZXN1bHQuZGF0YS5kYXRhO1xuXG5cdFx0XHRcdFx0c2VsZi5vblJlbmRlciggcmVzdWx0RGF0YSApO1xuXG5cdFx0XHRcdFx0c2VsZi5yZXNldExvYWRlciggc2VsZi4kZWwgKTtcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBjbG9zZSBtb2RhbFxuXHRcdFx0XHRcdGlmICggY2xvc2UgfHwgKCAhIF8uaXNVbmRlZmluZWQoIHJlc3VsdERhdGEuaXNfY2xvc2UgKSAmJiByZXN1bHREYXRhLmlzX2Nsb3NlICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLmNsb3NlKCBzZWxmICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQWRkIGNsb3NpbmcgZXZlbnRcblx0XHRcdFx0XHRzZWxmLiRlbC5maW5kKCAnLmZvcm1pbmF0b3ItYWRkb24tY2xvc2UnICkub24oICdjbGljaycsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c2VsZi5jbG9zZSggc2VsZiApO1xuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBub3RpZmljYXRpb25zXG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0ISBfLmlzVW5kZWZpbmVkKCByZXN1bHREYXRhLm5vdGlmaWNhdGlvbiApICYmXG5cdFx0XHRcdFx0XHQhIF8uaXNVbmRlZmluZWQoIHJlc3VsdERhdGEubm90aWZpY2F0aW9uLnR5cGUgKSAmJlxuXHRcdFx0XHRcdFx0ISBfLmlzVW5kZWZpbmVkKCByZXN1bHREYXRhLm5vdGlmaWNhdGlvbi50ZXh0IClcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGN1c3RvbSA9IG5ldyBOb3RpZmljYXRpb24oIHtcblx0XHRcdFx0XHRcdFx0dHlwZTogcmVzdWx0RGF0YS5ub3RpZmljYXRpb24udHlwZSxcblx0XHRcdFx0XHRcdFx0dGV4dDogcmVzdWx0RGF0YS5ub3RpZmljYXRpb24udGV4dCxcblx0XHRcdFx0XHRcdFx0dGltZTogNDAwMCxcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGN1c3RvbS5vcGVuKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIGJhY2sgYnV0dG9uXG5cdFx0XHRcdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIHJlc3VsdERhdGEuaGFzX2JhY2sgKSApIHtcblx0XHRcdFx0XHRcdGlmICggcmVzdWx0RGF0YS5oYXNfYmFjayApIHtcblx0XHRcdFx0XHRcdFx0c2VsZi4kZWwuZmluZCggJy5mb3JtaW5hdG9yLWFkZG9uLWJhY2snICkuc2hvdygpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c2VsZi4kZWwuZmluZCggJy5mb3JtaW5hdG9yLWFkZG9uLWJhY2snICkuaGlkZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLiRlbC5maW5kKCAnLmZvcm1pbmF0b3ItYWRkb24tYmFjaycgKS5oaWRlKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIG1vZGFsIHNpemVcblx0XHRcdFx0XHRpZiAoICEgXy5pc1VuZGVmaW5lZCggcmVzdWx0RGF0YS5zaXplICkgKSB7XG5cdFx0XHRcdFx0XHRjb25zdCAkcG9wdXAgPSBqUXVlcnkoICcjZm9ybWluYXRvci1pbnRlZ3JhdGlvbi1wb3B1cCcgKTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGFsbCBzaXplc1xuXHRcdFx0XHRcdFx0aWYgKCByZXN1bHREYXRhLnNpemUgPT09ICdub3JtYWwnICkge1xuXHRcdFx0XHRcdFx0XHQkcG9wdXAucmVtb3ZlQ2xhc3MoICdzdWktbW9kYWwtc20gc3VpLW1vZGFsLWxnJyApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIHJlc3VsdERhdGEuc2l6ZSA9PT0gJ3NtYWxsJyApIHtcblx0XHRcdFx0XHRcdFx0JHBvcHVwLmFkZENsYXNzKCAnc3VpLW1vZGFsLXNtJyApO1xuXHRcdFx0XHRcdFx0XHQkcG9wdXAucmVtb3ZlQ2xhc3MoICdzdWktbW9kYWwtbGcgc3VpLW1vZGFsLXJlZHVjZWQnICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggcmVzdWx0RGF0YS5zaXplID09PSAncmVkdWNlZCcgKSB7XG5cdFx0XHRcdFx0XHRcdCRwb3B1cC5hZGRDbGFzcyggJ3N1aS1tb2RhbC1zbScgKTtcblx0XHRcdFx0XHRcdFx0JHBvcHVwLnJlbW92ZUNsYXNzKCAnc3VpLW1vZGFsLWxnIHN1aS1tb2RhbC1tZCcgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCByZXN1bHREYXRhLnNpemUgPT09ICdsYXJnZScgKSB7XG5cdFx0XHRcdFx0XHRcdCRwb3B1cC5hZGRDbGFzcyggJ3N1aS1tb2RhbC1sZycgKTtcblx0XHRcdFx0XHRcdFx0JHBvcHVwLnJlbW92ZUNsYXNzKCAnc3VpLW1vZGFsLXNtIHN1aS1tb2RhbC1tZCcgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHJlc3VsdERhdGEuaXNfcG9sbCApIHtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoXG5cdFx0XHRcdFx0XHRcdHNlbGYucmVxdWVzdChcblx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbl9wYXJhbXMuZGF0YSxcblx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbl9wYXJhbXMuY2xvc2UsXG5cdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb25fcGFyYW1zLmxvYWRlclxuXHRcdFx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdFx0XHQ1MDAwXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0Ly8gUmViaW5kIEFjY29yZGlvbiBzY3JpcHRzXG5cdFx0XHRcdFx0XHRTVUkuc3VpQWNjb3JkaW9uKCBqUXVlcnkoICcuc3VpLWFjY29yZGlvbicgKSApO1xuXG5cdFx0XHRcdFx0XHQvLyBSZWJpbmQgVGFicyBzY3JpcHRzXG5cdFx0XHRcdFx0XHRTVUkuc3VpVGFicyggalF1ZXJ5KCAnLnN1aS10YWJzJyApICk7XG5cblx0XHRcdFx0XHRcdC8vIFJlYmluZCBTZWxlY3QyIHNjcmlwdHMuXG5cdFx0XHRcdFx0XHRqUXVlcnkoICdzZWxlY3Quc3VpLXNlbGVjdFtkYXRhLXRoZW1lPVwiaWNvblwiXScgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0U1VJLnNlbGVjdC5pbml0SWNvbiggalF1ZXJ5KCB0aGlzICkgKTtcblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdFx0alF1ZXJ5KCAnc2VsZWN0LnN1aS1zZWxlY3RbZGF0YS10aGVtZT1cImNvbG9yXCJdJyApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRTVUkuc2VsZWN0LmluaXRDb2xvciggalF1ZXJ5KCB0aGlzICkgKTtcblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdFx0alF1ZXJ5KCAnc2VsZWN0LnN1aS1zZWxlY3RbZGF0YS10aGVtZT1cInNlYXJjaFwiXScgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0U1VJLnNlbGVjdC5pbml0U2VhcmNoKCBqUXVlcnkoIHRoaXMgKSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0XHRqUXVlcnkoICdzZWxlY3Quc3VpLXNlbGVjdDpub3QoW2RhdGEtdGhlbWVdKTpub3QoLmN1c3RvbS1zZWxlY3QyKTpub3QoLmZ1aS1tdWx0aS1zZWxlY3QpJyApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRTVUkuc2VsZWN0LmluaXQoIGpRdWVyeSggdGhpcyApICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRcdC8vIFJlYmluZCBWYXJpYWJsZXMgc2NyaXB0cy5cblx0XHRcdFx0XHRcdGpRdWVyeSggJ3NlbGVjdC5zdWktdmFyaWFibGVzJyApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRTVUkuc2VsZWN0LmluaXRWYXJzKCBqUXVlcnkoIHRoaXMgKSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0XHQvLyBSZWJpbmQgQ2lyY2xlIHNjcmlwdHNcblx0XHRcdFx0XHRcdFNVSS5sb2FkQ2lyY2xlU2NvcmUoIGpRdWVyeSggJy5zdWktY2lyY2xlLXNjb3JlJyApICk7XG5cblx0XHRcdFx0XHRcdC8vIFJlYmluZCBQYXNzd29yZCBzY3JpcHRzXG5cdFx0XHRcdFx0XHRTVUkuc2hvd0hpZGVQYXNzd29yZCgpO1xuXHRcdFx0XHRcdH0sIDEwICk7XG5cblx0XHRcdFx0XHQvL2NoZWNrIHRoZSBoZWlnaHRcblx0XHRcdFx0XHRjb25zdCAkcG9wdXBCb3ggPSBqUXVlcnkoICcjZm9ybWluYXRvci1pbnRlZ3JhdGlvbi1wb3B1cCAuc3VpLWJveCcgKSxcblx0XHRcdFx0XHRcdCRwb3B1cEJveEhlaWdodCA9ICRwb3B1cEJveC5oZWlnaHQoKSxcblx0XHRcdFx0XHRcdCR3aW5kb3dIZWlnaHQgPSBqUXVlcnkoIHdpbmRvdyApLmhlaWdodCgpO1xuXG5cdFx0XHRcdFx0Ly8gc2Nyb2xsYmFyIGFwcGVhclxuXHRcdFx0XHRcdGlmICggJHBvcHVwQm94SGVpZ2h0ID4gJHdpbmRvd0hlaWdodCApIHtcblx0XHRcdFx0XHRcdC8vIG1ha2Ugc2Nyb2xsYmFyIGNsaWNrYWJsZVxuXHRcdFx0XHRcdFx0alF1ZXJ5KCAnI2Zvcm1pbmF0b3ItaW50ZWdyYXRpb24tcG9wdXAgLnN1aS1tb2RhbC1vdmVybGF5JyApLmNzcyhcblx0XHRcdFx0XHRcdFx0J3JpZ2h0Jyxcblx0XHRcdFx0XHRcdFx0c2VsZi5zY3JvbGxiYXJfd2lkdGggKyAncHgnXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkoICcjZm9ybWluYXRvci1pbnRlZ3JhdGlvbi1wb3B1cCAuc3VpLW1vZGFsLW92ZXJsYXknICkuY3NzKCAncmlnaHQnLCAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFNob3cgTWFpbGNoaW1wIGludGVyZXN0cyBpcyBHcm91cCBpcyBhbHJlYWR5IGNob29zZW4uXG5cdFx0XHRcdGlmICggJ21haWxjaGltcCcgPT09IHNlbGYuc2x1ZyApIHtcblx0XHRcdFx0XHRjb25zdCBncm91cCA9IHNlbGYuJGVsLmZpbmQoICcjZ3JvdXAnICk7XG5cdFx0XHRcdFx0aWYgKCBncm91cC5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRncm91cC50cmlnZ2VyKCAnY2hhbmdlJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXG5cdFx0Ly9yZW1vdmUgdGhlIHByZWxvYWRlclxuXHRcdHRoaXMuYWpheC5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c2VsZi4kZWwuZmluZCggJy5mdWktbG9hZGluZy1kaWFsb2cnICkucmVtb3ZlKCk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmVuZGVyQm9keSggcmVzdWx0ICkge1xuXHRcdHRoaXMuJGVsLmZpbmQoICcuc3VpLWJveC1ib2R5JyApLmh0bWwoIHJlc3VsdC5kYXRhLmRhdGEuaHRtbCApO1xuXHRcdC8vIGFwcGVuZCBoZWFkZXIgdG8gaW50ZWdyYXRpb24taGVhZGVyXG5cdFx0Y29uc3QgaW50ZWdyYXRpb25IZWFkZXIgPSB0aGlzLiRlbC5maW5kKCAnLnN1aS1ib3gtYm9keSAuZm9ybWluYXRvci1pbnRlZ3JhdGlvbi1wb3B1cF9faGVhZGVyJyApLnJlbW92ZSgpO1xuXHRcdGlmICggaW50ZWdyYXRpb25IZWFkZXIubGVuZ3RoID4gMCApIHtcblx0XHRcdHRoaXMuJGVsLmZpbmQoICcuZm9ybWluYXRvci1pbnRlZ3JhdGlvbi1wb3B1cF9faGVhZGVyJyApLmh0bWwoIGludGVncmF0aW9uSGVhZGVyLmh0bWwoKSApO1xuXHRcdH1cblx0fVxuXG5cdHJlbmRlckZvb3RlciggcmVzdWx0ICkge1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzLFxuXHRcdFx0YnV0dG9ucyA9IHJlc3VsdC5kYXRhLmRhdGEuYnV0dG9ucztcblxuXHRcdC8vIENsZWFyIGZvb3RlciBmcm9tIHByZXZpb3VzIGJ1dHRvbnNcblx0XHRzZWxmLiRlbC5maW5kKCAnLnN1aS1ib3gtZm9vdGVyJyApLmh0bWwoICcnICk7XG5cblx0XHQvLyBBcHBlbmQgYnV0dG9uc1xuXHRcdF8uZWFjaCggYnV0dG9ucywgZnVuY3Rpb24oIGJ1dHRvbiApIHtcblx0XHRcdHNlbGYuJGVsLmZpbmQoICcuc3VpLWJveC1mb290ZXInICkuYXBwZW5kKCBidXR0b24ubWFya3VwICk7XG5cdFx0fSApO1xuXHR9XG5cblx0b25SZW5kZXIoIHJlc3VsdCApIHtcblx0XHQvLyB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XG5cblx0XHQvLyBEZWxlZ2F0ZSBTVUkgZXZlbnRzXG5cdFx0c3VpRGVsZWdhdGVFdmVudHMoKTtcblx0XHQvLyBtdWx0aSBzZWxlY3QgKFRhZ3MpXG5cdFx0c2VsZWN0MlRhZ3MoIHRoaXMuJGVsLCB7fSApO1xuXG5cdFx0Ly8gVXBkYXRlIGN1cnJlbnQgc3RlcFxuXHRcdGlmICggISBfLmlzVW5kZWZpbmVkKCByZXN1bHQuZm9ybWluYXRvcl9hZGRvbl9jdXJyZW50X3N0ZXAgKSApIHtcblx0XHRcdHRoaXMuc3RlcCA9ICtyZXN1bHQuZm9ybWluYXRvcl9hZGRvbl9jdXJyZW50X3N0ZXA7XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlIGhhcyBuZXh0IHN0ZXBcblx0XHRpZiAoICEgXy5pc1VuZGVmaW5lZCggcmVzdWx0LmZvcm1pbmF0b3JfYWRkb25faGFzX25leHRfc3RlcCApICkge1xuXHRcdFx0dGhpcy5uZXh0X3N0ZXAgPSByZXN1bHQuZm9ybWluYXRvcl9hZGRvbl9oYXNfbmV4dF9zdGVwO1xuXHRcdH1cblxuXHRcdC8vIFVwZGF0ZSBoYXMgcHJldiBzdGVwXG5cdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIHJlc3VsdC5mb3JtaW5hdG9yX2FkZG9uX2hhc19wcmV2X3N0ZXAgKSApIHtcblx0XHRcdHRoaXMucHJldl9zdGVwID0gcmVzdWx0LmZvcm1pbmF0b3JfYWRkb25faGFzX3ByZXZfc3RlcDtcblx0XHR9XG5cdH1cblxuXHRjbG9zZSggc2VsZiApIHtcblx0XHQvLyBLaWxsIEFKQVggaGVhcmJlYXRcblx0XHRzZWxmLmFqYXguYWJvcnQoKTtcblxuXHRcdC8vIFJlbW92ZSB0aGUgdmlld1xuXHRcdHNlbGYucmVtb3ZlKCk7XG5cblx0XHR0aGlzLnRyaWdnZXIoICdtb2RhbDpjbG9zZWQnICk7XG5cdH1cblxuXHRyZWZyZXNoTGlzdHMoIGUgKSB7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHRjb25zdCBzZWxmID0gdGhpcyxcblx0XHRcdCR0aGlzID0galF1ZXJ5KCBlLmN1cnJlbnRUYXJnZXQgKSxcblx0XHRcdHNsdWcgPSB0aGlzLnNsdWcsXG5cdFx0XHRnbG9iYWxfaWQgPSB0aGlzLmdsb2JhbF9pZCxcblx0XHRcdG5vbmNlID0gdGhpcy5ub25jZSxcblx0XHRcdHBhcmFtcyA9IHtcblx0XHRcdFx0c2x1Zyxcblx0XHRcdFx0Z2xvYmFsX2lkLFxuXHRcdFx0fTtcblxuXHRcdCR0aGlzLmFkZENsYXNzKCAnc3VpLWJ1dHRvbi1vbmxvYWQnICk7XG5cblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiBhamF4dXJsLFxuXHRcdFx0dHlwZTogJ1BPU1QnLFxuXHRcdFx0ZGF0YToge1xuXHRcdFx0XHRhY3Rpb246ICdmb3JtaW5hdG9yX3JlZnJlc2hfZW1haWxfbGlzdHMnLFxuXHRcdFx0XHRkYXRhOiBwYXJhbXMsXG5cdFx0XHRcdF9hamF4X25vbmNlOiBub25jZSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2Vcblx0XHRcdH0sXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIHJlc3VsdC5zdWNjZXNzICkge1xuXHRcdFx0XHRpZiAoICd1bmRlZmluZWQnICE9PSB0eXBlb2YgcmVzdWx0LmRhdGEub3B0aW9ucyApIHtcblx0XHRcdFx0XHRjb25zdCAkc2VsZWN0ID0gJHRoaXMuc2libGluZ3MoICcuc3VpLXNlbGVjdCcgKSxcblx0XHRcdFx0XHRcdGdldFBhcmVudCA9ICRzZWxlY3QuY2xvc2VzdCggJy5zdWktbW9kYWwtY29udGVudCcgKSxcblx0XHRcdFx0XHRcdGdldFBhcmVudElkID0gZ2V0UGFyZW50LmF0dHIoICdpZCcgKSxcblx0XHRcdFx0XHRcdHNlbGVjdFBhcmVudCA9ICggZ2V0UGFyZW50Lmxlbmd0aCApID8galF1ZXJ5KCAnIycgKyBnZXRQYXJlbnRJZCApIDogalF1ZXJ5KCAnYm9keScgKSxcblx0XHRcdFx0XHRcdGhhc1NlYXJjaCA9ICggJ3RydWUnID09PSAkc2VsZWN0LmF0dHIoICdkYXRhLXNlYXJjaCcgKSApID8gMCA6IC0xLFxuXHRcdFx0XHRcdFx0aXNTbWFsbCA9ICRzZWxlY3QuaGFzQ2xhc3MoICdzdWktc2VsZWN0LXNtJyApID8gJ3N1aS1zZWxlY3QtZHJvcGRvd24tc20nIDogJyc7XG5cblx0XHRcdFx0XHQkc2VsZWN0Lmh0bWwoIHJlc3VsdC5kYXRhLm9wdGlvbnMgKTtcblx0XHRcdFx0XHQkc2VsZWN0LlNVSXNlbGVjdDIoIHtcblx0XHRcdFx0XHRcdGRyb3Bkb3duUGFyZW50OiBzZWxlY3RQYXJlbnQsXG5cdFx0XHRcdFx0XHRtaW5pbXVtUmVzdWx0c0ZvclNlYXJjaDogaGFzU2VhcmNoLFxuXHRcdFx0XHRcdFx0ZHJvcGRvd25Dc3NDbGFzczogaXNTbWFsbCxcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICkuZmFpbCggZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBUT0RPOiBoYW5kbGUgZXJyb3JzXG5cdFx0fSApLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHQkdGhpcy5yZW1vdmVDbGFzcyggJ3N1aS1idXR0b24tb25sb2FkJyApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNob3cgaW50ZXJlc3RzIGZvciBtYWlsY2hpbXAuXG5cdHNob3dJbnRlcmVzdHMoIGUgKSB7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXMsXG5cdFx0XHQkdGhpcyA9IGpRdWVyeSggZS5jdXJyZW50VGFyZ2V0ICksXG5cdFx0XHRub25jZSA9ICR0aGlzLmRhdGEoICdub25jZScgKSxcblx0XHRcdGRhdGEgPSB7fSxcblx0XHRcdGZvcm0gPSBzZWxmLiRlbC5maW5kKCAnZm9ybScgKSxcblx0XHRcdHBhcmFtcyA9IHtcblx0XHRcdFx0c2x1Zzogc2VsZi5zbHVnLFxuXHRcdFx0XHRnbG9iYWxfaWQ6IHRoaXMuZ2xvYmFsX2lkLFxuXHRcdFx0XHRtb2R1bGVfaWQ6IHRoaXMubW9kdWxlX2lkLFxuXHRcdFx0XHRtb2R1bGVfdHlwZTogdGhpcy50eXBlLFxuXHRcdFx0fTtcblxuXHRcdGxldCBmb3JtRGF0YSA9IGZvcm0uc2VyaWFsaXplKCk7XG5cblx0XHRmb3JtRGF0YSA9IGZvcm1EYXRhICsgJyYnICsgalF1ZXJ5LnBhcmFtKCBwYXJhbXMgKTtcblx0XHRkYXRhLmFjdGlvbiA9ICdmb3JtaW5hdG9yX21haWxjaGltcF9nZXRfZ3JvdXBfaW50ZXJlc3RzJztcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG5cdFx0ZGF0YS5fYWpheF9ub25jZSA9IG5vbmNlO1xuXHRcdGRhdGEuZGF0YSA9IGZvcm1EYXRhO1xuXG5cdFx0c2VsZi5hcHBseUxvYWRlciggc2VsZi4kZWwgKTtcblxuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IGFqYXh1cmwsXG5cdFx0XHR0eXBlOiAnUE9TVCcsXG5cdFx0XHRkYXRhLFxuXHRcdH0gKVxuXHRcdC5kb25lKCBmdW5jdGlvbiggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCByZXN1bHQuc3VjY2VzcyApIHtcblx0XHRcdFx0Zm9ybS5maW5kKCAnLnN1aS1mb3JtLWZpZWxkJyApLnNsaWNlKCAxICkucmVtb3ZlKCk7XG5cdFx0XHRcdGZvcm0uZmluZCggJy5zdWktZm9ybS1maWVsZDpmaXJzdC1jaGlsZCcgKS5hZnRlciggcmVzdWx0LmRhdGEgKTtcblx0XHRcdFx0Zm9ybS5maW5kKCAnLnN1aS1mb3JtLWZpZWxkJyApLnNsaWNlKCAxICkuZmluZCgnc2VsZWN0JykuZWFjaCggZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRTVUkuc2VsZWN0LmluaXQoIGpRdWVyeSggdGhpcyApICk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gKVxuXHRcdC5mYWlsKCBmdW5jdGlvbigpIHtcblx0XHQvLyBUT0RPOiBoYW5kbGUgZXJyb3JzXG5cdFx0fSApXG5cdFx0LmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzZWxmLnJlc2V0TG9hZGVyKCBzZWxmLiRlbCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHN1Ym1pdE5leHRTdGVwKCBlICkge1xuXHRcdGNvbnN0IGRhdGEgPSB7fSxcblx0XHRcdGZvcm0gPSB0aGlzLiRlbC5maW5kKCAnZm9ybScgKTtcblx0XHRsZXQgcGFyYW1zID0ge1xuXHRcdFx0c2x1ZzogdGhpcy5zbHVnLFxuXHRcdFx0c3RlcDogdGhpcy5nZXRTdGVwKCksXG5cdFx0XHRnbG9iYWxfaWQ6IHRoaXMuZ2xvYmFsX2lkLFxuXHRcdFx0Y3VycmVudF9zdGVwOiB0aGlzLnN0ZXAsXG5cdFx0fTtcblx0XHRsZXQgZm9ybURhdGEgPSBmb3JtLnNlcmlhbGl6ZSgpO1xuXG5cdFx0cGFyYW1zID0gdGhpcy5nZXRBamF4TW9kdWxlRGF0YSggcGFyYW1zLCBmYWxzZSApO1xuXG5cdFx0Zm9ybURhdGEgPSBmb3JtRGF0YSArICcmJyArIGpRdWVyeS5wYXJhbSggcGFyYW1zICk7XG5cdFx0ZGF0YS5hY3Rpb24gPSB0aGlzLmFjdGlvbjtcblx0XHRkYXRhLl9hamF4X25vbmNlID0gdGhpcy5ub25jZTtcblx0XHRkYXRhLmRhdGEgPSBmb3JtRGF0YTtcblxuXHRcdHRoaXMucmVxdWVzdCggZGF0YSwgZmFsc2UsIGZhbHNlICk7XG5cdH1cblxuXHRnb1ByZXZTdGVwKCBlICkge1xuXHRcdGNvbnN0IGRhdGEgPSB7fTtcblx0XHRsZXQgcGFyYW1zID0ge1xuXHRcdFx0c2x1ZzogdGhpcy5zbHVnLFxuXHRcdFx0c3RlcDogdGhpcy5nZXRQcmV2U3RlcCgpLFxuXHRcdFx0Z2xvYmFsX2lkOiB0aGlzLmdsb2JhbF9pZCxcblx0XHRcdGN1cnJlbnRfc3RlcDogdGhpcy5zdGVwLFxuXHRcdH07XG5cblx0XHRwYXJhbXMgPSB0aGlzLmdldEFqYXhNb2R1bGVEYXRhKCBwYXJhbXMsIHRydWUgKTtcblxuXHRcdGRhdGEuYWN0aW9uID0gdGhpcy5hY3Rpb247XG5cdFx0ZGF0YS5fYWpheF9ub25jZSA9IHRoaXMubm9uY2U7XG5cdFx0ZGF0YS5kYXRhID0gcGFyYW1zO1xuXG5cdFx0dGhpcy5yZXF1ZXN0KCBkYXRhLCBmYWxzZSwgZmFsc2UgKTtcblx0fVxuXG5cdGZpbmlzaFN0ZXBzKCBlICkge1xuXHRcdGNvbnN0IGRhdGEgPSB7fSxcblx0XHRcdGZvcm0gPSB0aGlzLiRlbC5maW5kKCAnZm9ybScgKTtcblx0XHRsZXQgcGFyYW1zID0ge1xuXHRcdFx0c2x1ZzogdGhpcy5zbHVnLFxuXHRcdFx0c3RlcDogdGhpcy5nZXRTdGVwKCksXG5cdFx0XHRnbG9iYWxfaWQ6IHRoaXMuZ2xvYmFsX2lkLFxuXHRcdFx0Y3VycmVudF9zdGVwOiB0aGlzLnN0ZXAsXG5cdFx0fTtcblxuXHRcdGxldCBmb3JtRGF0YSA9IGZvcm0uc2VyaWFsaXplKCk7XG5cblx0XHRwYXJhbXMgPSB0aGlzLmdldEFqYXhNb2R1bGVEYXRhKCBwYXJhbXMsIHRydWUgKTtcblxuXHRcdGZvcm1EYXRhID0gZm9ybURhdGEgKyAnJicgKyBqUXVlcnkucGFyYW0oIHBhcmFtcyApO1xuXHRcdGRhdGEuYWN0aW9uID0gdGhpcy5hY3Rpb247XG5cdFx0ZGF0YS5fYWpheF9ub25jZSA9IHRoaXMubm9uY2U7XG5cdFx0ZGF0YS5kYXRhID0gZm9ybURhdGE7XG5cblx0XHR0aGlzLnJlcXVlc3QoIGRhdGEsIGZhbHNlLCBmYWxzZSApO1xuXHR9XG5cblx0Z2V0U3RlcCgpIHtcblx0XHRpZiAoIHRoaXMubmV4dF9zdGVwICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RlcCArIDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuc3RlcDtcblx0fVxuXG5cdGdldFByZXZTdGVwKCkge1xuXHRcdGlmICggdGhpcy5wcmV2X3N0ZXAgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGVwIC0gMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5zdGVwO1xuXHR9XG5cblx0Y29ubmVjdEFkZG9uKCkge1xuXHRcdGNvbnN0IGRhdGEgPSB7fSxcblx0XHRcdGZvcm0gPSB0aGlzLiRlbC5maW5kKCAnZm9ybScgKTtcblx0XHRsZXQgcGFyYW1zID0ge1xuXHRcdFx0c2x1ZzogdGhpcy5zbHVnLFxuXHRcdFx0c3RlcDogdGhpcy5nZXRTdGVwKCksXG5cdFx0XHRnbG9iYWxfaWQ6IHRoaXMuZ2xvYmFsX2lkLFxuXHRcdFx0Y3VycmVudF9zdGVwOiB0aGlzLnN0ZXAsXG5cdFx0fTtcblxuXHRcdGxldCBmb3JtRGF0YSA9IGZvcm0uc2VyaWFsaXplKCk7XG5cblx0XHRwYXJhbXMgPSB0aGlzLmdldEFqYXhNb2R1bGVEYXRhKCBwYXJhbXMsIHRydWUgKTtcblxuXHRcdGZvcm1EYXRhID0gZm9ybURhdGEgKyAnJicgKyBqUXVlcnkucGFyYW0oIHBhcmFtcyApO1xuXHRcdGRhdGEuYWN0aW9uID0gdGhpcy5hY3Rpb247XG5cdFx0ZGF0YS5fYWpheF9ub25jZSA9IHRoaXMubm9uY2U7XG5cdFx0ZGF0YS5kYXRhID0gZm9ybURhdGE7XG5cblx0XHR0aGlzLnJlcXVlc3QoIGRhdGEsIGZhbHNlLCBmYWxzZSApO1xuXHR9XG5cblx0ZGlzY29ubmVjdEFkZG9uKCkge1xuXHRcdGNvbnN0IGRhdGEgPSB7fTtcblx0XHRkYXRhLmFjdGlvbiA9ICdmb3JtaW5hdG9yX2FkZG9uX2RlYWN0aXZhdGUnO1xuXHRcdGRhdGEuX2FqYXhfbm9uY2UgPSB0aGlzLm5vbmNlO1xuXHRcdGRhdGEuZGF0YSA9IHt9O1xuXHRcdGRhdGEuZGF0YS5zbHVnID0gdGhpcy5zbHVnO1xuXHRcdGRhdGEuZGF0YS5nbG9iYWxfaWQgPSB0aGlzLmdsb2JhbF9pZDtcblxuXHRcdHRoaXMucmVxdWVzdCggZGF0YSwgdHJ1ZSwgZmFsc2UgKTtcblx0fVxuXG5cdGZvcm1EaXNjb25uZWN0QWRkb24oKSB7XG5cdFx0Y29uc3QgZGF0YSA9IHt9O1xuXHRcdGRhdGEuYWN0aW9uID0gdGhpcy5nZXRBamF4TW9kdWxlQWN0aW9uKCAnZGVhY3RpdmF0ZScgKTtcblx0XHRkYXRhLl9hamF4X25vbmNlID0gdGhpcy5ub25jZTtcblx0XHRkYXRhLmRhdGEgPSB7fTtcblx0XHRkYXRhLmRhdGEuc2x1ZyA9IHRoaXMuc2x1ZztcblxuXHRcdGRhdGEuZGF0YSA9IHRoaXMuZ2V0QWpheE1vZHVsZURhdGEoIGRhdGEuZGF0YSwgdHJ1ZSApO1xuXG5cdFx0dGhpcy5yZXF1ZXN0KCBkYXRhLCB0cnVlLCBmYWxzZSApO1xuXHR9XG5cblx0Z2V0U2Nyb2xsYmFyV2lkdGgoKSB7XG5cdFx0Ly9odHRwczovL2dpdGh1Yi5jb20vYnJhbmRvbmFhcm9uL2pxdWVyeS1nZXRzY3JvbGxiYXJ3aWR0aC9cblx0XHRsZXQgc2Nyb2xsYmFyV2lkdGggPSAwO1xuXHRcdGlmICggbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCggXCJNU0lFXCIgKSApIHtcblx0XHRcdGxldCAkdGV4dGFyZWExID0galF1ZXJ5KCAnPHRleHRhcmVhIGNvbHM9XCIxMFwiIHJvd3M9XCIyXCI+PC90ZXh0YXJlYT4nIClcblx0XHRcdFx0XHQuY3NzKCB7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB0b3A6IC0xMDAwLCBsZWZ0OiAtMTAwMCB9IClcblx0XHRcdFx0XHQuYXBwZW5kVG8oICdib2R5JyApLFxuXHRcdFx0XHQkdGV4dGFyZWEyID0galF1ZXJ5KFxuXHRcdFx0XHRcdCc8dGV4dGFyZWEgY29scz1cIjEwXCIgcm93cz1cIjJcIiBzdHlsZT1cIm92ZXJmbG93OiBoaWRkZW47XCI+PC90ZXh0YXJlYT4nXG5cdFx0XHRcdClcblx0XHRcdFx0XHQuY3NzKCB7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB0b3A6IC0xMDAwLCBsZWZ0OiAtMTAwMCB9IClcblx0XHRcdFx0XHQuYXBwZW5kVG8oICdib2R5JyApO1xuXHRcdFx0c2Nyb2xsYmFyV2lkdGggPSAkdGV4dGFyZWExLndpZHRoKCkgLSAkdGV4dGFyZWEyLndpZHRoKCk7XG5cdFx0XHQkdGV4dGFyZWExLmFkZCggJHRleHRhcmVhMiApLnJlbW92ZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCAkZGl2ID0galF1ZXJ5KCAnPGRpdiAvPicgKVxuXHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0d2lkdGg6IDEwMCxcblx0XHRcdFx0XHRoZWlnaHQ6IDEwMCxcblx0XHRcdFx0XHRvdmVyZmxvdzogJ2F1dG8nLFxuXHRcdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRcdHRvcDogLTEwMDAsXG5cdFx0XHRcdFx0bGVmdDogLTEwMDAsXG5cdFx0XHRcdH0gKVxuXHRcdFx0XHQucHJlcGVuZFRvKCAnYm9keScgKVxuXHRcdFx0XHQuYXBwZW5kKCAnPGRpdiAvPicgKVxuXHRcdFx0XHQuZmluZCggJ2RpdicgKVxuXHRcdFx0XHQuY3NzKCB7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogMjAwIH0gKTtcblx0XHRcdHNjcm9sbGJhcldpZHRoID0gMTAwIC0gJGRpdi53aWR0aCgpO1xuXHRcdFx0JGRpdi5wYXJlbnQoKS5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2Nyb2xsYmFyV2lkdGg7XG5cdH1cblxuXHRnZXRBamF4TW9kdWxlRGF0YSggZGF0YSwgd2l0aF9tdWx0aV9pZCApIHtcblx0XHRpZiAoIHRoaXMubW9kdWxlX2lkICkge1xuXHRcdFx0ZGF0YS5tb2R1bGVfaWQgPSB0aGlzLm1vZHVsZV9pZDtcblx0XHRcdGRhdGEubW9kdWxlX3R5cGUgPSB0aGlzLnR5cGU7XG5cdFx0XHRkYXRhLmdsb2JhbF9pZCA9IHRoaXMuZ2xvYmFsX2lkO1xuXHRcdH1cblxuXHRcdGlmICggd2l0aF9tdWx0aV9pZCApIHtcblx0XHRcdGlmICggdGhpcy5tdWx0aV9pZCApIHtcblx0XHRcdFx0ZGF0YS5tdWx0aV9pZCA9IHRoaXMubXVsdGlfaWQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cblxuXHRnZXRBamF4TW9kdWxlQWN0aW9uKCBhY3Rpb24gKSB7XG5cdFx0c3dpdGNoICggYWN0aW9uICkge1xuXHRcdFx0Y2FzZSAnZGVhY3RpdmF0ZSc6XG5cdFx0XHRcdGFjdGlvbiA9ICdmb3JtaW5hdG9yX2FkZG9uX2RlYWN0aXZhdGVfZm9yX21vZHVsZSc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY3Rpb247XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9saWIvaW50ZWdyYXRpb25zLmpzIiwidmFyIHN1cHBvcnQgPSB7XG4gIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gc2VsZixcbiAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gIGJsb2I6XG4gICAgJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiZcbiAgICAnQmxvYicgaW4gc2VsZiAmJlxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBCbG9iKClcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gc2VsZixcbiAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gc2VsZlxufVxuXG5mdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbn1cblxuaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gIF1cblxuICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPVxuICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB2aWV3Q2xhc3Nlcy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSA+IC0xXG4gICAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgfVxuICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5eX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICB9XG4gIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbmZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KClcbiAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGl0ZXJhdG9yXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdGhpcy5tYXAgPSB7fVxuXG4gIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgfSwgdGhpcylcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pXG4gICAgfSwgdGhpcylcbiAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgIH0sIHRoaXMpXG4gIH1cbn1cblxuSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV1cbiAgdGhpcy5tYXBbbmFtZV0gPSBvbGRWYWx1ZSA/IG9sZFZhbHVlICsgJywgJyArIHZhbHVlIDogdmFsdWVcbn1cblxuSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbn1cblxuSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gIGZvciAodmFyIG5hbWUgaW4gdGhpcy5tYXApIHtcbiAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpXG4gICAgfVxuICB9XG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgaXRlbXMucHVzaChuYW1lKVxuICB9KVxuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpdGVtcy5wdXNoKHZhbHVlKVxuICB9KVxuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKVxuICB9KVxuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG59XG5cbmlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzXG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gIH1cbiAgYm9keS5ib2R5VXNlZCA9IHRydWVcbn1cblxuZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KVxuICAgIH1cbiAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcilcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICByZWFkZXIucmVhZEFzVGV4dChibG9iKVxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICB2YXIgY2hhcnMgPSBuZXcgQXJyYXkodmlldy5sZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pXG4gIH1cbiAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICB9IGVsc2Uge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpXG4gICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSlcbiAgICByZXR1cm4gdmlldy5idWZmZXJcbiAgfVxufVxuXG5mdW5jdGlvbiBCb2R5KCkge1xuICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHlcbiAgICBpZiAoIWJvZHkpIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpXG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcilcbiAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSlcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiByZWplY3RlZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxudmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ11cblxuZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2Rcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHlcblxuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgIH1cbiAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFsc1xuICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICB0aGlzLnNpZ25hbCA9IGlucHV0LnNpZ25hbFxuICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdFxuICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KVxuICB9XG5cbiAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnc2FtZS1vcmlnaW4nXG4gIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgfVxuICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJylcbiAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsXG4gIHRoaXMuc2lnbmFsID0gb3B0aW9ucy5zaWduYWwgfHwgdGhpcy5zaWduYWxcbiAgdGhpcy5yZWZlcnJlciA9IG51bGxcblxuICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICB9XG4gIHRoaXMuX2luaXRCb2R5KGJvZHkpXG59XG5cblJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxufVxuXG5mdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gIGJvZHlcbiAgICAudHJpbSgpXG4gICAgLnNwbGl0KCcmJylcbiAgICAuZm9yRWFjaChmdW5jdGlvbihieXRlcykge1xuICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGJ5dGVzLnNwbGl0KCc9JylcbiAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICBmb3JtLmFwcGVuZChkZWNvZGVVUklDb21wb25lbnQobmFtZSksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpXG4gICAgICB9XG4gICAgfSlcbiAgcmV0dXJuIGZvcm1cbn1cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gIC8vIFJlcGxhY2UgaW5zdGFuY2VzIG9mIFxcclxcbiBhbmQgXFxuIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBzcGFjZSBvciBob3Jpem9udGFsIHRhYiB3aXRoIGEgc3BhY2VcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgdmFyIHByZVByb2Nlc3NlZEhlYWRlcnMgPSByYXdIZWFkZXJzLnJlcGxhY2UoL1xccj9cXG5bXFx0IF0rL2csICcgJylcbiAgcHJlUHJvY2Vzc2VkSGVhZGVycy5zcGxpdCgvXFxyP1xcbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKVxuICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKVxuICAgIGlmIChrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKClcbiAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgfVxuICB9KVxuICByZXR1cm4gaGVhZGVyc1xufVxuXG5Cb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpXG5cbmV4cG9ydCBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIHRoaXMudHlwZSA9ICdkZWZhdWx0J1xuICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzID09PSB1bmRlZmluZWQgPyAyMDAgOiBvcHRpb25zLnN0YXR1c1xuICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gIHRoaXMuc3RhdHVzVGV4dCA9ICdzdGF0dXNUZXh0JyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogJ09LJ1xuICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpXG59XG5cbkJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cblJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICB1cmw6IHRoaXMudXJsXG4gIH0pXG59XG5cblJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pXG4gIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gIHJldHVybiByZXNwb25zZVxufVxuXG52YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG59XG5cbmV4cG9ydCB2YXIgRE9NRXhjZXB0aW9uID0gc2VsZi5ET01FeGNlcHRpb25cbnRyeSB7XG4gIG5ldyBET01FeGNlcHRpb24oKVxufSBjYXRjaCAoZXJyKSB7XG4gIERPTUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpXG4gICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrXG4gIH1cbiAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKVxuICBET01FeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRE9NRXhjZXB0aW9uXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaChpbnB1dCwgaW5pdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdClcblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbCAmJiByZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgIH1cblxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgZnVuY3Rpb24gYWJvcnRYaHIoKSB7XG4gICAgICB4aHIuYWJvcnQoKVxuICAgIH1cblxuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgfVxuICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHRcbiAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKVxuICAgIH1cblxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgIH1cblxuICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgfVxuXG4gICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICB9XG5cbiAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpXG5cbiAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ29taXQnKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyICYmIHN1cHBvcnQuYmxvYikge1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgIH1cblxuICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICB9KVxuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsKSB7XG4gICAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKVxuXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gIH0pXG59XG5cbmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxuXG5pZiAoIXNlbGYuZmV0Y2gpIHtcbiAgc2VsZi5mZXRjaCA9IGZldGNoXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnNcbiAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdFxuICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2Vcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gMTk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyIsImltcG9ydHt0eXBlT2YgYXMgZSxpc0VsZW1lbnQgYXMgdCxpc1ZhbGlkRWxlbWVudFR5cGUgYXMgbn1mcm9tXCJyZWFjdC1pc1wiO2ltcG9ydCByLHt1c2VTdGF0ZSBhcyBvLHVzZUNvbnRleHQgYXMgcyx1c2VNZW1vIGFzIGksdXNlRWZmZWN0IGFzIGEsdXNlUmVmIGFzIGMsY3JlYXRlRWxlbWVudCBhcyB1LHVzZURlYnVnVmFsdWUgYXMgbCx1c2VMYXlvdXRFZmZlY3QgYXMgZH1mcm9tXCJyZWFjdFwiO2ltcG9ydCBoIGZyb21cInNoYWxsb3dlcXVhbFwiO2ltcG9ydCBwIGZyb21cIkBlbW90aW9uL3N0eWxpc1wiO2ltcG9ydCBmIGZyb21cIkBlbW90aW9uL3VuaXRsZXNzXCI7aW1wb3J0IG0gZnJvbVwiQGVtb3Rpb24vaXMtcHJvcC12YWxpZFwiO2ltcG9ydCB5IGZyb21cImhvaXN0LW5vbi1yZWFjdC1zdGF0aWNzXCI7ZnVuY3Rpb24gdigpe3JldHVybih2PU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciBuPWFyZ3VtZW50c1t0XTtmb3IodmFyIHIgaW4gbilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixyKSYmKGVbcl09bltyXSl9cmV0dXJuIGV9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGc9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49W2VbMF1dLHI9MCxvPXQubGVuZ3RoO3I8bztyKz0xKW4ucHVzaCh0W3JdLGVbcisxXSk7cmV0dXJuIG59LFM9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10JiZcIm9iamVjdFwiPT10eXBlb2YgdCYmXCJbb2JqZWN0IE9iamVjdF1cIj09PSh0LnRvU3RyaW5nP3QudG9TdHJpbmcoKTpPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpJiYhZSh0KX0sdz1PYmplY3QuZnJlZXplKFtdKSxFPU9iamVjdC5mcmVlemUoe30pO2Z1bmN0aW9uIGIoZSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZX1mdW5jdGlvbiBfKGUpe3JldHVyblwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJlwic3RyaW5nXCI9PXR5cGVvZiBlJiZlfHxlLmRpc3BsYXlOYW1lfHxlLm5hbWV8fFwiQ29tcG9uZW50XCJ9ZnVuY3Rpb24gTihlKXtyZXR1cm4gZSYmXCJzdHJpbmdcIj09dHlwZW9mIGUuc3R5bGVkQ29tcG9uZW50SWR9dmFyIEE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3MmJihwcm9jZXNzLmVudi5SRUFDVF9BUFBfU0NfQVRUUnx8cHJvY2Vzcy5lbnYuU0NfQVRUUil8fFwiZGF0YS1zdHlsZWRcIixDPVwiNS4zLjNcIixJPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJlwiSFRNTEVsZW1lbnRcImluIHdpbmRvdyxQPUJvb2xlYW4oXCJib29sZWFuXCI9PXR5cGVvZiBTQ19ESVNBQkxFX1NQRUVEWT9TQ19ESVNBQkxFX1NQRUVEWTpcInVuZGVmaW5lZFwiIT10eXBlb2YgcHJvY2VzcyYmdm9pZCAwIT09cHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX1NDX0RJU0FCTEVfU1BFRURZJiZcIlwiIT09cHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX1NDX0RJU0FCTEVfU1BFRURZP1wiZmFsc2VcIiE9PXByb2Nlc3MuZW52LlJFQUNUX0FQUF9TQ19ESVNBQkxFX1NQRUVEWSYmcHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX1NDX0RJU0FCTEVfU1BFRURZOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzJiZ2b2lkIDAhPT1wcm9jZXNzLmVudi5TQ19ESVNBQkxFX1NQRUVEWSYmXCJcIiE9PXByb2Nlc3MuZW52LlNDX0RJU0FCTEVfU1BFRURZP1wiZmFsc2VcIiE9PXByb2Nlc3MuZW52LlNDX0RJU0FCTEVfU1BFRURZJiZwcm9jZXNzLmVudi5TQ19ESVNBQkxFX1NQRUVEWTpcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WKSxPPXt9LFI9XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVj97MTpcIkNhbm5vdCBjcmVhdGUgc3R5bGVkLWNvbXBvbmVudCBmb3IgY29tcG9uZW50OiAlcy5cXG5cXG5cIiwyOlwiQ2FuJ3QgY29sbGVjdCBzdHlsZXMgb25jZSB5b3UndmUgY29uc3VtZWQgYSBgU2VydmVyU3R5bGVTaGVldGAncyBzdHlsZXMhIGBTZXJ2ZXJTdHlsZVNoZWV0YCBpcyBhIG9uZSBvZmYgaW5zdGFuY2UgZm9yIGVhY2ggc2VydmVyLXNpZGUgcmVuZGVyIGN5Y2xlLlxcblxcbi0gQXJlIHlvdSB0cnlpbmcgdG8gcmV1c2UgaXQgYWNyb3NzIHJlbmRlcnM/XFxuLSBBcmUgeW91IGFjY2lkZW50YWxseSBjYWxsaW5nIGNvbGxlY3RTdHlsZXMgdHdpY2U/XFxuXFxuXCIsMzpcIlN0cmVhbWluZyBTU1IgaXMgb25seSBzdXBwb3J0ZWQgaW4gYSBOb2RlLmpzIGVudmlyb25tZW50OyBQbGVhc2UgZG8gbm90IHRyeSB0byBjYWxsIHRoaXMgbWV0aG9kIGluIHRoZSBicm93c2VyLlxcblxcblwiLDQ6XCJUaGUgYFN0eWxlU2hlZXRNYW5hZ2VyYCBleHBlY3RzIGEgdmFsaWQgdGFyZ2V0IG9yIHNoZWV0IHByb3AhXFxuXFxuLSBEb2VzIHRoaXMgZXJyb3Igb2NjdXIgb24gdGhlIGNsaWVudCBhbmQgaXMgeW91ciB0YXJnZXQgZmFsc3k/XFxuLSBEb2VzIHRoaXMgZXJyb3Igb2NjdXIgb24gdGhlIHNlcnZlciBhbmQgaXMgdGhlIHNoZWV0IGZhbHN5P1xcblxcblwiLDU6XCJUaGUgY2xvbmUgbWV0aG9kIGNhbm5vdCBiZSB1c2VkIG9uIHRoZSBjbGllbnQhXFxuXFxuLSBBcmUgeW91IHJ1bm5pbmcgaW4gYSBjbGllbnQtbGlrZSBlbnZpcm9ubWVudCBvbiB0aGUgc2VydmVyP1xcbi0gQXJlIHlvdSB0cnlpbmcgdG8gcnVuIFNTUiBvbiB0aGUgY2xpZW50P1xcblxcblwiLDY6XCJUcnlpbmcgdG8gaW5zZXJ0IGEgbmV3IHN0eWxlIHRhZywgYnV0IHRoZSBnaXZlbiBOb2RlIGlzIHVubW91bnRlZCFcXG5cXG4tIEFyZSB5b3UgdXNpbmcgYSBjdXN0b20gdGFyZ2V0IHRoYXQgaXNuJ3QgbW91bnRlZD9cXG4tIERvZXMgeW91ciBkb2N1bWVudCBub3QgaGF2ZSBhIHZhbGlkIGhlYWQgZWxlbWVudD9cXG4tIEhhdmUgeW91IGFjY2lkZW50YWxseSByZW1vdmVkIGEgc3R5bGUgdGFnIG1hbnVhbGx5P1xcblxcblwiLDc6J1RoZW1lUHJvdmlkZXI6IFBsZWFzZSByZXR1cm4gYW4gb2JqZWN0IGZyb20geW91ciBcInRoZW1lXCIgcHJvcCBmdW5jdGlvbiwgZS5nLlxcblxcbmBgYGpzXFxudGhlbWU9eygpID0+ICh7fSl9XFxuYGBgXFxuXFxuJyw4OidUaGVtZVByb3ZpZGVyOiBQbGVhc2UgbWFrZSB5b3VyIFwidGhlbWVcIiBwcm9wIGFuIG9iamVjdC5cXG5cXG4nLDk6XCJNaXNzaW5nIGRvY3VtZW50IGA8aGVhZD5gXFxuXFxuXCIsMTA6XCJDYW5ub3QgZmluZCBhIFN0eWxlU2hlZXQgaW5zdGFuY2UuIFVzdWFsbHkgdGhpcyBoYXBwZW5zIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBjb3BpZXMgb2Ygc3R5bGVkLWNvbXBvbmVudHMgbG9hZGVkIGF0IG9uY2UuIENoZWNrIG91dCB0aGlzIGlzc3VlIGZvciBob3cgdG8gdHJvdWJsZXNob290IGFuZCBmaXggdGhlIGNvbW1vbiBjYXNlcyB3aGVyZSB0aGlzIHNpdHVhdGlvbiBjYW4gaGFwcGVuOiBodHRwczovL2dpdGh1Yi5jb20vc3R5bGVkLWNvbXBvbmVudHMvc3R5bGVkLWNvbXBvbmVudHMvaXNzdWVzLzE5NDEjaXNzdWVjb21tZW50LTQxNzg2MjAyMVxcblxcblwiLDExOlwiX1RoaXMgZXJyb3Igd2FzIHJlcGxhY2VkIHdpdGggYSBkZXYtdGltZSB3YXJuaW5nLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZm9yIHY0IGZpbmFsLl8gW2NyZWF0ZUdsb2JhbFN0eWxlXSByZWNlaXZlZCBjaGlsZHJlbiB3aGljaCB3aWxsIG5vdCBiZSByZW5kZXJlZC4gUGxlYXNlIHVzZSB0aGUgY29tcG9uZW50IHdpdGhvdXQgcGFzc2luZyBjaGlsZHJlbiBlbGVtZW50cy5cXG5cXG5cIiwxMjpcIkl0IHNlZW1zIHlvdSBhcmUgaW50ZXJwb2xhdGluZyBhIGtleWZyYW1lIGRlY2xhcmF0aW9uICglcykgaW50byBhbiB1bnRhZ2dlZCBzdHJpbmcuIFRoaXMgd2FzIHN1cHBvcnRlZCBpbiBzdHlsZWQtY29tcG9uZW50cyB2MywgYnV0IGlzIG5vdCBsb25nZXIgc3VwcG9ydGVkIGluIHY0IGFzIGtleWZyYW1lcyBhcmUgbm93IGluamVjdGVkIG9uLWRlbWFuZC4gUGxlYXNlIHdyYXAgeW91ciBzdHJpbmcgaW4gdGhlIGNzc1xcXFxgXFxcXGAgaGVscGVyIHdoaWNoIGVuc3VyZXMgdGhlIHN0eWxlcyBhcmUgaW5qZWN0ZWQgY29ycmVjdGx5LiBTZWUgaHR0cHM6Ly93d3cuc3R5bGVkLWNvbXBvbmVudHMuY29tL2RvY3MvYXBpI2Nzc1xcblxcblwiLDEzOlwiJXMgaXMgbm90IGEgc3R5bGVkIGNvbXBvbmVudCBhbmQgY2Fubm90IGJlIHJlZmVycmVkIHRvIHZpYSBjb21wb25lbnQgc2VsZWN0b3IuIFNlZSBodHRwczovL3d3dy5zdHlsZWQtY29tcG9uZW50cy5jb20vZG9jcy9hZHZhbmNlZCNyZWZlcnJpbmctdG8tb3RoZXItY29tcG9uZW50cyBmb3IgbW9yZSBkZXRhaWxzLlxcblxcblwiLDE0OidUaGVtZVByb3ZpZGVyOiBcInRoZW1lXCIgcHJvcCBpcyByZXF1aXJlZC5cXG5cXG4nLDE1OlwiQSBzdHlsaXMgcGx1Z2luIGhhcyBiZWVuIHN1cHBsaWVkIHRoYXQgaXMgbm90IG5hbWVkLiBXZSBuZWVkIGEgbmFtZSBmb3IgZWFjaCBwbHVnaW4gdG8gYmUgYWJsZSB0byBwcmV2ZW50IHN0eWxpbmcgY29sbGlzaW9ucyBiZXR3ZWVuIGRpZmZlcmVudCBzdHlsaXMgY29uZmlndXJhdGlvbnMgd2l0aGluIHRoZSBzYW1lIGFwcC4gQmVmb3JlIHlvdSBwYXNzIHlvdXIgcGx1Z2luIHRvIGA8U3R5bGVTaGVldE1hbmFnZXIgc3R5bGlzUGx1Z2lucz17W119PmAsIHBsZWFzZSBtYWtlIHN1cmUgZWFjaCBwbHVnaW4gaXMgdW5pcXVlbHktbmFtZWQsIGUuZy5cXG5cXG5gYGBqc1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbXBvcnRlZFBsdWdpbiwgJ25hbWUnLCB7IHZhbHVlOiAnc29tZS11bmlxdWUtbmFtZScgfSk7XFxuYGBgXFxuXFxuXCIsMTY6XCJSZWFjaGVkIHRoZSBsaW1pdCBvZiBob3cgbWFueSBzdHlsZWQgY29tcG9uZW50cyBtYXkgYmUgY3JlYXRlZCBhdCBncm91cCAlcy5cXG5Zb3UgbWF5IG9ubHkgY3JlYXRlIHVwIHRvIDEsMDczLDc0MSw4MjQgY29tcG9uZW50cy4gSWYgeW91J3JlIGNyZWF0aW5nIGNvbXBvbmVudHMgZHluYW1pY2FsbHksXFxuYXMgZm9yIGluc3RhbmNlIGluIHlvdXIgcmVuZGVyIG1ldGhvZCB0aGVuIHlvdSBtYXkgYmUgcnVubmluZyBpbnRvIHRoaXMgbGltaXRhdGlvbi5cXG5cXG5cIiwxNzpcIkNTU1N0eWxlU2hlZXQgY291bGQgbm90IGJlIGZvdW5kIG9uIEhUTUxTdHlsZUVsZW1lbnQuXFxuSGFzIHN0eWxlZC1jb21wb25lbnRzJyBzdHlsZSB0YWcgYmVlbiB1bm1vdW50ZWQgb3IgYWx0ZXJlZCBieSBhbm90aGVyIHNjcmlwdD9cXG5cIn06e307ZnVuY3Rpb24gRCgpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoPD0wP3ZvaWQgMDphcmd1bWVudHNbMF0sdD1bXSxuPTEscj1hcmd1bWVudHMubGVuZ3RoO248cjtuKz0xKXQucHVzaChuPDB8fGFyZ3VtZW50cy5sZW5ndGg8PW4/dm9pZCAwOmFyZ3VtZW50c1tuXSk7cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7ZT1lLnJlcGxhY2UoLyVbYS16XS8sdCl9KSksZX1mdW5jdGlvbiBqKGUpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHQ+MT90LTE6MCkscj0xO3I8dDtyKyspbltyLTFdPWFyZ3VtZW50c1tyXTt0aHJvd1wicHJvZHVjdGlvblwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/bmV3IEVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQuIFNlZSBodHRwczovL2dpdC5pby9KVUlhRSNcIitlK1wiIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiKyhuLmxlbmd0aD4wP1wiIEFyZ3M6IFwiK24uam9pbihcIiwgXCIpOlwiXCIpKTpuZXcgRXJyb3IoRC5hcHBseSh2b2lkIDAsW1JbZV1dLmNvbmNhdChuKSkudHJpbSgpKX12YXIgVD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7dGhpcy5ncm91cFNpemVzPW5ldyBVaW50MzJBcnJheSg1MTIpLHRoaXMubGVuZ3RoPTUxMix0aGlzLnRhZz1lfXZhciB0PWUucHJvdG90eXBlO3JldHVybiB0LmluZGV4T2ZHcm91cD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MCxuPTA7bjxlO24rKyl0Kz10aGlzLmdyb3VwU2l6ZXNbbl07cmV0dXJuIHR9LHQuaW5zZXJ0UnVsZXM9ZnVuY3Rpb24oZSx0KXtpZihlPj10aGlzLmdyb3VwU2l6ZXMubGVuZ3RoKXtmb3IodmFyIG49dGhpcy5ncm91cFNpemVzLHI9bi5sZW5ndGgsbz1yO2U+PW87KShvPDw9MSk8MCYmaigxNixcIlwiK2UpO3RoaXMuZ3JvdXBTaXplcz1uZXcgVWludDMyQXJyYXkobyksdGhpcy5ncm91cFNpemVzLnNldChuKSx0aGlzLmxlbmd0aD1vO2Zvcih2YXIgcz1yO3M8bztzKyspdGhpcy5ncm91cFNpemVzW3NdPTB9Zm9yKHZhciBpPXRoaXMuaW5kZXhPZkdyb3VwKGUrMSksYT0wLGM9dC5sZW5ndGg7YTxjO2ErKyl0aGlzLnRhZy5pbnNlcnRSdWxlKGksdFthXSkmJih0aGlzLmdyb3VwU2l6ZXNbZV0rKyxpKyspfSx0LmNsZWFyR3JvdXA9ZnVuY3Rpb24oZSl7aWYoZTx0aGlzLmxlbmd0aCl7dmFyIHQ9dGhpcy5ncm91cFNpemVzW2VdLG49dGhpcy5pbmRleE9mR3JvdXAoZSkscj1uK3Q7dGhpcy5ncm91cFNpemVzW2VdPTA7Zm9yKHZhciBvPW47bzxyO28rKyl0aGlzLnRhZy5kZWxldGVSdWxlKG4pfX0sdC5nZXRHcm91cD1mdW5jdGlvbihlKXt2YXIgdD1cIlwiO2lmKGU+PXRoaXMubGVuZ3RofHwwPT09dGhpcy5ncm91cFNpemVzW2VdKXJldHVybiB0O2Zvcih2YXIgbj10aGlzLmdyb3VwU2l6ZXNbZV0scj10aGlzLmluZGV4T2ZHcm91cChlKSxvPXIrbixzPXI7czxvO3MrKyl0Kz10aGlzLnRhZy5nZXRSdWxlKHMpK1wiLyohc2MqL1xcblwiO3JldHVybiB0fSxlfSgpLHg9bmV3IE1hcCxrPW5ldyBNYXAsVj0xLEI9ZnVuY3Rpb24oZSl7aWYoeC5oYXMoZSkpcmV0dXJuIHguZ2V0KGUpO2Zvcig7ay5oYXMoVik7KVYrKzt2YXIgdD1WKys7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmKCgwfHQpPDB8fHQ+MTw8MzApJiZqKDE2LFwiXCIrdCkseC5zZXQoZSx0KSxrLnNldCh0LGUpLHR9LHo9ZnVuY3Rpb24oZSl7cmV0dXJuIGsuZ2V0KGUpfSxNPWZ1bmN0aW9uKGUsdCl7dD49ViYmKFY9dCsxKSx4LnNldChlLHQpLGsuc2V0KHQsZSl9LEc9XCJzdHlsZVtcIitBKyddW2RhdGEtc3R5bGVkLXZlcnNpb249XCI1LjMuM1wiXScsTD1uZXcgUmVnRXhwKFwiXlwiK0ErJ1xcXFwuZyhcXFxcZCspXFxcXFtpZD1cIihbXFxcXHdcXFxcZC1dKylcIlxcXFxdLio/XCIoW15cIl0qKScpLEY9ZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgcixvPW4uc3BsaXQoXCIsXCIpLHM9MCxpPW8ubGVuZ3RoO3M8aTtzKyspKHI9b1tzXSkmJmUucmVnaXN0ZXJOYW1lKHQscil9LFk9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49KHQudGV4dENvbnRlbnR8fFwiXCIpLnNwbGl0KFwiLyohc2MqL1xcblwiKSxyPVtdLG89MCxzPW4ubGVuZ3RoO288cztvKyspe3ZhciBpPW5bb10udHJpbSgpO2lmKGkpe3ZhciBhPWkubWF0Y2goTCk7aWYoYSl7dmFyIGM9MHxwYXJzZUludChhWzFdLDEwKSx1PWFbMl07MCE9PWMmJihNKHUsYyksRihlLHUsYVszXSksZS5nZXRUYWcoKS5pbnNlcnRSdWxlcyhjLHIpKSxyLmxlbmd0aD0wfWVsc2Ugci5wdXNoKGkpfX19LHE9ZnVuY3Rpb24oKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ2b2lkIDAhPT13aW5kb3cuX193ZWJwYWNrX25vbmNlX18/d2luZG93Ll9fd2VicGFja19ub25jZV9fOm51bGx9LEg9ZnVuY3Rpb24oZSl7dmFyIHQ9ZG9jdW1lbnQuaGVhZCxuPWV8fHQscj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiksbz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9ZS5jaGlsZE5vZGVzLG49dC5sZW5ndGg7bj49MDtuLS0pe3ZhciByPXRbbl07aWYociYmMT09PXIubm9kZVR5cGUmJnIuaGFzQXR0cmlidXRlKEEpKXJldHVybiByfX0obikscz12b2lkIDAhPT1vP28ubmV4dFNpYmxpbmc6bnVsbDtyLnNldEF0dHJpYnV0ZShBLFwiYWN0aXZlXCIpLHIuc2V0QXR0cmlidXRlKFwiZGF0YS1zdHlsZWQtdmVyc2lvblwiLFwiNS4zLjNcIik7dmFyIGk9cSgpO3JldHVybiBpJiZyLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsaSksbi5pbnNlcnRCZWZvcmUocixzKSxyfSwkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt2YXIgdD10aGlzLmVsZW1lbnQ9SChlKTt0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpKSx0aGlzLnNoZWV0PWZ1bmN0aW9uKGUpe2lmKGUuc2hlZXQpcmV0dXJuIGUuc2hlZXQ7Zm9yKHZhciB0PWRvY3VtZW50LnN0eWxlU2hlZXRzLG49MCxyPXQubGVuZ3RoO248cjtuKyspe3ZhciBvPXRbbl07aWYoby5vd25lck5vZGU9PT1lKXJldHVybiBvfWooMTcpfSh0KSx0aGlzLmxlbmd0aD0wfXZhciB0PWUucHJvdG90eXBlO3JldHVybiB0Lmluc2VydFJ1bGU9ZnVuY3Rpb24oZSx0KXt0cnl7cmV0dXJuIHRoaXMuc2hlZXQuaW5zZXJ0UnVsZSh0LGUpLHRoaXMubGVuZ3RoKyssITB9Y2F0Y2goZSl7cmV0dXJuITF9fSx0LmRlbGV0ZVJ1bGU9ZnVuY3Rpb24oZSl7dGhpcy5zaGVldC5kZWxldGVSdWxlKGUpLHRoaXMubGVuZ3RoLS19LHQuZ2V0UnVsZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnNoZWV0LmNzc1J1bGVzW2VdO3JldHVybiB2b2lkIDAhPT10JiZcInN0cmluZ1wiPT10eXBlb2YgdC5jc3NUZXh0P3QuY3NzVGV4dDpcIlwifSxlfSgpLFc9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3ZhciB0PXRoaXMuZWxlbWVudD1IKGUpO3RoaXMubm9kZXM9dC5jaGlsZE5vZGVzLHRoaXMubGVuZ3RoPTB9dmFyIHQ9ZS5wcm90b3R5cGU7cmV0dXJuIHQuaW5zZXJ0UnVsZT1mdW5jdGlvbihlLHQpe2lmKGU8PXRoaXMubGVuZ3RoJiZlPj0wKXt2YXIgbj1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0KSxyPXRoaXMubm9kZXNbZV07cmV0dXJuIHRoaXMuZWxlbWVudC5pbnNlcnRCZWZvcmUobixyfHxudWxsKSx0aGlzLmxlbmd0aCsrLCEwfXJldHVybiExfSx0LmRlbGV0ZVJ1bGU9ZnVuY3Rpb24oZSl7dGhpcy5lbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMubm9kZXNbZV0pLHRoaXMubGVuZ3RoLS19LHQuZ2V0UnVsZT1mdW5jdGlvbihlKXtyZXR1cm4gZTx0aGlzLmxlbmd0aD90aGlzLm5vZGVzW2VdLnRleHRDb250ZW50OlwiXCJ9LGV9KCksVT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7dGhpcy5ydWxlcz1bXSx0aGlzLmxlbmd0aD0wfXZhciB0PWUucHJvdG90eXBlO3JldHVybiB0Lmluc2VydFJ1bGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZTw9dGhpcy5sZW5ndGgmJih0aGlzLnJ1bGVzLnNwbGljZShlLDAsdCksdGhpcy5sZW5ndGgrKywhMCl9LHQuZGVsZXRlUnVsZT1mdW5jdGlvbihlKXt0aGlzLnJ1bGVzLnNwbGljZShlLDEpLHRoaXMubGVuZ3RoLS19LHQuZ2V0UnVsZT1mdW5jdGlvbihlKXtyZXR1cm4gZTx0aGlzLmxlbmd0aD90aGlzLnJ1bGVzW2VdOlwiXCJ9LGV9KCksSj1JLFg9e2lzU2VydmVyOiFJLHVzZUNTU09NSW5qZWN0aW9uOiFQfSxaPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQsbil7dm9pZCAwPT09ZSYmKGU9RSksdm9pZCAwPT09dCYmKHQ9e30pLHRoaXMub3B0aW9ucz12KHt9LFgse30sZSksdGhpcy5ncz10LHRoaXMubmFtZXM9bmV3IE1hcChuKSx0aGlzLnNlcnZlcj0hIWUuaXNTZXJ2ZXIsIXRoaXMuc2VydmVyJiZJJiZKJiYoSj0hMSxmdW5jdGlvbihlKXtmb3IodmFyIHQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChHKSxuPTAscj10Lmxlbmd0aDtuPHI7bisrKXt2YXIgbz10W25dO28mJlwiYWN0aXZlXCIhPT1vLmdldEF0dHJpYnV0ZShBKSYmKFkoZSxvKSxvLnBhcmVudE5vZGUmJm8ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvKSl9fSh0aGlzKSl9ZS5yZWdpc3RlcklkPWZ1bmN0aW9uKGUpe3JldHVybiBCKGUpfTt2YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5yZWNvbnN0cnVjdFdpdGhPcHRpb25zPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPSEwKSxuZXcgZSh2KHt9LHRoaXMub3B0aW9ucyx7fSx0KSx0aGlzLmdzLG4mJnRoaXMubmFtZXN8fHZvaWQgMCl9LHQuYWxsb2NhdGVHU0luc3RhbmNlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmdzW2VdPSh0aGlzLmdzW2VdfHwwKSsxfSx0LmdldFRhZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRhZ3x8KHRoaXMudGFnPShuPSh0PXRoaXMub3B0aW9ucykuaXNTZXJ2ZXIscj10LnVzZUNTU09NSW5qZWN0aW9uLG89dC50YXJnZXQsZT1uP25ldyBVKG8pOnI/bmV3ICQobyk6bmV3IFcobyksbmV3IFQoZSkpKTt2YXIgZSx0LG4scixvfSx0Lmhhc05hbWVGb3JJZD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLm5hbWVzLmhhcyhlKSYmdGhpcy5uYW1lcy5nZXQoZSkuaGFzKHQpfSx0LnJlZ2lzdGVyTmFtZT1mdW5jdGlvbihlLHQpe2lmKEIoZSksdGhpcy5uYW1lcy5oYXMoZSkpdGhpcy5uYW1lcy5nZXQoZSkuYWRkKHQpO2Vsc2V7dmFyIG49bmV3IFNldDtuLmFkZCh0KSx0aGlzLm5hbWVzLnNldChlLG4pfX0sdC5pbnNlcnRSdWxlcz1mdW5jdGlvbihlLHQsbil7dGhpcy5yZWdpc3Rlck5hbWUoZSx0KSx0aGlzLmdldFRhZygpLmluc2VydFJ1bGVzKEIoZSksbil9LHQuY2xlYXJOYW1lcz1mdW5jdGlvbihlKXt0aGlzLm5hbWVzLmhhcyhlKSYmdGhpcy5uYW1lcy5nZXQoZSkuY2xlYXIoKX0sdC5jbGVhclJ1bGVzPWZ1bmN0aW9uKGUpe3RoaXMuZ2V0VGFnKCkuY2xlYXJHcm91cChCKGUpKSx0aGlzLmNsZWFyTmFtZXMoZSl9LHQuY2xlYXJUYWc9ZnVuY3Rpb24oKXt0aGlzLnRhZz12b2lkIDB9LHQudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUuZ2V0VGFnKCksbj10Lmxlbmd0aCxyPVwiXCIsbz0wO288bjtvKyspe3ZhciBzPXoobyk7aWYodm9pZCAwIT09cyl7dmFyIGk9ZS5uYW1lcy5nZXQocyksYT10LmdldEdyb3VwKG8pO2lmKGkmJmEmJmkuc2l6ZSl7dmFyIGM9QStcIi5nXCIrbysnW2lkPVwiJytzKydcIl0nLHU9XCJcIjt2b2lkIDAhPT1pJiZpLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UubGVuZ3RoPjAmJih1Kz1lK1wiLFwiKX0pKSxyKz1cIlwiK2ErYysne2NvbnRlbnQ6XCInK3UrJ1wifS8qIXNjKi9cXG4nfX19cmV0dXJuIHJ9KHRoaXMpfSxlfSgpLEs9LyhhKShkKS9naSxRPWZ1bmN0aW9uKGUpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGUrKGU+MjU/Mzk6OTcpKX07ZnVuY3Rpb24gZWUoZSl7dmFyIHQsbj1cIlwiO2Zvcih0PU1hdGguYWJzKGUpO3Q+NTI7dD10LzUyfDApbj1RKHQlNTIpK247cmV0dXJuKFEodCU1MikrbikucmVwbGFjZShLLFwiJDEtJDJcIil9dmFyIHRlPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPXQubGVuZ3RoO247KWU9MzMqZV50LmNoYXJDb2RlQXQoLS1uKTtyZXR1cm4gZX0sbmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRlKDUzODEsZSl9O2Z1bmN0aW9uIHJlKGUpe2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCs9MSl7dmFyIG49ZVt0XTtpZihiKG4pJiYhTihuKSlyZXR1cm4hMX1yZXR1cm4hMH12YXIgb2U9bmUoXCI1LjMuM1wiKSxzZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LG4pe3RoaXMucnVsZXM9ZSx0aGlzLnN0YXRpY1J1bGVzSWQ9XCJcIix0aGlzLmlzU3RhdGljPVwicHJvZHVjdGlvblwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJih2b2lkIDA9PT1ufHxuLmlzU3RhdGljKSYmcmUoZSksdGhpcy5jb21wb25lbnRJZD10LHRoaXMuYmFzZUhhc2g9dGUob2UsdCksdGhpcy5iYXNlU3R5bGU9bixaLnJlZ2lzdGVySWQodCl9cmV0dXJuIGUucHJvdG90eXBlLmdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10aGlzLmNvbXBvbmVudElkLG89W107aWYodGhpcy5iYXNlU3R5bGUmJm8ucHVzaCh0aGlzLmJhc2VTdHlsZS5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcyhlLHQsbikpLHRoaXMuaXNTdGF0aWMmJiFuLmhhc2gpaWYodGhpcy5zdGF0aWNSdWxlc0lkJiZ0Lmhhc05hbWVGb3JJZChyLHRoaXMuc3RhdGljUnVsZXNJZCkpby5wdXNoKHRoaXMuc3RhdGljUnVsZXNJZCk7ZWxzZXt2YXIgcz1OZSh0aGlzLnJ1bGVzLGUsdCxuKS5qb2luKFwiXCIpLGk9ZWUodGUodGhpcy5iYXNlSGFzaCxzKT4+PjApO2lmKCF0Lmhhc05hbWVGb3JJZChyLGkpKXt2YXIgYT1uKHMsXCIuXCIraSx2b2lkIDAscik7dC5pbnNlcnRSdWxlcyhyLGksYSl9by5wdXNoKGkpLHRoaXMuc3RhdGljUnVsZXNJZD1pfWVsc2V7Zm9yKHZhciBjPXRoaXMucnVsZXMubGVuZ3RoLHU9dGUodGhpcy5iYXNlSGFzaCxuLmhhc2gpLGw9XCJcIixkPTA7ZDxjO2QrKyl7dmFyIGg9dGhpcy5ydWxlc1tkXTtpZihcInN0cmluZ1wiPT10eXBlb2YgaClsKz1oLFwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJih1PXRlKHUsaCtkKSk7ZWxzZSBpZihoKXt2YXIgcD1OZShoLGUsdCxuKSxmPUFycmF5LmlzQXJyYXkocCk/cC5qb2luKFwiXCIpOnA7dT10ZSh1LGYrZCksbCs9Zn19aWYobCl7dmFyIG09ZWUodT4+PjApO2lmKCF0Lmhhc05hbWVGb3JJZChyLG0pKXt2YXIgeT1uKGwsXCIuXCIrbSx2b2lkIDAscik7dC5pbnNlcnRSdWxlcyhyLG0seSl9by5wdXNoKG0pfX1yZXR1cm4gby5qb2luKFwiIFwiKX0sZX0oKSxpZT0vXlxccypcXC9cXC8uKiQvZ20sYWU9W1wiOlwiLFwiW1wiLFwiLlwiLFwiI1wiXTtmdW5jdGlvbiBjZShlKXt2YXIgdCxuLHIsbyxzPXZvaWQgMD09PWU/RTplLGk9cy5vcHRpb25zLGE9dm9pZCAwPT09aT9FOmksYz1zLnBsdWdpbnMsdT12b2lkIDA9PT1jP3c6YyxsPW5ldyBwKGEpLGQ9W10saD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe2lmKHQpdHJ5e2UodCtcIn1cIil9Y2F0Y2goZSl7fX1yZXR1cm4gZnVuY3Rpb24obixyLG8scyxpLGEsYyx1LGwsZCl7c3dpdGNoKG4pe2Nhc2UgMTppZigwPT09bCYmNjQ9PT1yLmNoYXJDb2RlQXQoMCkpcmV0dXJuIGUocitcIjtcIiksXCJcIjticmVhaztjYXNlIDI6aWYoMD09PXUpcmV0dXJuIHIrXCIvKnwqL1wiO2JyZWFrO2Nhc2UgMzpzd2l0Y2godSl7Y2FzZSAxMDI6Y2FzZSAxMTI6cmV0dXJuIGUob1swXStyKSxcIlwiO2RlZmF1bHQ6cmV0dXJuIHIrKDA9PT1kP1wiLyp8Ki9cIjpcIlwiKX1jYXNlLTI6ci5zcGxpdChcIi8qfCovfVwiKS5mb3JFYWNoKHQpfX19KChmdW5jdGlvbihlKXtkLnB1c2goZSl9KSksZj1mdW5jdGlvbihlLHIscyl7cmV0dXJuIDA9PT1yJiYtMSE9PWFlLmluZGV4T2Yoc1tuLmxlbmd0aF0pfHxzLm1hdGNoKG8pP2U6XCIuXCIrdH07ZnVuY3Rpb24gbShlLHMsaSxhKXt2b2lkIDA9PT1hJiYoYT1cIiZcIik7dmFyIGM9ZS5yZXBsYWNlKGllLFwiXCIpLHU9cyYmaT9pK1wiIFwiK3MrXCIgeyBcIitjK1wiIH1cIjpjO3JldHVybiB0PWEsbj1zLHI9bmV3IFJlZ0V4cChcIlxcXFxcIituK1wiXFxcXGJcIixcImdcIiksbz1uZXcgUmVnRXhwKFwiKFxcXFxcIituK1wiXFxcXGIpezIsfVwiKSxsKGl8fCFzP1wiXCI6cyx1KX1yZXR1cm4gbC51c2UoW10uY29uY2F0KHUsW2Z1bmN0aW9uKGUsdCxvKXsyPT09ZSYmby5sZW5ndGgmJm9bMF0ubGFzdEluZGV4T2Yobik+MCYmKG9bMF09b1swXS5yZXBsYWNlKHIsZikpfSxoLGZ1bmN0aW9uKGUpe2lmKC0yPT09ZSl7dmFyIHQ9ZDtyZXR1cm4gZD1bXSx0fX1dKSksbS5oYXNoPXUubGVuZ3RoP3UucmVkdWNlKChmdW5jdGlvbihlLHQpe3JldHVybiB0Lm5hbWV8fGooMTUpLHRlKGUsdC5uYW1lKX0pLDUzODEpLnRvU3RyaW5nKCk6XCJcIixtfXZhciB1ZT1yLmNyZWF0ZUNvbnRleHQoKSxsZT11ZS5Db25zdW1lcixkZT1yLmNyZWF0ZUNvbnRleHQoKSxoZT0oZGUuQ29uc3VtZXIsbmV3IFopLHBlPWNlKCk7ZnVuY3Rpb24gZmUoKXtyZXR1cm4gcyh1ZSl8fGhlfWZ1bmN0aW9uIG1lKCl7cmV0dXJuIHMoZGUpfHxwZX1mdW5jdGlvbiB5ZShlKXt2YXIgdD1vKGUuc3R5bGlzUGx1Z2lucyksbj10WzBdLHM9dFsxXSxjPWZlKCksdT1pKChmdW5jdGlvbigpe3ZhciB0PWM7cmV0dXJuIGUuc2hlZXQ/dD1lLnNoZWV0OmUudGFyZ2V0JiYodD10LnJlY29uc3RydWN0V2l0aE9wdGlvbnMoe3RhcmdldDplLnRhcmdldH0sITEpKSxlLmRpc2FibGVDU1NPTUluamVjdGlvbiYmKHQ9dC5yZWNvbnN0cnVjdFdpdGhPcHRpb25zKHt1c2VDU1NPTUluamVjdGlvbjohMX0pKSx0fSksW2UuZGlzYWJsZUNTU09NSW5qZWN0aW9uLGUuc2hlZXQsZS50YXJnZXRdKSxsPWkoKGZ1bmN0aW9uKCl7cmV0dXJuIGNlKHtvcHRpb25zOntwcmVmaXg6IWUuZGlzYWJsZVZlbmRvclByZWZpeGVzfSxwbHVnaW5zOm59KX0pLFtlLmRpc2FibGVWZW5kb3JQcmVmaXhlcyxuXSk7cmV0dXJuIGEoKGZ1bmN0aW9uKCl7aChuLGUuc3R5bGlzUGx1Z2lucyl8fHMoZS5zdHlsaXNQbHVnaW5zKX0pLFtlLnN0eWxpc1BsdWdpbnNdKSxyLmNyZWF0ZUVsZW1lbnQodWUuUHJvdmlkZXIse3ZhbHVlOnV9LHIuY3JlYXRlRWxlbWVudChkZS5Qcm92aWRlcix7dmFsdWU6bH0sXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVj9yLkNoaWxkcmVuLm9ubHkoZS5jaGlsZHJlbik6ZS5jaGlsZHJlbikpfXZhciB2ZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt2YXIgbj10aGlzO3RoaXMuaW5qZWN0PWZ1bmN0aW9uKGUsdCl7dm9pZCAwPT09dCYmKHQ9cGUpO3ZhciByPW4ubmFtZSt0Lmhhc2g7ZS5oYXNOYW1lRm9ySWQobi5pZCxyKXx8ZS5pbnNlcnRSdWxlcyhuLmlkLHIsdChuLnJ1bGVzLHIsXCJAa2V5ZnJhbWVzXCIpKX0sdGhpcy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBqKDEyLFN0cmluZyhuLm5hbWUpKX0sdGhpcy5uYW1lPWUsdGhpcy5pZD1cInNjLWtleWZyYW1lcy1cIitlLHRoaXMucnVsZXM9dH1yZXR1cm4gZS5wcm90b3R5cGUuZ2V0TmFtZT1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9cGUpLHRoaXMubmFtZStlLmhhc2h9LGV9KCksZ2U9LyhbQS1aXSkvLFNlPS8oW0EtWl0pL2csd2U9L15tcy0vLEVlPWZ1bmN0aW9uKGUpe3JldHVyblwiLVwiK2UudG9Mb3dlckNhc2UoKX07ZnVuY3Rpb24gYmUoZSl7cmV0dXJuIGdlLnRlc3QoZSk/ZS5yZXBsYWNlKFNlLEVlKS5yZXBsYWNlKHdlLFwiLW1zLVwiKTplfXZhciBfZT1mdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZXx8ITE9PT1lfHxcIlwiPT09ZX07ZnVuY3Rpb24gTmUoZSxuLHIsbyl7aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKHZhciBzLGk9W10sYT0wLGM9ZS5sZW5ndGg7YTxjO2ErPTEpXCJcIiE9PShzPU5lKGVbYV0sbixyLG8pKSYmKEFycmF5LmlzQXJyYXkocyk/aS5wdXNoLmFwcGx5KGkscyk6aS5wdXNoKHMpKTtyZXR1cm4gaX1pZihfZShlKSlyZXR1cm5cIlwiO2lmKE4oZSkpcmV0dXJuXCIuXCIrZS5zdHlsZWRDb21wb25lbnRJZDtpZihiKGUpKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZihsPWUpfHxsLnByb3RvdHlwZSYmbC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudHx8IW4pcmV0dXJuIGU7dmFyIHU9ZShuKTtyZXR1cm5cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZ0KHUpJiZjb25zb2xlLndhcm4oXyhlKStcIiBpcyBub3QgYSBzdHlsZWQgY29tcG9uZW50IGFuZCBjYW5ub3QgYmUgcmVmZXJyZWQgdG8gdmlhIGNvbXBvbmVudCBzZWxlY3Rvci4gU2VlIGh0dHBzOi8vd3d3LnN0eWxlZC1jb21wb25lbnRzLmNvbS9kb2NzL2FkdmFuY2VkI3JlZmVycmluZy10by1vdGhlci1jb21wb25lbnRzIGZvciBtb3JlIGRldGFpbHMuXCIpLE5lKHUsbixyLG8pfXZhciBsO3JldHVybiBlIGluc3RhbmNlb2YgdmU/cj8oZS5pbmplY3QocixvKSxlLmdldE5hbWUobykpOmU6UyhlKT9mdW5jdGlvbiBlKHQsbil7dmFyIHIsbyxzPVtdO2Zvcih2YXIgaSBpbiB0KXQuaGFzT3duUHJvcGVydHkoaSkmJiFfZSh0W2ldKSYmKEFycmF5LmlzQXJyYXkodFtpXSkmJnRbaV0uaXNDc3N8fGIodFtpXSk/cy5wdXNoKGJlKGkpK1wiOlwiLHRbaV0sXCI7XCIpOlModFtpXSk/cy5wdXNoLmFwcGx5KHMsZSh0W2ldLGkpKTpzLnB1c2goYmUoaSkrXCI6IFwiKyhyPWksbnVsbD09KG89dFtpXSl8fFwiYm9vbGVhblwiPT10eXBlb2Ygb3x8XCJcIj09PW8/XCJcIjpcIm51bWJlclwiIT10eXBlb2Ygb3x8MD09PW98fHIgaW4gZj9TdHJpbmcobykudHJpbSgpOm8rXCJweFwiKStcIjtcIikpO3JldHVybiBuP1tuK1wiIHtcIl0uY29uY2F0KHMsW1wifVwiXSk6c30oZSk6ZS50b1N0cmluZygpfXZhciBBZT1mdW5jdGlvbihlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKSYmKGUuaXNDc3M9ITApLGV9O2Z1bmN0aW9uIENlKGUpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHQ+MT90LTE6MCkscj0xO3I8dDtyKyspbltyLTFdPWFyZ3VtZW50c1tyXTtyZXR1cm4gYihlKXx8UyhlKT9BZShOZShnKHcsW2VdLmNvbmNhdChuKSkpKTowPT09bi5sZW5ndGgmJjE9PT1lLmxlbmd0aCYmXCJzdHJpbmdcIj09dHlwZW9mIGVbMF0/ZTpBZShOZShnKGUsbikpKX12YXIgSWU9L2ludmFsaWQgaG9vayBjYWxsL2ksUGU9bmV3IFNldCxPZT1mdW5jdGlvbihlLHQpe2lmKFwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYpe3ZhciBuPVwiVGhlIGNvbXBvbmVudCBcIitlKyh0Pycgd2l0aCB0aGUgaWQgb2YgXCInK3QrJ1wiJzpcIlwiKStcIiBoYXMgYmVlbiBjcmVhdGVkIGR5bmFtaWNhbGx5LlxcbllvdSBtYXkgc2VlIHRoaXMgd2FybmluZyBiZWNhdXNlIHlvdSd2ZSBjYWxsZWQgc3R5bGVkIGluc2lkZSBhbm90aGVyIGNvbXBvbmVudC5cXG5UbyByZXNvbHZlIHRoaXMgb25seSBjcmVhdGUgbmV3IFN0eWxlZENvbXBvbmVudHMgb3V0c2lkZSBvZiBhbnkgcmVuZGVyIG1ldGhvZCBhbmQgZnVuY3Rpb24gY29tcG9uZW50LlwiLHI9Y29uc29sZS5lcnJvcjt0cnl7dmFyIG89ITA7Y29uc29sZS5lcnJvcj1mdW5jdGlvbihlKXtpZihJZS50ZXN0KGUpKW89ITEsUGUuZGVsZXRlKG4pO2Vsc2V7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgscz1uZXcgQXJyYXkodD4xP3QtMTowKSxpPTE7aTx0O2krKylzW2ktMV09YXJndW1lbnRzW2ldO3IuYXBwbHkodm9pZCAwLFtlXS5jb25jYXQocykpfX0sYygpLG8mJiFQZS5oYXMobikmJihjb25zb2xlLndhcm4obiksUGUuYWRkKG4pKX1jYXRjaChlKXtJZS50ZXN0KGUubWVzc2FnZSkmJlBlLmRlbGV0ZShuKX1maW5hbGx5e2NvbnNvbGUuZXJyb3I9cn19fSxSZT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPUUpLGUudGhlbWUhPT1uLnRoZW1lJiZlLnRoZW1lfHx0fHxuLnRoZW1lfSxEZT0vWyFcIiMkJSYnKCkqKywuLzo7PD0+P0BbXFxcXFxcXV5ge3x9fi1dKy9nLGplPS8oXi18LSQpL2c7ZnVuY3Rpb24gVGUoZSl7cmV0dXJuIGUucmVwbGFjZShEZSxcIi1cIikucmVwbGFjZShqZSxcIlwiKX12YXIgeGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGVlKG5lKGUpPj4+MCl9O2Z1bmN0aW9uIGtlKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlJiYoXCJwcm9kdWN0aW9uXCI9PT1wcm9jZXNzLmVudi5OT0RFX0VOVnx8ZS5jaGFyQXQoMCk9PT1lLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpKX12YXIgVmU9ZnVuY3Rpb24oZSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZXx8XCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lJiYhQXJyYXkuaXNBcnJheShlKX0sQmU9ZnVuY3Rpb24oZSl7cmV0dXJuXCJfX3Byb3RvX19cIiE9PWUmJlwiY29uc3RydWN0b3JcIiE9PWUmJlwicHJvdG90eXBlXCIhPT1lfTtmdW5jdGlvbiB6ZShlLHQsbil7dmFyIHI9ZVtuXTtWZSh0KSYmVmUocik/TWUocix0KTplW25dPXR9ZnVuY3Rpb24gTWUoZSl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsbj1uZXcgQXJyYXkodD4xP3QtMTowKSxyPTE7cjx0O3IrKyluW3ItMV09YXJndW1lbnRzW3JdO2Zvcih2YXIgbz0wLHM9bjtvPHMubGVuZ3RoO28rKyl7dmFyIGk9c1tvXTtpZihWZShpKSlmb3IodmFyIGEgaW4gaSlCZShhKSYmemUoZSxpW2FdLGEpfXJldHVybiBlfXZhciBHZT1yLmNyZWF0ZUNvbnRleHQoKSxMZT1HZS5Db25zdW1lcjtmdW5jdGlvbiBGZShlKXt2YXIgdD1zKEdlKSxuPWkoKGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7aWYoIWUpcmV0dXJuIGooMTQpO2lmKGIoZSkpe3ZhciBuPWUodCk7cmV0dXJuXCJwcm9kdWN0aW9uXCI9PT1wcm9jZXNzLmVudi5OT0RFX0VOVnx8bnVsbCE9PW4mJiFBcnJheS5pc0FycmF5KG4pJiZcIm9iamVjdFwiPT10eXBlb2Ygbj9uOmooNyl9cmV0dXJuIEFycmF5LmlzQXJyYXkoZSl8fFwib2JqZWN0XCIhPXR5cGVvZiBlP2ooOCk6dD92KHt9LHQse30sZSk6ZX0oZS50aGVtZSx0KX0pLFtlLnRoZW1lLHRdKTtyZXR1cm4gZS5jaGlsZHJlbj9yLmNyZWF0ZUVsZW1lbnQoR2UuUHJvdmlkZXIse3ZhbHVlOm59LGUuY2hpbGRyZW4pOm51bGx9dmFyIFllPXt9O2Z1bmN0aW9uIHFlKGUsdCxuKXt2YXIgbz1OKGUpLGk9IWtlKGUpLGE9dC5hdHRycyxjPXZvaWQgMD09PWE/dzphLGQ9dC5jb21wb25lbnRJZCxoPXZvaWQgMD09PWQ/ZnVuY3Rpb24oZSx0KXt2YXIgbj1cInN0cmluZ1wiIT10eXBlb2YgZT9cInNjXCI6VGUoZSk7WWVbbl09KFllW25dfHwwKSsxO3ZhciByPW4rXCItXCIreGUoXCI1LjMuM1wiK24rWWVbbl0pO3JldHVybiB0P3QrXCItXCIrcjpyfSh0LmRpc3BsYXlOYW1lLHQucGFyZW50Q29tcG9uZW50SWQpOmQscD10LmRpc3BsYXlOYW1lLGY9dm9pZCAwPT09cD9mdW5jdGlvbihlKXtyZXR1cm4ga2UoZSk/XCJzdHlsZWQuXCIrZTpcIlN0eWxlZChcIitfKGUpK1wiKVwifShlKTpwLGc9dC5kaXNwbGF5TmFtZSYmdC5jb21wb25lbnRJZD9UZSh0LmRpc3BsYXlOYW1lKStcIi1cIit0LmNvbXBvbmVudElkOnQuY29tcG9uZW50SWR8fGgsUz1vJiZlLmF0dHJzP0FycmF5LnByb3RvdHlwZS5jb25jYXQoZS5hdHRycyxjKS5maWx0ZXIoQm9vbGVhbik6YyxBPXQuc2hvdWxkRm9yd2FyZFByb3A7byYmZS5zaG91bGRGb3J3YXJkUHJvcCYmKEE9dC5zaG91bGRGb3J3YXJkUHJvcD9mdW5jdGlvbihuLHIsbyl7cmV0dXJuIGUuc2hvdWxkRm9yd2FyZFByb3AobixyLG8pJiZ0LnNob3VsZEZvcndhcmRQcm9wKG4scixvKX06ZS5zaG91bGRGb3J3YXJkUHJvcCk7dmFyIEMsST1uZXcgc2UobixnLG8/ZS5jb21wb25lbnRTdHlsZTp2b2lkIDApLFA9SS5pc1N0YXRpYyYmMD09PWMubGVuZ3RoLE89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSx0LG4scil7dmFyIG89ZS5hdHRycyxpPWUuY29tcG9uZW50U3R5bGUsYT1lLmRlZmF1bHRQcm9wcyxjPWUuZm9sZGVkQ29tcG9uZW50SWRzLGQ9ZS5zaG91bGRGb3J3YXJkUHJvcCxoPWUuc3R5bGVkQ29tcG9uZW50SWQscD1lLnRhcmdldDtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZsKGgpO3ZhciBmPWZ1bmN0aW9uKGUsdCxuKXt2b2lkIDA9PT1lJiYoZT1FKTt2YXIgcj12KHt9LHQse3RoZW1lOmV9KSxvPXt9O3JldHVybiBuLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciB0LG4scyxpPWU7Zm9yKHQgaW4gYihpKSYmKGk9aShyKSksaSlyW3RdPW9bdF09XCJjbGFzc05hbWVcIj09PXQ/KG49b1t0XSxzPWlbdF0sbiYmcz9uK1wiIFwiK3M6bnx8cyk6aVt0XX0pKSxbcixvXX0oUmUodCxzKEdlKSxhKXx8RSx0LG8pLHk9ZlswXSxnPWZbMV0sUz1mdW5jdGlvbihlLHQsbixyKXt2YXIgbz1mZSgpLHM9bWUoKSxpPXQ/ZS5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcyhFLG8scyk6ZS5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcyhuLG8scyk7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmbChpKSxcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiYhdCYmciYmcihpKSxpfShpLHIseSxcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WP2Uud2FyblRvb01hbnlDbGFzc2VzOnZvaWQgMCksdz1uLF89Zy4kYXN8fHQuJGFzfHxnLmFzfHx0LmFzfHxwLE49a2UoXyksQT1nIT09dD92KHt9LHQse30sZyk6dCxDPXt9O2Zvcih2YXIgSSBpbiBBKVwiJFwiIT09SVswXSYmXCJhc1wiIT09SSYmKFwiZm9yd2FyZGVkQXNcIj09PUk/Qy5hcz1BW0ldOihkP2QoSSxtLF8pOiFOfHxtKEkpKSYmKENbSV09QVtJXSkpO3JldHVybiB0LnN0eWxlJiZnLnN0eWxlIT09dC5zdHlsZSYmKEMuc3R5bGU9dih7fSx0LnN0eWxlLHt9LGcuc3R5bGUpKSxDLmNsYXNzTmFtZT1BcnJheS5wcm90b3R5cGUuY29uY2F0KGMsaCxTIT09aD9TOm51bGwsdC5jbGFzc05hbWUsZy5jbGFzc05hbWUpLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKSxDLnJlZj13LHUoXyxDKX0oQyxlLHQsUCl9O3JldHVybiBPLmRpc3BsYXlOYW1lPWYsKEM9ci5mb3J3YXJkUmVmKE8pKS5hdHRycz1TLEMuY29tcG9uZW50U3R5bGU9SSxDLmRpc3BsYXlOYW1lPWYsQy5zaG91bGRGb3J3YXJkUHJvcD1BLEMuZm9sZGVkQ29tcG9uZW50SWRzPW8/QXJyYXkucHJvdG90eXBlLmNvbmNhdChlLmZvbGRlZENvbXBvbmVudElkcyxlLnN0eWxlZENvbXBvbmVudElkKTp3LEMuc3R5bGVkQ29tcG9uZW50SWQ9ZyxDLnRhcmdldD1vP2UudGFyZ2V0OmUsQy53aXRoQ29tcG9uZW50PWZ1bmN0aW9uKGUpe3ZhciByPXQuY29tcG9uZW50SWQsbz1mdW5jdGlvbihlLHQpe2lmKG51bGw9PWUpcmV0dXJue307dmFyIG4scixvPXt9LHM9T2JqZWN0LmtleXMoZSk7Zm9yKHI9MDtyPHMubGVuZ3RoO3IrKyluPXNbcl0sdC5pbmRleE9mKG4pPj0wfHwob1tuXT1lW25dKTtyZXR1cm4gb30odCxbXCJjb21wb25lbnRJZFwiXSkscz1yJiZyK1wiLVwiKyhrZShlKT9lOlRlKF8oZSkpKTtyZXR1cm4gcWUoZSx2KHt9LG8se2F0dHJzOlMsY29tcG9uZW50SWQ6c30pLG4pfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoQyxcImRlZmF1bHRQcm9wc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZm9sZGVkRGVmYXVsdFByb3BzfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fZm9sZGVkRGVmYXVsdFByb3BzPW8/TWUoe30sZS5kZWZhdWx0UHJvcHMsdCk6dH19KSxcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiYoT2UoZixnKSxDLndhcm5Ub29NYW55Q2xhc3Nlcz1mdW5jdGlvbihlLHQpe3ZhciBuPXt9LHI9ITE7cmV0dXJuIGZ1bmN0aW9uKG8pe2lmKCFyJiYobltvXT0hMCxPYmplY3Qua2V5cyhuKS5sZW5ndGg+PTIwMCkpe3ZhciBzPXQ/JyB3aXRoIHRoZSBpZCBvZiBcIicrdCsnXCInOlwiXCI7Y29uc29sZS53YXJuKFwiT3ZlciAyMDAgY2xhc3NlcyB3ZXJlIGdlbmVyYXRlZCBmb3IgY29tcG9uZW50IFwiK2UrcytcIi5cXG5Db25zaWRlciB1c2luZyB0aGUgYXR0cnMgbWV0aG9kLCB0b2dldGhlciB3aXRoIGEgc3R5bGUgb2JqZWN0IGZvciBmcmVxdWVudGx5IGNoYW5nZWQgc3R5bGVzLlxcbkV4YW1wbGU6XFxuICBjb25zdCBDb21wb25lbnQgPSBzdHlsZWQuZGl2LmF0dHJzKHByb3BzID0+ICh7XFxuICAgIHN0eWxlOiB7XFxuICAgICAgYmFja2dyb3VuZDogcHJvcHMuYmFja2dyb3VuZCxcXG4gICAgfSxcXG4gIH0pKWB3aWR0aDogMTAwJTtgXFxuXFxuICA8Q29tcG9uZW50IC8+XCIpLHI9ITAsbj17fX19fShmLGcpKSxDLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCIuXCIrQy5zdHlsZWRDb21wb25lbnRJZH0saSYmeShDLGUse2F0dHJzOiEwLGNvbXBvbmVudFN0eWxlOiEwLGRpc3BsYXlOYW1lOiEwLGZvbGRlZENvbXBvbmVudElkczohMCxzaG91bGRGb3J3YXJkUHJvcDohMCxzdHlsZWRDb21wb25lbnRJZDohMCx0YXJnZXQ6ITAsd2l0aENvbXBvbmVudDohMH0pLEN9dmFyIEhlPWZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbiBlKHQscixvKXtpZih2b2lkIDA9PT1vJiYobz1FKSwhbihyKSlyZXR1cm4gaigxLFN0cmluZyhyKSk7dmFyIHM9ZnVuY3Rpb24oKXtyZXR1cm4gdChyLG8sQ2UuYXBwbHkodm9pZCAwLGFyZ3VtZW50cykpfTtyZXR1cm4gcy53aXRoQ29uZmlnPWZ1bmN0aW9uKG4pe3JldHVybiBlKHQscix2KHt9LG8se30sbikpfSxzLmF0dHJzPWZ1bmN0aW9uKG4pe3JldHVybiBlKHQscix2KHt9LG8se2F0dHJzOkFycmF5LnByb3RvdHlwZS5jb25jYXQoby5hdHRycyxuKS5maWx0ZXIoQm9vbGVhbil9KSl9LHN9KHFlLGUpfTtbXCJhXCIsXCJhYmJyXCIsXCJhZGRyZXNzXCIsXCJhcmVhXCIsXCJhcnRpY2xlXCIsXCJhc2lkZVwiLFwiYXVkaW9cIixcImJcIixcImJhc2VcIixcImJkaVwiLFwiYmRvXCIsXCJiaWdcIixcImJsb2NrcXVvdGVcIixcImJvZHlcIixcImJyXCIsXCJidXR0b25cIixcImNhbnZhc1wiLFwiY2FwdGlvblwiLFwiY2l0ZVwiLFwiY29kZVwiLFwiY29sXCIsXCJjb2xncm91cFwiLFwiZGF0YVwiLFwiZGF0YWxpc3RcIixcImRkXCIsXCJkZWxcIixcImRldGFpbHNcIixcImRmblwiLFwiZGlhbG9nXCIsXCJkaXZcIixcImRsXCIsXCJkdFwiLFwiZW1cIixcImVtYmVkXCIsXCJmaWVsZHNldFwiLFwiZmlnY2FwdGlvblwiLFwiZmlndXJlXCIsXCJmb290ZXJcIixcImZvcm1cIixcImgxXCIsXCJoMlwiLFwiaDNcIixcImg0XCIsXCJoNVwiLFwiaDZcIixcImhlYWRcIixcImhlYWRlclwiLFwiaGdyb3VwXCIsXCJoclwiLFwiaHRtbFwiLFwiaVwiLFwiaWZyYW1lXCIsXCJpbWdcIixcImlucHV0XCIsXCJpbnNcIixcImtiZFwiLFwia2V5Z2VuXCIsXCJsYWJlbFwiLFwibGVnZW5kXCIsXCJsaVwiLFwibGlua1wiLFwibWFpblwiLFwibWFwXCIsXCJtYXJrXCIsXCJtYXJxdWVlXCIsXCJtZW51XCIsXCJtZW51aXRlbVwiLFwibWV0YVwiLFwibWV0ZXJcIixcIm5hdlwiLFwibm9zY3JpcHRcIixcIm9iamVjdFwiLFwib2xcIixcIm9wdGdyb3VwXCIsXCJvcHRpb25cIixcIm91dHB1dFwiLFwicFwiLFwicGFyYW1cIixcInBpY3R1cmVcIixcInByZVwiLFwicHJvZ3Jlc3NcIixcInFcIixcInJwXCIsXCJydFwiLFwicnVieVwiLFwic1wiLFwic2FtcFwiLFwic2NyaXB0XCIsXCJzZWN0aW9uXCIsXCJzZWxlY3RcIixcInNtYWxsXCIsXCJzb3VyY2VcIixcInNwYW5cIixcInN0cm9uZ1wiLFwic3R5bGVcIixcInN1YlwiLFwic3VtbWFyeVwiLFwic3VwXCIsXCJ0YWJsZVwiLFwidGJvZHlcIixcInRkXCIsXCJ0ZXh0YXJlYVwiLFwidGZvb3RcIixcInRoXCIsXCJ0aGVhZFwiLFwidGltZVwiLFwidGl0bGVcIixcInRyXCIsXCJ0cmFja1wiLFwidVwiLFwidWxcIixcInZhclwiLFwidmlkZW9cIixcIndiclwiLFwiY2lyY2xlXCIsXCJjbGlwUGF0aFwiLFwiZGVmc1wiLFwiZWxsaXBzZVwiLFwiZm9yZWlnbk9iamVjdFwiLFwiZ1wiLFwiaW1hZ2VcIixcImxpbmVcIixcImxpbmVhckdyYWRpZW50XCIsXCJtYXJrZXJcIixcIm1hc2tcIixcInBhdGhcIixcInBhdHRlcm5cIixcInBvbHlnb25cIixcInBvbHlsaW5lXCIsXCJyYWRpYWxHcmFkaWVudFwiLFwicmVjdFwiLFwic3RvcFwiLFwic3ZnXCIsXCJ0ZXh0XCIsXCJ0ZXh0UGF0aFwiLFwidHNwYW5cIl0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7SGVbZV09SGUoZSl9KSk7dmFyICRlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3RoaXMucnVsZXM9ZSx0aGlzLmNvbXBvbmVudElkPXQsdGhpcy5pc1N0YXRpYz1yZShlKSxaLnJlZ2lzdGVySWQodGhpcy5jb21wb25lbnRJZCsxKX12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5jcmVhdGVTdHlsZXM9ZnVuY3Rpb24oZSx0LG4scil7dmFyIG89cihOZSh0aGlzLnJ1bGVzLHQsbixyKS5qb2luKFwiXCIpLFwiXCIpLHM9dGhpcy5jb21wb25lbnRJZCtlO24uaW5zZXJ0UnVsZXMocyxzLG8pfSx0LnJlbW92ZVN0eWxlcz1mdW5jdGlvbihlLHQpe3QuY2xlYXJSdWxlcyh0aGlzLmNvbXBvbmVudElkK2UpfSx0LnJlbmRlclN0eWxlcz1mdW5jdGlvbihlLHQsbixyKXtlPjImJloucmVnaXN0ZXJJZCh0aGlzLmNvbXBvbmVudElkK2UpLHRoaXMucmVtb3ZlU3R5bGVzKGUsbiksdGhpcy5jcmVhdGVTdHlsZXMoZSx0LG4scil9LGV9KCk7ZnVuY3Rpb24gV2UoZSl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsbj1uZXcgQXJyYXkodD4xP3QtMTowKSxvPTE7bzx0O28rKyluW28tMV09YXJndW1lbnRzW29dO3ZhciBpPUNlLmFwcGx5KHZvaWQgMCxbZV0uY29uY2F0KG4pKSxhPVwic2MtZ2xvYmFsLVwiK3hlKEpTT04uc3RyaW5naWZ5KGkpKSx1PW5ldyAkZShpLGEpO2Z1bmN0aW9uIGwoZSl7dmFyIHQ9ZmUoKSxuPW1lKCksbz1zKEdlKSxsPWModC5hbGxvY2F0ZUdTSW5zdGFuY2UoYSkpLmN1cnJlbnQ7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmci5DaGlsZHJlbi5jb3VudChlLmNoaWxkcmVuKSYmY29uc29sZS53YXJuKFwiVGhlIGdsb2JhbCBzdHlsZSBjb21wb25lbnQgXCIrYStcIiB3YXMgZ2l2ZW4gY2hpbGQgSlNYLiBjcmVhdGVHbG9iYWxTdHlsZSBkb2VzIG5vdCByZW5kZXIgY2hpbGRyZW4uXCIpLFwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJmkuc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGUmJi0xIT09ZS5pbmRleE9mKFwiQGltcG9ydFwiKX0pKSYmY29uc29sZS53YXJuKFwiUGxlYXNlIGRvIG5vdCB1c2UgQGltcG9ydCBDU1Mgc3ludGF4IGluIGNyZWF0ZUdsb2JhbFN0eWxlIGF0IHRoaXMgdGltZSwgYXMgdGhlIENTU09NIEFQSXMgd2UgdXNlIGluIHByb2R1Y3Rpb24gZG8gbm90IGhhbmRsZSBpdCB3ZWxsLiBJbnN0ZWFkLCB3ZSByZWNvbW1lbmQgdXNpbmcgYSBsaWJyYXJ5IHN1Y2ggYXMgcmVhY3QtaGVsbWV0IHRvIGluamVjdCBhIHR5cGljYWwgPGxpbms+IG1ldGEgdGFnIHRvIHRoZSBzdHlsZXNoZWV0LCBvciBzaW1wbHkgZW1iZWRkaW5nIGl0IG1hbnVhbGx5IGluIHlvdXIgaW5kZXguaHRtbCA8aGVhZD4gc2VjdGlvbiBmb3IgYSBzaW1wbGVyIGFwcC5cIiksdC5zZXJ2ZXImJmgobCxlLHQsbyxuKSxkKChmdW5jdGlvbigpe2lmKCF0LnNlcnZlcilyZXR1cm4gaChsLGUsdCxvLG4pLGZ1bmN0aW9uKCl7cmV0dXJuIHUucmVtb3ZlU3R5bGVzKGwsdCl9fSksW2wsZSx0LG8sbl0pLG51bGx9ZnVuY3Rpb24gaChlLHQsbixyLG8pe2lmKHUuaXNTdGF0aWMpdS5yZW5kZXJTdHlsZXMoZSxPLG4sbyk7ZWxzZXt2YXIgcz12KHt9LHQse3RoZW1lOlJlKHQscixsLmRlZmF1bHRQcm9wcyl9KTt1LnJlbmRlclN0eWxlcyhlLHMsbixvKX19cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmT2UoYSksci5tZW1vKGwpfWZ1bmN0aW9uIFVlKGUpe1wicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJlwiUmVhY3ROYXRpdmVcIj09PW5hdmlnYXRvci5wcm9kdWN0JiZjb25zb2xlLndhcm4oXCJga2V5ZnJhbWVzYCBjYW5ub3QgYmUgdXNlZCBvbiBSZWFjdE5hdGl2ZSwgb25seSBvbiB0aGUgd2ViLiBUbyBkbyBhbmltYXRpb24gaW4gUmVhY3ROYXRpdmUgcGxlYXNlIHVzZSBBbmltYXRlZC5cIik7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsbj1uZXcgQXJyYXkodD4xP3QtMTowKSxyPTE7cjx0O3IrKyluW3ItMV09YXJndW1lbnRzW3JdO3ZhciBvPUNlLmFwcGx5KHZvaWQgMCxbZV0uY29uY2F0KG4pKS5qb2luKFwiXCIpLHM9eGUobyk7cmV0dXJuIG5ldyB2ZShzLG8pfXZhciBKZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt2YXIgZT10aGlzO3RoaXMuX2VtaXRTaGVldENTUz1mdW5jdGlvbigpe3ZhciB0PWUuaW5zdGFuY2UudG9TdHJpbmcoKTtpZighdClyZXR1cm5cIlwiO3ZhciBuPXEoKTtyZXR1cm5cIjxzdHlsZSBcIitbbiYmJ25vbmNlPVwiJytuKydcIicsQSsnPVwidHJ1ZVwiJywnZGF0YS1zdHlsZWQtdmVyc2lvbj1cIjUuMy4zXCInXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIikrXCI+XCIrdCtcIjwvc3R5bGU+XCJ9LHRoaXMuZ2V0U3R5bGVUYWdzPWZ1bmN0aW9uKCl7cmV0dXJuIGUuc2VhbGVkP2ooMik6ZS5fZW1pdFNoZWV0Q1NTKCl9LHRoaXMuZ2V0U3R5bGVFbGVtZW50PWZ1bmN0aW9uKCl7dmFyIHQ7aWYoZS5zZWFsZWQpcmV0dXJuIGooMik7dmFyIG49KCh0PXt9KVtBXT1cIlwiLHRbXCJkYXRhLXN0eWxlZC12ZXJzaW9uXCJdPVwiNS4zLjNcIix0LmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXtfX2h0bWw6ZS5pbnN0YW5jZS50b1N0cmluZygpfSx0KSxvPXEoKTtyZXR1cm4gbyYmKG4ubm9uY2U9byksW3IuY3JlYXRlRWxlbWVudChcInN0eWxlXCIsdih7fSxuLHtrZXk6XCJzYy0wLTBcIn0pKV19LHRoaXMuc2VhbD1mdW5jdGlvbigpe2Uuc2VhbGVkPSEwfSx0aGlzLmluc3RhbmNlPW5ldyBaKHtpc1NlcnZlcjohMH0pLHRoaXMuc2VhbGVkPSExfXZhciB0PWUucHJvdG90eXBlO3JldHVybiB0LmNvbGxlY3RTdHlsZXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuc2VhbGVkP2ooMik6ci5jcmVhdGVFbGVtZW50KHllLHtzaGVldDp0aGlzLmluc3RhbmNlfSxlKX0sdC5pbnRlcmxlYXZlV2l0aE5vZGVTdHJlYW09ZnVuY3Rpb24oZSl7cmV0dXJuIGooMyl9LGV9KCksWGU9ZnVuY3Rpb24oZSl7dmFyIHQ9ci5mb3J3YXJkUmVmKChmdW5jdGlvbih0LG4pe3ZhciBvPXMoR2UpLGk9ZS5kZWZhdWx0UHJvcHMsYT1SZSh0LG8saSk7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmdm9pZCAwPT09YSYmY29uc29sZS53YXJuKCdbd2l0aFRoZW1lXSBZb3UgYXJlIG5vdCB1c2luZyBhIFRoZW1lUHJvdmlkZXIgbm9yIHBhc3NpbmcgYSB0aGVtZSBwcm9wIG9yIGEgdGhlbWUgaW4gZGVmYXVsdFByb3BzIGluIGNvbXBvbmVudCBjbGFzcyBcIicrXyhlKSsnXCInKSxyLmNyZWF0ZUVsZW1lbnQoZSx2KHt9LHQse3RoZW1lOmEscmVmOm59KSl9KSk7cmV0dXJuIHkodCxlKSx0LmRpc3BsYXlOYW1lPVwiV2l0aFRoZW1lKFwiK18oZSkrXCIpXCIsdH0sWmU9ZnVuY3Rpb24oKXtyZXR1cm4gcyhHZSl9LEtlPXtTdHlsZVNoZWV0OlosbWFzdGVyU2hlZXQ6aGV9O1wicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJlwiUmVhY3ROYXRpdmVcIj09PW5hdmlnYXRvci5wcm9kdWN0JiZjb25zb2xlLndhcm4oXCJJdCBsb29rcyBsaWtlIHlvdSd2ZSBpbXBvcnRlZCAnc3R5bGVkLWNvbXBvbmVudHMnIG9uIFJlYWN0IE5hdGl2ZS5cXG5QZXJoYXBzIHlvdSdyZSBsb29raW5nIHRvIGltcG9ydCAnc3R5bGVkLWNvbXBvbmVudHMvbmF0aXZlJz9cXG5SZWFkIG1vcmUgYWJvdXQgdGhpcyBhdCBodHRwczovL3d3dy5zdHlsZWQtY29tcG9uZW50cy5jb20vZG9jcy9iYXNpY3MjcmVhY3QtbmF0aXZlXCIpLFwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJlwidGVzdFwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJih3aW5kb3dbXCJfX3N0eWxlZC1jb21wb25lbnRzLWluaXRfX1wiXT13aW5kb3dbXCJfX3N0eWxlZC1jb21wb25lbnRzLWluaXRfX1wiXXx8MCwxPT09d2luZG93W1wiX19zdHlsZWQtY29tcG9uZW50cy1pbml0X19cIl0mJmNvbnNvbGUud2FybihcIkl0IGxvb2tzIGxpa2UgdGhlcmUgYXJlIHNldmVyYWwgaW5zdGFuY2VzIG9mICdzdHlsZWQtY29tcG9uZW50cycgaW5pdGlhbGl6ZWQgaW4gdGhpcyBhcHBsaWNhdGlvbi4gVGhpcyBtYXkgY2F1c2UgZHluYW1pYyBzdHlsZXMgdG8gbm90IHJlbmRlciBwcm9wZXJseSwgZXJyb3JzIGR1cmluZyB0aGUgcmVoeWRyYXRpb24gcHJvY2VzcywgYSBtaXNzaW5nIHRoZW1lIHByb3AsIGFuZCBtYWtlcyB5b3VyIGFwcGxpY2F0aW9uIGJpZ2dlciB3aXRob3V0IGdvb2QgcmVhc29uLlxcblxcblNlZSBodHRwczovL3MtYy5zaC8yQkFYemVkIGZvciBtb3JlIGluZm8uXCIpLHdpbmRvd1tcIl9fc3R5bGVkLWNvbXBvbmVudHMtaW5pdF9fXCJdKz0xKTtleHBvcnQgZGVmYXVsdCBIZTtleHBvcnR7SmUgYXMgU2VydmVyU3R5bGVTaGVldCxsZSBhcyBTdHlsZVNoZWV0Q29uc3VtZXIsdWUgYXMgU3R5bGVTaGVldENvbnRleHQseWUgYXMgU3R5bGVTaGVldE1hbmFnZXIsTGUgYXMgVGhlbWVDb25zdW1lcixHZSBhcyBUaGVtZUNvbnRleHQsRmUgYXMgVGhlbWVQcm92aWRlcixLZSBhcyBfX1BSSVZBVEVfXyxXZSBhcyBjcmVhdGVHbG9iYWxTdHlsZSxDZSBhcyBjc3MsTiBhcyBpc1N0eWxlZENvbXBvbmVudCxVZSBhcyBrZXlmcmFtZXMsWmUgYXMgdXNlVGhlbWUsQyBhcyB2ZXJzaW9uLFhlIGFzIHdpdGhUaGVtZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZWQtY29tcG9uZW50cy5icm93c2VyLmVzbS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlZC1jb21wb25lbnRzL2Rpc3Qvc3R5bGVkLWNvbXBvbmVudHMuYnJvd3Nlci5lc20uanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiAzIDUiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO3ZhciBiPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3IsYz1iP1N5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpOjYwMTAzLGQ9Yj9TeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpOjYwMTA2LGU9Yj9TeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik6NjAxMDcsZj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTo2MDEwOCxnPWI/U3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpOjYwMTE0LGg9Yj9TeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik6NjAxMDksaz1iP1N5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpOjYwMTEwLGw9Yj9TeW1ib2wuZm9yKFwicmVhY3QuYXN5bmNfbW9kZVwiKTo2MDExMSxtPWI/U3ltYm9sLmZvcihcInJlYWN0LmNvbmN1cnJlbnRfbW9kZVwiKTo2MDExMSxuPWI/U3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpOjYwMTEyLHA9Yj9TeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIik6NjAxMTMscT1iP1xuU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIik6NjAxMjAscj1iP1N5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpOjYwMTE1LHQ9Yj9TeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKTo2MDExNix2PWI/U3ltYm9sLmZvcihcInJlYWN0LmJsb2NrXCIpOjYwMTIxLHc9Yj9TeW1ib2wuZm9yKFwicmVhY3QuZnVuZGFtZW50YWxcIik6NjAxMTcseD1iP1N5bWJvbC5mb3IoXCJyZWFjdC5yZXNwb25kZXJcIik6NjAxMTgseT1iP1N5bWJvbC5mb3IoXCJyZWFjdC5zY29wZVwiKTo2MDExOTtcbmZ1bmN0aW9uIHooYSl7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSl7dmFyIHU9YS4kJHR5cGVvZjtzd2l0Y2godSl7Y2FzZSBjOnN3aXRjaChhPWEudHlwZSxhKXtjYXNlIGw6Y2FzZSBtOmNhc2UgZTpjYXNlIGc6Y2FzZSBmOmNhc2UgcDpyZXR1cm4gYTtkZWZhdWx0OnN3aXRjaChhPWEmJmEuJCR0eXBlb2YsYSl7Y2FzZSBrOmNhc2UgbjpjYXNlIHQ6Y2FzZSByOmNhc2UgaDpyZXR1cm4gYTtkZWZhdWx0OnJldHVybiB1fX1jYXNlIGQ6cmV0dXJuIHV9fX1mdW5jdGlvbiBBKGEpe3JldHVybiB6KGEpPT09bX1leHBvcnRzLkFzeW5jTW9kZT1sO2V4cG9ydHMuQ29uY3VycmVudE1vZGU9bTtleHBvcnRzLkNvbnRleHRDb25zdW1lcj1rO2V4cG9ydHMuQ29udGV4dFByb3ZpZGVyPWg7ZXhwb3J0cy5FbGVtZW50PWM7ZXhwb3J0cy5Gb3J3YXJkUmVmPW47ZXhwb3J0cy5GcmFnbWVudD1lO2V4cG9ydHMuTGF6eT10O2V4cG9ydHMuTWVtbz1yO2V4cG9ydHMuUG9ydGFsPWQ7XG5leHBvcnRzLlByb2ZpbGVyPWc7ZXhwb3J0cy5TdHJpY3RNb2RlPWY7ZXhwb3J0cy5TdXNwZW5zZT1wO2V4cG9ydHMuaXNBc3luY01vZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIEEoYSl8fHooYSk9PT1sfTtleHBvcnRzLmlzQ29uY3VycmVudE1vZGU9QTtleHBvcnRzLmlzQ29udGV4dENvbnN1bWVyPWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09a307ZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlcj1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWh9O2V4cG9ydHMuaXNFbGVtZW50PWZ1bmN0aW9uKGEpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJmEuJCR0eXBlb2Y9PT1jfTtleHBvcnRzLmlzRm9yd2FyZFJlZj1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PW59O2V4cG9ydHMuaXNGcmFnbWVudD1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWV9O2V4cG9ydHMuaXNMYXp5PWZ1bmN0aW9uKGEpe3JldHVybiB6KGEpPT09dH07XG5leHBvcnRzLmlzTWVtbz1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PXJ9O2V4cG9ydHMuaXNQb3J0YWw9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1kfTtleHBvcnRzLmlzUHJvZmlsZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIHooYSk9PT1nfTtleHBvcnRzLmlzU3RyaWN0TW9kZT1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PWZ9O2V4cG9ydHMuaXNTdXNwZW5zZT1mdW5jdGlvbihhKXtyZXR1cm4geihhKT09PXB9O1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGU9ZnVuY3Rpb24oYSl7cmV0dXJuXCJzdHJpbmdcIj09PXR5cGVvZiBhfHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgYXx8YT09PWV8fGE9PT1tfHxhPT09Z3x8YT09PWZ8fGE9PT1wfHxhPT09cXx8XCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmKGEuJCR0eXBlb2Y9PT10fHxhLiQkdHlwZW9mPT09cnx8YS4kJHR5cGVvZj09PWh8fGEuJCR0eXBlb2Y9PT1rfHxhLiQkdHlwZW9mPT09bnx8YS4kJHR5cGVvZj09PXd8fGEuJCR0eXBlb2Y9PT14fHxhLiQkdHlwZW9mPT09eXx8YS4kJHR5cGVvZj09PXYpfTtleHBvcnRzLnR5cGVPZj16O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGVkLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMjAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIDMgNSIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGVkLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMjAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIDMgNSIsIi8vXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIsIGNvbXBhcmUsIGNvbXBhcmVDb250ZXh0KSB7XG4gIHZhciByZXQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCBvYmpBLCBvYmpCKSA6IHZvaWQgMDtcblxuICBpZiAocmV0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gISFyZXQ7XG4gIH1cblxuICBpZiAob2JqQSA9PT0gb2JqQikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSBcIm9iamVjdFwiIHx8ICFvYmpBIHx8IHR5cGVvZiBvYmpCICE9PSBcIm9iamVjdFwiIHx8ICFvYmpCKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBiSGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmJpbmQob2JqQik7XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwga2V5c0EubGVuZ3RoOyBpZHgrKykge1xuICAgIHZhciBrZXkgPSBrZXlzQVtpZHhdO1xuXG4gICAgaWYgKCFiSGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZUEgPSBvYmpBW2tleV07XG4gICAgdmFyIHZhbHVlQiA9IG9iakJba2V5XTtcblxuICAgIHJldCA9IGNvbXBhcmUgPyBjb21wYXJlLmNhbGwoY29tcGFyZUNvbnRleHQsIHZhbHVlQSwgdmFsdWVCLCBrZXkpIDogdm9pZCAwO1xuXG4gICAgaWYgKHJldCA9PT0gZmFsc2UgfHwgKHJldCA9PT0gdm9pZCAwICYmIHZhbHVlQSAhPT0gdmFsdWVCKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NoYWxsb3dlcXVhbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIDMgNSIsImZ1bmN0aW9uIHN0eWxpc19taW4gKFcpIHtcbiAgZnVuY3Rpb24gTShkLCBjLCBlLCBoLCBhKSB7XG4gICAgZm9yICh2YXIgbSA9IDAsIGIgPSAwLCB2ID0gMCwgbiA9IDAsIHEsIGcsIHggPSAwLCBLID0gMCwgaywgdSA9IGsgPSBxID0gMCwgbCA9IDAsIHIgPSAwLCBJID0gMCwgdCA9IDAsIEIgPSBlLmxlbmd0aCwgSiA9IEIgLSAxLCB5LCBmID0gJycsIHAgPSAnJywgRiA9ICcnLCBHID0gJycsIEM7IGwgPCBCOykge1xuICAgICAgZyA9IGUuY2hhckNvZGVBdChsKTtcbiAgICAgIGwgPT09IEogJiYgMCAhPT0gYiArIG4gKyB2ICsgbSAmJiAoMCAhPT0gYiAmJiAoZyA9IDQ3ID09PSBiID8gMTAgOiA0NyksIG4gPSB2ID0gbSA9IDAsIEIrKywgSisrKTtcblxuICAgICAgaWYgKDAgPT09IGIgKyBuICsgdiArIG0pIHtcbiAgICAgICAgaWYgKGwgPT09IEogJiYgKDAgPCByICYmIChmID0gZi5yZXBsYWNlKE4sICcnKSksIDAgPCBmLnRyaW0oKS5sZW5ndGgpKSB7XG4gICAgICAgICAgc3dpdGNoIChnKSB7XG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgZiArPSBlLmNoYXJBdChsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnID0gNTk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGcpIHtcbiAgICAgICAgICBjYXNlIDEyMzpcbiAgICAgICAgICAgIGYgPSBmLnRyaW0oKTtcbiAgICAgICAgICAgIHEgPSBmLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBrID0gMTtcblxuICAgICAgICAgICAgZm9yICh0ID0gKytsOyBsIDwgQjspIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChnID0gZS5jaGFyQ29kZUF0KGwpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjM6XG4gICAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgMTI1OlxuICAgICAgICAgICAgICAgICAgay0tO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICAgICAgc3dpdGNoIChnID0gZS5jaGFyQ29kZUF0KGwgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodSA9IGwgKyAxOyB1IDwgSjsgKyt1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5jaGFyQ29kZUF0KHUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICg0MiA9PT0gZyAmJiA0MiA9PT0gZS5jaGFyQ29kZUF0KHUgLSAxKSAmJiBsICsgMiAhPT0gdSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gdSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICg0NyA9PT0gZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gdSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gdTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDkxOlxuICAgICAgICAgICAgICAgICAgZysrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgICAgICAgIGcrKztcblxuICAgICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBsKysgPCBKICYmIGUuY2hhckNvZGVBdChsKSAhPT0gZzspIHtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKDAgPT09IGspIGJyZWFrO1xuICAgICAgICAgICAgICBsKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGsgPSBlLnN1YnN0cmluZyh0LCBsKTtcbiAgICAgICAgICAgIDAgPT09IHEgJiYgKHEgPSAoZiA9IGYucmVwbGFjZShjYSwgJycpLnRyaW0oKSkuY2hhckNvZGVBdCgwKSk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAocSkge1xuICAgICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgICAgIDAgPCByICYmIChmID0gZi5yZXBsYWNlKE4sICcnKSk7XG4gICAgICAgICAgICAgICAgZyA9IGYuY2hhckNvZGVBdCgxKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAxMDA6XG4gICAgICAgICAgICAgICAgICBjYXNlIDEwOTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICAgICAgICAgICAgciA9IGM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByID0gTztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBrID0gTShjLCByLCBrLCBnLCBhICsgMSk7XG4gICAgICAgICAgICAgICAgdCA9IGsubGVuZ3RoO1xuICAgICAgICAgICAgICAgIDAgPCBBICYmIChyID0gWChPLCBmLCBJKSwgQyA9IEgoMywgaywgciwgYywgRCwgeiwgdCwgZywgYSwgaCksIGYgPSByLmpvaW4oJycpLCB2b2lkIDAgIT09IEMgJiYgMCA9PT0gKHQgPSAoayA9IEMudHJpbSgpKS5sZW5ndGgpICYmIChnID0gMCwgayA9ICcnKSk7XG4gICAgICAgICAgICAgICAgaWYgKDAgPCB0KSBzd2l0Y2ggKGcpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgICAgICAgICBmID0gZi5yZXBsYWNlKGRhLCBlYSk7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTAwOlxuICAgICAgICAgICAgICAgICAgY2FzZSAxMDk6XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ1OlxuICAgICAgICAgICAgICAgICAgICBrID0gZiArICd7JyArIGsgKyAnfSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDEwNzpcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYucmVwbGFjZShmYSwgJyQxICQyJyk7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBmICsgJ3snICsgayArICd9JztcbiAgICAgICAgICAgICAgICAgICAgayA9IDEgPT09IHcgfHwgMiA9PT0gdyAmJiBMKCdAJyArIGssIDMpID8gJ0Atd2Via2l0LScgKyBrICsgJ0AnICsgayA6ICdAJyArIGs7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBrID0gZiArIGssIDExMiA9PT0gaCAmJiAoayA9IChwICs9IGssICcnKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGsgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGsgPSBNKGMsIFgoYywgZiwgSSksIGssIGgsIGEgKyAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgRiArPSBrO1xuICAgICAgICAgICAgayA9IEkgPSByID0gdSA9IHEgPSAwO1xuICAgICAgICAgICAgZiA9ICcnO1xuICAgICAgICAgICAgZyA9IGUuY2hhckNvZGVBdCgrK2wpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEyNTpcbiAgICAgICAgICBjYXNlIDU5OlxuICAgICAgICAgICAgZiA9ICgwIDwgciA/IGYucmVwbGFjZShOLCAnJykgOiBmKS50cmltKCk7XG4gICAgICAgICAgICBpZiAoMSA8ICh0ID0gZi5sZW5ndGgpKSBzd2l0Y2ggKDAgPT09IHUgJiYgKHEgPSBmLmNoYXJDb2RlQXQoMCksIDQ1ID09PSBxIHx8IDk2IDwgcSAmJiAxMjMgPiBxKSAmJiAodCA9IChmID0gZi5yZXBsYWNlKCcgJywgJzonKSkubGVuZ3RoKSwgMCA8IEEgJiYgdm9pZCAwICE9PSAoQyA9IEgoMSwgZiwgYywgZCwgRCwgeiwgcC5sZW5ndGgsIGgsIGEsIGgpKSAmJiAwID09PSAodCA9IChmID0gQy50cmltKCkpLmxlbmd0aCkgJiYgKGYgPSAnXFx4MDBcXHgwMCcpLCBxID0gZi5jaGFyQ29kZUF0KDApLCBnID0gZi5jaGFyQ29kZUF0KDEpLCBxKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgICAgIGlmICgxMDUgPT09IGcgfHwgOTkgPT09IGcpIHtcbiAgICAgICAgICAgICAgICAgIEcgKz0gZiArIGUuY2hhckF0KGwpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgNTggIT09IGYuY2hhckNvZGVBdCh0IC0gMSkgJiYgKHAgKz0gUChmLCBxLCBnLCBmLmNoYXJDb2RlQXQoMikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEkgPSByID0gdSA9IHEgPSAwO1xuICAgICAgICAgICAgZiA9ICcnO1xuICAgICAgICAgICAgZyA9IGUuY2hhckNvZGVBdCgrK2wpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZykge1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIDQ3ID09PSBiID8gYiA9IDAgOiAwID09PSAxICsgcSAmJiAxMDcgIT09IGggJiYgMCA8IGYubGVuZ3RoICYmIChyID0gMSwgZiArPSAnXFx4MDAnKTtcbiAgICAgICAgICAwIDwgQSAqIFkgJiYgSCgwLCBmLCBjLCBkLCBELCB6LCBwLmxlbmd0aCwgaCwgYSwgaCk7XG4gICAgICAgICAgeiA9IDE7XG4gICAgICAgICAgRCsrO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNTk6XG4gICAgICAgIGNhc2UgMTI1OlxuICAgICAgICAgIGlmICgwID09PSBiICsgbiArIHYgKyBtKSB7XG4gICAgICAgICAgICB6Kys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB6Kys7XG4gICAgICAgICAgeSA9IGUuY2hhckF0KGwpO1xuXG4gICAgICAgICAgc3dpdGNoIChnKSB7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICBpZiAoMCA9PT0gbiArIG0gKyBiKSBzd2l0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTg6XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgICB5ID0gJyc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAzMiAhPT0gZyAmJiAoeSA9ICcgJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgeSA9ICdcXFxcMCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICB5ID0gJ1xcXFxmJztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIHkgPSAnXFxcXHYnO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgMCA9PT0gbiArIGIgKyBtICYmIChyID0gSSA9IDEsIHkgPSAnXFxmJyArIHkpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMDg6XG4gICAgICAgICAgICAgIGlmICgwID09PSBuICsgYiArIG0gKyBFICYmIDAgPCB1KSBzd2l0Y2ggKGwgLSB1KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgMTEyID09PSB4ICYmIDU4ID09PSBlLmNoYXJDb2RlQXQobCAtIDMpICYmIChFID0geCk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAxMTEgPT09IEsgJiYgKEUgPSBLKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA1ODpcbiAgICAgICAgICAgICAgMCA9PT0gbiArIGIgKyBtICYmICh1ID0gbCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgICAwID09PSBiICsgdiArIG4gKyBtICYmIChyID0gMSwgeSArPSAnXFxyJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgMCA9PT0gYiAmJiAobiA9IG4gPT09IGcgPyAwIDogMCA9PT0gbiA/IGcgOiBuKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgOTE6XG4gICAgICAgICAgICAgIDAgPT09IG4gKyBiICsgdiAmJiBtKys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDkzOlxuICAgICAgICAgICAgICAwID09PSBuICsgYiArIHYgJiYgbS0tO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA0MTpcbiAgICAgICAgICAgICAgMCA9PT0gbiArIGIgKyBtICYmIHYtLTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAgIGlmICgwID09PSBuICsgYiArIG0pIHtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gcSkgc3dpdGNoICgyICogeCArIDMgKiBLKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDUzMzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHEgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2Kys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICAgICAgMCA9PT0gYiArIHYgKyBuICsgbSArIHUgKyBrICYmIChrID0gMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAgICAgaWYgKCEoMCA8IG4gKyBtICsgdikpIHN3aXRjaCAoYikge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoMiAqIGcgKyAzICogZS5jaGFyQ29kZUF0KGwgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIzNTpcbiAgICAgICAgICAgICAgICAgICAgICBiID0gNDc7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMjA6XG4gICAgICAgICAgICAgICAgICAgICAgdCA9IGwsIGIgPSA0MjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgICAgICAgNDcgPT09IGcgJiYgNDIgPT09IHggJiYgdCArIDIgIT09IGwgJiYgKDMzID09PSBlLmNoYXJDb2RlQXQodCArIDIpICYmIChwICs9IGUuc3Vic3RyaW5nKHQsIGwgKyAxKSksIHkgPSAnJywgYiA9IDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgMCA9PT0gYiAmJiAoZiArPSB5KTtcbiAgICAgIH1cblxuICAgICAgSyA9IHg7XG4gICAgICB4ID0gZztcbiAgICAgIGwrKztcbiAgICB9XG5cbiAgICB0ID0gcC5sZW5ndGg7XG5cbiAgICBpZiAoMCA8IHQpIHtcbiAgICAgIHIgPSBjO1xuICAgICAgaWYgKDAgPCBBICYmIChDID0gSCgyLCBwLCByLCBkLCBELCB6LCB0LCBoLCBhLCBoKSwgdm9pZCAwICE9PSBDICYmIDAgPT09IChwID0gQykubGVuZ3RoKSkgcmV0dXJuIEcgKyBwICsgRjtcbiAgICAgIHAgPSByLmpvaW4oJywnKSArICd7JyArIHAgKyAnfSc7XG5cbiAgICAgIGlmICgwICE9PSB3ICogRSkge1xuICAgICAgICAyICE9PSB3IHx8IEwocCwgMikgfHwgKEUgPSAwKTtcblxuICAgICAgICBzd2l0Y2ggKEUpIHtcbiAgICAgICAgICBjYXNlIDExMTpcbiAgICAgICAgICAgIHAgPSBwLnJlcGxhY2UoaGEsICc6LW1vei0kMScpICsgcDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMTI6XG4gICAgICAgICAgICBwID0gcC5yZXBsYWNlKFEsICc6Oi13ZWJraXQtaW5wdXQtJDEnKSArIHAucmVwbGFjZShRLCAnOjotbW96LSQxJykgKyBwLnJlcGxhY2UoUSwgJzotbXMtaW5wdXQtJDEnKSArIHA7XG4gICAgICAgIH1cblxuICAgICAgICBFID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gRyArIHAgKyBGO1xuICB9XG5cbiAgZnVuY3Rpb24gWChkLCBjLCBlKSB7XG4gICAgdmFyIGggPSBjLnRyaW0oKS5zcGxpdChpYSk7XG4gICAgYyA9IGg7XG4gICAgdmFyIGEgPSBoLmxlbmd0aCxcbiAgICAgICAgbSA9IGQubGVuZ3RoO1xuXG4gICAgc3dpdGNoIChtKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHZhciBiID0gMDtcblxuICAgICAgICBmb3IgKGQgPSAwID09PSBtID8gJycgOiBkWzBdICsgJyAnOyBiIDwgYTsgKytiKSB7XG4gICAgICAgICAgY1tiXSA9IFooZCwgY1tiXSwgZSkudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciB2ID0gYiA9IDA7XG5cbiAgICAgICAgZm9yIChjID0gW107IGIgPCBhOyArK2IpIHtcbiAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IG07ICsrbikge1xuICAgICAgICAgICAgY1t2KytdID0gWihkW25dICsgJyAnLCBoW2JdLCBlKS50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIGZ1bmN0aW9uIFooZCwgYywgZSkge1xuICAgIHZhciBoID0gYy5jaGFyQ29kZUF0KDApO1xuICAgIDMzID4gaCAmJiAoaCA9IChjID0gYy50cmltKCkpLmNoYXJDb2RlQXQoMCkpO1xuXG4gICAgc3dpdGNoIChoKSB7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICByZXR1cm4gYy5yZXBsYWNlKEYsICckMScgKyBkLnRyaW0oKSk7XG5cbiAgICAgIGNhc2UgNTg6XG4gICAgICAgIHJldHVybiBkLnRyaW0oKSArIGMucmVwbGFjZShGLCAnJDEnICsgZC50cmltKCkpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoMCA8IDEgKiBlICYmIDAgPCBjLmluZGV4T2YoJ1xcZicpKSByZXR1cm4gYy5yZXBsYWNlKEYsICg1OCA9PT0gZC5jaGFyQ29kZUF0KDApID8gJycgOiAnJDEnKSArIGQudHJpbSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZCArIGM7XG4gIH1cblxuICBmdW5jdGlvbiBQKGQsIGMsIGUsIGgpIHtcbiAgICB2YXIgYSA9IGQgKyAnOycsXG4gICAgICAgIG0gPSAyICogYyArIDMgKiBlICsgNCAqIGg7XG5cbiAgICBpZiAoOTQ0ID09PSBtKSB7XG4gICAgICBkID0gYS5pbmRleE9mKCc6JywgOSkgKyAxO1xuICAgICAgdmFyIGIgPSBhLnN1YnN0cmluZyhkLCBhLmxlbmd0aCAtIDEpLnRyaW0oKTtcbiAgICAgIGIgPSBhLnN1YnN0cmluZygwLCBkKS50cmltKCkgKyBiICsgJzsnO1xuICAgICAgcmV0dXJuIDEgPT09IHcgfHwgMiA9PT0gdyAmJiBMKGIsIDEpID8gJy13ZWJraXQtJyArIGIgKyBiIDogYjtcbiAgICB9XG5cbiAgICBpZiAoMCA9PT0gdyB8fCAyID09PSB3ICYmICFMKGEsIDEpKSByZXR1cm4gYTtcblxuICAgIHN3aXRjaCAobSkge1xuICAgICAgY2FzZSAxMDE1OlxuICAgICAgICByZXR1cm4gOTcgPT09IGEuY2hhckNvZGVBdCgxMCkgPyAnLXdlYmtpdC0nICsgYSArIGEgOiBhO1xuXG4gICAgICBjYXNlIDk1MTpcbiAgICAgICAgcmV0dXJuIDExNiA9PT0gYS5jaGFyQ29kZUF0KDMpID8gJy13ZWJraXQtJyArIGEgKyBhIDogYTtcblxuICAgICAgY2FzZSA5NjM6XG4gICAgICAgIHJldHVybiAxMTAgPT09IGEuY2hhckNvZGVBdCg1KSA/ICctd2Via2l0LScgKyBhICsgYSA6IGE7XG5cbiAgICAgIGNhc2UgMTAwOTpcbiAgICAgICAgaWYgKDEwMCAhPT0gYS5jaGFyQ29kZUF0KDQpKSBicmVhaztcblxuICAgICAgY2FzZSA5Njk6XG4gICAgICBjYXNlIDk0MjpcbiAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgYTtcblxuICAgICAgY2FzZSA5Nzg6XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbW96LScgKyBhICsgYTtcblxuICAgICAgY2FzZSAxMDE5OlxuICAgICAgY2FzZSA5ODM6XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbW96LScgKyBhICsgJy1tcy0nICsgYSArIGE7XG5cbiAgICAgIGNhc2UgODgzOlxuICAgICAgICBpZiAoNDUgPT09IGEuY2hhckNvZGVBdCg4KSkgcmV0dXJuICctd2Via2l0LScgKyBhICsgYTtcbiAgICAgICAgaWYgKDAgPCBhLmluZGV4T2YoJ2ltYWdlLXNldCgnLCAxMSkpIHJldHVybiBhLnJlcGxhY2UoamEsICckMS13ZWJraXQtJDInKSArIGE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDkzMjpcbiAgICAgICAgaWYgKDQ1ID09PSBhLmNoYXJDb2RlQXQoNCkpIHN3aXRjaCAoYS5jaGFyQ29kZUF0KDUpKSB7XG4gICAgICAgICAgY2FzZSAxMDM6XG4gICAgICAgICAgICByZXR1cm4gJy13ZWJraXQtYm94LScgKyBhLnJlcGxhY2UoJy1ncm93JywgJycpICsgJy13ZWJraXQtJyArIGEgKyAnLW1zLScgKyBhLnJlcGxhY2UoJ2dyb3cnLCAncG9zaXRpdmUnKSArIGE7XG5cbiAgICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtJyArIGEucmVwbGFjZSgnc2hyaW5rJywgJ25lZ2F0aXZlJykgKyBhO1xuXG4gICAgICAgICAgY2FzZSA5ODpcbiAgICAgICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtJyArIGEucmVwbGFjZSgnYmFzaXMnLCAncHJlZmVycmVkLXNpemUnKSArIGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tcy0nICsgYSArIGE7XG5cbiAgICAgIGNhc2UgOTY0OlxuICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1zLWZsZXgtJyArIGEgKyBhO1xuXG4gICAgICBjYXNlIDEwMjM6XG4gICAgICAgIGlmICg5OSAhPT0gYS5jaGFyQ29kZUF0KDgpKSBicmVhaztcbiAgICAgICAgYiA9IGEuc3Vic3RyaW5nKGEuaW5kZXhPZignOicsIDE1KSkucmVwbGFjZSgnZmxleC0nLCAnJykucmVwbGFjZSgnc3BhY2UtYmV0d2VlbicsICdqdXN0aWZ5Jyk7XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC1ib3gtcGFjaycgKyBiICsgJy13ZWJraXQtJyArIGEgKyAnLW1zLWZsZXgtcGFjaycgKyBiICsgYTtcblxuICAgICAgY2FzZSAxMDA1OlxuICAgICAgICByZXR1cm4ga2EudGVzdChhKSA/IGEucmVwbGFjZShhYSwgJzotd2Via2l0LScpICsgYS5yZXBsYWNlKGFhLCAnOi1tb3otJykgKyBhIDogYTtcblxuICAgICAgY2FzZSAxZTM6XG4gICAgICAgIGIgPSBhLnN1YnN0cmluZygxMykudHJpbSgpO1xuICAgICAgICBjID0gYi5pbmRleE9mKCctJykgKyAxO1xuXG4gICAgICAgIHN3aXRjaCAoYi5jaGFyQ29kZUF0KDApICsgYi5jaGFyQ29kZUF0KGMpKSB7XG4gICAgICAgICAgY2FzZSAyMjY6XG4gICAgICAgICAgICBiID0gYS5yZXBsYWNlKEcsICd0YicpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIzMjpcbiAgICAgICAgICAgIGIgPSBhLnJlcGxhY2UoRywgJ3RiLXJsJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjIwOlxuICAgICAgICAgICAgYiA9IGEucmVwbGFjZShHLCAnbHInKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tcy0nICsgYiArIGE7XG5cbiAgICAgIGNhc2UgMTAxNzpcbiAgICAgICAgaWYgKC0xID09PSBhLmluZGV4T2YoJ3N0aWNreScsIDkpKSBicmVhaztcblxuICAgICAgY2FzZSA5NzU6XG4gICAgICAgIGMgPSAoYSA9IGQpLmxlbmd0aCAtIDEwO1xuICAgICAgICBiID0gKDMzID09PSBhLmNoYXJDb2RlQXQoYykgPyBhLnN1YnN0cmluZygwLCBjKSA6IGEpLnN1YnN0cmluZyhkLmluZGV4T2YoJzonLCA3KSArIDEpLnRyaW0oKTtcblxuICAgICAgICBzd2l0Y2ggKG0gPSBiLmNoYXJDb2RlQXQoMCkgKyAoYi5jaGFyQ29kZUF0KDcpIHwgMCkpIHtcbiAgICAgICAgICBjYXNlIDIwMzpcbiAgICAgICAgICAgIGlmICgxMTEgPiBiLmNoYXJDb2RlQXQoOCkpIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICBhID0gYS5yZXBsYWNlKGIsICctd2Via2l0LScgKyBiKSArICc7JyArIGE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjA3OlxuICAgICAgICAgIGNhc2UgMTAyOlxuICAgICAgICAgICAgYSA9IGEucmVwbGFjZShiLCAnLXdlYmtpdC0nICsgKDEwMiA8IG0gPyAnaW5saW5lLScgOiAnJykgKyAnYm94JykgKyAnOycgKyBhLnJlcGxhY2UoYiwgJy13ZWJraXQtJyArIGIpICsgJzsnICsgYS5yZXBsYWNlKGIsICctbXMtJyArIGIgKyAnYm94JykgKyAnOycgKyBhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEgKyAnOyc7XG5cbiAgICAgIGNhc2UgOTM4OlxuICAgICAgICBpZiAoNDUgPT09IGEuY2hhckNvZGVBdCg1KSkgc3dpdGNoIChhLmNoYXJDb2RlQXQoNikpIHtcbiAgICAgICAgICBjYXNlIDEwNTpcbiAgICAgICAgICAgIHJldHVybiBiID0gYS5yZXBsYWNlKCctaXRlbXMnLCAnJyksICctd2Via2l0LScgKyBhICsgJy13ZWJraXQtYm94LScgKyBiICsgJy1tcy1mbGV4LScgKyBiICsgYTtcblxuICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tcy1mbGV4LWl0ZW0tJyArIGEucmVwbGFjZShiYSwgJycpICsgYTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1zLWZsZXgtbGluZS1wYWNrJyArIGEucmVwbGFjZSgnYWxpZ24tY29udGVudCcsICcnKS5yZXBsYWNlKGJhLCAnJykgKyBhO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDk3MzpcbiAgICAgIGNhc2UgOTg5OlxuICAgICAgICBpZiAoNDUgIT09IGEuY2hhckNvZGVBdCgzKSB8fCAxMjIgPT09IGEuY2hhckNvZGVBdCg0KSkgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTMxOlxuICAgICAgY2FzZSA5NTM6XG4gICAgICAgIGlmICghMCA9PT0gbGEudGVzdChkKSkgcmV0dXJuIDExNSA9PT0gKGIgPSBkLnN1YnN0cmluZyhkLmluZGV4T2YoJzonKSArIDEpKS5jaGFyQ29kZUF0KDApID8gUChkLnJlcGxhY2UoJ3N0cmV0Y2gnLCAnZmlsbC1hdmFpbGFibGUnKSwgYywgZSwgaCkucmVwbGFjZSgnOmZpbGwtYXZhaWxhYmxlJywgJzpzdHJldGNoJykgOiBhLnJlcGxhY2UoYiwgJy13ZWJraXQtJyArIGIpICsgYS5yZXBsYWNlKGIsICctbW96LScgKyBiLnJlcGxhY2UoJ2ZpbGwtJywgJycpKSArIGE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDk2MjpcbiAgICAgICAgaWYgKGEgPSAnLXdlYmtpdC0nICsgYSArICgxMDIgPT09IGEuY2hhckNvZGVBdCg1KSA/ICctbXMtJyArIGEgOiAnJykgKyBhLCAyMTEgPT09IGUgKyBoICYmIDEwNSA9PT0gYS5jaGFyQ29kZUF0KDEzKSAmJiAwIDwgYS5pbmRleE9mKCd0cmFuc2Zvcm0nLCAxMCkpIHJldHVybiBhLnN1YnN0cmluZygwLCBhLmluZGV4T2YoJzsnLCAyNykgKyAxKS5yZXBsYWNlKG1hLCAnJDEtd2Via2l0LSQyJykgKyBhO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9XG5cbiAgZnVuY3Rpb24gTChkLCBjKSB7XG4gICAgdmFyIGUgPSBkLmluZGV4T2YoMSA9PT0gYyA/ICc6JyA6ICd7JyksXG4gICAgICAgIGggPSBkLnN1YnN0cmluZygwLCAzICE9PSBjID8gZSA6IDEwKTtcbiAgICBlID0gZC5zdWJzdHJpbmcoZSArIDEsIGQubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIFIoMiAhPT0gYyA/IGggOiBoLnJlcGxhY2UobmEsICckMScpLCBlLCBjKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVhKGQsIGMpIHtcbiAgICB2YXIgZSA9IFAoYywgYy5jaGFyQ29kZUF0KDApLCBjLmNoYXJDb2RlQXQoMSksIGMuY2hhckNvZGVBdCgyKSk7XG4gICAgcmV0dXJuIGUgIT09IGMgKyAnOycgPyBlLnJlcGxhY2Uob2EsICcgb3IgKCQxKScpLnN1YnN0cmluZyg0KSA6ICcoJyArIGMgKyAnKSc7XG4gIH1cblxuICBmdW5jdGlvbiBIKGQsIGMsIGUsIGgsIGEsIG0sIGIsIHYsIG4sIHEpIHtcbiAgICBmb3IgKHZhciBnID0gMCwgeCA9IGMsIHc7IGcgPCBBOyArK2cpIHtcbiAgICAgIHN3aXRjaCAodyA9IFNbZ10uY2FsbChCLCBkLCB4LCBlLCBoLCBhLCBtLCBiLCB2LCBuLCBxKSkge1xuICAgICAgICBjYXNlIHZvaWQgMDpcbiAgICAgICAgY2FzZSAhMTpcbiAgICAgICAgY2FzZSAhMDpcbiAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgeCA9IHc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHggIT09IGMpIHJldHVybiB4O1xuICB9XG5cbiAgZnVuY3Rpb24gVChkKSB7XG4gICAgc3dpdGNoIChkKSB7XG4gICAgICBjYXNlIHZvaWQgMDpcbiAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgQSA9IFMubGVuZ3RoID0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZCkgU1tBKytdID0gZDtlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIGQpIGZvciAodmFyIGMgPSAwLCBlID0gZC5sZW5ndGg7IGMgPCBlOyArK2MpIHtcbiAgICAgICAgICBUKGRbY10pO1xuICAgICAgICB9IGVsc2UgWSA9ICEhZCB8IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIFQ7XG4gIH1cblxuICBmdW5jdGlvbiBVKGQpIHtcbiAgICBkID0gZC5wcmVmaXg7XG4gICAgdm9pZCAwICE9PSBkICYmIChSID0gbnVsbCwgZCA/ICdmdW5jdGlvbicgIT09IHR5cGVvZiBkID8gdyA9IDEgOiAodyA9IDIsIFIgPSBkKSA6IHcgPSAwKTtcbiAgICByZXR1cm4gVTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEIoZCwgYykge1xuICAgIHZhciBlID0gZDtcbiAgICAzMyA+IGUuY2hhckNvZGVBdCgwKSAmJiAoZSA9IGUudHJpbSgpKTtcbiAgICBWID0gZTtcbiAgICBlID0gW1ZdO1xuXG4gICAgaWYgKDAgPCBBKSB7XG4gICAgICB2YXIgaCA9IEgoLTEsIGMsIGUsIGUsIEQsIHosIDAsIDAsIDAsIDApO1xuICAgICAgdm9pZCAwICE9PSBoICYmICdzdHJpbmcnID09PSB0eXBlb2YgaCAmJiAoYyA9IGgpO1xuICAgIH1cblxuICAgIHZhciBhID0gTShPLCBlLCBjLCAwLCAwKTtcbiAgICAwIDwgQSAmJiAoaCA9IEgoLTIsIGEsIGUsIGUsIEQsIHosIGEubGVuZ3RoLCAwLCAwLCAwKSwgdm9pZCAwICE9PSBoICYmIChhID0gaCkpO1xuICAgIFYgPSAnJztcbiAgICBFID0gMDtcbiAgICB6ID0gRCA9IDE7XG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICB2YXIgY2EgPSAvXlxcMCsvZyxcbiAgICAgIE4gPSAvW1xcMFxcclxcZl0vZyxcbiAgICAgIGFhID0gLzogKi9nLFxuICAgICAga2EgPSAvem9vfGdyYS8sXG4gICAgICBtYSA9IC8oWyw6IF0pKHRyYW5zZm9ybSkvZyxcbiAgICAgIGlhID0gLyxcXHIrPy9nLFxuICAgICAgRiA9IC8oW1xcdFxcclxcbiBdKSpcXGY/Ji9nLFxuICAgICAgZmEgPSAvQChrXFx3KylcXHMqKFxcUyopXFxzKi8sXG4gICAgICBRID0gLzo6KHBsYWNlKS9nLFxuICAgICAgaGEgPSAvOihyZWFkLW9ubHkpL2csXG4gICAgICBHID0gL1tzdmhdXFx3Ky1bdGJscl17Mn0vLFxuICAgICAgZGEgPSAvXFwoXFxzKiguKilcXHMqXFwpL2csXG4gICAgICBvYSA9IC8oW1xcc1xcU10qPyk7L2csXG4gICAgICBiYSA9IC8tc2VsZnxmbGV4LS9nLFxuICAgICAgbmEgPSAvW15dKj8oOltycF1bZWxdYVtcXHctXSspW15dKi8sXG4gICAgICBsYSA9IC9zdHJldGNofDpcXHMqXFx3K1xcLSg/OmNvbnRlfGF2YWlsKS8sXG4gICAgICBqYSA9IC8oW14tXSkoaW1hZ2Utc2V0XFwoKS8sXG4gICAgICB6ID0gMSxcbiAgICAgIEQgPSAxLFxuICAgICAgRSA9IDAsXG4gICAgICB3ID0gMSxcbiAgICAgIE8gPSBbXSxcbiAgICAgIFMgPSBbXSxcbiAgICAgIEEgPSAwLFxuICAgICAgUiA9IG51bGwsXG4gICAgICBZID0gMCxcbiAgICAgIFYgPSAnJztcbiAgQi51c2UgPSBUO1xuICBCLnNldCA9IFU7XG4gIHZvaWQgMCAhPT0gVyAmJiBVKFcpO1xuICByZXR1cm4gQjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R5bGlzX21pbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL3N0eWxpcy9kaXN0L3N0eWxpcy5icm93c2VyLmVzbS5qc1xuLy8gbW9kdWxlIGlkID0gMjAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSAyIDMgNSIsInZhciB1bml0bGVzc0tleXMgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiAxLFxuICBib3JkZXJJbWFnZU91dHNldDogMSxcbiAgYm9yZGVySW1hZ2VTbGljZTogMSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogMSxcbiAgYm94RmxleDogMSxcbiAgYm94RmxleEdyb3VwOiAxLFxuICBib3hPcmRpbmFsR3JvdXA6IDEsXG4gIGNvbHVtbkNvdW50OiAxLFxuICBjb2x1bW5zOiAxLFxuICBmbGV4OiAxLFxuICBmbGV4R3JvdzogMSxcbiAgZmxleFBvc2l0aXZlOiAxLFxuICBmbGV4U2hyaW5rOiAxLFxuICBmbGV4TmVnYXRpdmU6IDEsXG4gIGZsZXhPcmRlcjogMSxcbiAgZ3JpZFJvdzogMSxcbiAgZ3JpZFJvd0VuZDogMSxcbiAgZ3JpZFJvd1NwYW46IDEsXG4gIGdyaWRSb3dTdGFydDogMSxcbiAgZ3JpZENvbHVtbjogMSxcbiAgZ3JpZENvbHVtbkVuZDogMSxcbiAgZ3JpZENvbHVtblNwYW46IDEsXG4gIGdyaWRDb2x1bW5TdGFydDogMSxcbiAgbXNHcmlkUm93OiAxLFxuICBtc0dyaWRSb3dTcGFuOiAxLFxuICBtc0dyaWRDb2x1bW46IDEsXG4gIG1zR3JpZENvbHVtblNwYW46IDEsXG4gIGZvbnRXZWlnaHQ6IDEsXG4gIGxpbmVIZWlnaHQ6IDEsXG4gIG9wYWNpdHk6IDEsXG4gIG9yZGVyOiAxLFxuICBvcnBoYW5zOiAxLFxuICB0YWJTaXplOiAxLFxuICB3aWRvd3M6IDEsXG4gIHpJbmRleDogMSxcbiAgem9vbTogMSxcbiAgV2Via2l0TGluZUNsYW1wOiAxLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiAxLFxuICBmbG9vZE9wYWNpdHk6IDEsXG4gIHN0b3BPcGFjaXR5OiAxLFxuICBzdHJva2VEYXNoYXJyYXk6IDEsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IDEsXG4gIHN0cm9rZU1pdGVybGltaXQ6IDEsXG4gIHN0cm9rZU9wYWNpdHk6IDEsXG4gIHN0cm9rZVdpZHRoOiAxXG59O1xuXG5leHBvcnQgZGVmYXVsdCB1bml0bGVzc0tleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZW1vdGlvbi91bml0bGVzcy9kaXN0L3VuaXRsZXNzLmJyb3dzZXIuZXNtLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIgMyA1IiwiaW1wb3J0IG1lbW9pemUgZnJvbSAnQGVtb3Rpb24vbWVtb2l6ZSc7XG5cbnZhciByZWFjdFByb3BzUmVnZXggPSAvXigoY2hpbGRyZW58ZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUx8a2V5fHJlZnxhdXRvRm9jdXN8ZGVmYXVsdFZhbHVlfGRlZmF1bHRDaGVja2VkfGlubmVySFRNTHxzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmd8c3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nfHZhbHVlTGlua3xhY2NlcHR8YWNjZXB0Q2hhcnNldHxhY2Nlc3NLZXl8YWN0aW9ufGFsbG93fGFsbG93VXNlck1lZGlhfGFsbG93UGF5bWVudFJlcXVlc3R8YWxsb3dGdWxsU2NyZWVufGFsbG93VHJhbnNwYXJlbmN5fGFsdHxhc3luY3xhdXRvQ29tcGxldGV8YXV0b1BsYXl8Y2FwdHVyZXxjZWxsUGFkZGluZ3xjZWxsU3BhY2luZ3xjaGFsbGVuZ2V8Y2hhclNldHxjaGVja2VkfGNpdGV8Y2xhc3NJRHxjbGFzc05hbWV8Y29sc3xjb2xTcGFufGNvbnRlbnR8Y29udGVudEVkaXRhYmxlfGNvbnRleHRNZW51fGNvbnRyb2xzfGNvbnRyb2xzTGlzdHxjb29yZHN8Y3Jvc3NPcmlnaW58ZGF0YXxkYXRlVGltZXxkZWNvZGluZ3xkZWZhdWx0fGRlZmVyfGRpcnxkaXNhYmxlZHxkaXNhYmxlUGljdHVyZUluUGljdHVyZXxkb3dubG9hZHxkcmFnZ2FibGV8ZW5jVHlwZXxmb3JtfGZvcm1BY3Rpb258Zm9ybUVuY1R5cGV8Zm9ybU1ldGhvZHxmb3JtTm9WYWxpZGF0ZXxmb3JtVGFyZ2V0fGZyYW1lQm9yZGVyfGhlYWRlcnN8aGVpZ2h0fGhpZGRlbnxoaWdofGhyZWZ8aHJlZkxhbmd8aHRtbEZvcnxodHRwRXF1aXZ8aWR8aW5wdXRNb2RlfGludGVncml0eXxpc3xrZXlQYXJhbXN8a2V5VHlwZXxraW5kfGxhYmVsfGxhbmd8bGlzdHxsb2FkaW5nfGxvb3B8bG93fG1hcmdpbkhlaWdodHxtYXJnaW5XaWR0aHxtYXh8bWF4TGVuZ3RofG1lZGlhfG1lZGlhR3JvdXB8bWV0aG9kfG1pbnxtaW5MZW5ndGh8bXVsdGlwbGV8bXV0ZWR8bmFtZXxub25jZXxub1ZhbGlkYXRlfG9wZW58b3B0aW11bXxwYXR0ZXJufHBsYWNlaG9sZGVyfHBsYXlzSW5saW5lfHBvc3RlcnxwcmVsb2FkfHByb2ZpbGV8cmFkaW9Hcm91cHxyZWFkT25seXxyZWZlcnJlclBvbGljeXxyZWx8cmVxdWlyZWR8cmV2ZXJzZWR8cm9sZXxyb3dzfHJvd1NwYW58c2FuZGJveHxzY29wZXxzY29wZWR8c2Nyb2xsaW5nfHNlYW1sZXNzfHNlbGVjdGVkfHNoYXBlfHNpemV8c2l6ZXN8c2xvdHxzcGFufHNwZWxsQ2hlY2t8c3JjfHNyY0RvY3xzcmNMYW5nfHNyY1NldHxzdGFydHxzdGVwfHN0eWxlfHN1bW1hcnl8dGFiSW5kZXh8dGFyZ2V0fHRpdGxlfHR5cGV8dXNlTWFwfHZhbHVlfHdpZHRofHdtb2RlfHdyYXB8YWJvdXR8ZGF0YXR5cGV8aW5saXN0fHByZWZpeHxwcm9wZXJ0eXxyZXNvdXJjZXx0eXBlb2Z8dm9jYWJ8YXV0b0NhcGl0YWxpemV8YXV0b0NvcnJlY3R8YXV0b1NhdmV8Y29sb3J8aW5lcnR8aXRlbVByb3B8aXRlbVNjb3BlfGl0ZW1UeXBlfGl0ZW1JRHxpdGVtUmVmfG9ufHJlc3VsdHN8c2VjdXJpdHl8dW5zZWxlY3RhYmxlfGFjY2VudEhlaWdodHxhY2N1bXVsYXRlfGFkZGl0aXZlfGFsaWdubWVudEJhc2VsaW5lfGFsbG93UmVvcmRlcnxhbHBoYWJldGljfGFtcGxpdHVkZXxhcmFiaWNGb3JtfGFzY2VudHxhdHRyaWJ1dGVOYW1lfGF0dHJpYnV0ZVR5cGV8YXV0b1JldmVyc2V8YXppbXV0aHxiYXNlRnJlcXVlbmN5fGJhc2VsaW5lU2hpZnR8YmFzZVByb2ZpbGV8YmJveHxiZWdpbnxiaWFzfGJ5fGNhbGNNb2RlfGNhcEhlaWdodHxjbGlwfGNsaXBQYXRoVW5pdHN8Y2xpcFBhdGh8Y2xpcFJ1bGV8Y29sb3JJbnRlcnBvbGF0aW9ufGNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnN8Y29sb3JQcm9maWxlfGNvbG9yUmVuZGVyaW5nfGNvbnRlbnRTY3JpcHRUeXBlfGNvbnRlbnRTdHlsZVR5cGV8Y3Vyc29yfGN4fGN5fGR8ZGVjZWxlcmF0ZXxkZXNjZW50fGRpZmZ1c2VDb25zdGFudHxkaXJlY3Rpb258ZGlzcGxheXxkaXZpc29yfGRvbWluYW50QmFzZWxpbmV8ZHVyfGR4fGR5fGVkZ2VNb2RlfGVsZXZhdGlvbnxlbmFibGVCYWNrZ3JvdW5kfGVuZHxleHBvbmVudHxleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkfGZpbGx8ZmlsbE9wYWNpdHl8ZmlsbFJ1bGV8ZmlsdGVyfGZpbHRlclJlc3xmaWx0ZXJVbml0c3xmbG9vZENvbG9yfGZsb29kT3BhY2l0eXxmb2N1c2FibGV8Zm9udEZhbWlseXxmb250U2l6ZXxmb250U2l6ZUFkanVzdHxmb250U3RyZXRjaHxmb250U3R5bGV8Zm9udFZhcmlhbnR8Zm9udFdlaWdodHxmb3JtYXR8ZnJvbXxmcnxmeHxmeXxnMXxnMnxnbHlwaE5hbWV8Z2x5cGhPcmllbnRhdGlvbkhvcml6b250YWx8Z2x5cGhPcmllbnRhdGlvblZlcnRpY2FsfGdseXBoUmVmfGdyYWRpZW50VHJhbnNmb3JtfGdyYWRpZW50VW5pdHN8aGFuZ2luZ3xob3JpekFkdlh8aG9yaXpPcmlnaW5YfGlkZW9ncmFwaGljfGltYWdlUmVuZGVyaW5nfGlufGluMnxpbnRlcmNlcHR8a3xrMXxrMnxrM3xrNHxrZXJuZWxNYXRyaXh8a2VybmVsVW5pdExlbmd0aHxrZXJuaW5nfGtleVBvaW50c3xrZXlTcGxpbmVzfGtleVRpbWVzfGxlbmd0aEFkanVzdHxsZXR0ZXJTcGFjaW5nfGxpZ2h0aW5nQ29sb3J8bGltaXRpbmdDb25lQW5nbGV8bG9jYWx8bWFya2VyRW5kfG1hcmtlck1pZHxtYXJrZXJTdGFydHxtYXJrZXJIZWlnaHR8bWFya2VyVW5pdHN8bWFya2VyV2lkdGh8bWFza3xtYXNrQ29udGVudFVuaXRzfG1hc2tVbml0c3xtYXRoZW1hdGljYWx8bW9kZXxudW1PY3RhdmVzfG9mZnNldHxvcGFjaXR5fG9wZXJhdG9yfG9yZGVyfG9yaWVudHxvcmllbnRhdGlvbnxvcmlnaW58b3ZlcmZsb3d8b3ZlcmxpbmVQb3NpdGlvbnxvdmVybGluZVRoaWNrbmVzc3xwYW5vc2UxfHBhaW50T3JkZXJ8cGF0aExlbmd0aHxwYXR0ZXJuQ29udGVudFVuaXRzfHBhdHRlcm5UcmFuc2Zvcm18cGF0dGVyblVuaXRzfHBvaW50ZXJFdmVudHN8cG9pbnRzfHBvaW50c0F0WHxwb2ludHNBdFl8cG9pbnRzQXRafHByZXNlcnZlQWxwaGF8cHJlc2VydmVBc3BlY3RSYXRpb3xwcmltaXRpdmVVbml0c3xyfHJhZGl1c3xyZWZYfHJlZll8cmVuZGVyaW5nSW50ZW50fHJlcGVhdENvdW50fHJlcGVhdER1cnxyZXF1aXJlZEV4dGVuc2lvbnN8cmVxdWlyZWRGZWF0dXJlc3xyZXN0YXJ0fHJlc3VsdHxyb3RhdGV8cnh8cnl8c2NhbGV8c2VlZHxzaGFwZVJlbmRlcmluZ3xzbG9wZXxzcGFjaW5nfHNwZWN1bGFyQ29uc3RhbnR8c3BlY3VsYXJFeHBvbmVudHxzcGVlZHxzcHJlYWRNZXRob2R8c3RhcnRPZmZzZXR8c3RkRGV2aWF0aW9ufHN0ZW1ofHN0ZW12fHN0aXRjaFRpbGVzfHN0b3BDb2xvcnxzdG9wT3BhY2l0eXxzdHJpa2V0aHJvdWdoUG9zaXRpb258c3RyaWtldGhyb3VnaFRoaWNrbmVzc3xzdHJpbmd8c3Ryb2tlfHN0cm9rZURhc2hhcnJheXxzdHJva2VEYXNob2Zmc2V0fHN0cm9rZUxpbmVjYXB8c3Ryb2tlTGluZWpvaW58c3Ryb2tlTWl0ZXJsaW1pdHxzdHJva2VPcGFjaXR5fHN0cm9rZVdpZHRofHN1cmZhY2VTY2FsZXxzeXN0ZW1MYW5ndWFnZXx0YWJsZVZhbHVlc3x0YXJnZXRYfHRhcmdldFl8dGV4dEFuY2hvcnx0ZXh0RGVjb3JhdGlvbnx0ZXh0UmVuZGVyaW5nfHRleHRMZW5ndGh8dG98dHJhbnNmb3JtfHUxfHUyfHVuZGVybGluZVBvc2l0aW9ufHVuZGVybGluZVRoaWNrbmVzc3x1bmljb2RlfHVuaWNvZGVCaWRpfHVuaWNvZGVSYW5nZXx1bml0c1BlckVtfHZBbHBoYWJldGljfHZIYW5naW5nfHZJZGVvZ3JhcGhpY3x2TWF0aGVtYXRpY2FsfHZhbHVlc3x2ZWN0b3JFZmZlY3R8dmVyc2lvbnx2ZXJ0QWR2WXx2ZXJ0T3JpZ2luWHx2ZXJ0T3JpZ2luWXx2aWV3Qm94fHZpZXdUYXJnZXR8dmlzaWJpbGl0eXx3aWR0aHN8d29yZFNwYWNpbmd8d3JpdGluZ01vZGV8eHx4SGVpZ2h0fHgxfHgyfHhDaGFubmVsU2VsZWN0b3J8eGxpbmtBY3R1YXRlfHhsaW5rQXJjcm9sZXx4bGlua0hyZWZ8eGxpbmtSb2xlfHhsaW5rU2hvd3x4bGlua1RpdGxlfHhsaW5rVHlwZXx4bWxCYXNlfHhtbG5zfHhtbG5zWGxpbmt8eG1sTGFuZ3x4bWxTcGFjZXx5fHkxfHkyfHlDaGFubmVsU2VsZWN0b3J8enx6b29tQW5kUGFufGZvcnxjbGFzc3xhdXRvZm9jdXMpfCgoW0RkXVtBYV1bVHRdW0FhXXxbQWFdW1JyXVtJaV1bQWFdfHgpLS4qKSkkLzsgLy8gaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81YmZlZTY4YTRjZDdlNjAwOWVmNjFkMjNcblxudmFyIGluZGV4ID0gbWVtb2l6ZShmdW5jdGlvbiAocHJvcCkge1xuICByZXR1cm4gcmVhY3RQcm9wc1JlZ2V4LnRlc3QocHJvcCkgfHwgcHJvcC5jaGFyQ29kZUF0KDApID09PSAxMTFcbiAgLyogbyAqL1xuICAmJiBwcm9wLmNoYXJDb2RlQXQoMSkgPT09IDExMFxuICAvKiBuICovXG4gICYmIHByb3AuY2hhckNvZGVBdCgyKSA8IDkxO1xufVxuLyogWisxICovXG4pO1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL2lzLXByb3AtdmFsaWQvZGlzdC9pcy1wcm9wLXZhbGlkLmJyb3dzZXIuZXNtLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIgMyA1IiwiZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICB2YXIgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAoY2FjaGVbYXJnXSA9PT0gdW5kZWZpbmVkKSBjYWNoZVthcmddID0gZm4oYXJnKTtcbiAgICByZXR1cm4gY2FjaGVbYXJnXTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWVtb2l6ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL21lbW9pemUvZGlzdC9tZW1vaXplLmJyb3dzZXIuZXNtLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIDIgMyA1IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgY29udGV4dFR5cGU6IHRydWUsXG4gIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogdHJ1ZSxcbiAgbWl4aW5zOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgbmFtZTogdHJ1ZSxcbiAgbGVuZ3RoOiB0cnVlLFxuICBwcm90b3R5cGU6IHRydWUsXG4gIGNhbGxlcjogdHJ1ZSxcbiAgY2FsbGVlOiB0cnVlLFxuICBhcmd1bWVudHM6IHRydWUsXG4gIGFyaXR5OiB0cnVlXG59O1xudmFyIEZPUldBUkRfUkVGX1NUQVRJQ1MgPSB7XG4gICckJHR5cGVvZic6IHRydWUsXG4gIHJlbmRlcjogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlXG59O1xudmFyIE1FTU9fU1RBVElDUyA9IHtcbiAgJyQkdHlwZW9mJzogdHJ1ZSxcbiAgY29tcGFyZTogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIFRZUEVfU1RBVElDUyA9IHt9O1xuVFlQRV9TVEFUSUNTW3JlYWN0SXMuRm9yd2FyZFJlZl0gPSBGT1JXQVJEX1JFRl9TVEFUSUNTO1xuVFlQRV9TVEFUSUNTW3JlYWN0SXMuTWVtb10gPSBNRU1PX1NUQVRJQ1M7XG5cbmZ1bmN0aW9uIGdldFN0YXRpY3MoY29tcG9uZW50KSB7XG4gIC8vIFJlYWN0IHYxNi4xMSBhbmQgYmVsb3dcbiAgaWYgKHJlYWN0SXMuaXNNZW1vKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gTUVNT19TVEFUSUNTO1xuICB9IC8vIFJlYWN0IHYxNi4xMiBhbmQgYWJvdmVcblxuXG4gIHJldHVybiBUWVBFX1NUQVRJQ1NbY29tcG9uZW50WyckJHR5cGVvZiddXSB8fCBSRUFDVF9TVEFUSUNTO1xufVxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBibGFja2xpc3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0U3RhdGljcyA9IGdldFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50KTtcbiAgICB2YXIgc291cmNlU3RhdGljcyA9IGdldFN0YXRpY3Moc291cmNlQ29tcG9uZW50KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghS05PV05fU1RBVElDU1trZXldICYmICEoYmxhY2tsaXN0ICYmIGJsYWNrbGlzdFtrZXldKSAmJiAhKHNvdXJjZVN0YXRpY3MgJiYgc291cmNlU3RhdGljc1trZXldKSAmJiAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaG9pc3ROb25SZWFjdFN0YXRpY3M7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZWQtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanNcbi8vIG1vZHVsZSBpZCA9IDIwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiAzIDUiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgVG9nZ2xlIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy90b2dnbGUnO1xuaW1wb3J0IFJhZGlvVGFicyBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvcmFkaW8tdGFicyc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvY29udGFpbmVyJztcbmltcG9ydCBJbnB1dCBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvaW5wdXQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWN1cml0eUJlaGF2aW91ciBleHRlbmRzIENvbXBvbmVudCB7XG5cdHJlbmRlcigpIHtcblx0XHRsZXQgZm9ybVR5cGUgPSBmb3JtaW5hdG9yRGF0YS5jdXJyZW50Rm9ybS5zZXR0aW5nc1snZm9ybS10eXBlJ10gfHwgJ2RlZmF1bHQnO1xuXHRcdGNvbnN0IHNwZWNpYWxGb3JtVHlwZXMgPSBbICdsb2dpbicsICdyZWdpc3RyYXRpb24nLCAnbGVhZHMnIF07XG5cdFx0bGV0IGlzRGlzYWJsZUZvcm0gPSBzcGVjaWFsRm9ybVR5cGVzLmluY2x1ZGVzKCBmb3JtVHlwZSApO1xuXG5cdFx0aWYgKCBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzWydha2lzbWV0LXByb3RlY3Rpb24nXSApICkge1xuXHRcdFx0dGhpcy5wcm9wcy5zZXR0aW5nc1snYWtpc21ldC1wcm90ZWN0aW9uJ10gPSAxO1xuXHRcdH1cblx0XHRpZiAoICEgIGZvcm1pbmF0b3JEYXRhLmFraXNtZXRFbmFibGVkICkge1xuXHRcdFx0dGhpcy5wcm9wcy5zZXR0aW5nc1snYWtpc21ldC1wcm90ZWN0aW9uJ10gPSAwO1xuXHRcdH1cblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3Mtcm93XCI+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0xXCI+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXNldHRpbmdzLWxhYmVsXCI+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1NlY3VyaXR5JyApIH1cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCI+eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHQnQWRkZWQgbGF5ZXJzIG9mIHNlY3VyaXR5IHRvIHByZXZlbnQgc3BhbSBzdWJtaXNzaW9ucy4nXG5cdFx0XHRcdFx0KSB9PC9zcGFuPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3MtY29sLTJcIj5cblxuXHRcdFx0XHRcdHsgJ2Zvcm0nID09PSB0aGlzLnByb3BzLm1vZHVsZVNsdWcgJiZcblx0XHRcdFx0XHRcdDxUb2dnbGUgeyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdFbmFibGUgSG9uZXlwb3QgcHJvdGVjdGlvbicgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwiaG9uZXlwb3RcIlxuXHRcdFx0XHRcdFx0XHRkZXNjcmlwdGlvbj17IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0XHQnRW5hYmxpbmcgdGhpcyBmZWF0dXJlIHRyaWNrcyBzcGFtIGJvdHMgYnkgZ2l2aW5nIHRoZW0gYSBoaWRkZW4gJyArXG5cdFx0XHRcdFx0XHRcdFx0J2NoYWxsZW5nZSBvbmx5IGJvdHMgd2lsbCBzZWUuIElmIHRoZSBib3QgdHJpZXMgdGhlIGNoYWxsZW5nZSB3ZSAnICtcblx0XHRcdFx0XHRcdFx0XHRcImtub3cgaXQncyBub3QgYSBodW1hbiBhbmQgcHJldmVudCB0aGUgZm9ybSBiZWluZyBzdWJtaXR0ZWQuXCJcblx0XHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdDxUb2dnbGVcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0VuYWJsZSBBa2lzbWV0IHNwYW0gcHJvdGVjdGlvbicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT1cImFraXNtZXQtcHJvdGVjdGlvblwiXG5cdFx0XHRcdFx0XHRkaXNhYmxlZD17ICEgZm9ybWluYXRvckRhdGEuYWtpc21ldEVuYWJsZWQgfVxuXHRcdFx0XHRcdFx0ZGVzY3JpcHRpb249eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdCdJZiB5b3UgaGF2ZSBpbnN0YWxsZWQgdGhlIHt7bGlua319QWtpc21ldCBhbnRpLXNwYW0gcGx1Z2lue3svbGlua319LCAnICtcblx0XHRcdFx0XHRcdFx0J3lvdSBjYW4gZW5hYmxlIHRoaXMgb3B0aW9uIHRvIHRlbGwgRm9ybWluYXRvciBob3cgdG8gaGFuZGxlIHN1Ym1pc3Npb25zICcgK1xuXHRcdFx0XHRcdFx0XHQndGhhdCBBa2lzbWV0IGZsYWdzIGFzIHNwYW0uJyxcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBvbmVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpbms6IDxhIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9XCJodHRwczovL3dvcmRwcmVzcy5vcmcvcGx1Z2lucy9ha2lzbWV0L1wiIC8+LFxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdDxSYWRpb1RhYnNcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJha2lzbWV0LXByb3RlY3Rpb24tYmVoYXZpb3JcIlxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0PVwiZmFpbFwiXG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnSG93IHNob3VsZCBGb3JtaW5hdG9yIGhhbmRsZSBzcGFtIHN1Ym1pc3Npb25zPycgKSB9XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZT1cImZhaWxcIlxuXHRcdFx0XHRcdFx0XHRcdGJveENsYXNzPVwic3VpLXRhYi1ib3hlZFwiXG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdGYWlsIFN1Ym1pc3Npb24nICkgfVxuXHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0PElucHV0IHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0N1c3RvbSBlcnJvciBtZXNzYWdlJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPXsgdHJhbnNsYXRlKCAnU29tZXRoaW5nIHdlbnQgd3JvbmcuJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwic3BhbS1mYWlsLW1lc3NhZ2VcIlxuXHRcdFx0XHRcdFx0XHRcdFx0ZGVzY3JpcHRpb249eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCdFbnRlciBhIGN1c3RvbSBlcnJvciBtZXNzYWdlIHRvIGxldCB5b3VyIHZpc2l0b3JzIGtub3cgd2h5IHRoZSBzdWJtaXNzaW9uIGZhaWxlZC4nXG5cdFx0XHRcdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHQ8L0NvbnRhaW5lcj5cblx0XHRcdFx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlPVwibWFya19zcGFtXCJcblx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ01hcmsgYXMgU3BhbScgKSB9XG5cdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHRcdFx0XHRyb2xlPVwiYWxlcnRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLW5vdGljZSBzdWktYWN0aXZlXCJcblx0XHRcdFx0XHRcdFx0XHRcdHN0eWxlPXsgeyBkaXNwbGF5OiAnYmxvY2snIH0gfVxuXHRcdFx0XHRcdFx0XHRcdFx0YXJpYS1saXZlPVwiYXNzZXJ0aXZlXCJcblx0XHRcdFx0XHRcdFx0XHQ+XG5cblx0XHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLW5vdGljZS1jb250ZW50XCI+XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktbm90aWNlLW1lc3NhZ2VcIj5cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1ub3RpY2UtaWNvbiBzdWktaWNvbi1pbmZvXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxwPnsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0J0VudHJpZXMgbWFya2VkIGFzIHNwYW0gd2lsbCBiZSBjYXB0dXJlZCBpbiB0aGUgJyArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQnZGF0YWJhc2UsIGJ1dCBub3Qgc2hvd24gaW4gU3VibWlzc2lvbnMuICcgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0J0FkZGl0aW9uYWxseSwgUGF5bWVudHMsIE5vdGlmaWNhdGlvbiBlbWFpbHMsICcgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0J2FuZCBvdGhlciBhdXRvbWF0aWMgcHJvY2Vzc2VzIHdpbGwgYmUgYmxvY2tlZC4nXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KSB9PC9wPlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0XHQ8L0NvbnRhaW5lcj5cblx0XHRcdFx0XHRcdDwvUmFkaW9UYWJzPlxuXHRcdFx0XHRcdDwvVG9nZ2xlPlxuXG5cdFx0XHRcdFx0eyAnZm9ybScgPT09IHRoaXMucHJvcHMubW9kdWxlU2x1ZyAmJiAhIGlzRGlzYWJsZUZvcm0gJiZcblx0XHRcdFx0XHRcdDxUb2dnbGVcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdFbmFibGUgbG9nZ2VkIGluIHN1Ym1pc3Npb24gb25seScgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwibG9nZ2VkLXVzZXJzXCJcblx0XHRcdFx0XHRcdFx0ZGVzY3JpcHRpb249eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdFx0J0xvY2sgZG93biB5b3VyIGZvcm0gc3VibWlzc2lvbnMgdG8gcmVnaXN0ZXJlZCB1c2VycyBvbmx5Lidcblx0XHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0XHRcdFx0PElucHV0XG5cdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdTdWJtaXNzaW9ucyBsaW1pdCBwZXIgbG9nZ2VkIGluIHVzZXInICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0ZGVzY3JpcHRpb249eyB0cmFuc2xhdGUoICdFbnRlciB0aGUgbnVtYmVyIG9mIHRpbWVzIGEgbG9nZ2VkIGluIHVzZXIgY2FuIHN1Ym1pdCB0aGlzIGZvcm0uIExlYXZlIGJsYW5rIG9yIGVudGVyIOKAnDDigJ0gZm9yIG5vIGxpbWl0LicgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlPVwibnVtYmVyXCJcblx0XHRcdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPVwiMFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cImxpbWl0LXBlci11c2VyXCJcblx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdFx0PGRpdiBzdHlsZT17IHsgbWFyZ2luVG9wOiAnMjBweCcgfSB9PlxuXHRcdFx0XHRcdFx0XHRcdDxJbnB1dFxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnTWVzc2FnZSB3aGVuIHVzZXIgaGFzIGFscmVhZHkgcmVhY2hlZCBzdWJtaXNzaW9ucyBsaW1pdCcgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj17IHRyYW5zbGF0ZSggJ1lvdeKAmXZlIGFscmVhZHkgcmVhY2hlZCBzdWJtaXNzaW9ucyBsaW1pdC4nICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJsaW1pdC1wZXItdXNlci1lcnJvclwiXG5cdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8L1RvZ2dsZT5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9nbG9iYWwvY29tcG9uZW50cy9iZWhhdmlvdXIvc2VjdXJpdHkuanMiLCJleHBvcnQgY29uc3QgdXBkYXRlQW5zd2VycyA9IGFuc3dlcnMgPT4gZGlzcGF0Y2ggPT4ge1xuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlIHdpdGggQ2hhbmdlc1xuXHR3aW5kb3cuZm9ybWluYXRvckNoYW5nZXMuc2V0dGluZ3MgPSB0cnVlO1xuXG5cdGRpc3BhdGNoKCB7XG5cdFx0dHlwZTogJ1VQREFURV9BTlNXRVJTJyxcblx0XHRhbnN3ZXJzOiBhbnN3ZXJzLFxuXHR9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlQW5zd2VyID0gYW5zd2VyID0+IGRpc3BhdGNoID0+IHtcblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZSB3aXRoIENoYW5nZXNcblx0d2luZG93LmZvcm1pbmF0b3JDaGFuZ2VzLnNldHRpbmdzID0gdHJ1ZTtcblxuXHRkaXNwYXRjaCgge1xuXHRcdHR5cGU6ICdVUERBVEVfQU5TV0VSJyxcblx0XHRhbnN3ZXI6IGFuc3dlcixcblx0fSApO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2FjdGlvbnMvYnVpbGRlci5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1aVRhZ3MgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdFx0dGhpcy5oYW5kbGVDaGFuZ2UgPSB0aGlzLmhhbmRsZUNoYW5nZS5iaW5kKCB0aGlzICk7XG5cdH1cblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHRjb25zdCB2YWx1ZSA9IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXSApXG5cdFx0XHQ/IFtdXG5cdFx0XHQ6IHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXTtcblxuXHRcdHRoaXMuJGVsID0galF1ZXJ5KCB0aGlzLmVsICk7XG5cdFx0Y29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG5cdFx0XHR7IGFsbG93Q2xlYXI6IHRydWUsIGRyb3Bkb3duQ3NzQ2xhc3M6ICdzdWktc2VsZWN0LWRyb3Bkb3duJyB9LFxuXHRcdFx0dGhpcy5wcm9wcy5vcHRpb25zXG5cdFx0KTtcblxuXHRcdGlmICggdHlwZW9mIHRoaXMuJGVsLlNVSXNlbGVjdDIgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHR0aGlzLiRlbC5TVUlzZWxlY3QyKCBvcHRpb25zICk7XG5cdFx0fSBlbHNlIGlmICggdHlwZW9mIHRoaXMuJGVsLkZVSXNlbGVjdDIgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHR0aGlzLiRlbC5GVUlzZWxlY3QyKCBvcHRpb25zICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUubG9nKCAnc2VsZWN0MiBub3QgaW50aWF0ZWQnICk7XG5cdFx0fVxuXG5cdFx0dGhpcy4kZWwub24oICdjaGFuZ2Uuc2VsZWN0MicsIHRoaXMuaGFuZGxlQ2hhbmdlICk7XG5cblx0XHRpZiAoXG5cdFx0XHQhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3MucGVybWlzc2lvbl90eXBlICkgJiZcblx0XHRcdChcblx0XHRcdFx0J3NwZWNpZmljJyA9PT0gdGhpcy5wcm9wcy5zZXR0aW5ncy5wZXJtaXNzaW9uX3R5cGUgfHxcblx0XHRcdFx0ISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzLnVzZXJfaW5mbyApXG5cdFx0XHQpXG5cdFx0KSB7XG5cdFx0XHRjb25zdCB1c2VySW5mb3MgPSB0aGlzLnByb3BzLnNldHRpbmdzLnVzZXJfaW5mbztcblxuXHRcdFx0Ly8gaW5pdGlhbCB2YWx1ZXMgYXBwZW5kXG5cdFx0XHRfLmVhY2goIHZhbHVlLCBmdW5jdGlvbiggb3B0aW9uICkge1xuXHRcdFx0XHRpZiAoICEgXy5pc1VuZGVmaW5lZCggdXNlckluZm9zWyBvcHRpb24gXSApICkge1xuXHRcdFx0XHRcdHNlbGYuJGVsLmFwcGVuZCggalF1ZXJ5KCAnPG9wdGlvbiB2YWx1ZT1cIicgKyBvcHRpb24gKyAnXCI+JyArXG5cdFx0XHRcdFx0dXNlckluZm9zWyBvcHRpb24gXS5lbWFpbCArXG5cdFx0XHRcdFx0Jzwvb3B0aW9uPicgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBpbml0aWFsIHZhbHVlcyBhcHBlbmRcblx0XHRcdF8uZWFjaCggdmFsdWUsIGZ1bmN0aW9uKCBvcHRpb24gKSB7XG5cdFx0XHRcdHNlbGYuJGVsLmFwcGVuZCggalF1ZXJ5KCAnPG9wdGlvbiB2YWx1ZT1cIicgKyBvcHRpb24gKyAnXCI+JyArIG9wdGlvbiArICc8L29wdGlvbj4nICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBpbml0aWFsIHZhbHVlcyBvbiBtb3VudFxuXHRcdHRoaXMuJGVsLnZhbCggdmFsdWUgKS50cmlnZ2VyKCAnY2hhbmdlLnNlbGVjdDInICk7XG5cdH1cblxuXHRjb21wb25lbnREaWRVcGRhdGUoIHByZXZQcm9wcywgcHJldlN0YXRlICkge1xuXHRcdGlmIChcblx0XHRcdCEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5ncy51c2VyX3JvbGUgKSAmJlxuXHRcdFx0cHJldlByb3BzLnNldHRpbmdzLnVzZXJfcm9sZSAhPT0gdGhpcy5wcm9wcy5zZXR0aW5ncy51c2VyX3JvbGVcblx0XHQpIHtcblx0XHRcdHRoaXMuJGVsLnZhbCggW10gKS50cmlnZ2VyKCAnY2hhbmdlLnNlbGVjdDInICk7XG5cdFx0fVxuXHR9XG5cblx0aGFuZGxlQ2hhbmdlKCBlICkge1xuXHRcdGNvbnN0IHZhbHVlID0galF1ZXJ5KCBlLnRhcmdldCApLnZhbCgpO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgb24gZmllbGQgc2V0dGluZ3Ncblx0XHRpZiAoIHR5cGVvZiB0aGlzLnByb3BzLnVwZGF0ZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0Ly8gVXBkYXRlIGZpZWxkIHN0YXRlXG5cdFx0XHR0aGlzLnByb3BzLnVwZGF0ZVByb3BlcnR5KCB0aGlzLnByb3BzLnByb3BlcnR5LCB2YWx1ZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBVcGRhdGUgc3RvcmVcblx0XHRcdHRoaXMucHJvcHMuYWN0aW9ucy5zZXR0aW5nc0FjdGlvbnMudXBkYXRlU2V0dGluZyggdGhpcy5wcm9wcy5wcm9wZXJ0eSwgdmFsdWUgKTtcblx0XHR9XG5cdH1cblxuXHRjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0XHR0aGlzLiRlbC5vZmYoICdjaGFuZ2UnLCB0aGlzLmhhbmRsZUNoYW5nZSApO1xuXHRcdHRoaXMuJGVsLnVuYmluZCgpLnJlbW92ZURhdGEoKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCB2YWx1ZSA9IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXSApXG5cdFx0XHQ/IFtdXG5cdFx0XHQ6IHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXTtcblxuXHRcdGxldCBmaWVsZExhYmVsID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMubGFiZWwgKSB7XG5cdFx0XHRmaWVsZExhYmVsID0gKFxuXHRcdFx0XHQ8bGFiZWwgaHRtbEZvcj17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHRoaXMucHJvcHMucHJvcGVydHkgfWAgfSBjbGFzc05hbWU9XCJzdWktbGFiZWxcIj5cblx0XHRcdFx0XHR7dGhpcy5wcm9wcy5sYWJlbH1cblx0XHRcdFx0XHR7dGhpcy5wcm9wcy5ub3RlICYmIDxzcGFuIGNsYXNzTmFtZT1cInN1aS1sYWJlbC1ub3RlXCI+e3RoaXMucHJvcHMubm90ZX08L3NwYW4+fVxuXHRcdFx0XHQ8L2xhYmVsPlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktZm9ybS1maWVsZFwiIHN0eWxlPXsgdGhpcy5wcm9wcy5zdHlsZSB9PlxuXHRcdFx0XHR7ZmllbGRMYWJlbH1cblxuXHRcdFx0XHQ8c2VsZWN0XG5cdFx0XHRcdFx0cmVmPXsgZWwgPT4gKCB0aGlzLmVsID0gZWwgKSB9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLXNlbGVjdFwiXG5cdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXsgdmFsdWUgfVxuXHRcdFx0XHRcdG11bHRpcGxlPVwibXVsdGlwbGVcIlxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0e3RoaXMucHJvcHMuY2hpbGRyZW59XG5cdFx0XHRcdDwvc2VsZWN0PlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzL2lucHV0cy9zdWktdGFncy5qcyIsImV4cG9ydCBjb25zdCBVUERBVEVfVElUTEUgPSAnVVBEQVRFX1RJVExFJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVRpdGxlKCB0aXRsZSApIHtcblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZSB3aXRoIENoYW5nZXNcblx0d2luZG93LmZvcm1pbmF0b3JDaGFuZ2VzLnNldHRpbmdzID0gdHJ1ZTtcblxuXHRyZXR1cm4geyB0eXBlOiBVUERBVEVfVElUTEUsIHRpdGxlIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9hY3Rpb25zL25hdmlnYXRpb24uanMiLCIvKiBqc2hpbnQgZXN2ZXJzaW9uOiA2ICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcmVuZGVyQmxvY2sgfSBmcm9tICcuLi9yZW5kZXJCbG9jayc7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IE1lbW9yeVJvdXRlciwgUm91dGUgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcbmltcG9ydCBjb25maWd1cmVTdG9yZSBmcm9tICcuL3N0b3JlL2NvbmZpZ3VyZVN0b3JlJztcbmltcG9ydCBpMThuIGZyb20gJ2kxOG4td3AtcGx1Z2luJztcblxuaW1wb3J0IE1haW4gZnJvbSAnLi9jb250YWluZXJzL21haW4nO1xuXG5jb25zdCBzdG9yZSA9IGNvbmZpZ3VyZVN0b3JlKCBmb3JtaW5hdG9yRGF0YS5jdXJyZW50Rm9ybSApO1xuXG5pMThuLnNldExvY2FsZSggZm9ybWluYXRvcmwxMG4ubG9jYWxlICk7XG5cbndpbmRvdy5mb3JtaW5hdG9yQ2hhbmdlcyA9IHtcblx0YW5zd2VyczogW10sXG5cdHNldHRpbmdzOiBmYWxzZSxcbn07XG5cbnJlbmRlckJsb2NrKFxuXHQnZm9ybWluYXRvci1wb2xsLWJ1aWxkZXInLFxuXHQ8UHJvdmlkZXIgc3RvcmU9eyBzdG9yZSB9PlxuXHRcdDxNZW1vcnlSb3V0ZXI+XG5cdFx0XHQ8Um91dGUgY29tcG9uZW50PXsgTWFpbiB9IC8+XG5cdFx0PC9NZW1vcnlSb3V0ZXI+XG5cdDwvUHJvdmlkZXI+XG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvaW5kZXguanMiLCJpbXBvcnQgeyBjcmVhdGVTdG9yZSwgY29tcG9zZSwgYXBwbHlNaWRkbGV3YXJlIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHRodW5rIGZyb20gJ3JlZHV4LXRodW5rJztcbmltcG9ydCBhcHBSZWR1Y2VycyBmcm9tICcuLi9yZWR1Y2Vycyc7XG5cbmNvbnN0IG5ld0NyZWF0ZVN0b3JlID0gY29tcG9zZSggYXBwbHlNaWRkbGV3YXJlKCB0aHVuayApICkoIGNyZWF0ZVN0b3JlICk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbmZpZ3VyZVN0b3JlKCBpbml0aWFsU3RhdGUgKSB7XG5cdHJldHVybiBuZXdDcmVhdGVTdG9yZSggYXBwUmVkdWNlcnMsIGluaXRpYWxTdGF0ZSApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvc3RvcmUvY29uZmlndXJlU3RvcmUuanMiLCJpbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tICdyZWR1eCc7XG5cbi8vIEltcG9ydCByZWR1Y2Vyc1xuaW1wb3J0IGFuc3dlcnMgZnJvbSAnLi9hbnN3ZXJzJztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuL3NldHRpbmdzJztcbmltcG9ydCBtb2RhbCBmcm9tICcuL21vZGFsJztcblxuY29uc3QgYXBwUmVkdWNlcnMgPSBjb21iaW5lUmVkdWNlcnMoIHtcblx0Ly8gTGlzdCByZWR1Y2Vyc1xuXHRhbnN3ZXJzLFxuXHRzZXR0aW5ncyxcblx0bW9kYWwsXG59ICk7XG5cbmV4cG9ydCBkZWZhdWx0IGFwcFJlZHVjZXJzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvcmVkdWNlcnMvaW5kZXguanMiLCJpbXBvcnQgeyByZXBsYWNlSW5Qb3NpdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZnVuY3Rpb24gdXBkYXRlQW5zd2VyKCBzdGF0ZSwgYWN0aW9uICkge1xuXHRjb25zdCB7IGFuc3dlciB9ID0gYWN0aW9uO1xuXHRjb25zdCBhbnN3ZXJJbmRleCA9IHN0YXRlLmZpbmRJbmRleCggYW5zd2VyT2JqID0+IGFuc3dlck9iai5lbGVtZW50X2lkID09PSBhbnN3ZXIuZWxlbWVudF9pZCApO1xuXG5cdHN0YXRlID0gcmVwbGFjZUluUG9zaXRpb24oIHN0YXRlLCBhbnN3ZXJJbmRleCwgYW5zd2VyICk7XG5cblx0cmV0dXJuIHN0YXRlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhbnN3ZXJzKCBzdGF0ZSA9IFtdLCBhY3Rpb24gKSB7XG5cdHN3aXRjaCAoIGFjdGlvbi50eXBlICkge1xuXHRcdGNhc2UgJ1VQREFURV9BTlNXRVJTJzpcblx0XHRcdHJldHVybiBhY3Rpb24uYW5zd2Vycztcblx0XHRjYXNlICdVUERBVEVfQU5TV0VSJzpcblx0XHRcdHJldHVybiB1cGRhdGVBbnN3ZXIoIFsgLi4uc3RhdGUgXSwgYWN0aW9uICk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBzdGF0ZTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvcmVkdWNlcnMvYW5zd2Vycy5qcyIsImZ1bmN0aW9uIHVwZGF0ZVNldHRpbmcoIHN0YXRlLCBhY3Rpb24gKSB7XG5cdGNvbnN0IHsgc2V0dGluZywgdmFsdWUgfSA9IGFjdGlvbjtcblxuXHQvLyBVcGRhdGUgdmFsdWVcblx0c3RhdGVbIHNldHRpbmcgXSA9IHZhbHVlO1xuXG5cdHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU2V0dGluZ3MoIHN0YXRlLCBhY3Rpb24gKSB7XG5cdGNvbnN0IHsgc2V0dGluZ3MgfSA9IGFjdGlvbjtcblxuXHRyZXR1cm4ge1xuXHRcdC4uLnN0YXRlLFxuXHRcdC4uLnNldHRpbmdzXG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlVGl0bGUoIHN0YXRlLCBhY3Rpb24gKSB7XG5cdGNvbnN0IHsgdGl0bGUgfSA9IGFjdGlvbjtcblxuXHQvLyBVcGRhdGUgdmFsdWVcblx0c3RhdGUuZm9ybU5hbWUgPSB0aXRsZTtcblxuXHRyZXR1cm4gc3RhdGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHRpbmdzKCBzdGF0ZSA9IFtdLCBhY3Rpb24gKSB7XG5cdGNvbnN0IG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbigge30sIHN0YXRlICk7XG5cblx0c3dpdGNoICggYWN0aW9uLnR5cGUgKSB7XG5cdFx0Y2FzZSAnVVBEQVRFX1NFVFRJTkdTJzpcblx0XHRcdHJldHVybiB1cGRhdGVTZXR0aW5ncyggbmV3U3RhdGUsIGFjdGlvbiApO1xuXHRcdGNhc2UgJ1VQREFURV9TRVRUSU5HJzpcblx0XHRcdHJldHVybiB1cGRhdGVTZXR0aW5nKCBuZXdTdGF0ZSwgYWN0aW9uICk7XG5cdFx0Y2FzZSAnVVBEQVRFX1RJVExFJzpcblx0XHRcdHJldHVybiB1cGRhdGVUaXRsZSggbmV3U3RhdGUsIGFjdGlvbiApO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL3JlZHVjZXJzL3NldHRpbmdzLmpzIiwiY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuXHRtb2RhbFR5cGU6IG51bGwsXG5cdG1vZGFsUHJvcHM6IHt9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgKCBzdGF0ZSA9IGluaXRpYWxTdGF0ZSwgYWN0aW9uICkgPT4ge1xuXHRzd2l0Y2ggKCBhY3Rpb24udHlwZSApIHtcblx0XHRjYXNlICdTSE9XX01PREFMJzpcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG1vZGFsUHJvcHM6IGFjdGlvbi5tb2RhbFByb3BzLFxuXHRcdFx0XHRtb2RhbFR5cGU6IGFjdGlvbi5tb2RhbFR5cGUsXG5cdFx0XHRcdHR5cGU6IGFjdGlvbi50eXBlLFxuXHRcdFx0fTtcblx0XHRjYXNlICdISURFX01PREFMJzpcblx0XHRcdHJldHVybiBpbml0aWFsU3RhdGU7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBzdGF0ZTtcblx0fVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL3JlZHVjZXJzL21vZGFsLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgUm91dGUsIFJlZGlyZWN0LCBMaW5rIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgSGVhZGVyIGZyb20gJy4vaGVhZGVyJztcbmltcG9ydCBNb2RhbCBmcm9tICcuL21vZGFsJztcbmltcG9ydCBNZXRhIGZyb20gJy4vbWV0YSc7XG5pbXBvcnQgTmF2aWdhdGlvbiBmcm9tICcuL25hdmlnYXRpb24nO1xuXG5pbXBvcnQgQnVpbGRlciBmcm9tICcuL2J1aWxkZXInO1xuaW1wb3J0IEFwcGVhcmFuY2UgZnJvbSAnLi9hcHBlYXJhbmNlJztcbmltcG9ydCBCZWhhdmlvdXIgZnJvbSAnLi9iZWhhdmlvdXInO1xuaW1wb3J0IE5vdGlmaWNhdGlvbnMgZnJvbSAnLi9ub3RpZmljYXRpb25zJztcbmltcG9ydCBJbnRlZ3JhdGlvbnMgZnJvbSAnLi9pbnRlZ3JhdGlvbnMnO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4vc2V0dGluZ3MnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWluIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnYmVmb3JldW5sb2FkJywgdGhpcy5oYW5kbGVCZWZvcmV1bmxvYWQgKTtcblxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnc2Nyb2xsJywgdGhpcy5hcHBseVN0aWNreS5iaW5kKCB0aGlzICkgKTtcblx0fVxuXHRjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2JlZm9yZXVubG9hZCcsIHRoaXMuaGFuZGxlQmVmb3JldW5sb2FkICk7XG5cdH1cblx0YXBwbHlTdGlja3koKSB7XG5cdFx0Y29uc3Qgbm9kZSA9IHRoaXMucmVmcy5TdGlja3lIZWFkZXI7XG5cdFx0Y29uc3QgY3VycmVudE9mZnNldCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuXHRcdGNvbnN0IHN0aWNreU9mZnNldCA9IHBhcnNlSW50KCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbm9kZSApLnRvcC5yZXBsYWNlKCAncHgnLCAnJyApICk7XG5cdFx0Y29uc3QgaXNTdHVjayA9IGN1cnJlbnRPZmZzZXQgPD0gc3RpY2t5T2Zmc2V0O1xuXG5cdFx0aWYgKCBpc1N0dWNrICkge1xuXHRcdFx0bm9kZS5jbGFzc0xpc3QuYWRkKCAnc3VpLWlzLXN0aWNreScgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bm9kZS5jbGFzc0xpc3QucmVtb3ZlKCAnc3VpLWlzLXN0aWNreScgKTtcblx0XHR9XG5cdH1cblx0aGFuZGxlQmVmb3JldW5sb2FkKCBlICkge1xuXHRcdGlmICggd2luZG93LmZvcm1pbmF0b3JDaGFuZ2VzLmxlbmd0aCA+IDAgfHwgd2luZG93LmZvcm1pbmF0b3JDaGFuZ2VzLnNldHRpbmdzID09PSB0cnVlICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0ZS5yZXR1cm5WYWx1ZSA9IHRyYW5zbGF0ZShcblx0XHRcdFx0J1lvdSBoYXZlIHVuc2F2ZWQgY2hhbmdlcywgYXJlIHlvdSBzdXJlIHdhbnQgdG8gbGVhdmUgdGhpcyBwYWdlJ1xuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0cmFuc2xhdGUoICdZb3UgaGF2ZSB1bnNhdmVkIGNoYW5nZXMsIGFyZSB5b3Ugc3VyZSB3YW50IHRvIGxlYXZlIHRoaXMgcGFnZScgKTtcblx0XHR9XG5cdH1cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2PlxuXG5cdFx0XHRcdDxIZWFkZXIgLz5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1yb3ctd2l0aC1zaWRlbmF2XCI+XG5cblx0XHRcdFx0XHQ8TmF2aWdhdGlvbiB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXG5cdFx0XHRcdFx0PGRpdj5cblxuXHRcdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0XHRpZD1cImZvcm1pbmF0b3ItYnVpbGRlci1zdGF0dXNcIlxuXHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktYm94IHN1aS1ib3gtc3RpY2t5XCJcblx0XHRcdFx0XHRcdFx0cmVmPVwiU3RpY2t5SGVhZGVyXCJcblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0PE1ldGEgLz5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0XHQ8Um91dGUgZXhhY3QgcGF0aD1cIi9cIiByZW5kZXI9eyAoKSA9PiA8UmVkaXJlY3QgdG89XCIvYnVpbGRlclwiIC8+IH0gLz5cblx0XHRcdFx0XHRcdDxSb3V0ZSBwYXRoPVwiL2J1aWxkZXJcIiBjb21wb25lbnQ9eyBCdWlsZGVyIH0gLz5cblx0XHRcdFx0XHRcdDxSb3V0ZSBwYXRoPVwiL2FwcGVhcmFuY2VcIiBjb21wb25lbnQ9eyBBcHBlYXJhbmNlIH0gLz5cblx0XHRcdFx0XHRcdDxSb3V0ZSBwYXRoPVwiL2JlaGF2aW91clwiIGNvbXBvbmVudD17IEJlaGF2aW91ciB9IC8+XG5cdFx0XHRcdFx0XHQ8Um91dGUgcGF0aD1cIi9ub3RpZmljYXRpb25zXCIgY29tcG9uZW50PXsgTm90aWZpY2F0aW9ucyB9IC8+XG5cdFx0XHRcdFx0XHQ8Um91dGUgcGF0aD1cIi9pbnRlZ3JhdGlvbnNcIiBjb21wb25lbnQ9eyBJbnRlZ3JhdGlvbnMgfSAvPlxuXHRcdFx0XHRcdFx0PFJvdXRlIHBhdGg9XCIvc2V0dGluZ3NcIiBjb21wb25lbnQ9eyBTZXR0aW5ncyB9IC8+XG5cblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8TW9kYWwgeyAuLi50aGlzLnByb3BzIH0gLz5cblxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29udGFpbmVycy9tYWluLmpzIiwiaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcblxuaW1wb3J0ICogYXMgc2V0dGluZ3NBY3Rpb25zIGZyb20gJy4uL2FjdGlvbnMvc2V0dGluZ3MnO1xuaW1wb3J0ICogYXMgbW9kYWxBY3Rpb25zIGZyb20gJy4uL2FjdGlvbnMvbW9kYWwnO1xuaW1wb3J0ICogYXMgbmF2aWdhdGlvbkFjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucy9uYXZpZ2F0aW9uJztcbmltcG9ydCBIZWFkZXIgZnJvbSAnLi4vY29tcG9uZW50cy9oZWFkZXInO1xuXG5mdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHMoIHN0YXRlICkge1xuXHRyZXR1cm4ge1xuXHRcdGlkOiBzdGF0ZS5zZXR0aW5ncy5mb3JtX2lkLFxuXHRcdHRpdGxlOiBzdGF0ZS5zZXR0aW5ncy5mb3JtTmFtZSB8fCAnJyxcblx0fTtcbn1cblxuZnVuY3Rpb24gbWFwRGlzcGF0Y2hUb1Byb3BzKCBkaXNwYXRjaCApIHtcblx0cmV0dXJuIHtcblx0XHRhY3Rpb25zOiB7XG5cdFx0XHRuYXZpZ2F0aW9uQWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKCBuYXZpZ2F0aW9uQWN0aW9ucywgZGlzcGF0Y2ggKSxcblx0XHRcdG1vZGFsQWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKCBtb2RhbEFjdGlvbnMsIGRpc3BhdGNoICksXG5cdFx0XHRzZXR0aW5nc0FjdGlvbnM6IGJpbmRBY3Rpb25DcmVhdG9ycyggc2V0dGluZ3NBY3Rpb25zLCBkaXNwYXRjaCApXG5cdFx0fSxcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChcblx0bWFwU3RhdGVUb1Byb3BzLFxuXHRtYXBEaXNwYXRjaFRvUHJvcHNcbikoIEhlYWRlciApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29udGFpbmVycy9oZWFkZXIuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgRG9jdW1lbnRhdGlvbiBmcm9tICcuL2hlYWRlci9kb2N1bWVudGF0aW9uJztcbmltcG9ydCBUaXRsZSBmcm9tICcuL2hlYWRlci90aXRsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhlYWRlciggcHJvcHMgKSB7XG5cdHJldHVybiAoXG5cdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktaGVhZGVyIGZ1aS1oZWFkZXItd2l0aC1zZXR0aW5nc1wiPlxuXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZ1aS1oZWFkZXItdGl0bGVcIj5cblxuXHRcdFx0XHQ8aDEgY2xhc3NOYW1lPVwic3VpLWhlYWRlci10aXRsZVwiPnsgdHJhbnNsYXRlKCAnRWRpdCBQb2xsJyApIH08L2gxPlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWFjdGlvbnMtcmlnaHRcIj5cblx0XHRcdFx0XHQ8RG9jdW1lbnRhdGlvbiB7IC4uLnByb3BzIH0gLz5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZ1aS1oZWFkZXItc2V0dGluZ3NcIj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1hY3Rpb25zLWxlZnRcIj5cblx0XHRcdFx0XHQ8VGl0bGUgeyAuLi5wcm9wcyB9IC8+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWFjdGlvbnMtcmlnaHRcIj5cblx0XHRcdFx0XHQ8RG9jdW1lbnRhdGlvbiB7IC4uLnByb3BzIH0gLz5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdDwvZGl2PlxuXG5cdFx0PC9kaXY+XG5cdCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL2hlYWRlci5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERvY3VtZW50YXRpb24oIHByb3BzICkge1xuXHRpZiAoICEgZm9ybWluYXRvckRhdGEuc2hvd0RvY0xpbmsgKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cdHJldHVybiAoXG5cdFx0PGFcblx0XHRcdGhyZWY9XCJodHRwczovL3dwbXVkZXYuY29tL2RvY3Mvd3BtdS1kZXYtcGx1Z2lucy9mb3JtaW5hdG9yLyNwb2xsc1wiXG5cdFx0XHR0YXJnZXQ9XCJfYmxhbmtcIlxuXHRcdFx0Y2xhc3NOYW1lPVwic3VpLWJ1dHRvbiBzdWktYnV0dG9uLWdob3N0XCJcblx0XHQ+XG5cdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktaWNvbi1hY2FkZW15XCIgLz4geyB0cmFuc2xhdGUoICdWaWV3IERvY3VtZW50YXRpb24nICkgfVxuXHRcdDwvYT5cblx0KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbXBvbmVudHMvaGVhZGVyL2RvY3VtZW50YXRpb24uanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMnO1xuaW1wb3J0IE1ldGFEcm9wZG93biBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2xheW91dC9tZXRhLWRyb3Bkb3duJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGl0bGUgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHRjb25zdCAkbW9kdWxlTmFtZSA9IGpRdWVyeSggJy5zdWktc2lkZW5hdiAuc3VpLXdpdGgtZmxvYXRpbmctaW5wdXQnICksXG5cdFx0XHQkcGFnZUhlYWRlciA9IGpRdWVyeSggJy5zdWktaGVhZGVyJyApLFxuXHRcdFx0JHBhZ2VUaXRsZSA9ICRwYWdlSGVhZGVyLmZpbmQoICcuc3VpLWhlYWRlci10aXRsZScgKSxcblx0XHRcdCR0aXRsZVdpZHRoID0gJHBhZ2VUaXRsZS53aWR0aCgpLFxuXHRcdFx0JG5hdldpZHRoID0gJHBhZ2VIZWFkZXIubmV4dCgpLmZpbmQoICcuc3VpLXNpZGVuYXYnICkud2lkdGgoKVxuXHRcdDtcblxuXHRcdGlmICggJHRpdGxlV2lkdGggPiAkbmF2V2lkdGggKSB7XG5cdFx0XHQkbW9kdWxlTmFtZS5jc3MoIHtcblx0XHRcdFx0bGVmdDogKCAkdGl0bGVXaWR0aCArIDIwICkgKyAncHgnLFxuXHRcdFx0fSApO1xuXHRcdH1cblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCB7IHRpdGxlIH0gPSB0aGlzLnByb3BzO1xuXHRcdGNvbnN0IGVtcHR5VGl0bGUgPSBfLmlzRW1wdHkoIHRpdGxlLnRyaW0oKSApO1xuXHRcdGNvbnN0IGN1c3RvbUNsYXNzID0gZW1wdHlUaXRsZSA/ICdzdWktZm9ybS1maWVsZC1lcnJvcicgOiAnJztcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXsgYHN1aS1mb3JtLWZpZWxkICR7IGN1c3RvbUNsYXNzIH1gIH0+XG5cblx0XHRcdFx0XHQ8bGFiZWxcblx0XHRcdFx0XHRcdGh0bWxGb3I9XCJmb3JtaW5hdG9yLXNldC10aXRsZVwiXG5cdFx0XHRcdFx0XHRpZD1cImZvcm1pbmF0b3Itc2V0LXRpdGxlLWxhYmVsXCJcblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1zY3JlZW4tcmVhZGVyLXRleHRcIlxuXHRcdFx0XHRcdD57IHRyYW5zbGF0ZSggJ05hbWUgeW91ciBwb2xsJyApIH08L2xhYmVsPlxuXG5cdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0XHR2YWx1ZT17IHRpdGxlIH1cblx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPXsgdHJhbnNsYXRlKCAnR2l2ZSB5b3VyIHBvbGwgYSBuYW1lJyApIH1cblx0XHRcdFx0XHRcdGlkPVwiZm9ybWluYXRvci1zZXQtdGl0bGVcIlxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWZvcm0tY29udHJvbFwiXG5cdFx0XHRcdFx0XHRhcmlhLWxhYmVsbGVkYnk9XCJmb3JtaW5hdG9yLXNldC10aXRsZS1sYWJlbFwiXG5cdFx0XHRcdFx0XHRhcmlhLWRlc2NyaWJlZGJ5PVwiZm9ybWluYXRvci1zZXQtdGl0bGUtbWVzc2FnZVwiXG5cdFx0XHRcdFx0XHRhcmlhLXJlcXVpcmVkPVwidHJ1ZVwiXG5cdFx0XHRcdFx0XHRhY2Nlc3NLZXk9XCJ0XCJcblx0XHRcdFx0XHRcdG9uQ2hhbmdlPXsgZSA9PiB0aGlzLnByb3BzLmFjdGlvbnMubmF2aWdhdGlvbkFjdGlvbnMudXBkYXRlVGl0bGUoXG5cdFx0XHRcdFx0XHRcdGUudGFyZ2V0LnZhbHVlXG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0PHBcblx0XHRcdFx0XHRcdHJvbGU9XCJhbGVydFwiXG5cdFx0XHRcdFx0XHRpZD1cImZvcm1pbmF0b3Itc2V0LXRpdGxlLW1lc3NhZ2VcIlxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWVycm9yLW1lc3NhZ2VcIlxuXHRcdFx0XHRcdFx0c3R5bGU9eyB7XG5cdFx0XHRcdFx0XHRcdGRpc3BsYXk6IGVtcHR5VGl0bGUgPyAnYmxvY2snIDogJ25vbmUnLFxuXHRcdFx0XHRcdFx0XHRtYXJnaW5Cb3R0b206IDAsXG5cdFx0XHRcdFx0XHR9IH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IGVtcHR5VGl0bGUgJiYgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHQnUGxlYXNlLCBlbnRlciBhIHZhbGlkIG5hbWUuJ1xuXHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0PC9wPlxuXG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxNZXRhRHJvcGRvd25cblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdHR5cGU9XCJwb2xsXCJcblx0XHRcdFx0Lz5cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9oZWFkZXIvdGl0bGUuanMiLCJpbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnO1xuXG5pbXBvcnQgTW9kYWwgZnJvbSAnLi4vY29tcG9uZW50cy9tb2RhbCc7XG5pbXBvcnQgKiBhcyBidWlsZGVyQWN0aW9ucyBmcm9tICcuLi9hY3Rpb25zL2J1aWxkZXInO1xuaW1wb3J0ICogYXMgc2V0dGluZ3NBY3Rpb25zIGZyb20gJy4uL2FjdGlvbnMvc2V0dGluZ3MnO1xuXG5mdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHMoIHN0YXRlICkge1xuXHRyZXR1cm4ge1xuXHRcdG1vZGFsOiBzdGF0ZS5tb2RhbCxcblx0XHRhbnN3ZXJzOiBzdGF0ZS5hbnN3ZXJzLFxuXHRcdHNldHRpbmdzOiBzdGF0ZS5zZXR0aW5ncyxcblx0XHRpZDogc3RhdGUuc2V0dGluZ3MuZm9ybV9pZCxcblx0fTtcbn1cblxuZnVuY3Rpb24gbWFwRGlzcGF0Y2hUb1Byb3BzKCBkaXNwYXRjaCApIHtcblx0cmV0dXJuIHtcblx0XHRhY3Rpb25zOiB7XG5cdFx0XHRidWlsZGVyQWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKCBidWlsZGVyQWN0aW9ucywgZGlzcGF0Y2ggKSxcblx0XHRcdHNldHRpbmdzQWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKCBzZXR0aW5nc0FjdGlvbnMsIGRpc3BhdGNoICksXG5cdFx0fSxcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChcblx0bWFwU3RhdGVUb1Byb3BzLFxuXHRtYXBEaXNwYXRjaFRvUHJvcHNcbikoIE1vZGFsICk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb250YWluZXJzL21vZGFsLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5pbXBvcnQgeyBkZWZhdWx0IGFzIG1vZGFsVHlwZXMgfSBmcm9tICcuL21vZGFscyc7XG5pbXBvcnQgRm9jdXNUcmFwIGZyb20gJy4uLy4uL2Zvcm0vY29tcG9uZW50cy9tb2RhbHMvcGFydGlhbHMvZm9jdXMtdHJhcCc7XG5pbXBvcnQgZGlzcGxhY2UgZnJvbSAncmVhY3QtZGlzcGxhY2UnO1xuXG5jb25zdCBNT0RBTF9UWVBFUyA9IHtcblx0cHJldmlldzogbW9kYWxUeXBlcy5wcmV2aWV3TW9kYWwsXG5cdHB1Ymxpc2g6IG1vZGFsVHlwZXMucHVibGlzaE1vZGFsLFxuXHRzaG9ydGNvZGU6IG1vZGFsVHlwZXMuc2hvcnRjb2RlTW9kYWwsXG5cdGRlbGV0ZTogbW9kYWxUeXBlcy5kZWxldGVNb2RhbCxcbn07XG5cbi8qIGdsb2JhbCBzZXRUaW1lb3V0LGNsZWFyVGltZW91dCAqL1xuY2xhc3MgTW9kYWwgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRjb21wb25lbnREaWRVcGRhdGUoIHByZXZQcm9wcyApIHtcblx0XHR0aGlzLiRlbCA9IGpRdWVyeSggdGhpcy5lbCApO1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCBwcmV2UHJvcHMubW9kYWwubW9kYWxQcm9wcy5vcGVuICE9PSB0aGlzLnByb3BzLm1vZGFsLm1vZGFsUHJvcHMub3BlbiApIHtcblx0XHRcdGNvbnN0IG1vZGFsRWxlbWVudCA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKCB0aGlzICk7XG5cblx0XHRcdGlmICggdGhpcy5wcm9wcy5tb2RhbC5tb2RhbFByb3BzLm9wZW4gKSB7XG5cdFx0XHRcdHRoaXMuZm9jdXNBZnRlckNsb3NlZCA9IHRoaXMucHJvcHMubW9kYWwubW9kYWxQcm9wcy5hY3RpdmVFbGVtZW50O1xuXG5cdFx0XHRcdGNvbnN0IGZvY3VzRmlyc3QgPSB0aGlzLnByb3BzLm1vZGFsLm1vZGFsUHJvcHMuZm9jdXNGaXJzdDtcblxuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoICdzdHJpbmcnID09PSB0eXBlb2YgZm9jdXNGaXJzdCApIHtcblx0XHRcdFx0XHRcdHNlbGYuZm9jdXNGaXJzdCA9IHNlbGYuJGVsLmZpbmQoIGZvY3VzRmlyc3QgKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAnb2JqZWN0JyA9PT0gdHlwZW9mIGZvY3VzRmlyc3QgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLmZvY3VzRmlyc3QgPSBmb2N1c0ZpcnN0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmZvY3VzRmlyc3QgPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggc2VsZi5mb2N1c0ZpcnN0ICYmIHNlbGYuZm9jdXNGaXJzdC5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnNldEZvY3VzKCBzZWxmLmZvY3VzRmlyc3QuZmlyc3QoKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgMzIwICk7XG5cblx0XHRcdFx0alF1ZXJ5KCAnI3dwd3JhcCcgKS5hdHRyKCAnYXJpYS1oaWRkZW4nLCAndHJ1ZScgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIHRoaXMucHJvcHMubW9kYWwubW9kYWxQcm9wcy5vcGVuICkge1xuXHRcdFx0XHRqUXVlcnkoICcjd3B3cmFwJyApLmF0dHIoICdhcmlhLWhpZGRlbicsICdmYWxzZScgKTtcblxuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLnNldEZvY3VzKCBzZWxmLmZvY3VzQWZ0ZXJDbG9zZWQgKTtcblx0XHRcdFx0fSwgMzIwICk7XG5cblx0XHRcdFx0dGhpcy5oaWRlTW9kYWxUaW1lb3V0ID0gc2V0VGltZW91dCggKCkgPT4ge1xuXHRcdFx0XHRcdG1vZGFsRWxlbWVudC5zZXRBdHRyaWJ1dGUoICdhcmlhLWhpZGRlbicsICd0cnVlJyApO1xuXHRcdFx0XHRcdC8vIGNsZWFudXBcblx0XHRcdFx0XHR0aGlzLnByb3BzLm1vZGFsLm1vZGFsVHlwZSA9IG51bGw7XG5cdFx0XHRcdFx0dGhpcy5mb3JjZVVwZGF0ZSgpO1xuXHRcdFx0XHR9LCAzMDAgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1vZGFsRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoICdhcmlhLWhpZGRlbicgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRzZXRGb2N1cyggZWxlbWVudCApIHtcblx0XHRjb25zdCBmb2N1c0ludGVydmFsID0gMTA7IC8vIG1zLCB0aW1lIGJldHdlZW4gZnVuY3Rpb24gY2FsbHNcblx0XHRjb25zdCBmb2N1c1RvdGFsUmVwZXRpdGlvbnMgPSAxMDsgLy8gbnVtYmVyIG9mIHJlcGV0aXRpb25zXG5cblx0XHRpZiAoIHR5cGVvZiBlbGVtZW50ID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRlbGVtZW50LmF0dHIoICd0YWJpbmRleCcsICcwJyApO1xuXHRcdGVsZW1lbnQuYmx1cigpO1xuXG5cdFx0bGV0IGZvY3VzUmVwZXRpdGlvbnMgPSAwO1xuXHRcdGNvbnN0IGludGVydmFsID0gd2luZG93LnNldEludGVydmFsKCBmdW5jdGlvbigpIHtcblx0XHRcdGVsZW1lbnQuZm9jdXMoKTtcblx0XHRcdGZvY3VzUmVwZXRpdGlvbnMrKztcblxuXHRcdFx0aWYgKCBmb2N1c1JlcGV0aXRpb25zID49IGZvY3VzVG90YWxSZXBldGl0aW9ucyApIHtcblx0XHRcdFx0d2luZG93LmNsZWFySW50ZXJ2YWwoIGludGVydmFsICk7XG5cdFx0XHR9XG5cdFx0fSwgZm9jdXNJbnRlcnZhbCApO1xuXHR9XG5cblx0Y29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLmhpZGVNb2RhbFRpbWVvdXQgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRpZiAoICEgdGhpcy5wcm9wcy5tb2RhbC5tb2RhbFR5cGUgKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRsZXQgbW9kYWxDbGFzcyA9ICdzdWktbW9kYWwtbGcnO1xuXHRcdGxldCBvdmVybGF5Q2xhc3MgPSBbICdzdWktbW9kYWwtY29udGVudCcsICdzdWktY29udGVudC1mYWRlLWluJyBdO1xuXHRcdGlmICggISB0aGlzLnByb3BzLm1vZGFsLm1vZGFsUHJvcHMub3BlbiApIHtcblx0XHRcdG92ZXJsYXlDbGFzcyA9IFsgJ3N1aS1tb2RhbC1jb250ZW50JywgJ3N1aS1jb250ZW50LWZhZGUtb3V0JyBdO1xuXHRcdH1cblxuXHRcdGNvbnN0IFNwZWNpZmllZE1vZGFsID0gTU9EQUxfVFlQRVNbIHRoaXMucHJvcHMubW9kYWwubW9kYWxUeXBlIF07XG5cblx0XHRpZiAoIHRoaXMucHJvcHMubW9kYWwubW9kYWxUeXBlID09PSAncHVibGlzaCcgKSB7XG5cdFx0XHRtb2RhbENsYXNzID0gJ3N1aS1tb2RhbC1zbSBmdWktZGlhbG9nLXB1Ymxpc2gnO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5wcm9wcy5tb2RhbC5tb2RhbFR5cGUgPT09ICdzaG9ydGNvZGUnICkge1xuXHRcdFx0bW9kYWxDbGFzcyA9ICdzdWktbW9kYWwtc20gZnVpLWRpYWxvZy1wdWJsaXNoJztcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMucHJvcHMubW9kYWwubW9kYWxUeXBlID09PSAnZGVsZXRlJyApIHtcblx0XHRcdG1vZGFsQ2xhc3MgPSAnc3VpLW1vZGFsLXNtJztcblx0XHR9XG5cblx0XHRjb25zdCBjbGFzc2VzID0galF1ZXJ5KCAnLnN1aS1jb2xvci1hY2Nlc3NpYmxlJyApLmxlbmd0aCA/ICdzdWktd3JhcCBzdWktY29sb3ItYWNjZXNzaWJsZScgOiAnc3VpLXdyYXAnO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPXsgY2xhc3NlcyB9PlxuXHRcdFx0XHQ8ZGl2IGlkPVwiZm9ybWluYXRvci1tb2RhbFwiIGNsYXNzTmFtZT17IGBzdWktbW9kYWwgc3VpLWFjdGl2ZSAkeyBtb2RhbENsYXNzIH1gIH0+XG5cdFx0XHRcdFx0ey8qIDxGb2N1c1RyYXA+ICovfVxuXHRcdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRcdHJvbGU9XCJkaWFsb2dcIlxuXHRcdFx0XHRcdFx0aWQ9eyBgbW9kYWwtJHsgdGhpcy5wcm9wcy5tb2RhbC5tb2RhbFByb3BzLmlkIH1gIH1cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT17IGAkeyBvdmVybGF5Q2xhc3Muam9pbiggJyAnICkgfWAgfVxuXHRcdFx0XHRcdFx0YXJpYS1tb2RhbD1cInRydWVcIlxuXHRcdFx0XHRcdFx0YXJpYS1saXZlPVwicG9saXRlXCJcblx0XHRcdFx0XHRcdHsgLi4uKCB0aGlzLnByb3BzLm1vZGFsLm1vZGFsUHJvcHMubGFiZWxsZWRCeSAmJlxuXHRcdFx0XHRcdFx0XHRcdHsgJ2FyaWEtbGFiZWxsZWRieSc6IHRoaXMucHJvcHMubW9kYWwubW9kYWxQcm9wcy5sYWJlbGxlZEJ5IH1cblx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdFx0eyAuLi4oIHRoaXMucHJvcHMubW9kYWwubW9kYWxQcm9wcy5kZXNjcmliZWRCeSAmJlxuXHRcdFx0XHRcdFx0XHRcdHsgJ2FyaWEtZGVzY3JpYmVkYnknOiB0aGlzLnByb3BzLm1vZGFsLm1vZGFsUHJvcHMuZGVzY3JpYmVkQnkgfVxuXHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0XHRyZWY9eyBlbCA9PiAoIHRoaXMuZWwgPSBlbCApIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3hcIj5cblx0XHRcdFx0XHRcdFx0PFNwZWNpZmllZE1vZGFsIHsgLi4udGhpcy5wcm9wcyB9IC8+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHR7LyogPC9Gb2N1c1RyYXA+ICovfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuY29uc3QgRGlzcGxhY2VkTW9kYWwgPSBkaXNwbGFjZSggTW9kYWwgKTtcblxuRGlzcGxhY2VkTW9kYWwucmVuZGVyVG8gPSBmdW5jdGlvbiggaW5wdXQgKSB7XG5cdHJldHVybiBkaXNwbGFjZSggTW9kYWwsIHsgcmVuZGVyVG86IGlucHV0IH0gKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGxhY2VkTW9kYWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL21vZGFsLmpzIiwiaW1wb3J0IHByZXZpZXdNb2RhbCBmcm9tICcuL3ByZXZpZXcnO1xuaW1wb3J0IHB1Ymxpc2hNb2RhbCBmcm9tICcuL3B1Ymxpc2gnO1xuaW1wb3J0IHNob3J0Y29kZU1vZGFsIGZyb20gJy4vc2hvcnRjb2RlJztcbmltcG9ydCBkZWxldGVNb2RhbCBmcm9tICcuL2RlbGV0ZSc7XG5cbmNvbnN0IG1vZGFsVHlwZXMgPSB7XG5cdHByZXZpZXdNb2RhbCxcblx0cHVibGlzaE1vZGFsLFxuXHRzaG9ydGNvZGVNb2RhbCxcblx0ZGVsZXRlTW9kYWwsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBtb2RhbFR5cGVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9tb2RhbHMvaW5kZXguanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgeyBCb3hIZWFkZXIgfSBmcm9tICdAd3BtdWRldi9yZWFjdC1ib3gnO1xuaW1wb3J0IHsgQnV0dG9uSWNvbiB9IGZyb20gJ0B3cG11ZGV2L3JlYWN0LWJ1dHRvbi1pY29uJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgcHJldmlld01vZGFsIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy5jbG9zZU1vZGFsID0gdGhpcy5wcm9wcy5tb2RhbC5tb2RhbFByb3BzLmNsb3NlTW9kYWwuYmluZCggdGhpcyApO1xuXHRcdHRoaXMucHJldmlld0xvYWRlZCA9IHRoaXMucHJldmlld0xvYWRlZC5iaW5kKCB0aGlzICk7XG5cdH1cblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLiRlbCA9IGpRdWVyeSggdGhpcy5lbCApO1xuXHRcdHRoaXMuJGJvZHkgPSBqUXVlcnkoIHRoaXMuYm9keSApO1xuXHRcdHRoaXMubW91bnRlZCA9IHRydWU7XG5cblx0XHR0aGlzLmxvYWQoKTtcblxuXHRcdGpRdWVyeSggZG9jdW1lbnQgKS5vZmYoICdhZnRlci5sb2FkLmZvcm1pbmF0b3InICk7XG5cdFx0alF1ZXJ5KCBkb2N1bWVudCApLm9uKCAnYWZ0ZXIubG9hZC5mb3JtaW5hdG9yJywgdGhpcy5wcmV2aWV3TG9hZGVkICk7XG5cdH1cblxuXHRjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0XHR0aGlzLm1vdW50ZWQgPSBmYWxzZTtcblx0fVxuXG5cdHByZXZpZXdMb2FkZWQoKSB7XG5cdFx0dGhpcy4kYm9keS5maW5kKCAnLnN1aS1ub3RpY2UtbG9hZGluZycgKS5yZW1vdmUoKTtcblx0fVxuXG5cdGxvYWQoKSB7XG5cdFx0Y29uc3Qgc3RhdGUgPSB7XG5cdFx0XHRhbnN3ZXJzOiB0aGlzLnByb3BzLmFuc3dlcnMsXG5cdFx0XHRzZXR0aW5nczogdGhpcy5wcm9wcy5zZXR0aW5ncyxcblx0XHR9O1xuXG5cdFx0Y29uc3QgY29uZmlnID0ge1xuXHRcdFx0aWQ6IHRoaXMucHJvcHMuaWQsXG5cdFx0XHRhY3Rpb246ICdmb3JtaW5hdG9yX2xvYWRfcG9sbCcsXG5cdFx0XHR0eXBlOiAnZm9ybWluYXRvcl9wb2xscycsXG5cdFx0XHRub25jZTogZm9ybWluYXRvckRhdGEucHJldmlld05vbmNlLFxuXHRcdFx0cmVuZGVyX2lkOiAwLFxuXHRcdFx0aXNfcHJldmlldzogMSxcblx0XHRcdHByZXZpZXdfZGF0YTogc3RhdGUsXG5cdFx0XHRsYXN0X3N1Ym1pdF9kYXRhOiB7fSxcblx0XHR9O1xuXHRcdHRoaXMuJGVsLmZvcm1pbmF0b3JMb2FkZXIoIGNvbmZpZyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdDxCb3hIZWFkZXJcblx0XHRcdFx0XHR0aXRsZT17IHRyYW5zbGF0ZSggJ1ByZXZpZXcnICkgfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0PEJ1dHRvbkljb25cblx0XHRcdFx0XHRcdGljb249XCJjbG9zZVwiXG5cdFx0XHRcdFx0XHRpY29uU2l6ZT1cIm1kXCJcblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQ2xvc2UgdGhpcyBkaWFsb2cgd2luZG93JyApIH1cblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLmNsb3NlTW9kYWwgfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQm94SGVhZGVyPlxuXG5cdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktYm94LWJvZHlcIlxuXHRcdFx0XHRcdHJlZj17IGJvZHkgPT4gKCB0aGlzLmJvZHkgPSBib2R5ICkgfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktbm90aWNlIHN1aS1ub3RpY2UtbG9hZGluZyBzdWktYWN0aXZlXCIgc3R5bGU9eyB7IGRpc3BsYXk6ICdibG9jaycgfSB9PlxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktbm90aWNlLWNvbnRlbnRcIj5cblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktbm90aWNlLW1lc3NhZ2VcIj5cblx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktbm90aWNlLWljb24gc3VpLWljb24tbG9hZGVyIHN1aS1sb2FkaW5nXCIgLz5cblx0XHRcdFx0XHRcdFx0XHQ8cD57IHRyYW5zbGF0ZSggJ0xvYWRpbmcgcHJldmlld+KApicgKSB9PC9wPlxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0PGZvcm1cblx0XHRcdFx0XHRcdHJlZj17IGVsID0+ICggdGhpcy5lbCA9IGVsICkgfVxuXHRcdFx0XHRcdFx0aWQ9eyBgZm9ybWluYXRvci1tb2R1bGUtJHsgdGhpcy5wcm9wcy5pZCB9YCB9XG5cdFx0XHRcdFx0XHRkYXRhLWZvcm1pbmF0b3ItcmVuZGVyPVwiMFwiXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktaGlkZGVuXCJcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9tb2RhbHMvcHJldmlldy5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHB1Ymxpc2hNb2RhbCBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblxuXHRcdHRoaXMuY2xvc2VNb2RhbCA9IHRoaXMucHJvcHMubW9kYWwubW9kYWxQcm9wcy5jbG9zZU1vZGFsLmJpbmQoIHRoaXMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPXtcblx0XHRcdFx0XHRcdCdzdWktYm94LWhlYWRlciAnICtcblx0XHRcdFx0XHRcdCdzdWktZmxhdHRlbiAnICtcblx0XHRcdFx0XHRcdCdzdWktY29udGVudC1jZW50ZXIgJyArXG5cdFx0XHRcdFx0XHQnc3VpLXNwYWNpbmctdG9wLS02MCcgK1xuXHRcdFx0XHRcdFx0YCR7IGZvcm1pbmF0b3JEYXRhLnNob3dCcmFuZGluZ1xuXHRcdFx0XHRcdFx0XHQ/ICcgc3VpLXNwYWNpbmctYm90dG9tLS0zMCdcblx0XHRcdFx0XHRcdFx0OiAnIHN1aS1zcGFjaW5nLWJvdHRvbS0tNjAnXG5cdFx0XHRcdFx0XHR9YFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1pY29uLWxvYWRlciBzdWktbG9hZGluZ1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG5cblx0XHRcdFx0XHQ8aDMgY2xhc3NOYW1lPVwic3VpLWJveC10aXRsZSBzdWktbGdcIiBpZD1cImRpYWxvZ1RpdGxlXCI+XG5cdFx0XHRcdFx0XHR7dHJhbnNsYXRlKCAnUHVibGlzaGluZyBwb2xs4oCmJyApfVxuXHRcdFx0XHRcdDwvaDM+XG5cblx0XHRcdFx0XHQ8cCBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj5cblx0XHRcdFx0XHRcdHt0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdCdHcmVhdCB3b3JrISBQbGVhc2UgaG9sZCB0aWdodCBhIGZldyBtb21lbnRzIHdoaWxlIHdlIHB1Ymxpc2ggeW91ciBmb3JtIHRvIHRoZSB3b3JsZC4nXG5cdFx0XHRcdFx0XHQpfVxuXHRcdFx0XHRcdDwvcD5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9tb2RhbHMvcHVibGlzaC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBOb3RpZmljYXRpb24gZnJvbSAnLi4vLi4vLi4vbm90aWZpY2F0aW9ucyc7XG5pbXBvcnQgeyBCdXR0b25JY29uIH0gZnJvbSAnQHdwbXVkZXYvcmVhY3QtYnV0dG9uLWljb24nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBzaG9ydGNvZGVNb2RhbCBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblxuXHRcdHRoaXMuY2xvc2VNb2RhbCA9IHRoaXMucHJvcHMubW9kYWwubW9kYWxQcm9wcy5jbG9zZU1vZGFsLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLmNvcHlUb0NsaXBib2FyZCA9IHRoaXMuY29weVRvQ2xpcGJvYXJkLmJpbmQoIHRoaXMgKTtcblx0fVxuXG5cdGNvcHlUb0NsaXBib2FyZCgpIHtcblx0XHR0aGlzLmlucHV0LnNlbGVjdCgpO1xuXHRcdGRvY3VtZW50LmV4ZWNDb21tYW5kKCAnY29weScgKTtcblxuXHRcdGNvbnN0IGN1c3RvbSA9IG5ldyBOb3RpZmljYXRpb24oIHtcblx0XHRcdHR5cGU6ICdzdWNjZXNzJyxcblx0XHRcdHRleHQ6IHRyYW5zbGF0ZSggJ1Nob3J0Y29kZSBoYXMgYmVlbiBjb3BpZWQgc3VjY2Vzc2Z1bGx5LicgKSxcblx0XHRcdHRpbWU6IDQwMDAsXG5cdFx0fSApO1xuXHRcdGN1c3RvbS5vcGVuKCk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LWhlYWRlciBzdWktZmxhdHRlbiBzdWktY29udGVudC1jZW50ZXIgc3VpLXNwYWNpbmctdG9wLS02MFwiPlxuXHRcdFx0XHRcdDxCdXR0b25JY29uXG5cdFx0XHRcdFx0XHRpY29uPVwiY2xvc2VcIlxuXHRcdFx0XHRcdFx0aWNvblNpemU9XCJtZFwiXG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0Nsb3NlIHRoaXMgZGlhbG9nIHdpbmRvdycgKSB9XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktYnV0dG9uLWZsb2F0LS1yaWdodCBmb3JtaW5hdG9yLWNhbmNlbC1jcmVhdGUtZm9ybVwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgdGhpcy5jbG9zZU1vZGFsIH1cblx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWljb24tY2hlY2sgc3VpLWxnXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cblxuXHRcdFx0XHRcdDxoM1xuXHRcdFx0XHRcdFx0aWQ9XCJkaWFsb2dUaXRsZVwiXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktYm94LXRpdGxlIHN1aS1sZ1wiXG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdSZWFkeSB0byBnbyEnICkgfVxuXHRcdFx0XHRcdDwvaDM+XG5cblx0XHRcdFx0XHQ8cCBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHQnWW91ciBwb2xsIGlzIG5vdyByZWFkeSB0byBiZSBlbWJlZGRlZCBpbnRvIGEgcGFnZSBvciB0ZW1wbGF0ZSAnICtcblx0XHRcdFx0XHRcdFx0J29mIHlvdXIgY2hvaWNlLiBTaW1wbHkgY29weSBhbmQgcGFzdGUgdGhlIHNob3J0Y29kZSBiZWxvdyB0byAnICtcblx0XHRcdFx0XHRcdFx0J2Rpc3BsYXkgaXQhJ1xuXHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0PC9wPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPXsgYHN1aS1ib3gtYm9keSR7IGZvcm1pbmF0b3JEYXRhLnNob3dCcmFuZGluZyA/ICcnIDogJyBzdWktc3BhY2luZy1ib3R0b20tLTYwJyB9YCB9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8ZGl2IGlkPVwiZm9ybWluYXRvci1mb3JtLW5hbWUtaW5wdXRcIiBjbGFzc05hbWU9XCJzdWktZm9ybS1maWVsZFwiPlxuXHRcdFx0XHRcdFx0PGxhYmVsIGh0bWxGb3I9XCJmb3JtaW5hdG9yLWZvcm0tbmFtZVwiIGNsYXNzTmFtZT1cInN1aS1sYWJlbFwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1Nob3J0Y29kZScgKSB9XG5cdFx0XHRcdFx0XHQ8L2xhYmVsPlxuXG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS13aXRoLWJ1dHRvbiBzdWktd2l0aC1idXR0b24taWNvblwiPlxuXHRcdFx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0XHRcdFx0aWQ9XCJmb3JtaW5hdG9yLWZvcm0tc2hvcnRjb2RlXCJcblx0XHRcdFx0XHRcdFx0XHRyZWY9eyAoIGlucHV0ICkgPT4gdGhpcy5pbnB1dCA9IGlucHV0IH1cblx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktZm9ybS1jb250cm9sXCJcblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9eyBgW2Zvcm1pbmF0b3JfcG9sbCBpZD1cIiR7IHRoaXMucHJvcHMuaWQgfVwiXWAgfVxuXHRcdFx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0XHRcdDxCdXR0b25JY29uXG5cdFx0XHRcdFx0XHRcdFx0aWNvbj1cImNvcHlcIlxuXHRcdFx0XHRcdFx0XHRcdGljb25TaXplPVwibWRcIlxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQ29weSBTaG9ydGNvZGUnICkgfVxuXHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLmNvcHlUb0NsaXBib2FyZCB9XG5cdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbXBvbmVudHMvbW9kYWxzL3Nob3J0Y29kZS5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBSb3V0ZSwgUmVkaXJlY3QsIE5hdkxpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSAnQHdwbXVkZXYvcmVhY3QtYnV0dG9uJztcbmltcG9ydCB7IEJ1dHRvbkljb24gfSBmcm9tICdAd3BtdWRldi9yZWFjdC1idXR0b24taWNvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGRlbGV0ZU1vZGFsIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy5jbG9zZU1vZGFsID0gdGhpcy5wcm9wcy5tb2RhbC5tb2RhbFByb3BzLmNsb3NlTW9kYWwuYmluZCggdGhpcyApO1xuXHRcdHRoaXMudHJhc2hGaWVsZCA9IHRoaXMudHJhc2hGaWVsZC5iaW5kKCB0aGlzICk7XG5cdH1cblxuXHR0cmFzaEZpZWxkKCkge1xuXHRcdC8vIERlbGV0ZSBmaWVsZFxuXHRcdHRoaXMucHJvcHMubW9kYWwubW9kYWxQcm9wcy50cmFzaEZpZWxkKCk7XG5cblx0XHQvLyBDbG9zZSBtb2RhbFxuXHRcdHRoaXMuY2xvc2VNb2RhbCgpO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGZpZWxkTGFiZWwgPSB0aGlzLnByb3BzLm1vZGFsLm1vZGFsUHJvcHMuYW5zd2VyLnRpdGxlO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1ib3gtaGVhZGVyIHN1aS1mbGF0dGVuIHN1aS1jb250ZW50LWNlbnRlciBzdWktc3BhY2luZy10b3AtLTYwXCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uXG5cdFx0XHRcdFx0XHRpY29uPVwiY2xvc2VcIlxuXHRcdFx0XHRcdFx0aWNvblNpemU9XCJtZFwiXG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0Nsb3NlIHRoaXMgZGlhbG9nIHdpbmRvdycgKSB9XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktYnV0dG9uLWZsb2F0LS1yaWdodFwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgdGhpcy5jbG9zZU1vZGFsIH1cblx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0PGgzXG5cdFx0XHRcdFx0XHRpZD1cImRpYWxvZ1RpdGxlXCJcblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1ib3gtdGl0bGUgc3VpLWxnXCJcblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0RlbGV0ZSBBbnN3ZXInICkgfVxuXHRcdFx0XHRcdDwvaDM+XG5cblx0XHRcdFx0XHQ8cCBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHQnRGVsZXRpbmcgdGhpcyBhbnN3ZXIgd2lsbCByZW1vdmUgaXRzIHZhbHVlIGZyb20gdGhlIGV4aXN0aW5nIHN1Ym1pc3Npb25zIGFzIHdlbGwuJ1xuXHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0PC9wPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWJveC1mb290ZXIgc3VpLWZsYXR0ZW4gc3VpLWNvbnRlbnQtY2VudGVyXCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxCdXR0b25cblx0XHRcdFx0XHRcdGRlc2lnbj1cImdob3N0XCJcblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cImZvcm1pbmF0b3ItZGlzY2FyZC1maWVsZC1zZXR0aW5nc1wiXG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0NhbmNlbCcgKSB9XG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgdGhpcy5jbG9zZU1vZGFsIH1cblx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0PEJ1dHRvblxuXHRcdFx0XHRcdFx0Y29sb3I9XCJyZWRcIlxuXHRcdFx0XHRcdFx0ZGVzaWduPVwiZ2hvc3RcIlxuXHRcdFx0XHRcdFx0aWNvbj1cInRyYXNoXCJcblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRGVsZXRlJyApIH1cblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLnRyYXNoRmllbGQgfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL21vZGFscy9kZWxldGUuanMiLCJpbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnO1xuXG5pbXBvcnQgKiBhcyBzZXR0aW5nc0FjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucy9zZXR0aW5ncyc7XG5pbXBvcnQgKiBhcyBtb2RhbEFjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucy9tb2RhbCc7XG5pbXBvcnQgTWV0YSBmcm9tICcuLi9jb21wb25lbnRzL21ldGEnO1xuXG5mdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHMoIHN0YXRlICkge1xuXHRyZXR1cm4ge1xuXHRcdGlkOiBzdGF0ZS5zZXR0aW5ncy5mb3JtX2lkLFxuXHRcdHN0YXR1czogc3RhdGUuc2V0dGluZ3MuZm9ybV9zdGF0dXMsXG5cdFx0c3RhdGU6IHN0YXRlLFxuXHRcdHRpdGxlOiBzdGF0ZS5zZXR0aW5ncy5mb3JtTmFtZSB8fCAnJyxcblx0XHRjaGFuZ2VkOiB3aW5kb3cuZm9ybWluYXRvckNoYW5nZXMsXG5cdH07XG59XG5cbmZ1bmN0aW9uIG1hcERpc3BhdGNoVG9Qcm9wcyggZGlzcGF0Y2ggKSB7XG5cdHJldHVybiB7XG5cdFx0YWN0aW9uczoge1xuXHRcdFx0c2V0dGluZ3NBY3Rpb25zOiBiaW5kQWN0aW9uQ3JlYXRvcnMoIHNldHRpbmdzQWN0aW9ucywgZGlzcGF0Y2ggKSxcblx0XHRcdG1vZGFsQWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKCBtb2RhbEFjdGlvbnMsIGRpc3BhdGNoICksXG5cdFx0fSxcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChcblx0bWFwU3RhdGVUb1Byb3BzLFxuXHRtYXBEaXNwYXRjaFRvUHJvcHNcbikoIE1ldGEgKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbnRhaW5lcnMvbWV0YS5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHFzIGZyb20gJ3FzJztcblxuaW1wb3J0IE5vdGlmaWNhdGlvbiBmcm9tICcuLi8uLi9ub3RpZmljYXRpb25zJztcblxuaW1wb3J0IFN0YXR1cyBmcm9tICcuL21ldGEvc3RhdHVzJztcbmltcG9ydCBCdXR0b25zIGZyb20gJy4vbWV0YS9idXR0b25zJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWV0YSBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblxuXHRcdHRoaXMuc3RhdGUgPSB7XG5cdFx0XHRwdWJsaXNoTG9hZGluZzogZmFsc2UsXG5cdFx0XHRkcmFmdExvYWRpbmc6IGZhbHNlLFxuXHRcdH07XG5cblx0XHR0aGlzLnB1Ymxpc2ggPSB0aGlzLnB1Ymxpc2guYmluZCggdGhpcyApO1xuXHRcdHRoaXMuZHJhZnQgPSB0aGlzLmRyYWZ0LmJpbmQoIHRoaXMgKTtcblx0fVxuXG5cdHB1Ymxpc2goKSB7XG5cdFx0Y29uc3QgeyBzdGF0ZSB9ID0gdGhpcy5wcm9wcztcblx0XHRjb25zdCB7IGZvcm1faWQsIGZvcm1OYW1lIH0gPSBzdGF0ZS5zZXR0aW5ncztcblxuXHRcdGNvbnN0IGZvcm1OYW1lVmFsdWUgPSAhIF8uaXNVbmRlZmluZWQoIGZvcm1OYW1lICkgPyBmb3JtTmFtZSA6ICcnO1xuXHRcdGNvbnN0IGZvcm1JZCA9ICEgXy5pc1VuZGVmaW5lZCggZm9ybV9pZCApID8gZm9ybV9pZCA6IC0xO1xuXG5cdFx0dGhpcy5zZXRTdGF0ZSgge1xuXHRcdFx0cHVibGlzaExvYWRpbmc6IHRydWUsXG5cdFx0fSApO1xuXG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdGFjdGlvbjogJ2Zvcm1pbmF0b3Jfc2F2ZV9wb2xsJyxcblx0XHRcdF93cG5vbmNlOiBmb3JtaW5hdG9yRGF0YS5mb3JtTm9uY2UsXG5cdFx0XHRmb3JtTmFtZTogZm9ybU5hbWVWYWx1ZSxcblx0XHRcdGZvcm1faWQ6IGZvcm1JZCxcblx0XHRcdHN0YXR1czogJ3B1Ymxpc2gnLFxuXHRcdFx0dmVyc2lvbjogZm9ybWluYXRvckRhdGEudmVyc2lvbixcblx0XHRcdGRhdGE6IEpTT04uc3RyaW5naWZ5KCBzdGF0ZSApLFxuXHRcdH07XG5cblx0XHQvLyBEZWxheSBhamF4IGEgYml0IHRvIGltaXRhdGUgc2F2aW5nXG5cdFx0c2V0VGltZW91dCggKCkgPT4ge1xuXHRcdFx0dGhpcy5zYXZlKCBkYXRhLCAncHVibGlzaCcgKTtcblx0XHR9LCAxNTAwICk7XG5cdH1cblxuXHRkcmFmdCgpIHtcblx0XHRjb25zdCB7IHN0YXRlIH0gPSB0aGlzLnByb3BzO1xuXHRcdGNvbnN0IHsgZm9ybV9pZCwgZm9ybU5hbWUgfSA9IHN0YXRlLnNldHRpbmdzO1xuXG5cdFx0Y29uc3QgZm9ybU5hbWVWYWx1ZSA9ICEgXy5pc1VuZGVmaW5lZCggZm9ybU5hbWUgKSA/IGZvcm1OYW1lIDogJyc7XG5cdFx0Y29uc3QgZm9ybUlkID0gISBfLmlzVW5kZWZpbmVkKCBmb3JtX2lkICkgPyBmb3JtX2lkIDogLTE7XG5cblx0XHR0aGlzLnNldFN0YXRlKCB7XG5cdFx0XHRkcmFmdExvYWRpbmc6IHRydWUsXG5cdFx0fSApO1xuXG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdGFjdGlvbjogJ2Zvcm1pbmF0b3Jfc2F2ZV9wb2xsJyxcblx0XHRcdF93cG5vbmNlOiBmb3JtaW5hdG9yRGF0YS5mb3JtTm9uY2UsXG5cdFx0XHRmb3JtTmFtZTogZm9ybU5hbWVWYWx1ZSxcblx0XHRcdGZvcm1faWQ6IGZvcm1JZCxcblx0XHRcdHN0YXR1czogJ2RyYWZ0Jyxcblx0XHRcdHZlcnNpb246IGZvcm1pbmF0b3JEYXRhLnZlcnNpb24sXG5cdFx0XHRkYXRhOiBKU09OLnN0cmluZ2lmeSggc3RhdGUgKSxcblx0XHR9O1xuXG5cdFx0Ly8gRGVsYXkgYWpheCBhIGJpdCB0byBpbWl0YXRlIHNhdmluZ1xuXHRcdHNldFRpbWVvdXQoICgpID0+IHtcblx0XHRcdHRoaXMuc2F2ZSggZGF0YSwgJ2RyYWZ0JyApO1xuXHRcdH0sIDE1MDAgKTtcblx0fVxuXG5cdGlzVmFsaWQoKSB7XG5cdFx0Y29uc3QgYW5zd2VycyA9IHRoaXMucHJvcHMuc3RhdGUuYW5zd2VycztcblxuXHRcdGlmICggYW5zd2Vycy5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaGFzRW1wdHkgPSBfLnNvbWUoIGFuc3dlcnMsIGZ1bmN0aW9uKCBhbnN3ZXIgKSB7XG5cdFx0XHRyZXR1cm4gXy5pc0VtcHR5KCBhbnN3ZXIudGl0bGUgKTtcblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gISBoYXNFbXB0eTtcblx0fVxuXG5cdHNhdmUoIG9iamVjdCwgbmV3U3RhdHVzICkge1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHRcdGNvbnN0IHsgc3RhdHVzIH0gPSB0aGlzLnByb3BzO1xuXHRcdGNvbnN0IGlzUHVibGlzaCA9ICggc3RhdHVzID09PSAnZHJhZnQnICYmIG5ld1N0YXR1cyA9PT0gJ3B1Ymxpc2gnICkgfHwgKCBfLmlzVW5kZWZpbmVkKCBzdGF0dXMgKSAmJiBuZXdTdGF0dXMgPT09ICdwdWJsaXNoJyApO1xuXHRcdGNvbnN0IHsgdm90ZV9saW1pdF9pbnB1dCB9ID0gdGhpcy5wcm9wcy5zdGF0ZS5zZXR0aW5ncztcblxuXHRcdGlmICggISB0aGlzLmlzVmFsaWQoKSApIHtcblx0XHRcdGNvbnN0IGN1c3RvbSA9IG5ldyBOb3RpZmljYXRpb24oIHtcblx0XHRcdFx0dHlwZTogJ2Vycm9yJyxcblx0XHRcdFx0dGV4dDogdHJhbnNsYXRlKCAnUG9sbCBhbnN3ZXJzIGNhbiBub3QgYmUgZW1wdHkuJyApLFxuXHRcdFx0XHR0aW1lOiA0MDAwLFxuXHRcdFx0fSApO1xuXG5cdFx0XHRjdXN0b20ub3BlbigpO1xuXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoIGlzUHVibGlzaCApO1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICggISBfLmlzVW5kZWZpbmVkKCB2b3RlX2xpbWl0X2lucHV0ICkgJiYgdm90ZV9saW1pdF9pbnB1dCA8IDAgKSB7XG5cdFx0XHRjb25zdCBjdXN0b20gPSBuZXcgTm90aWZpY2F0aW9uKCB7XG5cdFx0XHRcdHR5cGU6ICdlcnJvcicsXG5cdFx0XHRcdHRleHQ6IHRyYW5zbGF0ZSggJ1BsZWFzZSBlbnRlciB2YWxpZCB2b3RpbmcgbGltaXQuJyApLFxuXHRcdFx0XHR0aW1lOiA0MDAwLFxuXHRcdFx0fSApO1xuXG5cdFx0XHRjdXN0b20ub3BlbigpO1xuXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoIGlzUHVibGlzaCApO1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0YXhpb3MucG9zdCggZm9ybWluYXRvckRhdGEuYWpheFVybCxcblx0XHRcdHFzLnN0cmluZ2lmeSggb2JqZWN0IClcblx0XHQpXG5cdFx0XHQudGhlbiggKCBkYXRhICkgPT4ge1xuXHRcdFx0XHRpZiAoIGRhdGEuZGF0YS5zdWNjZXNzICkge1xuXHRcdFx0XHRcdC8vIFVwZGF0ZSBmb3JtIElEXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QuZm9ybV9pZCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnByb3BzLmFjdGlvbnMuc2V0dGluZ3NBY3Rpb25zLnVwZGF0ZVNldHRpbmcoICdmb3JtX2lkJywgZGF0YS5kYXRhLmRhdGEgKTtcblx0XHRcdFx0XHRcdC8vIHVwZGF0ZSBmb3JtX2lkIG9uIHdpbmRvdyBmb3JtaW5hdG9yRGF0YSwgZm9yIGZ1dHVyZSByZWZlcmVuY2Vcblx0XHRcdFx0XHRcdGZvcm1pbmF0b3JEYXRhLmN1cnJlbnRGb3JtLnNldHRpbmdzLmZvcm1faWQgPSBkYXRhLmRhdGEuZGF0YTtcblxuXHRcdFx0XHRcdFx0d2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKCB7fSwgXCJFZGl0IFBvbGxcIiwgZm9ybWluYXRvckRhdGEucG9sbEVkaXRVcmwgKyAnJmlkPScgKyBkYXRhLmRhdGEuZGF0YSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFVwZGF0ZSBmb3JtIHN0YXR1c1xuXHRcdFx0XHRcdHRoaXMucHJvcHMuYWN0aW9ucy5zZXR0aW5nc0FjdGlvbnMuc2F2ZUJ1aWxkZXIoICdmb3JtX3N0YXR1cycsIG5ld1N0YXR1cyApO1xuXG5cdFx0XHRcdFx0Ly8gV2UgdXNlIGBmYWxzZWAgaW50ZW50aW9uYWxseSBjdXogaWYgaXNQdWJsaXNoIGlzIGB0cnVlYCAtIGEgbmV3IHBvcHVwIHdpbGwgY2xvc2UgdGhlIHByZXZpb3VzIG9uZSBhdXRvbWF0aWNhbGx5LlxuXHRcdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCggZmFsc2UgKTtcblxuXHRcdFx0XHRcdGlmICggaXNQdWJsaXNoICkge1xuXHRcdFx0XHRcdFx0XHQvLyBDbG9zZSBtZXRob2Rcblx0XHRcdFx0XHRcdFx0Y29uc3QgY2xvc2UgPSBvcGVuID0+IHtcblx0XHRcdFx0XHRcdFx0XHRzZWxmLnByb3BzLmFjdGlvbnMubW9kYWxBY3Rpb25zLnNob3dNb2RhbChcblx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3BlbjogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0J3Nob3J0Y29kZSdcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdHNlbGYucHJvcHMuYWN0aW9ucy5tb2RhbEFjdGlvbnMuc2hvd01vZGFsKFxuXHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdG9wZW46IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9zZU1vZGFsOiBjbG9zZSxcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdCdzaG9ydGNvZGUnXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCggaXNQdWJsaXNoICk7XG5cblx0XHRcdFx0XHRjb25zdCBjdXN0b20gPSBuZXcgTm90aWZpY2F0aW9uKCB7XG5cdFx0XHRcdFx0XHR0eXBlOiAnZXJyb3InLFxuXHRcdFx0XHRcdFx0dGV4dDogdHJhbnNsYXRlKCAnU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2hpbGUgc2F2aW5nIHlvdXIgZm9ybS4gUGxlYXNlIHRyeSBhZ2Fpbi4nICksXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0Y3VzdG9tLm9wZW4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApXG5cdFx0XHQuY2F0Y2goICggZXJyICkgPT4ge1xuXHRcdFx0XHRjb25zdCBjdXN0b20gPSBuZXcgTm90aWZpY2F0aW9uKCB7XG5cdFx0XHRcdFx0dHlwZTogJ2Vycm9yJyxcblx0XHRcdFx0XHR0ZXh0OiB0cmFuc2xhdGUoICdTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBzYXZpbmcgeW91ciBmb3JtLiBQbGVhc2UgdHJ5IGFnYWluLicgKSxcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdGN1c3RvbS5vcGVuKCk7XG5cblx0XHRcdFx0Y29uc29sZS5sb2coIGVyciApO1xuXG5cdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCggaXNQdWJsaXNoICk7XG5cdFx0XHR9ICk7XG5cdH1cblxuXHRjbG9zZVBvcHVwKCBpc1B1Ymxpc2ggKSB7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIGlzUHVibGlzaCApIHtcblx0XHRcdHNlbGYucHJvcHMuYWN0aW9ucy5tb2RhbEFjdGlvbnMuc2hvd01vZGFsKFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0b3BlbjogZmFsc2UsXG5cdFx0XHRcdFx0Y2xvc2VNb2RhbDogdGhpcy5jbG9zZU1vZGFsLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHQncHVibGlzaCdcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRTdGF0ZSgge1xuXHRcdFx0cHVibGlzaExvYWRpbmc6IGZhbHNlLFxuXHRcdFx0ZHJhZnRMb2FkaW5nOiBmYWxzZSxcblx0XHR9ICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zdGF0dXNcIj5cblx0XHRcdFx0PFN0YXR1c1xuXHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0c3RhdGU9eyB0aGlzLnN0YXRlIH1cblx0XHRcdFx0Lz5cblx0XHRcdFx0PEJ1dHRvbnNcblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdHB1Ymxpc2g9eyB0aGlzLnB1Ymxpc2ggfVxuXHRcdFx0XHRcdGRyYWZ0PXsgdGhpcy5kcmFmdCB9XG5cdFx0XHRcdFx0c3RhdGU9eyB0aGlzLnN0YXRlIH1cblx0XHRcdFx0Lz5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbXBvbmVudHMvbWV0YS5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFN0YXR1cyggcHJvcHMgKSB7XG5cdGNvbnN0IHsgc3RhdHVzIH0gPSBwcm9wcztcblxuXHRjb25zdCBjbGFzc1R5cGUgPSBzdGF0dXMgPT09ICdwdWJsaXNoJyA/ICdzdWktdGFnLXB1Ymxpc2hlZCcgOiAnc3VpLXRhZy1kcmFmdCc7XG5cblx0Y29uc3QgaXNMb2FkaW5nID0gcHJvcHMuc3RhdGUuZHJhZnRMb2FkaW5nIHx8IHByb3BzLnN0YXRlLnB1Ymxpc2hMb2FkaW5nID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdHJldHVybiAoXG5cdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktc3RhdHVzXCI+XG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1zdGF0dXMtbW9kdWxlXCI+XG5cdFx0XHRcdHsgdHJhbnNsYXRlKCAnU3RhdHVzJyApIH1cblx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPXsgYHN1aS10YWcgJHsgY2xhc3NUeXBlIH1gIH0+XG5cdFx0XHRcdFx0eyggKCkgPT4ge1xuXHRcdFx0XHRcdFx0c3dpdGNoICggc3RhdHVzICkge1xuXHRcdFx0XHRcdFx0XHRjYXNlICdwdWJsaXNoJzpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnUHVibGlzaGVkJyApO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cmFuc2xhdGUoICdEcmFmdCcgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICkoKX1cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0PC9kaXY+XG5cblx0XHRcdHsgaXNMb2FkaW5nICYmXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLXN0YXR1cy1jaGFuZ2VzXCI+XG5cdFx0XHRcdFx0PGkgY2xhc3NOYW1lPVwic3VpLWljb24tbG9hZGVyIHN1aS1sb2FkaW5nXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuXHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnU2F2aW5nLi4uJyApIH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHR9XG5cblx0XHRcdHsgISBpc0xvYWRpbmcgJiYgcHJvcHMuY2hhbmdlZC5zZXR0aW5ncyAmJlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1zdGF0dXMtY2hhbmdlc1wiPlxuXHRcdFx0XHRcdDxpIGNsYXNzTmFtZT1cInN1aS1pY29uLXVwZGF0ZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cblx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1Vuc2F2ZWQgY2hhbmdlcycgKSB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0fVxuXG5cdFx0XHR7ICEgaXNMb2FkaW5nICYmICEgcHJvcHMuY2hhbmdlZC5zZXR0aW5ncyAmJiBwcm9wcy5jaGFuZ2VkLnNhdmVkICYmXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLXN0YXR1cy1jaGFuZ2VzXCI+XG5cdFx0XHRcdFx0PGkgY2xhc3NOYW1lPVwic3VpLWljb24tY2hlY2stdGlja1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cblx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1NhdmVkJyApIH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHR9XG5cdFx0PC9kaXY+XG5cdCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL21ldGEvc3RhdHVzLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgRnJhZ21lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5pbXBvcnQgUHJldmlldyBmcm9tICcuLi9uYXZpZ2F0aW9uL3ByZXZpZXcnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b25zIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy5wdWJsaXNoID0gdGhpcy5wdWJsaXNoLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLmRyYWZ0ID0gdGhpcy5kcmFmdC5iaW5kKCB0aGlzICk7XG5cdH1cblxuXHRjbG9zZU1vZGFsKCkge1xuXHRcdHRoaXMucHJvcHMuYWN0aW9ucy5tb2RhbEFjdGlvbnMuc2hvd01vZGFsKFxuXHRcdFx0e1xuXHRcdFx0XHRvcGVuOiBmYWxzZSxcblx0XHRcdH0sXG5cdFx0XHQncHVibGlzaCdcblx0XHQpO1xuXHR9XG5cblx0cHVibGlzaCgpIHtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHRjb25zdCB7IHN0YXR1cywgdGl0bGUgfSA9IHRoaXMucHJvcHM7XG5cblx0XHRpZiAoIF8uaXNFbXB0eSggdGl0bGUudHJpbSgpICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCBwYXJlbnQgbWV0aG9kIGZvciBwdWJsaXNoXG5cdFx0dGhpcy5wcm9wcy5wdWJsaXNoKCk7XG5cblx0XHRpZiAoIHN0YXR1cyA9PT0gJ2RyYWZ0JyB8fCBfLmlzRW1wdHkoIHN0YXR1cyApICkge1xuXHRcdFx0dGhpcy5wcm9wcy5hY3Rpb25zLm1vZGFsQWN0aW9ucy5zaG93TW9kYWwoXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRvcGVuOiB0cnVlLFxuXHRcdFx0XHRcdGNsb3NlTW9kYWw6IHRoaXMuY2xvc2VNb2RhbCxcblx0XHRcdFx0fSxcblx0XHRcdFx0J3B1Ymxpc2gnXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdGRyYWZ0KCkge1xuXHRcdGNvbnN0IHsgdGl0bGUgfSA9IHRoaXMucHJvcHM7XG5cblx0XHRpZiAoIF8uaXNFbXB0eSggdGl0bGUudHJpbSgpICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCBwYXJlbnQgbWV0aG9kIGZvciBkcmFmdFxuXHRcdHRoaXMucHJvcHMuZHJhZnQoKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCB7IHN0YXR1cyB9ID0gdGhpcy5wcm9wcztcblx0XHRjb25zdCB7IGRyYWZ0TG9hZGluZywgcHVibGlzaExvYWRpbmcgfSA9IHRoaXMucHJvcHMuc3RhdGU7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYWN0aW9uc1wiPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0aWQ9XCJmb3JtaW5hdG9yLW1vZHVsZS1zYXZlXCJcblx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktYnV0dG9uIHN1aS1idXR0b24tZ2hvc3RcIlxuXHRcdFx0XHRcdHN0eWxlPXsgeyBib3JkZXJDb2xvcjogJ3RyYW5zcGFyZW50JyB9IH1cblx0XHRcdFx0XHRkaXNhYmxlZD17ICEhIGRyYWZ0TG9hZGluZyB8fCBwdWJsaXNoTG9hZGluZyB9XG5cdFx0XHRcdFx0b25DbGljaz17IHRoaXMuZHJhZnQgfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0eyAncHVibGlzaCcgPT09IHN0YXR1cyAmJlxuXHRcdFx0XHRcdFx0PEZyYWdtZW50PlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktaWNvbi11bnB1Ymxpc2hcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG5cdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnVW5wdWJsaXNoJyApIH1cblx0XHRcdFx0XHRcdDwvRnJhZ21lbnQ+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHsgJ3B1Ymxpc2gnICE9PSBzdGF0dXMgJiZcblx0XHRcdFx0XHRcdDxGcmFnbWVudD5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWljb24tc2F2ZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdTYXZlIERyYWZ0JyApIH1cblx0XHRcdFx0XHRcdDwvRnJhZ21lbnQ+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PFByZXZpZXdcblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdGRpc2FibGVkPXsgISEgKCBkcmFmdExvYWRpbmcgfHwgcHVibGlzaExvYWRpbmcgKSB9XG5cdFx0XHRcdC8+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRpZD1cImZvcm1pbmF0b3ItbW9kdWxlLXB1Ymxpc2hcIlxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1idXR0b24gc3VpLWJ1dHRvbi1ibHVlXCJcblx0XHRcdFx0XHRkaXNhYmxlZD17ICEhICggZHJhZnRMb2FkaW5nIHx8IHB1Ymxpc2hMb2FkaW5nICkgfVxuXHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLnB1Ymxpc2ggfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWxvYWRpbmctdGV4dFwiPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWljb24td2ViLWdsb2JlLXdvcmxkXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwiYnV0dG9uLXRleHRcIj5cblx0XHRcdFx0XHRcdFx0eyggKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAoIHN0YXR1cyApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3B1Ymxpc2gnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnVXBkYXRlJyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ1B1Ymxpc2gnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICkoKX1cblx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWljb24tbG9hZGVyIHN1aS1sb2FkaW5nXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbXBvbmVudHMvbWV0YS9idXR0b25zLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJldmlldyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblxuXHRcdHRoaXMuY2xvc2VNb2RhbCA9IHRoaXMuY2xvc2VNb2RhbC5iaW5kKCB0aGlzICk7XG5cdFx0dGhpcy5vcGVuTW9kYWwgPSB0aGlzLm9wZW5Nb2RhbC5iaW5kKCB0aGlzICk7XG5cdH1cblxuXHRjbG9zZU1vZGFsKCBldmVudCApIHtcblx0XHR0aGlzLnByb3BzLmFjdGlvbnMubW9kYWxBY3Rpb25zLnNob3dNb2RhbChcblx0XHRcdHtcblx0XHRcdFx0b3BlbjogZmFsc2UsXG5cdFx0XHRcdHRpdGxlOiB0cmFuc2xhdGUoICdQcmV2aWV3JyApLFxuXHRcdFx0fSxcblx0XHRcdCdwcmV2aWV3J1xuXHRcdCk7XG5cblx0XHQvLyBSZW1vdmUgcHJldmlldyBjdXN0b20gc3R5bGVzXG5cdFx0alF1ZXJ5KCAnI2Zvcm1pbmF0b3ItbW9kdWxlLXN0eWxlcy0nICsgdGhpcy5wcm9wcy5pZCApLnJlbW92ZSgpO1xuXHR9XG5cblx0b3Blbk1vZGFsKCBldmVudCApIHtcblx0XHR0aGlzLnByb3BzLmFjdGlvbnMubW9kYWxBY3Rpb25zLnNob3dNb2RhbChcblx0XHRcdHtcblx0XHRcdFx0b3BlbjogdHJ1ZSxcblx0XHRcdFx0dGl0bGU6ICdQcmV2aWV3Jyxcblx0XHRcdFx0Y2xvc2VNb2RhbDogdGhpcy5jbG9zZU1vZGFsLFxuXHRcdFx0fSxcblx0XHRcdCdwcmV2aWV3J1xuXHRcdCk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0aWQ9XCJmb3JtaW5hdG9yLXByZXZpZXctYnV0dG9uXCJcblx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWJ1dHRvbiBzdWktc2lkZW5hdi1oaWRlLW1kXCJcblx0XHRcdFx0YWNjZXNzS2V5PVwicFwiXG5cdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLm9wZW5Nb2RhbCB9XG5cdFx0XHRcdGRpc2FibGVkPXsgdGhpcy5wcm9wcy5kaXNhYmxlZCB9XG5cdFx0XHQ+XG5cdFx0XHRcdDxpIGNsYXNzTmFtZT1cInN1aS1pY29uLWV5ZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+IHt0cmFuc2xhdGUoICdQcmV2aWV3JyApfVxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3ByZXZpZXcuanMiLCJpbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnO1xuXG5pbXBvcnQgKiBhcyBtb2RhbEFjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucy9tb2RhbCc7XG5pbXBvcnQgKiBhcyBuYXZpZ2F0aW9uQWN0aW9ucyBmcm9tICcuLi9hY3Rpb25zL25hdmlnYXRpb24nO1xuaW1wb3J0IE5hdmlnYXRpb24gZnJvbSAnLi4vY29tcG9uZW50cy9uYXZpZ2F0aW9uJztcblxuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzKCBzdGF0ZSApIHtcblx0cmV0dXJuIHtcblx0XHRpZDogc3RhdGUuc2V0dGluZ3MuZm9ybV9pZCxcblx0XHR0aXRsZTogc3RhdGUuc2V0dGluZ3MuZm9ybU5hbWUgfHwgJycsXG5cdH07XG59XG5cbmZ1bmN0aW9uIG1hcERpc3BhdGNoVG9Qcm9wcyggZGlzcGF0Y2ggKSB7XG5cdHJldHVybiB7XG5cdFx0YWN0aW9uczoge1xuXHRcdFx0bmF2aWdhdGlvbkFjdGlvbnM6IGJpbmRBY3Rpb25DcmVhdG9ycyggbmF2aWdhdGlvbkFjdGlvbnMsIGRpc3BhdGNoICksXG5cdFx0XHRtb2RhbEFjdGlvbnM6IGJpbmRBY3Rpb25DcmVhdG9ycyggbW9kYWxBY3Rpb25zLCBkaXNwYXRjaCApLFxuXHRcdH0sXG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3QoXG5cdG1hcFN0YXRlVG9Qcm9wcyxcblx0bWFwRGlzcGF0Y2hUb1Byb3BzXG4pKCBOYXZpZ2F0aW9uICk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb250YWluZXJzL25hdmlnYXRpb24uanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IE1lbnUgZnJvbSAnLi9uYXZpZ2F0aW9uL21lbnUnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBOYXZpZ2F0aW9uKCBwcm9wcyApIHtcblx0cmV0dXJuIChcblx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1zaWRlbmF2IGZ1aS1zaWRlbmF2XCI+XG5cdFx0XHQ8TWVudSB7IC4uLnByb3BzIH0gLz5cblx0XHQ8L2Rpdj5cblx0KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbXBvbmVudHMvbmF2aWdhdGlvbi5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBOYXZMaW5rIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBNb2JpbGVTZWxlY3QgZnJvbSAnLi4vbmF2aWdhdGlvbi9tb2JpbGUtc2VsZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVudSBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBnb1RvU2VjdGlvbiA9IG1vZHVsZSA9PiB7XG5cdFx0XHR0aGlzLnByb3BzLmhpc3RvcnkucHVzaCggJy8nICsgbW9kdWxlICk7XG5cdFx0fTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cblx0XHRcdFx0PHVsIGNsYXNzTmFtZT17XG5cdFx0XHRcdFx0J3N1aS12ZXJ0aWNhbC10YWJzICcgK1xuXHRcdFx0XHRcdCdzdWktc2lkZW5hdi1zdGlja3kgJyArXG5cdFx0XHRcdFx0J3N1aS1zaWRlbmF2LWhpZGUtbWQgJyArXG5cdFx0XHRcdFx0J2Z1aS1zaWRlbmF2J1xuXHRcdFx0XHR9PlxuXG5cdFx0XHRcdFx0PGxpIGNsYXNzTmFtZT1cInN1aS12ZXJ0aWNhbC10YWJcIj5cblx0XHRcdFx0XHRcdDxOYXZMaW5rIHRvPVwiL2J1aWxkZXJcIiBhY3RpdmVDbGFzc05hbWU9XCJjdXJyZW50XCI+XG5cdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnRGV0YWlscycgKSB9XG5cdFx0XHRcdFx0XHQ8L05hdkxpbms+XG5cdFx0XHRcdFx0PC9saT5cblxuXHRcdFx0XHRcdDxsaSBjbGFzc05hbWU9XCJzdWktdmVydGljYWwtdGFiXCI+XG5cdFx0XHRcdFx0XHQ8TmF2TGluayB0bz1cIi9hcHBlYXJhbmNlXCIgYWN0aXZlQ2xhc3NOYW1lPVwiY3VycmVudFwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0FwcGVhcmFuY2UnICkgfVxuXHRcdFx0XHRcdFx0PC9OYXZMaW5rPlxuXHRcdFx0XHRcdDwvbGk+XG5cblx0XHRcdFx0XHQ8bGkgY2xhc3NOYW1lPVwic3VpLXZlcnRpY2FsLXRhYlwiPlxuXHRcdFx0XHRcdFx0PE5hdkxpbmsgdG89XCIvYmVoYXZpb3VyXCIgYWN0aXZlQ2xhc3NOYW1lPVwiY3VycmVudFwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0JlaGF2aW9yJyApIH1cblx0XHRcdFx0XHRcdDwvTmF2TGluaz5cblx0XHRcdFx0XHQ8L2xpPlxuXG5cdFx0XHRcdFx0PGxpIGNsYXNzTmFtZT1cInN1aS12ZXJ0aWNhbC10YWJcIj5cblx0XHRcdFx0XHRcdDxOYXZMaW5rIHRvPVwiL25vdGlmaWNhdGlvbnNcIiBhY3RpdmVDbGFzc05hbWU9XCJjdXJyZW50XCI+XG5cdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnTm90aWZpY2F0aW9ucycgKSB9XG5cdFx0XHRcdFx0XHQ8L05hdkxpbms+XG5cdFx0XHRcdFx0PC9saT5cblxuXHRcdFx0XHRcdDxsaSBjbGFzc05hbWU9XCJzdWktdmVydGljYWwtdGFiXCI+XG5cdFx0XHRcdFx0XHQ8TmF2TGluayB0bz1cIi9pbnRlZ3JhdGlvbnNcIiBhY3RpdmVDbGFzc05hbWU9XCJjdXJyZW50XCI+XG5cdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnSW50ZWdyYXRpb25zJyApIH1cblx0XHRcdFx0XHRcdDwvTmF2TGluaz5cblx0XHRcdFx0XHQ8L2xpPlxuXG5cdFx0XHRcdFx0PGxpIGNsYXNzTmFtZT1cInN1aS12ZXJ0aWNhbC10YWJcIj5cblx0XHRcdFx0XHRcdDxOYXZMaW5rIHRvPVwiL3NldHRpbmdzXCIgYWN0aXZlQ2xhc3NOYW1lPVwiY3VycmVudFwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1NldHRpbmdzJyApIH1cblx0XHRcdFx0XHRcdDwvTmF2TGluaz5cblx0XHRcdFx0XHQ8L2xpPlxuXG5cdFx0XHRcdDwvdWw+XG5cblx0XHRcdFx0PE1vYmlsZVNlbGVjdCB7IC4uLnRoaXMucHJvcHMgfT5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiXCI+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0RldGFpbHMnICkgfVxuXHRcdFx0XHRcdDwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJhcHBlYXJhbmNlXCI+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0FwcGVhcmFuY2UnICkgfVxuXHRcdFx0XHRcdDwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJiZWhhdmlvdXJcIj5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnQmVoYXZpb3InICkgfVxuXHRcdFx0XHRcdDwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJub3RpZmljYXRpb25zXCI+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0VtYWlsIE5vdGlmaWNhdGlvbnMnICkgfVxuXHRcdFx0XHRcdDwvb3B0aW9uPlxuXHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJpbnRlZ3JhdGlvbnNcIj5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnSW50ZWdyYXRpb25zJyApIH1cblx0XHRcdFx0XHQ8L29wdGlvbj5cblx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwic2V0dGluZ3NcIj5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnU2V0dGluZ3MnICkgfVxuXHRcdFx0XHRcdDwvb3B0aW9uPlxuXHRcdFx0XHQ8L01vYmlsZVNlbGVjdD5cblxuXHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL25hdmlnYXRpb24vbWVudS5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vYmlsZVNlbGVjdCBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblxuXHRcdHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlLmJpbmQoIHRoaXMgKTtcblx0fVxuXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdHRoaXMuJGVsID0galF1ZXJ5KCB0aGlzLmVsICk7XG5cdFx0U1VJLnNlbGVjdC5pbml0KCB0aGlzLiRlbCApO1xuXG5cdFx0dGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUuYmluZCggdGhpcyApO1xuXHRcdHRoaXMuJGVsLm9uKCAnY2hhbmdlJywgdGhpcy51cGRhdGVWYWx1ZSApO1xuXHR9XG5cblx0dXBkYXRlVmFsdWUoIGUgKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcblxuXHRcdHRoaXMucHJvcHMuaGlzdG9yeS5wdXNoKCAnLycgKyB2YWx1ZSApO1xuXHR9XG5cblx0Y29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0dGhpcy4kZWwub2ZmKCAnY2hhbmdlJywgdGhpcy51cGRhdGVWYWx1ZSApO1xuXHRcdHRoaXMuJGVsLnVuYmluZCgpLnJlbW92ZURhdGEoKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktZm9ybS1maWVsZCBzdWktc2lkZW5hdi1oaWRlLWxnXCI+XG5cdFx0XHRcdDxsYWJlbCBjbGFzc05hbWU9XCJzdWktbGFiZWxcIj57IHRyYW5zbGF0ZSggJ05hdmlnYXRlJyApIH08L2xhYmVsPlxuXHRcdFx0XHQ8c2VsZWN0XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLXNlbGVjdCBzdWktbW9iaWxlLW5hdlwiXG5cdFx0XHRcdFx0cmVmPXsgZWwgPT4gKCB0aGlzLmVsID0gZWwgKSB9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuY2hpbGRyZW4gfVxuXHRcdFx0XHQ8L3NlbGVjdD5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9tb2JpbGUtc2VsZWN0LmpzIiwiaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcblxuaW1wb3J0ICogYXMgc2V0dGluZ3NBY3Rpb25zIGZyb20gJy4uL2FjdGlvbnMvc2V0dGluZ3MnO1xuaW1wb3J0ICogYXMgbW9kYWxBY3Rpb25zIGZyb20gJy4uL2FjdGlvbnMvbW9kYWwnO1xuaW1wb3J0ICogYXMgYnVpbGRlckFjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucy9idWlsZGVyJztcbmltcG9ydCBCdWlsZGVyIGZyb20gJy4uL2NvbXBvbmVudHMvYnVpbGRlcic7XG5cbmZ1bmN0aW9uIG1hcFN0YXRlVG9Qcm9wcyggc3RhdGUgKSB7XG5cdHJldHVybiB7XG5cdFx0YW5zd2Vyczogc3RhdGUuYW5zd2Vycyxcblx0XHRzZXR0aW5nczogc3RhdGUuc2V0dGluZ3MsXG5cdFx0c3VibWl0RGF0YTogc3RhdGUuc2V0dGluZ3Muc3VibWl0RGF0YSB8fCB7fSxcblx0XHRjaGFuZ2VkOiB3aW5kb3cuZm9ybWluYXRvckNoYW5nZXMsXG5cdH07XG59XG5cbmZ1bmN0aW9uIG1hcERpc3BhdGNoVG9Qcm9wcyggZGlzcGF0Y2ggKSB7XG5cdHJldHVybiB7XG5cdFx0YWN0aW9uczoge1xuXHRcdFx0c2V0dGluZ3NBY3Rpb25zOiBiaW5kQWN0aW9uQ3JlYXRvcnMoIHNldHRpbmdzQWN0aW9ucywgZGlzcGF0Y2ggKSxcblx0XHRcdGJ1aWxkZXJBY3Rpb25zOiBiaW5kQWN0aW9uQ3JlYXRvcnMoIGJ1aWxkZXJBY3Rpb25zLCBkaXNwYXRjaCApLFxuXHRcdFx0bW9kYWxBY3Rpb25zOiBiaW5kQWN0aW9uQ3JlYXRvcnMoIG1vZGFsQWN0aW9ucywgZGlzcGF0Y2ggKSxcblx0XHR9LFxuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KFxuXHRtYXBTdGF0ZVRvUHJvcHMsXG5cdG1hcERpc3BhdGNoVG9Qcm9wc1xuKSggQnVpbGRlciApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29udGFpbmVycy9idWlsZGVyLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IERldGFpbHMgZnJvbSAnLi9idWlsZGVyL2RldGFpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWlsZGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0alF1ZXJ5KCAnaHRtbCwgYm9keScgKS5hbmltYXRlKFxuXHRcdFx0e1xuXHRcdFx0XHRzY3JvbGxUb3A6IDAsXG5cdFx0XHR9LCAnZmFzdCdcblx0XHQpO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGdvVG9TZWN0aW9uID0gbW9kdWxlID0+IHtcblx0XHRcdHRoaXMucHJvcHMuaGlzdG9yeS5wdXNoKCAnLycgKyBtb2R1bGUgKTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgaWQ9XCJmb3JtaW5hdG9yLWZvcm0tZmllbGRzXCIgY2xhc3NOYW1lPVwic3VpLWJveFwiPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtaGVhZGVyXCI+XG5cdFx0XHRcdFx0PGgyIGNsYXNzTmFtZT1cInN1aS1ib3gtdGl0bGVcIj57IHRyYW5zbGF0ZSggJ0RldGFpbHMnICkgfTwvaDI+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtYm9keVwiPlxuXHRcdFx0XHRcdDxEZXRhaWxzIHsgLi4udGhpcy5wcm9wcyB9IC8+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtZm9vdGVyXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYWN0aW9ucy1yaWdodFwiPlxuXHRcdFx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktYnV0dG9uIHN1aS1idXR0b24taWNvbi1yaWdodFwiXG5cdFx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiBnb1RvU2VjdGlvbiggJ2FwcGVhcmFuY2UnICkgfVxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHR7dHJhbnNsYXRlKCAnQXBwZWFyYW5jZScgKX1cblx0XHRcdFx0XHRcdFx0PGkgY2xhc3NOYW1lPVwic3VpLWljb24tYXJyb3ctcmlnaHRcIiBhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuXHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9idWlsZGVyLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgSW5wdXQgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2lucHV0JztcbmltcG9ydCBVcGxvYWRzIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy91cGxvYWRzJztcbmltcG9ydCBDaGVja2JveCBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY2hlY2tib3gnO1xuaW1wb3J0IEFuc3dlcnMgZnJvbSAnLi9hbnN3ZXJzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGV0YWlscyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1yb3dcIj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMVwiPlxuXG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktc2V0dGluZ3MtbGFiZWxcIj57IHRyYW5zbGF0ZSggJ1F1ZXN0aW9uJyApIH08L3NwYW4+XG5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0XHQnU3RhcnQgYnkgYWRkaW5nIHRoZSBxdWVzdGlvbiB5b3Ugd2lsbCBiZSBhc2tpbmcgJyArXG5cdFx0XHRcdFx0XHRcdFx0J3BvbGwgdmlzaXRvcnMgdG8gdm90ZSBvbi4nXG5cdFx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXG5cdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3MtY29sLTJcIj5cblxuXHRcdFx0XHRcdFx0PElucHV0XG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnV2hhdCBpcyB5b3VyIG1haW4gcXVlc3Rpb24/JyApIH1cblx0XHRcdFx0XHRcdFx0dHlwZT1cInRleHRcIlxuXHRcdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj17IHRyYW5zbGF0ZSggJ0UuZy4gV2h5IGRpZCB0aGUgY2hpY2tlbiBjcm9zcyB0aGUgcm9hZD8nICkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cInBvbGwtcXVlc3Rpb25cIlxuXHRcdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdFx0PFVwbG9hZHNcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0dHlwZT1cImltYWdlXCJcblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdGZWF0dXJlIEltYWdlIChvcHRpb25hbCknICkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cInBvbGwtaW1hZ2VcIlxuXHRcdFx0XHRcdFx0XHRpbWFnZVNpemU9XCJsYXJnZVwiXG5cdFx0XHRcdFx0XHRcdGRlc2NyaXB0aW9uPXsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHRcdCdUaGlzIGltYWdlIHdpbGwgYXBwZWFyIHVuZGVyIHlvdXIgbWFpbiBxdWVzdGlvbiAnICtcblx0XHRcdFx0XHRcdFx0XHQnYW5kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBwb2xscyBiYXNlZCBvbiBhbiBpbWFnZS4nXG5cdFx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdFx0PElucHV0XG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRGVzY3JpcHRpb24gKG9wdGlvbmFsKScgKSB9XG5cdFx0XHRcdFx0XHRcdHR5cGU9XCJ0ZXh0XCJcblx0XHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9eyB0cmFuc2xhdGUoICdFbnRlciBhbiBvcHRpb25hbCBkZXNjcmlwdGlvbicgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwicG9sbC1kZXNjcmlwdGlvblwiXG5cdFx0XHRcdFx0XHRcdGRlc2NyaXB0aW9uPXsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHRcdCdUaGlzIHdpbGwgYXBwZWFyIGJlbG93IHRoZSBtYWluIHF1ZXN0aW9uIGFuZCAnICtcblx0XHRcdFx0XHRcdFx0XHQnY2FuIGJlIHVzZWQgdG8gZnVydGhlciBleHBsYWluIHRoZSBtYWluIHF1ZXN0aW9uLidcblx0XHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLXJvdyBzdWktZmx1c2hlZFwiXG5cdFx0XHRcdFx0c3R5bGU9eyB7IGJvcmRlckJvdHRvbTogJzAnIH0gfT5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMlwiPlxuXG5cdFx0XHRcdFx0XHQ8bGFiZWwgY2xhc3NOYW1lPVwic3VpLXNldHRpbmdzLWxhYmVsIHN1aS1kYXJrXCI+XG5cdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnQW5zd2VycycgKSB9XG5cdFx0XHRcdFx0XHQ8L2xhYmVsPlxuXG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj5cblx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdFx0J05vdyBhZGQgYW5zd2VycyB0byB5b3VyIHF1ZXN0aW9uIHRoYXQgeW91ciB1c2VycyB3aWxsIHVzZSAnICtcblx0XHRcdFx0XHRcdFx0XHQndG8gdm90ZSB3aXRoLiBBZGQgYXMgbWFueSBhcyB5b3UgbGlrZSwganVzdCBiZSBjYXJlZnVsIHRvICcgK1xuXHRcdFx0XHRcdFx0XHRcdCdtYWtlIHN1cmUgZWFjaCBvbmUgaXMgdW5pcXVlISdcblx0XHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0XHQ8L3NwYW4+XG5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3dpdGNoLWJveFwiPlxuXG5cdFx0XHRcdFx0XHRcdDxDaGVja2JveFxuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdFbmFibGUgSW1hZ2VzJyApIH1cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cImVuYWJsZV9pbWFnZXNcIlxuXHRcdFx0XHRcdFx0XHRcdGl0ZW1DbGFzcz1cInN1aS1jaGVja2JveC1zbSBcIlxuXHRcdFx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdFx0PEFuc3dlcnMgeyAuLi50aGlzLnByb3BzIH0gLz5cblxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1yb3dcIj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMVwiPlxuXG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktc2V0dGluZ3MtbGFiZWxcIj57IHRyYW5zbGF0ZSggJ0J1dHRvbicgKSB9PC9zcGFuPlxuXG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj5cblx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdFx0J0N1c3RvbWl6ZSB0aGUgYnV0dG9uIGxhYmVsIHVzZWQgZm9yICcgK1xuXHRcdFx0XHRcdFx0XHRcdCdzdWJtaXR0aW5nIHRoZSB1c2VycyBhbnN3ZXIuJ1xuXHRcdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0yXCI+XG5cdFx0XHRcdFx0XHQ8SW5wdXRcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCdXR0b24gVGV4dCcgKSB9XG5cdFx0XHRcdFx0XHRcdHR5cGU9XCJ0ZXh0XCJcblx0XHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9eyB0cmFuc2xhdGUoICdFLmcuIFZvdGUnICkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cInBvbGwtYnV0dG9uLWxhYmVsXCJcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9idWlsZGVyL2RldGFpbHMuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlLCBnZXRNYXhJRCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IEFuc3dlciBmcm9tICcuL2Fuc3dlci1yb3cnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbnN3ZXJzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy5hZGRBbnN3ZXIgPSB0aGlzLmFkZEFuc3dlci5iaW5kKCB0aGlzICk7XG5cdH1cblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblxuXHRcdHRoaXMuJGVsID0galF1ZXJ5KCB0aGlzLmVsICk7XG5cblx0XHR0aGlzLm1vdmVPcHRpb24gPSB0aGlzLm1vdmVPcHRpb24uYmluZCggdGhpcyApO1xuXG5cdFx0dGhpcy4kZWwuZmluZCggJy5mdWktYW5zd2VycycgKS5zb3J0YWJsZSgge1xuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGUsIHVpICkge1xuXHRcdFx0XHRjb25zdCB0byA9IHVpLml0ZW0uaW5kZXgoKTtcblx0XHRcdFx0c2VsZi4kZWwuZmluZCggJy5mdWktYW5zd2VycycgKS5zb3J0YWJsZSggJ2NhbmNlbCcgKTtcblx0XHRcdFx0Y29uc3QgZnJvbSA9IHVpLml0ZW0uaW5kZXgoKTtcblxuXHRcdFx0XHRzZWxmLm1vdmVPcHRpb24oIGZyb20sIHRvICk7XG5cdFx0XHR9LFxuXHRcdH0gKTtcblx0fVxuXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdHRoaXMuJGVsLnVuYmluZCgpLnJlbW92ZURhdGEoKTtcblx0fVxuXG5cblx0bW92ZU9wdGlvbiggZnJvbSwgdG8gKSB7XG5cdFx0Y29uc3QgbmV3U3RhdGUgPSB0aGlzLnByb3BzLmFuc3dlcnM7XG5cblx0XHRuZXdTdGF0ZS5zcGxpY2UoIHRvLCAwLCBuZXdTdGF0ZS5zcGxpY2UoIGZyb20sIDEgKVsgMCBdICk7XG5cblx0XHR0aGlzLnByb3BzLmFjdGlvbnMuYnVpbGRlckFjdGlvbnMudXBkYXRlQW5zd2VycyggbmV3U3RhdGUgKTtcblxuXHRcdHRoaXMuZm9yY2VVcGRhdGUoKTtcblx0fVxuXG5cdGFkZEFuc3dlcigpIHtcblx0XHRjb25zdCBhbnN3ZXJzID0gWyAuLi50aGlzLnByb3BzLmFuc3dlcnMgXTtcblxuXHRcdGNvbnN0IG5ld0Fuc3dlciA9IFtcblx0XHRcdHtcblx0XHRcdFx0ZWxlbWVudF9pZDogJ2Fuc3dlci0nICsgZ2V0TWF4SUQoICdhbnN3ZXInLCB0aGlzLnByb3BzLmFuc3dlcnMgKSxcblx0XHRcdH0sXG5cdFx0XTtcblxuXHRcdGNvbnN0IG5ld1N0YXRlID0gW1xuXHRcdFx0Li4uYW5zd2Vycyxcblx0XHRcdC4uLm5ld0Fuc3dlcixcblx0XHRdO1xuXG5cdFx0dGhpcy5wcm9wcy5hY3Rpb25zLmJ1aWxkZXJBY3Rpb25zLnVwZGF0ZUFuc3dlcnMoIG5ld1N0YXRlICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZnVpLW11bHRpLWFuc3dlcnNcIiByZWY9eyBlbCA9PiAoIHRoaXMuZWwgPSBlbCApIH0+XG5cdFx0XHRcdDx1bCBjbGFzc05hbWU9XCJmdWktYW5zd2Vyc1wiPlxuXHRcdFx0XHRcdHsgXy5tYXAoIHRoaXMucHJvcHMuYW5zd2VycywgKCBhbnN3ZXIsIGkgKSA9PiAoXG5cdFx0XHRcdFx0XHQ8QW5zd2VyIGtleT17IGFuc3dlci5lbGVtZW50X2lkIH0gYW5zd2VyPXsgYW5zd2VyIH0geyAuLi50aGlzLnByb3BzIH0gY291bnRlcj17IGkgfSAvPlxuXHRcdFx0XHRcdCkgKX1cblx0XHRcdFx0PC91bD5cblxuXHRcdFx0XHQ8YnV0dG9uIGNsYXNzTmFtZT1cInN1aS1idXR0b24gc3VpLWJ1dHRvbi1kYXNoZWRcIiBvbkNsaWNrPXsgdGhpcy5hZGRBbnN3ZXIgfT5cblx0XHRcdFx0XHQ8aSBjbGFzc05hbWU9XCJzdWktaWNvbi1wbHVzXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuXHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnQWRkIEFuc3dlcicgKSB9XG5cdFx0XHRcdDwvYnV0dG9uPlxuXG5cdFx0XHRcdHsgdGhpcy5wcm9wcy5hbnN3ZXJzLmxlbmd0aCA9PT0gMCAmJlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZnVpLWVtcHR5LW1lc3NhZ2VcIj5cblxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCI+eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdCdBIHBvbGwgd2l0aG91dCBhbnN3ZXJzIGlzbuKAmXQgZ29pbmcgdG8gYmUgdmVyeSB1c2VmdWzigKYgJyArXG5cdFx0XHRcdFx0XHRcdCdBZGQgeW91ciBhbnN3ZXJzIGFib3ZlISdcblx0XHRcdFx0XHRcdCkgfTwvc3Bhbj5cblxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHR9XG5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbXBvbmVudHMvYnVpbGRlci9hbnN3ZXJzLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IFVwbG9hZHMgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL3VwbG9hZHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbnN3ZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cblx0XHR0aGlzLnRyYXNoRmllbGQgXHQgID0gdGhpcy50cmFzaEZpZWxkLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLmRlbGV0ZUZpZWxkIFx0ICA9IHRoaXMuZGVsZXRlRmllbGQuYmluZCggdGhpcyApO1xuXHRcdHRoaXMuY2xvc2VEZWxldGVGaWVsZCA9IHRoaXMuY2xvc2VEZWxldGVGaWVsZC5iaW5kKCB0aGlzICk7XG5cdFx0dGhpcy51cGRhdGVJbWFnZSBcdCAgPSB0aGlzLnVwZGF0ZUltYWdlLmJpbmQoIHRoaXMgKTtcblx0fVxuXG5cdHVwZGF0ZVRpdGxlKCBlICkge1xuXHRcdGNvbnN0IGFuc3dlciA9IE9iamVjdC5hc3NpZ24oIHt9LCB0aGlzLnByb3BzLmFuc3dlciApO1xuXHRcdGFuc3dlci50aXRsZSA9IGUudGFyZ2V0LnZhbHVlO1xuXG5cdFx0dGhpcy5wcm9wcy5hY3Rpb25zLmJ1aWxkZXJBY3Rpb25zLnVwZGF0ZUFuc3dlciggYW5zd2VyICk7XG5cdH1cblxuXHR1cGRhdGVFeHRyYSggZSApIHtcblx0XHRjb25zdCBhbnN3ZXIgPSBPYmplY3QuYXNzaWduKCB7fSwgdGhpcy5wcm9wcy5hbnN3ZXIgKTtcblx0XHRhbnN3ZXIuZXh0cmEgPSBlLnRhcmdldC52YWx1ZTtcblxuXHRcdHRoaXMucHJvcHMuYWN0aW9ucy5idWlsZGVyQWN0aW9ucy51cGRhdGVBbnN3ZXIoIGFuc3dlciApO1xuXHR9XG5cblx0YWRkRXh0cmEoKSB7XG5cdFx0Y29uc3QgYW5zd2VyID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMucHJvcHMuYW5zd2VyICk7XG5cdFx0YW5zd2VyLnVzZV9leHRyYSA9IHRydWU7XG5cblx0XHR0aGlzLnByb3BzLmFjdGlvbnMuYnVpbGRlckFjdGlvbnMudXBkYXRlQW5zd2VyKCBhbnN3ZXIgKTtcblx0fVxuXG5cdHJlbW92ZUV4dHJhKCkge1xuXHRcdGNvbnN0IGFuc3dlciA9IE9iamVjdC5hc3NpZ24oIHt9LCB0aGlzLnByb3BzLmFuc3dlciApO1xuXHRcdGFuc3dlci51c2VfZXh0cmEgPSBmYWxzZTtcblx0XHRhbnN3ZXIuZXh0cmEgPSAnJztcblxuXHRcdHRoaXMucHJvcHMuYWN0aW9ucy5idWlsZGVyQWN0aW9ucy51cGRhdGVBbnN3ZXIoIGFuc3dlciApO1xuXHR9XG5cblx0Z2V0QW5zd2Vyc1dpdGhvdXRDdXJyZW50KCBhbnN3ZXJzICkge1xuXHRcdHJldHVybiBhbnN3ZXJzLmZpbHRlciggZmllbGQgPT4ge1xuXHRcdFx0cmV0dXJuIGZpZWxkLmVsZW1lbnRfaWQgIT09IHRoaXMucHJvcHMuYW5zd2VyLmVsZW1lbnRfaWQ7XG5cdFx0fSApO1xuXHR9XG5cblx0Y2xvc2VNZW51KCkge1xuXHRcdGpRdWVyeSggJy5zdWktZHJvcGRvd24nICkucmVtb3ZlQ2xhc3MoICdvcGVuJyApO1xuXHR9XG5cblx0ZGVsZXRlRmllbGQoKSB7XG5cdFx0Ly8gSGlkZSBmaWVsZCBzZXR0aW5ncyBtZW51XG5cdFx0dGhpcy5jbG9zZU1lbnUoKTtcblxuXHRcdHRoaXMucHJvcHMuYWN0aW9ucy5tb2RhbEFjdGlvbnMuc2hvd01vZGFsKFxuXHRcdFx0e1xuXHRcdFx0XHRvcGVuOiB0cnVlLFxuXHRcdFx0XHRhbnN3ZXI6IHRoaXMucHJvcHMuYW5zd2VyLFxuXHRcdFx0XHRjbG9zZU1vZGFsOiB0aGlzLmNsb3NlRGVsZXRlRmllbGQsXG5cdFx0XHRcdHRyYXNoRmllbGQ6IHRoaXMudHJhc2hGaWVsZCxcblx0XHRcdH0sXG5cdFx0XHQnZGVsZXRlJ1xuXHRcdCk7XG5cdH1cblxuXHRjbG9zZURlbGV0ZUZpZWxkKCkge1xuXHRcdHRoaXMucHJvcHMuYWN0aW9ucy5tb2RhbEFjdGlvbnMuc2hvd01vZGFsKFxuXHRcdFx0e1xuXHRcdFx0XHRvcGVuOiBmYWxzZSxcblx0XHRcdFx0YW5zd2VyOiB0aGlzLnByb3BzLmFuc3dlcixcblx0XHRcdFx0Y2xvc2VNb2RhbDogdGhpcy5jbG9zZURlbGV0ZUZpZWxkLFxuXHRcdFx0XHR0cmFzaEZpZWxkOiB0aGlzLnRyYXNoRmllbGQsXG5cdFx0XHR9LFxuXHRcdFx0J2RlbGV0ZSdcblx0XHQpO1xuXHR9XG5cblx0dHJhc2hGaWVsZCgpIHtcblx0XHRjb25zdCBhbnN3ZXJzID0gWyAuLi50aGlzLnByb3BzLmFuc3dlcnMgXTtcblxuXHRcdGNvbnN0IGFuc3dlcnNPYmogPSB0aGlzLmdldEFuc3dlcnNXaXRob3V0Q3VycmVudCggYW5zd2VycyApO1xuXG5cdFx0Ly8gSGlkZSBmaWVsZCBzZXR0aW5ncyBtZW51XG5cdFx0dGhpcy5jbG9zZU1lbnUoKTtcblxuXHRcdC8vIFVwZGF0ZSBzdGF0ZVxuXHRcdHRoaXMucHJvcHMuYWN0aW9ucy5idWlsZGVyQWN0aW9ucy51cGRhdGVBbnN3ZXJzKCBhbnN3ZXJzT2JqICk7XG5cdH1cblxuXHR1cGRhdGVJbWFnZSggcHJvcGVydHksIHZhbHVlICkge1xuXHRcdHRoaXMucHJvcHMuYW5zd2VyWyBwcm9wZXJ0eSBdID0gdmFsdWU7XG5cdFx0dGhpcy5wcm9wcy5hY3Rpb25zLmJ1aWxkZXJBY3Rpb25zLnVwZGF0ZUFuc3dlciggdGhpcy5wcm9wcy5hbnN3ZXIgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBoYXNUaXRsZSA9IHRoaXMucHJvcHMuYW5zd2VyLnRpdGxlID8gdHJ1ZSA6IGZhbHNlO1xuXHRcdGNvbnN0IHZhbGlkYXRpb25DbGFzcyA9ICEgaGFzVGl0bGUgPyAnZnVpLWVycm9yJyA6ICcnO1xuXHRcdGNvbnN0IGVuYWJsZV9pbWFnZXMgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3MuZW5hYmxlX2ltYWdlcyApID8gdGhpcy5wcm9wcy5zZXR0aW5ncy5lbmFibGVfaW1hZ2VzIDogZmFsc2U7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGxpIGRhdGEtaW5kZXg9eyB0aGlzLnByb3BzLmNvdW50ZXIgfSBjbGFzc05hbWU9eyBgYW5zd2VyLXJvdyAkeyB2YWxpZGF0aW9uQ2xhc3MgfWAgfT5cblx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwiZnVpLWFuc3dlci0tbW92ZVwiPlxuXHRcdFx0XHRcdDxpIGNsYXNzTmFtZT1cInN1aS1pY29uLWRyYWdcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwiZnVpLWFuc3dlci0tZmllbGRzXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktZm9ybS1maWVsZFwiPlxuXG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFuc3dlci10aXRsZVwiPlxuXHRcdFx0XHRcdFx0XHQ8aW5wdXQgY2xhc3NOYW1lPVwic3VpLWZvcm0tY29udHJvbFwiIGRlZmF1bHRWYWx1ZT17IHRoaXMucHJvcHMuYW5zd2VyLnRpdGxlIH0gb25DaGFuZ2U9eyB0aGlzLnVwZGF0ZVRpdGxlLmJpbmQoIHRoaXMgKSB9IG9uVG91Y2hFbmQ9eyAoZSkgPT4geyBlLnRhcmdldC5mb2N1cygpIH0gfSAvPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHRcdHsgZW5hYmxlX2ltYWdlcyAmJlxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhbnN3ZXItaW1hZ2VcIj5cblx0XHRcdFx0XHRcdFx0PFVwbG9hZHNcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdHNldHRpbmdzPXsgdGhpcy5wcm9wcy5hbnN3ZXIgfVxuXHRcdFx0XHRcdFx0XHRcdHR5cGU9XCJpbWFnZVwiXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRDbGFzcz1cInN1aS1hdXRvXCJcblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cImFuc3dlcl9pbWFnZVwiXG5cdFx0XHRcdFx0XHRcdFx0dXBkYXRlUHJvcGVydHk9eyB0aGlzLnVwZGF0ZUltYWdlLmJpbmQoIHRoaXMgKSB9XG5cdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5hbnN3ZXIudXNlX2V4dHJhID09PSB0cnVlICYmXG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1mb3JtLWZpZWxkXCI+XG5cdFx0XHRcdFx0XHRcdDxpbnB1dCBjbGFzc05hbWU9XCJzdWktZm9ybS1jb250cm9sXCIgcGxhY2Vob2xkZXI9eyB0cmFuc2xhdGUoICdFbnRlciBQbGFjZWhvbGRlcicgKSB9IGRlZmF1bHRWYWx1ZT17IHRoaXMucHJvcHMuYW5zd2VyLmV4dHJhIH0gb25DaGFuZ2U9eyB0aGlzLnVwZGF0ZUV4dHJhLmJpbmQoIHRoaXMgKSB9IG9uVG91Y2hFbmQ9eyAoZSkgPT4geyBlLnRhcmdldC5mb2N1cygpIH0gfSAvPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cImZ1aS1hbnN3ZXItLWFjdGlvbnNcIj5cblx0XHRcdFx0XHQ8YnV0dG9uIG9uQ2xpY2s9eyB0aGlzLmRlbGV0ZUZpZWxkIH1cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1idXR0b24taWNvbiBzdWktYnV0dG9uLXJlZCBzdWktdG9vbHRpcFwiXG5cdFx0XHRcdFx0XHRkYXRhLXRvb2x0aXA9eyB0cmFuc2xhdGUoICdEZWxldGUnICkgfT5cblx0XHRcdFx0XHRcdDxpIGNsYXNzTmFtZT1cInN1aS1pY29uLXRyYXNoXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXNjcmVlbi1yZWFkZXItdGV4dFwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0RlbGV0ZSBhbnN3ZXInICkgfVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kcm9wZG93blwiPlxuXHRcdFx0XHRcdFx0PGJ1dHRvbiBjbGFzc05hbWU9XCJzdWktYnV0dG9uLWljb24gc3VpLWRyb3Bkb3duLWFuY2hvclwiPlxuXHRcdFx0XHRcdFx0XHQ8aSBjbGFzc05hbWU9XCJzdWktaWNvbi13aWRnZXQtc2V0dGluZ3MtY29uZmlnXCJcblx0XHRcdFx0XHRcdFx0XHRhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1zY3JlZW4tcmVhZGVyLXRleHRcIj5cblx0XHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0Fuc3dlciBvcHRpb25zJyApIH1cblx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0XHQ8dWw+XG5cdFx0XHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5hbnN3ZXIudXNlX2V4dHJhICE9PSB0cnVlICYmXG5cdFx0XHRcdFx0XHRcdFx0PGxpPlxuXHRcdFx0XHRcdFx0XHRcdFx0PGJ1dHRvbiBvbkNsaWNrPXsgdGhpcy5hZGRFeHRyYS5iaW5kKCB0aGlzICkgfT5cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdFbmFibGUgY3VzdG9tIGlucHV0JyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0eyB0aGlzLnByb3BzLmFuc3dlci51c2VfZXh0cmEgPT09IHRydWUgJiZcblx0XHRcdFx0XHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8YnV0dG9uIG9uQ2xpY2s9eyB0aGlzLnJlbW92ZUV4dHJhLmJpbmQoIHRoaXMgKSB9PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1JlbW92ZSBjdXN0b20gaW5wdXQnICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0PC91bD5cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdDwvbGk+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9idWlsZGVyL2Fuc3dlci1yb3cuanMiLCJpbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnO1xuXG5pbXBvcnQgKiBhcyBzZXR0aW5nc0FjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucy9zZXR0aW5ncyc7XG5pbXBvcnQgKiBhcyBidWlsZGVyQWN0aW9ucyBmcm9tICcuLi9hY3Rpb25zL2J1aWxkZXInO1xuaW1wb3J0ICogYXMgbW9kYWxBY3Rpb25zIGZyb20gJy4uL2FjdGlvbnMvbW9kYWwnO1xuXG5pbXBvcnQgQXBwZWFyYW5jZSBmcm9tICcuLi9jb21wb25lbnRzL2FwcGVhcmFuY2UnO1xuXG5mdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHMoIHN0YXRlICkge1xuXHRyZXR1cm4ge1xuXHRcdGFuc3dlcnM6IHN0YXRlLmFuc3dlcnMsXG5cdFx0c2V0dGluZ3M6IHN0YXRlLnNldHRpbmdzLFxuXHR9O1xufVxuXG5mdW5jdGlvbiBtYXBEaXNwYXRjaFRvUHJvcHMoIGRpc3BhdGNoICkge1xuXHRyZXR1cm4ge1xuXHRcdGFjdGlvbnM6IHtcblx0XHRcdHNldHRpbmdzQWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKCBzZXR0aW5nc0FjdGlvbnMsIGRpc3BhdGNoICksXG5cdFx0XHRidWlsZGVyQWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKCBidWlsZGVyQWN0aW9ucywgZGlzcGF0Y2ggKSxcblx0XHRcdG1vZGFsQWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKCBtb2RhbEFjdGlvbnMsIGRpc3BhdGNoICksXG5cdFx0fSxcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChcblx0bWFwU3RhdGVUb1Byb3BzLFxuXHRtYXBEaXNwYXRjaFRvUHJvcHNcbikoIEFwcGVhcmFuY2UgKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbnRhaW5lcnMvYXBwZWFyYW5jZS5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGdldFRoZW1lUHJlZml4IH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCBxcyBmcm9tICdxcyc7XG5cbmltcG9ydCBEZXNpZ25TdHlsZSBmcm9tICcuL2FwcGVhcmFuY2UvZGVzaWduLXN0eWxlJztcbmltcG9ydCBDb2xvcnMgZnJvbSAnLi9hcHBlYXJhbmNlL2NvbG9ycyc7XG5pbXBvcnQgTGF5b3V0IGZyb20gJy4vYXBwZWFyYW5jZS9vcHRpb25zLWxheW91dCc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vYXBwZWFyYW5jZS9jb250YWluZXInO1xuaW1wb3J0IEN1c3RvbUNzcyBmcm9tICcuL2FwcGVhcmFuY2UvY3VzdG9tLWNzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFwcGVhcmFuY2UgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHRqUXVlcnkoICdodG1sLCBib2R5JyApLmFuaW1hdGUoXG5cdFx0XHR7XG5cdFx0XHRcdHNjcm9sbFRvcDogMCxcblx0XHRcdH0sICdmYXN0J1xuXHRcdCk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgZ29Ub1NlY3Rpb24gPSBtb2R1bGUgPT4ge1xuXHRcdFx0dGhpcy5wcm9wcy5oaXN0b3J5LnB1c2goICcvJyArIG1vZHVsZSApO1xuXHRcdH07XG5cdFx0Y29uc3QgZW5hYmxlSW1hZ2VzID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzLmVuYWJsZV9pbWFnZXMgKSA/IHRoaXMucHJvcHMuc2V0dGluZ3MuZW5hYmxlX2ltYWdlcyA6IGZhbHNlO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgaWQ9XCJmb3JtaW5hdG9yLWZvcm0tYXBwZWFyYW5jZVwiXG5cdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1ib3hcIj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtaGVhZGVyXCI+XG5cdFx0XHRcdFx0PGgyIGNsYXNzTmFtZT1cInN1aS1ib3gtdGl0bGVcIj57IHRyYW5zbGF0ZSggJ0FwcGVhcmFuY2UnICkgfTwvaDI+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1ib2R5XCIga2V5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXRoZW1lS2V5YH0+XG5cdFx0XHRcdFx0PERlc2lnblN0eWxlIHsgLi4udGhpcy5wcm9wcyB9IC8+XG5cdFx0XHRcdFx0PENvbG9ycyB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdHsgZW5hYmxlSW1hZ2VzICYmXG5cdFx0XHRcdFx0XHQ8TGF5b3V0IHsgLi4udGhpcy5wcm9wcyB9IC8+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdDxDb250YWluZXIgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHQ8Q3VzdG9tQ3NzIHsgLi4udGhpcy5wcm9wcyB9IC8+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1mb290ZXJcIj5cblxuXHRcdFx0XHRcdDxidXR0b24gY2xhc3NOYW1lPVwic3VpLWJ1dHRvblwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gZ29Ub1NlY3Rpb24oICcnICkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdDxpIGNsYXNzTmFtZT1cInN1aS1pY29uLWFycm93LWxlZnRcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0RldGFpbHMnICkgfVxuXHRcdFx0XHRcdDwvYnV0dG9uPlxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYWN0aW9ucy1yaWdodFwiPlxuXG5cdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzTmFtZT1cInN1aS1idXR0b24gc3VpLWJ1dHRvbi1pY29uLXJpZ2h0XCJcblx0XHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IGdvVG9TZWN0aW9uKCAnYmVoYXZpb3VyJyApIH1cblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdCZWhhdmlvcicgKSB9XG5cdFx0XHRcdFx0XHRcdDxpIGNsYXNzTmFtZT1cInN1aS1pY29uLWFycm93LXJpZ2h0XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuXHRcdFx0XHRcdFx0PC9idXR0b24+XG5cblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IFJhZGlvVGFicyBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvcmFkaW8tdGFicyc7XG5cbmltcG9ydCBEZXNpZ25EZWZhdWx0IGZyb20gJy4vZGVzaWduLXN0eWxlL2RlZmF1bHQnO1xuaW1wb3J0IERlc2lnbkZsYXQgZnJvbSAnLi9kZXNpZ24tc3R5bGUvZmxhdCc7XG5pbXBvcnQgRGVzaWduQm9sZCBmcm9tICcuL2Rlc2lnbi1zdHlsZS9ib2xkJztcbmltcG9ydCBEZXNpZ25NYXRlcmlhbCBmcm9tICcuL2Rlc2lnbi1zdHlsZS9tYXRlcmlhbCc7XG5pbXBvcnQgRGVzaWduQmFzaWMgZnJvbSAnLi9kZXNpZ24tc3R5bGUvYmFzaWMnO1xuaW1wb3J0IERlc2lnbk5vbmUgZnJvbSAnLi9kZXNpZ24tc3R5bGUvbm9uZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlc2lnblN0eWxlIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3Mtcm93XCI+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0xXCI+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXNldHRpbmdzLWxhYmVsXCI+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0Rlc2lnbiBTdHlsZScgKSB9XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdCdDaG9vc2UgYSBwcmUtbWFkZSBzdHlsZSBmb3IgeW91ciBwb2xsIGFuZCAnICtcblx0XHRcdFx0XHRcdFx0XCJmdXJ0aGVyIGN1c3RvbWl6ZSBpdCdzIGFwcGVhcmFuY2UgYmVsb3cuXCJcblx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0yXCI+XG5cblx0XHRcdFx0XHQ8UmFkaW9UYWJzXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9XCJmb3JtaW5hdG9yLXBvbGwtZGVzaWduXCJcblx0XHRcdFx0XHRcdGRlZmF1bHQ9XCJkZWZhdWx0XCJcblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHQ8RGVzaWduRGVmYXVsdFxuXHRcdFx0XHRcdFx0XHR2YWx1ZT1cImRlZmF1bHRcIlxuXHRcdFx0XHRcdFx0XHRib3hDbGFzcz1cInN1aS10YWItY29udGVudCBzdWktdGFiLWJveGVkXCJcblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdEZWZhdWx0JyApIH1cblx0XHRcdFx0XHRcdDwvRGVzaWduRGVmYXVsdD5cblx0XHRcdFx0XHRcdDxEZXNpZ25GbGF0XG5cdFx0XHRcdFx0XHRcdHZhbHVlPVwiZmxhdFwiXG5cdFx0XHRcdFx0XHRcdGJveENsYXNzPVwic3VpLXRhYi1jb250ZW50IHN1aS10YWItYm94ZWRcIlxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0ZsYXQnICkgfVxuXHRcdFx0XHRcdFx0PC9EZXNpZ25GbGF0PlxuXHRcdFx0XHRcdFx0PERlc2lnbkJvbGRcblx0XHRcdFx0XHRcdFx0dmFsdWU9XCJib2xkXCJcblx0XHRcdFx0XHRcdFx0Ym94Q2xhc3M9XCJzdWktdGFiLWNvbnRlbnQgc3VpLXRhYi1ib3hlZFwiXG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnQm9sZCcgKSB9XG5cdFx0XHRcdFx0XHQ8L0Rlc2lnbkJvbGQ+XG5cdFx0XHRcdFx0XHQ8RGVzaWduTWF0ZXJpYWxcblx0XHRcdFx0XHRcdFx0dmFsdWU9XCJtYXRlcmlhbFwiXG5cdFx0XHRcdFx0XHRcdGJveENsYXNzPVwic3VpLXRhYi1jb250ZW50IHN1aS10YWItYm94ZWRcIlxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ01hdGVyaWFsJyApIH1cblx0XHRcdFx0XHRcdDwvRGVzaWduTWF0ZXJpYWw+XG5cdFx0XHRcdFx0XHR7Lyo8RGVzaWduQmFzaWMgdmFsdWU9XCJiYXNpY1wiIGJveENsYXNzPVwic3VpLXRhYi1jb250ZW50IHN1aS10YWItYm94ZWRcIj4qL31cblx0XHRcdFx0XHRcdHsvKlx0eyB0cmFuc2xhdGUoICdUaGVtZSBzdHlsZScgKSB9Ki99XG5cdFx0XHRcdFx0XHR7Lyo8L0Rlc2lnbkJhc2ljPiovfVxuXHRcdFx0XHRcdFx0PERlc2lnbk5vbmVcblx0XHRcdFx0XHRcdFx0dmFsdWU9XCJub25lXCJcblx0XHRcdFx0XHRcdFx0Ym94Q2xhc3M9XCJzdWktdGFiLWNvbnRlbnRcIlxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ05vbmUnICkgfVxuXHRcdFx0XHRcdFx0PC9EZXNpZ25Ob25lPlxuXHRcdFx0XHRcdDwvUmFkaW9UYWJzPlxuXG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvZGVzaWduLXN0eWxlLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVzaWduRGVmYXVsdCBleHRlbmRzIENvbXBvbmVudCB7XG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmdWktZGVtbyBmdWktZGVtby0tcG9sbCBmdWktZGVtby0tZGVmYXVsdFwiPlxuXHRcdFx0XHQ8bGFiZWwgaHRtbEZvcj1cImZvcm1pbmF0b3ItcG9sbC1wcmV2aWV3LS1kZWZhdWx0LWRlZmF1bHRcIj5cblx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdHR5cGU9XCJyYWRpb1wiXG5cdFx0XHRcdFx0XHRpZD1cImZvcm1pbmF0b3ItcG9sbC1wcmV2aWV3LS1kZWZhdWx0LWRlZmF1bHRcIlxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuXHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnRGVmYXVsdCcgKSB9XG5cdFx0XHRcdDwvbGFiZWw+XG5cdFx0XHRcdDxsYWJlbCBodG1sRm9yPVwiZm9ybWluYXRvci1wb2xsLXByZXZpZXctLWRlZmF1bHQtY2hlY2tlZFwiPlxuXHRcdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdFx0dHlwZT1cInJhZGlvXCJcblx0XHRcdFx0XHRcdGlkPVwiZm9ybWluYXRvci1wb2xsLXByZXZpZXctLWRlZmF1bHQtY2hlY2tlZFwiXG5cdFx0XHRcdFx0XHRjaGVja2VkXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG5cdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdDaGVja2VkJyApIH1cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdFx0PGJ1dHRvbj57IHRyYW5zbGF0ZSggJ0J1dHRvbicgKSB9PC9idXR0b24+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvZGVzaWduLXN0eWxlL2RlZmF1bHQuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZXNpZ25GbGF0IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZ1aS1kZW1vIGZ1aS1kZW1vLS1wb2xsIGZ1aS1kZW1vLS1mbGF0XCI+XG5cdFx0XHRcdDxsYWJlbCBodG1sRm9yPVwiZm9ybWluYXRvci1wb2xsLXByZXZpZXctLWZsYXQtZGVmYXVsdFwiPlxuXHRcdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdFx0dHlwZT1cInJhZGlvXCJcblx0XHRcdFx0XHRcdGlkPVwiZm9ybWluYXRvci1wb2xsLXByZXZpZXctLWZsYXQtZGVmYXVsdFwiXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG5cdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdEZWZhdWx0JyApIH1cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdFx0PGxhYmVsIGh0bWxGb3I9XCJmb3JtaW5hdG9yLXBvbGwtcHJldmlldy0tZmxhdC1jaGVja2VkXCI+XG5cdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHR0eXBlPVwicmFkaW9cIlxuXHRcdFx0XHRcdFx0aWQ9XCJmb3JtaW5hdG9yLXBvbGwtcHJldmlldy0tZmxhdC1jaGVja2VkXCJcblx0XHRcdFx0XHRcdGNoZWNrZWRcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cblx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0NoZWNrZWQnICkgfVxuXHRcdFx0XHQ8L2xhYmVsPlxuXHRcdFx0XHQ8YnV0dG9uPnsgdHJhbnNsYXRlKCAnQnV0dG9uJyApIH08L2J1dHRvbj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9kZXNpZ24tc3R5bGUvZmxhdC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlc2lnbkJvbGQgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZnVpLWRlbW8gZnVpLWRlbW8tLXBvbGwgZnVpLWRlbW8tLWJvbGRcIj5cblx0XHRcdFx0PGxhYmVsIGh0bWxGb3I9XCJmb3JtaW5hdG9yLXBvbGwtcHJldmlldy0tYm9sZC1kZWZhdWx0XCI+XG5cdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHR0eXBlPVwicmFkaW9cIlxuXHRcdFx0XHRcdFx0aWQ9XCJmb3JtaW5hdG9yLXBvbGwtcHJldmlldy0tYm9sZC1kZWZhdWx0XCJcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cblx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0RlZmF1bHQnICkgfVxuXHRcdFx0XHQ8L2xhYmVsPlxuXHRcdFx0XHQ8bGFiZWwgaHRtbEZvcj1cImZvcm1pbmF0b3ItcG9sbC1wcmV2aWV3LS1ib2xkLWNoZWNrZWRcIj5cblx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdHR5cGU9XCJyYWRpb1wiXG5cdFx0XHRcdFx0XHRpZD1cImZvcm1pbmF0b3ItcG9sbC1wcmV2aWV3LS1ib2xkLWNoZWNrZWRcIlxuXHRcdFx0XHRcdFx0Y2hlY2tlZFxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuXHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnQ2hlY2tlZCcgKSB9XG5cdFx0XHRcdDwvbGFiZWw+XG5cdFx0XHRcdDxidXR0b24+eyB0cmFuc2xhdGUoICdCdXR0b24nICkgfTwvYnV0dG9uPlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2Rlc2lnbi1zdHlsZS9ib2xkLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVzaWduTWF0ZXJpYWwgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZnVpLWRlbW8gZnVpLWRlbW8tLXBvbGwgZnVpLWRlbW8tLW1hdGVyaWFsXCI+XG5cdFx0XHRcdDxsYWJlbCBodG1sRm9yPVwiZm9ybWluYXRvci1wb2xsLXByZXZpZXctLW1hdGVyaWFsLWRlZmF1bHRcIj5cblx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdHR5cGU9XCJyYWRpb1wiXG5cdFx0XHRcdFx0XHRpZD1cImZvcm1pbmF0b3ItcG9sbC1wcmV2aWV3LS1tYXRlcmlhbC1kZWZhdWx0XCJcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cblx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0RlZmF1bHQnICkgfVxuXHRcdFx0XHQ8L2xhYmVsPlxuXHRcdFx0XHQ8bGFiZWwgaHRtbEZvcj1cImZvcm1pbmF0b3ItcG9sbC1wcmV2aWV3LS1tYXRlcmlhbC1jaGVja2VkXCI+XG5cdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHR0eXBlPVwicmFkaW9cIlxuXHRcdFx0XHRcdFx0aWQ9XCJmb3JtaW5hdG9yLXBvbGwtcHJldmlldy0tbWF0ZXJpYWwtY2hlY2tlZFwiXG5cdFx0XHRcdFx0XHRjaGVja2VkXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG5cdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdDaGVja2VkJyApIH1cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdFx0PGJ1dHRvbj57IHRyYW5zbGF0ZSggJ0J1dHRvbicgKSB9PC9idXR0b24+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvZGVzaWduLXN0eWxlL21hdGVyaWFsLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVzaWduQmFzaWMgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZnVpLWRlbW8gZnVpLWRlbW8tLXBvbGwgZnVpLWRlbW8tLWJhc2ljXCI+XG5cdFx0XHRcdDxsYWJlbCBodG1sRm9yPVwiZm9ybWluYXRvci1wb2xsLXByZXZpZXctLWJhc2ljLWRlZmF1bHRcIj5cblx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdHR5cGU9XCJyYWRpb1wiXG5cdFx0XHRcdFx0XHRpZD1cImZvcm1pbmF0b3ItcG9sbC1wcmV2aWV3LS1iYXNpYy1kZWZhdWx0XCJcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cblx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0RlZmF1bHQnICkgfVxuXHRcdFx0XHQ8L2xhYmVsPlxuXHRcdFx0XHQ8bGFiZWwgaHRtbEZvcj1cImZvcm1pbmF0b3ItcG9sbC1wcmV2aWV3LS1iYXNpYy1jaGVja2VkXCI+XG5cdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHR0eXBlPVwicmFkaW9cIlxuXHRcdFx0XHRcdFx0aWQ9XCJmb3JtaW5hdG9yLXBvbGwtcHJldmlldy0tYmFzaWMtY2hlY2tlZFwiXG5cdFx0XHRcdFx0XHRjaGVja2VkXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG5cdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdDaGVja2VkJyApIH1cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdFx0PGJ1dHRvbj57IHRyYW5zbGF0ZSggJ0J1dHRvbicgKSB9PC9idXR0b24+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvZGVzaWduLXN0eWxlL2Jhc2ljLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVzaWduTm9uZSBleHRlbmRzIENvbXBvbmVudCB7XG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktbm90aWNlIHN1aS1hY3RpdmVcIiBzdHlsZT17IHsgZGlzcGxheTogJ2Jsb2NrJyB9IH0+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLW5vdGljZS1jb250ZW50XCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktbm90aWNlLW1lc3NhZ2VcIj5cblx0XHRcdFx0XHRcdDxwPnsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHQnWW91IGhhdmUgb3B0ZWQgZm9yIG5vIHN0eWxlc2hlZXQgdG8gYmUgZW5xdWV1ZWQuICcgK1xuXHRcdFx0XHRcdFx0XHRcIlRoZSBmb3JtIHdpbGwgaW5oZXJpdCBzdHlsZXMgZnJvbSB5b3VyIHRoZW1lJ3MgQ1NTLlwiXG5cdFx0XHRcdFx0XHQpIH08L3A+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2Rlc2lnbi1zdHlsZS9ub25lLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgdHJhbnNsYXRlLCBnZXRDaGFydFR5cGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBSYWRpb1RhYnMgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL3JhZGlvLXRhYnMnO1xuaW1wb3J0IEVtcHR5IGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvZW1wdHknO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbnRhaW5lcic7XG5pbXBvcnQgQWNjb3JkaW9uIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvYWNjb3JkaW9uJztcblxuaW1wb3J0IENvbnRhaW5lckNvbG9ycyBmcm9tICcuL2NvbG9ycy9jb250YWluZXInO1xuaW1wb3J0IFJlc3BvbnNlU3VjY2VzcyBmcm9tICcuL2NvbG9ycy9yZXNwb25zZS1zdWNjZXNzJztcbmltcG9ydCBSZXNwb25zZUVycm9yIGZyb20gJy4vY29sb3JzL3Jlc3BvbnNlLWVycm9yJztcbmltcG9ydCBDb250ZW50Q29sb3JzIGZyb20gJy4vY29sb3JzL2NvbnRlbnQnO1xuaW1wb3J0IE9wdGlvbnNDb2xvcnMgZnJvbSAnLi9jb2xvcnMvb3B0aW9ucyc7XG5pbXBvcnQgSW1hZ2VzQ29sb3JzIGZyb20gJy4vY29sb3JzL2ltYWdlcyc7XG5pbXBvcnQgSW5wdXRDb2xvcnMgZnJvbSAnLi9jb2xvcnMvaW5wdXQnO1xuaW1wb3J0IFN1Ym1pdENvbG9ycyBmcm9tICcuL2NvbG9ycy9zdWJtaXQnO1xuaW1wb3J0IExpbmtzQ29sb3JzIGZyb20gJy4vY29sb3JzL2xpbmtzJztcbmltcG9ydCBDaGFydCBmcm9tICcuL2NvbG9ycy9jaGFydCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9ycyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBlbmFibGVJbWFnZXMgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3MuZW5hYmxlX2ltYWdlcyApID8gdGhpcy5wcm9wcy5zZXR0aW5ncy5lbmFibGVfaW1hZ2VzIDogZmFsc2U7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLXJvd1wiPlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMVwiPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1zZXR0aW5ncy1sYWJlbFwiPlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdDb2xvcnMnICkgfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdCdBZGp1c3QgdGhlIGRlZmF1bHQgY29sb3IgY29tYmluYXRpb25zIHRvIG1hdGNoIHlvdXIgdGhlbWUgc3R5bGluZy4nXG5cdFx0XHRcdFx0KSB9PC9zcGFuPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3MtY29sLTJcIj5cblxuXHRcdFx0XHRcdDxSYWRpb1RhYnNcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT1cInBvbGwtY29sb3JzXCJcblx0XHRcdFx0XHRcdGRlZmF1bHQ9XCJcIlxuXHRcdFx0XHRcdD5cblxuXHRcdFx0XHRcdFx0PEVtcHR5IHZhbHVlPVwiXCI+XG5cdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnVXNlIGRlZmF1bHQgY29sb3JzJyApIH1cblx0XHRcdFx0XHRcdDwvRW1wdHk+XG5cblx0XHRcdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRcdFx0dmFsdWU9XCJ0cnVlXCJcblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdDdXN0b20nICkgfVxuXHRcdFx0XHRcdFx0PlxuXG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWFjY29yZGlvblwiPlxuXG5cdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYWNjb3JkaW9uLWhlYWRlclwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0PGRpdj57IHRyYW5zbGF0ZSggJ0VsZW1lbnQnICkgfTwvZGl2PlxuXHRcdFx0XHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUG9sbCBDb250YWluZXInICkgfVxuXHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdDxDb250YWluZXJDb2xvcnMgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblxuXHRcdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1BvbGwgQmFzaWNzJyApIH1cblx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8Q29udGVudENvbG9ycyB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgZW5hYmxlSW1hZ2VzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdD8gdHJhbnNsYXRlKCAnQW5zd2VycyAtIFJhZGlvIE9wdGlvbicgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ6IHRyYW5zbGF0ZSggJ1JhZGlvIE9wdGlvbnMnIClcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8T3B0aW9uc0NvbG9ycyB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHRcdFx0eyBlbmFibGVJbWFnZXMgJiYgKFxuXHRcdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0Fuc3dlcnMgLSBSYWRpbyBJbWFnZScgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxJbWFnZXNDb2xvcnMgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXHRcdFx0XHRcdFx0XHRcdCl9XG5cblx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdDdXN0b20gQW5zd2VyIElucHV0JyApIH1cblx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8SW5wdXRDb2xvcnMgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblxuXHRcdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1N1Ym1pdCBCdXR0b24nICkgfVxuXHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdDxTdWJtaXRDb2xvcnMgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblxuXHRcdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1ZpZXcgUmVzdWx0cyBMaW5rJyApIH1cblx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8TGlua3NDb2xvcnMgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblxuXHRcdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1Jlc3BvbnNlIFN1Y2Nlc3MnICkgfVxuXHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdDxSZXNwb25zZVN1Y2Nlc3MgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblxuXHRcdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1Jlc3BvbnNlIEVycm9yJyApIH1cblx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8UmVzcG9uc2VFcnJvciB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHRcdFx0eyAnbm9uZScgIT09IGdldENoYXJ0VHlwZSggdGhpcy5wcm9wcy5zZXR0aW5ncyApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4uIHRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1Jlc3VsdHMgQ2hhcnQnICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8Q2hhcnQgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0XHQ8L1JhZGlvVGFicz5cblxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IHRyYW5zbGF0ZSwgZ2V0VGhlbWVQcmVmaXgsIGdldERlZmF1bHRWYWx1ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IENvbG9yUGlja2VyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9jb2xvci1waWNrZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250YWluZXJDb2xvcnMgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Ym94X2JvcmRlcmB9XG5cdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzAwMDAwMDAwXCIpIH1gfVxuXHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0Lz5cblx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWJveF9iYWNrZ3JvdW5kYH1cblx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjZmZmZmZmMDBcIikgfWB9XG5cdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHQvPlxuXHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQm94IHNoYWRvdycgKSB9XG5cdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Ym94X3NoYWRvd2B9XG5cdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI2U2ZTZlNjAwXCIpIH1gfVxuXHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0Lz5cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9jb250YWluZXIuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyB0cmFuc2xhdGUsIGdldFRoZW1lUHJlZml4LCBnZXREZWZhdWx0VmFsdWUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY29sb3ItcGlja2VyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3VjY2Vzc0NvbG9ycyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXG5cdFx0XHRcdDxwIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPnsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdCdTdWNjZXNzZnVsIHJlc3BvbnNlIG1lc3NhZ2Ugd2lsbCBiZSBkaXNwbGF5ZWQgYWZ0ZXIgcG9sbCBzdWJtaXNzaW9uIHN1Y2NlZWRzLidcblx0XHRcdFx0KSB9PC9wPlxuXG5cdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXIgY29sb3InICkgfVxuXHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXN1Y2Nlc3NfYm9yZGVyYH1cblx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMUFCQ0ExXCIpIH1gfVxuXHRcdFx0XHQvPlxuXG5cdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCYWNrZ3JvdW5kIGNvbG9yJyApIH1cblx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1zdWNjZXNzX2JhY2tncm91bmRgfVxuXHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNCQ0VFRTZcIikgfWB9XG5cdFx0XHRcdC8+XG5cblx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RleHQgY29sb3InICkgfVxuXHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXN1Y2Nlc3NfdGV4dGB9XG5cdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzMzMzMzM1wiKSB9YH1cblx0XHRcdFx0Lz5cblxuXHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL3Jlc3BvbnNlLXN1Y2Nlc3MuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyB0cmFuc2xhdGUsIGdldFRoZW1lUHJlZml4LCBnZXREZWZhdWx0VmFsdWUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY29sb3ItcGlja2VyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JDb2xvcnMgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblxuXHRcdFx0XHQ8cCBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHQnRXJyb3IgcmVzcG9uc2UgbWVzc2FnZSB3aWxsIGJlIGRpc3BsYXllZCBhZnRlciBwb2xsIHZvdGUgc3VibWlzc2lvbiBmYWlscy4nXG5cdFx0XHRcdCkgfTwvcD5cblxuXHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQm9yZGVyIGNvbG9yJyApIH1cblx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1lcnJvcl9ib3JkZXJgfVxuXHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFMDQ1NjJcIikgfWB9XG5cdFx0XHRcdC8+XG5cblx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWVycm9yX2JhY2tncm91bmRgfVxuXHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNGOUU0RThcIikgfWB9XG5cdFx0XHRcdC8+XG5cblx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RleHQgY29sb3InICkgfVxuXHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWVycm9yX3RleHRgfVxuXHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMzMzMzMzNcIikgfWB9XG5cdFx0XHRcdC8+XG5cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9yZXNwb25zZS1lcnJvci5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IHRyYW5zbGF0ZSwgZ2V0VGhlbWVQcmVmaXgsIGdldERlZmF1bHRWYWx1ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IENvbG9yUGlja2VyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9jb2xvci1waWNrZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZW50Q29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdRdWVzdGlvbiBjb2xvcicgKSB9XG5cdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9cG9sbF9xdWVzdGlvbmB9XG5cdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzMzMzMzM1wiKSB9YH1cblx0XHRcdFx0Lz5cblx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0Rlc2NyaXB0aW9uIGNvbG9yJyApIH1cblx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1wb2xsX2Rlc2NyaXB0aW9uYH1cblx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjNzc3NzcxXCIpIH1gfVxuXHRcdFx0XHQvPlxuXHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnXCJObyB2b3RlcyB5ZXRcIiB0ZXh0IGNvbG9yJyApIH1cblx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1ub3ZvdGVzX3RleHRgfVxuXHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMzMzMzMzNcIikgfWB9XG5cdFx0XHRcdFx0ZGVzY3JpcHRpb249eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHQnVXNlcnMgc2VlIHRoaXMgdGV4dCBuZXh0IHRvIHN1Ym1pdCBidXR0b24gd2hlbiAnICtcblx0XHRcdFx0XHRcdCdcImxpbmsgb24gcG9sbFwiIHN1Ym1pc3Npb24gaXMgZW5hYmxlZC4nXG5cdFx0XHRcdFx0KSB9XG5cdFx0XHRcdC8+XG5cdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvY29udGVudC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IHRyYW5zbGF0ZSwgZ2V0VGhlbWVQcmVmaXgsIGdldERlZmF1bHRWYWx1ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IFRhYnMgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy90YWJzJztcbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY29sb3ItcGlja2VyJztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9jb250YWluZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZW50Q29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8VGFic1xuXHRcdFx0XHR0eXBlPVwidGFic1wiXG5cdFx0XHRcdGRlZmF1bHQ9XCJkZWZhdWx0XCJcblx0XHRcdFx0ZXh0cmFDbGFzcz1cInN1aS10YWJzLWZsdXNoZWRcIlxuXHRcdFx0PlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHR2YWx1ZT1cImRlZmF1bHRcIlxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRGVmYXVsdCcgKSB9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1pbnB1dGJvYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcInJnYmEoMTE5LDExOSwxMTMsMSlcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQnICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9aW5wdXRiZ2B9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCJyZ2JhKDIzNywyMzcsMjM3LDEpXCIpIH1gfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdUZXh0IGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXBvbGxfYW5zd2Vyc2B9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMDAwMDAwXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHR2YWx1ZT1cImNoZWNrZWRcIlxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQ2hlY2tlZCcgKSB9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1pbnB1dGJvX2FjdGl2ZWB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCJyZ2JhKDIzLDE2OCwyMjcsMSlcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQnICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9aW5wdXRiZ19hY3RpdmVgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwicmdiYSgyMzcsMjM3LDIzNywxKVwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnSWNvbiBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1yYWRpb19kb3RgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwicmdiYSgyMywxNjgsMjI3LDEpXCIpIH1gfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHQ8L1RhYnM+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9vcHRpb25zLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgdHJhbnNsYXRlLCBnZXRUaGVtZVByZWZpeCwgZ2V0RGVmYXVsdFZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgVGFicyBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL3RhYnMnO1xuaW1wb3J0IENvbG9yUGlja2VyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9jb2xvci1waWNrZXInO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbnRhaW5lcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGlvSW1hZ2VzQ29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8VGFic1xuXHRcdFx0XHR0eXBlPVwidGFic1wiXG5cdFx0XHRcdGRlZmF1bHQ9XCJkZWZhdWx0XCJcblx0XHRcdFx0ZXh0cmFDbGFzcz1cInN1aS10YWJzLWZsdXNoZWRcIlxuXHRcdFx0PlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHR2YWx1ZT1cImRlZmF1bHRcIlxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRGVmYXVsdCcgKSB9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1pbWFnZS1ib3JkZXItc3RhdGljYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM3Nzc3NzFcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQnICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9aW1hZ2UtYmFja2dyb3VuZC1zdGF0aWNgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI2VkZWRlZFwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0dmFsdWU9XCJob3ZlclwiXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdIb3ZlcicgKSB9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1pbWFnZS1ib3JkZXItaG92ZXJgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzE3YThlM1wiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQmFja2dyb3VuZCcgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1pbWFnZS1iYWNrZ3JvdW5kLWhvdmVyYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNlMWY2ZmZcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdHZhbHVlPVwiY2hlY2tlZFwiXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdDaGVja2VkJyApIH1cblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQm9yZGVyIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWltYWdlLWJvcmRlci1jaGVja2VkYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMxN2E4ZTNcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQnICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9aW1hZ2UtYmFja2dyb3VuZC1jaGVja2VkYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNlMWY2ZmZcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdDwvVGFicz5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2ltYWdlcy5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IHRyYW5zbGF0ZSwgZ2V0VGhlbWVQcmVmaXgsIGdldERlZmF1bHRWYWx1ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IFRhYnMgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy90YWJzJztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9jb250YWluZXInO1xuaW1wb3J0IENvbG9yUGlja2VyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9jb2xvci1waWNrZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dENvbG9ycyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PFRhYnNcblx0XHRcdFx0dHlwZT1cInRhYnNcIlxuXHRcdFx0XHRkZWZhdWx0PVwiZGVmYXVsdFwiXG5cdFx0XHRcdGV4dHJhQ2xhc3M9XCJzdWktdGFicy1mbHVzaGVkXCJcblx0XHRcdD5cblxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0dmFsdWU9XCJkZWZhdWx0XCJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0RlZmF1bHQnICkgfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXIgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Zm9ybWluYXRvci1wb2xsLWlucHV0LWJvcmRlcl9zdGF0aWNgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwicmdiYSgxMTksMTE5LDExMywxKVwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQmFja2dyb3VuZCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1mb3JtaW5hdG9yLXBvbGwtaW5wdXQtYmFja2dyb3VuZF9zdGF0aWNgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwicmdiYSgyMzcsMjM3LDIzNywxKVwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUGxhY2Vob2xkZXInICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9aW5wdXRfcGxhY2Vob2xkZXJgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzg4ODg4OFwiKSB9YH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGV4dCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1pbnB1dF90ZXh0YH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMwMDAwMDBcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdHZhbHVlPVwiaG92ZXJcIlxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnSG92ZXInICkgfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXIgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Zm9ybWluYXRvci1wb2xsLWlucHV0LWJvcmRlcl9ob3ZlcmB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCJyZ2JhKDIzLDE2OCwyMjcsMSlcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Zm9ybWluYXRvci1wb2xsLWlucHV0LWJhY2tncm91bmRfaG92ZXJgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwicmdiYSgyMzAsMjMwLDIzMCwxKVwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGV4dCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1pbnB1dF90ZXh0X2hvdmVyYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMwMDAwMDBcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdHZhbHVlPVwiZm9jdXNcIlxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRm9jdXMnICkgfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXIgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Zm9ybWluYXRvci1wb2xsLWlucHV0LWJvcmRlcl9hY3RpdmVgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwicmdiYSgyMywxNjgsMjI3LDEpXCIpIH1gfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCYWNrZ3JvdW5kIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWZvcm1pbmF0b3ItcG9sbC1pbnB1dC1iYWNrZ3JvdW5kX2FjdGl2ZWB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCJyZ2JhKDIzMCwyMzAsMjMwLDEpXCIpIH1gfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdUZXh0IGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWlucHV0X3RleHRfYWN0aXZlYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMwMDAwMDBcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdDwvVGFicz5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2lucHV0LmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgdHJhbnNsYXRlLCBnZXRUaGVtZVByZWZpeCwgZ2V0RGVmYXVsdFZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgVGFicyBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL3RhYnMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbnRhaW5lcic7XG5pbXBvcnQgQ29sb3JQaWNrZXIgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2NvbG9yLXBpY2tlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1Ym1pdENvbG9ycyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PFRhYnNcblx0XHRcdFx0dHlwZT1cInRhYnNcIlxuXHRcdFx0XHRkZWZhdWx0PVwiZGVmYXVsdFwiXG5cdFx0XHRcdGV4dHJhQ2xhc3M9XCJzdWktdGFicy1mbHVzaGVkXCJcblx0XHRcdD5cblxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0dmFsdWU9XCJkZWZhdWx0XCJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0RlZmF1bHQnICkgfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCYWNrZ3JvdW5kIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWJ1dHRvbmJnYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcInJnYmEoMjMsMTY4LDIyNywxKVwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGV4dCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1idXR0b250eHRgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwicmdiYSgyNTUsMjU1LDI1NSwxKVwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0dmFsdWU9XCJob3ZlclwiXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdIb3ZlcicgKSB9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9YnV0dG9uYmdfaG92ZXJgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwicmdiYSgwLDE0MywyMDIsMSlcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RleHQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9YnV0dG9udHh0X2hvdmVyYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcInJnYmEoMjU1LDI1NSwyNTUsMSlcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdHZhbHVlPVwiYWN0aXZlXCJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0FjdGl2ZScgKSB9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9YnV0dG9uYmdfYWN0aXZlYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcInJnYmEoMCwxNDMsMjAyLDEpXCIpIH1gfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdUZXh0IGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWJ1dHRvbnR4dF9hY3RpdmVgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwicmdiYSgyNTUsMjU1LDI1NSwxKVwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0PC9UYWJzPlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvc3VibWl0LmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgdHJhbnNsYXRlLCBnZXRUaGVtZVByZWZpeCwgZ2V0RGVmYXVsdFZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgVGFicyBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL3RhYnMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbnRhaW5lcic7XG5pbXBvcnQgQ29sb3JQaWNrZXIgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2NvbG9yLXBpY2tlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmtzQ29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8VGFic1xuXHRcdFx0XHR0eXBlPVwidGFic1wiXG5cdFx0XHRcdGRlZmF1bHQ9XCJkZWZhdWx0XCJcblx0XHRcdFx0ZXh0cmFDbGFzcz1cInN1aS10YWJzLWZsdXNoZWRcIlxuXHRcdFx0PlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHR2YWx1ZT1cImRlZmF1bHRcIlxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRGVmYXVsdCcgKSB9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0xpbmsgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Y29sb3JfbGlua2B9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCJyZ2JhKDIzLDE2OCwyMjcsIDEpXCIpIH1gfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHR2YWx1ZT1cImhvdmVyXCJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0hvdmVyJyApIH1cblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnTGluayBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1jb2xvcl9saW5rX2hvdmVyYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcInJnYmEoMCwxNDMsMjAyLCAxKVwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0dmFsdWU9XCJhY3RpdmVcIlxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQWN0aXZlJyApIH1cblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnTGluayBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1jb2xvcl9saW5rX2FjdGl2ZWB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCJyZ2JhKDAsMTQzLDIwMiwgMSlcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdDwvVGFicz5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2xpbmtzLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgdHJhbnNsYXRlLCBnZXRDaGFydFR5cGUsIGdldFRoZW1lUHJlZml4LCBnZXREZWZhdWx0VmFsdWUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBUYWJzIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvdGFicyc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvY29udGFpbmVyJztcbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY29sb3ItcGlja2VyJztcbmltcG9ydCBBbnN3ZXJDb2xvciBmcm9tICcuL2Fuc3dlci1jb2xvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYXJ0Q29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8VGFic1xuXHRcdFx0XHR0eXBlPVwidGFic1wiXG5cdFx0XHRcdGRlZmF1bHQ9XCJiYXNpY3NcIlxuXHRcdFx0XHRleHRyYUNsYXNzPVwic3VpLXRhYnMtZmx1c2hlZFwiXG5cdFx0XHQ+XG5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdHZhbHVlPVwiYmFzaWNzXCJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0Jhc2ljcycgKSB9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7ICdiYXInID09PSBnZXRDaGFydFR5cGUoIHRoaXMucHJvcHMuc2V0dGluZ3MgKSAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQ2hhcnQgZ3JpZCBsaW5lcycgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWdyaWRfbGluZXNgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjRTVFNUU1XCIpIH1gfVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyAncGllJyA9PT0gZ2V0Q2hhcnRUeXBlKCB0aGlzLnByb3BzLnNldHRpbmdzIClcblx0XHRcdFx0XHRcdFx0PyB0cmFuc2xhdGUoICdMZWdlbmQgdGV4dCBjb2xvcicgKVxuXHRcdFx0XHRcdFx0XHQ6IHRyYW5zbGF0ZSggJ0NoYXJ0IGxhYmVscyBjb2xvcicgKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZGVzY3JpcHRpb249eyAncGllJyA9PT0gZ2V0Q2hhcnRUeXBlKCB0aGlzLnByb3BzLnNldHRpbmdzIClcblx0XHRcdFx0XHRcdFx0PyB0cmFuc2xhdGUoICdMZWdlbmRzIGFyZSBhbHdheXMgZGlzcGxheWVkIG9uIHRvcCBvZiB0aGUgY2hhcnQuJyApXG5cdFx0XHRcdFx0XHRcdDogJydcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWdyaWRfbGFiZWxzYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM3Nzc3NzFcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR7ICdiYXInID09PSBnZXRDaGFydFR5cGUoIHRoaXMucHJvcHMuc2V0dGluZ3MgKSAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVm90ZXMgY291bnQnICkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1vbmJhcl92b3Rlc2B9XG5cdFx0XHRcdFx0XHRcdGRlc2NyaXB0aW9uPXsgdHJhbnNsYXRlKCAnVGV4dCBkaXNwbGF5ZWQgaW5zaWRlIGJhcnMuJyApIH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzMzMzMzM1wiKSB9YH1cblx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHR2YWx1ZT1cInRvb2x0aXBzXCJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1Rvb2x0aXBzJyApIH1cblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQmFja2dyb3VuZCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH10b29sdGlwc19iYWNrZ3JvdW5kYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMzMzMzMzNcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RleHQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9dG9vbHRpcHNfdGV4dGB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjRkZGRkZGXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHR2YWx1ZT1cInZvdGVzXCJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0Fuc3dlcnMnICkgfVxuXHRcdFx0XHQ+XG5cblx0XHRcdFx0XHQ8cCBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdCdDaG9vc2UgdGhlIGdyYXBoIGNvbG9ycyBmb3IgZWFjaCBwb2xsIGFuc3dlcnMgYmVsb3cuJ1xuXHRcdFx0XHRcdCkgfTwvcD5cblxuXHRcdFx0XHRcdHsgXy5tYXAoIHRoaXMucHJvcHMuYW5zd2VycywgKCBhbnN3ZXIsIGkgKSA9PiAoXG5cdFx0XHRcdFx0XHQ8QW5zd2VyQ29sb3Jcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0a2V5PXsgYW5zd2VyLmVsZW1lbnRfaWQgfVxuXHRcdFx0XHRcdFx0XHRhbnN3ZXI9eyBhbnN3ZXIgfVxuXHRcdFx0XHRcdFx0XHRjb3VudGVyPXsgaSB9XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdCkgKX1cblxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0PC9UYWJzPlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvY2hhcnQuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyB0cmFuc2xhdGUsIGdldENoYXJ0VHlwZSwgZ2V0VGhlbWVQcmVmaXgsIGdldERlZmF1bHRWYWx1ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IENvbG9yUGlja2VyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9jb2xvci1waWNrZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbnN3ZXJDb2xvciBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblxuXHRcdHRoaXMudXBkYXRlUHJvcGVydHkgPSB0aGlzLnVwZGF0ZVByb3BlcnR5LmJpbmQoIHRoaXMgKTtcblx0fVxuXG5cdHVwZGF0ZVByb3BlcnR5KCBwcm9wLCB2YWx1ZSApIHtcblx0XHRjb25zdCBhbnN3ZXIgPSBPYmplY3QuYXNzaWduKCB7fSwgdGhpcy5wcm9wcy5hbnN3ZXIgKTtcblx0XHRhbnN3ZXIuY29sb3IgPSB2YWx1ZTtcblxuXHRcdHRoaXMucHJvcHMuYWN0aW9ucy5idWlsZGVyQWN0aW9ucy51cGRhdGVBbnN3ZXIoIGFuc3dlciApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGRlZmF1bHRDb2xvciA9IGZvcm1pbmF0b3JEYXRhLnBvbGxBbnN3ZXJDb2xvcnNbIHRoaXMucHJvcHMuY291bnRlciBdIHx8ICcjRTVFNUU1JztcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0bGFiZWw9eyB0aGlzLnByb3BzLmFuc3dlci50aXRsZSB9XG5cdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWNvbG9yYH1cblx0XHRcdFx0ZGVmYXVsdFZhbHVlPXsgZGVmYXVsdENvbG9yIH1cblx0XHRcdFx0c2V0dGluZ3M9eyB0aGlzLnByb3BzLmFuc3dlciB9XG5cdFx0XHRcdHVwZGF0ZVByb3BlcnR5PXsgdGhpcy51cGRhdGVQcm9wZXJ0eSB9XG5cdFx0XHRcdGlzQWxwaGFcblx0XHRcdC8+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9hbnN3ZXItY29sb3IuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBTZXR0aW5nc1JvdyBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL3NldHRpbmdzLXJvdyc7XG5pbXBvcnQgUmFkaW9UYWJzIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9yYWRpby10YWJzJztcbmltcG9ydCBSYWRpb09wdGlvbnMgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL3JhZGlvLW9wdGlvbnMnO1xuaW1wb3J0IFN1aVNlbGVjdCBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvc3VpLXNlbGVjdCc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvY29udGFpbmVyJztcbmltcG9ydCBFbXB0eSBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2VtcHR5JztcbmltcG9ydCBGaWVsZEltYWdlU2l6ZSBmcm9tICcuL2xheW91dC9maWVsZC1pbWFnZS1zaXplJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3B0aW9uc0xheW91dCBleHRlbmRzIENvbXBvbmVudCB7XG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PFNldHRpbmdzUm93XG5cdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnTGF5b3V0JyApIH1cblx0XHRcdFx0ZGVzY3JpcHRpb249eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0J0FkanVzdCB0aGUgYW5zd2VycyBsYXlvdXQgYW5kIG92ZXJhbGwgcG9sbCBhbGlnbm1lbnQuJ1xuXHRcdFx0XHQpIH1cblx0XHRcdD5cblx0XHRcdFx0PFJhZGlvVGFic1xuXHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0cHJvcGVydHk9XCJmaWVsZC1pbWFnZS1zaXplXCJcblx0XHRcdFx0XHRkZWZhdWx0PVwiY3VzdG9tXCJcblx0XHRcdFx0XHRzZXR0aW5nc0xhYmVsPXsgdHJhbnNsYXRlKCAnUmFkaW8vQ2hlY2tib3ggSW1hZ2UgU2l6ZScgKSB9XG5cdFx0XHRcdFx0ZGVzY3JpcHRpb249eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHQnU2V0IHJhZGlvL2NoZWNrYm94IGltYWdlIHNpemUuJ1xuXHRcdFx0XHRcdCkgfVxuXHRcdFx0XHQ+XG5cblx0XHRcdFx0XHQ8RW1wdHkgdmFsdWU9XCJhdXRvXCI+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0F1dG9tYXRpYycgKSB9XG5cdFx0XHRcdFx0PC9FbXB0eT5cblxuXHRcdFx0XHRcdDxGaWVsZEltYWdlU2l6ZSB7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0dmFsdWU9XCJjdXN0b21cIlxuXHRcdFx0XHRcdFx0Ym94Q2xhc3M9XCJzdWktdGFiLWJveGVkXCI+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0N1c3RvbScgKSB9XG5cdFx0XHRcdFx0PC9GaWVsZEltYWdlU2l6ZT5cblxuXHRcdFx0XHQ8L1JhZGlvVGFicz5cblxuXHRcdFx0XHQ8UmFkaW9PcHRpb25zXG5cdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRwcm9wZXJ0eT1cInZpc3VhbF9zdHlsZVwiXG5cdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPVwibGlzdFwiXG5cdFx0XHRcdFx0c2V0dGluZ3NMYWJlbD17IHRyYW5zbGF0ZSggJ0Fuc3dlcnMnICkgfVxuXHRcdFx0XHRcdHNldHRpbmdzRGVzYz17IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdCdDaG9vc2Ugd2hldGhlciB0aGUgcG9sbCBhbnN3ZXJzIHNob3VsZCBhcHBlYXIgaW4gYSBsaXN0IG9yIGEgZ3JpZC4nXG5cdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0cmFkaW9DbGFzcz1cInN1aS1yYWRpby1zbVwiXG5cdFx0XHRcdFx0cmFkaW9Db250ZW50PVwidHJ1ZVwiXG5cdFx0XHRcdD5cblxuXHRcdFx0XHRcdDxFbXB0eVxuXHRcdFx0XHRcdFx0dmFsdWU9XCJsaXN0XCJcblx0XHRcdFx0XHRcdGhhc0ltYWdlXG5cdFx0XHRcdFx0XHRpbWFnZTF4PVwicXVpei1saXN0LnBuZ1wiXG5cdFx0XHRcdFx0XHRpbWFnZTJ4PVwicXVpei1saXN0QDJ4LnBuZ1wiXG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0xpc3QnICkgfVxuXHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0XHR2YWx1ZT1cImdyaWRcIlxuXHRcdFx0XHRcdFx0aGFzSW1hZ2Vcblx0XHRcdFx0XHRcdGltYWdlMXg9XCJxdWl6LWdyaWQucG5nXCJcblx0XHRcdFx0XHRcdGltYWdlMng9XCJxdWl6LWdyaWRAMngucG5nXCJcblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnR3JpZCcgKSB9XG5cdFx0XHRcdFx0PlxuXG5cdFx0XHRcdFx0XHQ8cFxuXHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIlxuXHRcdFx0XHRcdFx0XHRzdHlsZT17IHsgbWFyZ2luQm90dG9tOiAnMjBweCcgfSB9XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHRcdCdDaG9vc2UgdGhlIG51bWJlciBvZiBjb2x1bW5zIHRvIGZpdCBpbiBvbmUgcm93LiAnICtcblx0XHRcdFx0XHRcdFx0XHQnTm90ZSB0aGF0IGdyaWQgbGF5b3V0IGNoYW5nZXMgdG8gdHdvIGNvbHVtbnMgb24gJyArXG5cdFx0XHRcdFx0XHRcdFx0XCJzbWFsbGVyIHNjcmVlbnMgc28gdGhpcyB3b24ndCBhZmZlY3QgdGhlIHNtYWxsZXIgXCIgK1xuXHRcdFx0XHRcdFx0XHRcdCdzY3JlZW5zLidcblx0XHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0XHQ8L3A+XG5cblx0XHRcdFx0XHRcdDxTdWlTZWxlY3Rcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJwb2xsLWdyaWQtY29sc1wiXG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT1cIjNcIlxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0NvbHVtbnMgcGVyIHJvdycgKSB9XG5cdFx0XHRcdFx0XHRcdGZpZWxkc2l6ZT1cIjEwMFwiXG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCIyXCI+Mjwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiM1wiPjM8L29wdGlvbj5cblx0XHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIjRcIj40PC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCI1XCI+NTwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiNlwiPjY8L29wdGlvbj5cblx0XHRcdFx0XHRcdDwvU3VpU2VsZWN0PlxuXG5cdFx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0PC9SYWRpb09wdGlvbnM+XG5cblx0XHRcdFx0ey8qIDxSYWRpb1RhYnNcblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdHByb3BlcnR5PVwicG9sbF9hbGlnbm1lbnRcIlxuXHRcdFx0XHRcdGRlZmF1bHQ9XCJsZWZ0XCJcblx0XHRcdFx0XHRzZXR0aW5nc0xhYmVsPXsgdHJhbnNsYXRlKCAnUG9sbCBBbGlnbm1lbnQnICkgfVxuXHRcdFx0XHRcdGRlc2NyaXB0aW9uPXsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0J0Nob29zZSB0aGUgb3ZlcmFsbCBhbGlnbm1lbnQgb2YgeW91ciBwb2xsLiBUaGlzIHNldHRpbmcgJyArXG5cdFx0XHRcdFx0XHQnYWZmZWN0cyBldmVyeXRoaW5nLCBpbmNsdWRpbmcgdGl0bGUsIGRlc2NyaXB0aW9uLCBxdWVzdGlvbnMgJyArXG5cdFx0XHRcdFx0XHQnYW5kIGFuc3dlcnMsIGJ1dHRvbnMsIGFuZCBzb2NpYWwgc2hhcmUgbWVzc2FnZS4nXG5cdFx0XHRcdFx0KSB9XG5cdFx0XHRcdD5cblxuXHRcdFx0XHRcdDxFbXB0eSB2YWx1ZT1cImxlZnRcIj5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnTGVmdCcgKSB9XG5cdFx0XHRcdFx0PC9FbXB0eT5cblxuXHRcdFx0XHRcdDxFbXB0eSB2YWx1ZT1cImNlbnRlclwiPlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdDZW50ZXInICkgfVxuXHRcdFx0XHRcdDwvRW1wdHk+XG5cblx0XHRcdFx0XHQ8RW1wdHkgdmFsdWU9XCJyaWdodFwiPlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdSaWdodCcgKSB9XG5cdFx0XHRcdFx0PC9FbXB0eT5cblxuXHRcdFx0XHQ8L1JhZGlvVGFicz4gKi99XG5cblx0XHRcdFx0PFJhZGlvVGFic1xuXHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0cHJvcGVydHk9XCJpbnB1dF92aXNpYmlsaXR5XCJcblx0XHRcdFx0XHRkZWZhdWx0PVwidHJ1ZVwiXG5cdFx0XHRcdFx0c2V0dGluZ3NMYWJlbD17IHRyYW5zbGF0ZSggJ0Fuc3dlciBUeXBlJyApIH1cblx0XHRcdFx0XHRkZXNjcmlwdGlvbj17IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdCdDaG9vc2UgaG93IHlvdXIgcG9sbCBhbnN3ZXJzIHNob3VsZCBiZSBkaXNwbGF5ZWQgb24gdGhlIGZyb250ZW5kLidcblx0XHRcdFx0XHQpIH1cblx0XHRcdFx0PlxuXG5cdFx0XHRcdFx0PEVtcHR5IHZhbHVlPVwidHJ1ZVwiPlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdJbWFnZSBhbmQgUmFkaW8gQnV0dG9uJyApIH1cblx0XHRcdFx0XHQ8L0VtcHR5PlxuXG5cdFx0XHRcdFx0PEVtcHR5IHZhbHVlPVwiZmFsc2VcIj5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnSW1hZ2Ugb25seScgKSB9XG5cdFx0XHRcdFx0PC9FbXB0eT5cblxuXHRcdFx0XHQ8L1JhZGlvVGFicz5cblxuXHRcdFx0PC9TZXR0aW5nc1Jvdz5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2Uvb3B0aW9ucy1sYXlvdXQuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgQ29sIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvY29sJztcbmltcG9ydCBJbnB1dCBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvaW5wdXQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWVsZEltYWdlU2l6ZSBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0cm9sZT1cImFsZXJ0XCJcblx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktbm90aWNlIHN1aS1ub3RpY2UtYmx1ZSBzdWktYWN0aXZlXCJcblx0XHRcdFx0XHRhcmlhLWxpdmU9XCJhc3NlcnRpdmVcIlxuXHRcdFx0XHRcdHN0eWxlPXsgeyBkaXNwbGF5OiAnYmxvY2snIH0gfVxuXHRcdFx0XHQ+XG5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ub3RpY2UtY29udGVudFwiPlxuXG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ub3RpY2UtbWVzc2FnZVwiPlxuXG5cdFx0XHRcdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLW5vdGljZS1pY29uIHN1aS1pY29uLWluZm9cIlxuXHRcdFx0XHRcdFx0XHRcdGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG5cdFx0XHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0XHRcdFx0PHA+XG5cdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdFx0XHQnTm90ZTogSWYgdmFsdWUgaXMgZW1wdHkgb3IgemVybywgaW1hZ2Ugd2lsbCBmYWxsYmFjayB0byBkZWZhdWx0IHNpemUuJ1xuXHRcdFx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdFx0XHQ8L3A+XG5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1yb3dcIlxuXHRcdFx0XHRcdHN0eWxlPXsgeyBtYXJnaW5Cb3R0b206ICcxMHB4JyB9IH0+XG5cdFx0XHRcdFx0PENvbCBjb2xzPVwiM1wiPlxuXHRcdFx0XHRcdFx0PElucHV0XG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnV2lkdGgnICkgfVxuXHRcdFx0XHRcdFx0XHR0eXBlPVwibnVtYmVyXCJcblx0XHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9XCIwXCJcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXsgNzAgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cImZpZWxkLWltYWdlLXdpZHRoXCJcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9Db2w+XG5cdFx0XHRcdFx0PENvbCBjb2xzPVwiM1wiPlxuXHRcdFx0XHRcdFx0PElucHV0XG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnSGVpZ2h0JyApIH1cblx0XHRcdFx0XHRcdFx0dHlwZT1cIm51bWJlclwiXG5cdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPVwiMFwiXG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17IDcwIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJmaWVsZC1pbWFnZS1oZWlnaHRcIlxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8L0NvbD5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCI+XG5cdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdTZXQgeW91ciBjdXN0b20gZGltZW5zaW9ucyBpbiBwaXhlbHMuJyApIH1cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvbGF5b3V0L2ZpZWxkLWltYWdlLXNpemUuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgRW1wdHkgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9lbXB0eSc7XG5pbXBvcnQgUGFkZGluZ0N1c3RvbSBmcm9tICcuL2NvbnRhaW5lci9wYWRkaW5nLWN1c3RvbSc7XG5pbXBvcnQgQm9yZGVyQ3VzdG9tIGZyb20gJy4vY29udGFpbmVyL2JvcmRlci1jdXN0b20nO1xuaW1wb3J0IFJhZGlvVGFicyBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvcmFkaW8tdGFicyc7XG5pbXBvcnQgU3BhY2luZ0N1c3RvbSBmcm9tICcuL2NvbnRhaW5lci9zcGFjaW5nLWN1c3RvbSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRhaW5lciBleHRlbmRzIENvbXBvbmVudCB7XG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLXJvd1wiPlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMVwiPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1zZXR0aW5ncy1sYWJlbFwiPnsgdHJhbnNsYXRlKCAnRm9ybSBDb250YWluZXInICkgfTwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCBcIkN1c3RvbWl6ZSB0aGUgZm9ybSBjb250YWluZXIncyBwYWRkaW5nIGFuZCBib3JkZXIuXCIgKSB9XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3MtY29sLTJcIj5cblxuXHRcdFx0XHRcdDxSYWRpb1RhYnNcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT1cInBvbGwtcGFkZGluZ1wiXG5cdFx0XHRcdFx0XHRzZXR0aW5nc0xhYmVsPXsgdHJhbnNsYXRlKCAnUGFkZGluZycgKSB9XG5cdFx0XHRcdFx0XHRkZXNjcmlwdGlvbj17IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0J0J5IGRlZmF1bHQgdGhlIGZvcm0gd2lsbCBmaWxsIHRoZSBhdmFpbGFibGUgJyArXG5cdFx0XHRcdFx0XHRcdCdzcGFjZSB3aGVyZSB5b3UgaW5zZXJ0IGl0LiBZb3UgY2FuIGFkZCBzb21lICcgK1xuXHRcdFx0XHRcdFx0XHQncGFkZGluZyBoZXJlIHRvIGJldHRlciBzdWl0IHlvdXIgdGhlbWUuJ1xuXHRcdFx0XHRcdFx0KSB9PlxuXHRcdFx0XHRcdFx0PEVtcHR5IHZhbHVlPVwiXCI+XG5cdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnTm9uZScgKSB9XG5cdFx0XHRcdFx0XHQ8L0VtcHR5PlxuXHRcdFx0XHRcdFx0PFBhZGRpbmdDdXN0b20geyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0dmFsdWU9XCJjdXN0b21cIlxuXHRcdFx0XHRcdFx0XHRib3hDbGFzcz1cInN1aS10YWItYm94ZWRcIj5cblx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdDdXN0b20nICkgfVxuXHRcdFx0XHRcdFx0PC9QYWRkaW5nQ3VzdG9tPlxuXHRcdFx0XHRcdDwvUmFkaW9UYWJzPlxuXG5cdFx0XHRcdFx0PFJhZGlvVGFic1xuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PVwicG9sbC1ib3JkZXJcIlxuXHRcdFx0XHRcdFx0c2V0dGluZ3NMYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlcicgKSB9XG5cdFx0XHRcdFx0XHRkZXNjcmlwdGlvbj17IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0J0FkZCBhbiBvcHRpb25hbCBib3JkZXIgYXJvdW5kIHRoZSBmb3JtLidcblx0XHRcdFx0XHRcdCkgfT5cblx0XHRcdFx0XHRcdDxFbXB0eSB2YWx1ZT1cIlwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ05vbmUnICkgfVxuXHRcdFx0XHRcdFx0PC9FbXB0eT5cblx0XHRcdFx0XHRcdDxCb3JkZXJDdXN0b20geyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0dmFsdWU9XCJjdXN0b21cIlxuXHRcdFx0XHRcdFx0XHRib3hDbGFzcz1cInN1aS10YWItYm94ZWRcIj5cblx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdDdXN0b20nICkgfVxuXHRcdFx0XHRcdFx0PC9Cb3JkZXJDdXN0b20+XG5cdFx0XHRcdFx0PC9SYWRpb1RhYnM+XG5cblx0XHRcdFx0XHQ8UmFkaW9UYWJzXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9XCJhbnN3ZXJzLXNwYWNpbmdcIlxuXHRcdFx0XHRcdFx0c2V0dGluZ3NMYWJlbD17IHRyYW5zbGF0ZSggJ1NwYWNpbmcnICkgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdD1cIm9wZW5cIlxuXHRcdFx0XHRcdFx0ZGVzY3JpcHRpb249eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdCdDaG9vc2UgaG93IG11Y2ggc3BhY2luZyB5b3Ugd2FudCBiZXR3ZWVuIGVhY2ggcG9sbCBvcHRpb24uJ1xuXHRcdFx0XHRcdFx0KSB9PlxuXHRcdFx0XHRcdFx0PEVtcHR5IHZhbHVlPVwib3BlblwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0NvbWZvcnRhYmxlJyApIH1cblx0XHRcdFx0XHRcdDwvRW1wdHk+XG5cdFx0XHRcdFx0XHQ8RW1wdHkgdmFsdWU9XCJlbmNsb3NlZFwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0VuY2xvc2VkJyApIH1cblx0XHRcdFx0XHRcdDwvRW1wdHk+XG5cdFx0XHRcdFx0XHQ8U3BhY2luZ0N1c3RvbVxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHR2YWx1ZT1cImN1c3RvbVwiXG5cdFx0XHRcdFx0XHRcdGJveENsYXNzPVwic3VpLXRhYi1ib3hlZFwiXG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnQ3VzdG9tJyApIH1cblx0XHRcdFx0XHRcdDwvU3BhY2luZ0N1c3RvbT5cblx0XHRcdFx0XHQ8L1JhZGlvVGFicz5cblxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbnRhaW5lci5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb2wgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9jb2wnO1xuaW1wb3J0IElucHV0IGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9pbnB1dCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHBhZGRpbmdDdXN0b20gZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktcm93XCJcblx0XHRcdFx0XHRzdHlsZT17IHsgbWFyZ2luQm90dG9tOiAnMTBweCcgfSB9PlxuXHRcdFx0XHRcdDxDb2wgY29scz1cIjNcIj5cblx0XHRcdFx0XHRcdDxJbnB1dFxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RvcCcgKSB9XG5cdFx0XHRcdFx0XHRcdHR5cGU9XCJudW1iZXJcIlxuXHRcdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj1cIjBcIlxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9XCIyMFwiXG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwiZm9ybWluYXRvci1wb2xsLXBhZGRpbmctdG9wXCJcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9Db2w+XG5cdFx0XHRcdFx0PENvbCBjb2xzPVwiM1wiPlxuXHRcdFx0XHRcdFx0PElucHV0XG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQm90dG9tJyApIH1cblx0XHRcdFx0XHRcdFx0dHlwZT1cIm51bWJlclwiXG5cdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPVwiMFwiXG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT1cIjIwXCJcblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJmb3JtaW5hdG9yLXBvbGwtcGFkZGluZy1ib3R0b21cIlxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8L0NvbD5cblx0XHRcdFx0XHQ8Q29sIGNvbHM9XCIzXCI+XG5cdFx0XHRcdFx0XHQ8SW5wdXRcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdMZWZ0JyApIH1cblx0XHRcdFx0XHRcdFx0dHlwZT1cIm51bWJlclwiXG5cdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPVwiMFwiXG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT1cIjIwXCJcblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJmb3JtaW5hdG9yLXBvbGwtcGFkZGluZy1sZWZ0XCJcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9Db2w+XG5cdFx0XHRcdFx0PENvbCBjb2xzPVwiM1wiPlxuXHRcdFx0XHRcdFx0PElucHV0XG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUmlnaHQnICkgfVxuXHRcdFx0XHRcdFx0XHR0eXBlPVwibnVtYmVyXCJcblx0XHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9XCIwXCJcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPVwiMjBcIlxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cImZvcm1pbmF0b3ItcG9sbC1wYWRkaW5nLXJpZ2h0XCJcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9Db2w+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPlxuXHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnU2V0IHlvdXIgY3VzdG9tIHBhZGRpbmcgaW4gcGl4ZWxzLicgKSB9XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbnRhaW5lci9wYWRkaW5nLWN1c3RvbS5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb2wgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9jb2wnO1xuaW1wb3J0IElucHV0IGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9pbnB1dCc7XG5pbXBvcnQgU3VpU2VsZWN0MiBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvc3VpLXNlbGVjdDInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBib3JkZXJDdXN0b20gZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktcm93XCJcblx0XHRcdFx0XHRzdHlsZT17IHsgbWFyZ2luQm90dG9tOiAnMTBweCcgfSB9PlxuXHRcdFx0XHRcdDxDb2wgY29scz1cIjRcIj5cblx0XHRcdFx0XHRcdDxJbnB1dFxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1JhZGl1cycgKSB9XG5cdFx0XHRcdFx0XHRcdG5vdGU9eyB0cmFuc2xhdGUoICdpbiBweCcgKSB9XG5cdFx0XHRcdFx0XHRcdHR5cGU9XCJudW1iZXJcIlxuXHRcdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj1cIjBcIlxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cImZvcm1pbmF0b3ItcG9sbC1ib3JkZXItcmFkaXVzXCJcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9Db2w+XG5cdFx0XHRcdFx0PENvbCBjb2xzPVwiNFwiPlxuXHRcdFx0XHRcdFx0PElucHV0XG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGhpY2tuZXNzJyApIH1cblx0XHRcdFx0XHRcdFx0bm90ZT17IHRyYW5zbGF0ZSggJ2luIHB4JyApIH1cblx0XHRcdFx0XHRcdFx0dHlwZT1cIm51bWJlclwiXG5cdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPVwiMFwiXG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwiZm9ybWluYXRvci1wb2xsLWJvcmRlci13aWR0aFwiXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDwvQ29sPlxuXHRcdFx0XHRcdDxDb2wgY29scz1cIjRcIj5cblx0XHRcdFx0XHRcdDxTdWlTZWxlY3QyXG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwiZm9ybWluYXRvci1wb2xsLWJvcmRlci1zdHlsZVwiXG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnU3R5bGUnICkgfSB7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9XCJub25lXCJcblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cInNvbGlkXCI+XG5cdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdTb2xpZCcgKSB9XG5cdFx0XHRcdFx0XHRcdDwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiZGFzaGVkXCI+XG5cdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdEYXNoZWQnICkgfVxuXHRcdFx0XHRcdFx0XHQ8L29wdGlvbj5cblx0XHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cImRvdHRlZFwiPlxuXHRcdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnRG90dGVkJyApIH1cblx0XHRcdFx0XHRcdFx0PC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJub25lXCI+XG5cdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdOb25lJyApIH1cblx0XHRcdFx0XHRcdFx0PC9vcHRpb24+XG5cdFx0XHRcdFx0XHQ8L1N1aVNlbGVjdDI+XG5cdFx0XHRcdFx0PC9Db2w+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHQnTm90ZTogU2V0IHRoZSBjb2xvciBvZiB0aGUgYm9yZGVyIGluIHRoZSBDb2xvcnMgc2V0dGluZ3MgYXJlYSBhYm92ZS4nXG5cdFx0XHRcdCkgfTwvc3Bhbj5cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbnRhaW5lci9ib3JkZXItY3VzdG9tLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IElucHV0IGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9pbnB1dCc7XG5cbmltcG9ydCB7IHRyYW5zbGF0ZSwgZ2V0VGhlbWVQcmVmaXggfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHNwYWNpbmdDdXN0b20gZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxJbnB1dFxuXHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1NwYWNpbmcnICkgfVxuXHRcdFx0XHRub3RlPXsgdHJhbnNsYXRlKCAnaW4gcGl4ZWxzJyApIH1cblx0XHRcdFx0dHlwZT1cIm51bWJlclwiXG5cdFx0XHRcdHBsYWNlaG9sZGVyPXsgdHJhbnNsYXRlKCAnMCcgKSB9XG5cdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXNwYWNpbmdgfVxuXHRcdFx0Lz5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29udGFpbmVyL3NwYWNpbmctY3VzdG9tLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IFRvZ2dsZSBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvdG9nZ2xlJztcbmltcG9ydCBBY2VFZGl0b3IgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2FjZS1lZGl0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21Dc3MgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1yb3dcIj5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0xXCI+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXNldHRpbmdzLWxhYmVsXCI+eyB0cmFuc2xhdGUoICdDdXN0b20gQ1NTJyApIH08L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCI+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0ZvciBtb3JlIGFkdmFuY2VkIGN1c3RvbWl6YXRpb24gb3B0aW9ucyB1c2UgY3VzdG9tIENTUy4nICkgfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0yXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktZm9ybS1maWVsZFwiPlxuXHRcdFx0XHRcdFx0PGRpdiBzdHlsZT17IHsgbWFyZ2luQm90dG9tOiAnMTBweCcgfSB9PlxuXHRcdFx0XHRcdFx0XHQ8VG9nZ2xlIHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdFbmFibGUgY3VzdG9tIENTUycgKSB9XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJ1c2UtY3VzdG9tLWNzc1wiXG5cdFx0XHRcdFx0XHRcdFx0dW5XcmFwXG5cdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdHsgISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzWyAndXNlLWN1c3RvbS1jc3MnIF0gKSAmJiB0aGlzLnByb3BzLnNldHRpbmdzWyAndXNlLWN1c3RvbS1jc3MnIF0gJiZcblx0XHRcdFx0XHRcdFx0PEFjZUVkaXRvclxuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJjdXN0b21fY3NzXCJcblx0XHRcdFx0XHRcdFx0XHR0eXBlPVwicG9sbFwiXG5cdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9hcHBlYXJhbmNlL2N1c3RvbS1jc3MuanMiLCJpbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnO1xuXG5pbXBvcnQgKiBhcyBzZXR0aW5nc0FjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucy9zZXR0aW5ncyc7XG5pbXBvcnQgKiBhcyBtb2RhbEFjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucy9tb2RhbCc7XG5cbmltcG9ydCBCZWhhdmlvdXIgZnJvbSAnLi4vY29tcG9uZW50cy9iZWhhdmlvdXInO1xuXG5mdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHMoIHN0YXRlICkge1xuXHRyZXR1cm4ge1xuXHRcdHNldHRpbmdzOiBzdGF0ZS5zZXR0aW5ncyxcblx0fTtcbn1cblxuZnVuY3Rpb24gbWFwRGlzcGF0Y2hUb1Byb3BzKCBkaXNwYXRjaCApIHtcblx0cmV0dXJuIHtcblx0XHRhY3Rpb25zOiB7XG5cdFx0XHRzZXR0aW5nc0FjdGlvbnM6IGJpbmRBY3Rpb25DcmVhdG9ycyggc2V0dGluZ3NBY3Rpb25zLCBkaXNwYXRjaCApLFxuXHRcdFx0bW9kYWxBY3Rpb25zOiBiaW5kQWN0aW9uQ3JlYXRvcnMoIG1vZGFsQWN0aW9ucywgZGlzcGF0Y2ggKSxcblx0XHR9LFxuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KFxuXHRtYXBTdGF0ZVRvUHJvcHMsXG5cdG1hcERpc3BhdGNoVG9Qcm9wc1xuKSggQmVoYXZpb3VyICk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb250YWluZXJzL2JlaGF2aW91ci5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmltcG9ydCBSZXN1bHRzRGlzcGxheSBmcm9tICcuL2JlaGF2aW91ci9yZXN1bHRzLWRpc3BsYXknO1xuaW1wb3J0IFZvdGVDb3VudCBmcm9tICcuL2JlaGF2aW91ci92b3RlLWNvdW50JztcbmltcG9ydCBTdWJNZXRob2QgZnJvbSAnLi9iZWhhdmlvdXIvc3VibWlzc2lvbi1tZXRob2QnO1xuaW1wb3J0IE9wZW5pbmcgZnJvbSAnLi9iZWhhdmlvdXIvb3BlbmluZyc7XG5pbXBvcnQgU2VjdXJpdHlCZWhhdmlvdXIgZnJvbSAnLi4vLi4vZ2xvYmFsL2NvbXBvbmVudHMvYmVoYXZpb3VyL3NlY3VyaXR5JztcbmltcG9ydCBMaW1pdHMgZnJvbSAnLi9iZWhhdmlvdXIvbGltaXRzJztcbmltcG9ydCBSZW5kZXJCZWhhdmlvdXIgZnJvbSAnLi9iZWhhdmlvdXIvcmVuZGVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmVoYXZpb3VyIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0alF1ZXJ5KCAnaHRtbCwgYm9keScgKS5hbmltYXRlKFxuXHRcdFx0e1xuXHRcdFx0XHRzY3JvbGxUb3A6IDAsXG5cdFx0XHR9LCAnZmFzdCdcblx0XHQpO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGdvVG9TZWN0aW9uID0gbW9kdWxlID0+IHtcblx0XHRcdHRoaXMucHJvcHMuaGlzdG9yeS5wdXNoKCAnLycgKyBtb2R1bGUgKTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgaWQ9XCJmb3JtaW5hdG9yLWZvcm0tYXBwZWFyYW5jZVwiIGNsYXNzTmFtZT1cInN1aS1ib3hcIj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtaGVhZGVyXCI+XG5cdFx0XHRcdFx0PGgyIGNsYXNzTmFtZT1cInN1aS1ib3gtdGl0bGVcIj57IHRyYW5zbGF0ZSggJ0JlaGF2aW9yJyApIH08L2gyPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtYm9keVwiPlxuXG5cdFx0XHRcdFx0PFJlc3VsdHNEaXNwbGF5IHsgLi4udGhpcy5wcm9wcyB9IC8+XG5cdFx0XHRcdFx0PFZvdGVDb3VudCB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdDxTdWJNZXRob2QgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHQ8T3BlbmluZyB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdDxMaW1pdHMgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHQ8U2VjdXJpdHlCZWhhdmlvdXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRtb2R1bGVTbHVnPSdwb2xsJ1xuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PFJlbmRlckJlaGF2aW91ciB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1mb290ZXJcIj5cblx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzTmFtZT1cInN1aS1idXR0b25cIiBvbkNsaWNrPXsgKCkgPT4gZ29Ub1NlY3Rpb24oICdhcHBlYXJhbmNlJyApIH0+XG5cdFx0XHRcdFx0XHQ8aSBjbGFzc05hbWU9XCJzdWktaWNvbi1hcnJvdy1sZWZ0XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cblx0XHRcdFx0XHRcdHt0cmFuc2xhdGUoICdBcHBlYXJhbmNlJyApfVxuXHRcdFx0XHRcdDwvYnV0dG9uPlxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYWN0aW9ucy1yaWdodFwiPlxuXHRcdFx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktYnV0dG9uIHN1aS1idXR0b24taWNvbi1yaWdodFwiXG5cdFx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiBnb1RvU2VjdGlvbiggJ25vdGlmaWNhdGlvbnMnICkgfVxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHR7dHJhbnNsYXRlKCAnRW1haWwgTm90aWZpY2F0aW9ucycgKX1cblx0XHRcdFx0XHRcdFx0PGkgY2xhc3NOYW1lPVwic3VpLWljb24tYXJyb3ctcmlnaHRcIiBhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuXHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9iZWhhdmlvdXIuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBFbXB0eSBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2VtcHR5JztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9jb250YWluZXInO1xuXG5pbXBvcnQgUmFkaW8gZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL3JhZGlvJztcbmltcG9ydCBSYWRpb1RhYnMgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL3JhZGlvLXRhYnMnO1xuaW1wb3J0IFJhZGlvT3B0aW9ucyBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvcmFkaW8tb3B0aW9ucyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc3VsdHNEaXNwbGF5IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGdvVG9TZWN0aW9uID0gbW9kdWxlID0+IHtcblx0XHRcdHRoaXMucHJvcHMuaGlzdG9yeS5wdXNoKCAnLycgKyBtb2R1bGUgKTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgcmVzdWx0U3R5bGUgPSAoXG5cdFx0XHQ8UmFkaW9PcHRpb25zXG5cdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdGRlZmF1bHRWYWx1ZT1cImJhclwiXG5cdFx0XHRcdHByb3BlcnR5PVwicmVzdWx0cy1zdHlsZVwiXG5cdFx0XHRcdHJhZGlvQ2xhc3M9XCJzdWktcmFkaW8tc21cIlxuXHRcdFx0PlxuXHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0dmFsdWU9XCJwaWVcIlxuXHRcdFx0XHRcdGltYWdlMXg9XCJncmFwaC1waWUucG5nXCJcblx0XHRcdFx0XHRpbWFnZTJ4PVwiZ3JhcGgtcGllQDJ4LnBuZ1wiXG5cdFx0XHRcdFx0aGFzSW1hZ2Vcblx0XHRcdFx0PnsgdHJhbnNsYXRlKCAnUGllIENoYXJ0JyApIH08L2Rpdj5cblx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdHZhbHVlPVwiYmFyXCJcblx0XHRcdFx0XHRpbWFnZTF4PVwiZ3JhcGgtYmFyLnBuZ1wiXG5cdFx0XHRcdFx0aW1hZ2UyeD1cImdyYXBoLWJhckAyeC5wbmdcIlxuXHRcdFx0XHRcdGhhc0ltYWdlXG5cdFx0XHRcdD57IHRyYW5zbGF0ZSggJ0JhciBHcmFwaCcgKSB9PC9kaXY+XG5cdFx0XHQ8L1JhZGlvT3B0aW9ucz5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1yb3dcIj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3MtY29sLTFcIj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktc2V0dGluZ3MtbGFiZWxcIj57IHRyYW5zbGF0ZSggJ1Jlc3VsdHMgRGlzcGxheScgKSB9PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPnsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0J0Nob29zZSBob3cgeW91IHdhbnQgdG8gZGlzcGxheSBwb2xsIHJlc3VsdHMgdG8gbmV3IHN1Ym1pc3Npb25zLiAnICtcblx0XHRcdFx0XHRcdCdZb3UgY2FuIGN1c3RvbWlzZSBjb2xvcnMgaW4gdGhlIHt7bGlua319QXBwZWFyYW5jZXt7L2xpbmt9fSB0YWIuJyxcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y29tcG9uZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdGxpbms6IDxhIGhyZWY9XCIjXCIgb25DbGljaz17ICgpID0+IGdvVG9TZWN0aW9uKCAnYXBwZWFyYW5jZScgKSB9IC8+LFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCkgfTwvc3Bhbj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0yXCI+XG5cblx0XHRcdFx0XHQ8UmFkaW9UYWJzXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9XCJyZXN1bHRzLWJlaGF2XCJcblx0XHRcdFx0XHRcdGRlZmF1bHQ9XCJub3Rfc2hvd1wiXG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHR2YWx1ZT1cImxpbmtfb25cIlxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0xpbmsgb24gcG9sbCcgKSB9XG5cdFx0XHRcdFx0XHRcdGJveENsYXNzPVwic3VpLXRhYi1ib3hlZFwiXG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdHsgcmVzdWx0U3R5bGUgfVxuXHRcdFx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0dmFsdWU9XCJzaG93X2FmdGVyXCJcblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdTaG93IGFmdGVyIHZvdGVkJyApIH1cblx0XHRcdFx0XHRcdFx0Ym94Q2xhc3M9XCJzdWktdGFiLWJveGVkXCJcblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0eyByZXN1bHRTdHlsZSB9XG5cdFx0XHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0XHRcdFx0PEVtcHR5XG5cdFx0XHRcdFx0XHRcdHZhbHVlPVwibm90X3Nob3dcIlxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0RvIG5vdCBzaG93JyApIH1cblx0XHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0XHQ8L1JhZGlvVGFicz5cblxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9iZWhhdmlvdXIvcmVzdWx0cy1kaXNwbGF5LmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzJztcbmltcG9ydCBSYWRpbyBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvcmFkaW8nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWb3RlQ291bnQgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1yb3dcIj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3MtY29sLTFcIj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktc2V0dGluZ3MtbGFiZWxcIj57IHRyYW5zbGF0ZSggJ1ZvdGUgQ291bnQnICkgfTwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdCdEaXNwbGF5IHRoZSBudW1iZXJzIG9mIHZvdGVzIG9uIGJhciBjaGFydCByZXN1bHRzJ1xuXHRcdFx0XHRcdCkgfTwvc3Bhbj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0yXCI+XG5cblx0XHRcdFx0XHQ8UmFkaW9cblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT1cInNob3ctdm90ZXMtY291bnRcIlxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPVwiZmFsc2VcIlxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdDxkaXYgdmFsdWU9XCJmYWxzZVwiPnsgdHJhbnNsYXRlKCAnSGlkZScgKSB9PC9kaXY+XG5cdFx0XHRcdFx0XHQ8ZGl2IHZhbHVlPVwidHJ1ZVwiPnsgdHJhbnNsYXRlKCAnU2hvdycgKSB9PC9kaXY+XG5cdFx0XHRcdFx0PC9SYWRpbz5cblxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9iZWhhdmlvdXIvdm90ZS1jb3VudC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5pbXBvcnQgUmFkaW8gZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL3JhZGlvJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ViTWV0aG9kIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3Mtcm93XCI+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0xXCI+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXNldHRpbmdzLWxhYmVsXCI+eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHQnU3VibWlzc2lvbiBNZXRob2QnXG5cdFx0XHRcdFx0KSB9PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPnsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XCJCeSBkZWZhdWx0LCBzdWJtaXNzaW9ucyBkb24ndCByZXF1aXJlIHRoZSBwYWdlIHRvIHJlbG9hZC4gXCIgK1xuXHRcdFx0XHRcdFx0J0lmIHlvdSBhcmUgaGF2aW5nIGlzc3VlcyB5b3UgbWlnaHQgd2FudCB1c2UgdGhlIHRyYWRpdGlvbmFsICcgK1xuXHRcdFx0XHRcdFx0J21ldGhvZCBvZiByZWxvYWRpbmcgdGhlIHBhZ2UuJ1xuXHRcdFx0XHRcdCkgfTwvc3Bhbj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0yXCI+XG5cblx0XHRcdFx0XHQ8UmFkaW9cblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT1cImVuYWJsZS1hamF4XCJcblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT1cIlwiXG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0PGRpdiB2YWx1ZT1cIlwiPnsgdHJhbnNsYXRlKCAnUmVsb2FkIFBhZ2UnICkgfTwvZGl2PlxuXHRcdFx0XHRcdFx0PGRpdiB2YWx1ZT1cInRydWVcIj57IHRyYW5zbGF0ZSggJ0FqYXgnICkgfTwvZGl2PlxuXHRcdFx0XHRcdDwvUmFkaW8+XG5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbXBvbmVudHMvYmVoYXZpb3VyL3N1Ym1pc3Npb24tbWV0aG9kLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgUmFkaW9UYWJzIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9yYWRpby10YWJzJztcbmltcG9ydCBFbXB0eSBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2VtcHR5JztcbmltcG9ydCBSb3cgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9yb3cnO1xuaW1wb3J0IENvbCBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbCc7XG5pbXBvcnQgSW5wdXQgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2lucHV0JztcbmltcG9ydCBEYXRlVGltZVBpY2tlciBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvZGF0ZS10aW1lLXBpY2tlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9wZW5pbmcgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1yb3dcIj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3MtY29sLTFcIj5cblxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1zZXR0aW5ncy1sYWJlbFwiPnsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0J1ZvdGUgT3BlbmluZydcblx0XHRcdFx0XHQpIH08L3NwYW4+XG5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdCdDaG9vc2Ugd2hlbiB5b3Ugd2FudCB0byBvcGVuIGFuZCBjbG9zZSB2b3RpbmcnXG5cdFx0XHRcdFx0KSB9PC9zcGFuPlxuXG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMlwiPlxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktZm9ybS1maWVsZFwiPlxuXHRcdFx0XHRcdFx0PGxhYmVsIGNsYXNzTmFtZT1cInN1aS1zZXR0aW5ncy1sYWJlbFwiPnsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHQnU3RhdHVzJ1xuXHRcdFx0XHRcdFx0KX08L2xhYmVsPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCI+eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdCdDaG9vc2UgdGhlIHN0YXR1cyBvZiB2b3RpbmcnXG5cdFx0XHRcdFx0XHQpfTwvc3Bhbj5cblxuXHRcdFx0XHRcdFx0PFJhZGlvVGFic1xuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cIm9wZW5pbmdfc3RhdHVzXCJcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdD1cIm9wZW5cIlxuXHRcdFx0XHRcdFx0XHRzaW1wbGVcblx0XHRcdFx0XHRcdD5cblxuXHRcdFx0XHRcdFx0XHQ8RW1wdHlcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZT1cIm9wZW5cIlxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnT3BlbicgKSB9XG5cdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdDxFbXB0eVxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlPVwicGF1c2VcIlxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUGF1c2UnICkgfVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHQ8RW1wdHlcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZT1cImNsb3NlXCJcblx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0Nsb3NlJyApIH1cblx0XHRcdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdFx0PC9SYWRpb1RhYnM+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktZm9ybS1maWVsZFwiPlxuXG5cdFx0XHRcdFx0XHQ8bGFiZWwgY2xhc3NOYW1lPVwic3VpLXNldHRpbmdzLWxhYmVsXCI+eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdCdPcGVuIGZyb20nXG5cdFx0XHRcdFx0XHQpfTwvbGFiZWw+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0J0Nob29zZSB3aGVuIHZvdGluZyB3aWxsIGJlIG9wZW5lZCdcblx0XHRcdFx0XHRcdCl9PC9zcGFuPlxuXG5cdFx0XHRcdFx0XHQ8UmFkaW9UYWJzXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwib3BlbmluZ19vcGVuX2Zyb21cIlxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0PVwibm93XCJcblx0XHRcdFx0XHRcdFx0c2ltcGxlXG5cdFx0XHRcdFx0XHQ+XG5cblx0XHRcdFx0XHRcdFx0PEVtcHR5XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWU9XCJub3dcIlxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnTm93JyApIH1cblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWU9XCJzcGVjaWZpY19kYXRlX3RpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnU3BlY2lmaWMgRGF0ZSBUaW1lJyApIH1cblx0XHRcdFx0XHRcdFx0XHRib3hDbGFzcz1cInN1aS10YWItYm94ZWRcIlxuXHRcdFx0XHRcdFx0XHQ+XG5cblx0XHRcdFx0XHRcdFx0XHQ8Q29sIGNvbHM9XCIxMlwiPlxuXG5cdFx0XHRcdFx0XHRcdFx0XHQ8RGF0ZVRpbWVQaWNrZXIgeyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJvcGVuaW5nX29wZW5fZnJvbV9kYXRlX3RpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0XHQ8L0NvbD5cblx0XHRcdFx0XHRcdFx0PC9Sb3c+XG5cdFx0XHRcdFx0XHQ8L1JhZGlvVGFicz5cblxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGRcIj5cblxuXHRcdFx0XHRcdFx0PGxhYmVsIGNsYXNzTmFtZT1cInN1aS1zZXR0aW5ncy1sYWJlbFwiPnsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHQnT3BlbiB1bnRpbCdcblx0XHRcdFx0XHRcdCl9PC9sYWJlbD5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPnsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHQnQ2hvb3NlIGhvdyBsb25nIHZvdGluZyB3aWxsIHJlbWFpbiBvcGVuJ1xuXHRcdFx0XHRcdFx0KX08L3NwYW4+XG5cblx0XHRcdFx0XHRcdDxSYWRpb1RhYnNcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJvcGVuaW5nX29wZW5fdW50aWxcIlxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0PVwiZm9yZXZlclwiXG5cdFx0XHRcdFx0XHRcdHNpbXBsZVxuXHRcdFx0XHRcdFx0PlxuXG5cdFx0XHRcdFx0XHRcdDxFbXB0eVxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlPVwiZm9yZXZlclwiXG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdGb3JldmVyJyApIH1cblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWU9XCJzcGVjaWZpY19kYXRlX3RpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnU3BlY2lmaWMgRGF0ZSBUaW1lJyApIH1cblx0XHRcdFx0XHRcdFx0XHRib3hDbGFzcz1cInN1aS10YWItYm94ZWRcIlxuXHRcdFx0XHRcdFx0XHQ+XG5cblx0XHRcdFx0XHRcdFx0XHQ8Q29sIGNvbHM9XCIxMlwiPlxuXG5cdFx0XHRcdFx0XHRcdFx0XHQ8RGF0ZVRpbWVQaWNrZXIgeyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJvcGVuaW5nX29wZW5fdW50aWxfZGF0ZV90aW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdFx0PC9Db2w+XG5cdFx0XHRcdFx0XHRcdDwvUm93PlxuXHRcdFx0XHRcdFx0PC9SYWRpb1RhYnM+XG5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1mb3JtLWZpZWxkXCI+XG5cblx0XHRcdFx0XHRcdDxsYWJlbCBjbGFzc05hbWU9XCJzdWktc2V0dGluZ3MtbGFiZWxcIj57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0J0N1c3RvbSBtZXNzYWdlcydcblx0XHRcdFx0XHRcdCl9PC9sYWJlbD5cblxuXHRcdFx0XHRcdFx0PElucHV0XG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnTWVzc2FnZSB3aGVuIHZvdGluZyBpcyBjbG9zZWQnICkgfVxuXHRcdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwib3BlbmluZ19jbG9zZV9tc2dcIlxuXHRcdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj17IHRyYW5zbGF0ZSggJ0UuZy4gVm90aW5nIGlzIGNsb3NlZCcgKSB9XG5cdFx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0XHQ8SW5wdXRcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdNZXNzYWdlIHdoZW4gdm90aW5nIGlzIHBhdXNlZCcgKSB9XG5cdFx0XHRcdFx0XHRcdHR5cGU9XCJ0ZXh0XCJcblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJvcGVuaW5nX3BhdXNlX21zZ1wiXG5cdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPXsgdHJhbnNsYXRlKCAnRS5nLiBWb3RpbmcgaXMgcGF1c2VkLCBjaGVjayBhZ2FpbiBsYXRlcicgKSB9XG5cdFx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0XHQ8SW5wdXRcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdNZXNzYWdlIGJlZm9yZSB2b3Rpbmcgb3BlbiBmcm9tIHRpbWUnICkgfVxuXHRcdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwib3BlbmluZ19iZWZvcmVfb3Blbl9mcm9tX21zZ1wiXG5cdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPXsgdHJhbnNsYXRlKCAnRS5nLiBWb3RpbmcgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgeWV0JyApIH1cblx0XHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9iZWhhdmlvdXIvb3BlbmluZy5qcyIsIi8qIGVzbGludC1kaXNhYmxlIGRvdC1ub3RhdGlvbiAqL1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgRGF0ZVBpY2tlciBmcm9tICcuL2RhdGUtcGlja2VyJztcbmltcG9ydCBTdWlTZWxlY3QyIGZyb20gJy4vc3VpLXNlbGVjdDInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRlVGltZVBpY2tlciBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblxuXHRcdHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLnVwZGF0ZURhdGVWYWx1ZSA9IHRoaXMudXBkYXRlRGF0ZVZhbHVlLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLnVwZGF0ZUhvdXJWYWx1ZSA9IHRoaXMudXBkYXRlSG91clZhbHVlLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLnVwZGF0ZU1pbnV0ZVZhbHVlID0gdGhpcy51cGRhdGVNaW51dGVWYWx1ZS5iaW5kKCB0aGlzICk7XG5cdFx0dGhpcy51cGRhdGVBbVBtVmFsdWUgPSB0aGlzLnVwZGF0ZUFtUG1WYWx1ZS5iaW5kKCB0aGlzICk7XG5cblx0XHR0aGlzLmRhdGEgPSB7fTtcblx0XHR0aGlzLnZhbHVlID0gJyc7XG5cdFx0dGhpcy50aW1lVHlwZSA9ICd0d2VsdmUnOyAvL29yIHR3ZW50eWZvdXJcblx0XHR0aGlzLmRhdGVGb3JtYXQgPSAnZCBNTSB5eSc7XG5cblx0XHR0aGlzLmluaXQoKTtcblx0fVxuXG5cdGluaXQoKSB7XG5cdFx0dGhpcy52YWx1ZSA9IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXSApXG5cdFx0XHQ/IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlXG5cdFx0XHQ6IHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXTtcblxuXHRcdGlmIChcblx0XHRcdCEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wc1sgJ3RpbWVUeXBlJyBdICkgJiZcblx0XHRcdCggdGhpcy5wcm9wc1sgJ3RpbWVUeXBlJyBdID09PSAndHdlbHZlJyB8fCB0aGlzLnByb3BzWyAndGltZVR5cGUnIF0gPT09ICd0d2VudHlmb3VyJyApXG5cdFx0KSB7XG5cdFx0XHR0aGlzLnRpbWVUeXBlID0gdGhpcy5wcm9wc1sgJ3RpbWVUeXBlJyBdO1xuXHRcdH1cblxuXHRcdGlmICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzWyAnZGF0ZUZvcm1hdCcgXSApICkge1xuXHRcdFx0dGhpcy5kYXRlRm9ybWF0ID0gdGhpcy5wcm9wc1sgJ2RhdGVGb3JtYXQnIF07XG5cdFx0fVxuXG5cdFx0Y29uc3QgbW9udGhOYW1lcyA9IFtcblx0XHRcdCdKYW51YXJ5Jyxcblx0XHRcdCdGZWJydWFyeScsXG5cdFx0XHQnTWFyY2gnLFxuXHRcdFx0J0FwcmlsJyxcblx0XHRcdCdNYXknLFxuXHRcdFx0J0p1bmUnLFxuXHRcdFx0J0p1bHknLFxuXHRcdFx0J0F1Z3VzdCcsXG5cdFx0XHQnU2VwdGVtYmVyJyxcblx0XHRcdCdPY3RvYmVyJyxcblx0XHRcdCdOb3ZlbWJlcicsXG5cdFx0XHQnRGVjZW1iZXInLFxuXHRcdF07XG5cblx0XHRsZXQgZCA9IG5ldyBEYXRlKCB0aGlzLnZhbHVlICk7XG5cblx0XHRpZiAoIGQgaW5zdGFuY2VvZiBEYXRlICYmICEgaXNOYU4oIGQgKSApIHtcblx0XHRcdGNvbnN0IGggPSBkLmdldEhvdXJzKCk7XG5cblx0XHRcdHRoaXMuc2V0RGF0YShcblx0XHRcdFx0J2RhdGUnLCBkLmdldERhdGUoKSArICcgJyArIG1vbnRoTmFtZXNbIGQuZ2V0TW9udGgoKSBdICsgJyAnICsgZC5nZXRGdWxsWWVhcigpXG5cdFx0XHQpO1xuXHRcdFx0dGhpcy5zZXREYXRhKCAnaG91cicsIHRoaXMubGVhZGluZ1plcm8oIGggKSApO1xuXHRcdFx0dGhpcy5zZXREYXRhKCAnbWludXRlJywgdGhpcy5sZWFkaW5nWmVybyggZC5nZXRNaW51dGVzKCkgKSApO1xuXG5cdFx0XHRpZiAoIHRoaXMudGltZVR5cGUgPT09ICd0d2VsdmUnICkge1xuXHRcdFx0XHRjb25zdCBhbXBtID0gKCBoID49IDEyICkgPyAncG0nIDogJ2FtJztcblx0XHRcdFx0aWYgKCBoID09PSAwICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0RGF0YSggJ2hvdXInLCAxMiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc2V0RGF0YSggJ2FtcG0nLCBhbXBtICk7XG5cdFx0XHRcdGlmICggYW1wbSA9PT0gJ3BtJyAmJiBoID4gMTIgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXREYXRhKCAnaG91cicsIHRoaXMubGVhZGluZ1plcm8oIGggLSAxMiApICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZCA9IG5ldyBEYXRlKCk7XG5cblx0XHRcdHRoaXMuc2V0RGF0YShcblx0XHRcdFx0J2RhdGUnLCBkLmdldERhdGUoKSArICcgJyArIG1vbnRoTmFtZXNbIGQuZ2V0TW9udGgoKSBdICsgJyAnICsgZC5nZXRGdWxsWWVhcigpXG5cdFx0XHQpO1xuXHRcdFx0dGhpcy5zZXREYXRhKCAnaG91cicsICcwMCcgKTtcblx0XHRcdHRoaXMuc2V0RGF0YSggJ21pbnV0ZScsICcwMCcgKTtcblx0XHRcdHRoaXMuc2V0RGF0YSggJ2FtcG0nLCAnJyApO1xuXG5cdFx0XHRpZiAoIHRoaXMudGltZVR5cGUgPT09ICd0d2VsdmUnICkge1xuXHRcdFx0XHR0aGlzLnNldERhdGEoICdhbXBtJywgJ2FtJyApO1xuXHRcdFx0XHR0aGlzLnNldERhdGEoICdob3VyJywgJzEyJyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHVwZGF0ZVZhbHVlKCB2YWx1ZSApIHtcblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBvbiBmaWVsZCBzZXR0aW5nc1xuXHRcdGlmICggdHlwZW9mIHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHQvLyBVcGRhdGUgZmllbGQgc3RhdGVcblx0XHRcdHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkoIHRoaXMucHJvcHMucHJvcGVydHksIHZhbHVlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFVwZGF0ZSBzdG9yZVxuXHRcdFx0dGhpcy5wcm9wcy5hY3Rpb25zLnNldHRpbmdzQWN0aW9ucy51cGRhdGVTZXR0aW5nKCB0aGlzLnByb3BzLnByb3BlcnR5LCB2YWx1ZSApO1xuXHRcdH1cblx0fVxuXG5cdHNldERhdGEoIHByb3BlcnR5LCB2YWx1ZSApIHtcblx0XHRjb25zdCBrZXkgPSB0aGlzLnByb3BzLnByb3BlcnR5ICsgJ18nICsgcHJvcGVydHk7XG5cdFx0dGhpcy5kYXRhWyBrZXkgXSA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0RGF0YSggcHJvcGVydHkgKSB7XG5cdFx0Y29uc3Qga2V5ID0gdGhpcy5wcm9wcy5wcm9wZXJ0eSArICdfJyArIHByb3BlcnR5O1xuXHRcdHJldHVybiAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5kYXRhWyBrZXkgXSApICkgPyB0aGlzLmRhdGFbIGtleSBdIDogJyc7XG5cdH1cblxuXHR1cGRhdGVEYXRhKCBwcm9wZXJ0eSwgdmFsdWUgKSB7XG5cdFx0dGhpcy5zZXREYXRhKCBwcm9wZXJ0eSwgdmFsdWUgKTtcblxuXHRcdC8vIE1ha2UgZnVsbCBkYXRlIHRpbWUgdmFsdWVcblx0XHRsZXQgZnVsbFZhbHVlID1cblx0XHRcdHRoaXMuZ2V0RGF0YSggJ2RhdGUnICkgKyAnICcgKyB0aGlzLmdldERhdGEoICdob3VyJyApICsgJzonICsgdGhpcy5nZXREYXRhKCAnbWludXRlJyApO1xuXG5cdFx0aWYgKCB0aGlzLnRpbWVUeXBlID09PSAndHdlbHZlJyApIHtcblx0XHRcdGZ1bGxWYWx1ZSArPSAnICcgKyB0aGlzLmdldERhdGEoICdhbXBtJyApO1xuXHRcdH1cblxuXHRcdHRoaXMudXBkYXRlVmFsdWUoIGZ1bGxWYWx1ZSApO1xuXHR9XG5cblx0dXBkYXRlRGF0ZVZhbHVlKCBwcm9wZXJ0eSwgdmFsdWUgKSB7XG5cdFx0dGhpcy51cGRhdGVEYXRhKCAnZGF0ZScsIHZhbHVlICk7XG5cdH1cblxuXHR1cGRhdGVIb3VyVmFsdWUoIHByb3BlcnR5LCB2YWx1ZSApIHtcblx0XHR0aGlzLnVwZGF0ZURhdGEoICdob3VyJywgdmFsdWUgKTtcblx0fVxuXG5cdHVwZGF0ZU1pbnV0ZVZhbHVlKCBwcm9wZXJ0eSwgdmFsdWUgKSB7XG5cdFx0dGhpcy51cGRhdGVEYXRhKCAnbWludXRlJywgdmFsdWUgKTtcblx0fVxuXG5cdHVwZGF0ZUFtUG1WYWx1ZSggcHJvcGVydHksIHZhbHVlICkge1xuXHRcdHRoaXMudXBkYXRlRGF0YSggJ2FtcG0nLCB2YWx1ZSApO1xuXHR9XG5cblx0bGVhZGluZ1plcm8oIG51bSApIHtcblx0XHRjb25zdCBzID0gbnVtICsgJyc7XG5cdFx0cmV0dXJuICggcy5sZW5ndGggPCAyICkgPyAnMCcgKyBzIDogcztcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBob3Vyc01heCA9IHRoaXMudGltZVR5cGUgPT09ICd0d2VsdmUnID8gMTIgOiAyNDtcblx0XHRjb25zdCBob3VyRml4ID0gaG91cnNNYXggPT09IDEyID8gMSA6IDA7XG5cdFx0Y29uc3QgcHJlZmlleCA9IHRoaXMucHJvcHMucHJvcGVydHk7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1mb3JtLWZpZWxkLWlubGluZSBmb3JtaW5hdG9yLWZpZWxkcy1saW5lLTJ4XCI+XG5cdFx0XHRcdFx0PERhdGVQaWNrZXIgeyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsID0geyB0cmFuc2xhdGUoICdEYXRlJyApIH1cblx0XHRcdFx0XHRcdHNldHRpbmdzPXsgdGhpcy5kYXRhIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXsgcHJlZmlleCArICdfZGF0ZScgfVxuXHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9eyB0cmFuc2xhdGUoICcxMCBKYW51YXJ5IDIwMjAnICkgfVxuXHRcdFx0XHRcdFx0dXBkYXRlUHJvcGVydHk9eyB0aGlzLnVwZGF0ZURhdGVWYWx1ZSB9XG5cdFx0XHRcdFx0XHRkYXRlRm9ybWF0PXsgdGhpcy5kYXRlRm9ybWF0IH1cblx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGQtaW5saW5lIGZvcm1pbmF0b3ItZmllbGRzLWxpbmUtMnhcIj5cblx0XHRcdFx0XHQ8U3VpU2VsZWN0MiB7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0c2V0dGluZ3M9eyB0aGlzLmRhdGEgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdIb3VyJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXsgcHJlZmlleCArICdfaG91cicgfVxuXHRcdFx0XHRcdFx0dXBkYXRlUHJvcGVydHk9eyB0aGlzLnVwZGF0ZUhvdXJWYWx1ZSB9XG5cdFx0XHRcdFx0XHRkYXRhLXdpZHRoPVwiODZcIlxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgWyAuLi5BcnJheSggaG91cnNNYXggKSBdLm1hcCggKCB4LCBpICkgPT5cblx0XHRcdFx0XHRcdFx0PG9wdGlvblxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlPXsgdGhpcy5sZWFkaW5nWmVybyggaSArIGhvdXJGaXggKSB9XG5cdFx0XHRcdFx0XHRcdFx0a2V5PXsgdGhpcy5sZWFkaW5nWmVybyggaSArIGhvdXJGaXggKSB9XG5cdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHR7IHRoaXMubGVhZGluZ1plcm8oIGkgKyBob3VyRml4ICkgfVxuXHRcdFx0XHRcdFx0XHQ8L29wdGlvbj5cblx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdDwvU3VpU2VsZWN0Mj5cblxuXHRcdFx0XHRcdDxTdWlTZWxlY3QyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0c2V0dGluZ3M9eyB0aGlzLmRhdGEgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdNaW51dGUnICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9eyBwcmVmaWV4ICsgJ19taW51dGUnIH1cblx0XHRcdFx0XHRcdHVwZGF0ZVByb3BlcnR5PXsgdGhpcy51cGRhdGVNaW51dGVWYWx1ZSB9XG5cdFx0XHRcdFx0XHRkYXRhLXdpZHRoPVwiODZcIlxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgWyAuLi5BcnJheSggNjAgKSBdLm1hcCggKCB4LCBpICkgPT5cblx0XHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT17IHRoaXMubGVhZGluZ1plcm8oIGkgKSB9IGtleT17IHRoaXMubGVhZGluZ1plcm8oIGkgKSB9PlxuXHRcdFx0XHRcdFx0XHRcdHsgdGhpcy5sZWFkaW5nWmVybyggaSApIH1cblx0XHRcdFx0XHRcdFx0PC9vcHRpb24+XG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQ8L1N1aVNlbGVjdDI+XG5cblx0XHRcdFx0XHR7dGhpcy50aW1lVHlwZSA9PT0gJ3R3ZWx2ZScgJiYgKFxuXHRcdFx0XHRcdFx0PFN1aVNlbGVjdDJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0c2V0dGluZ3M9eyB0aGlzLmRhdGEgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0FNL1BNJyApIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9eyBwcmVmaWV4ICsgJ19hbXBtJyB9XG5cdFx0XHRcdFx0XHRcdHVwZGF0ZVByb3BlcnR5PXsgdGhpcy51cGRhdGVBbVBtVmFsdWUgfVxuXHRcdFx0XHRcdFx0XHRkYXRhLXdpZHRoPVwiODZcIlxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiYW1cIiBrZXk9XCJhbVwiPkFNPC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJwbVwiIGtleT1cInBtXCI+UE08L29wdGlvbj5cblx0XHRcdFx0XHRcdDwvU3VpU2VsZWN0Mj5cblx0XHRcdFx0XHQpfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzL2lucHV0cy9kYXRlLXRpbWUtcGlja2VyLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgUmFkaW9UYWJzIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9yYWRpby10YWJzJztcbmltcG9ydCBFbXB0eSBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2VtcHR5JztcbmltcG9ydCBSb3cgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9yb3cnO1xuaW1wb3J0IENvbCBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbCc7XG5pbXBvcnQgSW5wdXQgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2lucHV0JztcbmltcG9ydCBTdWlTZWxlY3QgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL3N1aS1zZWxlY3QnO1xuaW1wb3J0IFJhZGlvIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9yYWRpbyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbWl0cyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLXJvd1wiPlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMVwiPlxuXG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXNldHRpbmdzLWxhYmVsXCI+eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHQnVm90aW5nIExpbWl0J1xuXHRcdFx0XHRcdCkgfTwvc3Bhbj5cblxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPnsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0J0Nob29zZSB3aGV0aGVyIHlvdSB3YW50IHRvIGxpbWl0IHRoZSBudW1iZXIgb2Ygdm90ZXMgJyArXG5cdFx0XHRcdFx0XHQncGVyIHVzZXJzIGFuZCBob3cgZG8geW91IHdhbnQgdG8gaW1wb3NlIHRoYXQgbGltaXQuICdcblx0XHRcdFx0XHQpIH08L3NwYW4+XG5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0yXCI+XG5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1mb3JtLWZpZWxkXCI+XG5cblx0XHRcdFx0XHRcdDxsYWJlbCBjbGFzc05hbWU9XCJzdWktc2V0dGluZ3MtbGFiZWxcIj57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0J1ZvdGVzIHBlciB1c2VyJ1xuXHRcdFx0XHRcdFx0KSB9PC9sYWJlbD5cblxuXHRcdFx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCJcblx0XHRcdFx0XHRcdFx0c3R5bGU9eyB7IG1hcmdpbkJvdHRvbTogJzIwcHgnIH0gfVxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0XHQnQnkgZGVmYXVsdCwgYSB1c2VyIGNhbiBvbmx5IHZvdGUgb25jZSBvbiBhIHBvbGwuIEhvd2V2ZXIsICcgK1xuXHRcdFx0XHRcdFx0XHRcdCd5b3UgY2FuIGFsbG93IHRoZSB1c2VycyB0byB2b3RlIG11bHRpcGxlIHRpbWVzIGFuZCBhbHNvICcgK1xuXHRcdFx0XHRcdFx0XHRcdCdzcGVjaWZ5IHRoZSB0aW1lIGFmdGVyIHdoaWNoIGEgdXNlciBjYW4gdm90ZSBhZ2Fpbi4nXG5cdFx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXG5cdFx0XHRcdFx0XHQ8UmFkaW9UYWJzXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwiZW5hYmxlLXZvdGVzLWxpbWl0XCJcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdD1cImZhbHNlXCJcblx0XHRcdFx0XHRcdFx0c2ltcGxlXG5cdFx0XHRcdFx0XHQ+XG5cblx0XHRcdFx0XHRcdFx0PEVtcHR5XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWU9XCJmYWxzZVwiXG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdPbmNlJyApIH1cblx0XHRcdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdFx0XHQ8Um93XG5cdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHR2YWx1ZT1cInRydWVcIlxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQWxsb3cgTXVsdGlwbGUnICkgfVxuXHRcdFx0XHRcdFx0XHRcdGJveENsYXNzPVwic3VpLXRhYi1ib3hlZFwiXG5cdFx0XHRcdFx0XHRcdD5cblxuXHRcdFx0XHRcdFx0XHRcdDxDb2wgY29scz1cIjZcIj5cblx0XHRcdFx0XHRcdFx0XHRcdDxJbnB1dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlPVwibnVtYmVyXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJ2b3RlX2xpbWl0X2lucHV0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9XCIxMFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1pblZhbHVlPVwiMFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlzUG9zaXRpdmVcblx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdFx0PC9Db2w+XG5cblx0XHRcdFx0XHRcdFx0XHQ8Q29sIGNvbHM9XCI2XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8U3VpU2VsZWN0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwidm90ZV9saW1pdF9vcHRpb25zXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPVwibVwiXG5cdFx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJtXCI+eyB0cmFuc2xhdGUoICdtaW51dGUocyknICkgfTwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiaFwiPnsgdHJhbnNsYXRlKCAnaG91cihzKScgKSB9PC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJkXCI+eyB0cmFuc2xhdGUoICdkYXkocyknICkgfTwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiV1wiPnsgdHJhbnNsYXRlKCAnd2VlayhzKScgKSB9PC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJNXCI+eyB0cmFuc2xhdGUoICdtb250aChzKScgKSB9PC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJZXCI+eyB0cmFuc2xhdGUoICd5ZWFyKHMpJyApIH08L29wdGlvbj5cblx0XHRcdFx0XHRcdFx0XHRcdDwvU3VpU2VsZWN0PlxuXHRcdFx0XHRcdFx0XHRcdDwvQ29sPlxuXG5cdFx0XHRcdFx0XHRcdDwvUm93PlxuXG5cdFx0XHRcdFx0XHQ8L1JhZGlvVGFicz5cblxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktZm9ybS1maWVsZFwiPlxuXHRcdFx0XHRcdFx0PGxhYmVsIGNsYXNzTmFtZT1cInN1aS1zZXR0aW5ncy1sYWJlbFwiPnsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHQnTWV0aG9kJ1xuXHRcdFx0XHRcdFx0KX08L2xhYmVsPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCI+eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdCdDaG9vc2UgdGhlIG1ldGhvZCB5b3Ugd2FudCB0byB1c2UgdG8gbGltaXQgdGhlIG51bWJlciBvZiB2b3Rlcy4nXG5cdFx0XHRcdFx0XHQpfTwvc3Bhbj5cblx0XHRcdFx0XHRcdDxSYWRpb1xuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cImVuYWJsZS12b3Rlcy1tZXRob2RcIlxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9XCJ1c2VyX2lwXCJcblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0PGRpdiB2YWx1ZT1cInVzZXJfaXBcIj57IHRyYW5zbGF0ZSggJ1VzZXIgSVAnICkgfTwvZGl2PlxuXHRcdFx0XHRcdFx0XHQ8ZGl2IHZhbHVlPVwiYnJvd3Nlcl9jb29raWVcIj57IHRyYW5zbGF0ZSggJ0Jyb3dzZXIgQ29va2llJyApIH08L2Rpdj5cblx0XHRcdFx0XHRcdDwvUmFkaW8+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcG9sbC9jb21wb25lbnRzL2JlaGF2aW91ci9saW1pdHMuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgVG9nZ2xlIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy90b2dnbGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJCZWhhdmlvdXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1yb3dcIj5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0xXCI+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXNldHRpbmdzLWxhYmVsXCI+e3RyYW5zbGF0ZSggJ1JlbmRlcmluZycgKX08L3NwYW4+XG5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj5cblx0XHRcdFx0XHRcdHt0cmFuc2xhdGUoICdDaG9vc2UgaG93IHlvdSB3YW50IHlvdXIgcG9sbCB0byBiZSByZW5kZXJlZCBmb3IgdXNlcnMuJyApfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0yXCI+XG5cdFx0XHRcdFx0PFRvZ2dsZVxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PVwidXNlX2FqYXhfbG9hZFwiXG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0xvYWQgcG9sbCB1c2luZyBBSkFYJyApIH1cblx0XHRcdFx0XHRcdGRlc2NyaXB0aW9uPXsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHQnRW5hYmxpbmcgdGhpcyBmZWF0dXJlIHdpbGwgbG9hZCB0aGUgcG9sbCB2aWEgQUpBWCBhZnRlciB0aGUgcGFnZSAnICtcblx0XHRcdFx0XHRcdFx0XHQnaGFzIGxvYWRlZCB1cCwgZWZmZWN0aXZlbHkgc3BlZWRpbmcgdXAgeW91ciBwYWdlIGxvYWQgdGltZS4gJyArXG5cdFx0XHRcdFx0XHRcdFx0J1RoaXMgbWV0aG9kIGNhbiBhbHNvIChpbiBtb3N0IGNhc2VzKSBhdm9pZCBwYWdlIGNhY2hpbmcgaXNzdWVzICcgK1xuXHRcdFx0XHRcdFx0XHRcdCd3aXRoIHlvdXIgcG9sbC4nXG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0PFRvZ2dsZVxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PVwidXNlX2Rvbm90Y2FjaGVwYWdlXCJcblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUHJldmVudCBwYWdlIGNhY2hpbmcgb24gcG9sbCBwYWdlcycgKSB9XG5cdFx0XHRcdFx0XHRkZXNjcmlwdGlvbj17IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0J1BhZ2UgY2FjaGluZyBwbHVnaW5zIHNlcnZlIGEgc3RhdGljIEhUTUwgdmVyc2lvbiBvZiB0aGUgcGFnZSB3aGljaCAnICtcblx0XHRcdFx0XHRcdFx0XHRcImNhbiBjYXVzZSBpc3N1ZXMgdG8geW91ciBkeW5hbWljIHBvbGxzLiBCeSBlbmFibGluZyB0aGlzLCB3ZSdsbCBcIiArXG5cdFx0XHRcdFx0XHRcdFx0J3VzZSB7e3N0cm9uZ319RE9OT1RDQUNIRVBBR0V7ey9zdHJvbmd9fSBjb25zdGFudCB0byBwcmV2ZW50ICcgK1xuXHRcdFx0XHRcdFx0XHRcdCdwYWdlcyB3aXRoIHRoaXMgcG9sbCBvbiBpdCBmcm9tIGJlaW5nIGNhY2hlZC4nLFxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcG9uZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3Ryb25nOiA8c3Ryb25nIC8+LFxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9iZWhhdmlvdXIvcmVuZGVyLmpzIiwiaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcblxuaW1wb3J0ICogYXMgc2V0dGluZ3NBY3Rpb25zIGZyb20gJy4uL2FjdGlvbnMvc2V0dGluZ3MnO1xuaW1wb3J0ICogYXMgbW9kYWxBY3Rpb25zIGZyb20gJy4uL2FjdGlvbnMvbW9kYWwnO1xuXG5pbXBvcnQgTm90aWZpY2F0aW9ucyBmcm9tICcuLi9jb21wb25lbnRzL25vdGlmaWNhdGlvbnMnO1xuXG5mdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHMoIHN0YXRlICkge1xuXHRyZXR1cm4ge1xuXHRcdHNldHRpbmdzOiBzdGF0ZS5zZXR0aW5ncyxcblx0fTtcbn1cblxuZnVuY3Rpb24gbWFwRGlzcGF0Y2hUb1Byb3BzKCBkaXNwYXRjaCApIHtcblx0cmV0dXJuIHtcblx0XHRhY3Rpb25zOiB7XG5cdFx0XHRzZXR0aW5nc0FjdGlvbnM6IGJpbmRBY3Rpb25DcmVhdG9ycyggc2V0dGluZ3NBY3Rpb25zLCBkaXNwYXRjaCApLFxuXHRcdFx0bW9kYWxBY3Rpb25zOiBiaW5kQWN0aW9uQ3JlYXRvcnMoIG1vZGFsQWN0aW9ucywgZGlzcGF0Y2ggKSxcblx0XHR9LFxuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KFxuXHRtYXBTdGF0ZVRvUHJvcHMsXG5cdG1hcERpc3BhdGNoVG9Qcm9wc1xuKSggTm90aWZpY2F0aW9ucyApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29udGFpbmVycy9ub3RpZmljYXRpb25zLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCBBZG1pbkVtYWlsIGZyb20gJy4vbm90aWZpY2F0aW9ucy9hZG1pbi1lbWFpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vdGlmaWNhdGlvbnMgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHRqUXVlcnkoICdodG1sLCBib2R5JyApLmFuaW1hdGUoXG5cdFx0XHR7XG5cdFx0XHRcdHNjcm9sbFRvcDogMCxcblx0XHRcdH0sICdmYXN0J1xuXHRcdCk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgZ29Ub1NlY3Rpb24gPSBtb2R1bGUgPT4ge1xuXHRcdFx0dGhpcy5wcm9wcy5oaXN0b3J5LnB1c2goICcvJyArIG1vZHVsZSApO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBpZD1cImZvcm1pbmF0b3ItZm9ybS1ub3RpZmljYXRpb25zXCIgY2xhc3NOYW1lPVwic3VpLWJveFwiPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtaGVhZGVyXCI+XG5cdFx0XHRcdFx0PGgyIGNsYXNzTmFtZT1cInN1aS1ib3gtdGl0bGVcIj57dHJhbnNsYXRlKCAnRW1haWwgTm90aWZpY2F0aW9ucycgKX08L2gyPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtYm9keVwiPlxuXHRcdFx0XHRcdDxBZG1pbkVtYWlsIHsgLi4udGhpcy5wcm9wcyB9IC8+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1mb290ZXJcIj5cblx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzTmFtZT1cInN1aS1idXR0b25cIiBvbkNsaWNrPXsgKCkgPT4gZ29Ub1NlY3Rpb24oICdiZWhhdmlvdXInICkgfT5cblx0XHRcdFx0XHRcdDxpIGNsYXNzTmFtZT1cInN1aS1pY29uLWFycm93LWxlZnRcIiBhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuXHRcdFx0XHRcdFx0e3RyYW5zbGF0ZSggJ0JlaGF2aW9yJyApfVxuXHRcdFx0XHRcdDwvYnV0dG9uPlxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYWN0aW9ucy1yaWdodFwiPlxuXHRcdFx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktYnV0dG9uIHN1aS1idXR0b24taWNvbi1yaWdodFwiXG5cdFx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiBnb1RvU2VjdGlvbiggJ2ludGVncmF0aW9ucycgKSB9XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdHt0cmFuc2xhdGUoICdJbnRlZ3JhdGlvbnMnICl9XG5cdFx0XHRcdFx0XHRcdDxpIGNsYXNzTmFtZT1cInN1aS1pY29uLWFycm93LXJpZ2h0XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cblx0XHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbXBvbmVudHMvbm90aWZpY2F0aW9ucy5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGlzRW1haWxXcCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IGVzY2FwZUhUTUwgfSBmcm9tICdAd29yZHByZXNzL2VzY2FwZS1odG1sJztcblxuaW1wb3J0IElucHV0IGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9pbnB1dCc7XG5pbXBvcnQgVG9nZ2xlIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy90b2dnbGUnO1xuaW1wb3J0IFN1aVRhZ3MgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL3N1aS10YWdzJztcbmltcG9ydCBXcEVkaXRvciBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvd3AtZWRpdG9yJztcbmltcG9ydCBTdWlWYXJpYWJsZXMgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL3N1aS12YXJpYWJsZXMnO1xuaW1wb3J0IFN1aVNlbGVjdDIgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL3N1aS1zZWxlY3QyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWRtaW5FbWFpbCBleHRlbmRzIENvbXBvbmVudCB7XG5cdGdldE5hbWVPcHRpb25zKCkge1xuXHRcdGNvbnN0IG5hbWVPcHRpb25zID0gW107XG5cdFx0Xy5tYXAoIGZvcm1pbmF0b3JEYXRhLnZhcmlhYmxlcywgKCBsYWJlbCwga2V5ICkgPT4ge1xuXHRcdFx0bmFtZU9wdGlvbnMucHVzaCgge1xuXHRcdFx0XHRsYWJlbDogbGFiZWwsXG5cdFx0XHRcdHZhbHVlOiAneycgKyBrZXkgKyAnfScsXG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIG5hbWVPcHRpb25zO1xuXHR9XG5cdGdldEVtYWlsT3B0aW9ucygpIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0Z2V0UmVjaXBpZW50VGFnc09wdGlvbnMoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRhZ3M6IHRydWUsXG5cdFx0XHR0b2tlblNlcGFyYXRvcnM6IFsgJywnLCAnICcgXSxcblx0XHRcdGxhbmd1YWdlOiB7XG5cdFx0XHRcdHNlYXJjaGluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ1NlYXJjaGluZycgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0bm9SZXN1bHRzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnTm8gUmVzdWx0IEZvdW5kJyApO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSxcblx0XHRcdHBsYWNlaG9sZGVyOiB0cmFuc2xhdGUoICdSZWNpcGllbnQocyknICksXG5cdFx0XHRhamF4OiB7XG5cdFx0XHRcdHVybDogZm9ybWluYXRvckRhdGEuYWpheFVybCxcblx0XHRcdFx0dHlwZTogJ1BPU1QnLFxuXHRcdFx0XHRkZWxheTogMzUwLFxuXHRcdFx0XHRkYXRhOiBmdW5jdGlvbiggcGFyYW1zICkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRhY3Rpb246ICdmb3JtaW5hdG9yX2J1aWxkZXJfc2VhcmNoX2VtYWlscycsXG5cdFx0XHRcdFx0XHRfd3Bub25jZTogZm9ybWluYXRvckRhdGEuc2VhcmNoTm9uY2UsXG5cdFx0XHRcdFx0XHRxOiBwYXJhbXMudGVybSxcblx0XHRcdFx0XHRcdHBlcm1pc3Npb246ICdmb3JtaW5hdG9yJyxcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRwcm9jZXNzUmVzdWx0czogZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHJlc3VsdHM6IGRhdGEuZGF0YSxcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjYWNoZTogdHJ1ZSxcblx0XHRcdH0sXG5cdFx0XHR0ZW1wbGF0ZVJlc3VsdDogZnVuY3Rpb24oIHJlc3VsdCApIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCEgXy5pc1VuZGVmaW5lZCggcmVzdWx0LmlkICkgJiZcblx0XHRcdFx0XHQhIF8uaXNVbmRlZmluZWQoIHJlc3VsdC50ZXh0ICkgJiZcblx0XHRcdFx0XHQhIF8uaXNVbmRlZmluZWQoIHJlc3VsdC5kaXNwbGF5X25hbWUgKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5KFxuXHRcdFx0XHRcdFx0JzxzcGFuPicgK1xuXHRcdFx0XHRcdFx0XHQnPGI+JyArXG5cdFx0XHRcdFx0XHRcdHJlc3VsdC50ZXh0ICtcblx0XHRcdFx0XHRcdFx0JzwvYj4gLSAnICtcblx0XHRcdFx0XHRcdFx0JzxzbWFsbD4nICtcblx0XHRcdFx0XHRcdFx0cmVzdWx0LmRpc3BsYXlfbmFtZSArXG5cdFx0XHRcdFx0XHRcdCc8L3NtYWxsPicgK1xuXHRcdFx0XHRcdFx0XHQnPC9zcGFuPidcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHJlc3VsdC50ZXh0O1xuXHRcdFx0fSxcblx0XHRcdGNyZWF0ZVRhZzogZnVuY3Rpb24oIHBhcmFtcyApIHtcblx0XHRcdFx0Y29uc3QgdGVybSA9IHBhcmFtcy50ZXJtLnRyaW0oKTtcblx0XHRcdFx0aWYgKCAhIGlzRW1haWxXcCggdGVybSApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aWQ6IHRlcm0sXG5cdFx0XHRcdFx0dGV4dDogdGVybSxcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0fTtcblx0fVxuXHRnZXRDY0JjY09wdGlvbnMoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRhZ3M6IHRydWUsXG5cdFx0XHRwbGFjZWhvbGRlcjogdHJhbnNsYXRlKCAnTm9uZScgKSxcblx0XHRcdGNyZWF0ZVRhZzogZnVuY3Rpb24oIHBhcmFtcyApIHtcblx0XHRcdFx0Y29uc3QgdGVybSA9IHBhcmFtcy50ZXJtLnRyaW0oKTtcblx0XHRcdFx0aWYgKCAhIGlzRW1haWxXcCggdGVybSApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aWQ6IHRlcm0sXG5cdFx0XHRcdFx0dGV4dDogdGVybSxcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHR0b2tlblNlcGFyYXRvcnM6IFsgJywnLCAnICcgXSxcblx0XHRcdGxhbmd1YWdlOiB7XG5cdFx0XHRcdHNlYXJjaGluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ1NlYXJjaGluZycgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0bm9SZXN1bHRzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnTm8gUmVzdWx0IEZvdW5kJyApO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSxcblx0XHRcdGFqYXg6IHtcblx0XHRcdFx0dXJsOiBmb3JtaW5hdG9yRGF0YS5hamF4VXJsLFxuXHRcdFx0XHR0eXBlOiAnUE9TVCcsXG5cdFx0XHRcdGRlbGF5OiAzNTAsXG5cdFx0XHRcdGRhdGE6IGZ1bmN0aW9uKCBwYXJhbXMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGFjdGlvbjogJ2Zvcm1pbmF0b3JfYnVpbGRlcl9zZWFyY2hfZW1haWxzJyxcblx0XHRcdFx0XHRcdF93cG5vbmNlOiBmb3JtaW5hdG9yRGF0YS5zZWFyY2hOb25jZSxcblx0XHRcdFx0XHRcdHE6IHBhcmFtcy50ZXJtLFxuXHRcdFx0XHRcdFx0cGVybWlzc2lvbjogJ2Zvcm1pbmF0b3InLFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHByb2Nlc3NSZXN1bHRzOiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0cmVzdWx0czogZGF0YS5kYXRhLFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNhY2hlOiB0cnVlLFxuXHRcdFx0fSxcblx0XHRcdHRlbXBsYXRlUmVzdWx0OiBmdW5jdGlvbiggcmVzdWx0ICkge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ISBfLmlzVW5kZWZpbmVkKCByZXN1bHQuaWQgKSAmJlxuXHRcdFx0XHRcdCEgXy5pc1VuZGVmaW5lZCggcmVzdWx0LnRleHQgKSAmJlxuXHRcdFx0XHRcdCEgXy5pc1VuZGVmaW5lZCggcmVzdWx0LmRpc3BsYXlfbmFtZSApXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkoXG5cdFx0XHRcdFx0XHQnPHNwYW4+JyArXG5cdFx0XHRcdFx0XHRcdCc8Yj4nICtcblx0XHRcdFx0XHRcdFx0cmVzdWx0LnRleHQgK1xuXHRcdFx0XHRcdFx0XHQnPC9iPiAtICcgK1xuXHRcdFx0XHRcdFx0XHQnPHNtYWxsPicgK1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQuZGlzcGxheV9uYW1lICtcblx0XHRcdFx0XHRcdFx0Jzwvc21hbGw+JyArXG5cdFx0XHRcdFx0XHRcdCc8L3NwYW4+J1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0LnRleHQ7XG5cdFx0XHR9LFxuXHRcdH07XG5cdH1cblx0LypnZXRDY0FkZHJlc3Nlc09wdGlvbnMoKSB7XG5cdFx0Y29uc3QgY2NFbWFpbE9wdGlvbnMgPSB0aGlzLmdldEVtYWlsT3B0aW9ucygpO1xuXHRcdGNvbnN0IGNjRW1haWxPcHRpb25zVmFsdWVzID0gW107XG5cdFx0Y2NFbWFpbE9wdGlvbnMubWFwKCBvcHQgPT4ge1xuXHRcdFx0Y2NFbWFpbE9wdGlvbnNWYWx1ZXMucHVzaCggb3B0LnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdFx0Y29uc3Qgc2F2ZWRDY0FkZHJlc3NlcyA9XG5cdFx0XHRfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzWyAnYWRtaW4tZW1haWwtY2MtYWRkcmVzcycgXSApIHx8XG5cdFx0XHQhIF8uaXNBcnJheSggdGhpcy5wcm9wcy5zZXR0aW5nc1sgJ2FkbWluLWVtYWlsLWNjLWFkZHJlc3MnIF0gKVxuXHRcdFx0XHQ/IFtdXG5cdFx0XHRcdDogdGhpcy5wcm9wcy5zZXR0aW5nc1sgJ2FkbWluLWVtYWlsLWNjLWFkZHJlc3MnIF07XG5cblx0XHRjb25zdCBjY0FkZHJlc3NPcHRpb25zID0gc2F2ZWRDY0FkZHJlc3Nlcy5maWx0ZXIoXG5cdFx0XHRjY0FkZHJlc3MgPT4gY2NFbWFpbE9wdGlvbnNWYWx1ZXMuaW5kZXhPZiggY2NBZGRyZXNzICkgPCAwXG5cdFx0KTtcblx0XHRjY0FkZHJlc3NPcHRpb25zLm1hcCggY2NBZGRyZXNzID0+IHtcblx0XHRcdGNjRW1haWxPcHRpb25zLnB1c2goIHtcblx0XHRcdFx0dmFsdWU6IGNjQWRkcmVzcyxcblx0XHRcdFx0bGFiZWw6IGNjQWRkcmVzcyxcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gY2NFbWFpbE9wdGlvbnM7XG5cdH0qL1xuXHQvKmdldEJjY0FkZHJlc3Nlc09wdGlvbnMoKSB7XG5cdFx0Y29uc3QgYmNjRW1haWxPcHRpb25zID0gdGhpcy5nZXRFbWFpbE9wdGlvbnMoKTtcblx0XHRjb25zdCBiY2NFbWFpbE9wdGlvbnNWYWx1ZXMgPSBbXTtcblx0XHRiY2NFbWFpbE9wdGlvbnMubWFwKCBvcHQgPT4ge1xuXHRcdFx0YmNjRW1haWxPcHRpb25zVmFsdWVzLnB1c2goIG9wdC52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHRcdGNvbnN0IHNhdmVkQkNjQWRkcmVzc2VzID1cblx0XHRcdF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3NbICdhZG1pbi1lbWFpbC1iY2MtYWRkcmVzcycgXSApIHx8XG5cdFx0XHQhIF8uaXNBcnJheSggdGhpcy5wcm9wcy5zZXR0aW5nc1sgJ2FkbWluLWVtYWlsLWJjYy1hZGRyZXNzJyBdIClcblx0XHRcdFx0PyBbXVxuXHRcdFx0XHQ6IHRoaXMucHJvcHMuc2V0dGluZ3NbICdhZG1pbi1lbWFpbC1iY2MtYWRkcmVzcycgXTtcblxuXHRcdGNvbnN0IGJjY0FkZHJlc3NPcHRpb25zID0gc2F2ZWRCQ2NBZGRyZXNzZXMuZmlsdGVyKFxuXHRcdFx0YmNjQWRkcmVzcyA9PiBiY2NFbWFpbE9wdGlvbnNWYWx1ZXMuaW5kZXhPZiggYmNjQWRkcmVzcyApIDwgMFxuXHRcdCk7XG5cdFx0YmNjQWRkcmVzc09wdGlvbnMubWFwKCBiY2NBZGRyZXNzID0+IHtcblx0XHRcdGJjY0VtYWlsT3B0aW9ucy5wdXNoKCB7XG5cdFx0XHRcdHZhbHVlOiBiY2NBZGRyZXNzLFxuXHRcdFx0XHRsYWJlbDogYmNjQWRkcmVzcyxcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gYmNjRW1haWxPcHRpb25zO1xuXHR9Ki9cblx0Z2V0QXV0b0NyZWF0ZUVtYWlsQWRkcmVzc09wdGlvbnMoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRhZ3M6IHRydWUsXG5cdFx0XHRjcmVhdGVUYWc6IGZ1bmN0aW9uKCBwYXJhbXMgKSB7XG5cdFx0XHRcdGNvbnN0IHRlcm0gPSBwYXJhbXMudGVybS50cmltKCk7XG5cdFx0XHRcdGlmICggISBpc0VtYWlsV3AoIHRlcm0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGlkOiB0ZXJtLFxuXHRcdFx0XHRcdHRleHQ6IHRlcm0sXG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0aW5zZXJ0VGFnOiBmdW5jdGlvbiggZGF0YSwgdGFnICkge1xuXHRcdFx0XHQvLyBJbnNlcnQgdGhlIHRhZyBhdCB0aGUgZW5kIG9mIHRoZSByZXN1bHRzXG5cdFx0XHRcdGRhdGEucHVzaCggdGFnICk7XG5cdFx0XHR9LFxuXHRcdH07XG5cdH1cblx0Z2V0RnJvbUFkZHJlc3NPcHRpb25zKCkge1xuXHRcdGNvbnN0IGZyb21FbWFpbE9wdGlvbnMgPSB0aGlzLmdldEVtYWlsT3B0aW9ucygpO1xuXHRcdGZyb21FbWFpbE9wdGlvbnMudW5zaGlmdCgge1xuXHRcdFx0dmFsdWU6ICcnLFxuXHRcdFx0bGFiZWw6IHRyYW5zbGF0ZSggJ0RlZmF1bHQnICksXG5cdFx0fSApO1xuXG5cdFx0Y29uc3QgZnJvbUVtYWlsT3B0aW9uc1ZhbHVlcyA9IFtdO1xuXHRcdGZyb21FbWFpbE9wdGlvbnMubWFwKCBvcHQgPT4ge1xuXHRcdFx0ZnJvbUVtYWlsT3B0aW9uc1ZhbHVlcy5wdXNoKCBvcHQudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0XHRjb25zdCBzYXZlZEZyb21BZGRyZXNzID0gXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5nc1sgJ2FkbWluLWVtYWlsLWZyb20tYWRkcmVzcycgXSApXG5cdFx0XHQ/ICcnXG5cdFx0XHQ6IHRoaXMucHJvcHMuc2V0dGluZ3NbICdhZG1pbi1lbWFpbC1mcm9tLWFkZHJlc3MnIF07XG5cblx0XHRpZiAoIGZyb21FbWFpbE9wdGlvbnNWYWx1ZXMuaW5kZXhPZiggc2F2ZWRGcm9tQWRkcmVzcyApIDwgMCApIHtcblx0XHRcdGZyb21FbWFpbE9wdGlvbnMucHVzaCgge1xuXHRcdFx0XHR2YWx1ZTogc2F2ZWRGcm9tQWRkcmVzcyxcblx0XHRcdFx0bGFiZWw6IHNhdmVkRnJvbUFkZHJlc3MsXG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZyb21FbWFpbE9wdGlvbnM7XG5cdH1cblx0Z2V0UmVwbHlUb0FkZHJlc3NPcHRpb25zKCkge1xuXHRcdGNvbnN0IHJlcGx5VG9BZGRyZXNzT3B0aW9ucyA9IHRoaXMuZ2V0RW1haWxPcHRpb25zKCk7XG5cdFx0cmVwbHlUb0FkZHJlc3NPcHRpb25zLnVuc2hpZnQoIHtcblx0XHRcdHZhbHVlOiAnJyxcblx0XHRcdGxhYmVsOiB0cmFuc2xhdGUoICdOb25lJyApLFxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IGVtYWlsT3B0aW9uc1ZhbHVlcyA9IFtdO1xuXHRcdHJlcGx5VG9BZGRyZXNzT3B0aW9ucy5tYXAoIG9wdCA9PiB7XG5cdFx0XHRlbWFpbE9wdGlvbnNWYWx1ZXMucHVzaCggb3B0LnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdFx0Y29uc3Qgc2F2ZWRBZGRyZXNzID0gXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5nc1sgJ2FkbWluLWVtYWlsLXJlcGx5LXRvLWFkZHJlc3MnIF0gKVxuXHRcdFx0PyAnJ1xuXHRcdFx0OiB0aGlzLnByb3BzLnNldHRpbmdzWyAnYWRtaW4tZW1haWwtcmVwbHktdG8tYWRkcmVzcycgXTtcblxuXHRcdGlmICggZW1haWxPcHRpb25zVmFsdWVzLmluZGV4T2YoIHNhdmVkQWRkcmVzcyApIDwgMCApIHtcblx0XHRcdHJlcGx5VG9BZGRyZXNzT3B0aW9ucy5wdXNoKCB7XG5cdFx0XHRcdHZhbHVlOiBzYXZlZEFkZHJlc3MsXG5cdFx0XHRcdGxhYmVsOiBzYXZlZEFkZHJlc3MsXG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlcGx5VG9BZGRyZXNzT3B0aW9ucztcblx0fVxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgZnJvbUFkZHJlc3NPcHRpb25zID0gdGhpcy5nZXRFbWFpbE9wdGlvbnMoKTtcblx0XHRmcm9tQWRkcmVzc09wdGlvbnMudW5zaGlmdCgge1xuXHRcdFx0dmFsdWU6ICcnLFxuXHRcdFx0bGFiZWw6IHRyYW5zbGF0ZSggJ0RlZmF1bHQnICksXG5cdFx0fSApO1xuXG5cdFx0Y29uc3QgcmVwbHlUb0FkZHJlc3NPcHRpb25zID0gdGhpcy5nZXRFbWFpbE9wdGlvbnMoKTtcblx0XHRyZXBseVRvQWRkcmVzc09wdGlvbnMudW5zaGlmdCgge1xuXHRcdFx0dmFsdWU6ICcnLFxuXHRcdFx0bGFiZWw6IHRyYW5zbGF0ZSggJ05vbmUnICksXG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1yb3dcIj5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0xXCI+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXNldHRpbmdzLWxhYmVsXCI+eyB0cmFuc2xhdGUoICdBZG1pbiBFbWFpbCcgKSB9PC9zcGFuPlxuXG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCI+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0J09wdGlvbmFsbHksIHlvdSBjYW4gc2VuZCBhIG5vdGlmaWNhdGlvbiBlbWFpbCB0byAnICtcblx0XHRcdFx0XHRcdFx0J25vbWluYXRlZCBlbWFpbCBhY2NvdW50cyB3aGVuIHBvbGwgc3VibWlzc2lvbnMgY29tZSBpbi4nXG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMlwiPlxuXG5cdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGRcIlxuXHRcdFx0XHRcdFx0c3R5bGU9eyB7IG1hcmdpbkJvdHRvbTogJzEwcHgnIH0gfVxuXHRcdFx0XHRcdD5cblxuXHRcdFx0XHRcdFx0PFRvZ2dsZVxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cInVzZS1hZG1pbi1lbWFpbFwiXG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnU2VuZCBhbiBlbWFpbCB0byBhZG1pbiB1c2VycycgKSB9XG5cdFx0XHRcdFx0XHRcdHVuV3JhcFxuXHRcdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0eyEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5nc1sgJ3VzZS1hZG1pbi1lbWFpbCcgXSApICYmXG5cdFx0XHRcdFx0XHR0aGlzLnByb3BzLnNldHRpbmdzWyAndXNlLWFkbWluLWVtYWlsJyBdICYmIChcblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJvcmRlci1mcmFtZSBzdWktdG9nZ2xlLWNvbnRlbnRcIj5cblx0XHRcdFx0XHRcdFx0PFN1aVZhcmlhYmxlc1xuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJhZG1pbi1lbWFpbC1mcm9tLW5hbWVcIlxuXHRcdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPXsgdHJhbnNsYXRlKCAnRGVmYXVsdCcgKSB9XG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdGcm9tIE5hbWUnICkgfVxuXHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0e3RoaXMuZ2V0TmFtZU9wdGlvbnMoKS5tYXAoICggb3B0aW9uLCBpICkgPT4gKFxuXHRcdFx0XHRcdFx0XHRcdFx0PG9wdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXk9eyBpIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWU9eyBvcHRpb24udmFsdWUgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkYXRhLWNvbnRlbnQ9eyBvcHRpb24udmFsdWUgfVxuXHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGVzY2FwZUhUTUwoIG9wdGlvbi5sYWJlbCApIH1cblx0XHRcdFx0XHRcdFx0XHRcdDwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0XHRcdCkgKX1cblx0XHRcdFx0XHRcdFx0PC9TdWlWYXJpYWJsZXM+XG5cblx0XHRcdFx0XHRcdFx0PFN1aVNlbGVjdDJcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwiYWRtaW4tZW1haWwtZnJvbS1hZGRyZXNzXCJcblx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0Zyb20gQWRkcmVzcycgKSB9XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPVwiXCJcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zPXsgdGhpcy5nZXRBdXRvQ3JlYXRlRW1haWxBZGRyZXNzT3B0aW9ucygpIH1cblx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdHt0aGlzLmdldEZyb21BZGRyZXNzT3B0aW9ucygpLm1hcCggKCBvcHRpb24sIGkgKSA9PiAoXG5cdFx0XHRcdFx0XHRcdFx0XHQ8b3B0aW9uIGtleT17IGkgfSB2YWx1ZT17IG9wdGlvbi52YWx1ZSB9PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7b3B0aW9uLmxhYmVsfVxuXHRcdFx0XHRcdFx0XHRcdFx0PC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdFx0KSApfVxuXHRcdFx0XHRcdFx0XHQ8L1N1aVNlbGVjdDI+XG5cblx0XHRcdFx0XHRcdFx0PFN1aVRhZ3Ncblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwiYWRtaW4tZW1haWwtcmVjaXBpZW50c1wiXG5cdFx0XHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9eyB0cmFuc2xhdGUoICdSZWNpcGllbnQocyknICkgfVxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM9eyB0aGlzLmdldFJlY2lwaWVudFRhZ3NPcHRpb25zKCkgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUmVjaXBpZW50cycgKSB9XG5cdFx0XHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0XHRcdFx0PFN1aVNlbGVjdDJcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwiYWRtaW4tZW1haWwtcmVwbHktdG8tYWRkcmVzc1wiXG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdSZXBseSBUbyBBZGRyZXNzJyApIH1cblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9XCJcIlxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM9eyB0aGlzLmdldEF1dG9DcmVhdGVFbWFpbEFkZHJlc3NPcHRpb25zKCkgfVxuXHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0e3RoaXMuZ2V0UmVwbHlUb0FkZHJlc3NPcHRpb25zKCkubWFwKCAoIG9wdGlvbiwgaSApID0+IChcblx0XHRcdFx0XHRcdFx0XHRcdDxvcHRpb24ga2V5PXsgaSB9IHZhbHVlPXsgb3B0aW9uLnZhbHVlIH0+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHtvcHRpb24ubGFiZWx9XG5cdFx0XHRcdFx0XHRcdFx0XHQ8L29wdGlvbj5cblx0XHRcdFx0XHRcdFx0XHQpICl9XG5cdFx0XHRcdFx0XHRcdDwvU3VpU2VsZWN0Mj5cblxuXHRcdFx0XHRcdFx0XHQ8U3VpVGFnc1xuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJhZG1pbi1lbWFpbC1jYy1hZGRyZXNzXCJcblx0XHRcdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj17IHRyYW5zbGF0ZSggJ05vbmUnICkgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQ0MgQWRkcmVzc2VzJyApIH1cblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zPXsgdGhpcy5nZXRDY0JjY09wdGlvbnMoKSB9XG5cdFx0XHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0XHRcdFx0PFN1aVRhZ3Ncblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwiYWRtaW4tZW1haWwtYmNjLWFkZHJlc3NcIlxuXHRcdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPXsgdHJhbnNsYXRlKCAnTm9uZScgKSB9XG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCQ0MgQWRkcmVzc2VzJyApIH1cblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zPXsgdGhpcy5nZXRDY0JjY09wdGlvbnMoKSB9XG5cdFx0XHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0XHRcdFx0PElucHV0XG5cdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cImFkbWluLWVtYWlsLXRpdGxlXCJcblx0XHRcdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj17IHRyYW5zbGF0ZSggJ0VudGVyIHN1YmplY3QnICkgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnU3ViamVjdCcgKSB9XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPVwiXCJcblx0XHRcdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdFx0XHQ8V3BFZGl0b3Jcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwiYWRtaW4tZW1haWwtZWRpdG9yXCJcblx0XHRcdFx0XHRcdFx0XHRlZGl0b3JPcHRpb25zPXsgZm9ybWluYXRvckRhdGEudmFyaWFibGVzIH1cblx0XHRcdFx0XHRcdFx0XHRlbmFibGVGb3JtRGF0YT17IGZhbHNlIH1cblx0XHRcdFx0XHRcdFx0XHRib3hDbGFzcz1cInN1aS10YWItYm94ZWRcIlxuXHRcdFx0XHRcdFx0XHRcdG1haW5PcHRpb25zPXsge1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9sbF9uYW1lOiB0cmFuc2xhdGUoICdQb2xsIE5hbWUnICksXG5cdFx0XHRcdFx0XHRcdFx0XHRwb2xsX2Fuc3dlcjogdHJhbnNsYXRlKCAnUG9sbCBBbnN3ZXInICksXG5cdFx0XHRcdFx0XHRcdFx0XHRwb2xsX3Jlc3VsdDogdHJhbnNsYXRlKCAnUG9sbCBSZXN1bHQnICksXG5cdFx0XHRcdFx0XHRcdFx0fSB9XG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb2R5JyApIH1cblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdCl9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9ub3RpZmljYXRpb25zL2FkbWluLWVtYWlsLmpzIiwiaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IHNob3dNb2RhbCwgaGlkZU1vZGFsIH0gZnJvbSAnLi4vYWN0aW9ucy9tb2RhbCc7XG5cbmltcG9ydCBJbnRlZ3JhdGlvbnMgZnJvbSAnLi4vY29tcG9uZW50cy9pbnRlZ3JhdGlvbnMnO1xuXG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSBkaXNwYXRjaCA9PiAoIHtcblx0aGlkZU1vZGFsOiAoKSA9PiBkaXNwYXRjaCggaGlkZU1vZGFsKCkgKSxcblx0c2hvd01vZGFsOiAoIG1vZGFsUHJvcHMsIG1vZGFsVHlwZSApID0+IHtcblx0XHRkaXNwYXRjaCggc2hvd01vZGFsKCB7IG1vZGFsUHJvcHMsIG1vZGFsVHlwZSB9ICkgKTtcblx0fSxcbn0gKTtcblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChcblx0bnVsbCxcblx0bWFwRGlzcGF0Y2hUb1Byb3BzXG4pKCBJbnRlZ3JhdGlvbnMgKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbnRhaW5lcnMvaW50ZWdyYXRpb25zLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCBGb3JtaW5hdG9ySW50ZWdyYXRpb25zTW9kYWwgZnJvbSAnLi4vLi4vbGliL2ludGVncmF0aW9ucy1tb2RhbCc7XG5pbXBvcnQgJ3doYXR3Zy1mZXRjaCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludGVncmF0aW9ucyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblxuXHRcdHRoaXMuc3RhdGUgPSB7XG5cdFx0XHRsb2FkaW5nOiBmYWxzZSxcblx0XHRcdG1hcmt1cDogJycsXG5cdFx0fTtcblx0XHR0aGlzLmxvYWRJbnRlZ3JhdGlvbnMgPSB0aGlzLmxvYWRJbnRlZ3JhdGlvbnMuYmluZCggdGhpcyApO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0dGhpcy5tb3VudGVkID0gdHJ1ZTtcblxuXHRcdHRoaXMubG9hZEludGVncmF0aW9ucygpO1xuXG5cdFx0alF1ZXJ5KCAnaHRtbCwgYm9keScgKS5hbmltYXRlKFxuXHRcdFx0e1xuXHRcdFx0XHRzY3JvbGxUb3A6IDAsXG5cdFx0XHR9LCAnZmFzdCdcblx0XHQpO1xuXHR9XG5cblx0Y29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0dGhpcy5tb3VudGVkID0gZmFsc2U7XG5cdH1cblxuXHRsb2FkSW50ZWdyYXRpb25zKCkge1xuXHRcdGNvbnN0IGZvcm1JZCA9IGZvcm1pbmF0b3JEYXRhLmN1cnJlbnRGb3JtLnNldHRpbmdzLmZvcm1faWQ7XG5cblx0XHQvLyBjaGVjayBpZiBmb3JtIGlkIGV4aXN0cywgbWVhbnMgaXRzIHNhdmVkXG5cdFx0aWYgKCBfLmlzVW5kZWZpbmVkKCBmb3JtSWQgKSB8fCArZm9ybUlkIDw9IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBwcm9jZXNzIGFqYXggcmVxdWVzdFxuXHRcdGlmICggdGhpcy5zdGF0ZS5sb2FkaW5nICkge1xuXHRcdFx0Ly8gQWpheCByZXF1ZXN0IGluIHByb2Nlc3MsIHNraXBcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnNldFN0YXRlKCB7XG5cdFx0XHRtYXJrdXA6ICcnLFxuXHRcdFx0bG9hZGluZzogdHJ1ZSxcblx0XHR9ICk7XG5cblx0XHR3aW5kb3dcblx0XHRcdC5mZXRjaCggZm9ybWluYXRvckRhdGEuYWpheFVybCwge1xuXHRcdFx0XHRtZXRob2Q6ICdQT1NUJyxcblx0XHRcdFx0aGVhZGVyczoge1xuXHRcdFx0XHRcdCdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PXV0Zi04Jyxcblx0XHRcdFx0fSxcblx0XHRcdFx0Ym9keTpcblx0XHRcdFx0XHQnYWN0aW9uPWZvcm1pbmF0b3JfYWRkb25fZ2V0X21vZHVsZV9hZGRvbnMmX2FqYXhfbm9uY2U9JyArXG5cdFx0XHRcdFx0Zm9ybWluYXRvckRhdGEuYWRkb25Ob25jZSArXG5cdFx0XHRcdFx0JyZkYXRhW21vZHVsZV90eXBlXT1wb2xsJyArXG5cdFx0XHRcdFx0JyZkYXRhW21vZHVsZV9pZF09JyArXG5cdFx0XHRcdFx0Zm9ybUlkLFxuXHRcdFx0fSApXG5cdFx0XHQudGhlbiggcmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpIClcblx0XHRcdC50aGVuKCBkYXRhID0+IHtcblx0XHRcdFx0aWYgKCBkYXRhLnN1Y2Nlc3MgJiYgdGhpcy5tb3VudGVkICkge1xuXHRcdFx0XHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHRcdFx0XHRcdHRoaXMuc2V0U3RhdGUoIHsgbWFya3VwOiBkYXRhLmRhdGEuZGF0YSB9ICk7XG5cblx0XHRcdFx0XHRzZXRUaW1lb3V0KCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCAkYWRkb25zID0gd2luZG93LmpRdWVyeSggJy5mb3JtLWludGVncmF0aW9ucy13cmFwcGVyJyApO1xuXG5cdFx0XHRcdFx0XHQkYWRkb25zLkZvcm1pbmF0b3JJbnRlZ3JhdGlvbnNNb2RhbCgge1xuXHRcdFx0XHRcdFx0XHR0eXBlOiAncG9sbCcsXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRcdCRhZGRvbnMub24oICdyZWxvYWQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0JGFkZG9ucy51bmJpbmQoKTtcblx0XHRcdFx0XHRcdFx0c2VsZi5sb2FkSW50ZWdyYXRpb25zKCk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSwgMTAgKTtcblxuXHRcdFx0XHRcdC8vIFNldCBsb2FkaW5nIHRvIGZhbHNlXG5cdFx0XHRcdFx0dGhpcy5zZXRTdGF0ZSggeyBsb2FkaW5nOiBmYWxzZSB9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKVxuXHRcdFx0LmNhdGNoKCBlcnJvciA9PiB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCBlcnJvciApO1xuXHRcdFx0fSApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IHsgbG9hZGluZyB9ID0gdGhpcy5zdGF0ZTtcblx0XHRjb25zdCB7IG1hcmt1cCB9ID0gdGhpcy5zdGF0ZTtcblxuXHRcdGNvbnN0IGZvcm1JZCA9IGZvcm1pbmF0b3JEYXRhLmN1cnJlbnRGb3JtLnNldHRpbmdzLmZvcm1faWQ7XG5cblx0XHRjb25zdCBnb1RvU2VjdGlvbiA9IG1vZHVsZSA9PiB7XG5cdFx0XHR0aGlzLnByb3BzLmhpc3RvcnkucHVzaCggJy8nICsgbW9kdWxlICk7XG5cdFx0fTtcblxuXHRcdGxldCBjb250ZW50ID0gJyc7XG5cblx0XHRpZiAoIGxvYWRpbmcgKSB7XG5cdFx0XHRjb250ZW50ID0gKFxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ub3RpY2Ugc3VpLWFjdGl2ZVwiIHN0eWxlPXsgeyBkaXNwbGF5OiAnYmxvY2snIH0gfT5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ub3RpY2UtY29udGVudFwiPlxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktbm90aWNlLW1lc3NhZ2VcIj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLW5vdGljZS1pY29uIHN1aS1pY29uLWxvYWRlciBzdWktbG9hZGluZ1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG5cdFx0XHRcdFx0XHRcdDxwPnt0cmFuc2xhdGUoICdGZXRjaGluZyBpbnRlZ3JhdGlvbiBsaXN04oCmJyApfTwvcD5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmICggXy5pc1VuZGVmaW5lZCggZm9ybUlkICkgfHwgK2Zvcm1JZCA8PSAwICkge1xuXHRcdFx0Y29udGVudCA9IChcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktbm90aWNlIHN1aS1ub3RpY2UteWVsbG93IHN1aS1hY3RpdmVcIiBzdHlsZT17IHsgZGlzcGxheTogJ2Jsb2NrJyB9IH0+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktbm90aWNlLWNvbnRlbnRcIj5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLW5vdGljZS1tZXNzYWdlXCI+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1ub3RpY2UtaWNvbiBzdWktaWNvbi1pbmZvXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cblx0XHRcdFx0XHRcdFx0PHA+eyB0cmFuc2xhdGUoICdZb3UgbmVlZCB0byBzYXZlIHRoaXMgcG9sbCBiZWZvcmUgdXNpbmcgaW50ZWdyYXRpb25zLicgKSB9PC9wPlxuXHRcdFx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktYnV0dG9uXCIgb25DbGljaz17IHRoaXMubG9hZEludGVncmF0aW9ucyB9PlxuXHRcdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnVHJ5IEFnYWluJyApIH1cblx0XHRcdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGVudCA9IChcblx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJmb3JtLWludGVncmF0aW9ucy13cmFwcGVyXCJcblx0XHRcdFx0XHRkYW5nZXJvdXNseVNldElubmVySFRNTD17IHsgX19odG1sOiBtYXJrdXAgfSB9XG5cdFx0XHRcdC8+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGlkPVwiZm9ybWluYXRvci1mb3JtLWFwcGVhcmFuY2VcIiBjbGFzc05hbWU9XCJzdWktYm94XCI+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1oZWFkZXJcIj5cblx0XHRcdFx0XHQ8aDIgY2xhc3NOYW1lPVwic3VpLWJveC10aXRsZVwiPnt0cmFuc2xhdGUoICdJbnRlZ3JhdGlvbnMnICl9PC9oMj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LWJvZHlcIj57Y29udGVudH08L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtZm9vdGVyXCI+XG5cdFx0XHRcdFx0PGJ1dHRvbiBjbGFzc05hbWU9XCJzdWktYnV0dG9uXCIgb25DbGljaz17ICgpID0+IGdvVG9TZWN0aW9uKCAnbm90aWZpY2F0aW9ucycgKSB9PlxuXHRcdFx0XHRcdFx0PGkgY2xhc3NOYW1lPVwic3VpLWljb24tYXJyb3ctbGVmdFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG5cdFx0XHRcdFx0XHR7dHJhbnNsYXRlKCAnRW1haWwgTm90aWZpY2F0aW9ucycgKX1cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWFjdGlvbnMtcmlnaHRcIj5cblx0XHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWJ1dHRvbiBzdWktYnV0dG9uLWljb24tcmlnaHRcIlxuXHRcdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gZ29Ub1NlY3Rpb24oICdzZXR0aW5ncycgKSB9XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdHt0cmFuc2xhdGUoICdTZXR0aW5ncycgKX1cblx0XHRcdFx0XHRcdFx0PGkgY2xhc3NOYW1lPVwic3VpLWljb24tYXJyb3ctcmlnaHRcIiBhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuXHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9pbnRlZ3JhdGlvbnMuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcblxuaW1wb3J0ICogYXMgc2V0dGluZ3NBY3Rpb25zIGZyb20gJy4uL2FjdGlvbnMvc2V0dGluZ3MnO1xuaW1wb3J0ICogYXMgbW9kYWxBY3Rpb25zIGZyb20gJy4uL2FjdGlvbnMvbW9kYWwnO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uL2NvbXBvbmVudHMvc2V0dGluZ3MnO1xuXG5mdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHMoIHN0YXRlICkge1xuXHRyZXR1cm4ge1xuXHRcdHNldHRpbmdzOiBzdGF0ZS5zZXR0aW5ncyxcblx0fTtcbn1cblxuZnVuY3Rpb24gbWFwRGlzcGF0Y2hUb1Byb3BzKCBkaXNwYXRjaCApIHtcblx0cmV0dXJuIHtcblx0XHRhY3Rpb25zOiB7XG5cdFx0XHRzZXR0aW5nc0FjdGlvbnM6IGJpbmRBY3Rpb25DcmVhdG9ycyggc2V0dGluZ3NBY3Rpb25zLCBkaXNwYXRjaCApLFxuXHRcdFx0bW9kYWxBY3Rpb25zOiBiaW5kQWN0aW9uQ3JlYXRvcnMoIG1vZGFsQWN0aW9ucywgZGlzcGF0Y2ggKSxcblx0XHR9LFxuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KFxuXHRtYXBTdGF0ZVRvUHJvcHMsXG5cdG1hcERpc3BhdGNoVG9Qcm9wc1xuKSggU2V0dGluZ3MgKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbnRhaW5lcnMvc2V0dGluZ3MuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgRGF0YVN0b3JhZ2UgZnJvbSAnLi9zZXR0aW5ncy9kYXRhLXN0b3JhZ2UnO1xuaW1wb3J0IFByaXZhY3kgZnJvbSAnLi9zZXR0aW5ncy9wcml2YWN5JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2V0dGluZ3MgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHRqUXVlcnkoICdodG1sLCBib2R5JyApLmFuaW1hdGUoXG5cdFx0XHR7XG5cdFx0XHRcdHNjcm9sbFRvcDogMCxcblx0XHRcdH0sICdmYXN0J1xuXHRcdCk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgZ29Ub1NlY3Rpb24gPSBtb2R1bGUgPT4ge1xuXHRcdFx0dGhpcy5wcm9wcy5oaXN0b3J5LnB1c2goICcvJyArIG1vZHVsZSApO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdlxuXHRcdFx0XHRpZD1cImZvcm1pbmF0b3ItZm9ybS1hcHBlYXJhbmNlXCJcblx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWJveFwiXG5cdFx0XHQ+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LWhlYWRlclwiPlxuXHRcdFx0XHRcdDxoMiBjbGFzc05hbWU9XCJzdWktYm94LXRpdGxlXCI+eyB0cmFuc2xhdGUoICdTZXR0aW5ncycgKSB9PC9oMj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LWJvZHlcIj5cblxuXHRcdFx0XHRcdDxEYXRhU3RvcmFnZSB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdDxQcml2YWN5IHsgLi4udGhpcy5wcm9wcyB9IC8+XG5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LWZvb3RlclwiPlxuXHRcdFx0XHRcdDxidXR0b24gY2xhc3NOYW1lPVwic3VpLWJ1dHRvblwiIG9uQ2xpY2s9eyAoKSA9PiBnb1RvU2VjdGlvbiggJ2ludGVncmF0aW9ucycgKSB9PlxuXHRcdFx0XHRcdFx0PGkgY2xhc3NOYW1lPVwic3VpLWljb24tYXJyb3ctbGVmdFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+eycgJ31cblx0XHRcdFx0XHRcdHt0cmFuc2xhdGUoICdJbnRlZ3JhdGlvbnMnICl9XG5cdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9zZXR0aW5ncy5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5pbXBvcnQgVG9nZ2xlIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy90b2dnbGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhU3RvcmFnZSBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLXJvd1wiPlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMVwiPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1zZXR0aW5ncy1sYWJlbFwiPnsgdHJhbnNsYXRlKCAnRGF0YSBTdG9yYWdlJyApIH08L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCI+eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcIkJ5IGRlZmF1bHQgd2UnbGwgc3RvcmUgYWxsIHN1Ym1pc3Npb25zIGluIHlvdXIgZGF0YWJhc2UuXCJcblx0XHRcdFx0XHQpIH08L3NwYW4+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMlwiPlxuXG5cdFx0XHRcdFx0PFRvZ2dsZVxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PVwic3RvcmVfc3VibWlzc2lvbnNcIlxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdTdG9yZSBTdWJtaXNzaW9ucyBpbiBEYXRhYmFzZScgKSB9XG5cdFx0XHRcdFx0XHRkZXNjcmlwdGlvbj17IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0J0Rpc2FibGUgdGhpcyBmZWF0dXJlIHRvIHByZXZlbnQgc3VibWlzc2lvbnMgZnJvbSBiZWluZyBzdG9yZWQgaW4geW91ciBkYXRhYmFzZS4gJyArXG5cdFx0XHRcdFx0XHRcdCdOb3RlIHRoYXQgYW55IHN1Ym1pc3Npb25zIHByZXZpb3VzbHkgc3RvcmVkIGluIHRoZSBkYXRhYmFzZSB3aWxsIGJlIHJldGFpbmVkIGFuZCBhdXRvbWF0aWNhbGx5IGRlbGV0ZWQgJyArXG5cdFx0XHRcdFx0XHRcdCdhY2NvcmRpbmcgdG8gdGhlIHJldGVudGlvbiBzY2hlZHVsZSBjb25maWd1cmVkIGluIHRoZSBQcml2YWN5IHNldHRpbmdzIGJlbG93Lidcblx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wb2xsL2NvbXBvbmVudHMvc2V0dGluZ3MvZGF0YS1zdG9yYWdlLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgaXNUcnVlLCB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBSYWRpb1RhYnMgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL3JhZGlvLXRhYnMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbnRhaW5lcic7XG5pbXBvcnQgQ29sIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvY29sJztcbmltcG9ydCBJbnB1dCBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvaW5wdXQnO1xuaW1wb3J0IFN1aVNlbGVjdCBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvc3VpLXNlbGVjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByaXZhY3kgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgaXBSZXRhaW5Gb3JldmVyID1cblx0XHRcdF8uaXNFbXB0eSggZm9ybWluYXRvckRhdGEucG9sbF9pcF9yZXRhaW5fbnVtYmVyICkgfHxcblx0XHRcdGZvcm1pbmF0b3JEYXRhLnBvbGxfaXBfcmV0YWluX251bWJlciA9PT0gJzAnO1xuXG5cdFx0bGV0IGlwUmV0YWluRGVmYXVsdCA9IHRyYW5zbGF0ZSggJ2ZvcmV2ZXInICk7XG5cblx0XHRpZiAoICEgaXBSZXRhaW5Gb3JldmVyICkge1xuXHRcdFx0aXBSZXRhaW5EZWZhdWx0ID0gYCR7IGZvcm1pbmF0b3JEYXRhLnBvbGxfaXBfcmV0YWluX251bWJlciB9ICR7XG5cdFx0XHRcdGZvcm1pbmF0b3JEYXRhLnBvbGxfaXBfcmV0YWluX3VuaXRcblx0XHRcdH1gO1xuXHRcdH1cblxuXHRcdGNvbnN0IHN1Ym1pc3Npb25zUmV0YWluRm9yZXZlciA9XG5cdFx0XHRfLmlzRW1wdHkoIGZvcm1pbmF0b3JEYXRhLnN1Ym1pc3Npb25zX2lwX3JldGFpbl9udW1iZXIgKSB8fFxuXHRcdFx0Zm9ybWluYXRvckRhdGEuc3VibWlzc2lvbnNfaXBfcmV0YWluX251bWJlciA9PT0gJzAnO1xuXG5cdFx0bGV0IHN1Ym1pc2lvbnNSZXRhaW5EZWZhdWx0ID0gdHJhbnNsYXRlKCAnZm9yZXZlcicgKTtcblxuXHRcdGlmICggISBzdWJtaXNzaW9uc1JldGFpbkZvcmV2ZXIgKSB7XG5cdFx0XHRzdWJtaXNpb25zUmV0YWluRGVmYXVsdCA9IGAkeyBmb3JtaW5hdG9yRGF0YS5zdWJtaXNzaW9uc19pcF9yZXRhaW5fbnVtYmVyIH0gJHtcblx0XHRcdFx0Zm9ybWluYXRvckRhdGEuc3VibWlzc2lvbnNfaXBfcmV0YWluX3VuaXRcblx0XHRcdH1gO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNhbk1hbmFnZVNldHRpbmdzID0gaXNUcnVlKCBmb3JtaW5hdG9yRGF0YS51c2VyUGVybWlzc2lvbnMubWFuYWdlX2Zvcm1pbmF0b3Jfc2V0dGluZ3MgKSB8fCBpc1RydWUoIGZvcm1pbmF0b3JEYXRhLnVzZXJQZXJtaXNzaW9ucy5tYW5hZ2Vfb3B0aW9ucyApO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1yb3dcIj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3MtY29sLTFcIj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktc2V0dGluZ3MtbGFiZWxcIj57IHRyYW5zbGF0ZSggJ1ByaXZhY3knICkgfTwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdCdDaG9vc2UgaG93IHlvdSB3YW50IHRvIGhhbmRsZSB0aGlzIHBvbGxcXCdzIGRhdGEgc3RvcmFnZS4gJyArXG5cdFx0XHRcdFx0XHRcIkJ5IGRlZmF1bHQgd2UnbGwgdXNlIHRoZSBjb25maWd1cmF0aW9uIHlvdSd2ZSBzZXQgaW4geW91ciBcIlxuXHRcdFx0XHRcdCl9XG5cdFx0XHRcdFx0eyBjYW5NYW5hZ2VTZXR0aW5ncyAmJlxuXHRcdFx0XHRcdFx0XHQ8YSBocmVmPXsgZm9ybWluYXRvckRhdGEuc2V0dGluZ3NVcmwgKyAnJnNlY3Rpb249c3VibWlzc2lvbnMnIH0gdGFyZ2V0PVwiX2JsYW5rXCI+XG5cdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdnbG9iYWwgcHJpdmFjeSBzZXR0aW5ncy4nICkgfVxuXHRcdFx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHsgISBjYW5NYW5hZ2VTZXR0aW5ncyAmJlxuXHRcdFx0XHRcdFx0XHR0cmFuc2xhdGUoICdnbG9iYWwgcHJpdmFjeSBzZXR0aW5ncy4nIClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3MtY29sLTJcIj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGRcIj5cblxuXHRcdFx0XHRcdFx0PGxhYmVsIGNsYXNzTmFtZT1cInN1aS1zZXR0aW5ncy1sYWJlbFwiPnsgdHJhbnNsYXRlKCAnU3VibWlzc2lvbnMnICkgfTwvbGFiZWw+XG5cblx0XHRcdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiXG5cdFx0XHRcdFx0XHRcdHN0eWxlPXsgeyBtYXJnaW5Cb3R0b206ICcxMHB4JyB9IH1cblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdFx0XCJIb3cgbG9uZyBkbyB5b3Ugd2FudCB0byByZXRhaW4gdGhpcyBwb2xsJ3Mgc3VibWlzc2lvbnMgZm9yP1wiXG5cdFx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXG5cdFx0XHRcdFx0XHQ8ZGl2IHN0eWxlPXsgeyBtYXJnaW5Ub3A6ICcxMHB4JyB9IH0+XG5cblx0XHRcdFx0XHRcdFx0PFJhZGlvVGFic1xuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdD1cImZhbHNlXCJcblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cImVuYWJsZS1zdWJtaXNzaW9ucy1yZXRlbnRpb25cIlxuXHRcdFx0XHRcdFx0XHRcdHNpbXBsZVxuXHRcdFx0XHRcdFx0XHQ+XG5cblx0XHRcdFx0XHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZT1cImZhbHNlXCJcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVXNlIGRlZmF1bHQnICkgfVxuXHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLW5vdGljZSBzdWktYWN0aXZlXCIgc3R5bGU9eyB7IGRpc3BsYXk6ICdibG9jaycgfSB9PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ub3RpY2UtY29udGVudFwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLW5vdGljZS1tZXNzYWdlXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktbm90aWNlLWljb24gc3VpLWljb24taW5mb1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8cD57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0J1lvdXIgZGVmYXVsdCBzZXR0aW5nIHZhbHVlIGlzIHRvIGtlZXAgdGhlIHN1Ym1pc3Npb25zICVzLicsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzOiBbIHN1Ym1pc2lvbnNSZXRhaW5EZWZhdWx0IF0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCkgfTwvcD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0XHRcdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZT1cInRydWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdDdXN0b20nICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0Ym94Q2xhc3M9XCJzdWktdGFiLWJveGVkXCJcblx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1yb3dcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdHlsZT17IHsgbWFyZ2luQm90dG9tOiAnMTBweCcgfSB9XG5cdFx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxDb2wgY29scz1cIjZcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8SW5wdXRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlPVwibnVtYmVyXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT1cIjBcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJzdWJtaXNzaW9ucy1yZXRlbnRpb24tbnVtYmVyXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPVwiMTBcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvQ29sPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8Q29sIGNvbHM9XCI2XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PFN1aVNlbGVjdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT1cImRheXNcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJzdWJtaXNzaW9ucy1yZXRlbnRpb24tdW5pdFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cImRheXNcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdkYXkocyknICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwid2Vla3NcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICd3ZWVrKHMpJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cIm1vbnRoc1wiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ21vbnRoKHMpJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cInllYXJzXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAneWVhcihzKScgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L29wdGlvbj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L1N1aVNlbGVjdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PC9Db2w+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQnTGVhdmUgdGhlIGZpZWxkIGJsYW5rIHRvIHJldGFpbiBzdWJtaXNzaW9ucyBmb3JldmVyLidcblx0XHRcdFx0XHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0XHRcdFx0PC9SYWRpb1RhYnM+XG5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1mb3JtLWZpZWxkXCI+XG5cblx0XHRcdFx0XHRcdDxsYWJlbCBjbGFzc05hbWU9XCJzdWktc2V0dGluZ3MtbGFiZWxcIj57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0J0lQIFJldGVudGlvbidcblx0XHRcdFx0XHRcdCkgfTwvbGFiZWw+XG5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPnsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHQnQ2hvb3NlIGhvdyBsb25nIHRvIHJldGFpbiBJUCBhZGRyZXNzIGJlZm9yZSBhIHN1Ym1pc3Npb24gaXMgJyArXG5cdFx0XHRcdFx0XHRcdCdhbm9ueW1pemVkLiBLZWVwIGluIG1pbmQgdGhhdCB0aGUgSVAgYWRkcmVzcyBpcyBiZWluZyB1c2VkICcgK1xuXHRcdFx0XHRcdFx0XHQnaW4gY2hlY2tpbmcgbXVsdGlwbGUgdm90ZXMgZnJvbSBzYW1lIHVzZXIuJ1xuXHRcdFx0XHRcdFx0KSB9PC9zcGFuPlxuXG5cdFx0XHRcdFx0XHQ8ZGl2IHN0eWxlPXsgeyBtYXJnaW5Ub3A6ICcxMHB4JyB9IH0+XG5cblx0XHRcdFx0XHRcdFx0PFJhZGlvVGFic1xuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdD1cImZhbHNlXCJcblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cImVuYWJsZS1pcC1hZGRyZXNzLXJldGVudGlvblwiXG5cdFx0XHRcdFx0XHRcdFx0c2ltcGxlXG5cdFx0XHRcdFx0XHRcdD5cblxuXHRcdFx0XHRcdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZT1cImZhbHNlXCJcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVXNlIGRlZmF1bHQnICkgfVxuXHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLW5vdGljZVwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8cD57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQnWW91ciBkZWZhdWx0IHNldHRpbmcga2VlcCB0aGUgSVBzICVzLicsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJnczogWyBpcFJldGFpbkRlZmF1bHQgXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCkgfTwvcD5cblx0XHRcdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHRcdFx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlPVwidHJ1ZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0N1c3RvbScgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRib3hDbGFzcz1cInN1aS10YWItYm94ZWRcIlxuXHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLXJvd1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0eWxlPXsgeyBtYXJnaW5Cb3R0b206ICcxMHB4JyB9IH1cblx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PENvbCBjb2xzPVwiNlwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxJbnB1dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU9XCJudW1iZXJcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPVwiMFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cImlwLWFkZHJlc3MtcmV0ZW50aW9uLW51bWJlclwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj1cIjEwXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L0NvbD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PENvbCBjb2xzPVwiNlwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxTdWlTZWxlY3Rcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9XCJkYXlzXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwiaXAtYWRkcmVzcy1yZXRlbnRpb24tdW5pdFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cImRheXNcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdkYXkocyknICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwid2Vla3NcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICd3ZWVrKHMpJyApfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwibW9udGhzXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnbW9udGgocyknICl9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L29wdGlvbj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJ5ZWFyc1wiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ3llYXIocyknICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PC9TdWlTZWxlY3Q+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvQ29sPlxuXHRcdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0J0xlYXZlIHRoZSBmaWVsZCBibGFuayB0byBrZWVwIElQcyBmb3JldmVyLidcblx0XHRcdFx0XHRcdFx0XHRcdCkgfTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0XHRcdFx0XHQ8L1JhZGlvVGFicz5cblxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BvbGwvY29tcG9uZW50cy9zZXR0aW5ncy9wcml2YWN5LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==