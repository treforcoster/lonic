/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 807);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = React;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.randNumber = randNumber;
exports.generateWrapperId = generateWrapperId;
exports.getWrapper = getWrapper;
exports.getDefaultValue = getDefaultValue;
exports.getThemePrefix = getThemePrefix;
exports.restrictedGroupFields = restrictedGroupFields;
exports.lonerFields = lonerFields;
exports.getSubmissionBehaviors = getSubmissionBehaviors;
exports.countFieldsByType = countFieldsByType;
exports.getMaxIDByType = getMaxIDByType;
exports.getMaxID = getMaxID;
exports.generateValue = generateValue;
exports.hasFieldType = hasFieldType;
exports.getFieldsByType = getFieldsByType;
exports.mapFieldsByType = mapFieldsByType;
exports.getFieldLabel = getFieldLabel;
exports.fieldExist = fieldExist;
exports.buildFieldObject = buildFieldObject;
exports.buildFieldObjectFromSlug = buildFieldObjectFromSlug;
exports.getFieldType = getFieldType;
exports.getForminatorField = getForminatorField;
exports.insertInPosition = insertInPosition;
exports.replaceInPosition = replaceInPosition;
exports.translate = translate;
exports.getFontVariants = getFontVariants;
exports.ucfirst = ucfirst;
exports.getConditionLabel = getConditionLabel;
exports.convertTimestamp = convertTimestamp;
exports.getFields = getFields;
exports.getDateFields = getDateFields;
exports.getNameFields = getNameFields;
exports.getRangeSliderFields = getRangeSliderFields;
exports.fieldHasNumber = fieldHasNumber;
exports.fieldHasCalcs = fieldHasCalcs;
exports.fieldFormula = fieldFormula;
exports.fieldHasOptions = fieldHasOptions;
exports.getFieldValues = getFieldValues;
exports.getAddressFields = getAddressFields;
exports.getTimeFields = getTimeFields;
exports.getFieldAutofillProviders = getFieldAutofillProviders;
exports.getRuleLabel = getRuleLabel;
exports.isEmailWp = isEmailWp;
exports.suiDelegateEvents = suiDelegateEvents;
exports.getChartType = getChartType;
exports.getCalculationFields = getCalculationFields;
exports.select2Tags = select2Tags;
exports.isFieldRequired = isFieldRequired;
exports.hasFieldWithAttribute = hasFieldWithAttribute;
exports.hasPostdataFieldWithMultiselect = hasPostdataFieldWithMultiselect;
exports.getPersonalityQuestions = getPersonalityQuestions;
exports.getPlanValidation = getPlanValidation;
exports.isTrue = isTrue;
exports.parseQueryString = parseQueryString;
exports.goToLink = goToLink;

var _i18nWpPlugin = __webpack_require__(52);

var _i18nWpPlugin2 = _interopRequireDefault(_i18nWpPlugin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Returns unique 4 digit number
 *
 * @return {number}
 **/
function randNumber() {
	//return Math.floor( Math.random() * 9999 );
	var min = Math.ceil(1000);
	var max = Math.floor(9999);
	return Math.floor(Math.random() * (max - min) + min);
}

/**
 * Returns wrapper uniq ID
 *
 * @return {string}
 **/
function generateWrapperId() {
	return 'wrapper-' + randNumber() + '-' + randNumber();
}

/**
 * Returns wrapper object by wrapper ID
 *
 * @param {string} wrapperID ID of the wrapper
 * @param {array} wrappers current wrappers
 *
 * @return {string}
 **/
function getWrapper(wrapperID, wrappers) {
	var wrapperObject = void 0;

	wrappers.map(function (wrapper) {
		if (wrapper.wrapper_id === wrapperID) {
			wrapperObject = wrapper;
		}
	});

	return wrapperObject;
}

/**
 * Return passed default value or empty if it's Basic theme
 *
 * @param {String} getDefaultValue Default value
 * @param {String} formDesign Property
 * @return {String}
 */
function getDefaultValue(props, getDefaultValue) {
	return getThemeName(props) !== 'basic' ? getDefaultValue : '';
}

/**
 * Get prefix for properties if it's Basic theme
 *
 * @param {type} formDesign Property
 * @return {String}
 */
function getThemePrefix(props) {
	return getThemeName(props) === 'basic' ? 'basic-' : '';
}

/**
 * Get design theme name
 *
 * @param {type} propsProperties
 * @return {String}
 */
function getThemeName(props) {
	if ("undefined" !== typeof props.formDesign) {
		return props.formDesign;
	}

	if ("undefined" !== typeof props.settings && "undefined" !== typeof props.settings['forminator-poll-design']) return props.settings['forminator-poll-design'];

	if ("undefined" !== typeof props.quizDesign) return props.quizDesign;

	return '';
}

/**
 * Returns all field types disabled inside Group Fields
 *
 * @return {array}
 */
function restrictedGroupFields() {
	return ['page-break', 'paypal', 'stripe', 'signature', 'captcha', 'postdata', 'group'];
}

/**
 * Returns all field types that should only occupy a single row. ;(
 * Field can only be added for new/unreleased field types.
 *
 * @return {array}
 */
function lonerFields() {
	return ['pdf-page-break', 'all-form-data'];
}

/**
 * Returns all behavior types
 *
 * @return {object}
 */
function getSubmissionBehaviors() {
	return {
		'behaviour-thankyou': translate('Inline Message'),
		'behaviour-redirect': translate('Redirect user to a URL'),
		'behaviour-hide': translate('Hide form')
	};
}

/**
 * Returns count of existing fields by type
 *
 * @param {string} type type of field
 * @param {array} wrappers current wrappers
 *
 * @return {number}
 **/
function countFieldsByType(type, wrappers) {
	var counter = 0;

	wrappers.map(function (wrapper) {
		wrapper.fields.map(function (field) {
			if (field.type === type) {
				counter++;
			}
		});
	});

	return counter;
}

/**
 * Returns max ID number by type
 *
 * @param {string} type type of field
 * @param {array} wrappers current wrappers
 *
 * @return {number}
 **/
function getMaxIDByType(type, wrappers) {
	var fieldIDs = [];

	wrappers.map(function (wrapper) {
		wrapper.fields.map(function (field) {
			if (field.type === type) {
				var fieldId = field.element_id;
				var fieldIdArray = fieldId.split('-');
				switch (field.type) {
					case 'page-break':
					case 'rich-text':
						fieldIDs.push(parseInt(fieldIdArray[2]));
						break;
					case 'all-form-data':
					case 'pdf-page-break':
						fieldIDs.push(parseInt(fieldIdArray[3]));
						break;
					default:
						fieldIDs.push(parseInt(fieldIdArray[1]));
						break;
				}
			}
		});
	});

	var maxValue = 0;

	if (!_.isEmpty(fieldIDs)) {
		maxValue = _.max(fieldIDs);
	}

	return parseInt(maxValue) + 1;
}

function getMaxID(type, values) {
	var ids = [];

	_.map(values, function (value) {
		var fieldId = value.element_id;
		var fieldIdArray = fieldId.split('-');

		ids.push(parseInt(fieldIdArray[1]));
	});

	var maxValue = 0;

	if (!_.isEmpty(ids)) {
		maxValue = _.max(ids);
	}

	return parseInt(maxValue) + 1;
}

/**
 * Returns Label converted to value
 *
 * @param {string} value entered label
 *
 * @return {string}
 **/
function generateValue(value) {
	value = value.trim().replace(/\s+|\//g, '-');

	return value;
}

/**
 * Return true if it's Global Appearance Preset
 *
 * @param {array} wrappers current wrappers
 * @return {Boolean}
 */
function isGlobalPreset(wrappers) {
	return null === wrappers;
}

/**
 * Returns true if field exist
 *
 * @param {string} type type of field
 * @param {array} wrappers current wrappers
 *
 * @return {bool}
 **/
function hasFieldType(type, wrappers) {
	var counter = 0;

	if (isGlobalPreset(wrappers)) {
		return true;
	}

	wrappers.map(function (wrapper) {
		wrapper.fields.map(function (field) {
			if (field.type === type) {
				counter++;
			}
		});
	});

	return counter > 0;
}

/**
 * Returns array of fields by type
 *
 * @param {string} type type of field
 * @param {array} wrappers current wrappers
 *
 * @return {array}
 **/
function getFieldsByType(type, wrappers) {
	var fields = [];

	wrappers.map(function (wrapper) {
		wrapper.fields.map(function (field) {
			if (field.type === type) {
				fields.push(field);
			}
		});
	});

	return fields;
}

/**
 * Returns array of fields by type mapped for select field
 *
 * @param {string} type type of field
 * @param {array} wrappers current wrappers
 *
 * @return {array}
 **/
function mapFieldsByType(type, wrappers) {
	var fields = [];
	var fieldsByType = getFieldsByType(type, wrappers);
	fieldsByType.map(function (field) {
		var label = field.field_label;

		if (type === 'address') {
			label = field.element_id;
		}

		fields.push({
			value: field.element_id,
			label: label,
			element_id: field.element_id
		});
	});

	return fields;
}

/**
 * Returns field label by ID
 *
 * @param {string} id field ID
 * @param {array} wrappers current wrappers
 *
 * @return {string}
 **/
function getFieldLabel(id, wrappers) {
	var label = '';
	wrappers.map(function (wrapper) {
		wrapper.fields.map(function (field) {
			if (field.element_id === id) {
				label = field.field_label;
			}
		});
	});

	return label;
}
/**
 * Returns true or false if field exist
 *
 * @param {string} id field ID
 * @param {array} wrappers current wrappers
 *
 * @return {bool}
 **/
function fieldExist(id, wrappers) {
	var exist = 0;

	wrappers.map(function (wrapper) {
		wrapper.fields.map(function (field) {
			if (field.element_id === id) {
				exist++;
			}
		});
	});

	return exist > 0;
}

/**
 * Returns field object with defaults from slug
 *
 * @param {object} field field
 * @param {string} wrapperID wrapper id
 * @param {number} cols columns
 * @param {array} wrappers wrappers
 * @param {array} tempNewFields New Siblings Fields that aren't included in wrappers yet
 *
 * @return {object}
 **/
function buildFieldObject(field, wrapperID, cols, wrappers, tempNewFields) {
	tempNewFields = tempNewFields || [];
	var wraps = [].concat(_toConsumableArray(wrappers), [{ fields: tempNewFields }]);
	var fieldNumber = getMaxIDByType(field.type, wraps);

	return _.extend(field, {
		element_id: field.type + '-' + fieldNumber,
		formID: wrapperID,
		cols: cols
	});
}

/**
 * Returns field object with defaults from slug
 *
 * @param {string} slug field slug
 * @param {array} wrappers wrappers
 * @param {string} wrapepr ID
 *
 * @return {object}
 **/
function buildFieldObjectFromSlug(slug, wrappers, wrapperID) {
	var field = forminatorData.fields.find(function (fieldData) {
		return fieldData.slug === slug;
	});

	var fieldNumber = getMaxIDByType(field.type, wrappers);

	var props = {
		element_id: field.type + '-' + fieldNumber,
		type: field.type,
		options: field.options,
		cols: 12,
		conditions: {},
		wrapper_id: wrapperID
	};

	if (_.contains(['calculation', 'number', 'slider', 'radio', 'currency', 'select', 'checkbox'], field.type)) {
		props['hidden_behavior'] = 'zero';
	}

	return _.extend(props, JSON.parse(JSON.stringify(field.defaults)));
}

/**
 * Returns field type by field object
 *
 * @param {object} field field
 *
 * @return {string}
 **/
function getFieldType(field) {
	var type = field.type;


	return type;
}

/**
 * Returns forminatorData.fields(PHP) from field object from builder
 *
 * Comparing `type`
 *
 * @param {object} field field
 *
 * @return {object}
 **/
function getForminatorField(field) {
	return forminatorData.fields.find(function (forminatorField) {
		return forminatorField.type === field.type;
	});
}

/**
 * Insert item into array in specific position
 *
 * @param {array} array array
 * @param {number} position position
 * @param {any} replacement replacement
 *
 * @return {array} array
 */
function insertInPosition(array, position, replacement) {
	return [].concat(_toConsumableArray(array.slice(0, position)), [replacement], _toConsumableArray(array.slice(position)));
}

/**
 * Replace item in array in specific position
 *
 * @param {array} array array
 * @param {number} position position
 * @param {any} replacement replacement
 *
 * @return {array} array
 */
function replaceInPosition(array, position, replacement) {
	return [].concat(_toConsumableArray(array.slice(0, position)), [replacement], _toConsumableArray(array.slice(position + 1)));
}

/**
 * Translate string
 *
 * @see i18n.translate
 *
 * @return {string} translated string
 */
function translate() {
	return _i18nWpPlugin2.default.translate.apply(null, arguments);
}

/**
 * Returns variants for selected font
 *
 * @param {string} value font
 * @param {array} fonts fonts

 * @return {array}
 **/
function getFontVariants(value, fonts) {
	var fontObject = _.filter(fonts, function (font) {
		return font.family === value;
	});

	if (!_.isUndefined(fontObject[0]) && !_.isUndefined(fontObject[0].variants)) {
		return fontObject[0].variants;
	}

	return [translate('None')];
}

/**
 * Capitalize string
 *
 * @param {string} value value
 * @returns {string}
 **/
function ucfirst(value) {
	return value.charAt(0).toUpperCase() + value.slice(1);
}

/**
 * Get condition label
 *
 * @returns {string}
 */
function getConditionLabel(field, condition) {
	var value = condition.value;
	var valueLabel = void 0;

	// If option field and have values, we need the option updateValue
	// Else return the field value
	if (field.hasOptions && field.values.length > 0) {
		var label = void 0;

		// Check in values
		label = _.where(field.values, { value: value })[0];

		// If label is not set, check in labels
		if (!label) {
			label = _.where(field.values, { label: value })[0];
		}

		// If label is still not found, return
		if (!label) {
			return;
		}

		valueLabel = label.label;
	} else if ('date' === field.field_type && ['is_before', 'is_after'].includes(condition.rule)) {
		// Get formatted date string
		valueLabel = convertTimestamp(value);
	} else {
		valueLabel = value;
	}

	// If label empty, return null
	if (_.isEmpty(valueLabel)) {
		return translate('null');
	}

	return valueLabel;
}

/*
 * Convert date from timestamp
 */
function convertTimestamp(value) {
	if (!isNaN(Number(value))) {
		// Convert timestamp to Date object
		var date = new Date(value * 1);

		// Options for formatting the date
		var options = { day: 'numeric', month: 'numeric', year: 'numeric' };

		// Get the formatted date string
		value = date.toLocaleDateString('en-US', options);
	}

	return value;
}

/*
 * Returns builder fields from wrappers
 */
function getFields(wrappers, disabledFields, extra, includedFields, excludeSubFields) {
	var fieldsArray = [];

	if (_.isUndefined(disabledFields)) {
		disabledFields = ['page-break', 'postdata', 'total', 'product', 'captcha'];
	}
	if (Array.isArray(disabledFields) && !isTrue(excludeSubFields)) {
		disabledFields.push('group');
	}
	var main_date_field = false;

	if (!_.isUndefined(extra) && !_.isUndefined(extra.main_date_field) && extra.main_date_field === true) {
		main_date_field = true;
	}

	// Loop all wrappers we have
	wrappers.map(function (wrapper) {
		var fields = wrapper.fields,
		    parentGroup = wrapper.parent_group;
		fields.map(function (field) {
			// Check if field is included
			if (!_.isUndefined(includedFields)) {
				if (!_.contains(includedFields, field.type)) {
					return;
				}
			} else if (_.contains(disabledFields, field.type)) {
				// Check if field is disabled
				return;
			}

			var label = void 0;

			// Get field label
			if (!_.isUndefined(field.field_label) && !_.isEmpty(field.field_label)) {
				label = field.field_label;
			} else {
				label = field.type;
				label = ucfirst(label);
			}

			// If field is name, get all existing sub fields
			if (field.type === 'name' && !isTrue(excludeSubFields)) {
				fieldsArray = fieldsArray.concat(getNameFields(field, label, parentGroup));
			} else if (field.type === 'address' && !isTrue(excludeSubFields)) {
				fieldsArray = fieldsArray.concat(getAddressFields(field, label, parentGroup));
			} else if (field.type === 'slider' && field.slider_type === 'range') {
				fieldsArray = fieldsArray.concat(getRangeSliderFields(field, label, parentGroup));
			} else if (field.type === 'time' && !isTrue(excludeSubFields)) {
				fieldsArray = fieldsArray.concat(getTimeFields(field, label, parentGroup));
			} else if (field.type === 'date' && field.field_type !== 'picker' && main_date_field === false) {
				//skip now
			} else {
				fieldsArray.push({
					element_id: field.element_id,
					parent_group: parentGroup,
					required: field.required,
					field_type: field.type,
					field_slug: field.type,
					label: label,
					values: getFieldValues(field),
					hasOptions: fieldHasOptions(field),
					hasCalcs: fieldHasCalcs(field),
					formula: fieldFormula(field),
					isNumber: fieldHasNumber(field),
					fieldData: field
				});
			}
			if (field.type === 'date' && field.field_type !== 'picker' && !isTrue(excludeSubFields)) {
				fieldsArray = fieldsArray.concat(getDateFields(field, label, parentGroup));
			}
		});
	});
	return fieldsArray;
}
/**
 * Get name_fields (support dropdown & input date fields)
 * @param {object} field field to parse
 * @param {string} fieldLabel parent label
 * @returns {Array}
 **/
function getDateFields(field, fieldLabel, parentGroup) {
	var fieldsArray = [];

	var day_label = void 0;
	if (!_.isUndefined(field.day_label) && !_.isEmpty(field.day_label)) {
		day_label = fieldLabel + ' - ' + field.day_label;
	} else {
		day_label = fieldLabel + ' - ' + translate('Day');
	}

	var month_label = void 0;
	if (!_.isUndefined(field.month_label) && !_.isEmpty(field.month_label)) {
		month_label = fieldLabel + ' - ' + field.month_label;
	} else {
		month_label = fieldLabel + ' - ' + translate('Month');
	}

	var year_label = void 0;
	if (!_.isUndefined(field.year_label) && !_.isEmpty(field.year_label)) {
		year_label = fieldLabel + ' - ' + field.year_label;
	} else {
		year_label = fieldLabel + ' - ' + translate('Year');
	}
	if (field.field_type === 'input') {
		fieldsArray.push({
			element_id: field.element_id + '-day',
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type + '-day',
			label: day_label,
			values: false,
			hasOptions: false,
			isNumber: true
		}, {
			element_id: field.element_id + '-month',
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type + '-month',
			label: month_label,
			values: false,
			hasOptions: false,
			isNumber: true
		}, {
			element_id: field.element_id + '-year',
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type + '-year',
			label: year_label,
			values: false,
			hasOptions: false,
			isNumber: true
		});
	} else {
		fieldsArray.push({
			element_id: field.element_id + '-day',
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type + '-day',
			label: day_label,
			values: getFieldValues(field),
			hasOptions: fieldHasOptions(field),
			isNumber: fieldHasNumber(field)
		}, {
			element_id: field.element_id + '-month',
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type + '-month',
			label: month_label,
			values: getFieldValues(field),
			hasOptions: fieldHasOptions(field),
			isNumber: fieldHasNumber(field)
		}, {
			element_id: field.element_id + '-year',
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type + '-year',
			label: year_label,
			values: getFieldValues(field),
			hasOptions: fieldHasOptions(field),
			isNumber: fieldHasNumber(field)
		});
	}

	return fieldsArray;
}

/**
 * Get name_fields (support multiple name fields)
 * @param {object} field field to parse
 * @param {string} fieldLabel parent label
 * @returns {Array}
 **/
function getNameFields(field, fieldLabel, parentGroup) {
	var fieldsArray = [];
	//handle multiple name
	if (field.multiple_name === 'true' || true === field.multiple_name) {
		[{
			attr: 'prefix',
			label: 'prefix_label',
			element_suffix: 'prefix',
			hasOptions: true,
			values: [{ label: 'Mr.', value: 'Mr' }, { label: 'Mrs.', value: 'Mrs' }, { label: 'Ms.', value: 'Ms' }, { label: 'Mx.', value: 'Mx' }, { label: 'Miss', value: 'Miss' }, { label: 'Dr.', value: 'Dr' }, { label: 'Prof.', value: 'Prof' }],
			isNumber: false
		}, {
			attr: 'fname',
			label: 'fname_label',
			element_suffix: 'first-name',
			hasOptions: false,
			values: false,
			isNumber: false
		}, {
			attr: 'mname',
			label: 'mname_label',
			element_suffix: 'middle-name',
			hasOptions: false,
			values: false,
			isNumber: false
		}, {
			attr: 'lname',
			label: 'lname_label',
			element_suffix: 'last-name',
			hasOptions: false,
			values: false,
			isNumber: false
		}].map(function (attribute) {
			if (field[attribute.attr] === 'true' || field[attribute.attr] === true) {
				var label = void 0;
				if (!_.isUndefined(field[attribute.label]) && !_.isEmpty(field[attribute.label])) {
					label = fieldLabel + ' - ' + field[attribute.label];
				} else {
					label = fieldLabel + ' - ';
				}

				fieldsArray.push({
					element_id: field.element_id + '-' + attribute.element_suffix,
					parent_group: parentGroup,
					required: field.required,
					field_type: field.type,
					field_slug: field.type + '-' + attribute.element_suffix,
					label: label,
					values: attribute.values,
					hasOptions: attribute.hasOptions,
					isNumber: attribute.isNumber
				});
			}
		});
	} else {
		fieldsArray.push({
			element_id: field.element_id,
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type,
			label: fieldLabel,
			values: getFieldValues(field),
			hasOptions: fieldHasOptions(field),
			isNumber: fieldHasNumber(field)
		});
	}

	return fieldsArray;
}

/**
 * Get Range Slider fields
 * @param {object} field field to parse
 * @param {string} fieldLabel parent label
 * @returns {Array}
 **/
function getRangeSliderFields(field, fieldLabel, parentGroup) {
	var fieldsArray = [];
	[{
		suffix: 'min'
	}, {
		suffix: 'max'
	}].map(function (attribute) {
		fieldsArray.push({
			element_id: field.element_id + '-' + attribute.suffix,
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type + '-' + attribute.suffix,
			label: fieldLabel + ' - ' + attribute.suffix,
			isNumber: true,
			hasCalcs: fieldHasCalcs(field)
		});
	});

	return fieldsArray;
}

/*
 * Returns if field has number
 */
function fieldHasNumber(field) {
	if (_.contains(['calculation', 'number', 'slider', 'phone', 'currency'], field.type)) {
		return true;
	}

	return false;
}

/*
 * Returns if field has calculations enabled
 */
function fieldHasCalcs(field) {
	if (field.calculations === 'true' || field.calculations === true) {
		return true;
	}

	return false;
}

function fieldFormula(field) {
	if (field.formula) {
		return field.formula;
	}

	return false;
}

/*
 * Returns if field has options
 */
function fieldHasOptions(field) {
	if (field.type === 'select' || field.type === 'checkbox' || field.type === 'radio') {
		return true;
	}

	return false;
}

/*
 * Returns field values
 */
function getFieldValues(field) {
	var type = field.type;

	if (type === 'select' || type === 'checkbox' || type === 'radio') {
		return field.options;
	}

	return false;
}

/**
 * Get address_fields (support multi sub fields)
 * @param {object} field field
 * @param {string} fieldLabel lbel
 * @returns {array}
 **/
function getAddressFields(field, fieldLabel, parentGroup) {
	var fieldsArray = [];

	[{
		attr: 'street_address',
		label: 'street_address_label',
		element_suffix: 'street_address',
		hasOptions: false,
		values: false,
		isNumber: false
	}, {
		attr: 'address_line',
		label: 'address_line_label',
		element_suffix: 'address_line',
		hasOptions: false,
		values: false,
		isNumber: false
	}, {
		attr: 'address_city',
		label: 'address_city_label',
		element_suffix: 'city',
		hasOptions: false,
		values: false,
		isNumber: false
	}, {
		attr: 'address_state',
		label: 'address_state_label',
		element_suffix: 'state',
		hasOptions: false,
		values: false,
		isNumber: false
	}, {
		attr: 'address_zip',
		label: 'address_zip_label',
		element_suffix: 'zip',
		hasOptions: false,
		values: false,
		isNumber: false
	}, {
		attr: 'address_country',
		label: 'address_country_label',
		element_suffix: 'country',
		hasOptions: false,
		values: false,
		isNumber: false
	}].map(function (attribute) {
		if (isTrue(field[attribute.attr])) {
			var label = void 0;
			if (!_.isUndefined(field[attribute.label]) && !_.isEmpty(field[attribute.label])) {
				label = fieldLabel + ' - ' + field[attribute.label];
			} else {
				label = fieldLabel + ' - ';
			}

			fieldsArray.push({
				element_id: field.element_id + '-' + attribute.element_suffix,
				parent_group: parentGroup,
				required: field.required,
				field_type: field.type,
				field_slug: field.type + '-' + attribute.element_suffix,
				label: label,
				values: attribute.values,
				hasOptions: attribute.hasOptions,
				isNumber: attribute.isNumber
			});
		}
	});

	return fieldsArray;
}

/**
 * Get time_fields (support multi sub fields)
 * @param {object} field field
 * @param {string} fieldLabel label
 * @returns {array}
 **/
function getTimeFields(field, fieldLabel, parentGroup) {
	var fieldsArray = [];

	var hh_label = void 0;
	if (!_.isUndefined(field.hh_label) && !_.isEmpty(field.hh_label)) {
		hh_label = fieldLabel + ' - ' + field.hh_label;
	} else {
		hh_label = fieldLabel + ' - ' + translate('Hour');
	}

	var mm_label = void 0;
	if (!_.isUndefined(field.mm_label) && !_.isEmpty(field.mm_label)) {
		mm_label = fieldLabel + ' - ' + field.mm_label;
	} else {
		mm_label = fieldLabel + ' - ' + translate('Minute');
	}

	fieldsArray.push({
		element_id: field.element_id + '-hours',
		parent_group: parentGroup,
		required: field.required,
		field_type: field.type,
		field_slug: field.type + '-hours',
		label: hh_label,
		values: false,
		hasOptions: false,
		isNumber: true
	}, {
		element_id: field.element_id + '-minutes',
		parent_group: parentGroup,
		required: field.required,
		field_type: field.type,
		field_slug: field.type + '-minutes',
		label: mm_label,
		values: false,
		hasOptions: false,
		isNumber: true
	});

	if (field.time_type === 'twelve') {
		fieldsArray.push({
			element_id: field.element_id + '-ampm',
			parent_group: parentGroup,
			required: field.required,
			field_type: field.type,
			field_slug: field.type + '-ampm',
			label: fieldLabel + '-AM/PM',
			values: [{ label: 'AM', value: 'am' }, { label: 'PM', value: 'pm' }],
			hasOptions: true,
			isNumber: false
		});
	}

	return fieldsArray;
}

/**
 *
 * @param {string} fieldType fieldType
 * @returns {array}
 **/
function getFieldAutofillProviders(fieldType) {
	var autofillProviders = [];
	var fieldSettings = forminatorData.fields.filter(function (field) {
		return field.type === fieldType;
	});

	if (fieldSettings.length < 1) {
		return [];
	}

	fieldSettings = fieldSettings[0];
	if (!_.isUndefined(fieldSettings.autofill_settings)) {
		autofillProviders = fieldSettings.autofill_settings;
	}

	return autofillProviders;
}

/**
 * Returns label by rule value
 *
 * @param {string} rule rule
 * @param {string} type type
 * @param {mix} type value ( optional )
 * @returns {string}
 **/
function getRuleLabel(rule, type, value) {
	var val = !_.isUndefined(value) ? value : '';
	switch (rule) {
		case 'is':
			return translate('is');
		case 'is_not':
			return translate('is not');
		case 'day_is':
			return translate('day is');
		case 'day_is_not':
			return translate('day is not');
		case 'month_is_not':
			return translate('month is not');
		case 'month_is':
			return translate('month is');
		case 'is_before':
			return translate('is before');
		case 'is_after':
			return translate('is after');
		case 'is_before_n_or_more_days':
			return translate('is before %s or more days from current date').replace('%s', val);
		case 'is_before_less_than_n_days':
			return translate('is before less than %s days from current date').replace('%s', val);
		case 'is_after_n_or_more_days':
			return translate('is after %s or more days from current date').replace('%s', val);
		case 'is_after_less_than_n_days':
			return translate('is after less than %s days from current date').replace('%s', val);
		case 'is_great':
			return translate('is greater than');
		case 'is_less':
			return translate('is less than');
		case 'contains':
			return translate('contains');
		case 'starts':
			return translate('starts with');
		case 'ends':
			return translate('ends with');
		case 'is_correct':
			return translate('is correct');
		case 'is_incorrect':
			return translate('is incorrect');
		// Personality quiz rules.
		case 'is_final_result':
			return translate('is final result');
		case 'is_not_final_result':
			return translate('is not final result');
		default:
			return '-';
	}
}

/**
 * Return if value is valid email wp
 *
 * @param {string} value value to check
 * @returns {bool}
 **/
function isEmailWp(value) {
	if (value.length < 6) {
		return false;
	}

	// Test for an @ character after the first position
	if (value.indexOf('@', 1) < 0) {
		return false;
	}

	// Split out the local and domain parts
	var parts = value.split('@', 2);

	// LOCAL PART
	// Test for invalid characters
	if (!parts[0].match(/^[a-zA-Z0-9!#$%&'*+\/=?^_`{|}~\.-]+$/)) {
		return false;
	}

	// DOMAIN PART
	// Test for sequences of periods
	if (parts[1].match(/\.{2,}/)) {
		return false;
	}

	var domain = parts[1];
	// Split the domain into subs
	var subs = domain.split('.');
	if (subs.length < 2) {
		return false;
	}

	var subsLen = subs.length;
	for (var i = 0; i < subsLen; i++) {
		// Test for invalid characters
		if (!subs[i].match(/^[a-z0-9-]+$/i)) {
			return false;
		}
	}
	return true;
}

/**
 * Display SUI JS Elements
 **/
function suiDelegateEvents() {
	if ('object' !== _typeof(window.SUI)) {
		return;
	}

	// Time it out
	setTimeout(function () {
		// Rebind Accordion scripts
		SUI.suiAccordion(jQuery('.sui-accordion'));

		// Rebind Tabs scripts
		SUI.suiTabs(jQuery('.sui-tabs'));

		// Rebind Select2 scripts.
		jQuery('select.sui-select[data-theme="icon"]').each(function () {
			SUI.select.initIcon(jQuery(this));
		});

		jQuery('select.sui-select[data-theme="color"]').each(function () {
			SUI.select.initColor(jQuery(this));
		});

		jQuery('select.sui-select[data-theme="search"]').each(function () {
			SUI.select.initSearch(jQuery(this));
		});

		jQuery('select.sui-select:not([data-theme]):not(.custom-select2):not(.fui-multi-select)').each(function () {
			SUI.select.init(jQuery(this));
		});

		// Rebind Variables scripts.
		jQuery('select.sui-variables').each(function () {
			SUI.select.initVars(jQuery(this));
		});

		// Rebind Circle scripts
		SUI.loadCircleScore(jQuery('.sui-circle-score'));

		// Rebind Password scripts
		SUI.showHidePassword();
	}, 50);
}

/**
 * Returns chart type from settings
 *
 * @param {array} settings Settings array
 *
 * @return {string} Chart type
 */
function getChartType(settings) {
	var type = 'none';

	if (_typeof(settings['results-behav']) && _typeof(settings['results-style'])) {
		if (settings['results-behav'] === 'link_on' || settings['results-behav'] === 'show_after') {
			type = settings['results-style'];
		}
	}

	return type;
}

/**
 * Returns array of calculation fields
 *
 * @param {array} wrappers current wrappers
 *
 * @return {array}
 **/
function getCalculationFields(wrappers) {
	var disabled = [];

	// Push disabled fields
	_.each(forminatorData.fields, function (field) {
		if (field.type !== 'calculation') {
			disabled.push(field.type);
		}
	});

	return getFields(wrappers, disabled);
}

/**
 * Display Select2 with multiple tags
 *
 * @param {jQuery} $el jQuery wrapper el to find
 * @param {object} options Select2 options
 **/
function select2Tags($el, options) {
	options = _.defaults(options, {
		allowClear: true,
		dropdownCssClass: 'sui-select-dropdown'
	});

	// SELECT2 forminator-ui-tags
	$el.find('select.sui-select.fui-multi-select').each(function () {
		// reorder-support, it will preserve order based on user tags added
		if (jQuery(this).attr('data-reorder')) {
			jQuery(this).on('select2:select', function (e) {
				var elm = e.params.data.element,
				    $elm = jQuery(elm),
				    $t = jQuery(this);
				$t.append($elm);
				$t.trigger('change.select2');
			});
		}
		jQuery(this).SUIselect2(options);
	});
}

/**
 * Returns if field is required
 *
 * @param {object} field field
 *
 * @return {bool}
 **/
function isFieldRequired(field) {
	// Handle name field sub fields
	if (field.type === 'name') {
		if (field.multiple_name === 'true' || field.multiple_name === true) {
			// We have multi field

			if (field['prefix_required'] || field['fname_required'] || field['mname_required'] || field['lname_required']) {
				return true;
			} else {
				return false;
			}
		}
	}

	// Handle name field sub fields
	if (field.type === 'address') {
		if (field['street_address_required'] || field['address_line_required'] || field['address_city_required'] || field['address_state_required'] || field['address_zip_required'] || field['address_country_required']) {
			return true;
		} else {
			return false;
		}
	}

	// Fallback to default required prop
	return field.required;
}

/*
 * Returns if form has a field with requested attribute and the requested value
 */
function hasFieldWithAttribute(wrappers, type, attribute, value) {
	var counter = 0;

	if (isGlobalPreset(wrappers)) {
		return true;
	}

	wrappers.map(function (wrapper) {
		wrapper.fields.map(function (field) {
			if (type === field.type && value === field[attribute]) {
				counter++;
			}
		});
	});

	return counter > 0;
}

/*
 * Returns if form has a field with multiple category
 */
function hasPostdataFieldWithMultiselect(wrappers) {
	var counter = 0;

	if (isGlobalPreset(wrappers)) {
		return true;
	}

	wrappers.map(function (wrapper) {
		wrapper.fields.map(function (field) {
			var post_category = forminatorData.postCategories[field.post_type];
			if (typeof post_category !== 'undefined') {
				post_category.map(function (category) {
					var category_key = category.value + '_multiple';
					if (1 === parseInt(field[category_key])) {
						counter++;
					}
				});
			}
		});
	});

	return counter > 0;
}

/**
 * Returns array of personality questions
 *
 * @param {array}
 *
 * @return {array}
 **/
function getPersonalityQuestions(currentPersonality, questions) {
	var personalitySlug = currentPersonality.slug;
	var questionsArray = [];

	if (!_.isEmpty(questions)) {
		_.each(questions, function (question, keyQuestion) {
			if (!_.isEmpty(question.answers)) {
				_.each(question.answers, function (answer, keyAnswer) {
					if (answer.result === personalitySlug) {
						questionsArray.push({
							title: question.title,
							slug: question.slug,
							question: question
						});
					}
				});
			}
		});
		questionsArray = _.uniq(questionsArray, 'slug');
	}

	return questionsArray;
}

/**
 * Get payment plan validation
 *
 * @param {array} validation
 * @param {array} payments
 *
 * @return {array}
 */
function getPlanValidation(validation, payments) {

	var paymentIndex = [];

	_.each(payments, function (payment, index) {
		if (!payment.amount_type || !payment.plan_name) {
			validation.error = translate('Please fix the error(s) in the SETTINGS tab.');
			validation.isValid = false;
			paymentIndex.push(index);
		}

		if ('single' === payment.payment_method && ('fixed' === payment.amount_type && _.isEmpty(payment.amount) || 'variable' === payment.amount_type && _.isEmpty(payment.variable))) {
			validation.error = translate('Please fix the error(s) in the SETTINGS tab.');
			validation.isValid = false;
			paymentIndex.push(index);
		} else if ('subscription' === payment.payment_method) {
			var subscriptionAmount = !_.isUndefined(payment.subscription_amount_type) ? payment.subscription_amount_type : 'fixed';
			var subscriptionQuantity = !_.isUndefined(payment.quantity_type) ? payment.quantity_type : 'fixed';
			var Quantity = !_.isUndefined(payment.quantity) ? payment.quantity : 1;
			var BillInput = !_.isUndefined(payment.bill_input) ? payment.bill_input : 1;
			if ('fixed' === subscriptionAmount && _.isEmpty(payment.subscription_amount) || 'variable' === subscriptionAmount && _.isEmpty(payment.subscription_variable)) {
				validation.error = translate('Please fix the error(s) in the SETTINGS tab.');
				validation.isValid = false;
				paymentIndex.push(index);
			}
			if ('fixed' === subscriptionQuantity && !Quantity || 'variable' === subscriptionQuantity && _.isEmpty(payment.variable_quantity)) {
				validation.error = translate('Please fix the error(s) in the SETTINGS tab.');
				validation.isValid = false;
				paymentIndex.push(index);
			}
			if (!BillInput) {
				validation.error = translate('Please fix the error(s) in the SETTINGS tab.');
				validation.isValid = false;
				paymentIndex.push(index);
			} else if (BillInput <= 0) {
				validation.error = translate('Billing frequency should be greater than or equal to 1');
				validation.isValid = false;
				paymentIndex.push(index);
			}
		}
	});

	if (paymentIndex.length > 0) {
		validation.paymentKey = paymentIndex;
	}

	return validation;
}

/**
 * Check if value evaluates to true
 *
 * @param {string} value
 *
 * @return {bool}
 */
function isTrue(value) {
	if ('undefined' === typeof value) {
		return false;
	}
	if ('string' === typeof value) {
		value = value.trim().toLowerCase();
	}

	switch (value) {
		case true:
		case "true":
		case 1:
		case "1":
		case "on":
		case "yes":
			return true;
		default:
			return false;
	}
}

/**
 * Parse query string
 * *
 * @return {string}
 */
function parseQueryString() {
	var parsedParameters = {},
	    uriParameters = location.search.substring(1).split('&');

	for (var i = 0; i < uriParameters.length; i++) {
		var parameter = uriParameters[i].split('=');
		parsedParameters[parameter[0]] = decodeURIComponent(parameter[1]);
	}

	return parsedParameters;
}

/** Go to link
 *
 * @param {string} value
 *
 */
function goToLink(link) {
	var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '_blank';

	window.open(link, target);
}

/***/ }),
/* 2 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Input = function (_Component) {
	_inherits(Input, _Component);

	function Input(props) {
		_classCallCheck(this, Input);

		var _this = _possibleConstructorReturn(this, (Input.__proto__ || Object.getPrototypeOf(Input)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		return _this;
	}

	_createClass(Input, [{
		key: 'updateValue',
		value: function updateValue(value) {
			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'isValid',
		value: function isValid(value) {
			if (this.props.isRequired) {
				return this.props.isRequired && !_.isEmpty(value);
			} else if (!_.isUndefined(this.props.isPositive)) {
				return _.isEmpty(value) || value >= 0;
			}

			return true;
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) ? this.props.defaultValue : this.props.settings[this.props.property];

			var type = !_.isUndefined(this.props.type) ? this.props.type : 'text';

			var requiredError = !_.isUndefined(this.props.requiredError) ? this.props.requiredError : (0, _utils.translate)('This field is required!');

			var hasErrorClass = !this.isValid(value) ? 'sui-form-field-error' : '';

			var fieldClass = !_.isUndefined(this.props.fieldClass) ? 'sui-form-field ' + this.props.fieldClass : 'sui-form-field';

			var inputClass = 'sui-form-control';

			if (!_.isUndefined(this.props.inputClass) && '' !== this.props.inputClass) {
				inputClass += ' ' + this.props.inputClass;
			}

			if (!_.isUndefined(this.props.prefix) && '' !== this.props.prefix) {
				inputClass += ' sui-field-has-prefix';
			}

			if (!_.isUndefined(this.props.suffix) && '' !== this.props.suffix) {
				inputClass += ' sui-field-has-suffix';
			}

			var inputId = !_.isUndefined(this.props.inputId) ? this.props.inputId : this.props.property;

			var inputLabel = void 0;

			if (this.props.label) {
				inputLabel = _react2.default.createElement(
					'label',
					{
						htmlFor: 'forminator-field-' + inputId,
						className: this.props.darkLabel ? 'sui-settings-label sui-dark' : 'sui-label'
					},
					this.props.label,
					this.props.isRequired && _react2.default.createElement(
						_react2.default.Fragment,
						null,
						'\xA0',
						_react2.default.createElement(
							'span',
							{ className: 'sui-error' },
							'*'
						)
					),
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						this.props.note
					)
				);
			}

			var inputField = _react2.default.createElement('input', _extends({ type: type,
				placeholder: this.props.placeholder,
				value: value || '',
				id: 'forminator-field-' + inputId,
				className: inputClass
			}, this.props.notWritable && { readonly: '' }, this.props.minValue && { min: this.props.minValue }, this.props.maxValue && { max: this.props.maxValue }, this.props.step && { step: this.props.step }, this.props.maxLength && { maxLength: this.props.maxLength }, this.props.inputStyles && { style: this.props.inputStyles }, {
				disabled: this.props.disabled ? true : false,
				onChange: function onChange(e) {
					_this2.updateValue(e.target.value);
				}
			}));

			var getFields = _react2.default.createElement(
				'div',
				{ className: fieldClass + ' ' + hasErrorClass },
				inputLabel,
				!_.isUndefined(this.props.prefix) && '' !== this.props.prefix && _react2.default.createElement(
					'span',
					{ className: 'sui-field-prefix' },
					this.props.prefix
				),
				!this.props.canTrash ? inputField : _react2.default.createElement(
					'div',
					{ className: 'sui-with-button sui-with-button-icon' },
					inputField,
					_react2.default.createElement(
						'button',
						{ className: 'sui-button-icon sui-tooltip sui-tooltip-top-right',
							'data-tooltip': (0, _utils.translate)('Delete') },
						_react2.default.createElement('i', { className: 'sui-icon-trash', 'aria-hidden': 'true' })
					)
				),
				this.props.suffix && _react2.default.createElement(
					'span',
					{ className: 'sui-field-suffix' },
					this.props.suffix
				),
				this.props.isRequired && !this.isValid(value) && _react2.default.createElement(
					'span',
					{ className: 'sui-error-message' },
					requiredError
				),
				!_.isUndefined(this.props.isPositive) && !this.isValid(value) && _react2.default.createElement(
					'span',
					{ className: 'sui-error-message' },
					(0, _utils.translate)('Please enter valid number.')
				),
				this.props.description && _react2.default.createElement(
					'span',
					{ className: 'sui-description' },
					this.props.description
				)
			);

			if (this.props.simple) {
				return inputField;
			}

			return getFields;
		}
	}]);

	return Input;
}(_react.Component);

exports.default = Input;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Container = function (_Component) {
	_inherits(Container, _Component);

	function Container(props) {
		_classCallCheck(this, Container);

		return _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).call(this, props));
	}

	_createClass(Container, [{
		key: 'render',
		value: function render() {
			var children = _react2.default.Children.map(this.props.children, function (child) {
				return child;
			});

			return _react2.default.createElement(
				'div',
				null,
				children
			);
		}
	}]);

	return Container;
}(_react.Component);

exports.default = Container;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Col = function (_Component) {
	_inherits(Col, _Component);

	function Col(props) {
		_classCallCheck(this, Col);

		return _possibleConstructorReturn(this, (Col.__proto__ || Object.getPrototypeOf(Col)).call(this, props));
	}

	_createClass(Col, [{
		key: 'render',
		value: function render() {
			var children = _react2.default.Children.map(this.props.children, function (children) {
				return children;
			});

			var customClass = this.props.customClass ? this.props.customClass : '';

			return _react2.default.createElement(
				'div',
				{ className: 'sui-col-md-' + this.props.cols + ' ' + customClass },
				children
			);
		}
	}]);

	return Col;
}(_react.Component);

exports.default = Col;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ColorPicker = function (_Component) {
	_inherits(ColorPicker, _Component);

	function ColorPicker(props) {
		_classCallCheck(this, ColorPicker);

		var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		return _this;
	}

	_createClass(ColorPicker, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.$el = jQuery(this.el);
			this.$el.wpColorPicker({
				change: function change(event, ui) {
					var $this = jQuery(this);
					$this.val(ui.color.toCSS()).trigger('change');
				},
				palettes: ['#333333', '#FFFFFF', '#17A8E3', '#E1F6FF', '#666666', '#AAAAAA', '#E6E6E6']
			});

			var $suiPickerInput = this.$el,
			    $suiPicker = $suiPickerInput.closest('.sui-colorpicker-wrap'),
			    $suiPickerColor = $suiPicker.find('.sui-colorpicker-value span[role=button]'),
			    $suiPickerValue = $suiPicker.find('.sui-colorpicker-value'),
			    $suiPickerClear = $suiPickerValue.find('button');

			var $wpPicker = $suiPickerInput.closest('.wp-picker-container'),
			    $wpPickerButton = $wpPicker.find('.wp-color-result'),
			    $wpPickerAlpha = $wpPickerButton.find('.color-alpha'),
			    $wpPickerClear = $wpPicker.find('.wp-picker-clear');

			var $pickerBackground = $wpPickerAlpha;

			// Check if alpha exists
			if ($suiPickerInput.data('alpha') === true) {
				$pickerBackground = $wpPickerAlpha;
			} else {
				$pickerBackground = $wpPickerButton;
			}

			// Listen to color change
			$suiPickerInput.bind('change', function () {
				// Change color preview
				$suiPickerColor.find('span').css({
					'background-color': $pickerBackground.css('background-color')
				});

				// Change color value
				$suiPickerValue.find('input').val($suiPickerInput.val());
			});

			// Open iris picker
			$suiPicker.find('.sui-button, span[role=button]').on('click', function (e) {
				e.preventDefault();
				e.stopPropagation();
				$wpPickerButton.click();
			});

			// Clear color value
			$suiPickerClear.on('click', function (e) {
				e.preventDefault();
				e.stopPropagation();

				$wpPickerClear.click();
				$suiPickerValue.find('input').val('');
				$suiPickerColor.find('span').css({
					'background-color': ''
				});
			});

			this.updateValue = this.updateValue.bind(this);
			this.$el.on('change', this.updateValue);
		}
	}, {
		key: 'updateValue',
		value: function updateValue(e) {
			var value = e.target.value;

			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.$el.off('change', this.updateValue);
			this.$el.unbind().removeData();
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) || this.props.settings[this.props.property] === null ? this.props.defaultValue : this.props.settings[this.props.property];

			var fieldLabel = '';

			if (this.props.label) {
				fieldLabel = _react2.default.createElement(
					'label',
					{ className: 'sui-label',
						htmlFor: 'forminator-color-' + this.props.property },
					this.props.label,
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						' ',
						this.props.note
					)
				);
			}

			return _react2.default.createElement(
				'div',
				{ className: 'sui-form-field' },
				fieldLabel,
				_react2.default.createElement(
					'div',
					{ className: 'sui-colorpicker-wrap' },
					_react2.default.createElement(
						'div',
						{
							className: 'sui-colorpicker sui-colorpicker-' + (this.props.isAlpha ? 'rgba' : 'hex'),
							'aria-hidden': 'true' },
						_react2.default.createElement(
							'div',
							{ className: 'sui-colorpicker-value' },
							_react2.default.createElement(
								'span',
								{ role: 'button' },
								_react2.default.createElement('span', { style: { backgroundColor: value } })
							),
							_react2.default.createElement('input', { type: 'text', defaultValue: value,
								readOnly: 'readonly' }),
							_react2.default.createElement(
								'button',
								null,
								_react2.default.createElement('i', { className: 'sui-icon-close', 'aria-hidden': 'true' })
							)
						),
						_react2.default.createElement(
							'button',
							{ className: 'sui-button' },
							(0, _utils.translate)('Select')
						)
					),
					_react2.default.createElement('input', { ref: function ref(el) {
							return _this2.el = el;
						},
						defaultValue: value,
						id: 'forminator-color-' + this.props.property,
						className: 'sui-colorpicker-input',
						'data-alpha': this.props.isAlpha ? 'true' : 'false'
					})
				),
				this.props.description && '' !== this.props.description && _react2.default.createElement(
					'span',
					{ className: 'sui-description' },
					this.props.description
				)
			);
		}
	}]);

	return ColorPicker;
}(_react.Component);

exports.default = ColorPicker;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RadioTabs = function (_Component) {
	_inherits(RadioTabs, _Component);

	function RadioTabs(props) {
		_classCallCheck(this, RadioTabs);

		return _possibleConstructorReturn(this, (RadioTabs.__proto__ || Object.getPrototypeOf(RadioTabs)).call(this, props));
	}

	_createClass(RadioTabs, [{
		key: 'toggleValue',
		value: function toggleValue(value) {
			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'getDefaultValue',
		value: function getDefaultValue() {
			var defaultValue = this.props.default ? this.props.default : '';

			var value = _.isUndefined(this.props.settings[this.props.property]) ? defaultValue : this.props.settings[this.props.property];

			return value;
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = this.getDefaultValue();

			var tabTitles = _react2.default.Children.map(this.props.children, function (tab) {
				if (!tab) {
					return _react2.default.createElement(_react2.default.Fragment, null);
				}

				var label = !_.isUndefined(tab.props.label) ? tab.props.label : tab.props.children;

				if (_this2.props.disabled) {
					return _react2.default.createElement(
						'div',
						{ className: 'sui-tab-item' + (tab.props.value === value ? ' active' : ''),
							style: {
								opacity: 0.5,
								cursor: 'not-allowed'
							}
						},
						label
					);
				}

				if (!_this2.props.disabled) {
					return _react2.default.createElement(
						'div',
						{ className: 'sui-tab-item' + (tab.props.value === value ? ' active' : ''),
							onClick: _this2.toggleValue.bind(_this2, tab.props.value)
						},
						label
					);
				}
			});

			var contentClass = !_.isUndefined(this.props.divClass) ? 'sui-tabs-content ' + this.props.divClass : 'sui-tabs-content';

			var tabContents = _react2.default.Children.map(this.props.children, function (tab) {
				if (!tab) {
					return _react2.default.createElement(_react2.default.Fragment, null);
				}

				var boxClass = !_.isUndefined(tab.props.boxClass) ? tab.props.boxClass : '';

				if (tab.type.name !== 'Empty') {
					return _react2.default.createElement(
						'div',
						{ className: boxClass + ' sui-tab-content' + (tab.props.value === value ? ' active' : '') },
						tab.props.value === value && tab
					);
				}

				return _react2.default.createElement(_react2.default.Fragment, null);
			});

			var tabsLabel = '';

			if (this.props.label && '' !== this.props.label) {
				tabsLabel = _react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-field-' + this.props.property,
						className: 'sui-label' },
					this.props.label,
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						' ',
						this.props.note
					)
				);
			}

			var settingsLabel = '';

			if (this.props.settingsLabel && '' !== this.props.settingsLabel) {
				var labelClass = this.props.labelClass ? this.props.labelClass : 'sui-settings-label';
				settingsLabel = _react2.default.createElement(
					'label',
					{ className: labelClass },
					this.props.settingsLabel
				);
			}

			var description = '';

			if (this.props.description && '' !== this.props.description) {
				description = _react2.default.createElement(
					'span',
					{
						className: 'sui-description',
						style: { marginBottom: 10 }
					},
					this.props.description
				);
			}

			var wrapperClass = !_.isUndefined(this.props.wrapperClass) ? this.props.wrapperClass : '';

			wrapperClass = this.props.basicTabs ? 'sui-tabs sui-tabs-overflow ' + wrapperClass : 'sui-side-tabs ' + wrapperClass;

			var tabsMarkup = _react2.default.createElement(
				'div',
				{ className: wrapperClass },
				_react2.default.createElement(
					'div',
					{ className: 'sui-tabs-menu' },
					tabTitles
				),
				_react2.default.createElement(
					'div',
					{ className: contentClass },
					tabContents
				)
			);

			if (!this.props.simple) {
				tabsMarkup = _react2.default.createElement(
					'div',
					{ className: 'sui-form-field' },
					settingsLabel,
					tabsLabel,
					description,
					_react2.default.createElement(
						'div',
						{ className: wrapperClass },
						_react2.default.createElement(
							'div',
							{ className: 'sui-tabs-menu' },
							tabTitles
						),
						_react2.default.createElement(
							'div',
							{ className: contentClass },
							tabContents
						)
					)
				);
			}

			return tabsMarkup;
		}
	}]);

	return RadioTabs;
}(_react.Component);

exports.default = RadioTabs;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Row = function (_Component) {
	_inherits(Row, _Component);

	function Row(props) {
		_classCallCheck(this, Row);

		return _possibleConstructorReturn(this, (Row.__proto__ || Object.getPrototypeOf(Row)).call(this, props));
	}

	_createClass(Row, [{
		key: 'render',
		value: function render() {
			var columns = _react2.default.Children.map(this.props.children, function (children) {
				return children;
			});

			return _react2.default.createElement(
				'div',
				{ className: 'sui-row' + (!_.isUndefined(this.props.class) ? ' ' + this.props.class : '') },
				columns
			);
		}
	}]);

	return Row;
}(_react.Component);

exports.default = Row;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(116)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(118)();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tabs = function (_Component) {
	_inherits(Tabs, _Component);

	function Tabs(props) {
		_classCallCheck(this, Tabs);

		var _this = _possibleConstructorReturn(this, (Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call(this, props));

		_this.state = {
			active: _this.props.default ? _this.props.default : ''
		};
		return _this;
	}

	_createClass(Tabs, [{
		key: 'toggleValue',
		value: function toggleValue(value) {
			this.setState({
				active: value
			});
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var defaultValue = this.props.default ? this.props.default : '';

			var type = this.props.type ? this.props.type : 'side-tabs';

			var extraClass = this.props.extraClass ? this.props.extraClass : '';

			var tabTitles = _react2.default.Children.map(this.props.children, function (tab) {
				if (_.isUndefined(tab) || _.isNull(tab)) {
					return;
				}

				return _react2.default.createElement(
					'div',
					{
						className: 'forminator-toggle sui-tab-item' + (tab.props.value === _this2.state.active ? ' active' : ''),
						onClick: _this2.toggleValue.bind(_this2, tab.props.value)
					},
					tab.props.label,
					' ',
					tab.props.required && _react2.default.createElement(
						'span',
						{ className: 'sui-error' },
						'*'
					)
				);
			});

			var tabContents = _react2.default.Children.map(this.props.children, function (tab) {
				if (_.isUndefined(tab) || _.isNull(tab)) {
					return;
				}

				var boxClassValue = !_.isUndefined(tab.props.boxClass) ? tab.props.boxClass : 'sui-tab-content';

				return _react2.default.createElement(
					'div',
					{ className: boxClassValue + (tab.props.value === _this2.state.active ? ' active' : '') },
					tab.props.value === _this2.state.active && tab
				);
			});

			return _react2.default.createElement(
				'div',
				{ className: 'sui-' + type + ' ' + extraClass },
				_react2.default.createElement(
					'div',
					{ className: 'sui-tabs-menu' },
					tabTitles
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-tabs-content' },
					tabContents
				)
			);
		}
	}]);

	return Tabs;
}(_react.Component);

exports.default = Tabs;

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStore", function() { return createStore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineReducers", function() { return combineReducers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindActionCreators", function() { return bindActionCreators; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyMiddleware", function() { return applyMiddleware; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return compose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__DO_NOT_USE__ActionTypes", function() { return ActionTypes; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_symbol_observable__ = __webpack_require__(123);


/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = {
  INIT: '@@redux/INIT' + Math.random().toString(36).substring(7).split('').join('.'),
  REPLACE: '@@redux/REPLACE' + Math.random().toString(36).substring(7).split('').join('.')
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) return false;

  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    if (isDispatching) {
      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
    }

    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected the listener to be a function.');
    }

    if (isDispatching) {
      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.REPLACE });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if ((typeof observer === 'undefined' ? 'undefined' : _typeof(observer)) !== 'object' || observer === null) {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[__WEBPACK_IMPORTED_MODULE_0_symbol_observable__["a" /* default */]] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[__WEBPACK_IMPORTED_MODULE_0_symbol_observable__["a" /* default */]] = observable, _ref2;
}

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty
}

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionDescription = actionType && 'action "' + String(actionType) + '"' || 'an action';

  return 'Given ' + actionDescription + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });

  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });

  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, { type: ActionTypes.INIT });

    if (typeof initialState === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
    }

    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    if (typeof reducer(undefined, { type: type }) === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
    }
  });
}

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (process.env.NODE_ENV !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        warning('No reducer provided for key "' + key + '"');
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);

  var unexpectedKeyCache = void 0;
  if (process.env.NODE_ENV !== 'production') {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError = void 0;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var action = arguments[1];

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (process.env.NODE_ENV !== 'production') {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        warning(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(this, arguments));
  };
}

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if ((typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) !== 'object' || actionCreators === null) {
    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators === 'undefined' ? 'undefined' : _typeof(actionCreators)) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(undefined, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var store = createStore.apply(undefined, args);
      var _dispatch = function dispatch() {
        throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(undefined, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(undefined, chain)(store.dispatch);

      return _extends({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */
function isCrushed() {}

if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  warning("You are currently using minified code outside of NODE_ENV === 'production'. " + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}



/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = Empty;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Empty() {
	return '';
}

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Provider__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_connectAdvanced__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__connect_connect__ = __webpack_require__(120);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Provider", function() { return __WEBPACK_IMPORTED_MODULE_0__components_Provider__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "createProvider", function() { return __WEBPACK_IMPORTED_MODULE_0__components_Provider__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "connectAdvanced", function() { return __WEBPACK_IMPORTED_MODULE_1__components_connectAdvanced__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "connect", function() { return __WEBPACK_IMPORTED_MODULE_2__connect_connect__["a"]; });






/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(80);
var isBuffer = __webpack_require__(163);

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SettingsRow = function (_Component) {
	_inherits(SettingsRow, _Component);

	function SettingsRow(props) {
		_classCallCheck(this, SettingsRow);

		return _possibleConstructorReturn(this, (SettingsRow.__proto__ || Object.getPrototypeOf(SettingsRow)).call(this, props));
	}

	_createClass(SettingsRow, [{
		key: 'render',
		value: function render() {
			var content = _react2.default.Children.map(this.props.children, function (children) {
				return children;
			});

			var label = '';

			if (this.props.label && '' !== this.props.label) {
				label = _react2.default.createElement(
					'span',
					{ className: 'sui-settings-label' + ('' + (this.props.labelDark === true ? ' sui-dark' : '')) },
					this.props.label
				);
			}

			var description = '';
			var descriptionSpacing = 10;

			if (!_.isUndefined(this.props.descriptionSpacing) && '' !== this.props.descriptionSpacing) {
				descriptionSpacing = this.props.descriptionSpacing;
			}

			if (!_.isUndefined(this.props.description) && '' !== this.props.description) {
				if (this.props.sidebar === false) {
					description = _react2.default.createElement(
						'span',
						{
							className: 'sui-description',
							style: { marginBottom: descriptionSpacing + 'px' }
						},
						this.props.description
					);
				} else {
					description = _react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						this.props.description
					);
				}
			}

			var sidebar = '';

			if (this.props.label && '' !== this.props.label || this.props.description && '' !== this.props.description) {
				sidebar = _react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					label,
					description
				);
			}

			var conditionalStyles = this.props.lastChild ? { marginBottom: 0, borderBottom: 'unset' } : {};

			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row', style: conditionalStyles },
				(_.isUndefined(this.props.sidebar) || this.props.sidebar !== false) && sidebar,
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					!_.isUndefined(this.props.sidebar) && this.props.sidebar === false && label,
					!_.isUndefined(this.props.sidebar) && this.props.sidebar === false && description,
					content
				)
			);
		}
	}]);

	return SettingsRow;
}(_react.Component);

exports.default = SettingsRow;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SuiSelect2 = function (_Component) {
	_inherits(SuiSelect2, _Component);

	function SuiSelect2(props) {
		_classCallCheck(this, SuiSelect2);

		var _this = _possibleConstructorReturn(this, (SuiSelect2.__proto__ || Object.getPrototypeOf(SuiSelect2)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		_this.afterSave = _this.afterSave.bind(_this);
		return _this;
	}

	_createClass(SuiSelect2, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.$el = jQuery(this.el);

			var parent = this.$el.closest('.sui-modal-content');
			var parentId = parent.attr('id');
			var hasSearch = this.props.hasSearch ? 0 : -1;

			var options = Object.assign({
				dropdownParent: parent.length ? jQuery('#' + parentId) : jQuery('body[class*="sui-"]'),
				minimumResultsForSearch: hasSearch,
				dropdownCssClass: this.$el.hasClass('sui-select-sm') ? 'sui-select-dropdown-sm' : '',
				width: '100%'
			}, this.props.options);

			if (typeof this.$el.SUIselect2 === 'function') {
				this.$el.SUIselect2(options);
			} else if (typeof this.$el.FUIselect2 === 'function') {
				this.$el.FUIselect2(options);
			} else {
				throw Error('SUI Select2 not initiated');
			}

			this.updateValue = this.updateValue.bind(this);
			this.$el.on('change', this.updateValue);

			if (this.props.triggerChange) {
				this.$el.trigger('change');
			}
		}
	}, {
		key: 'updateValue',
		value: function updateValue(e) {
			var value = jQuery(e.target).val();

			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}

			this.afterSave(value);
		}
	}, {
		key: 'afterSave',
		value: function afterSave() {
			return false;
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.$el.off('change', this.updateValue);
			this.$el.unbind().removeData();
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) ? this.props.defaultValue : this.props.settings[this.props.property];

			var divClass = !_.isUndefined(this.props.fieldClass) ? 'sui-form-field ' + this.props.fieldClass : 'sui-form-field';

			var selectId = !_.isUndefined(this.props.elementId) ? this.props.elementId : this.props.property;

			var inputLabel = void 0;

			if (this.props.label) {
				inputLabel = _react2.default.createElement(
					'label',
					{
						htmlFor: 'forminator-field-' + this.props.property,
						className: 'sui-label'
					},
					this.props.label,
					'\xA0',
					this.props.required && _react2.default.createElement(
						'span',
						{ className: 'sui-error' },
						' *'
					),
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						this.props.note
					)
				);
			}

			var multiple = this.props.multiple;

			var _props = this.props,
			    formType = _props.formType,
			    updateProperty = _props.updateProperty,
			    noWrapper = _props.noWrapper,
			    fieldClass = _props.fieldClass,
			    staticContext = _props.staticContext,
			    formDesign = _props.formDesign,
			    fieldSize = _props.fieldSize,
			    selectProps = _objectWithoutProperties(_props, ['formType', 'updateProperty', 'noWrapper', 'fieldClass', 'staticContext', 'formDesign', 'fieldSize']);

			var getSelect = _react2.default.createElement(
				'select',
				_extends({
					id: 'forminator-field-' + selectId,
					className: 'sui-select',
					ref: function ref(el) {
						return _this2.el = el;
					},
					defaultValue: value,
					multiple: multiple
				}, selectProps),
				this.props.children
			);

			var getElement = _react2.default.createElement(
				'select',
				{
					id: 'forminator-field-' + selectId,
					className: 'sui-select',
					ref: function ref(el) {
						return _this2.el = el;
					},
					defaultValue: value,
					multiple: multiple
				},
				this.props.children
			);

			if ('md' === this.props.fieldsize || 'medium' === this.props.fieldsize) {
				getElement = _react2.default.createElement(
					'div',
					{ className: 'sui-form-field sui-input-md' },
					getSelect
				);
			} else if ('sm' === this.props.fieldsize || 'small' === this.props.fieldsize) {
				getElement = _react2.default.createElement(
					'div',
					{ className: 'sui-form-field sui-input-sm' },
					getSelect
				);
			} else if (!_.isUndefined(this.props.fieldsize) && '' !== this.props.fieldsize) {
				getElement = _react2.default.createElement(
					'div',
					{ style: { width: '100%', maxWidth: this.props.fieldsize + 'px' } },
					getSelect
				);
			}

			if (this.props.noWrapper) {
				return getSelect;
			}

			return _react2.default.createElement(
				'div',
				{ className: divClass },
				inputLabel,
				getElement,
				this.props.description && _react2.default.createElement(
					'span',
					{
						className: 'sui-description',
						style: { marginTop: '10px' }
					},
					this.props.description
				)
			);
		}
	}]);

	return SuiSelect2;
}(_react.Component);

exports.default = SuiSelect2;

/***/ }),
/* 18 */,
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @providesModule warning
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var __DEV__ = process.env.NODE_ENV !== 'production';

var warning = function() {};

if (__DEV__) {
  var printWarning = function printWarning(format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    var argIndex = 0;
    var message = 'Warning: ' +
      format.replace(/%s/g, function() {
        return args[argIndex++];
      });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  }

  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
          '`warning(condition, format, ...args)` requires a warning ' +
          'message argument'
      );
    }
    if (!condition) {
      printWarning.apply(null, [format].concat(args));
    }
  };
}

module.exports = warning;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SuiSelect = function (_Component) {
	_inherits(SuiSelect, _Component);

	function SuiSelect(props) {
		_classCallCheck(this, SuiSelect);

		var _this = _possibleConstructorReturn(this, (SuiSelect.__proto__ || Object.getPrototypeOf(SuiSelect)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		return _this;
	}

	_createClass(SuiSelect, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.$el = jQuery(this.el);
			// SUI.select.init( this.$el );

			this.updateValue = this.updateValue.bind(this);
			this.$el.on('change', this.updateValue);
		}
	}, {
		key: 'updateValue',
		value: function updateValue(e) {
			var value = e.target.value;

			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.$el.off('change', this.updateValue);
			this.$el.unbind().removeData();
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) ? this.props.defaultValue : this.props.settings[this.props.property];

			var fieldClass = !_.isUndefined(this.props.fieldClass) ? 'sui-form-field ' + this.props.fieldClass : 'sui-form-field';

			var selectClass = !_.isUndefined(this.props.elementClass) ? this.props.elementClass : '';

			var selectId = !_.isUndefined(this.props.elementId) ? this.props.elementId : this.props.property;

			var selectLabel = '';

			if (this.props.label) {
				selectLabel = _react2.default.createElement(
					'label',
					{
						htmlFor: 'forminator-field-' + this.props.property,
						id: 'forminator-field-' + this.props.property + '-label',
						className: 'sui-label'
					},
					this.props.label,
					'\xA0',
					this.props.required && _react2.default.createElement(
						'span',
						{ className: 'sui-error' },
						' *'
					),
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						this.props.note
					)
				);
			}

			// For backwards compatibility.
			if (!_.isUndefined(value) && ('phone_national_country' === this.props.property || 'phone_international_country' === this.props.property)) {
				value = value.toLowerCase();
			}

			var selectField = _react2.default.createElement(
				'select',
				{
					defaultValue: value,
					id: 'forminator-field-' + selectId,
					className: selectClass,
					'aria-labelledby': 'forminator-field-' + selectId + '-label',
					ref: function ref(el) {
						return _this2.el = el;
					},
					style: { maxWidth: 'none' }
				},
				this.props.children
			);

			var getElement = selectField;

			if ('md' === this.props.fieldsize || 'medium' === this.props.fieldsize) {
				getElement = _react2.default.createElement(
					'div',
					{ className: 'sui-form-field sui-input-md' },
					selectField
				);
			} else if ('sm' === this.props.fieldsize || 'small' === this.props.fieldsize) {
				getElement = _react2.default.createElement(
					'div',
					{ className: 'sui-form-field sui-input-sm' },
					selectField
				);
			} else if ('' !== this.props.fieldsize) {
				getElement = _react2.default.createElement(
					'div',
					{ style: { width: '100%', maxWidth: this.props.fieldsize + 'px' } },
					selectField
				);
			}

			var getField = getElement;

			if (!this.props.simple) {
				getField = _react2.default.createElement(
					'div',
					{ className: fieldClass },
					selectLabel,
					getElement,
					this.props.description && _react2.default.createElement(
						'span',
						{
							className: 'sui-description',
							style: { marginTop: '10px' }
						},
						this.props.description
					)
				);
			}

			return getField;
		}
	}]);

	return SuiSelect;
}(_react.Component);

exports.default = SuiSelect;

/***/ }),
/* 21 */,
/* 22 */,
/* 23 */
/***/ (function(module, exports) {

module.exports = ReactDOM;

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__createBrowserHistory__ = __webpack_require__(140);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__createBrowserHistory__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__createHashHistory__ = __webpack_require__(143);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_1__createHashHistory__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__createMemoryHistory__ = __webpack_require__(144);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_2__createMemoryHistory__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__LocationUtils__ = __webpack_require__(34);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_3__LocationUtils__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_3__LocationUtils__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__PathUtils__ = __webpack_require__(28);
/* unused harmony reexport parsePath */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_4__PathUtils__["b"]; });










/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Toggle = function (_Component) {
	_inherits(Toggle, _Component);

	function Toggle(props) {
		_classCallCheck(this, Toggle);

		var _this = _possibleConstructorReturn(this, (Toggle.__proto__ || Object.getPrototypeOf(Toggle)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		return _this;
	}

	_createClass(Toggle, [{
		key: 'updateValue',
		value: function updateValue(value) {
			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) ? '' : this.props.settings[this.props.property];

			var customClass = !_.isUndefined(this.props.customClass) ? this.props.customClass : 'sui-form-control';

			var disabled = !_.isUndefined(this.props.disabled) && this.props.disabled;
			var checked = value && !disabled;

			var toggleContent = _react2.default.createElement(
				'label',
				{ htmlFor: 'forminator-field-' + this.props.property,
					className: 'sui-toggle'
				},
				_react2.default.createElement('input', { type: 'checkbox',
					value: 'true',
					id: 'forminator-field-' + this.props.property,
					className: customClass,
					disabled: disabled ? 'disabled' : '',
					checked: checked ? 'checked' : '',
					onChange: function onChange(e) {
						_this2.updateValue(e.target.checked);
					}
				}),
				_react2.default.createElement('span', { className: 'sui-toggle-slider' }),
				this.props.label && _react2.default.createElement(
					_react2.default.Fragment,
					null,
					_react2.default.createElement(
						'span',
						{ className: 'sui-screen-reader-text' },
						(0, _utils.translate)('Enable'),
						' ',
						this.props.label
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-toggle-label' },
						this.props.label
					)
				),
				this.props.description && _react2.default.createElement(
					'span',
					{ className: 'sui-description sui-toggle-description' },
					this.props.description
				)
			);

			var subToggle = '';

			if (this.props.children && this.props.settings[this.props.property]) {
				subToggle = _react2.default.createElement(
					_react2.default.Fragment,
					null,
					_react2.default.createElement(
						'div',
						{
							tabIndex: '0',
							className: 'sui-toggle-content sui-border-frame',
							'aria-label': this.props.label
						},
						this.props.children
					)
				);
			}

			if (this.props.unWrap) {
				return _react2.default.createElement(
					_react2.default.Fragment,
					null,
					toggleContent,
					subToggle
				);
			}

			if (!this.props.unWrap) {
				return _react2.default.createElement(
					'div',
					{ className: 'sui-form-field' },
					toggleContent,
					subToggle
				);
			}
		}
	}]);

	return Toggle;
}(_react.Component);

exports.default = Toggle;

/***/ }),
/* 26 */,
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BrowserRouter__ = __webpack_require__(139);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "BrowserRouter", function() { return __WEBPACK_IMPORTED_MODULE_0__BrowserRouter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__HashRouter__ = __webpack_require__(145);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "HashRouter", function() { return __WEBPACK_IMPORTED_MODULE_1__HashRouter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Link__ = __webpack_require__(75);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Link", function() { return __WEBPACK_IMPORTED_MODULE_2__Link__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__MemoryRouter__ = __webpack_require__(146);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MemoryRouter", function() { return __WEBPACK_IMPORTED_MODULE_3__MemoryRouter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__NavLink__ = __webpack_require__(148);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "NavLink", function() { return __WEBPACK_IMPORTED_MODULE_4__NavLink__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Prompt__ = __webpack_require__(150);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Prompt", function() { return __WEBPACK_IMPORTED_MODULE_5__Prompt__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Redirect__ = __webpack_require__(152);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Redirect", function() { return __WEBPACK_IMPORTED_MODULE_6__Redirect__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Route__ = __webpack_require__(76);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Route", function() { return __WEBPACK_IMPORTED_MODULE_7__Route__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Router__ = __webpack_require__(47);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Router", function() { return __WEBPACK_IMPORTED_MODULE_8__Router__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__StaticRouter__ = __webpack_require__(154);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "StaticRouter", function() { return __WEBPACK_IMPORTED_MODULE_9__StaticRouter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__Switch__ = __webpack_require__(156);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Switch", function() { return __WEBPACK_IMPORTED_MODULE_10__Switch__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__generatePath__ = __webpack_require__(158);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "generatePath", function() { return __WEBPACK_IMPORTED_MODULE_11__generatePath__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__matchPath__ = __webpack_require__(159);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "matchPath", function() { return __WEBPACK_IMPORTED_MODULE_12__matchPath__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__withRouter__ = __webpack_require__(160);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "withRouter", function() { return __WEBPACK_IMPORTED_MODULE_13__withRouter__["a"]; });





























/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addLeadingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return stripLeadingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return hasBasename; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return stripBasename; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return stripTrailingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return parsePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createPath; });
var addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;


  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),
/* 29 */,
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Notification = function (_Component) {
	_inherits(Notification, _Component);

	function Notification(props) {
		_classCallCheck(this, Notification);

		return _possibleConstructorReturn(this, (Notification.__proto__ || Object.getPrototypeOf(Notification)).call(this, props));
	}

	_createClass(Notification, [{
		key: 'initialize',
		value: function initialize() {
			if (!jQuery('.sui-floating-notices').length) {
				jQuery('main.sui-wrap').prepend('<div class="sui-floating-notices"></div>');
			}

			if (!jQuery('#forminator-notification').length) {
				jQuery('.sui-floating-notices').append('<div role="alert" id="forminator-notification" class="sui-notice" aria-live="assertive"></div>');
			} else {
				jQuery('#forminator-notification').remove();
				this.initialize();
			}

			this.$notification = jQuery('#forminator-notification');
		}
	}, {
		key: 'open',
		value: function open() {
			this.initialize();

			var noticeId = 'forminator-notification';
			var noticeMessage = '<p>' + this.props.text + '</p>';
			var noticeOptions = {
				type: this.props.type || 'default',
				autoclose: {
					timeout: this.props.time || 5000
				},
				dismiss: {
					show: this.props.dismiss || false
				}
			};

			SUI.openNotice(noticeId, noticeMessage, noticeOptions);
		}
	}, {
		key: 'close',
		value: function close() {
			var noticeId = 'forminator-notification';
			SUI.closeNotice(noticeId);
		}
	}]);

	return Notification;
}(_react.Component);

exports.default = Notification;

/***/ }),
/* 31 */,
/* 32 */,
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return locationsAreEqual; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_resolve_pathname__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_value_equal__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__PathUtils__ = __webpack_require__(28);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };





var createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = Object(__WEBPACK_IMPORTED_MODULE_2__PathUtils__["d" /* parsePath */])(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = Object(__WEBPACK_IMPORTED_MODULE_0_resolve_pathname__["a" /* default */])(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && Object(__WEBPACK_IMPORTED_MODULE_1_value_equal__["a" /* default */])(a.state, b.state);
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Accordion = function (_Component) {
	_inherits(Accordion, _Component);

	function Accordion(props) {
		_classCallCheck(this, Accordion);

		var _this = _possibleConstructorReturn(this, (Accordion.__proto__ || Object.getPrototypeOf(Accordion)).call(this, props));

		_this.state = {
			open: props.expanded || false
		};

		_this.toggleState = _this.toggleState.bind(_this);
		return _this;
	}

	_createClass(Accordion, [{
		key: 'toggleState',
		value: function toggleState() {
			this.setState({
				open: !this.state.open
			});
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var label = this.props.label;
			var open = this.state.open;

			var divClass = '';

			if (open) {
				divClass = 'sui-accordion-item--open';
			}

			// eslint-disable-next-line max-len
			var boxedContent = !_.isUndefined(this.props.boxedContent) && '' !== this.props.boxedContent ? this.props.boxedContent : true;

			var defaultContentRender = !_.isUndefined(this.props.defaultContentRender) ? this.props.defaultContentRender : false;

			var accordionContents = _react2.default.Children.map(this.props.children, function (tab) {
				return tab;
			});

			// It's intentionally we use span here to avoid unwanted handlers from SUI on div.sui-accordion-item-header.
			return _react2.default.createElement(
				'div',
				{ className: 'sui-accordion-item ' + divClass },
				_react2.default.createElement(
					'span',
					{ className: 'sui-accordion-item-header', onClick: function onClick() {
							return _this2.toggleState();
						} },
					_react2.default.createElement(
						'div',
						{ className: 'sui-accordion-item-title' },
						_react2.default.createElement(
							'span',
							null,
							label
						),
						_react2.default.createElement(
							'button',
							{
								className: 'sui-button-icon sui-accordion-open-indicator',
								onClick: function onClick() {
									return _this2.toggleState();
								}
							},
							_react2.default.createElement('i', { className: 'sui-icon-chevron-down', 'aria-hidden': 'true' }),
							_react2.default.createElement(
								'span',
								{ className: 'sui-screen-reader-text' },
								false === this.state.open ? 'Open' : 'Close'
							)
						)
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-accordion-item-body' },
					false === boxedContent ? (defaultContentRender || open) && accordionContents : _react2.default.createElement(
						'div',
						{ className: 'sui-box' },
						_react2.default.createElement(
							'div',
							{ className: 'sui-box-body' },
							(defaultContentRender || open) && accordionContents
						),
						boxedContent
					)
				)
			);
		}
	}]);

	return Accordion;
}(_react.Component);

exports.default = Accordion;

/***/ }),
/* 36 */,
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(54);
var inherits = __webpack_require__(55);

exports.inherits = inherits;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),
/* 38 */,
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(162);

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stringify = __webpack_require__(180);
var parse = __webpack_require__(181);
var formats = __webpack_require__(86);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Checkbox = function (_Component) {
	_inherits(Checkbox, _Component);

	function Checkbox(props) {
		_classCallCheck(this, Checkbox);

		var _this = _possibleConstructorReturn(this, (Checkbox.__proto__ || Object.getPrototypeOf(Checkbox)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		return _this;
	}

	_createClass(Checkbox, [{
		key: 'updateValue',
		value: function updateValue(value) {
			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) ? this.props.defaultValue : this.props.settings[this.props.property];

			var fieldId = _.isUndefined(this.props.fieldId) ? this.props.property : this.props.fieldId;

			var disabled = !_.isUndefined(this.props.disabled) && this.props.disabled ? true : false;

			var extraClass = '';

			if (this.props.itemClass && '' !== this.props.itemClass) {
				extraClass = ' ' + this.props.itemClass;
			}

			return _react2.default.createElement(
				'label',
				{
					htmlFor: 'forminator-field-' + fieldId,
					className: 'sui-checkbox' + extraClass
				},
				_react2.default.createElement('input', {
					type: 'checkbox',
					id: 'forminator-field-' + fieldId,
					value: 'true',
					checked: value ? 'checked' : '',
					disabled: disabled,
					onChange: function onChange(e) {
						_this2.updateValue(e.target.checked);
					}
				}),
				_react2.default.createElement('span', { 'aria-hidden': 'true' }),
				this.props.label && _react2.default.createElement(
					'span',
					null,
					this.props.label,
					!_.isUndefined(this.props.tooltip) && '' !== this.props.tooltip && _react2.default.createElement(
						'span',
						{
							className: 'sui-tooltip sui-tooltip-constrained',
							style: {
								marginLeft: 10,
								verticalAlign: 'middle',
								'--tooltip-width': '165px'
							},
							'data-tooltip': this.props.tooltip
						},
						_react2.default.createElement('span', {
							className: 'sui-icon-info',
							'aria-hidden': 'true',
							style: { pointerEvents: 'none' }
						})
					)
				)
			);
		}
	}]);

	return Checkbox;
}(_react.Component);

exports.default = Checkbox;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 43 */,
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}

/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);


var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          __WEBPACK_IMPORTED_MODULE_0_warning___default()(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

/* harmony default export */ __webpack_exports__["a"] = (createTransitionManager);

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Router__ = __webpack_require__(48);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Router__["a" /* default */]);

/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_prop_types__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * The public API for putting history on context.
 */

var Router = function (_React$Component) {
  _inherits(Router, _React$Component);

  function Router() {
    var _temp, _this, _ret;

    _classCallCheck(this, Router);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props.history.location.pathname)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Router.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        history: this.props.history,
        route: {
          location: this.props.history.location,
          match: this.state.match
        }
      })
    };
  };

  Router.prototype.computeMatch = function computeMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };

  Router.prototype.componentWillMount = function componentWillMount() {
    var _this2 = this;

    var _props = this.props,
        children = _props.children,
        history = _props.history;


    __WEBPACK_IMPORTED_MODULE_1_invariant___default()(children == null || __WEBPACK_IMPORTED_MODULE_2_react___default.a.Children.count(children) === 1, "A <Router> may have only one child element");

    // Do this here so we can setState when a <Redirect> changes the
    // location in componentWillMount. This happens e.g. when doing
    // server rendering using a <StaticRouter>.
    this.unlisten = history.listen(function () {
      _this2.setState({
        match: _this2.computeMatch(history.location.pathname)
      });
    });
  };

  Router.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(this.props.history === nextProps.history, "You cannot change <Router history>");
  };

  Router.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unlisten();
  };

  Router.prototype.render = function render() {
    var children = this.props.children;

    return children ? __WEBPACK_IMPORTED_MODULE_2_react___default.a.Children.only(children) : null;
  };

  return Router;
}(__WEBPACK_IMPORTED_MODULE_2_react___default.a.Component);

Router.propTypes = {
  history: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired,
  children: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.node
};
Router.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object
};
Router.childContextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Router);

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path_to_regexp__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path_to_regexp___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_path_to_regexp__);


var patternCache = {};
var cacheLimit = 10000;
var cacheCount = 0;

var compilePath = function compilePath(pattern, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});

  if (cache[pattern]) return cache[pattern];

  var keys = [];
  var re = __WEBPACK_IMPORTED_MODULE_0_path_to_regexp___default()(pattern, keys, options);
  var compiledPattern = { re: re, keys: keys };

  if (cacheCount < cacheLimit) {
    cache[pattern] = compiledPattern;
    cacheCount++;
  }

  return compiledPattern;
};

/**
 * Public API for matching a URL pathname to a path pattern.
 */
var matchPath = function matchPath(pathname) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var parent = arguments[2];

  if (typeof options === "string") options = { path: options };

  var _options = options,
      path = _options.path,
      _options$exact = _options.exact,
      exact = _options$exact === undefined ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === undefined ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === undefined ? false : _options$sensitive;


  if (path == null) return parent;

  var _compilePath = compilePath(path, { end: exact, strict: strict, sensitive: sensitive }),
      re = _compilePath.re,
      keys = _compilePath.keys;

  var match = re.exec(pathname);

  if (!match) return null;

  var url = match[0],
      values = match.slice(1);

  var isExact = pathname === url;

  if (exact && !isExact) return null;

  return {
    path: path, // the path pattern used to match
    url: path === "/" && url === "" ? "/" : url, // the matched portion of the URL
    isExact: isExact, // whether or not we matched exactly
    params: keys.reduce(function (memo, key, index) {
      memo[key.name] = values[index];
      return memo;
    }, {})
  };
};

/* harmony default export */ __webpack_exports__["a"] = (matchPath);

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(14);
var normalizeHeaderName = __webpack_require__(165);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(81);
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(81);
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 51 */,
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Internal dependencies
 */
var I18N = __webpack_require__( 92 ),
	i18n = new I18N();

module.exports = {
	numberFormat: i18n.numberFormat.bind( i18n ),
	translate: i18n.translate.bind( i18n ),
	configure: i18n.configure.bind( i18n ),
	setLocale: i18n.setLocale.bind( i18n ),
	getLocale: i18n.getLocale.bind( i18n ),
	getLocaleSlug: i18n.getLocaleSlug.bind( i18n ),
	addTranslations: i18n.addTranslations.bind( i18n ),
	reRenderTranslations: i18n.reRenderTranslations.bind( i18n ),
	registerComponentUpdateHook: i18n.registerComponentUpdateHook.bind( i18n ),
	registerTranslateHook: i18n.registerTranslateHook.bind( i18n ),
	state: i18n.state,
	stateObserver: i18n.stateObserver,
	on: i18n.stateObserver.on.bind(i18n.stateObserver),
	off: i18n.stateObserver.removeListener.bind(i18n.stateObserver),
	emit: i18n.stateObserver.emit.bind(i18n.stateObserver),
	localize: __webpack_require__( 105 )( i18n ),
	$this: i18n,
	I18N: I18N
};



/***/ }),
/* 53 */,
/* 54 */
/***/ (function(module, exports) {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),
/* 55 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 56 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(57);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 60 */
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object),
    nativeMax = Math.max;

/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign = createAssigner(function(object, source) {
  if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = assign;


/***/ }),
/* 61 */,
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 63 */,
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _close = __webpack_require__(65);

var _close2 = _interopRequireDefault(_close);

var _image = __webpack_require__(235);

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ModalHeader = function (_Component) {
	_inherits(ModalHeader, _Component);

	function ModalHeader(props) {
		_classCallCheck(this, ModalHeader);

		var _this = _possibleConstructorReturn(this, (ModalHeader.__proto__ || Object.getPrototypeOf(ModalHeader)).call(this, props));

		_this.closeModal = _this.props.closeModal.bind(_this);
		return _this;
	}

	_createClass(ModalHeader, [{
		key: 'render',
		value: function render() {
			var children = _react2.default.Children.map(this.props.children, function (content) {
				return content;
			});

			var alignment = !_.isUndefined(this.props.alignment) && '' !== this.props.alignment ? this.props.alignment : '';

			var flatten = !_.isUndefined(this.props.flatten) && true === this.props.flatten ? true : false;

			var hasClose = !_.isUndefined(this.props.canClose) && false === this.props.canClose ? false : true;

			var closeType = !_.isUndefined(this.props.closeType) && '' !== this.props.closeType ? this.props.closeType : '';

			// eslint-disable-next-line max-len
			var closeColor = !_.isUndefined(this.props.closeColor) && '' !== this.props.closeColor ? this.props.closeColor : 'default';

			// eslint-disable-next-line max-len
			var hasImage = !_.isUndefined(this.props.imageName) && '' !== this.props.imageName ? true : false;

			// eslint-disable-next-line max-len
			var isLogo = !_.isUndefined(this.props.imageLogo) && true === this.props.imageLogo ? true : false;

			var hasAlt = !_.isUndefined(this.props.imageAlt) && true === this.props.imageAlt ? this.props.imageAlt : '';

			// eslint-disable-next-line max-len
			var hasClass = !_.isUndefined(this.props.customClass) && '' !== this.props.customClass ? true : false;

			var elClass = 'sui-box-header';

			if ('' !== alignment) {
				elClass += ' sui-content-' + alignment;
			}

			if (true === flatten) {
				elClass += ' sui-flatten';
			}

			if (true === hasImage) {
				elClass += ' sui-spacing-top--60';
			}

			if (true === hasClass) {
				elClass += ' ' + this.props.customClass;
			}

			var markup = _react2.default.createElement(
				'div',
				{ className: elClass },
				true === hasClose && _react2.default.createElement(_close2.default, _extends({
					type: closeType,
					float: 'right',
					color: closeColor
				}, hasClose && { closeModal: this.closeModal })),
				true === hasImage && _react2.default.createElement(_image2.default, {
					logo: isLogo,
					filename: this.props.imageName,
					alt: hasAlt
				}),
				children
			);

			if ('center' !== alignment) {
				markup = _react2.default.createElement(
					_react2.default.Fragment,
					null,
					true === hasClose && _react2.default.createElement(_close2.default, _extends({
						sronly: true
					}, hasClose && { closeModal: this.closeModal })),
					_react2.default.createElement(
						'div',
						{ className: elClass },
						true === hasImage && _react2.default.createElement(_image2.default, {
							logo: isLogo,
							filename: this.props.imageName,
							alt: hasAlt
						}),
						children,
						_react2.default.createElement(
							'div',
							{ className: 'sui-actions-right' },
							true === hasClose && _react2.default.createElement(_close2.default, {
								type: closeType,
								color: closeColor,
								closeModal: this.closeModal
							})
						)
					)
				);
			}

			return markup;
		}
	}]);

	return ModalHeader;
}(_react.Component);

exports.default = ModalHeader;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ModalClose = function (_Component) {
	_inherits(ModalClose, _Component);

	function ModalClose(props) {
		_classCallCheck(this, ModalClose);

		var _this = _possibleConstructorReturn(this, (ModalClose.__proto__ || Object.getPrototypeOf(ModalClose)).call(this, props));

		_this.closeModal = _this.props.closeModal.bind(_this);
		return _this;
	}

	_createClass(ModalClose, [{
		key: 'render',
		value: function render() {
			var label = !_.isUndefined(this.props.label) && '' !== this.props.label ? this.props.label : (0, _utils.translate)('Close this dialog');

			var color = !_.isUndefined(this.props.color) && '' !== this.props.color ? this.props.color : '';

			var isIcon = !_.isUndefined(this.props.type) && 'icon' === this.props.type ? true : false;

			var isHidden = !_.isUndefined(this.props.sronly) && true === this.props.sronly ? true : false;

			var hasIcon = !_.isUndefined(this.props.icon) && '' !== this.props.icon ? true : false;

			var floatsLeft = !_.isUndefined(this.props.float) && 'left' === this.props.float ? true : false;

			var floatsRight = !_.isUndefined(this.props.float) && 'right' === this.props.float ? true : false;

			// eslint-disable-next-line max-len
			var hasCustomClass = !_.isUndefined(this.props.customClass) && '' !== this.props.customClass ? true : false;

			var elClass = 'sui-button';

			if (true === isHidden) {
				elClass = 'sui-screen-reader-text';
			} else if (false === isHidden && true === isIcon) {
				elClass = 'sui-button-icon';
			}

			if (false === isHidden && '' !== color) {
				elClass += ' sui-button-' + color;
			}

			if (false === isHidden && (true === floatsLeft || true === floatsRight)) {
				elClass += ' sui-button-float--' + this.props.float;
			}

			if (true === hasCustomClass) {
				elClass += ' ' + this.props.customClass;
			}

			elClass += ' modal-close-button';

			return _react2.default.createElement(
				'button',
				{ className: elClass, onClick: this.closeModal },
				true === isIcon && _react2.default.createElement('i', { className: 'sui-icon-close sui-md', 'aria-hidden': 'true' }),
				true === hasIcon && _react2.default.createElement('i', { className: 'sui-icon-' + this.props.icon, 'aria-hidden': 'true' }),
				true === isIcon ? _react2.default.createElement(
					'span',
					{ className: 'sui-screen-reader-text' },
					label
				) : label
			);
		}
	}]);

	return ModalClose;
}(_react.Component);

exports.default = ModalClose;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ModalTitle = function (_Component) {
	_inherits(ModalTitle, _Component);

	function ModalTitle(props) {
		_classCallCheck(this, ModalTitle);

		return _possibleConstructorReturn(this, (ModalTitle.__proto__ || Object.getPrototypeOf(ModalTitle)).call(this, props));
	}

	_createClass(ModalTitle, [{
		key: 'render',
		value: function render() {
			var titleId = this.props.id ? 'modal-' + this.props.id + '--title' : 'unique-id-required';

			var titleLabel = this.props.label ? this.props.label : 'A title is required for your modals';

			var titleTag = !_.isUndefined(this.props.tag) && '' !== this.props.tag ? this.props.tag : '';

			// eslint-disable-next-line max-len
			var titleTagColor = !_.isUndefined(this.props.tagColor) && '' !== this.props.tagColor ? ' sui-tag-' + this.props.titleTagColor : '';

			var titleClass = 'sui-box-title';

			if ('lg' === this.props.size) {
				titleClass += ' sui-lg';
			}

			if (!_.isUndefined(this.props.customClass) && '' !== this.props.customClass) {
				titleClass += ' ' + this.props.customClass;
			}

			return _react2.default.createElement(
				'h3',
				{ id: titleId, className: titleClass },
				titleLabel,
				'' !== titleTag && _react2.default.createElement(
					'span',
					{
						className: 'sui-tag' + titleTagColor,
						style: { marginTop: '-2px', marginLeft: '10px' }
					},
					titleTag
				)
			);
		}
	}]);

	return ModalTitle;
}(_react.Component);

exports.default = ModalTitle;

/***/ }),
/* 67 */,
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return subscriptionShape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return storeShape; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_prop_types__);


var subscriptionShape = __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.shape({
  trySubscribe: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  tryUnsubscribe: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  notifyNestedSubs: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  isSubscribed: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired
});

var storeShape = __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.shape({
  subscribe: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  dispatch: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  getState: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired
});

/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (immutable) */ __webpack_exports__["a"] = connectAdvanced;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_hoist_non_react_statics__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_hoist_non_react_statics___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_hoist_non_react_statics__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_Subscription__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_PropTypes__ = __webpack_require__(68);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }








var hotReloadingVersion = 0;
var dummyState = {};
function noop() {}
function makeSelectorStateful(sourceSelector, store) {
  // wrap the selector in an object that tracks its results between runs.
  var selector = {
    run: function runComponentSelector(props) {
      try {
        var nextProps = sourceSelector(store.getState(), props);
        if (nextProps !== selector.props || selector.error) {
          selector.shouldComponentUpdate = true;
          selector.props = nextProps;
          selector.error = null;
        }
      } catch (error) {
        selector.shouldComponentUpdate = true;
        selector.error = error;
      }
    }
  };

  return selector;
}

function connectAdvanced(
/*
  selectorFactory is a func that is responsible for returning the selector function used to
  compute new props from state, props, and dispatch. For example:
     export default connectAdvanced((dispatch, options) => (state, props) => ({
      thing: state.things[props.thingId],
      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
    }))(YourComponent)
   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
  outside of their selector as an optimization. Options passed to connectAdvanced are passed to
  the selectorFactory, along with displayName and WrappedComponent, as the second argument.
   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
  props. Do not use connectAdvanced directly without memoizing results between calls to your
  selector, otherwise the Connect component will re-render on every state or props change.
*/
selectorFactory) {
  var _contextTypes, _childContextTypes;

  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$getDisplayName = _ref.getDisplayName,
      getDisplayName = _ref$getDisplayName === undefined ? function (name) {
    return 'ConnectAdvanced(' + name + ')';
  } : _ref$getDisplayName,
      _ref$methodName = _ref.methodName,
      methodName = _ref$methodName === undefined ? 'connectAdvanced' : _ref$methodName,
      _ref$renderCountProp = _ref.renderCountProp,
      renderCountProp = _ref$renderCountProp === undefined ? undefined : _ref$renderCountProp,
      _ref$shouldHandleStat = _ref.shouldHandleStateChanges,
      shouldHandleStateChanges = _ref$shouldHandleStat === undefined ? true : _ref$shouldHandleStat,
      _ref$storeKey = _ref.storeKey,
      storeKey = _ref$storeKey === undefined ? 'store' : _ref$storeKey,
      _ref$withRef = _ref.withRef,
      withRef = _ref$withRef === undefined ? false : _ref$withRef,
      connectOptions = _objectWithoutProperties(_ref, ['getDisplayName', 'methodName', 'renderCountProp', 'shouldHandleStateChanges', 'storeKey', 'withRef']);

  var subscriptionKey = storeKey + 'Subscription';
  var version = hotReloadingVersion++;

  var contextTypes = (_contextTypes = {}, _contextTypes[storeKey] = __WEBPACK_IMPORTED_MODULE_4__utils_PropTypes__["a" /* storeShape */], _contextTypes[subscriptionKey] = __WEBPACK_IMPORTED_MODULE_4__utils_PropTypes__["b" /* subscriptionShape */], _contextTypes);
  var childContextTypes = (_childContextTypes = {}, _childContextTypes[subscriptionKey] = __WEBPACK_IMPORTED_MODULE_4__utils_PropTypes__["b" /* subscriptionShape */], _childContextTypes);

  return function wrapWithConnect(WrappedComponent) {
    __WEBPACK_IMPORTED_MODULE_1_invariant___default()(typeof WrappedComponent == 'function', 'You must pass a component to the function returned by ' + (methodName + '. Instead received ' + JSON.stringify(WrappedComponent)));

    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';

    var displayName = getDisplayName(wrappedComponentName);

    var selectorFactoryOptions = _extends({}, connectOptions, {
      getDisplayName: getDisplayName,
      methodName: methodName,
      renderCountProp: renderCountProp,
      shouldHandleStateChanges: shouldHandleStateChanges,
      storeKey: storeKey,
      withRef: withRef,
      displayName: displayName,
      wrappedComponentName: wrappedComponentName,
      WrappedComponent: WrappedComponent
    });

    var Connect = function (_Component) {
      _inherits(Connect, _Component);

      function Connect(props, context) {
        _classCallCheck(this, Connect);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

        _this.version = version;
        _this.state = {};
        _this.renderCount = 0;
        _this.store = props[storeKey] || context[storeKey];
        _this.propsMode = Boolean(props[storeKey]);
        _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);

        __WEBPACK_IMPORTED_MODULE_1_invariant___default()(_this.store, 'Could not find "' + storeKey + '" in either the context or props of ' + ('"' + displayName + '". Either wrap the root component in a <Provider>, ') + ('or explicitly pass "' + storeKey + '" as a prop to "' + displayName + '".'));

        _this.initSelector();
        _this.initSubscription();
        return _this;
      }

      Connect.prototype.getChildContext = function getChildContext() {
        var _ref2;

        // If this component received store from props, its subscription should be transparent
        // to any descendants receiving store+subscription from context; it passes along
        // subscription passed to it. Otherwise, it shadows the parent subscription, which allows
        // Connect to control ordering of notifications to flow top-down.
        var subscription = this.propsMode ? null : this.subscription;
        return _ref2 = {}, _ref2[subscriptionKey] = subscription || this.context[subscriptionKey], _ref2;
      };

      Connect.prototype.componentDidMount = function componentDidMount() {
        if (!shouldHandleStateChanges) return;

        // componentWillMount fires during server side rendering, but componentDidMount and
        // componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.
        // Otherwise, unsubscription would never take place during SSR, causing a memory leak.
        // To handle the case where a child component may have triggered a state change by
        // dispatching an action in its componentWillMount, we have to re-run the select and maybe
        // re-render.
        this.subscription.trySubscribe();
        this.selector.run(this.props);
        if (this.selector.shouldComponentUpdate) this.forceUpdate();
      };

      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        this.selector.run(nextProps);
      };

      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
        return this.selector.shouldComponentUpdate;
      };

      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.subscription) this.subscription.tryUnsubscribe();
        this.subscription = null;
        this.notifyNestedSubs = noop;
        this.store = null;
        this.selector.run = noop;
        this.selector.shouldComponentUpdate = false;
      };

      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
        __WEBPACK_IMPORTED_MODULE_1_invariant___default()(withRef, 'To access the wrapped instance, you need to specify ' + ('{ withRef: true } in the options argument of the ' + methodName + '() call.'));
        return this.wrappedInstance;
      };

      Connect.prototype.setWrappedInstance = function setWrappedInstance(ref) {
        this.wrappedInstance = ref;
      };

      Connect.prototype.initSelector = function initSelector() {
        var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);
        this.selector = makeSelectorStateful(sourceSelector, this.store);
        this.selector.run(this.props);
      };

      Connect.prototype.initSubscription = function initSubscription() {
        if (!shouldHandleStateChanges) return;

        // parentSub's source should match where store came from: props vs. context. A component
        // connected to the store via props shouldn't use subscription from context, or vice versa.
        var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];
        this.subscription = new __WEBPACK_IMPORTED_MODULE_3__utils_Subscription__["a" /* default */](this.store, parentSub, this.onStateChange.bind(this));

        // `notifyNestedSubs` is duplicated to handle the case where the component is  unmounted in
        // the middle of the notification loop, where `this.subscription` will then be null. An
        // extra null check every change can be avoided by copying the method onto `this` and then
        // replacing it with a no-op on unmount. This can probably be avoided if Subscription's
        // listeners logic is changed to not call listeners that have been unsubscribed in the
        // middle of the notification loop.
        this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);
      };

      Connect.prototype.onStateChange = function onStateChange() {
        this.selector.run(this.props);

        if (!this.selector.shouldComponentUpdate) {
          this.notifyNestedSubs();
        } else {
          this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;
          this.setState(dummyState);
        }
      };

      Connect.prototype.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate() {
        // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it
        // needs to notify nested subs. Once called, it unimplements itself until further state
        // changes occur. Doing it this way vs having a permanent `componentDidUpdate` that does
        // a boolean check every time avoids an extra method call most of the time, resulting
        // in some perf boost.
        this.componentDidUpdate = undefined;
        this.notifyNestedSubs();
      };

      Connect.prototype.isSubscribed = function isSubscribed() {
        return Boolean(this.subscription) && this.subscription.isSubscribed();
      };

      Connect.prototype.addExtraProps = function addExtraProps(props) {
        if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props;
        // make a shallow copy so that fields added don't leak to the original selector.
        // this is especially important for 'ref' since that's a reference back to the component
        // instance. a singleton memoized selector would then be holding a reference to the
        // instance, preventing the instance from being garbage collected, and that would be bad
        var withExtras = _extends({}, props);
        if (withRef) withExtras.ref = this.setWrappedInstance;
        if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;
        if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription;
        return withExtras;
      };

      Connect.prototype.render = function render() {
        var selector = this.selector;
        selector.shouldComponentUpdate = false;

        if (selector.error) {
          throw selector.error;
        } else {
          return Object(__WEBPACK_IMPORTED_MODULE_2_react__["createElement"])(WrappedComponent, this.addExtraProps(selector.props));
        }
      };

      return Connect;
    }(__WEBPACK_IMPORTED_MODULE_2_react__["Component"]);

    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = displayName;
    Connect.childContextTypes = childContextTypes;
    Connect.contextTypes = contextTypes;
    Connect.propTypes = contextTypes;

    if (process.env.NODE_ENV !== 'production') {
      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
        var _this2 = this;

        // We are hot reloading!
        if (this.version !== version) {
          this.version = version;
          this.initSelector();

          // If any connected descendants don't hot reload (and resubscribe in the process), their
          // listeners will be lost when we unsubscribe. Unfortunately, by copying over all
          // listeners, this does mean that the old versions of connected descendants will still be
          // notified of state changes; however, their onStateChange function is a no-op so this
          // isn't a huge deal.
          var oldListeners = [];

          if (this.subscription) {
            oldListeners = this.subscription.listeners.get();
            this.subscription.tryUnsubscribe();
          }
          this.initSubscription();
          if (shouldHandleStateChanges) {
            this.subscription.trySubscribe();
            oldListeners.forEach(function (listener) {
              return _this2.subscription.listeners.subscribe(listener);
            });
          }
        }
      };
    }

    return __WEBPACK_IMPORTED_MODULE_0_hoist_non_react_statics___default()(Connect, WrappedComponent);
  };
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)))

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try { // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
}

module.exports = hoistNonReactStatics;


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (immutable) */ __webpack_exports__["a"] = wrapMapToPropsConstant;
/* unused harmony export getDependsOnOwnProps */
/* harmony export (immutable) */ __webpack_exports__["b"] = wrapMapToPropsFunc;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_verifyPlainObject__ = __webpack_require__(72);


function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant = getConstant(dispatch, options);

    function constantSelector() {
      return constant;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}

// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
// whether mapToProps needs to be invoked when props have changed.
// 
// A length of one signals that mapToProps does not depend on props from the parent component.
// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
// therefore not reporting its length accurately..
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}

// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
// this function wraps mapToProps in a proxy function which does several things:
// 
//  * Detects whether the mapToProps function being called depends on props, which
//    is used by selectorFactory to decide if it should reinvoke on props changes.
//    
//  * On first call, handles mapToProps if returns another function, and treats that
//    new function as the true mapToProps for subsequent calls.
//    
//  * On first call, verifies the first result is a plain object, in order to warn
//    the developer that their mapToProps function is not returning a valid result.
//    
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref) {
    var displayName = _ref.displayName;

    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    };

    // allow detectFactoryAndVerify to get ownProps
    proxy.dependsOnOwnProps = true;

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);

      if (typeof props === 'function') {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }

      if (process.env.NODE_ENV !== 'production') Object(__WEBPACK_IMPORTED_MODULE_0__utils_verifyPlainObject__["a" /* default */])(props, displayName, methodName);

      return props;
    };

    return proxy;
  };
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)))

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = verifyPlainObject;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__warning__ = __webpack_require__(45);



function verifyPlainObject(value, displayName, methodName) {
  if (!Object(__WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__["a" /* default */])(value)) {
    Object(__WEBPACK_IMPORTED_MODULE_1__warning__["a" /* default */])(methodName + '() in ' + displayName + ' must return a plain object. Instead received ' + value + '.');
  }
}

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(128);


/** Built-in value references. */
var Symbol = __WEBPACK_IMPORTED_MODULE_0__root_js__["a" /* default */].Symbol;

/* harmony default export */ __webpack_exports__["a"] = (Symbol);


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return canUseDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return removeEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getConfirmation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return supportsHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return supportsPopStateOnHashChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return supportsGoWithoutReloadUsingHash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isExtraneousPopstateEvent; });
var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history__ = __webpack_require__(24);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var isModifiedEvent = function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
};

/**
 * The public API for rendering a history-aware <a>.
 */

var Link = function (_React$Component) {
  _inherits(Link, _React$Component);

  function Link() {
    var _temp, _this, _ret;

    _classCallCheck(this, Link);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {
      if (_this.props.onClick) _this.props.onClick(event);

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && // ignore everything but left clicks
      !_this.props.target && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();

          var history = _this.context.router.history;
          var _this$props = _this.props,
              replace = _this$props.replace,
              to = _this$props.to;


          if (replace) {
            history.replace(to);
          } else {
            history.push(to);
          }
        }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Link.prototype.render = function render() {
    var _props = this.props,
        replace = _props.replace,
        to = _props.to,
        innerRef = _props.innerRef,
        props = _objectWithoutProperties(_props, ["replace", "to", "innerRef"]); // eslint-disable-line no-unused-vars

    __WEBPACK_IMPORTED_MODULE_2_invariant___default()(this.context.router, "You should not use <Link> outside a <Router>");

    __WEBPACK_IMPORTED_MODULE_2_invariant___default()(to !== undefined, 'You must specify the "to" property');

    var history = this.context.router.history;

    var location = typeof to === "string" ? Object(__WEBPACK_IMPORTED_MODULE_3_history__["c" /* createLocation */])(to, null, null, history.location) : to;

    var href = history.createHref(location);
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("a", _extends({}, props, { onClick: this.handleClick, href: href, ref: innerRef }));
  };

  return Link;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Link.propTypes = {
  onClick: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  target: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  replace: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  to: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object]).isRequired,
  innerRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func])
};
Link.defaultProps = {
  replace: false
};
Link.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    history: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
      push: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
      replace: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
      createHref: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired
    }).isRequired
  }).isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Link);

/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Route__ = __webpack_require__(77);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Route__["a" /* default */]);

/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__matchPath__ = __webpack_require__(49);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var isEmptyChildren = function isEmptyChildren(children) {
  return __WEBPACK_IMPORTED_MODULE_2_react___default.a.Children.count(children) === 0;
};

/**
 * The public API for matching a single path and rendering.
 */

var Route = function (_React$Component) {
  _inherits(Route, _React$Component);

  function Route() {
    var _temp, _this, _ret;

    _classCallCheck(this, Route);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props, _this.context.router)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Route.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        route: {
          location: this.props.location || this.context.router.route.location,
          match: this.state.match
        }
      })
    };
  };

  Route.prototype.computeMatch = function computeMatch(_ref, router) {
    var computedMatch = _ref.computedMatch,
        location = _ref.location,
        path = _ref.path,
        strict = _ref.strict,
        exact = _ref.exact,
        sensitive = _ref.sensitive;

    if (computedMatch) return computedMatch; // <Switch> already computed the match for us

    __WEBPACK_IMPORTED_MODULE_1_invariant___default()(router, "You should not use <Route> or withRouter() outside a <Router>");

    var route = router.route;

    var pathname = (location || route.location).pathname;

    return Object(__WEBPACK_IMPORTED_MODULE_4__matchPath__["a" /* default */])(pathname, { path: path, strict: strict, exact: exact, sensitive: sensitive }, route.match);
  };

  Route.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(this.props.component && this.props.render), "You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored");

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(this.props.component && this.props.children && !isEmptyChildren(this.props.children)), "You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored");

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(this.props.render && this.props.children && !isEmptyChildren(this.props.children)), "You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored");
  };

  Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');

    this.setState({
      match: this.computeMatch(nextProps, nextContext.router)
    });
  };

  Route.prototype.render = function render() {
    var match = this.state.match;
    var _props = this.props,
        children = _props.children,
        component = _props.component,
        render = _props.render;
    var _context$router = this.context.router,
        history = _context$router.history,
        route = _context$router.route,
        staticContext = _context$router.staticContext;

    var location = this.props.location || route.location;
    var props = { match: match, location: location, history: history, staticContext: staticContext };

    if (component) return match ? __WEBPACK_IMPORTED_MODULE_2_react___default.a.createElement(component, props) : null;

    if (render) return match ? render(props) : null;

    if (typeof children === "function") return children(props);

    if (children && !isEmptyChildren(children)) return __WEBPACK_IMPORTED_MODULE_2_react___default.a.Children.only(children);

    return null;
  };

  return Route;
}(__WEBPACK_IMPORTED_MODULE_2_react___default.a.Component);

Route.propTypes = {
  computedMatch: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object, // private, from <Switch>
  path: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.string,
  exact: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool,
  strict: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool,
  sensitive: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool,
  component: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.func,
  render: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.func,
  children: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.func, __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.node]),
  location: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object
};
Route.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.shape({
    history: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired,
    route: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired,
    staticContext: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object
  })
};
Route.childContextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Route);

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var isarray = __webpack_require__(149)

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = options && options.delimiter || '/'
  var res

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      continue
    }

    var next = str[index]
    var prefix = res[2]
    var name = res[3]
    var capture = res[4]
    var group = res[5]
    var modifier = res[6]
    var asterisk = res[7]

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
    }

    var partial = prefix != null && next != null && next !== prefix
    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var delimiter = res[2] || defaultDelimiter
    var pattern = capture || group

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    })
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index)
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path)
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')
    }
  }

  return function (obj, opts) {
    var path = ''
    var data = obj || {}
    var options = opts || {}
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token

        continue
      }

      var value = data[token.name]
      var segment

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j])

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      })
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var route = ''

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
    } else {
      var prefix = escapeString(token.prefix)
      var capture = '(?:' + token.pattern + ')'

      keys.push(token)

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*'
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?'
        } else {
          capture = prefix + '(' + capture + ')?'
        }
      } else {
        capture = prefix + '(' + capture + ')'
      }

      route += capture
    }
  }

  var delimiter = escapeString(options.delimiter || '/')
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
  }

  if (end) {
    route += '$'
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}


/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path_to_regexp__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path_to_regexp___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_path_to_regexp__);


var patternCache = {};
var cacheLimit = 10000;
var cacheCount = 0;

var compileGenerator = function compileGenerator(pattern) {
  var cacheKey = pattern;
  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});

  if (cache[pattern]) return cache[pattern];

  var compiledGenerator = __WEBPACK_IMPORTED_MODULE_0_path_to_regexp___default.a.compile(pattern);

  if (cacheCount < cacheLimit) {
    cache[pattern] = compiledGenerator;
    cacheCount++;
  }

  return compiledGenerator;
};

/**
 * Public API for generating a URL pathname from a pattern and parameters.
 */
var generatePath = function generatePath() {
  var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "/";
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (pattern === "/") {
    return pattern;
  }
  var generator = compileGenerator(pattern);
  return generator(params, { pretty: true });
};

/* harmony default export */ __webpack_exports__["a"] = (generatePath);

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(14);
var settle = __webpack_require__(166);
var buildURL = __webpack_require__(168);
var parseHeaders = __webpack_require__(169);
var isURLSameOrigin = __webpack_require__(170);
var createError = __webpack_require__(82);
var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(171);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if (process.env.NODE_ENV !== 'test' &&
        typeof window !== 'undefined' &&
        window.XDomainRequest && !('withCredentials' in request) &&
        !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || (request.readyState !== 4 && !xDomain)) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(172);

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(167);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    var obj;

    while (queue.length) {
        var item = queue.pop();
        obj = item.obj[item.prop];

        if (Array.isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }

    return obj;
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (typeof target === 'object') {
            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                if (target[i] && typeof target[i] === 'object') {
                    target[i] = merge(target[i], item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};

var encode = function encode(str) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    return compactQueue(queue);
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (obj === null || typeof obj === 'undefined') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ModalFooter = function (_Component) {
	_inherits(ModalFooter, _Component);

	function ModalFooter(props) {
		_classCallCheck(this, ModalFooter);

		return _possibleConstructorReturn(this, (ModalFooter.__proto__ || Object.getPrototypeOf(ModalFooter)).call(this, props));
	}

	_createClass(ModalFooter, [{
		key: 'render',
		value: function render() {
			var children = _react2.default.Children.map(this.props.children, function (footerChildren) {
				return footerChildren;
			});

			var alignment = !_.isUndefined(this.props.alignment) && '' !== this.props.alignment ? this.props.alignment : '';

			var flatten = !_.isUndefined(this.props.flatten) && true === this.props.flatten ? true : false;

			// eslint-disable-next-line max-len
			var hasClass = !_.isUndefined(this.props.customClass) && '' !== this.props.customClass ? true : false;

			var elClass = 'sui-box-footer';

			if (true === flatten) {
				elClass += ' sui-flatten';
			}

			if ('' !== alignment) {
				elClass += ' sui-content-' + alignment;
			}

			if (true === hasClass) {
				elClass += ' ' + this.props.customClass;
			}

			return _react2.default.createElement(
				'div',
				{ className: elClass },
				children
			);
		}
	}]);

	return ModalFooter;
}(_react.Component);

exports.default = ModalFooter;

/***/ }),
/* 88 */,
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.renderBlock = renderBlock;

var _reactDom = __webpack_require__(23);

var _client = __webpack_require__(90);

var _semver = __webpack_require__(91);

var _semver2 = _interopRequireDefault(_semver);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * render Block
 **/
function renderBlock(containerId, element) {
	var container = document.getElementById(containerId);

	// If container is hidden in PHP.
	if (_.isNull(container)) {
		return;
	}

	if (_semver2.default.gte(_reactDom.version, '18.0.0')) {
		// React 18 or higher.
		var root = (0, _client.createRoot)(container);
		root.render(element);
	} else {
		(0, _reactDom.render)(element, container);
	}
}

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var m = __webpack_require__(23);
if (process.env.NODE_ENV === 'production') {
  exports.createRoot = m.createRoot;
  exports.hydrateRoot = m.hydrateRoot;
} else {
  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  exports.createRoot = function(c, o) {
    i.usingClientEntryPoint = true;
    try {
      return m.createRoot(c, o);
    } finally {
      i.usingClientEntryPoint = false;
    }
  };
  exports.hydrateRoot = function(c, h, o) {
    i.usingClientEntryPoint = true;
    try {
      return m.hydrateRoot(c, h, o);
    } finally {
      i.usingClientEntryPoint = false;
    }
  };
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = SemVer;

// The debug function is excluded entirely from the minified version.
/* nomin */ var debug;
/* nomin */ if (typeof process === 'object' &&
    /* nomin */ process.env &&
    /* nomin */ process.env.NODE_DEBUG &&
    /* nomin */ /\bsemver\b/i.test(process.env.NODE_DEBUG))
  /* nomin */ debug = function() {
    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);
    /* nomin */ args.unshift('SEMVER');
    /* nomin */ console.log.apply(console, args);
    /* nomin */ };
/* nomin */ else
  /* nomin */ debug = function() {};

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0';

var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16;

// The actual regexps go on exports.re
var re = exports.re = [];
var src = exports.src = [];
var R = 0;

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';


// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';


// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')';

var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')';

var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')';


// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';


// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?';

src[FULL] = '^' + FULLPLAIN + '$';

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?';

var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';

var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)';

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?';

var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?';

var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++;
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])';

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';

var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';

var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++;
src[LONECARET] = '(?:\\^)';

var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';

var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';


// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3';


// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$';

var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$';

// Star ranges basically just allow anything at all.
var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*';

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i]);
  if (!re[i])
    re[i] = new RegExp(src[i]);
}

exports.parse = parse;
function parse(version, loose) {
  if (version instanceof SemVer)
    return version;

  if (typeof version !== 'string')
    return null;

  if (version.length > MAX_LENGTH)
    return null;

  var r = loose ? re[LOOSE] : re[FULL];
  if (!r.test(version))
    return null;

  try {
    return new SemVer(version, loose);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;
function valid(version, loose) {
  var v = parse(version, loose);
  return v ? v.version : null;
}


exports.clean = clean;
function clean(version, loose) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, loose) {
  if (version instanceof SemVer) {
    if (version.loose === loose)
      return version;
    else
      version = version.version;
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH)
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')

  if (!(this instanceof SemVer))
    return new SemVer(version, loose);

  debug('SemVer', version, loose);
  this.loose = loose;
  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);

  if (!m)
    throw new TypeError('Invalid Version: ' + version);

  this.raw = version;

  // these are actually numbers
  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0)
    throw new TypeError('Invalid major version')

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
    throw new TypeError('Invalid minor version')

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
    throw new TypeError('Invalid patch version')

  // numberify any prerelease numeric ids
  if (!m[4])
    this.prerelease = [];
  else
    this.prerelease = m[4].split('.').map(function(id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;
        if (num >= 0 && num < MAX_SAFE_INTEGER)
          return num;
      }
      return id;
    });

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function() {
  this.version = this.major + '.' + this.minor + '.' + this.patch;
  if (this.prerelease.length)
    this.version += '-' + this.prerelease.join('.');
  return this.version;
};

SemVer.prototype.toString = function() {
  return this.version;
};

SemVer.prototype.compare = function(other) {
  debug('SemVer.compare', this.version, this.loose, other);
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length)
    return -1;
  else if (!this.prerelease.length && other.prerelease.length)
    return 1;
  else if (!this.prerelease.length && !other.prerelease.length)
    return 0;

  var i = 0;
  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);
    if (a === undefined && b === undefined)
      return 0;
    else if (b === undefined)
      return 1;
    else if (a === undefined)
      return -1;
    else if (a === b)
      continue;
    else
      return compareIdentifiers(a, b);
  } while (++i);
};

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function(release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;
    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0)
        this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
        this.major++;
      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0)
        this.minor++;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0)
        this.patch++;
      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0)
        this.prerelease = [0];
      else {
        var i = this.prerelease.length;
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }
        if (i === -1) // didn't increment anything
          this.prerelease.push(0);
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1]))
            this.prerelease = [identifier, 0];
        } else
          this.prerelease = [identifier, 0];
      }
      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }
  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;
function inc(version, release, loose, identifier) {
  if (typeof(loose) === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;
function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    if (v1.prerelease.length || v2.prerelease.length) {
      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return 'pre'+key;
          }
        }
      }
      return 'prerelease';
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return key;
        }
      }
    }
  }
}

exports.compareIdentifiers = compareIdentifiers;

var numeric = /^[0-9]+$/;
function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return (anum && !bnum) ? -1 :
         (bnum && !anum) ? 1 :
         a < b ? -1 :
         a > b ? 1 :
         0;
}

exports.rcompareIdentifiers = rcompareIdentifiers;
function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;
function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;
function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;
function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;
function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;
function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;
function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;
function sort(list, loose) {
  return list.sort(function(a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;
function rsort(list, loose) {
  return list.sort(function(a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;
function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;
function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;
function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;
function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;
function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;
function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;
function cmp(a, op, b, loose) {
  var ret;
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a === b;
      break;
    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a !== b;
      break;
    case '': case '=': case '==': ret = eq(a, b, loose); break;
    case '!=': ret = neq(a, b, loose); break;
    case '>': ret = gt(a, b, loose); break;
    case '>=': ret = gte(a, b, loose); break;
    case '<': ret = lt(a, b, loose); break;
    case '<=': ret = lte(a, b, loose); break;
    default: throw new TypeError('Invalid operator: ' + op);
  }
  return ret;
}

exports.Comparator = Comparator;
function Comparator(comp, loose) {
  if (comp instanceof Comparator) {
    if (comp.loose === loose)
      return comp;
    else
      comp = comp.value;
  }

  if (!(this instanceof Comparator))
    return new Comparator(comp, loose);

  debug('comparator', comp, loose);
  this.loose = loose;
  this.parse(comp);

  if (this.semver === ANY)
    this.value = '';
  else
    this.value = this.operator + this.semver.version;

  debug('comp', this);
}

var ANY = {};
Comparator.prototype.parse = function(comp) {
  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m)
    throw new TypeError('Invalid comparator: ' + comp);

  this.operator = m[1];
  if (this.operator === '=')
    this.operator = '';

  // if it literally is just '>' or '' then allow anything.
  if (!m[2])
    this.semver = ANY;
  else
    this.semver = new SemVer(m[2], this.loose);
};

Comparator.prototype.toString = function() {
  return this.value;
};

Comparator.prototype.test = function(version) {
  debug('Comparator.test', version, this.loose);

  if (this.semver === ANY)
    return true;

  if (typeof version === 'string')
    version = new SemVer(version, this.loose);

  return cmp(version, this.operator, this.semver, this.loose);
};

Comparator.prototype.intersects = function(comp, loose) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  var rangeTmp;

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, loose);
    return satisfies(this.value, rangeTmp, loose);
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, loose);
    return satisfies(comp.semver, rangeTmp, loose);
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, loose) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'));
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, loose) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'));

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};


exports.Range = Range;
function Range(range, loose) {
  if (range instanceof Range) {
    if (range.loose === loose) {
      return range;
    } else {
      return new Range(range.raw, loose);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, loose);
  }

  if (!(this instanceof Range))
    return new Range(range, loose);

  this.loose = loose;

  // First, split based on boolean or ||
  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function(range) {
    return this.parseRange(range.trim());
  }, this).filter(function(c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function() {
  this.range = this.set.map(function(comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function() {
  return this.range;
};

Range.prototype.parseRange = function(range) {
  var loose = this.loose;
  range = range.trim();
  debug('range', range, loose);
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range);
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[COMPARATORTRIM]);

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace);

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace);

  // normalize spaces
  range = range.split(/\s+/).join(' ');

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function(comp) {
    return parseComparator(comp, loose);
  }).join(' ').split(/\s+/);
  if (this.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function(comp) {
      return !!comp.match(compRe);
    });
  }
  set = set.map(function(comp) {
    return new Comparator(comp, loose);
  });

  return set;
};

Range.prototype.intersects = function(range, loose) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function(thisComparators) {
    return thisComparators.every(function(thisComparator) {
      return range.set.some(function(rangeComparators) {
        return rangeComparators.every(function(rangeComparator) {
          return thisComparator.intersects(rangeComparator, loose);
        });
      });
    });
  });
};

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators;
function toComparators(range, loose) {
  return new Range(range, loose).set.map(function(comp) {
    return comp.map(function(c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator(comp, loose) {
  debug('comp', comp);
  comp = replaceCarets(comp, loose);
  debug('caret', comp);
  comp = replaceTildes(comp, loose);
  debug('tildes', comp);
  comp = replaceXRanges(comp, loose);
  debug('xrange', comp);
  comp = replaceStars(comp, loose);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes(comp, loose) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceTilde(comp, loose);
  }).join(' ');
}

function replaceTilde(comp, loose) {
  var r = loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p))
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    else if (pr) {
      debug('replaceTilde pr', pr);
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      ret = '>=' + M + '.' + m + '.' + p + pr +
            ' <' + M + '.' + (+m + 1) + '.0';
    } else
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0';

    debug('tilde return', ret);
    return ret;
  });
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets(comp, loose) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceCaret(comp, loose);
  }).join(' ');
}

function replaceCaret(comp, loose) {
  debug('caret', comp, loose);
  var r = loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p)) {
      if (M === '0')
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      else
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
    } else if (pr) {
      debug('replaceCaret pr', pr);
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p + pr +
              ' <' + (+M + 1) + '.0.0';
    } else {
      debug('no pr');
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0';
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, loose) {
  debug('replaceXRanges', comp, loose);
  return comp.split(/\s+/).map(function(comp) {
    return replaceXRange(comp, loose);
  }).join(' ');
}

function replaceXRange(comp, loose) {
  comp = comp.trim();
  var r = loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX)
      gtlt = '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // replace X with 0
      if (xm)
        m = 0;
      if (xp)
        p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else if (xp) {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';
        if (xm)
          M = +M + 1;
        else
          m = +m + 1;
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    debug('xRange return', ret);

    return ret;
  });
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars(comp, loose) {
  debug('replaceStars', comp, loose);
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '');
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace($0,
                       from, fM, fm, fp, fpr, fb,
                       to, tM, tm, tp, tpr, tb) {

  if (isX(fM))
    from = '';
  else if (isX(fm))
    from = '>=' + fM + '.0.0';
  else if (isX(fp))
    from = '>=' + fM + '.' + fm + '.0';
  else
    from = '>=' + from;

  if (isX(tM))
    to = '';
  else if (isX(tm))
    to = '<' + (+tM + 1) + '.0.0';
  else if (isX(tp))
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  else if (tpr)
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  else
    to = '<=' + to;

  return (from + ' ' + to).trim();
}


// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function(version) {
  if (!version)
    return false;

  if (typeof version === 'string')
    version = new SemVer(version, this.loose);

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version))
      return true;
  }
  return false;
};

function testSet(set, version) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version))
      return false;
  }

  if (version.prerelease.length) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (var i = 0; i < set.length; i++) {
      debug(set[i].semver);
      if (set[i].semver === ANY)
        continue;

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch)
          return true;
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false;
  }

  return true;
}

exports.satisfies = satisfies;
function satisfies(version, range, loose) {
  try {
    range = new Range(range, loose);
  } catch (er) {
    return false;
  }
  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;
function maxSatisfying(versions, range, loose) {
  var max = null;
  var maxSV = null;
  try {
    var rangeObj = new Range(range, loose);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) { // satisfies(v, range, loose)
      if (!max || maxSV.compare(v) === -1) { // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, loose);
      }
    }
  })
  return max;
}

exports.minSatisfying = minSatisfying;
function minSatisfying(versions, range, loose) {
  var min = null;
  var minSV = null;
  try {
    var rangeObj = new Range(range, loose);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) { // satisfies(v, range, loose)
      if (!min || minSV.compare(v) === 1) { // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, loose);
      }
    }
  })
  return min;
}

exports.validRange = validRange;
function validRange(range, loose) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, loose).range || '*';
  } catch (er) {
    return null;
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr;
function ltr(version, range, loose) {
  return outside(version, range, '<', loose);
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr;
function gtr(version, range, loose) {
  return outside(version, range, '>', loose);
}

exports.outside = outside;
function outside(version, range, hilo, loose) {
  version = new SemVer(version, loose);
  range = new Range(range, loose);

  var gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, loose)) {
    return false;
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];

    var high = null;
    var low = null;

    comparators.forEach(function(comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, loose)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, loose)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
}

exports.prerelease = prerelease;
function prerelease(version, loose) {
  var parsed = parse(version, loose);
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;
}

exports.intersects = intersects;
function intersects(r1, r2, loose) {
  r1 = new Range(r1, loose)
  r2 = new Range(r2, loose)
  return r1.intersects(r2)
}

exports.coerce = coerce;
function coerce(version) {
  if (version instanceof SemVer)
    return version;

  if (typeof version !== 'string')
    return null;

  var match = version.match(re[COERCE]);

  if (match == null)
    return null;

  return parse((match[1] || '0') + '.' + (match[2] || '0') + '.' + (match[3] || '0')); 
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * External dependencies
 */
var debug = __webpack_require__( 93 )( 'i18n-wp-plugin' ),
	Jed = __webpack_require__( 96 ),
	sha1 = __webpack_require__( 97 ),
	EventEmitter = __webpack_require__( 56 ).EventEmitter,
	interpolateComponents = __webpack_require__( 100 ).default,
	LRU = __webpack_require__( 103 ),
	assign = __webpack_require__( 60 );

/**
 * Internal dependencies
 */
var numberFormatPHPJS = __webpack_require__( 104 );

/**
 * Constants
 */
var decimal_point_translation_key = 'number_format_decimals',
	thousands_sep_translation_key = 'number_format_thousands_sep';

var translationLookup = [
	// By default don't modify the options when looking up translations.
	function( options ) {
		return options;
	}
];

var hashCache = {};

// raise a console warning
function warn() {
	if ( ! I18N.throwErrors ) {
		return;
	}
	if ( 'undefined' !== typeof window && window.console && window.console.warn ) {
		window.console.warn.apply( window.console, arguments );
	}
}

// turns Function.arguments into an array
function simpleArguments( args ) {
	return Array.prototype.slice.call( args );
}

/**
 * Coerce the possible arguments and normalize to a single object
 * @param  {arguments} args - arguments passed in from `translate()`
 * @return {object}         - a single object describing translation needs
 */
function normalizeTranslateArguments( args ) {
	var original = args[ 0 ],
		options = {},
		i;

	// warn about older deprecated syntax
	if ( typeof original !== 'string' || args.length > 3 || ( args.length > 2 && typeof args[ 1 ] === 'object' && typeof args[ 2 ] === 'object' ) ) {
		warn( 'Deprecated Invocation: `translate()` accepts ( string, [string], [object] ). These arguments passed:', simpleArguments( args ), '. See https://github.com/pentatonicfunk/i18n-wp-plugin#translate-method' );
	}
	if ( args.length === 2 && typeof original === 'string' && typeof args[ 1 ] === 'string' ) {
		warn( 'Invalid Invocation: `translate()` requires an options object for plural translations, but passed:', simpleArguments( args ) );
	}

	// options could be in position 0, 1, or 2
	// sending options as the first object is deprecated and will raise a warning
	for ( i = 0; i < args.length; i++ ) {
		if ( typeof args[ i ] === 'object' ) {
			options = args[ i ];
		}
	}

	// `original` can be passed as first parameter or as part of the options object
	// though passing original as part of the options is a deprecated approach and will be removed
	if ( typeof original === 'string' ) {
		options.original = original;
	} else if ( typeof options.original === 'object' ) {
		options.plural = options.original.plural;
		options.count = options.original.count;
		options.original = options.original.single;
	}
	if ( typeof args[ 1 ] === 'string' ) {
		options.plural = args[ 1 ];
	}

	if ( typeof options.original === 'undefined' ) {
		throw new Error( 'Translate called without a `string` value as first argument.' );
	}

	return options;
}

/**
 * Pull the right set of arguments for the Jed method
 * @param  {string} jedMethod Name of jed gettext-style method. [See docs](http://slexaxton.github.io/Jed/)
 * @param  {[object]} props     properties passed into `translate()` method
 * @return {[array]}           array of properties to pass into gettext-style method
 */
function getJedArgs( jedMethod, props ) {
	switch ( jedMethod ) {
		case 'gettext':
			return [ props.original ];
		case 'ngettext':
			return [ props.original, props.plural, props.count ];
		case 'npgettext':
			return [ props.context, props.original, props.plural, props.count ];
		case 'pgettext':
			return [ props.context, props.original ];
	}

	return [];
}

/**
 * Takes translate options object and coerces to a Jed request to retrieve translation
 * @param  {object} jed     - jed data object
 * @param  {object} options - object describing translation
 * @return {string}         - the returned translation from Jed
 */
function getTranslationFromJed( jed, options ) {
	var jedMethod = 'gettext',
		jedArgs;

	if ( options.context ) {
		jedMethod = 'p' + jedMethod;
	}

	if ( typeof options.original === 'string' && typeof options.plural === 'string' ) {
		jedMethod = 'n' + jedMethod;
	}

	jedArgs = getJedArgs( jedMethod, options );

	return jed[ jedMethod ].apply( jed, jedArgs );
}

function getTranslation( i18n, options ) {
	var i, lookup;

	for ( i = translationLookup.length - 1; i >= 0; i-- ) {
		lookup = translationLookup[ i ]( assign( {}, options ) );
		// Only get the translation from jed if it exists.
		if ( i18n.state.locale[ lookup.original ] ) {
			return getTranslationFromJed( i18n.state.jed, lookup );
		}
	}

	return null;
}


function I18N() {
	if( ! ( this instanceof I18N ) ) {
		return new I18N();
	}
	this.defaultLocaleSlug = 'en';
	this.state = {
		numberFormatSettings: {},
		jed: undefined,
		locale: undefined,
		localeSlug: undefined,
		translations: LRU( { max: 100 } )
	};
	this.componentUpdateHooks = [];
	this.translateHooks = [];
	this.stateObserver = new EventEmitter();
	// Because the higher-order component can wrap a ton of React components,
	// we need to bump the number of listeners to infinity and beyond
	// FIXME: still valid?
	this.stateObserver.setMaxListeners( 0 );
	// default configuration
	this.configure();
}

I18N.throwErrors = false;

/**
 * Formats numbers using locale settings and/or passed options
 * @param  {String|Number|Int}  number to format (required)
 * @param  {Int|object} options  Number of decimal places or options object (optional)
 * @return {string}         Formatted number as string
 */
I18N.prototype.numberFormat = function( number ) {
	var options = arguments[ 1 ] || {},
		decimals = ( typeof options === 'number' ) ? options : options.decimals || 0,
		decPoint = options.decPoint || this.state.numberFormatSettings.decimal_point || '.',
		thousandsSep = options.thousandsSep || this.state.numberFormatSettings.thousands_sep || ',';

	return numberFormatPHPJS( number, decimals, decPoint, thousandsSep );
};

I18N.prototype.configure = function( options ) {
	assign( this, options || {} );
	this.setLocale();
};

I18N.prototype.setLocale = function( localeData ) {
	if ( localeData && localeData[ '' ] && localeData[ '' ][ 'key-hash' ] ) {
		var hashLength, minHashLength, maxHashLength, keyHash = localeData[ '' ][ 'key-hash' ];

		var transform = function( string, hashLength ) {
			const lookupPrefix = hashLength === false ? '' : String( hashLength );
			if ( typeof hashCache[ lookupPrefix + string ] !== 'undefined' ) {
				return hashCache[ lookupPrefix + string ];
			}
			var hash = sha1().update( string ).digest('hex');

			if ( hashLength ) {
				return hashCache[ lookupPrefix + string ] = hash.substr( 0, hashLength );
			}

			return hashCache[ lookupPrefix + string ] = hash;
		};

		var generateLookup = function( hashLength ) {
			return function( options ) {
				if ( options.context ) {
					options.original = transform( options.context + String.fromCharCode( 4 ) + options.original, hashLength );
					delete options.context;
				} else {
					options.original = transform( options.original, hashLength );
				}

				return options;
			};
		}

		if ( keyHash.substr( 0, 4 ) === 'sha1' ) {
			if ( keyHash.length === 4 ) {
				translationLookup.push( generateLookup( false ) );
			} else {
				var variableHashLengthPos = keyHash.substr( 5 ).indexOf( '-' );
				if ( variableHashLengthPos < 0 ) {
					hashLength = Number( keyHash.substr( 5 ) );
					translationLookup.push( generateLookup( hashLength ) );
				} else {
					minHashLength = Number( keyHash.substr( 5, variableHashLengthPos ) );
					maxHashLength = Number( keyHash.substr( 6 + variableHashLengthPos ) );

					for ( hashLength = minHashLength; hashLength <= maxHashLength; hashLength++ ) {
						translationLookup.push( generateLookup( hashLength ) );
					}
				}
			}
		}
	}

	// if localeData is not given, assumes default locale and reset
	if ( ! localeData || ! localeData[ '' ].localeSlug ) {
		this.state.locale = { '': { localeSlug: this.defaultLocaleSlug } };
	} else if ( localeData[ '' ].localeSlug === this.state.localeSlug ) {
		// Exit if same data as current (comparing references only)
		if ( localeData === this.state.locale ) {
			return;
		}

		// merge new data into existing one
		assign( this.state.locale, localeData );
	} else {
		this.state.locale = assign( {}, localeData );
	}

	this.state.localeSlug = this.state.locale[ '' ].localeSlug;

	this.state.jed = new Jed( {
		locale_data: {
			messages: this.state.locale
		}
	} );


	// Updates numberFormat preferences with settings from translations
	this.state.numberFormatSettings.decimal_point = getTranslationFromJed(
		this.state.jed,
		normalizeTranslateArguments( [ decimal_point_translation_key ] )
	);
	this.state.numberFormatSettings.thousands_sep = getTranslationFromJed(
		this.state.jed,
		normalizeTranslateArguments( [ thousands_sep_translation_key ] )
	);

	// If translation isn't set, define defaults.
	if ( this.state.numberFormatSettings.decimal_point === decimal_point_translation_key ) {
		this.state.numberFormatSettings.decimal_point = '.';
	}

	if ( this.state.numberFormatSettings.thousands_sep === thousands_sep_translation_key ) {
		this.state.numberFormatSettings.thousands_sep = ',';
	}

	this.state.translations.clear();
	this.stateObserver.emit( 'change' );
};

I18N.prototype.getLocale = function() {
	return this.state.locale;
};

/**
 * Get the current locale slug.
 * @returns {string} The string representing the currently loaded locale
 **/
I18N.prototype.getLocaleSlug = function() {
	return this.state.localeSlug;
};


/**
 * Adds new translations to the locale data, overwriting any existing translations with a matching key
 **/
I18N.prototype.addTranslations = function( localeData ) {
	for ( var prop in localeData ) {
		if ( prop !== '' ) {
			this.state.jed.options.locale_data.messages[prop] = localeData[prop];
		}
	}

	this.state.translations.clear();
	this.stateObserver.emit( 'change' );
};


/**
 * Checks whether the given original has a translation. Parameters are the same as for translate().
 *
 * @param  {string} original  the string to translate
 * @param  {string} plural    the plural string to translate (if applicable), original used as singular
 * @param  {object} options   properties describing translation requirements for given text
 * @return {boolean} whether a translation exists
 */
I18N.prototype.hasTranslation = function() {
	return !! getTranslation( this, normalizeTranslateArguments( arguments ) );
}

/**
 * Exposes single translation method, which is converted into its respective Jed method.
 * See sibling README
 * @param  {string} original  the string to translate
 * @param  {string} plural    the plural string to translate (if applicable), original used as singular
 * @param  {object} options   properties describing translation requirements for given text
 * @return {string|React-components} translated text or an object containing React children that can be inserted into a parent component
 */
I18N.prototype.translate = function() {
	var options, translation, sprintfArgs, errorMethod, optionsString, cacheable;

	options = normalizeTranslateArguments( arguments );

	cacheable = ! options.components;
	if ( cacheable ) {
		// Safe JSON stringification here to catch Circular JSON error
		// caused by passing a React component into args where only scalars are allowed
		try {
			optionsString = JSON.stringify( options );
		} catch ( e ) {
			cacheable = false;
		}

		if ( optionsString ) {
			translation = this.state.translations.get( optionsString );
			// Return the cached translation.
			if ( translation ) {
				return translation;
			}
		}
	}

	translation = getTranslation( this, options );
	if ( ! translation ) {
		// This purposefully calls jed for a case where there is no translation,
		// so that jed gives us the expected object with English text.
		translation = getTranslationFromJed( this.state.jed, options );
	}

	// handle any string substitution
	if ( options.args ) {
		sprintfArgs = ( Array.isArray( options.args ) ) ? options.args.slice( 0 ) : [ options.args ];
		sprintfArgs.unshift( translation );
		try {
			translation = Jed.sprintf.apply( Jed, sprintfArgs );
		} catch ( error ) {
			if ( ! window || ! window.console ) {
				return;
			}
			errorMethod = this.throwErrors ? 'error' : 'warn';
			if ( typeof error !== 'string' ) {
				window.console[ errorMethod ]( error );
			} else {
				window.console[ errorMethod ]( 'i18n sprintf error:', sprintfArgs );
			}
		}
	}

	// interpolate any components
	if ( options.components ) {
		translation = interpolateComponents( {
			mixedString: translation,
			components: options.components,
			throwErrors: this.throwErrors
		} );
	}

	// run any necessary hooks
	this.translateHooks.forEach( function( hook ) {
		translation = hook( translation, options );
	} );

	if ( cacheable ) {
		this.state.translations.set( optionsString, translation );
	}

	return translation;
};

/**
 * Causes i18n to re-render all translations.
 *
 * This can be necessary if an extension makes changes that i18n is unaware of
 * and needs those changes manifested immediately (e.g. adding an important
 * translation hook, or modifying the behaviour of an existing hook).
 *
 * If at all possible, react components should try to use the more local
 * updateTranslation() function inherited from the mixin.
 */
I18N.prototype.reRenderTranslations = function() {
	debug( 'Re-rendering all translations due to external request' );
	this.state.translations.clear();
	this.stateObserver.emit( 'change' );
};

I18N.prototype.registerComponentUpdateHook = function( callback ) {
	this.componentUpdateHooks.push( callback );
};

I18N.prototype.registerTranslateHook = function( callback ) {
	this.translateHooks.push( callback );
};

module.exports = I18N;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(94);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(95);

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),
/* 95 */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @preserve jed.js v0.5.0beta https://github.com/SlexAxton/Jed
 */
/*
-----------
A gettext compatible i18n library for modern JavaScript Applications

by Alex Sexton - AlexSexton [at] gmail - @SlexAxton
WTFPL license for use
Dojo CLA for contributions

Jed offers the entire applicable GNU gettext spec'd set of
functions, but also offers some nicer wrappers around them.
The api for gettext was written for a language with no function
overloading, so Jed allows a little more of that.

Many thanks to Joshua I. Miller - unrtst@cpan.org - who wrote
gettext.js back in 2008. I was able to vet a lot of my ideas
against his. I also made sure Jed passed against his tests
in order to offer easy upgrades -- jsgettext.berlios.de
*/
(function (root, undef) {

  // Set up some underscore-style functions, if you already have
  // underscore, feel free to delete this section, and use it
  // directly, however, the amount of functions used doesn't
  // warrant having underscore as a full dependency.
  // Underscore 1.3.0 was used to port and is licensed
  // under the MIT License by Jeremy Ashkenas.
  var ArrayProto    = Array.prototype,
      ObjProto      = Object.prototype,
      slice         = ArrayProto.slice,
      hasOwnProp    = ObjProto.hasOwnProperty,
      nativeForEach = ArrayProto.forEach,
      breaker       = {};

  // We're not using the OOP style _ so we don't need the
  // extra level of indirection. This still means that you
  // sub out for real `_` though.
  var _ = {
    forEach : function( obj, iterator, context ) {
      var i, l, key;
      if ( obj === null ) {
        return;
      }

      if ( nativeForEach && obj.forEach === nativeForEach ) {
        obj.forEach( iterator, context );
      }
      else if ( obj.length === +obj.length ) {
        for ( i = 0, l = obj.length; i < l; i++ ) {
          if ( i in obj && iterator.call( context, obj[i], i, obj ) === breaker ) {
            return;
          }
        }
      }
      else {
        for ( key in obj) {
          if ( hasOwnProp.call( obj, key ) ) {
            if ( iterator.call (context, obj[key], key, obj ) === breaker ) {
              return;
            }
          }
        }
      }
    },
    extend : function( obj ) {
      this.forEach( slice.call( arguments, 1 ), function ( source ) {
        for ( var prop in source ) {
          obj[prop] = source[prop];
        }
      });
      return obj;
    }
  };
  // END Miniature underscore impl

  // Jed is a constructor function
  var Jed = function ( options ) {
    // Some minimal defaults
    this.defaults = {
      "locale_data" : {
        "messages" : {
          "" : {
            "domain"       : "messages",
            "lang"         : "en",
            "plural_forms" : "nplurals=2; plural=(n != 1);"
          }
          // There are no default keys, though
        }
      },
      // The default domain if one is missing
      "domain" : "messages",
      // enable debug mode to log untranslated strings to the console
      "debug" : false
    };

    // Mix in the sent options with the default options
    this.options = _.extend( {}, this.defaults, options );
    this.textdomain( this.options.domain );

    if ( options.domain && ! this.options.locale_data[ this.options.domain ] ) {
      throw new Error('Text domain set to non-existent domain: `' + options.domain + '`');
    }
  };

  // The gettext spec sets this character as the default
  // delimiter for context lookups.
  // e.g.: context\u0004key
  // If your translation company uses something different,
  // just change this at any time and it will use that instead.
  Jed.context_delimiter = String.fromCharCode( 4 );

  function getPluralFormFunc ( plural_form_string ) {
    return Jed.PF.compile( plural_form_string || "nplurals=2; plural=(n != 1);");
  }

  function Chain( key, i18n ){
    this._key = key;
    this._i18n = i18n;
  }

  // Create a chainable api for adding args prettily
  _.extend( Chain.prototype, {
    onDomain : function ( domain ) {
      this._domain = domain;
      return this;
    },
    withContext : function ( context ) {
      this._context = context;
      return this;
    },
    ifPlural : function ( num, pkey ) {
      this._val = num;
      this._pkey = pkey;
      return this;
    },
    fetch : function ( sArr ) {
      if ( {}.toString.call( sArr ) != '[object Array]' ) {
        sArr = [].slice.call(arguments, 0);
      }
      return ( sArr && sArr.length ? Jed.sprintf : function(x){ return x; } )(
        this._i18n.dcnpgettext(this._domain, this._context, this._key, this._pkey, this._val),
        sArr
      );
    }
  });

  // Add functions to the Jed prototype.
  // These will be the functions on the object that's returned
  // from creating a `new Jed()`
  // These seem redundant, but they gzip pretty well.
  _.extend( Jed.prototype, {
    // The sexier api start point
    translate : function ( key ) {
      return new Chain( key, this );
    },

    textdomain : function ( domain ) {
      if ( ! domain ) {
        return this._textdomain;
      }
      this._textdomain = domain;
    },

    gettext : function ( key ) {
      return this.dcnpgettext.call( this, undef, undef, key );
    },

    dgettext : function ( domain, key ) {
     return this.dcnpgettext.call( this, domain, undef, key );
    },

    dcgettext : function ( domain , key /*, category */ ) {
      // Ignores the category anyways
      return this.dcnpgettext.call( this, domain, undef, key );
    },

    ngettext : function ( skey, pkey, val ) {
      return this.dcnpgettext.call( this, undef, undef, skey, pkey, val );
    },

    dngettext : function ( domain, skey, pkey, val ) {
      return this.dcnpgettext.call( this, domain, undef, skey, pkey, val );
    },

    dcngettext : function ( domain, skey, pkey, val/*, category */) {
      return this.dcnpgettext.call( this, domain, undef, skey, pkey, val );
    },

    pgettext : function ( context, key ) {
      return this.dcnpgettext.call( this, undef, context, key );
    },

    dpgettext : function ( domain, context, key ) {
      return this.dcnpgettext.call( this, domain, context, key );
    },

    dcpgettext : function ( domain, context, key/*, category */) {
      return this.dcnpgettext.call( this, domain, context, key );
    },

    npgettext : function ( context, skey, pkey, val ) {
      return this.dcnpgettext.call( this, undef, context, skey, pkey, val );
    },

    dnpgettext : function ( domain, context, skey, pkey, val ) {
      return this.dcnpgettext.call( this, domain, context, skey, pkey, val );
    },

    // The most fully qualified gettext function. It has every option.
    // Since it has every option, we can use it from every other method.
    // This is the bread and butter.
    // Technically there should be one more argument in this function for 'Category',
    // but since we never use it, we might as well not waste the bytes to define it.
    dcnpgettext : function ( domain, context, singular_key, plural_key, val ) {
      // Set some defaults

      plural_key = plural_key || singular_key;

      // Use the global domain default if one
      // isn't explicitly passed in
      domain = domain || this._textdomain;

      var fallback;

      // Handle special cases

      // No options found
      if ( ! this.options ) {
        // There's likely something wrong, but we'll return the correct key for english
        // We do this by instantiating a brand new Jed instance with the default set
        // for everything that could be broken.
        fallback = new Jed();
        return fallback.dcnpgettext.call( fallback, undefined, undefined, singular_key, plural_key, val );
      }

      // No translation data provided
      if ( ! this.options.locale_data ) {
        throw new Error('No locale data provided.');
      }

      if ( ! this.options.locale_data[ domain ] ) {
        throw new Error('Domain `' + domain + '` was not found.');
      }

      if ( ! this.options.locale_data[ domain ][ "" ] ) {
        throw new Error('No locale meta information provided.');
      }

      // Make sure we have a truthy key. Otherwise we might start looking
      // into the empty string key, which is the options for the locale
      // data.
      if ( ! singular_key ) {
        throw new Error('No translation key found.');
      }

      var key  = context ? context + Jed.context_delimiter + singular_key : singular_key,
          locale_data = this.options.locale_data,
          dict = locale_data[ domain ],
          defaultConf = (locale_data.messages || this.defaults.locale_data.messages)[""],
          pluralForms = dict[""].plural_forms || dict[""]["Plural-Forms"] || dict[""]["plural-forms"] || defaultConf.plural_forms || defaultConf["Plural-Forms"] || defaultConf["plural-forms"],
          val_list,
          res;

      var val_idx;
      if (val === undefined) {
        // No value passed in; assume singular key lookup.
        val_idx = 1;

      } else {
        // Value has been passed in; use plural-forms calculations.

        // Handle invalid numbers, but try casting strings for good measure
        if ( typeof val != 'number' ) {
          val = parseInt( val, 10 );

          if ( isNaN( val ) ) {
            throw new Error('The number that was passed in is not a number.');
          }
        }

        val_idx = getPluralFormFunc(pluralForms)(val) + 1;
      }

      // Throw an error if a domain isn't found
      if ( ! dict ) {
        throw new Error('No domain named `' + domain + '` could be found.');
      }

      val_list = dict[ key ];

      // If there is no match, then revert back to
      // english style singular/plural with the keys passed in.
      if ( ! val_list || val_idx >= val_list.length ) {
        if (this.options.missing_key_callback) {
          this.options.missing_key_callback(key, domain);
        }
        res = [ null, singular_key, plural_key ];

        // collect untranslated strings
        if (this.options.debug===true) {
          console.log(res[ getPluralFormFunc(pluralForms)( val ) + 1 ]);
        }
        return res[ getPluralFormFunc()( val ) + 1 ];
      }

      res = val_list[ val_idx ];

      // This includes empty strings on purpose
      if ( ! res  ) {
        res = [ null, singular_key, plural_key ];
        return res[ getPluralFormFunc()( val ) + 1 ];
      }
      return res;
    }
  });


  // We add in sprintf capabilities for post translation value interolation
  // This is not internally used, so you can remove it if you have this
  // available somewhere else, or want to use a different system.

  // We _slightly_ modify the normal sprintf behavior to more gracefully handle
  // undefined values.

  /**
   sprintf() for JavaScript 0.7-beta1
   http://www.diveintojavascript.com/projects/javascript-sprintf

   Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:
       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
         documentation and/or other materials provided with the distribution.
       * Neither the name of sprintf() for JavaScript nor the
         names of its contributors may be used to endorse or promote products
         derived from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   DISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY
   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
  var sprintf = (function() {
    function get_type(variable) {
      return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
    }
    function str_repeat(input, multiplier) {
      for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
      return output.join('');
    }

    var str_format = function() {
      if (!str_format.cache.hasOwnProperty(arguments[0])) {
        str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
      }
      return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
    };

    str_format.format = function(parse_tree, argv) {
      var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
      for (i = 0; i < tree_length; i++) {
        node_type = get_type(parse_tree[i]);
        if (node_type === 'string') {
          output.push(parse_tree[i]);
        }
        else if (node_type === 'array') {
          match = parse_tree[i]; // convenience purposes only
          if (match[2]) { // keyword argument
            arg = argv[cursor];
            for (k = 0; k < match[2].length; k++) {
              if (!arg.hasOwnProperty(match[2][k])) {
                throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
              }
              arg = arg[match[2][k]];
            }
          }
          else if (match[1]) { // positional argument (explicit)
            arg = argv[match[1]];
          }
          else { // positional argument (implicit)
            arg = argv[cursor++];
          }

          if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
            throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
          }

          // Jed EDIT
          if ( typeof arg == 'undefined' || arg === null ) {
            arg = '';
          }
          // Jed EDIT

          switch (match[8]) {
            case 'b': arg = arg.toString(2); break;
            case 'c': arg = String.fromCharCode(arg); break;
            case 'd': arg = parseInt(arg, 10); break;
            case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
            case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
            case 'o': arg = arg.toString(8); break;
            case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
            case 'u': arg = Math.abs(arg); break;
            case 'x': arg = arg.toString(16); break;
            case 'X': arg = arg.toString(16).toUpperCase(); break;
          }
          arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
          pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
          pad_length = match[6] - String(arg).length;
          pad = match[6] ? str_repeat(pad_character, pad_length) : '';
          output.push(match[5] ? arg + pad : pad + arg);
        }
      }
      return output.join('');
    };

    str_format.cache = {};

    str_format.parse = function(fmt) {
      var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
      while (_fmt) {
        if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
          parse_tree.push(match[0]);
        }
        else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
          parse_tree.push('%');
        }
        else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
          if (match[2]) {
            arg_names |= 1;
            var field_list = [], replacement_field = match[2], field_match = [];
            if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
              field_list.push(field_match[1]);
              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                }
                else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                }
                else {
                  throw('[sprintf] huh?');
                }
              }
            }
            else {
              throw('[sprintf] huh?');
            }
            match[2] = field_list;
          }
          else {
            arg_names |= 2;
          }
          if (arg_names === 3) {
            throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
          }
          parse_tree.push(match);
        }
        else {
          throw('[sprintf] huh?');
        }
        _fmt = _fmt.substring(match[0].length);
      }
      return parse_tree;
    };

    return str_format;
  })();

  var vsprintf = function(fmt, argv) {
    argv.unshift(fmt);
    return sprintf.apply(null, argv);
  };

  Jed.parse_plural = function ( plural_forms, n ) {
    plural_forms = plural_forms.replace(/n/g, n);
    return Jed.parse_expression(plural_forms);
  };

  Jed.sprintf = function ( fmt, args ) {
    if ( {}.toString.call( args ) == '[object Array]' ) {
      return vsprintf( fmt, [].slice.call(args) );
    }
    return sprintf.apply(this, [].slice.call(arguments) );
  };

  Jed.prototype.sprintf = function () {
    return Jed.sprintf.apply(this, arguments);
  };
  // END sprintf Implementation

  // Start the Plural forms section
  // This is a full plural form expression parser. It is used to avoid
  // running 'eval' or 'new Function' directly against the plural
  // forms.
  //
  // This can be important if you get translations done through a 3rd
  // party vendor. I encourage you to use this instead, however, I
  // also will provide a 'precompiler' that you can use at build time
  // to output valid/safe function representations of the plural form
  // expressions. This means you can build this code out for the most
  // part.
  Jed.PF = {};

  Jed.PF.parse = function ( p ) {
    var plural_str = Jed.PF.extractPluralExpr( p );
    return Jed.PF.parser.parse.call(Jed.PF.parser, plural_str);
  };

  Jed.PF.compile = function ( p ) {
    // Handle trues and falses as 0 and 1
    function imply( val ) {
      return (val === true ? 1 : val ? val : 0);
    }

    var ast = Jed.PF.parse( p );
    return function ( n ) {
      return imply( Jed.PF.interpreter( ast )( n ) );
    };
  };

  Jed.PF.interpreter = function ( ast ) {
    return function ( n ) {
      var res;
      switch ( ast.type ) {
        case 'GROUP':
          return Jed.PF.interpreter( ast.expr )( n );
        case 'TERNARY':
          if ( Jed.PF.interpreter( ast.expr )( n ) ) {
            return Jed.PF.interpreter( ast.truthy )( n );
          }
          return Jed.PF.interpreter( ast.falsey )( n );
        case 'OR':
          return Jed.PF.interpreter( ast.left )( n ) || Jed.PF.interpreter( ast.right )( n );
        case 'AND':
          return Jed.PF.interpreter( ast.left )( n ) && Jed.PF.interpreter( ast.right )( n );
        case 'LT':
          return Jed.PF.interpreter( ast.left )( n ) < Jed.PF.interpreter( ast.right )( n );
        case 'GT':
          return Jed.PF.interpreter( ast.left )( n ) > Jed.PF.interpreter( ast.right )( n );
        case 'LTE':
          return Jed.PF.interpreter( ast.left )( n ) <= Jed.PF.interpreter( ast.right )( n );
        case 'GTE':
          return Jed.PF.interpreter( ast.left )( n ) >= Jed.PF.interpreter( ast.right )( n );
        case 'EQ':
          return Jed.PF.interpreter( ast.left )( n ) == Jed.PF.interpreter( ast.right )( n );
        case 'NEQ':
          return Jed.PF.interpreter( ast.left )( n ) != Jed.PF.interpreter( ast.right )( n );
        case 'MOD':
          return Jed.PF.interpreter( ast.left )( n ) % Jed.PF.interpreter( ast.right )( n );
        case 'VAR':
          return n;
        case 'NUM':
          return ast.val;
        default:
          throw new Error("Invalid Token found.");
      }
    };
  };

  Jed.PF.extractPluralExpr = function ( p ) {
    // trim first
    p = p.replace(/^\s\s*/, '').replace(/\s\s*$/, '');

    if (! /;\s*$/.test(p)) {
      p = p.concat(';');
    }

    var nplurals_re = /nplurals\=(\d+);/,
        plural_re = /plural\=(.*);/,
        nplurals_matches = p.match( nplurals_re ),
        res = {},
        plural_matches;

    // Find the nplurals number
    if ( nplurals_matches.length > 1 ) {
      res.nplurals = nplurals_matches[1];
    }
    else {
      throw new Error('nplurals not found in plural_forms string: ' + p );
    }

    // remove that data to get to the formula
    p = p.replace( nplurals_re, "" );
    plural_matches = p.match( plural_re );

    if (!( plural_matches && plural_matches.length > 1 ) ) {
      throw new Error('`plural` expression not found: ' + p);
    }
    return plural_matches[ 1 ];
  };

  /* Jison generated parser */
  Jed.PF.parser = (function(){

var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"expressions":3,"e":4,"EOF":5,"?":6,":":7,"||":8,"&&":9,"<":10,"<=":11,">":12,">=":13,"!=":14,"==":15,"%":16,"(":17,")":18,"n":19,"NUMBER":20,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",6:"?",7:":",8:"||",9:"&&",10:"<",11:"<=",12:">",13:">=",14:"!=",15:"==",16:"%",17:"(",18:")",19:"n",20:"NUMBER"},
productions_: [0,[3,2],[4,5],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,1],[4,1]],
performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {

var $0 = $$.length - 1;
switch (yystate) {
case 1: return { type : 'GROUP', expr: $$[$0-1] };
break;
case 2:this.$ = { type: 'TERNARY', expr: $$[$0-4], truthy : $$[$0-2], falsey: $$[$0] };
break;
case 3:this.$ = { type: "OR", left: $$[$0-2], right: $$[$0] };
break;
case 4:this.$ = { type: "AND", left: $$[$0-2], right: $$[$0] };
break;
case 5:this.$ = { type: 'LT', left: $$[$0-2], right: $$[$0] };
break;
case 6:this.$ = { type: 'LTE', left: $$[$0-2], right: $$[$0] };
break;
case 7:this.$ = { type: 'GT', left: $$[$0-2], right: $$[$0] };
break;
case 8:this.$ = { type: 'GTE', left: $$[$0-2], right: $$[$0] };
break;
case 9:this.$ = { type: 'NEQ', left: $$[$0-2], right: $$[$0] };
break;
case 10:this.$ = { type: 'EQ', left: $$[$0-2], right: $$[$0] };
break;
case 11:this.$ = { type: 'MOD', left: $$[$0-2], right: $$[$0] };
break;
case 12:this.$ = { type: 'GROUP', expr: $$[$0-1] };
break;
case 13:this.$ = { type: 'VAR' };
break;
case 14:this.$ = { type: 'NUM', val: Number(yytext) };
break;
}
},
table: [{3:1,4:2,17:[1,3],19:[1,4],20:[1,5]},{1:[3]},{5:[1,6],6:[1,7],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16]},{4:17,17:[1,3],19:[1,4],20:[1,5]},{5:[2,13],6:[2,13],7:[2,13],8:[2,13],9:[2,13],10:[2,13],11:[2,13],12:[2,13],13:[2,13],14:[2,13],15:[2,13],16:[2,13],18:[2,13]},{5:[2,14],6:[2,14],7:[2,14],8:[2,14],9:[2,14],10:[2,14],11:[2,14],12:[2,14],13:[2,14],14:[2,14],15:[2,14],16:[2,14],18:[2,14]},{1:[2,1]},{4:18,17:[1,3],19:[1,4],20:[1,5]},{4:19,17:[1,3],19:[1,4],20:[1,5]},{4:20,17:[1,3],19:[1,4],20:[1,5]},{4:21,17:[1,3],19:[1,4],20:[1,5]},{4:22,17:[1,3],19:[1,4],20:[1,5]},{4:23,17:[1,3],19:[1,4],20:[1,5]},{4:24,17:[1,3],19:[1,4],20:[1,5]},{4:25,17:[1,3],19:[1,4],20:[1,5]},{4:26,17:[1,3],19:[1,4],20:[1,5]},{4:27,17:[1,3],19:[1,4],20:[1,5]},{6:[1,7],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[1,28]},{6:[1,7],7:[1,29],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16]},{5:[2,3],6:[2,3],7:[2,3],8:[2,3],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,3]},{5:[2,4],6:[2,4],7:[2,4],8:[2,4],9:[2,4],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,4]},{5:[2,5],6:[2,5],7:[2,5],8:[2,5],9:[2,5],10:[2,5],11:[2,5],12:[2,5],13:[2,5],14:[2,5],15:[2,5],16:[1,16],18:[2,5]},{5:[2,6],6:[2,6],7:[2,6],8:[2,6],9:[2,6],10:[2,6],11:[2,6],12:[2,6],13:[2,6],14:[2,6],15:[2,6],16:[1,16],18:[2,6]},{5:[2,7],6:[2,7],7:[2,7],8:[2,7],9:[2,7],10:[2,7],11:[2,7],12:[2,7],13:[2,7],14:[2,7],15:[2,7],16:[1,16],18:[2,7]},{5:[2,8],6:[2,8],7:[2,8],8:[2,8],9:[2,8],10:[2,8],11:[2,8],12:[2,8],13:[2,8],14:[2,8],15:[2,8],16:[1,16],18:[2,8]},{5:[2,9],6:[2,9],7:[2,9],8:[2,9],9:[2,9],10:[2,9],11:[2,9],12:[2,9],13:[2,9],14:[2,9],15:[2,9],16:[1,16],18:[2,9]},{5:[2,10],6:[2,10],7:[2,10],8:[2,10],9:[2,10],10:[2,10],11:[2,10],12:[2,10],13:[2,10],14:[2,10],15:[2,10],16:[1,16],18:[2,10]},{5:[2,11],6:[2,11],7:[2,11],8:[2,11],9:[2,11],10:[2,11],11:[2,11],12:[2,11],13:[2,11],14:[2,11],15:[2,11],16:[2,11],18:[2,11]},{5:[2,12],6:[2,12],7:[2,12],8:[2,12],9:[2,12],10:[2,12],11:[2,12],12:[2,12],13:[2,12],14:[2,12],15:[2,12],16:[2,12],18:[2,12]},{4:30,17:[1,3],19:[1,4],20:[1,5]},{5:[2,2],6:[1,7],7:[2,2],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,2]}],
defaultActions: {6:[2,1]},
parseError: function parseError(str, hash) {
    throw new Error(str);
},
parse: function parse(input) {
    var self = this,
        stack = [0],
        vstack = [null], // semantic value stack
        lstack = [], // location stack
        table = this.table,
        yytext = '',
        yylineno = 0,
        yyleng = 0,
        recovering = 0,
        TERROR = 2,
        EOF = 1;

    //this.reductionCount = this.shiftCount = 0;

    this.lexer.setInput(input);
    this.lexer.yy = this.yy;
    this.yy.lexer = this.lexer;
    if (typeof this.lexer.yylloc == 'undefined')
        this.lexer.yylloc = {};
    var yyloc = this.lexer.yylloc;
    lstack.push(yyloc);

    if (typeof this.yy.parseError === 'function')
        this.parseError = this.yy.parseError;

    function popStack (n) {
        stack.length = stack.length - 2*n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }

    function lex() {
        var token;
        token = self.lexer.lex() || 1; // $end = 1
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }
        return token;
    }

    var symbol, preErrorSymbol, state, action, a, r, yyval={},p,len,newState, expected;
    while (true) {
        // retreive state number from top of stack
        state = stack[stack.length-1];

        // use default actions if available
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol == null)
                symbol = lex();
            // read action for current state and first input
            action = table[state] && table[state][symbol];
        }

        // handle parse error
        _handle_error:
        if (typeof action === 'undefined' || !action.length || !action[0]) {

            if (!recovering) {
                // Report error
                expected = [];
                for (p in table[state]) if (this.terminals_[p] && p > 2) {
                    expected.push("'"+this.terminals_[p]+"'");
                }
                var errStr = '';
                if (this.lexer.showPosition) {
                    errStr = 'Parse error on line '+(yylineno+1)+":\n"+this.lexer.showPosition()+"\nExpecting "+expected.join(', ') + ", got '" + this.terminals_[symbol]+ "'";
                } else {
                    errStr = 'Parse error on line '+(yylineno+1)+": Unexpected " +
                                  (symbol == 1 /*EOF*/ ? "end of input" :
                                              ("'"+(this.terminals_[symbol] || symbol)+"'"));
                }
                this.parseError(errStr,
                    {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
            }

            // just recovered from another error
            if (recovering == 3) {
                if (symbol == EOF) {
                    throw new Error(errStr || 'Parsing halted.');
                }

                // discard current lookahead and grab another
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                symbol = lex();
            }

            // try to recover from error
            while (1) {
                // check for error recovery rule in this state
                if ((TERROR.toString()) in table[state]) {
                    break;
                }
                if (state == 0) {
                    throw new Error(errStr || 'Parsing halted.');
                }
                popStack(1);
                state = stack[stack.length-1];
            }

            preErrorSymbol = symbol; // save the lookahead token
            symbol = TERROR;         // insert generic error symbol as new lookahead
            state = stack[stack.length-1];
            action = table[state] && table[state][TERROR];
            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
        }

        // this shouldn't happen, unless resolve defaults are off
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);
        }

        switch (action[0]) {

            case 1: // shift
                //this.shiftCount++;

                stack.push(symbol);
                vstack.push(this.lexer.yytext);
                lstack.push(this.lexer.yylloc);
                stack.push(action[1]); // push state
                symbol = null;
                if (!preErrorSymbol) { // normal execution/no error
                    yyleng = this.lexer.yyleng;
                    yytext = this.lexer.yytext;
                    yylineno = this.lexer.yylineno;
                    yyloc = this.lexer.yylloc;
                    if (recovering > 0)
                        recovering--;
                } else { // error just occurred, resume old lookahead f/ before error
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                }
                break;

            case 2: // reduce
                //this.reductionCount++;

                len = this.productions_[action[1]][1];

                // perform semantic action
                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1
                // default location, uses first token for firsts, last for lasts
                yyval._$ = {
                    first_line: lstack[lstack.length-(len||1)].first_line,
                    last_line: lstack[lstack.length-1].last_line,
                    first_column: lstack[lstack.length-(len||1)].first_column,
                    last_column: lstack[lstack.length-1].last_column
                };
                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);

                if (typeof r !== 'undefined') {
                    return r;
                }

                // pop off stack
                if (len) {
                    stack = stack.slice(0,-1*len*2);
                    vstack = vstack.slice(0, -1*len);
                    lstack = lstack.slice(0, -1*len);
                }

                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                // goto new state = table[STATE][NONTERMINAL]
                newState = table[stack[stack.length-2]][stack[stack.length-1]];
                stack.push(newState);
                break;

            case 3: // accept
                return true;
        }

    }

    return true;
}};/* Jison generated lexer */
var lexer = (function(){

var lexer = ({EOF:1,
parseError:function parseError(str, hash) {
        if (this.yy.parseError) {
            this.yy.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },
setInput:function (input) {
        this._input = input;
        this._more = this._less = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
        return this;
    },
input:function () {
        var ch = this._input[0];
        this.yytext+=ch;
        this.yyleng++;
        this.match+=ch;
        this.matched+=ch;
        var lines = ch.match(/\n/);
        if (lines) this.yylineno++;
        this._input = this._input.slice(1);
        return ch;
    },
unput:function (ch) {
        this._input = ch + this._input;
        return this;
    },
more:function () {
        this._more = true;
        return this;
    },
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
    },
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c+"^";
    },
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) this.done = true;

        var token,
            match,
            col,
            lines;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i=0;i < rules.length; i++) {
            match = this._input.match(this.rules[rules[i]]);
            if (match) {
                lines = match[0].match(/\n.*/g);
                if (lines) this.yylineno += lines.length;
                this.yylloc = {first_line: this.yylloc.last_line,
                               last_line: this.yylineno+1,
                               first_column: this.yylloc.last_column,
                               last_column: lines ? lines[lines.length-1].length-1 : this.yylloc.last_column + match[0].length}
                this.yytext += match[0];
                this.match += match[0];
                this.matches = match;
                this.yyleng = this.yytext.length;
                this._more = false;
                this._input = this._input.slice(match[0].length);
                this.matched += match[0];
                token = this.performAction.call(this, this.yy, this, rules[i],this.conditionStack[this.conditionStack.length-1]);
                if (token) return token;
                else return;
            }
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(),
                    {text: "", token: null, line: this.yylineno});
        }
    },
lex:function lex() {
        var r = this.next();
        if (typeof r !== 'undefined') {
            return r;
        } else {
            return this.lex();
        }
    },
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },
popState:function popState() {
        return this.conditionStack.pop();
    },
_currentRules:function _currentRules() {
        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
    },
topState:function () {
        return this.conditionStack[this.conditionStack.length-2];
    },
pushState:function begin(condition) {
        this.begin(condition);
    }});
lexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {

var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:/* skip whitespace */
break;
case 1:return 20
break;
case 2:return 19
break;
case 3:return 8
break;
case 4:return 9
break;
case 5:return 6
break;
case 6:return 7
break;
case 7:return 11
break;
case 8:return 13
break;
case 9:return 10
break;
case 10:return 12
break;
case 11:return 14
break;
case 12:return 15
break;
case 13:return 16
break;
case 14:return 17
break;
case 15:return 18
break;
case 16:return 5
break;
case 17:return 'INVALID'
break;
}
};
lexer.rules = [/^\s+/,/^[0-9]+(\.[0-9]+)?\b/,/^n\b/,/^\|\|/,/^&&/,/^\?/,/^:/,/^<=/,/^>=/,/^</,/^>/,/^!=/,/^==/,/^%/,/^\(/,/^\)/,/^$/,/^./];
lexer.conditions = {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17],"inclusive":true}};return lexer;})()
parser.lexer = lexer;
return parser;
})();
// End parser

  // Handle node, amd, and global systems
  if (true) {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Jed;
    }
    exports.Jed = Jed;
  }
  else {
    if (typeof define === 'function' && define.amd) {
      define('jed', function() {
        return Jed;
      });
    }
    // Leak a global regardless of module system
    root['Jed'] = Jed;
  }

})(this);


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(37);
var common = __webpack_require__(98);
var shaCommon = __webpack_require__(99);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(37);
var assert = __webpack_require__(54);

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(37);
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /**
                                                                                                                                                                                                                                                                               * External Dependencies
                                                                                                                                                                                                                                                                               */


/**
 * Internal Dependencies
 */


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactAddonsCreateFragment = __webpack_require__(101);

var _reactAddonsCreateFragment2 = _interopRequireDefault(_reactAddonsCreateFragment);

var _tokenize = __webpack_require__(102);

var _tokenize2 = _interopRequireDefault(_tokenize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var currentMixedString = void 0;

function getCloseIndex(openIndex, tokens) {
	var openToken = tokens[openIndex],
	    nestLevel = 0,
	    token,
	    i;
	for (i = openIndex + 1; i < tokens.length; i++) {
		token = tokens[i];
		if (token.value === openToken.value) {
			if (token.type === 'componentOpen') {
				nestLevel++;
				continue;
			}
			if (token.type === 'componentClose') {
				if (nestLevel === 0) {
					return i;
				}
				nestLevel--;
			}
		}
	}
	// if we get this far, there was no matching close token
	throw new Error('Missing closing component token `' + openToken.value + '`');
}

function buildChildren(tokens, components) {
	var children = [],
	    childrenObject = {},
	    openComponent,
	    clonedOpenComponent,
	    openIndex,
	    closeIndex,
	    token,
	    i,
	    grandChildTokens,
	    grandChildren,
	    siblingTokens,
	    siblings;

	for (i = 0; i < tokens.length; i++) {
		token = tokens[i];
		if (token.type === 'string') {
			children.push(token.value);
			continue;
		}
		// component node should at least be set
		if (!components.hasOwnProperty(token.value) || typeof components[token.value] === 'undefined') {
			throw new Error('Invalid interpolation, missing component node: `' + token.value + '`');
		}
		// should be either ReactElement or null (both type "object"), all other types deprecated
		if (_typeof(components[token.value]) !== 'object') {
			throw new Error('Invalid interpolation, component node must be a ReactElement or null: `' + token.value + '`', '\n> ' + currentMixedString);
		}
		// we should never see a componentClose token in this loop
		if (token.type === 'componentClose') {
			throw new Error('Missing opening component token: `' + token.value + '`');
		}
		if (token.type === 'componentOpen') {
			openComponent = components[token.value];
			openIndex = i;
			break;
		}
		// componentSelfClosing token
		children.push(components[token.value]);
		continue;
	}

	if (openComponent) {
		closeIndex = getCloseIndex(openIndex, tokens);
		grandChildTokens = tokens.slice(openIndex + 1, closeIndex);
		grandChildren = buildChildren(grandChildTokens, components);
		clonedOpenComponent = _react2.default.cloneElement(openComponent, {}, grandChildren);
		children.push(clonedOpenComponent);

		if (closeIndex < tokens.length - 1) {
			siblingTokens = tokens.slice(closeIndex + 1);
			siblings = buildChildren(siblingTokens, components);
			children = children.concat(siblings);
		}
	}

	if (children.length === 1) {
		return children[0];
	}

	children.forEach(function (child, index) {
		if (child) {
			childrenObject['interpolation-child-' + index] = child;
		}
	});

	return (0, _reactAddonsCreateFragment2.default)(childrenObject);
}

function interpolate(options) {
	var mixedString = options.mixedString,
	    components = options.components,
	    throwErrors = options.throwErrors;


	currentMixedString = mixedString;

	if (!components) {
		return mixedString;
	}

	if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) !== 'object') {
		if (throwErrors) {
			throw new Error('Interpolation Error: unable to process `' + mixedString + '` because components is not an object');
		}

		return mixedString;
	}

	var tokens = (0, _tokenize2.default)(mixedString);

	try {
		return buildChildren(tokens, components);
	} catch (error) {
		if (throwErrors) {
			throw new Error('Interpolation Error: unable to process `' + mixedString + '` because of error `' + error.message + '`');
		}

		return mixedString;
	}
};

exports.default = interpolate;
//# sourceMappingURL=index.js.map

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var React = __webpack_require__(0);

var REACT_ELEMENT_TYPE =
  (typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element')) ||
  0xeac7;

var emptyFunction = __webpack_require__(57);
var invariant = __webpack_require__(58);
var warning = __webpack_require__(59);

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

var didWarnAboutMaps = false;

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

function getIteratorFn(maybeIterable) {
  var iteratorFn =
    maybeIterable &&
    ((ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL]) ||
      maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function(match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

function traverseAllChildrenImpl(
  children,
  nameSoFar,
  callback,
  traverseContext
) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (
    children === null ||
    type === 'string' ||
    type === 'number' ||
    // The following is inlined from ReactElement. This means we can optimize
    // some checks. React Fiber also inlines this logic for similar purposes.
    (type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE)
  ) {
    callback(
      traverseContext,
      children,
      // If it's the only child, treat the name as if it was wrapped in an array
      // so that it's consistent if the number of children grows.
      nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar
    );
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(
        child,
        nextName,
        callback,
        traverseContext
      );
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      if (process.env.NODE_ENV !== 'production') {
        // Warn about using Maps as children
        if (iteratorFn === children.entries) {
          warning(
            didWarnAboutMaps,
            'Using Maps as children is unsupported and will likely yield ' +
              'unexpected results. Convert it to a sequence/iterable of keyed ' +
              'ReactElements instead.'
          );
          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(children);
      var step;
      var ii = 0;
      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getComponentKey(child, ii++);
        subtreeCount += traverseAllChildrenImpl(
          child,
          nextName,
          callback,
          traverseContext
        );
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum =
          ' If you meant to render a collection of children, use an array ' +
          'instead or wrap the object using createFragment(object) from the ' +
          'React add-ons.';
      }
      var childrenString = '' + children;
      invariant(
        false,
        'Objects are not valid as a React child (found: %s).%s',
        childrenString === '[object Object]'
          ? 'object with keys {' + Object.keys(children).join(', ') + '}'
          : childrenString,
        addendum
      );
    }
  }

  return subtreeCount;
}

function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

function cloneAndReplaceKey(oldElement, newKey) {
  return React.cloneElement(
    oldElement,
    {key: newKey},
    oldElement.props !== undefined ? oldElement.props.children : undefined
  );
}

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

var oneArgumentPooler = function(copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var standardReleaser = function standardReleaser(instance) {
  var Klass = this;
  invariant(
    instance instanceof Klass,
    'Trying to release an instance into a pool of a different type.'
  );
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function() {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result;
  var keyPrefix = bookKeeping.keyPrefix;
  var func = bookKeeping.func;
  var context = bookKeeping.context;

  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(
      mappedChild,
      result,
      childKey,
      emptyFunction.thatReturnsArgument
    );
  } else if (mappedChild != null) {
    if (React.isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(
        mappedChild,
        // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        keyPrefix +
          (mappedChild.key && (!child || child.key !== mappedChild.key)
            ? escapeUserProvidedKey(mappedChild.key) + '/'
            : '') +
          childKey
      );
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(
    array,
    escapedPrefix,
    func,
    context
  );
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

var numericPropertyRegex = /^\d+$/;

var warnedAboutNumeric = false;

function createReactFragment(object) {
  if (typeof object !== 'object' || !object || Array.isArray(object)) {
    warning(
      false,
      'React.addons.createFragment only accepts a single object. Got: %s',
      object
    );
    return object;
  }
  if (React.isValidElement(object)) {
    warning(
      false,
      'React.addons.createFragment does not accept a ReactElement ' +
        'without a wrapper object.'
    );
    return object;
  }

  invariant(
    object.nodeType !== 1,
    'React.addons.createFragment(...): Encountered an invalid child; DOM ' +
      'elements are not valid children of React components.'
  );

  var result = [];

  for (var key in object) {
    if (process.env.NODE_ENV !== 'production') {
      if (!warnedAboutNumeric && numericPropertyRegex.test(key)) {
        warning(
          false,
          'React.addons.createFragment(...): Child objects should have ' +
            'non-numeric keys so ordering is preserved.'
        );
        warnedAboutNumeric = true;
      }
    }
    mapIntoWithKeyPrefixInternal(
      object[key],
      result,
      key,
      emptyFunction.thatReturnsArgument
    );
  }

  return result;
}

module.exports = createReactFragment;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function identifyToken(item) {
	// {{/example}}
	if (item.match(/^\{\{\//)) {
		return {
			type: 'componentClose',
			value: item.replace(/\W/g, '')
		};
	}
	// {{example /}}
	if (item.match(/\/\}\}$/)) {
		return {
			type: 'componentSelfClosing',
			value: item.replace(/\W/g, '')
		};
	}
	// {{example}}
	if (item.match(/^\{\{/)) {
		return {
			type: 'componentOpen',
			value: item.replace(/\W/g, '')
		};
	}
	return {
		type: 'string',
		value: item
	};
}

module.exports = function (mixedString) {
	var tokenStrings = mixedString.split(/(\{\{\/?\s*\w+\s*\/?\}\})/g); // split to components and strings
	return tokenStrings.map(identifyToken);
};
//# sourceMappingURL=tokenize.js.map

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var events = __webpack_require__(56)
var inherits = __webpack_require__(55)

module.exports = LRU

function LRU (opts) {
  if (!(this instanceof LRU)) return new LRU(opts)
  if (typeof opts === 'number') opts = {max: opts}
  if (!opts) opts = {}
  events.EventEmitter.call(this)
  this.cache = {}
  this.head = this.tail = null
  this.length = 0
  this.max = opts.max || 1000
  this.maxAge = opts.maxAge || 0
}

inherits(LRU, events.EventEmitter)

Object.defineProperty(LRU.prototype, 'keys', {
  get: function () { return Object.keys(this.cache) }
})

LRU.prototype.clear = function () {
  this.cache = {}
  this.head = this.tail = null
  this.length = 0
}

LRU.prototype.remove = function (key) {
  if (typeof key !== 'string') key = '' + key
  if (!this.cache.hasOwnProperty(key)) return

  var element = this.cache[key]
  delete this.cache[key]
  this._unlink(key, element.prev, element.next)
  return element.value
}

LRU.prototype._unlink = function (key, prev, next) {
  this.length--

  if (this.length === 0) {
    this.head = this.tail = null
  } else {
    if (this.head === key) {
      this.head = prev
      this.cache[this.head].next = null
    } else if (this.tail === key) {
      this.tail = next
      this.cache[this.tail].prev = null
    } else {
      this.cache[prev].next = next
      this.cache[next].prev = prev
    }
  }
}

LRU.prototype.peek = function (key) {
  if (!this.cache.hasOwnProperty(key)) return

  var element = this.cache[key]

  if (!this._checkAge(key, element)) return
  return element.value
}

LRU.prototype.set = function (key, value) {
  if (typeof key !== 'string') key = '' + key

  var element

  if (this.cache.hasOwnProperty(key)) {
    element = this.cache[key]
    element.value = value
    if (this.maxAge) element.modified = Date.now()

    // If it's already the head, there's nothing more to do:
    if (key === this.head) return value
    this._unlink(key, element.prev, element.next)
  } else {
    element = {value: value, modified: 0, next: null, prev: null}
    if (this.maxAge) element.modified = Date.now()
    this.cache[key] = element

    // Eviction is only possible if the key didn't already exist:
    if (this.length === this.max) this.evict()
  }

  this.length++
  element.next = null
  element.prev = this.head

  if (this.head) this.cache[this.head].next = key
  this.head = key

  if (!this.tail) this.tail = key
  return value
}

LRU.prototype._checkAge = function (key, element) {
  if (this.maxAge && (Date.now() - element.modified) > this.maxAge) {
    this.remove(key)
    this.emit('evict', {key: key, value: element.value})
    return false
  }
  return true
}

LRU.prototype.get = function (key) {
  if (typeof key !== 'string') key = '' + key
  if (!this.cache.hasOwnProperty(key)) return

  var element = this.cache[key]

  if (!this._checkAge(key, element)) return

  if (this.head !== key) {
    if (key === this.tail) {
      this.tail = element.next
      this.cache[this.tail].prev = null
    } else {
      // Set prev.next -> element.next:
      this.cache[element.prev].next = element.next
    }

    // Set element.next.prev -> element.prev:
    this.cache[element.next].prev = element.prev

    // Element is the new head
    this.cache[this.head].next = key
    element.prev = this.head
    element.next = null
    this.head = key
  }

  return element.value
}

LRU.prototype.evict = function () {
  if (!this.tail) return
  var key = this.tail
  var value = this.remove(this.tail)
  this.emit('evict', {key: key, value: value})
}


/***/ }),
/* 104 */
/***/ (function(module, exports) {

/**
 * Exposes number format capability
 *
 * @copyright Copyright (c) 2013 Kevin van Zonneveld (http://kvz.io) and Contributors (http://phpjs.org/authors).
 * @license See CREDITS.md
 * @see https://github.com/kvz/phpjs/blob/ffe1356af23a6f2512c84c954dd4e828e92579fa/functions/strings/number_format.js
 */
function number_format( number, decimals, dec_point, thousands_sep ) {
  number = ( number + '' )
    .replace( /[^0-9+\-Ee.]/g, '' );
  var n = ! isFinite( +number ) ? 0 : +number,
    prec = ! isFinite( +decimals ) ? 0 : Math.abs( decimals ),
    sep = ( typeof thousands_sep === 'undefined' ) ? ',' : thousands_sep,
    dec = ( typeof dec_point === 'undefined' ) ? '.' : dec_point,
    s = '',
    toFixedFix = function( n, prec ) {
      var k = Math.pow( 10, prec );
      return '' + ( Math.round( n * k ) / k )
          .toFixed( prec );
    };
  // Fix for IE parseFloat(0.55).toFixed(0) = 0;
  s = ( prec ? toFixedFix( n, prec ) : '' + Math.round( n ) )
    .split( '.' );
  if ( s[ 0 ].length > 3 ) {
    s[ 0 ] = s[ 0 ].replace( /\B(?=(?:\d{3})+(?!\d))/g, sep );
  }
  if ( ( s[ 1 ] || '' )
        .length < prec ) {
    s[ 1 ] = s[ 1 ] || '';
    s[ 1 ] += new Array( prec - s[ 1 ].length + 1 )
      .join( '0' );
  }
  return s.join( dec );
}

module.exports = number_format;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var React = __webpack_require__( 0 ),
	assign = __webpack_require__( 60 ),
	createClass = __webpack_require__( 106 );

/**
 * Localize a React component
 * @param ComposedComponent
 * @returns A new Localized React Component
 */
module.exports = function( i18n ) {
	var i18nProps = {
		numberFormat: i18n.numberFormat.bind( i18n ),
		translate: i18n.translate.bind( i18n )
	};

	return function( ComposedComponent ) {
		var componentName = ComposedComponent.displayName || ComposedComponent.name || '';

		var component = createClass({
			displayName: 'Localized(' + componentName + ')',

			componentDidMount: function() {
				this.boundForceUpdate = this.forceUpdate.bind( this );
				i18n.stateObserver.addListener( 'change', this.boundForceUpdate );
			},

			componentWillUnmount: function() {
				// in some cases, componentWillUnmount is called before componentDidMount
				// Supposedly fixed in React 15.1.0: https://github.com/facebook/react/issues/2410
				if ( this.boundForceUpdate ) {
					i18n.stateObserver.removeListener( 'change', this.boundForceUpdate );
				}
			},

			render: function() {
				var props = assign( {}, this.props, i18nProps );
				return React.createElement( ComposedComponent, props );
			}
		} );
		component._composedComponent = ComposedComponent;
		return component;
	};
};


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var React = __webpack_require__(0);
var factory = __webpack_require__(107);

if (typeof React === 'undefined') {
  throw Error(
    'create-react-class could not find the React object. If you are using script tags, ' +
      'make sure that React is being loaded before create-react-class.'
  );
}

// Hack to grab NoopUpdateQueue from isomorphic React
var ReactNoopUpdateQueue = new React.Component().updater;

module.exports = factory(
  React.Component,
  React.isValidElement,
  ReactNoopUpdateQueue
);


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var _assign = __webpack_require__(62);

var emptyObject = __webpack_require__(108);
var _invariant = __webpack_require__(58);

if (process.env.NODE_ENV !== 'production') {
  var warning = __webpack_require__(59);
}

var MIXINS_KEY = 'mixins';

// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

var ReactPropTypeLocationNames;
if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
} else {
  ReactPropTypeLocationNames = {};
}

function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
  /**
   * Policies that describe methods in `ReactClassInterface`.
   */

  var injectedMixins = [];

  /**
   * Composite components are higher-level components that compose other composite
   * or host components.
   *
   * To create a new type of `ReactClass`, pass a specification of
   * your new class to `React.createClass`. The only requirement of your class
   * specification is that you implement a `render` method.
   *
   *   var MyComponent = React.createClass({
   *     render: function() {
   *       return <div>Hello World</div>;
   *     }
   *   });
   *
   * The class specification supports a specific protocol of methods that have
   * special meaning (e.g. `render`). See `ReactClassInterface` for
   * more the comprehensive protocol. Any other properties and methods in the
   * class specification will be available on the prototype.
   *
   * @interface ReactClassInterface
   * @internal
   */
  var ReactClassInterface = {
    /**
     * An array of Mixin objects to include when defining your component.
     *
     * @type {array}
     * @optional
     */
    mixins: 'DEFINE_MANY',

    /**
     * An object containing properties and methods that should be defined on
     * the component's constructor instead of its prototype (static methods).
     *
     * @type {object}
     * @optional
     */
    statics: 'DEFINE_MANY',

    /**
     * Definition of prop types for this component.
     *
     * @type {object}
     * @optional
     */
    propTypes: 'DEFINE_MANY',

    /**
     * Definition of context types for this component.
     *
     * @type {object}
     * @optional
     */
    contextTypes: 'DEFINE_MANY',

    /**
     * Definition of context types this component sets for its children.
     *
     * @type {object}
     * @optional
     */
    childContextTypes: 'DEFINE_MANY',

    // ==== Definition methods ====

    /**
     * Invoked when the component is mounted. Values in the mapping will be set on
     * `this.props` if that prop is not specified (i.e. using an `in` check).
     *
     * This method is invoked before `getInitialState` and therefore cannot rely
     * on `this.state` or use `this.setState`.
     *
     * @return {object}
     * @optional
     */
    getDefaultProps: 'DEFINE_MANY_MERGED',

    /**
     * Invoked once before the component is mounted. The return value will be used
     * as the initial value of `this.state`.
     *
     *   getInitialState: function() {
     *     return {
     *       isOn: false,
     *       fooBaz: new BazFoo()
     *     }
     *   }
     *
     * @return {object}
     * @optional
     */
    getInitialState: 'DEFINE_MANY_MERGED',

    /**
     * @return {object}
     * @optional
     */
    getChildContext: 'DEFINE_MANY_MERGED',

    /**
     * Uses props from `this.props` and state from `this.state` to render the
     * structure of the component.
     *
     * No guarantees are made about when or how often this method is invoked, so
     * it must not have side effects.
     *
     *   render: function() {
     *     var name = this.props.name;
     *     return <div>Hello, {name}!</div>;
     *   }
     *
     * @return {ReactComponent}
     * @required
     */
    render: 'DEFINE_ONCE',

    // ==== Delegate methods ====

    /**
     * Invoked when the component is initially created and about to be mounted.
     * This may have side effects, but any external subscriptions or data created
     * by this method must be cleaned up in `componentWillUnmount`.
     *
     * @optional
     */
    componentWillMount: 'DEFINE_MANY',

    /**
     * Invoked when the component has been mounted and has a DOM representation.
     * However, there is no guarantee that the DOM node is in the document.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been mounted (initialized and rendered) for the first time.
     *
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidMount: 'DEFINE_MANY',

    /**
     * Invoked before the component receives new props.
     *
     * Use this as an opportunity to react to a prop transition by updating the
     * state using `this.setState`. Current props are accessed via `this.props`.
     *
     *   componentWillReceiveProps: function(nextProps, nextContext) {
     *     this.setState({
     *       likesIncreasing: nextProps.likeCount > this.props.likeCount
     *     });
     *   }
     *
     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
     * transition may cause a state change, but the opposite is not true. If you
     * need it, you are probably looking for `componentWillUpdate`.
     *
     * @param {object} nextProps
     * @optional
     */
    componentWillReceiveProps: 'DEFINE_MANY',

    /**
     * Invoked while deciding if the component should be updated as a result of
     * receiving new props, state and/or context.
     *
     * Use this as an opportunity to `return false` when you're certain that the
     * transition to the new props/state/context will not require a component
     * update.
     *
     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
     *     return !equal(nextProps, this.props) ||
     *       !equal(nextState, this.state) ||
     *       !equal(nextContext, this.context);
     *   }
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @return {boolean} True if the component should update.
     * @optional
     */
    shouldComponentUpdate: 'DEFINE_ONCE',

    /**
     * Invoked when the component is about to update due to a transition from
     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
     * and `nextContext`.
     *
     * Use this as an opportunity to perform preparation before an update occurs.
     *
     * NOTE: You **cannot** use `this.setState()` in this method.
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @param {ReactReconcileTransaction} transaction
     * @optional
     */
    componentWillUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component's DOM representation has been updated.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been updated.
     *
     * @param {object} prevProps
     * @param {?object} prevState
     * @param {?object} prevContext
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component is about to be removed from its parent and have
     * its DOM representation destroyed.
     *
     * Use this as an opportunity to deallocate any external resources.
     *
     * NOTE: There is no `componentDidUnmount` since your component will have been
     * destroyed by that point.
     *
     * @optional
     */
    componentWillUnmount: 'DEFINE_MANY',

    /**
     * Replacement for (deprecated) `componentWillMount`.
     *
     * @optional
     */
    UNSAFE_componentWillMount: 'DEFINE_MANY',

    /**
     * Replacement for (deprecated) `componentWillReceiveProps`.
     *
     * @optional
     */
    UNSAFE_componentWillReceiveProps: 'DEFINE_MANY',

    /**
     * Replacement for (deprecated) `componentWillUpdate`.
     *
     * @optional
     */
    UNSAFE_componentWillUpdate: 'DEFINE_MANY',

    // ==== Advanced methods ====

    /**
     * Updates the component's currently mounted DOM representation.
     *
     * By default, this implements React's rendering and reconciliation algorithm.
     * Sophisticated clients may wish to override this.
     *
     * @param {ReactReconcileTransaction} transaction
     * @internal
     * @overridable
     */
    updateComponent: 'OVERRIDE_BASE'
  };

  /**
   * Similar to ReactClassInterface but for static methods.
   */
  var ReactClassStaticInterface = {
    /**
     * This method is invoked after a component is instantiated and when it
     * receives new props. Return an object to update state in response to
     * prop changes. Return null to indicate no change to state.
     *
     * If an object is returned, its keys will be merged into the existing state.
     *
     * @return {object || null}
     * @optional
     */
    getDerivedStateFromProps: 'DEFINE_MANY_MERGED'
  };

  /**
   * Mapping from class specification keys to special processing functions.
   *
   * Although these are declared like instance properties in the specification
   * when defining classes using `React.createClass`, they are actually static
   * and are accessible on the constructor instead of the prototype. Despite
   * being static, they must be defined outside of the "statics" key under
   * which all other static methods are defined.
   */
  var RESERVED_SPEC_KEYS = {
    displayName: function(Constructor, displayName) {
      Constructor.displayName = displayName;
    },
    mixins: function(Constructor, mixins) {
      if (mixins) {
        for (var i = 0; i < mixins.length; i++) {
          mixSpecIntoComponent(Constructor, mixins[i]);
        }
      }
    },
    childContextTypes: function(Constructor, childContextTypes) {
      if (process.env.NODE_ENV !== 'production') {
        validateTypeDef(Constructor, childContextTypes, 'childContext');
      }
      Constructor.childContextTypes = _assign(
        {},
        Constructor.childContextTypes,
        childContextTypes
      );
    },
    contextTypes: function(Constructor, contextTypes) {
      if (process.env.NODE_ENV !== 'production') {
        validateTypeDef(Constructor, contextTypes, 'context');
      }
      Constructor.contextTypes = _assign(
        {},
        Constructor.contextTypes,
        contextTypes
      );
    },
    /**
     * Special case getDefaultProps which should move into statics but requires
     * automatic merging.
     */
    getDefaultProps: function(Constructor, getDefaultProps) {
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps = createMergedResultFunction(
          Constructor.getDefaultProps,
          getDefaultProps
        );
      } else {
        Constructor.getDefaultProps = getDefaultProps;
      }
    },
    propTypes: function(Constructor, propTypes) {
      if (process.env.NODE_ENV !== 'production') {
        validateTypeDef(Constructor, propTypes, 'prop');
      }
      Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
    },
    statics: function(Constructor, statics) {
      mixStaticSpecIntoComponent(Constructor, statics);
    },
    autobind: function() {}
  };

  function validateTypeDef(Constructor, typeDef, location) {
    for (var propName in typeDef) {
      if (typeDef.hasOwnProperty(propName)) {
        // use a warning instead of an _invariant so components
        // don't show up in prod but only in __DEV__
        if (process.env.NODE_ENV !== 'production') {
          warning(
            typeof typeDef[propName] === 'function',
            '%s: %s type `%s` is invalid; it must be a function, usually from ' +
              'React.PropTypes.',
            Constructor.displayName || 'ReactClass',
            ReactPropTypeLocationNames[location],
            propName
          );
        }
      }
    }
  }

  function validateMethodOverride(isAlreadyDefined, name) {
    var specPolicy = ReactClassInterface.hasOwnProperty(name)
      ? ReactClassInterface[name]
      : null;

    // Disallow overriding of base class methods unless explicitly allowed.
    if (ReactClassMixin.hasOwnProperty(name)) {
      _invariant(
        specPolicy === 'OVERRIDE_BASE',
        'ReactClassInterface: You are attempting to override ' +
          '`%s` from your class specification. Ensure that your method names ' +
          'do not overlap with React methods.',
        name
      );
    }

    // Disallow defining methods more than once unless explicitly allowed.
    if (isAlreadyDefined) {
      _invariant(
        specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED',
        'ReactClassInterface: You are attempting to define ' +
          '`%s` on your component more than once. This conflict may be due ' +
          'to a mixin.',
        name
      );
    }
  }

  /**
   * Mixin helper which handles policy validation and reserved
   * specification keys when building React classes.
   */
  function mixSpecIntoComponent(Constructor, spec) {
    if (!spec) {
      if (process.env.NODE_ENV !== 'production') {
        var typeofSpec = typeof spec;
        var isMixinValid = typeofSpec === 'object' && spec !== null;

        if (process.env.NODE_ENV !== 'production') {
          warning(
            isMixinValid,
            "%s: You're attempting to include a mixin that is either null " +
              'or not an object. Check the mixins included by the component, ' +
              'as well as any mixins they include themselves. ' +
              'Expected object but got %s.',
            Constructor.displayName || 'ReactClass',
            spec === null ? null : typeofSpec
          );
        }
      }

      return;
    }

    _invariant(
      typeof spec !== 'function',
      "ReactClass: You're attempting to " +
        'use a component class or function as a mixin. Instead, just use a ' +
        'regular object.'
    );
    _invariant(
      !isValidElement(spec),
      "ReactClass: You're attempting to " +
        'use a component as a mixin. Instead, just use a regular object.'
    );

    var proto = Constructor.prototype;
    var autoBindPairs = proto.__reactAutoBindPairs;

    // By handling mixins before any other properties, we ensure the same
    // chaining order is applied to methods with DEFINE_MANY policy, whether
    // mixins are listed before or after these methods in the spec.
    if (spec.hasOwnProperty(MIXINS_KEY)) {
      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
    }

    for (var name in spec) {
      if (!spec.hasOwnProperty(name)) {
        continue;
      }

      if (name === MIXINS_KEY) {
        // We have already handled mixins in a special case above.
        continue;
      }

      var property = spec[name];
      var isAlreadyDefined = proto.hasOwnProperty(name);
      validateMethodOverride(isAlreadyDefined, name);

      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
        RESERVED_SPEC_KEYS[name](Constructor, property);
      } else {
        // Setup methods on prototype:
        // The following member methods should not be automatically bound:
        // 1. Expected ReactClass methods (in the "interface").
        // 2. Overridden methods (that were mixed in).
        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
        var isFunction = typeof property === 'function';
        var shouldAutoBind =
          isFunction &&
          !isReactClassMethod &&
          !isAlreadyDefined &&
          spec.autobind !== false;

        if (shouldAutoBind) {
          autoBindPairs.push(name, property);
          proto[name] = property;
        } else {
          if (isAlreadyDefined) {
            var specPolicy = ReactClassInterface[name];

            // These cases should already be caught by validateMethodOverride.
            _invariant(
              isReactClassMethod &&
                (specPolicy === 'DEFINE_MANY_MERGED' ||
                  specPolicy === 'DEFINE_MANY'),
              'ReactClass: Unexpected spec policy %s for key %s ' +
                'when mixing in component specs.',
              specPolicy,
              name
            );

            // For methods which are defined more than once, call the existing
            // methods before calling the new property, merging if appropriate.
            if (specPolicy === 'DEFINE_MANY_MERGED') {
              proto[name] = createMergedResultFunction(proto[name], property);
            } else if (specPolicy === 'DEFINE_MANY') {
              proto[name] = createChainedFunction(proto[name], property);
            }
          } else {
            proto[name] = property;
            if (process.env.NODE_ENV !== 'production') {
              // Add verbose displayName to the function, which helps when looking
              // at profiling tools.
              if (typeof property === 'function' && spec.displayName) {
                proto[name].displayName = spec.displayName + '_' + name;
              }
            }
          }
        }
      }
    }
  }

  function mixStaticSpecIntoComponent(Constructor, statics) {
    if (!statics) {
      return;
    }

    for (var name in statics) {
      var property = statics[name];
      if (!statics.hasOwnProperty(name)) {
        continue;
      }

      var isReserved = name in RESERVED_SPEC_KEYS;
      _invariant(
        !isReserved,
        'ReactClass: You are attempting to define a reserved ' +
          'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' +
          'as an instance property instead; it will still be accessible on the ' +
          'constructor.',
        name
      );

      var isAlreadyDefined = name in Constructor;
      if (isAlreadyDefined) {
        var specPolicy = ReactClassStaticInterface.hasOwnProperty(name)
          ? ReactClassStaticInterface[name]
          : null;

        _invariant(
          specPolicy === 'DEFINE_MANY_MERGED',
          'ReactClass: You are attempting to define ' +
            '`%s` on your component more than once. This conflict may be ' +
            'due to a mixin.',
          name
        );

        Constructor[name] = createMergedResultFunction(Constructor[name], property);

        return;
      }

      Constructor[name] = property;
    }
  }

  /**
   * Merge two objects, but throw if both contain the same key.
   *
   * @param {object} one The first object, which is mutated.
   * @param {object} two The second object
   * @return {object} one after it has been mutated to contain everything in two.
   */
  function mergeIntoWithNoDuplicateKeys(one, two) {
    _invariant(
      one && two && typeof one === 'object' && typeof two === 'object',
      'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'
    );

    for (var key in two) {
      if (two.hasOwnProperty(key)) {
        _invariant(
          one[key] === undefined,
          'mergeIntoWithNoDuplicateKeys(): ' +
            'Tried to merge two objects with the same key: `%s`. This conflict ' +
            'may be due to a mixin; in particular, this may be caused by two ' +
            'getInitialState() or getDefaultProps() methods returning objects ' +
            'with clashing keys.',
          key
        );
        one[key] = two[key];
      }
    }
    return one;
  }

  /**
   * Creates a function that invokes two functions and merges their return values.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createMergedResultFunction(one, two) {
    return function mergedResult() {
      var a = one.apply(this, arguments);
      var b = two.apply(this, arguments);
      if (a == null) {
        return b;
      } else if (b == null) {
        return a;
      }
      var c = {};
      mergeIntoWithNoDuplicateKeys(c, a);
      mergeIntoWithNoDuplicateKeys(c, b);
      return c;
    };
  }

  /**
   * Creates a function that invokes two functions and ignores their return vales.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createChainedFunction(one, two) {
    return function chainedFunction() {
      one.apply(this, arguments);
      two.apply(this, arguments);
    };
  }

  /**
   * Binds a method to the component.
   *
   * @param {object} component Component whose method is going to be bound.
   * @param {function} method Method to be bound.
   * @return {function} The bound method.
   */
  function bindAutoBindMethod(component, method) {
    var boundMethod = method.bind(component);
    if (process.env.NODE_ENV !== 'production') {
      boundMethod.__reactBoundContext = component;
      boundMethod.__reactBoundMethod = method;
      boundMethod.__reactBoundArguments = null;
      var componentName = component.constructor.displayName;
      var _bind = boundMethod.bind;
      boundMethod.bind = function(newThis) {
        for (
          var _len = arguments.length,
            args = Array(_len > 1 ? _len - 1 : 0),
            _key = 1;
          _key < _len;
          _key++
        ) {
          args[_key - 1] = arguments[_key];
        }

        // User is trying to bind() an autobound method; we effectively will
        // ignore the value of "this" that the user is trying to use, so
        // let's warn.
        if (newThis !== component && newThis !== null) {
          if (process.env.NODE_ENV !== 'production') {
            warning(
              false,
              'bind(): React component methods may only be bound to the ' +
                'component instance. See %s',
              componentName
            );
          }
        } else if (!args.length) {
          if (process.env.NODE_ENV !== 'production') {
            warning(
              false,
              'bind(): You are binding a component method to the component. ' +
                'React does this for you automatically in a high-performance ' +
                'way, so you can safely remove this call. See %s',
              componentName
            );
          }
          return boundMethod;
        }
        var reboundMethod = _bind.apply(boundMethod, arguments);
        reboundMethod.__reactBoundContext = component;
        reboundMethod.__reactBoundMethod = method;
        reboundMethod.__reactBoundArguments = args;
        return reboundMethod;
      };
    }
    return boundMethod;
  }

  /**
   * Binds all auto-bound methods in a component.
   *
   * @param {object} component Component whose method is going to be bound.
   */
  function bindAutoBindMethods(component) {
    var pairs = component.__reactAutoBindPairs;
    for (var i = 0; i < pairs.length; i += 2) {
      var autoBindKey = pairs[i];
      var method = pairs[i + 1];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }

  var IsMountedPreMixin = {
    componentDidMount: function() {
      this.__isMounted = true;
    }
  };

  var IsMountedPostMixin = {
    componentWillUnmount: function() {
      this.__isMounted = false;
    }
  };

  /**
   * Add more to the ReactClass base class. These are all legacy features and
   * therefore not already part of the modern ReactComponent.
   */
  var ReactClassMixin = {
    /**
     * TODO: This will be deprecated because state should always keep a consistent
     * type signature and the only use case for this, is to avoid that.
     */
    replaceState: function(newState, callback) {
      this.updater.enqueueReplaceState(this, newState, callback);
    },

    /**
     * Checks whether or not this composite component is mounted.
     * @return {boolean} True if mounted, false otherwise.
     * @protected
     * @final
     */
    isMounted: function() {
      if (process.env.NODE_ENV !== 'production') {
        warning(
          this.__didWarnIsMounted,
          '%s: isMounted is deprecated. Instead, make sure to clean up ' +
            'subscriptions and pending requests in componentWillUnmount to ' +
            'prevent memory leaks.',
          (this.constructor && this.constructor.displayName) ||
            this.name ||
            'Component'
        );
        this.__didWarnIsMounted = true;
      }
      return !!this.__isMounted;
    }
  };

  var ReactClassComponent = function() {};
  _assign(
    ReactClassComponent.prototype,
    ReactComponent.prototype,
    ReactClassMixin
  );

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  function createClass(spec) {
    // To keep our warnings more understandable, we'll use a little hack here to
    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
    // unnecessarily identify a class without displayName as 'Constructor'.
    var Constructor = identity(function(props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if (process.env.NODE_ENV !== 'production') {
        warning(
          this instanceof Constructor,
          'Something is calling a React component directly. Use a factory or ' +
            'JSX instead. See: https://fb.me/react-legacyfactory'
        );
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (process.env.NODE_ENV !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (
          initialState === undefined &&
          this.getInitialState._isMockFunction
        ) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      _invariant(
        typeof initialState === 'object' && !Array.isArray(initialState),
        '%s.getInitialState(): must return an object or null',
        Constructor.displayName || 'ReactCompositeComponent'
      );

      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, IsMountedPreMixin);
    mixSpecIntoComponent(Constructor, spec);
    mixSpecIntoComponent(Constructor, IsMountedPostMixin);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if (process.env.NODE_ENV !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    _invariant(
      Constructor.prototype.render,
      'createClass(...): Class specification must implement a `render` method.'
    );

    if (process.env.NODE_ENV !== 'production') {
      warning(
        !Constructor.prototype.componentShouldUpdate,
        '%s has a method called ' +
          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +
          'The name is phrased as a question because the function is ' +
          'expected to return a value.',
        spec.displayName || 'A component'
      );
      warning(
        !Constructor.prototype.componentWillRecieveProps,
        '%s has a method called ' +
          'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
        spec.displayName || 'A component'
      );
      warning(
        !Constructor.prototype.UNSAFE_componentWillRecieveProps,
        '%s has a method called UNSAFE_componentWillRecieveProps(). ' +
          'Did you mean UNSAFE_componentWillReceiveProps()?',
        spec.displayName || 'A component'
      );
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  }

  return createClass;
}

module.exports = factory;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var updateSetting = exports.updateSetting = function updateSetting(setting, value) {
	return function (dispatch) {
		// Update global variable with Changes
		window.forminatorChanges.settings = true;

		dispatch({
			type: 'UPDATE_SETTING',
			setting: setting,
			value: value
		});
	};
};

var updateSettings = exports.updateSettings = function updateSettings(settings) {
	return function (dispatch) {
		// Update global variable with Changes
		window.forminatorChanges.settings = true;

		dispatch({
			type: 'UPDATE_SETTINGS',
			settings: settings
		});
	};
};

var resetSettings = exports.resetSettings = function resetSettings(settings) {
	return function (dispatch) {
		// Update global variable with Changes
		window.forminatorChanges.settings = true;

		dispatch({
			type: 'RESET_SETTINGS',
			settings: settings
		});
	};
};

var saveBuilder = exports.saveBuilder = function saveBuilder(setting, value) {
	return function (dispatch) {
		// Empty global changed variable
		window.forminatorChanges = {
			fields: [],
			settings: false,
			saved: true
		};

		dispatch({
			type: 'UPDATE_SETTING',
			setting: setting,
			value: value
		});
	};
};

/***/ }),
/* 110 */,
/* 111 */,
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
function createThunkMiddleware(extraArgument) {
  return function (_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (action) {
        if (typeof action === 'function') {
          return action(dispatch, getState, extraArgument);
        }

        return next(action);
      };
    };
  };
}

var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

/* harmony default export */ __webpack_exports__["default"] = (thunk);

/***/ }),
/* 113 */,
/* 114 */,
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (immutable) */ __webpack_exports__["a"] = createProvider;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_PropTypes__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_warning__ = __webpack_require__(45);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var didWarnAboutReceivingStore = false;
function warnAboutReceivingStore() {
  if (didWarnAboutReceivingStore) {
    return;
  }
  didWarnAboutReceivingStore = true;

  Object(__WEBPACK_IMPORTED_MODULE_3__utils_warning__["a" /* default */])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
}

function createProvider() {
  var _Provider$childContex;

  var storeKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'store';
  var subKey = arguments[1];

  var subscriptionKey = subKey || storeKey + 'Subscription';

  var Provider = function (_Component) {
    _inherits(Provider, _Component);

    Provider.prototype.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[storeKey] = this[storeKey], _ref[subscriptionKey] = null, _ref;
    };

    function Provider(props, context) {
      _classCallCheck(this, Provider);

      var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

      _this[storeKey] = props.store;
      return _this;
    }

    Provider.prototype.render = function render() {
      return __WEBPACK_IMPORTED_MODULE_0_react__["Children"].only(this.props.children);
    };

    return Provider;
  }(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]);

  if (process.env.NODE_ENV !== 'production') {
    Provider.prototype.componentWillReceiveProps = function (nextProps) {
      if (this[storeKey] !== nextProps.store) {
        warnAboutReceivingStore();
      }
    };
  }

  Provider.propTypes = {
    store: __WEBPACK_IMPORTED_MODULE_2__utils_PropTypes__["a" /* storeShape */].isRequired,
    children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element.isRequired
  };
  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[storeKey] = __WEBPACK_IMPORTED_MODULE_2__utils_PropTypes__["a" /* storeShape */].isRequired, _Provider$childContex[subscriptionKey] = __WEBPACK_IMPORTED_MODULE_2__utils_PropTypes__["b" /* subscriptionShape */], _Provider$childContex);

  return Provider;
}

/* harmony default export */ __webpack_exports__["b"] = (createProvider());
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)))

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var assign = __webpack_require__(62);

var ReactPropTypesSecret = __webpack_require__(44);
var checkPropTypes = __webpack_require__(117);

var printWarning = function() {};

if (process.env.NODE_ENV !== 'production') {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (process.env.NODE_ENV !== 'production') {
  var ReactPropTypesSecret = __webpack_require__(44);
  var loggedTypeFailures = {};

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          )

        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

module.exports = checkPropTypes;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(44);

function emptyFunction() {}

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Subscription; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// encapsulates the subscription logic for connecting a component to the redux store, as
// well as nesting subscriptions of descendant components, so that we can ensure the
// ancestor components re-render before descendants

var CLEARED = null;
var nullListeners = {
  notify: function notify() {}
};

function createListenerCollection() {
  // the current/next pattern is copied from redux's createStore code.
  // TODO: refactor+expose that code to be reusable here?
  var current = [];
  var next = [];

  return {
    clear: function clear() {
      next = CLEARED;
      current = CLEARED;
    },
    notify: function notify() {
      var listeners = current = next;
      for (var i = 0; i < listeners.length; i++) {
        listeners[i]();
      }
    },
    get: function get() {
      return next;
    },
    subscribe: function subscribe(listener) {
      var isSubscribed = true;
      if (next === current) next = current.slice();
      next.push(listener);

      return function unsubscribe() {
        if (!isSubscribed || current === CLEARED) return;
        isSubscribed = false;

        if (next === current) next = current.slice();
        next.splice(next.indexOf(listener), 1);
      };
    }
  };
}

var Subscription = function () {
  function Subscription(store, parentSub, onStateChange) {
    _classCallCheck(this, Subscription);

    this.store = store;
    this.parentSub = parentSub;
    this.onStateChange = onStateChange;
    this.unsubscribe = null;
    this.listeners = nullListeners;
  }

  Subscription.prototype.addNestedSub = function addNestedSub(listener) {
    this.trySubscribe();
    return this.listeners.subscribe(listener);
  };

  Subscription.prototype.notifyNestedSubs = function notifyNestedSubs() {
    this.listeners.notify();
  };

  Subscription.prototype.isSubscribed = function isSubscribed() {
    return Boolean(this.unsubscribe);
  };

  Subscription.prototype.trySubscribe = function trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);

      this.listeners = createListenerCollection();
    }
  };

  Subscription.prototype.tryUnsubscribe = function tryUnsubscribe() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
      this.listeners.clear();
      this.listeners = nullListeners;
    }
  };

  return Subscription;
}();



/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export createConnect */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_connectAdvanced__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_shallowEqual__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mapDispatchToProps__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mapStateToProps__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__mergeProps__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__selectorFactory__ = __webpack_require__(137);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }








/*
  connect is a facade over connectAdvanced. It turns its args into a compatible
  selectorFactory, which has the signature:

    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
  
  connect passes its args to connectAdvanced as options, which will in turn pass them to
  selectorFactory each time a Connect component instance is instantiated or hot reloaded.

  selectorFactory returns a final props selector from its mapStateToProps,
  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
  mergePropsFactories, and pure args.

  The resulting final props selector is called by the Connect component instance whenever
  it receives new props or store state.
 */

function match(arg, factories, name) {
  for (var i = factories.length - 1; i >= 0; i--) {
    var result = factories[i](arg);
    if (result) return result;
  }

  return function (dispatch, options) {
    throw new Error('Invalid value of type ' + typeof arg + ' for ' + name + ' argument when connecting component ' + options.wrappedComponentName + '.');
  };
}

function strictEqual(a, b) {
  return a === b;
}

// createConnect with default args builds the 'official' connect behavior. Calling it with
// different options opens up some testing and extensibility scenarios
function createConnect() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$connectHOC = _ref.connectHOC,
      connectHOC = _ref$connectHOC === undefined ? __WEBPACK_IMPORTED_MODULE_0__components_connectAdvanced__["a" /* default */] : _ref$connectHOC,
      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
      mapStateToPropsFactories = _ref$mapStateToPropsF === undefined ? __WEBPACK_IMPORTED_MODULE_3__mapStateToProps__["a" /* default */] : _ref$mapStateToPropsF,
      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
      mapDispatchToPropsFactories = _ref$mapDispatchToPro === undefined ? __WEBPACK_IMPORTED_MODULE_2__mapDispatchToProps__["a" /* default */] : _ref$mapDispatchToPro,
      _ref$mergePropsFactor = _ref.mergePropsFactories,
      mergePropsFactories = _ref$mergePropsFactor === undefined ? __WEBPACK_IMPORTED_MODULE_4__mergeProps__["a" /* default */] : _ref$mergePropsFactor,
      _ref$selectorFactory = _ref.selectorFactory,
      selectorFactory = _ref$selectorFactory === undefined ? __WEBPACK_IMPORTED_MODULE_5__selectorFactory__["a" /* default */] : _ref$selectorFactory;

  return function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
    var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref2$pure = _ref2.pure,
        pure = _ref2$pure === undefined ? true : _ref2$pure,
        _ref2$areStatesEqual = _ref2.areStatesEqual,
        areStatesEqual = _ref2$areStatesEqual === undefined ? strictEqual : _ref2$areStatesEqual,
        _ref2$areOwnPropsEqua = _ref2.areOwnPropsEqual,
        areOwnPropsEqual = _ref2$areOwnPropsEqua === undefined ? __WEBPACK_IMPORTED_MODULE_1__utils_shallowEqual__["a" /* default */] : _ref2$areOwnPropsEqua,
        _ref2$areStatePropsEq = _ref2.areStatePropsEqual,
        areStatePropsEqual = _ref2$areStatePropsEq === undefined ? __WEBPACK_IMPORTED_MODULE_1__utils_shallowEqual__["a" /* default */] : _ref2$areStatePropsEq,
        _ref2$areMergedPropsE = _ref2.areMergedPropsEqual,
        areMergedPropsEqual = _ref2$areMergedPropsE === undefined ? __WEBPACK_IMPORTED_MODULE_1__utils_shallowEqual__["a" /* default */] : _ref2$areMergedPropsE,
        extraOptions = _objectWithoutProperties(_ref2, ['pure', 'areStatesEqual', 'areOwnPropsEqual', 'areStatePropsEqual', 'areMergedPropsEqual']);

    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');

    return connectHOC(selectorFactory, _extends({
      // used in error messages
      methodName: 'connect',

      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function getDisplayName(name) {
        return 'Connect(' + name + ')';
      },

      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),

      // passed through to selectorFactory
      initMapStateToProps: initMapStateToProps,
      initMapDispatchToProps: initMapDispatchToProps,
      initMergeProps: initMergeProps,
      pure: pure,
      areStatesEqual: areStatesEqual,
      areOwnPropsEqual: areOwnPropsEqual,
      areStatePropsEqual: areStatePropsEqual,
      areMergedPropsEqual: areMergedPropsEqual

    }, extraOptions));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (createConnect());

/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = shallowEqual;
var hasOwn = Object.prototype.hasOwnProperty;

function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) return false;

  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export whenMapDispatchToPropsIsFunction */
/* unused harmony export whenMapDispatchToPropsIsMissing */
/* unused harmony export whenMapDispatchToPropsIsObject */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_redux__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__wrapMapToProps__ = __webpack_require__(71);



function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return typeof mapDispatchToProps === 'function' ? Object(__WEBPACK_IMPORTED_MODULE_1__wrapMapToProps__["b" /* wrapMapToPropsFunc */])(mapDispatchToProps, 'mapDispatchToProps') : undefined;
}

function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return !mapDispatchToProps ? Object(__WEBPACK_IMPORTED_MODULE_1__wrapMapToProps__["a" /* wrapMapToPropsConstant */])(function (dispatch) {
    return { dispatch: dispatch };
  }) : undefined;
}

function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? Object(__WEBPACK_IMPORTED_MODULE_1__wrapMapToProps__["a" /* wrapMapToPropsConstant */])(function (dispatch) {
    return Object(__WEBPACK_IMPORTED_MODULE_0_redux__["bindActionCreators"])(mapDispatchToProps, dispatch);
  }) : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = ([whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject]);

/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ponyfill_js__ = __webpack_require__(125);
/* global window */


var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {
  root = Function('return this')();
}

var result = Object(__WEBPACK_IMPORTED_MODULE_0__ponyfill_js__["a" /* default */])(root);
/* harmony default export */ __webpack_exports__["a"] = (result);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(42), __webpack_require__(124)(module)))

/***/ }),
/* 124 */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if(!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true,
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};


/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getPrototype_js__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__ = __webpack_require__(134);




/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!Object(__WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__["a" /* default */])(value) || Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a" /* default */])(value) != objectTag) {
    return false;
  }
  var proto = Object(__WEBPACK_IMPORTED_MODULE_1__getPrototype_js__["a" /* default */])(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/* harmony default export */ __webpack_exports__["a"] = (isPlainObject);


/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getRawTag_js__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__objectToString_js__ = __webpack_require__(131);




/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */].toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? Object(__WEBPACK_IMPORTED_MODULE_1__getRawTag_js__["a" /* default */])(value)
    : Object(__WEBPACK_IMPORTED_MODULE_2__objectToString_js__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (baseGetTag);


/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__ = __webpack_require__(129);


/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__["a" /* default */] || freeSelf || Function('return this')();

/* harmony default export */ __webpack_exports__["a"] = (root);


/***/ }),
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/* harmony default export */ __webpack_exports__["a"] = (freeGlobal);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(42)))

/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(73);


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */].toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (getRawTag);


/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/* harmony default export */ __webpack_exports__["a"] = (objectToString);


/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__overArg_js__ = __webpack_require__(133);


/** Built-in value references. */
var getPrototype = Object(__WEBPACK_IMPORTED_MODULE_0__overArg_js__["a" /* default */])(Object.getPrototypeOf, Object);

/* harmony default export */ __webpack_exports__["a"] = (getPrototype);


/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (overArg);


/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ __webpack_exports__["a"] = (isObjectLike);


/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export whenMapStateToPropsIsFunction */
/* unused harmony export whenMapStateToPropsIsMissing */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__wrapMapToProps__ = __webpack_require__(71);


function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === 'function' ? Object(__WEBPACK_IMPORTED_MODULE_0__wrapMapToProps__["b" /* wrapMapToPropsFunc */])(mapStateToProps, 'mapStateToProps') : undefined;
}

function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? Object(__WEBPACK_IMPORTED_MODULE_0__wrapMapToProps__["a" /* wrapMapToPropsConstant */])(function () {
    return {};
  }) : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = ([whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]);

/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export defaultMergeProps */
/* unused harmony export wrapMergePropsFunc */
/* unused harmony export whenMergePropsIsFunction */
/* unused harmony export whenMergePropsIsOmitted */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_verifyPlainObject__ = __webpack_require__(72);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return _extends({}, ownProps, stateProps, dispatchProps);
}

function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, _ref) {
    var displayName = _ref.displayName,
        pure = _ref.pure,
        areMergedPropsEqual = _ref.areMergedPropsEqual;

    var hasRunOnce = false;
    var mergedProps = void 0;

    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;

        if (process.env.NODE_ENV !== 'production') Object(__WEBPACK_IMPORTED_MODULE_0__utils_verifyPlainObject__["a" /* default */])(mergedProps, displayName, 'mergeProps');
      }

      return mergedProps;
    };
  };
}

function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
}

function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? function () {
    return defaultMergeProps;
  } : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = ([whenMergePropsIsFunction, whenMergePropsIsOmitted]);
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)))

/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export impureFinalPropsSelectorFactory */
/* unused harmony export pureFinalPropsSelectorFactory */
/* harmony export (immutable) */ __webpack_exports__["a"] = finalPropsSelectorFactory;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__verifySubselectors__ = __webpack_require__(138);
function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }



function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
  };
}

function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
  var areStatesEqual = _ref.areStatesEqual,
      areOwnPropsEqual = _ref.areOwnPropsEqual,
      areStatePropsEqual = _ref.areStatePropsEqual;

  var hasRunAtLeastOnce = false;
  var state = void 0;
  var ownProps = void 0;
  var stateProps = void 0;
  var dispatchProps = void 0;
  var mergedProps = void 0;

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;

    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);

    return mergedProps;
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state);
    state = nextState;
    ownProps = nextOwnProps;

    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}

// TODO: Add more comments

// If pure is true, the selector returned by selectorFactory will memoize its results,
// allowing connectAdvanced's shouldComponentUpdate to return false if final
// props have not changed. If false, the selector will always return a new
// object and shouldComponentUpdate will always return true.

function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps,
      initMapDispatchToProps = _ref2.initMapDispatchToProps,
      initMergeProps = _ref2.initMergeProps,
      options = _objectWithoutProperties(_ref2, ['initMapStateToProps', 'initMapDispatchToProps', 'initMergeProps']);

  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  var mergeProps = initMergeProps(dispatch, options);

  if (process.env.NODE_ENV !== 'production') {
    Object(__WEBPACK_IMPORTED_MODULE_0__verifySubselectors__["a" /* default */])(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName);
  }

  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;

  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)))

/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = verifySubselectors;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_warning__ = __webpack_require__(45);


function verify(selector, methodName, displayName) {
  if (!selector) {
    throw new Error('Unexpected value for ' + methodName + ' in ' + displayName + '.');
  } else if (methodName === 'mapStateToProps' || methodName === 'mapDispatchToProps') {
    if (!selector.hasOwnProperty('dependsOnOwnProps')) {
      Object(__WEBPACK_IMPORTED_MODULE_0__utils_warning__["a" /* default */])('The selector for ' + methodName + ' of ' + displayName + ' did not specify a value for dependsOnOwnProps.');
    }
  }
}

function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
  verify(mapStateToProps, 'mapStateToProps', displayName);
  verify(mapDispatchToProps, 'mapDispatchToProps', displayName);
  verify(mergeProps, 'mergeProps', displayName);
}

/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Router__ = __webpack_require__(47);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter = function (_React$Component) {
  _inherits(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, BrowserRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = Object(__WEBPACK_IMPORTED_MODULE_3_history__["a" /* createBrowserHistory */])(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  BrowserRouter.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!this.props.history, "<BrowserRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { BrowserRouter as Router }`.");
  };

  BrowserRouter.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__Router__["a" /* default */], { history: this.history, children: this.props.children });
  };

  return BrowserRouter;
}(__WEBPACK_IMPORTED_MODULE_1_react___default.a.Component);

BrowserRouter.propTypes = {
  basename: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.string,
  forceRefresh: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.bool,
  getUserConfirmation: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.func,
  keyLength: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.number,
  children: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.node
};


/* harmony default export */ __webpack_exports__["a"] = (BrowserRouter);

/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LocationUtils__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__PathUtils__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__createTransitionManager__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__DOMUtils__ = __webpack_require__(74);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  __WEBPACK_IMPORTED_MODULE_1_invariant___default()(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["b" /* canUseDOM */], 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["g" /* supportsHistory */])();
  var needsHashChangeListener = !Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["h" /* supportsPopStateOnHashChange */])();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? __WEBPACK_IMPORTED_MODULE_5__DOMUtils__["c" /* getConfirmation */] : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["g" /* stripTrailingSlash */])(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */])(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;


    var path = pathname + search + hash;

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!basename || Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["c" /* hasBasename */])(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["e" /* stripBasename */])(path, basename);

    return Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = Object(__WEBPACK_IMPORTED_MODULE_4__createTransitionManager__["a" /* default */])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if (Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["d" /* isExtraneousPopstateEvent */])(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location);
  };

  var push = function push(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        __WEBPACK_IMPORTED_MODULE_0_warning___default()(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        __WEBPACK_IMPORTED_MODULE_0_warning___default()(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["a" /* addEventListener */])(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["a" /* addEventListener */])(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["e" /* removeEventListener */])(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["e" /* removeEventListener */])(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ __webpack_exports__["a"] = (createBrowserHistory);

/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to) {
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var toParts = to && to.split('/') || [];
  var fromParts = from && from.split('/') || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash = void 0;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) {
    fromParts.unshift('..');
  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (resolvePathname);

/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function valueEqual(a, b) {
  if (a === b) return true;

  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return valueEqual(item, b[index]);
    });
  }

  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (aType !== bType) return false;

  if (aType === 'object') {
    var aValue = a.valueOf();
    var bValue = b.valueOf();

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) return false;

    return aKeys.every(function (key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
}

/* harmony default export */ __webpack_exports__["a"] = (valueEqual);

/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LocationUtils__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__PathUtils__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__createTransitionManager__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__DOMUtils__ = __webpack_require__(74);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["f" /* stripLeadingSlash */])(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: __WEBPACK_IMPORTED_MODULE_3__PathUtils__["f" /* stripLeadingSlash */],
    decodePath: __WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */]
  },
  slash: {
    encodePath: __WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */],
    decodePath: __WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */]
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  __WEBPACK_IMPORTED_MODULE_1_invariant___default()(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["b" /* canUseDOM */], 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["f" /* supportsGoWithoutReloadUsingHash */])();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? __WEBPACK_IMPORTED_MODULE_5__DOMUtils__["c" /* getConfirmation */] : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["g" /* stripTrailingSlash */])(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */])(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;


  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!basename || Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["c" /* hasBasename */])(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["e" /* stripBasename */])(path, basename);

    return Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path);
  };

  var transitionManager = Object(__WEBPACK_IMPORTED_MODULE_4__createTransitionManager__["a" /* default */])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["b" /* locationsAreEqual */])(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location));
  };

  var push = function push(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        __WEBPACK_IMPORTED_MODULE_0_warning___default()(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["a" /* addEventListener */])(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["e" /* removeEventListener */])(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ __webpack_exports__["a"] = (createHashHistory);

/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__PathUtils__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LocationUtils__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__createTransitionManager__ = __webpack_require__(46);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };






var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


  var transitionManager = Object(__WEBPACK_IMPORTED_MODULE_3__createTransitionManager__["a" /* default */])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(entry, undefined, createKey()) : Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = __WEBPACK_IMPORTED_MODULE_1__PathUtils__["b" /* createPath */];

  var push = function push(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ __webpack_exports__["a"] = (createMemoryHistory);

/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Router__ = __webpack_require__(47);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter = function (_React$Component) {
  _inherits(HashRouter, _React$Component);

  function HashRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, HashRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = Object(__WEBPACK_IMPORTED_MODULE_3_history__["b" /* createHashHistory */])(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  HashRouter.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!this.props.history, "<HashRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { HashRouter as Router }`.");
  };

  HashRouter.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__Router__["a" /* default */], { history: this.history, children: this.props.children });
  };

  return HashRouter;
}(__WEBPACK_IMPORTED_MODULE_1_react___default.a.Component);

HashRouter.propTypes = {
  basename: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.string,
  getUserConfirmation: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.func,
  hashType: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.oneOf(["hashbang", "noslash", "slash"]),
  children: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.node
};


/* harmony default export */ __webpack_exports__["a"] = (HashRouter);

/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_MemoryRouter__ = __webpack_require__(147);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_MemoryRouter__["a" /* default */]);

/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Router__ = __webpack_require__(48);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter = function (_React$Component) {
  _inherits(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, MemoryRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = Object(__WEBPACK_IMPORTED_MODULE_3_history__["d" /* createMemoryHistory */])(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  MemoryRouter.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!this.props.history, "<MemoryRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { MemoryRouter as Router }`.");
  };

  MemoryRouter.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__Router__["a" /* default */], { history: this.history, children: this.props.children });
  };

  return MemoryRouter;
}(__WEBPACK_IMPORTED_MODULE_1_react___default.a.Component);

MemoryRouter.propTypes = {
  initialEntries: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.array,
  initialIndex: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.number,
  getUserConfirmation: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.func,
  keyLength: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.number,
  children: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.node
};


/* harmony default export */ __webpack_exports__["a"] = (MemoryRouter);

/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Route__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Link__ = __webpack_require__(75);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






/**
 * A <Link> wrapper that knows if it's "active" or not.
 */
var NavLink = function NavLink(_ref) {
  var to = _ref.to,
      exact = _ref.exact,
      strict = _ref.strict,
      location = _ref.location,
      activeClassName = _ref.activeClassName,
      className = _ref.className,
      activeStyle = _ref.activeStyle,
      style = _ref.style,
      getIsActive = _ref.isActive,
      ariaCurrent = _ref["aria-current"],
      rest = _objectWithoutProperties(_ref, ["to", "exact", "strict", "location", "activeClassName", "className", "activeStyle", "style", "isActive", "aria-current"]);

  var path = (typeof to === "undefined" ? "undefined" : _typeof(to)) === "object" ? to.pathname : to;

  // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202
  var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__Route__["a" /* default */], {
    path: escapedPath,
    exact: exact,
    strict: strict,
    location: location,
    children: function children(_ref2) {
      var location = _ref2.location,
          match = _ref2.match;

      var isActive = !!(getIsActive ? getIsActive(match, location) : match);

      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__Link__["a" /* default */], _extends({
        to: to,
        className: isActive ? [className, activeClassName].filter(function (i) {
          return i;
        }).join(" ") : className,
        style: isActive ? _extends({}, style, activeStyle) : style,
        "aria-current": isActive && ariaCurrent || null
      }, rest));
    }
  });
};

NavLink.propTypes = {
  to: __WEBPACK_IMPORTED_MODULE_3__Link__["a" /* default */].propTypes.to,
  exact: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  strict: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  location: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  activeClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  className: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  activeStyle: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  style: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  isActive: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  "aria-current": __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(["page", "step", "location", "date", "time", "true"])
};

NavLink.defaultProps = {
  activeClassName: "active",
  "aria-current": "page"
};

/* harmony default export */ __webpack_exports__["a"] = (NavLink);

/***/ }),
/* 149 */
/***/ (function(module, exports) {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Prompt__ = __webpack_require__(151);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Prompt__["a" /* default */]);

/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_invariant__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * The public API for prompting the user before navigating away
 * from a screen with a component.
 */

var Prompt = function (_React$Component) {
  _inherits(Prompt, _React$Component);

  function Prompt() {
    _classCallCheck(this, Prompt);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Prompt.prototype.enable = function enable(message) {
    if (this.unblock) this.unblock();

    this.unblock = this.context.router.history.block(message);
  };

  Prompt.prototype.disable = function disable() {
    if (this.unblock) {
      this.unblock();
      this.unblock = null;
    }
  };

  Prompt.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_2_invariant___default()(this.context.router, "You should not use <Prompt> outside a <Router>");

    if (this.props.when) this.enable(this.props.message);
  };

  Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.when) {
      if (!this.props.when || this.props.message !== nextProps.message) this.enable(nextProps.message);
    } else {
      this.disable();
    }
  };

  Prompt.prototype.componentWillUnmount = function componentWillUnmount() {
    this.disable();
  };

  Prompt.prototype.render = function render() {
    return null;
  };

  return Prompt;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Prompt.propTypes = {
  when: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  message: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string]).isRequired
};
Prompt.defaultProps = {
  when: true
};
Prompt.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    history: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
      block: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired
    }).isRequired
  }).isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Prompt);

/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Redirect__ = __webpack_require__(153);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Redirect__["a" /* default */]);

/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_warning__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_history__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__generatePath__ = __webpack_require__(79);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








/**
 * The public API for updating the location programmatically
 * with a component.
 */

var Redirect = function (_React$Component) {
  _inherits(Redirect, _React$Component);

  function Redirect() {
    _classCallCheck(this, Redirect);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Redirect.prototype.isStatic = function isStatic() {
    return this.context.router && this.context.router.staticContext;
  };

  Redirect.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_3_invariant___default()(this.context.router, "You should not use <Redirect> outside a <Router>");

    if (this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidMount = function componentDidMount() {
    if (!this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var prevTo = Object(__WEBPACK_IMPORTED_MODULE_4_history__["c" /* createLocation */])(prevProps.to);
    var nextTo = Object(__WEBPACK_IMPORTED_MODULE_4_history__["c" /* createLocation */])(this.props.to);

    if (Object(__WEBPACK_IMPORTED_MODULE_4_history__["f" /* locationsAreEqual */])(prevTo, nextTo)) {
      __WEBPACK_IMPORTED_MODULE_2_warning___default()(false, "You tried to redirect to the same route you're currently on: " + ("\"" + nextTo.pathname + nextTo.search + "\""));
      return;
    }

    this.perform();
  };

  Redirect.prototype.computeTo = function computeTo(_ref) {
    var computedMatch = _ref.computedMatch,
        to = _ref.to;

    if (computedMatch) {
      if (typeof to === "string") {
        return Object(__WEBPACK_IMPORTED_MODULE_5__generatePath__["a" /* default */])(to, computedMatch.params);
      } else {
        return _extends({}, to, {
          pathname: Object(__WEBPACK_IMPORTED_MODULE_5__generatePath__["a" /* default */])(to.pathname, computedMatch.params)
        });
      }
    }

    return to;
  };

  Redirect.prototype.perform = function perform() {
    var history = this.context.router.history;
    var push = this.props.push;

    var to = this.computeTo(this.props);

    if (push) {
      history.push(to);
    } else {
      history.replace(to);
    }
  };

  Redirect.prototype.render = function render() {
    return null;
  };

  return Redirect;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Redirect.propTypes = {
  computedMatch: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object, // private, from <Switch>
  push: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  from: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  to: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object]).isRequired
};
Redirect.defaultProps = {
  push: false
};
Redirect.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    history: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
      push: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
      replace: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired
    }).isRequired,
    staticContext: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object
  }).isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Redirect);

/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_StaticRouter__ = __webpack_require__(155);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_StaticRouter__["a" /* default */]);

/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_history__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Router__ = __webpack_require__(48);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
};

var addBasename = function addBasename(basename, location) {
  if (!basename) return location;

  return _extends({}, location, {
    pathname: addLeadingSlash(basename) + location.pathname
  });
};

var stripBasename = function stripBasename(basename, location) {
  if (!basename) return location;

  var base = addLeadingSlash(basename);

  if (location.pathname.indexOf(base) !== 0) return location;

  return _extends({}, location, {
    pathname: location.pathname.substr(base.length)
  });
};

var createURL = function createURL(location) {
  return typeof location === "string" ? location : Object(__WEBPACK_IMPORTED_MODULE_4_history__["e" /* createPath */])(location);
};

var staticHandler = function staticHandler(methodName) {
  return function () {
    __WEBPACK_IMPORTED_MODULE_1_invariant___default()(false, "You cannot %s with <StaticRouter>", methodName);
  };
};

var noop = function noop() {};

/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */

var StaticRouter = function (_React$Component) {
  _inherits(StaticRouter, _React$Component);

  function StaticRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, StaticRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.createHref = function (path) {
      return addLeadingSlash(_this.props.basename + createURL(path));
    }, _this.handlePush = function (location) {
      var _this$props = _this.props,
          basename = _this$props.basename,
          context = _this$props.context;

      context.action = "PUSH";
      context.location = addBasename(basename, Object(__WEBPACK_IMPORTED_MODULE_4_history__["c" /* createLocation */])(location));
      context.url = createURL(context.location);
    }, _this.handleReplace = function (location) {
      var _this$props2 = _this.props,
          basename = _this$props2.basename,
          context = _this$props2.context;

      context.action = "REPLACE";
      context.location = addBasename(basename, Object(__WEBPACK_IMPORTED_MODULE_4_history__["c" /* createLocation */])(location));
      context.url = createURL(context.location);
    }, _this.handleListen = function () {
      return noop;
    }, _this.handleBlock = function () {
      return noop;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  StaticRouter.prototype.getChildContext = function getChildContext() {
    return {
      router: {
        staticContext: this.props.context
      }
    };
  };

  StaticRouter.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!this.props.history, "<StaticRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { StaticRouter as Router }`.");
  };

  StaticRouter.prototype.render = function render() {
    var _props = this.props,
        basename = _props.basename,
        context = _props.context,
        location = _props.location,
        props = _objectWithoutProperties(_props, ["basename", "context", "location"]);

    var history = {
      createHref: this.createHref,
      action: "POP",
      location: stripBasename(basename, Object(__WEBPACK_IMPORTED_MODULE_4_history__["c" /* createLocation */])(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler("go"),
      goBack: staticHandler("goBack"),
      goForward: staticHandler("goForward"),
      listen: this.handleListen,
      block: this.handleBlock
    };

    return __WEBPACK_IMPORTED_MODULE_2_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5__Router__["a" /* default */], _extends({}, props, { history: history }));
  };

  return StaticRouter;
}(__WEBPACK_IMPORTED_MODULE_2_react___default.a.Component);

StaticRouter.propTypes = {
  basename: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.string,
  context: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired,
  location: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object])
};
StaticRouter.defaultProps = {
  basename: "",
  location: "/"
};
StaticRouter.childContextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (StaticRouter);

/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Switch__ = __webpack_require__(157);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Switch__["a" /* default */]);

/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_warning__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_invariant__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__matchPath__ = __webpack_require__(49);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch = function (_React$Component) {
  _inherits(Switch, _React$Component);

  function Switch() {
    _classCallCheck(this, Switch);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Switch.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_3_invariant___default()(this.context.router, "You should not use <Switch> outside a <Router>");
  };

  Switch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    __WEBPACK_IMPORTED_MODULE_2_warning___default()(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    __WEBPACK_IMPORTED_MODULE_2_warning___default()(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');
  };

  Switch.prototype.render = function render() {
    var route = this.context.router.route;
    var children = this.props.children;

    var location = this.props.location || route.location;

    var match = void 0,
        child = void 0;
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.Children.forEach(children, function (element) {
      if (match == null && __WEBPACK_IMPORTED_MODULE_0_react___default.a.isValidElement(element)) {
        var _element$props = element.props,
            pathProp = _element$props.path,
            exact = _element$props.exact,
            strict = _element$props.strict,
            sensitive = _element$props.sensitive,
            from = _element$props.from;

        var path = pathProp || from;

        child = element;
        match = Object(__WEBPACK_IMPORTED_MODULE_4__matchPath__["a" /* default */])(location.pathname, { path: path, exact: exact, strict: strict, sensitive: sensitive }, route.match);
      }
    });

    return match ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.cloneElement(child, { location: location, computedMatch: match }) : null;
  };

  return Switch;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Switch.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    route: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired
  }).isRequired
};
Switch.propTypes = {
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node,
  location: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object
};


/* harmony default export */ __webpack_exports__["a"] = (Switch);

/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_generatePath__ = __webpack_require__(79);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_generatePath__["a" /* default */]);

/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_matchPath__ = __webpack_require__(49);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_matchPath__["a" /* default */]);

/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_withRouter__ = __webpack_require__(161);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_withRouter__["a" /* default */]);

/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_hoist_non_react_statics__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_hoist_non_react_statics___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_hoist_non_react_statics__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Route__ = __webpack_require__(77);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






/**
 * A public higher-order component to access the imperative API
 */
var withRouter = function withRouter(Component) {
  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = _objectWithoutProperties(props, ["wrappedComponentRef"]);

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__Route__["a" /* default */], {
      children: function children(routeComponentProps) {
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Component, _extends({}, remainingProps, routeComponentProps, {
          ref: wrappedComponentRef
        }));
      }
    });
  };

  C.displayName = "withRouter(" + (Component.displayName || Component.name) + ")";
  C.WrappedComponent = Component;
  C.propTypes = {
    wrappedComponentRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func
  };

  return __WEBPACK_IMPORTED_MODULE_2_hoist_non_react_statics___default()(C, Component);
};

/* harmony default export */ __webpack_exports__["a"] = (withRouter);

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);
var bind = __webpack_require__(80);
var Axios = __webpack_require__(164);
var defaults = __webpack_require__(50);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(84);
axios.CancelToken = __webpack_require__(178);
axios.isCancel = __webpack_require__(83);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(179);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),
/* 163 */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(50);
var utils = __webpack_require__(14);
var InterceptorManager = __webpack_require__(173);
var dispatchRequest = __webpack_require__(174);

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(82);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error;
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);
var transformData = __webpack_require__(175);
var isCancel = __webpack_require__(83);
var defaults = __webpack_require__(50);
var isAbsoluteURL = __webpack_require__(176);
var combineURLs = __webpack_require__(177);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(14);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(84);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(85);
var formats = __webpack_require__(86);

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var toISO = Date.prototype.toISOString;

var defaults = {
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (Array.isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (Array.isArray(obj)) {
            values = values.concat(stringify(
                obj[key],
                generateArrayPrefix(prefix, key),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        } else {
            values = values.concat(stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        }
    }

    return values;
};

module.exports = function (object, opts) {
    var obj = object;
    var options = opts ? utils.assign({}, opts) : {};

    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === 'undefined') {
        options.format = formats['default'];
    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError('Unknown format option provided.');
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
        arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (sort) {
        objKeys.sort(sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        keys = keys.concat(stringify(
            obj[key],
            key,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encode ? encoder : null,
            filter,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly
        ));
    }

    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(85);

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    parameterLimit: 1000,
    plainObjects: false,
    strictNullHandling: false
};

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);

    for (var i = 0; i < parts.length; ++i) {
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder);
            val = options.decoder(part.slice(pos + 1), defaults.decoder);
        }
        if (has.call(obj, key)) {
            obj[key] = [].concat(obj[key]).concat(val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]') {
            obj = [];
            obj = obj.concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys
        // that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

module.exports = function (str, opts) {
    var options = opts ? utils.assign({}, opts) : {};

    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = __webpack_require__(0);
var ReactDOM = __webpack_require__(23);

// React 16+ supports Portals.
var canUsePortals = !!ReactDOM.createPortal;

function displace(WrappedComponent, options) {
  if (!global.document) {
    return function (_React$Component) {
      _inherits(EmptyDisplace, _React$Component);

      function EmptyDisplace() {
        _classCallCheck(this, EmptyDisplace);

        return _possibleConstructorReturn(this, (EmptyDisplace.__proto__ || Object.getPrototypeOf(EmptyDisplace)).apply(this, arguments));
      }

      _createClass(EmptyDisplace, [{
        key: 'render',
        value: function render() {
          return false;
        }
      }]);

      return EmptyDisplace;
    }(React.Component);
  }

  options = options || {};

  var Displaced = function (_React$Component2) {
    _inherits(Displaced, _React$Component2);

    function Displaced() {
      var _ref;

      var _temp, _this2, _ret;

      _classCallCheck(this, Displaced);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this2 = _possibleConstructorReturn(this, (_ref = Displaced.__proto__ || Object.getPrototypeOf(Displaced)).call.apply(_ref, [this].concat(args))), _this2), _this2.renderDisplaced = function () {
        ReactDOM.unstable_renderSubtreeIntoContainer(_this2, React.createElement(WrappedComponent, _this2.props, _this2.props.children), _this2.container);
      }, _this2.removeDisplaced = function () {
        ReactDOM.unmountComponentAtNode(_this2.container);
      }, _temp), _possibleConstructorReturn(_this2, _ret);
    }

    _createClass(Displaced, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        this.container = function () {
          if (!options.renderTo) {
            var result = document.createElement('div');
            document.body.appendChild(result);
            return result;
          } else if (typeof options.renderTo === 'string') {
            return document.querySelector(options.renderTo);
          } else {
            return options.renderTo;
          }
        }();
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        if (canUsePortals) return;
        if (this.props.mounted) {
          this.renderDisplaced();
        }
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps) {
        if (canUsePortals) return;
        if (prevProps.mounted && !this.props.mounted) {
          ReactDOM.unmountComponentAtNode(this.container);
        } else if (this.props.mounted) {
          this.renderDisplaced();
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (!canUsePortals) {
          ReactDOM.unmountComponentAtNode(this.container);
        }
        if (!options.renderTo) {
          this.container.parentNode.removeChild(this.container);
        }
      }
    }, {
      key: 'render',
      value: function render() {
        if (!canUsePortals || this.props.mounted === false) {
          return null;
        }
        return ReactDOM.createPortal(React.createElement(WrappedComponent, this.props, this.props.children), this.container);
      }
    }]);

    return Displaced;
  }(React.Component);

  Displaced.defaultProps = {
    mounted: true
  };
  Displaced.WrappedComponent = WrappedComponent;


  return Displaced;
}

module.exports = displace;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AceEditor = function (_Component) {
	_inherits(AceEditor, _Component);

	function AceEditor(props) {
		_classCallCheck(this, AceEditor);

		var _this = _possibleConstructorReturn(this, (AceEditor.__proto__ || Object.getPrototypeOf(AceEditor)).call(this, props));

		_this.updateValue = _this.updateValue.bind(_this);
		_this.insertSelector = _this.insertSelector.bind(_this);
		return _this;
	}

	_createClass(AceEditor, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			// eslint-disable-next-line no-undef
			this.editor = ace.edit('forminator-field-' + this.props.property);

			this.session = this.editor.getSession();
			this.session.setUseWorker(false);
			this.editor.setShowPrintMargin(false);

			this.session.setMode('ace/mode/css');
			this.editor.setTheme('ace/theme/sui');
			this.editor.renderer.setShowGutter(true);
			this.editor.setHighlightActiveLine(true);
			this.editor.focus();

			this.editor.on('change', this.updateValue);
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.editor.destroy();
			this.editor = null;
		}
	}, {
		key: 'insertSelector',
		value: function insertSelector(selector) {
			var selectClass = selector + '{}';

			this.editor.navigateFileEnd();
			this.editor.insert(selectClass);
			this.editor.navigateLeft(1);
			this.editor.focus();
		}
	}, {
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate() {
			return false;
		}
	}, {
		key: 'updateValue',
		value: function updateValue() {
			this.props.actions.settingsActions.updateSetting(this.props.property, this.editor.getValue());
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) ? '' : this.props.settings[this.props.property];

			var type = !_.isUndefined(this.props.type) ? this.props.type : 'form';

			if ('pdf-form' === this.props.formType) {
				type = this.props.formType;
			}

			var basicSelectors = _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'label',
					{ className: 'sui-label' },
					(0, _utils.translate)('Basic selectors')
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-ace-selectors' },
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' ');
							}
						},
						(0, _utils.translate)('Form')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-title ');
							}
						},
						(0, _utils.translate)('Section Title')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-subtitle ');
							}
						},
						(0, _utils.translate)('Section Subtitle')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-label ');
							}
						},
						(0, _utils.translate)('Field Label')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-description ');
							}
						},
						(0, _utils.translate)('Field Description')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-input ');
							}
						},
						(0, _utils.translate)('Input')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-textarea ');
							}
						},
						(0, _utils.translate)('Textarea')
					)
				)
			);

			var pollSelectors = _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'label',
					{ className: 'sui-label' },
					(0, _utils.translate)('Basic selectors')
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-ace-selectors' },
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' ');
							}
						},
						(0, _utils.translate)('Poll')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-poll--question ');
							}
						},
						(0, _utils.translate)('Question')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-radio .forminator-radio-bullet ');
							}
						},
						(0, _utils.translate)('Answer Input')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-radio .forminator-radio-label ');
							}
						},
						(0, _utils.translate)('Answer Label')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-button ');
							}
						},
						(0, _utils.translate)('Submit Button')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' .forminator-poll-footer a.forminator-link, ' + '.forminator-poll-footer a.forminator-link:visited ');
							}
						},
						(0, _utils.translate)('View Results Link')
					)
				)
			);

			var quizSelectors = _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'label',
					{ className: 'sui-label' },
					(0, _utils.translate)('Basic selectors')
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-ace-selectors' },
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector(' ');
							}
						},
						(0, _utils.translate)('Quiz')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-quiz--title ');
							}
						},
						(0, _utils.translate)('Title')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-quiz--description p ');
							}
						},
						(0, _utils.translate)('Description')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-question .forminator-legend ');
							}
						},
						(0, _utils.translate)('Question')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-answer .forminator-answer--design ');
							}
						},
						(0, _utils.translate)('Answer Container')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-answer .forminator-answer--name ');
							}
						},
						(0, _utils.translate)('Answer Text')
					)
				)
			);

			var pdfSelectors = _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'label',
					{ className: 'sui-label' },
					(0, _utils.translate)('PDF selectors')
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-ace-selectors' },
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('body');
							}
						},
						(0, _utils.translate)('Body')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-pdf-header');
							}
						},
						(0, _utils.translate)('PDF Header')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.pdf-logo');
							}
						},
						(0, _utils.translate)('Logo')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.pdf-title');
							}
						},
						(0, _utils.translate)('Title')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-row-heading td');
							}
						},
						(0, _utils.translate)('Field Label')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-row-content td');
							}
						},
						(0, _utils.translate)('Field Value')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-pdf-footer-text td');
							}
						},
						(0, _utils.translate)('Footer')
					),
					_react2.default.createElement(
						'a',
						{ className: 'sui-selector sui-insert-selector',
							onClick: function onClick() {
								return _this2.insertSelector('.forminator-pdf-pagination td');
							}
						},
						(0, _utils.translate)('Pagination')
					)
				)
			);

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				type === 'form' && basicSelectors,
				type === 'poll' && pollSelectors,
				type === 'quiz' && quizSelectors,
				type === 'pdf-form' && pdfSelectors,
				_react2.default.createElement(
					'div',
					{ id: 'forminator-field-' + this.props.property,
						'data-value': value,
						style: { height: '210px' }
					},
					value
				)
			);
		}
	}]);

	return AceEditor;
}(_react.Component);

exports.default = AceEditor;

/***/ }),
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = configureStore;

var _redux = __webpack_require__(11);

var _reduxThunk = __webpack_require__(112);

var _reduxThunk2 = _interopRequireDefault(_reduxThunk);

var _reducers = __webpack_require__(223);

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var newCreateStore = (0, _redux.compose)((0, _redux.applyMiddleware)(_reduxThunk2.default))(_redux.createStore);

function configureStore(initialState) {
	return newCreateStore(_reducers2.default, initialState);
}

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _redux = __webpack_require__(11);

var _wrappers = __webpack_require__(224);

var _wrappers2 = _interopRequireDefault(_wrappers);

var _settings = __webpack_require__(225);

var _settings2 = _interopRequireDefault(_settings);

var _modal = __webpack_require__(226);

var _modal2 = _interopRequireDefault(_modal);

var _integrations = __webpack_require__(227);

var _integrations2 = _interopRequireDefault(_integrations);

var _behaviors = __webpack_require__(228);

var _behaviors2 = _interopRequireDefault(_behaviors);

var _notifications = __webpack_require__(229);

var _notifications2 = _interopRequireDefault(_notifications);

var _pdfs = __webpack_require__(230);

var _pdfs2 = _interopRequireDefault(_pdfs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var appReducers = (0, _redux.combineReducers)({
	// List reducers
	wrappers: _wrappers2.default,
	settings: _settings2.default,
	modal: _modal2.default,
	integrationConditions: _integrations2.default,
	behaviorArray: _behaviors2.default,
	notifications: _notifications2.default,
	pdfs: _pdfs2.default
});

// Import reducers
exports.default = appReducers;

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = wrappers;

var _utils = __webpack_require__(1);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function updateField(state, action) {
	var wrapper = action.wrapper;

	var wrapperIndex = state.findIndex(function (wrap) {
		return wrap.wrapper_id === wrapper.wrapper_id;
	});

	state = (0, _utils.replaceInPosition)(state, wrapperIndex, wrapper);

	return state;
}

function wrappers() {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	var action = arguments[1];

	switch (action.type) {
		case 'UPDATE_FIELDS':
			return action.wrappers;
		case 'UPDATE_FIELD':
			return updateField([].concat(_toConsumableArray(state)), action);
		default:
			return state;
	}
}

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = settings;
function updateSetting(state, action) {
	var setting = action.setting,
	    value = action.value;

	// Update value

	state[setting] = value;

	return state;
}

function updateSettings(state, action) {
	var settings = action.settings;


	return _extends({}, state, settings);
}

function resetSettings(state, action) {
	var settings = action.settings;

	return _extends({}, settings);
}

function updateTitle(state, action) {
	var title = action.title;

	// Update value

	state.formName = title;

	return state;
}

function settings() {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	var action = arguments[1];

	var newState = Object.assign({}, state);

	switch (action.type) {
		case 'UPDATE_SETTINGS':
			return updateSettings(newState, action);
		case 'RESET_SETTINGS':
			return resetSettings(newState, action);
		case 'UPDATE_SETTING':
			return updateSetting(newState, action);
		case 'UPDATE_TITLE':
			return updateTitle(newState, action);
		default:
			return state;
	}
}

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var initialState = {
	modalType: null,
	modalProps: {}
};

exports.default = function () {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	var action = arguments[1];

	switch (action.type) {
		case 'SHOW_MODAL':
			return {
				modalProps: action.modalProps,
				modalType: action.modalType,
				type: action.type
			};
		case 'HIDE_MODAL':
			return initialState;
		default:
			return state;
	}
};

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = integrationConditions;

var _utils = __webpack_require__(1);

function integrationConditions() {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	var action = arguments[1];

	switch (action.type) {
		case 'UPDATE_INTEGRATION_CONDITIONS':
			return action.conditions;
		default:
			return state;
	}
}

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = behaviors;

var _utils = __webpack_require__(1);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function updateBehaviorArray(state, action) {
	var behavior = action.behavior;

	var behaviorIndex = state.findIndex(function (notify) {
		return notify.slug === behavior.slug;
	});

	state = (0, _utils.replaceInPosition)(state, behaviorIndex, behavior);

	return state;
}

function behaviors() {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	var action = arguments[1];

	switch (action.type) {
		case 'UPDATE_BEHAVIORS':
			return action.behaviors;
		case 'UPDATE_BEHAVIOR':
			return updateBehaviorArray([].concat(_toConsumableArray(state)), action);
		default:
			return state;
	}
}

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = notifications;

var _utils = __webpack_require__(1);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function updateNotification(state, action) {
	var notification = action.notification;

	var notificationIndex = state.findIndex(function (notify) {
		return notify.slug === notification.slug;
	});

	state = (0, _utils.replaceInPosition)(state, notificationIndex, notification);

	return state;
}

function notifications() {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	var action = arguments[1];

	switch (action.type) {
		case 'UPDATE_NOTIFICATIONS':
			return action.notifications;
		case 'UPDATE_NOTIFICATION':
			return updateNotification([].concat(_toConsumableArray(state)), action);
		default:
			return state;
	}
}

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = pdfs;
function pdfs() {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	var action = arguments[1];

	switch (action.type) {
		case 'UPDATE_PDFS':
			return action.pdfs;
		default:
			return state;
	}
}

/***/ }),
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ModalImage = function (_Component) {
	_inherits(ModalImage, _Component);

	function ModalImage(props) {
		_classCallCheck(this, ModalImage);

		return _possibleConstructorReturn(this, (ModalImage.__proto__ || Object.getPrototypeOf(ModalImage)).call(this, props));
	}

	_createClass(ModalImage, [{
		key: 'render',
		value: function render() {
			var image = this.props.filename ? this.props.filename : '';

			var getclass = 'sui-box-banner';
			var getalt = (0, _utils.translate)('Forminator image');

			if (!_.isUndefined(this.props.logo) && true === this.props.logo) {
				getclass = 'sui-box-logo';
			}

			if (!_.isUndefined(this.props.alt) && '' !== this.props.alt) {
				getalt = this.props.alt;
			}

			return _react2.default.createElement(
				'figure',
				{ className: getclass, 'aria-hidden': 'true' },
				_react2.default.createElement('img', {
					src: forminatorData.imagesUrl + '/' + image + '.png',
					srcSet: forminatorData.imagesUrl + '/' + image + '.png 1x,\n\t\t\t\t\t' + forminatorData.imagesUrl + '/' + image + '@2x.png 2x',
					alt: getalt
				})
			);
		}
	}]);

	return ModalImage;
}(_react.Component);

exports.default = ModalImage;

/***/ }),
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(27);

var _utils = __webpack_require__(1);

var _default = __webpack_require__(252);

var _default2 = _interopRequireDefault(_default);

var _flat = __webpack_require__(253);

var _flat2 = _interopRequireDefault(_flat);

var _bold = __webpack_require__(254);

var _bold2 = _interopRequireDefault(_bold);

var _material = __webpack_require__(255);

var _material2 = _interopRequireDefault(_material);

var _basic = __webpack_require__(256);

var _basic2 = _interopRequireDefault(_basic);

var _none = __webpack_require__(257);

var _none2 = _interopRequireDefault(_none);

var _radioTabs = __webpack_require__(7);

var _radioTabs2 = _interopRequireDefault(_radioTabs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DesignStyle = function (_Component) {
	_inherits(DesignStyle, _Component);

	function DesignStyle() {
		_classCallCheck(this, DesignStyle);

		return _possibleConstructorReturn(this, (DesignStyle.__proto__ || Object.getPrototypeOf(DesignStyle)).apply(this, arguments));
	}

	_createClass(DesignStyle, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Design Style')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)("Choose a pre-made style for your form and further customize it's appearance below.")
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(
						_radioTabs2.default,
						_extends({}, this.props, {
							property: 'form-style',
							'default': 'default'
						}),
						_react2.default.createElement(
							_default2.default,
							{ value: 'default', boxClass: 'sui-tab-content sui-tab-boxed' },
							(0, _utils.translate)('Default')
						),
						_react2.default.createElement(
							_flat2.default,
							{ value: 'flat', boxClass: 'sui-tab-content sui-tab-boxed' },
							(0, _utils.translate)('Flat')
						),
						_react2.default.createElement(
							_bold2.default,
							{ value: 'bold', boxClass: 'sui-tab-content sui-tab-boxed' },
							(0, _utils.translate)('Bold')
						),
						_react2.default.createElement(
							_material2.default,
							{ value: 'material', boxClass: 'sui-tab-content sui-tab-boxed' },
							(0, _utils.translate)('Material')
						),
						_react2.default.createElement(
							_none2.default,
							{ value: 'none', boxClass: 'sui-tab-content' },
							(0, _utils.translate)('None')
						)
					)
				)
			);
		}
	}]);

	return DesignStyle;
}(_react.Component);

exports.default = DesignStyle;

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var designDefault = function (_Component) {
	_inherits(designDefault, _Component);

	function designDefault(props) {
		_classCallCheck(this, designDefault);

		return _possibleConstructorReturn(this, (designDefault.__proto__ || Object.getPrototypeOf(designDefault)).call(this, props));
	}

	_createClass(designDefault, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'fui-demo fui-demo--custom-form fui-demo--default' },
				_react2.default.createElement(
					'label',
					null,
					(0, _utils.translate)('Field Label')
				),
				_react2.default.createElement('input', {
					type: 'text',
					placeholder: (0, _utils.translate)('Placeholder'),
					readOnly: 'readonly'
				}),
				_react2.default.createElement(
					'label',
					null,
					(0, _utils.translate)('Field Label')
				),
				_react2.default.createElement('input', { type: 'text', value: (0, _utils.translate)('Text'), readOnly: 'readonly' }),
				_react2.default.createElement(
					'button',
					null,
					(0, _utils.translate)('Button')
				)
			);
		}
	}]);

	return designDefault;
}(_react.Component);

exports.default = designDefault;

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var designFlat = function (_Component) {
	_inherits(designFlat, _Component);

	function designFlat(props) {
		_classCallCheck(this, designFlat);

		return _possibleConstructorReturn(this, (designFlat.__proto__ || Object.getPrototypeOf(designFlat)).call(this, props));
	}

	_createClass(designFlat, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'fui-demo fui-demo--custom-form fui-demo--flat' },
				_react2.default.createElement(
					'label',
					null,
					(0, _utils.translate)('Field Label')
				),
				_react2.default.createElement('input', {
					type: 'text',
					placeholder: (0, _utils.translate)('Placeholder'),
					readOnly: 'readonly'
				}),
				_react2.default.createElement(
					'label',
					null,
					(0, _utils.translate)('Field Label')
				),
				_react2.default.createElement('input', { type: 'text', value: (0, _utils.translate)('Text'), readOnly: 'readonly' }),
				_react2.default.createElement(
					'button',
					null,
					(0, _utils.translate)('Button')
				)
			);
		}
	}]);

	return designFlat;
}(_react.Component);

exports.default = designFlat;

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var designBold = function (_Component) {
	_inherits(designBold, _Component);

	function designBold(props) {
		_classCallCheck(this, designBold);

		return _possibleConstructorReturn(this, (designBold.__proto__ || Object.getPrototypeOf(designBold)).call(this, props));
	}

	_createClass(designBold, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'fui-demo fui-demo--custom-form fui-demo--bold' },
				_react2.default.createElement(
					'label',
					null,
					(0, _utils.translate)('Field Label')
				),
				_react2.default.createElement('input', {
					type: 'text',
					placeholder: (0, _utils.translate)('Placeholder'),
					readOnly: 'readonly'
				}),
				_react2.default.createElement(
					'label',
					null,
					(0, _utils.translate)('Field Label')
				),
				_react2.default.createElement('input', { type: 'text', value: (0, _utils.translate)('Text'), readOnly: 'readonly' }),
				_react2.default.createElement(
					'button',
					null,
					(0, _utils.translate)('Button')
				)
			);
		}
	}]);

	return designBold;
}(_react.Component);

exports.default = designBold;

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var designMaterial = function (_Component) {
	_inherits(designMaterial, _Component);

	function designMaterial(props) {
		_classCallCheck(this, designMaterial);

		return _possibleConstructorReturn(this, (designMaterial.__proto__ || Object.getPrototypeOf(designMaterial)).call(this, props));
	}

	_createClass(designMaterial, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'fui-demo fui-demo--custom-form fui-demo--material' },
				_react2.default.createElement(
					'div',
					{ className: 'fui-is_empty' },
					_react2.default.createElement(
						'label',
						null,
						(0, _utils.translate)('Field Label')
					),
					_react2.default.createElement('input', {
						type: 'text',
						readOnly: 'readonly'
					})
				),
				_react2.default.createElement(
					'div',
					{ className: 'fui-is_filled' },
					_react2.default.createElement(
						'label',
						null,
						(0, _utils.translate)('Field Label')
					),
					_react2.default.createElement('input', { type: 'text', value: (0, _utils.translate)('Text'), readOnly: 'readonly' })
				),
				_react2.default.createElement(
					'button',
					null,
					(0, _utils.translate)('Button')
				)
			);
		}
	}]);

	return designMaterial;
}(_react.Component);

exports.default = designMaterial;

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DesignBasic = function (_Component) {
	_inherits(DesignBasic, _Component);

	function DesignBasic(props) {
		_classCallCheck(this, DesignBasic);

		return _possibleConstructorReturn(this, (DesignBasic.__proto__ || Object.getPrototypeOf(DesignBasic)).call(this, props));
	}

	_createClass(DesignBasic, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'fui-demo fui-demo--custom-form fui-demo--basic' },
				_react2.default.createElement(
					'div',
					{ className: 'fui-is_empty' },
					_react2.default.createElement(
						'label',
						null,
						(0, _utils.translate)('Field Label')
					),
					_react2.default.createElement('input', {
						type: 'text',
						readOnly: 'readonly'
					})
				),
				_react2.default.createElement(
					'div',
					{ className: 'fui-is_filled' },
					_react2.default.createElement(
						'label',
						null,
						(0, _utils.translate)('Field Label')
					),
					_react2.default.createElement('input', { type: 'text', value: (0, _utils.translate)('Text'), readOnly: 'readonly' })
				),
				_react2.default.createElement(
					'button',
					null,
					(0, _utils.translate)('Button')
				)
			);
		}
	}]);

	return DesignBasic;
}(_react.Component);

exports.default = DesignBasic;

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var designNone = function (_Component) {
	_inherits(designNone, _Component);

	function designNone(props) {
		_classCallCheck(this, designNone);

		return _possibleConstructorReturn(this, (designNone.__proto__ || Object.getPrototypeOf(designNone)).call(this, props));
	}

	_createClass(designNone, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{
					role: 'alert',
					className: 'sui-notice sui-active',
					style: { display: 'block' },
					'aria-live': 'assertive'
				},
				_react2.default.createElement(
					'div',
					{ className: 'sui-notice-content' },
					_react2.default.createElement(
						'div',
						{ className: 'sui-notice-message' },
						_react2.default.createElement('span', {
							className: 'sui-notice-icon sui-icon-info',
							'aria-hidden': 'true'
						}),
						_react2.default.createElement(
							'p',
							null,
							(0, _utils.translate)('You have opted for no stylesheet to be enqueued. ' + "The form will inherit styles from your theme's CSS.")
						)
					)
				)
			);
		}
	}]);

	return designNone;
}(_react.Component);

exports.default = designNone;

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _qs = __webpack_require__(40);

var _qs2 = _interopRequireDefault(_qs);

var _axios = __webpack_require__(39);

var _axios2 = _interopRequireDefault(_axios);

var _utils = __webpack_require__(1);

var _accordion = __webpack_require__(35);

var _accordion2 = _interopRequireDefault(_accordion);

var _formContainer = __webpack_require__(259);

var _formContainer2 = _interopRequireDefault(_formContainer);

var _fieldsBasics = __webpack_require__(260);

var _fieldsBasics2 = _interopRequireDefault(_fieldsBasics);

var _responseLoading = __webpack_require__(261);

var _responseLoading2 = _interopRequireDefault(_responseLoading);

var _responseError = __webpack_require__(262);

var _responseError2 = _interopRequireDefault(_responseError);

var _responseSuccess = __webpack_require__(263);

var _responseSuccess2 = _interopRequireDefault(_responseSuccess);

var _section = __webpack_require__(264);

var _section2 = _interopRequireDefault(_section);

var _inputs = __webpack_require__(265);

var _inputs2 = _interopRequireDefault(_inputs);

var _inputsExtra = __webpack_require__(266);

var _inputsExtra2 = _interopRequireDefault(_inputsExtra);

var _radio = __webpack_require__(267);

var _radio2 = _interopRequireDefault(_radio);

var _consent = __webpack_require__(268);

var _consent2 = _interopRequireDefault(_consent);

var _select = __webpack_require__(269);

var _select2 = _interopRequireDefault(_select);

var _dropdown = __webpack_require__(270);

var _dropdown2 = _interopRequireDefault(_dropdown);

var _dropdownSearch = __webpack_require__(271);

var _dropdownSearch2 = _interopRequireDefault(_dropdownSearch);

var _multiSelect = __webpack_require__(272);

var _multiSelect2 = _interopRequireDefault(_multiSelect);

var _calendarBasics = __webpack_require__(273);

var _calendarBasics2 = _interopRequireDefault(_calendarBasics);

var _signature = __webpack_require__(274);

var _signature2 = _interopRequireDefault(_signature);

var _group = __webpack_require__(275);

var _group2 = _interopRequireDefault(_group);

var _repeater = __webpack_require__(276);

var _repeater2 = _interopRequireDefault(_repeater);

var _calendarTable = __webpack_require__(277);

var _calendarTable2 = _interopRequireDefault(_calendarTable);

var _paginationSteps = __webpack_require__(278);

var _paginationSteps2 = _interopRequireDefault(_paginationSteps);

var _paginationProgress = __webpack_require__(279);

var _paginationProgress2 = _interopRequireDefault(_paginationProgress);

var _paginationBack = __webpack_require__(280);

var _paginationBack2 = _interopRequireDefault(_paginationBack);

var _paginationNext = __webpack_require__(281);

var _paginationNext2 = _interopRequireDefault(_paginationNext);

var _submit = __webpack_require__(282);

var _submit2 = _interopRequireDefault(_submit);

var _empty = __webpack_require__(12);

var _empty2 = _interopRequireDefault(_empty);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _radioTabs = __webpack_require__(7);

var _radioTabs2 = _interopRequireDefault(_radioTabs);

var _uploadedFiles = __webpack_require__(283);

var _uploadedFiles2 = _interopRequireDefault(_uploadedFiles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
//import PaginationColors from './colors/pagination';


var Colors = function (_Component) {
	_inherits(Colors, _Component);

	function Colors(props) {
		_classCallCheck(this, Colors);

		return _possibleConstructorReturn(this, (Colors.__proto__ || Object.getPrototypeOf(Colors)).call(this, props));
	}

	_createClass(Colors, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.loadFonts();
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate() {
			this.loadFonts();
		}
	}, {
		key: 'loadFonts',
		value: function loadFonts() {
			if (!_.isUndefined(window.forminatorFonts)) {
				return;
			}

			var options = {
				isObject: true
			};

			var data = {
				action: 'forminator_load_google_fonts',
				data: options,
				_wpnonce: forminatorData.gFontNonce
			};

			_axios2.default.post(forminatorData.ajaxUrl, _qs2.default.stringify(data)).then(function (response) {
				window.forminatorFonts = response.data.data;
			}).catch(function (err) {
				console.log(err);
			});
		}
	}, {
		key: 'hasIndicatorEnabled',
		value: function hasIndicatorEnabled(settings) {
			if (typeof settings['submission-indicator'] !== 'undefined' && settings['submission-indicator'] === 'show') {
				return true;
			}

			return false;
		}
	}, {
		key: 'render',
		value: function render() {
			var hasPagination = (0, _utils.hasFieldType)('page-break', this.props.wrappers);

			var hasSection = (0, _utils.hasFieldType)('section', this.props.wrappers);

			var hasSingleRadio = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'radio', 'value_type', 'radio');

			var hasSingleDropdown = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'select', 'value_type', 'single');

			var hasMultiCheckbox = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'checkbox', 'value_type', 'checkbox');

			var hasMultiSelect = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'select', 'value_type', 'multiselect');

			var hasDatePicker = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'date', 'field_type', 'picker');

			var hasESign = (0, _utils.hasFieldType)('signature', this.props.wrappers);

			var hasGroup = (0, _utils.hasFieldType)('group', this.props.wrappers);

			var hasDateDropdown = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'date', 'field_type', 'select');

			var hasTimeDropdown = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'time', 'field_type', 'select') || (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'time', 'time_type', 'twelve');

			var hasAddresCountry = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'address', 'address_country', 'true');

			var hasNamePrefix = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'name', 'prefix', 'true');

			var hasGDPR = (0, _utils.hasFieldType)('gdprcheckbox', this.props.wrappers);

			var hasFileUpload = (0, _utils.hasFieldType)('upload', this.props.wrappers);

			var hasCurrency = (0, _utils.hasFieldType)('currency', this.props.wrappers);

			var hasStripe = (0, _utils.hasFieldType)('stripe', this.props.wrappers);

			var hasCalculation = (0, _utils.hasFieldType)('calculation', this.props.wrappers);

			var hasConsent = (0, _utils.hasFieldType)('consent', this.props.wrappers);

			var postdata_multiple = (0, _utils.hasPostdataFieldWithMultiselect)(this.props.wrappers);

			var isPreset = !_.isUndefined(this.props.preset);

			var hasIndicator = isPreset || this.hasIndicatorEnabled(this.props.settings);

			var hasPaginationHeader = _.isUndefined(this.props.settings.paginationData) || _.isUndefined(this.props.settings.paginationData['pagination-header-design']) ? '' : this.props.settings.paginationData['pagination-header-design'];

			var paginationHeader = _.isUndefined(this.props.settings.paginationData) || _.isUndefined(this.props.settings.paginationData['pagination-header']) ? '' : this.props.settings.paginationData['pagination-header'];

			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Colors')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)('Adjust the default color combinations to match your theme styling.')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(
						_radioTabs2.default,
						_extends({}, this.props, {
							property: 'cform-color-settings',
							'default': ''
						}),
						_react2.default.createElement(
							_empty2.default,
							{ value: '', boxClass: '' },
							(0, _utils.translate)('Use Default Colors')
						),
						_react2.default.createElement(
							_container2.default,
							{ value: 'true', label: (0, _utils.translate)('Custom') },
							_react2.default.createElement(
								'div',
								{ className: 'sui-accordion' },
								_react2.default.createElement(
									'div',
									{ className: 'sui-accordion-header' },
									_react2.default.createElement(
										'div',
										null,
										(0, _utils.translate)('Element')
									)
								),
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Form Container')
									}),
									_react2.default.createElement(_formContainer2.default, this.props)
								),
								hasIndicator && _react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Submission Indicator')
									}),
									_react2.default.createElement(_responseLoading2.default, this.props)
								),
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Response Success')
									}),
									_react2.default.createElement(
										'p',
										{ className: 'sui-description' },
										(0, _utils.translate)('Successful response message will be displayed after ' + 'form submission succeeds.')
									),
									_react2.default.createElement(_responseSuccess2.default, this.props)
								),
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Response Error')
									}),
									_react2.default.createElement(
										'p',
										{ className: 'sui-description' },
										(0, _utils.translate)('Error response message will be displayed after ' + 'form submission fails.')
									),
									_react2.default.createElement(_responseError2.default, this.props)
								),
								(isPreset || hasPagination && hasPaginationHeader === 'show' && paginationHeader === 'nav') && _react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Pagination Steps')
									}),
									_react2.default.createElement(_paginationSteps2.default, this.props)
								),
								(isPreset || hasPagination && hasPaginationHeader === 'show' && paginationHeader === 'bar') && _react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Pagination Progress Bar')
									}),
									_react2.default.createElement(_paginationProgress2.default, this.props)
								),
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Fields Basics')
									}),
									_react2.default.createElement(_fieldsBasics2.default, this.props)
								),
								hasSection && _react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Section')
									}),
									_react2.default.createElement(_section2.default, this.props)
								),
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Input and Textarea')
									}),
									_react2.default.createElement(_inputs2.default, this.props)
								),
								(hasDatePicker || hasCurrency || hasStripe || hasCalculation) && _react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Input Extras')
									}),
									_react2.default.createElement(_inputsExtra2.default, this.props)
								),
								(hasMultiCheckbox || hasSingleRadio || hasGDPR) && _react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Radio and Checkbox')
									}),
									_react2.default.createElement(_radio2.default, this.props)
								),
								(hasSingleDropdown || hasDateDropdown || hasTimeDropdown || hasAddresCountry || hasNamePrefix) && _react2.default.createElement(
									_react2.default.Fragment,
									null,
									_react2.default.createElement(
										_accordion2.default,
										_extends({}, this.props, {
											label: (0, _utils.translate)('Select')
										}),
										_react2.default.createElement(_select2.default, this.props)
									),
									_react2.default.createElement(
										_accordion2.default,
										_extends({}, this.props, {
											label: (0, _utils.translate)('Dropdown List')
										}),
										_react2.default.createElement(_dropdown2.default, this.props)
									)
								),
								hasAddresCountry && _react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Dropdown Search')
									}),
									_react2.default.createElement(_dropdownSearch2.default, this.props)
								),
								(hasMultiSelect || postdata_multiple) && _react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Multi Select')
									}),
									_react2.default.createElement(_multiSelect2.default, this.props)
								),
								hasDatePicker && _react2.default.createElement(
									_react2.default.Fragment,
									null,
									_react2.default.createElement(
										_accordion2.default,
										_extends({}, this.props, {
											label: (0, _utils.translate)('Calendar Basics')
										}),
										_react2.default.createElement(_calendarBasics2.default, this.props)
									),
									_react2.default.createElement(
										_accordion2.default,
										_extends({}, this.props, {
											label: (0, _utils.translate)('Calendar Table')
										}),
										_react2.default.createElement(_calendarTable2.default, this.props)
									)
								),
								hasFileUpload && _react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('File Upload'),
										boxedContent: false
									}),
									_react2.default.createElement(_uploadedFiles2.default, this.props)
								),
								hasESign && _react2.default.createElement(
									_react2.default.Fragment,
									null,
									_react2.default.createElement(
										_accordion2.default,
										_extends({}, this.props, {
											label: (0, _utils.translate)('E-Signature')
										}),
										_react2.default.createElement(_signature2.default, this.props)
									)
								),
								hasGroup && _react2.default.createElement(
									_react2.default.Fragment,
									null,
									_react2.default.createElement(
										_accordion2.default,
										_extends({}, this.props, {
											label: (0, _utils.translate)('Field Group')
										}),
										_react2.default.createElement(_group2.default, this.props)
									),
									_react2.default.createElement(
										_accordion2.default,
										_extends({}, this.props, {
											label: (0, _utils.translate)('Repeater Button'),
											boxedContent: false
										}),
										_react2.default.createElement(_repeater2.default, this.props)
									)
								),
								hasPagination && _react2.default.createElement(
									_react2.default.Fragment,
									null,
									_react2.default.createElement(
										_accordion2.default,
										_extends({}, this.props, {
											label: (0, _utils.translate)('Button Back')
										}),
										_react2.default.createElement(_paginationBack2.default, this.props)
									),
									_react2.default.createElement(
										_accordion2.default,
										_extends({}, this.props, {
											label: (0, _utils.translate)('Button Next')
										}),
										_react2.default.createElement(_paginationNext2.default, this.props)
									)
								),
								hasConsent && _react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Consent')
									}),
									_react2.default.createElement(_consent2.default, this.props)
								),
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Submit Button')
									}),
									_react2.default.createElement(_submit2.default, this.props)
								)
							)
						)
					)
				)
			);
		}
	}]);

	return Colors;
}(_react.Component);

exports.default = Colors;

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BasicColors = function (_Component) {
	_inherits(BasicColors, _Component);

	function BasicColors(props) {
		_classCallCheck(this, BasicColors);

		return _possibleConstructorReturn(this, (BasicColors.__proto__ || Object.getPrototypeOf(BasicColors)).call(this, props));
	}

	_createClass(BasicColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#00000000"),
					property: (0, _utils.getThemePrefix)(this.props) + 'cform-form-border',
					label: (0, _utils.translate)('Border color'),
					isAlpha: true
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#00000000"),
					property: (0, _utils.getThemePrefix)(this.props) + 'cform-form-background',
					label: (0, _utils.translate)('Background color'),
					isAlpha: true
				}))
			);
		}
	}]);

	return BasicColors;
}(_react.Component);

exports.default = BasicColors;

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GlobalColors = function (_Component) {
	_inherits(GlobalColors, _Component);

	function GlobalColors(props) {
		_classCallCheck(this, GlobalColors);

		return _possibleConstructorReturn(this, (GlobalColors.__proto__ || Object.getPrototypeOf(GlobalColors)).call(this, props));
	}

	_createClass(GlobalColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
					property: (0, _utils.getThemePrefix)(this.props) + 'cform-label-color',
					label: (0, _utils.translate)('Label')
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E04562"),
					property: (0, _utils.getThemePrefix)(this.props) + 'cform-asterisk-color',
					label: (0, _utils.translate)('Required asterisk')
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
					property: (0, _utils.getThemePrefix)(this.props) + 'label-helper-color',
					label: (0, _utils.translate)('Description')
				})),
				this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#F9E4E8"),
					property: (0, _utils.getThemePrefix)(this.props) + 'label-validation-background',
					label: (0, _utils.translate)('Error message BG'),
					isAlpha: true
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E04562"),
					property: (0, _utils.getThemePrefix)(this.props) + 'label-validation-color',
					label: this.props.formDesign !== 'material' ? (0, _utils.translate)('Error message color') : (0, _utils.translate)('Global error color'),
					description: this.props.formDesign === 'material' ? (0, _utils.translate)('This color will be used when fields throw an ' + 'error as text color, border color, etc.') : ''
				}))
			);
		}
	}]);

	return GlobalColors;
}(_react.Component);

exports.default = GlobalColors;

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ResponseLoadingColors = function (_Component) {
	_inherits(ResponseLoadingColors, _Component);

	function ResponseLoadingColors(props) {
		_classCallCheck(this, ResponseLoadingColors);

		return _possibleConstructorReturn(this, (ResponseLoadingColors.__proto__ || Object.getPrototypeOf(ResponseLoadingColors)).call(this, props));
	}

	_createClass(ResponseLoadingColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#F8F8F8"),
					property: (0, _utils.getThemePrefix)(this.props) + 'response-loading-background',
					label: (0, _utils.translate)('Background color'),
					isAlpha: true
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#666666"),
					property: (0, _utils.getThemePrefix)(this.props) + 'response-loading-color',
					label: (0, _utils.translate)('Text color')
				}))
			);
		}
	}]);

	return ResponseLoadingColors;
}(_react.Component);

exports.default = ResponseLoadingColors;

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ResponseErrorColors = function (_Component) {
	_inherits(ResponseErrorColors, _Component);

	function ResponseErrorColors(props) {
		_classCallCheck(this, ResponseErrorColors);

		return _possibleConstructorReturn(this, (ResponseErrorColors.__proto__ || Object.getPrototypeOf(ResponseErrorColors)).call(this, props));
	}

	_createClass(ResponseErrorColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E04562"),
					property: (0, _utils.getThemePrefix)(this.props) + 'response-error-border',
					label: (0, _utils.translate)('Border color'),
					isAlpha: true
				})),
				this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#F9E4E8"),
					property: (0, _utils.getThemePrefix)(this.props) + 'response-error-background',
					label: (0, _utils.translate)('Background color'),
					isAlpha: true
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#333333"),
					property: (0, _utils.getThemePrefix)(this.props) + 'response-error-color',
					label: (0, _utils.translate)('Text color')
				}))
			);
		}
	}]);

	return ResponseErrorColors;
}(_react.Component);

exports.default = ResponseErrorColors;

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ResponseSuccessColors = function (_Component) {
	_inherits(ResponseSuccessColors, _Component);

	function ResponseSuccessColors(props) {
		_classCallCheck(this, ResponseSuccessColors);

		return _possibleConstructorReturn(this, (ResponseSuccessColors.__proto__ || Object.getPrototypeOf(ResponseSuccessColors)).call(this, props));
	}

	_createClass(ResponseSuccessColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#1ABCA1"),
					property: (0, _utils.getThemePrefix)(this.props) + 'response-success-border',
					label: (0, _utils.translate)('Border color'),
					isAlpha: true
				})),
				this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#BCEEE6"),
					property: (0, _utils.getThemePrefix)(this.props) + 'response-success-background',
					label: (0, _utils.translate)('Background color'),
					isAlpha: true
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#333333"),
					property: (0, _utils.getThemePrefix)(this.props) + 'response-success-color',
					label: (0, _utils.translate)('Text color')
				}))
			);
		}
	}]);

	return ResponseSuccessColors;
}(_react.Component);

exports.default = ResponseSuccessColors;

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SectionColors = function (_Component) {
	_inherits(SectionColors, _Component);

	function SectionColors(props) {
		_classCallCheck(this, SectionColors);

		return _possibleConstructorReturn(this, (SectionColors.__proto__ || Object.getPrototypeOf(SectionColors)).call(this, props));
	}

	_createClass(SectionColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('Title color'),
					property: (0, _utils.getThemePrefix)(this.props) + 'cform-title-color',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#333333") })),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('Subtitle color'),
					property: (0, _utils.getThemePrefix)(this.props) + 'cform-subtitle-color',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#333333") }))
			);
		}
	}]);

	return SectionColors;
}(_react.Component);

exports.default = SectionColors;

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputsColors = function (_Component) {
	_inherits(InputsColors, _Component);

	function InputsColors(props) {
		_classCallCheck(this, InputsColors);

		return _possibleConstructorReturn(this, (InputsColors.__proto__ || Object.getPrototypeOf(InputsColors)).call(this, props));
	}

	_createClass(InputsColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'default',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Default'),
						value: 'default'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'input-border',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
						isAlpha: true
					})),
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'input-bg',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#EDEDED"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Placeholder'),
						property: (0, _utils.getThemePrefix)(this.props) + 'input-placeholder',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#888888")
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'input-color',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Hover'),
						value: 'hover'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'input-border-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					})),
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'input-hover-bg',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E6E6E6"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'input-hover-color',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Focus'),
						value: 'focus'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'input-border-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					})),
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'input-active-bg',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E6E6E6"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'input-active-color',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000")
					}))
				),
				this.props.formDesign !== 'material' && _react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Error'),
						value: 'error'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E04562"),
						property: (0, _utils.getThemePrefix)(this.props) + 'input-border-error',
						label: (0, _utils.translate)('Border color'),
						isAlpha: true
					}))
				)
			);
		}
	}]);

	return InputsColors;
}(_react.Component);

exports.default = InputsColors;

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputExtraColors = function (_Component) {
	_inherits(InputExtraColors, _Component);

	function InputExtraColors(props) {
		_classCallCheck(this, InputExtraColors);

		return _possibleConstructorReturn(this, (InputExtraColors.__proto__ || Object.getPrototypeOf(InputExtraColors)).call(this, props));
	}

	_createClass(InputExtraColors, [{
		key: 'render',
		value: function render() {
			var hasDatePicker = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'date', 'field_type', 'picker');

			var hasCalculation = (0, _utils.hasFieldType)('calculation', this.props.wrappers);

			var hasCurrency = (0, _utils.hasFieldType)('currency', this.props.wrappers);

			var hasStripe = (0, _utils.hasFieldType)('stripe', this.props.wrappers);

			var content = _react2.default.createElement(
				_react2.default.Fragment,
				null,
				(hasDatePicker || hasStripe) && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					property: (0, _utils.getThemePrefix)(this.props) + 'input-icon',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
					label: (0, _utils.translate)('Icon color')
				})),
				hasCalculation && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					property: (0, _utils.getThemePrefix)(this.props) + 'prefix-color',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000"),
					label: (0, _utils.translate)('Prefix color')
				})),
				(hasCurrency || hasCalculation) && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					property: (0, _utils.getThemePrefix)(this.props) + 'suffix-color',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000"),
					label: (0, _utils.translate)('Suffix color')
				}))
			);

			if (hasStripe) {
				content = _react2.default.createElement(
					_tabs2.default,
					{
						'default': 'default',
						type: 'tabs',
						extraClass: 'sui-tabs-flushed'
					},
					_react2.default.createElement(
						_container2.default,
						{
							label: (0, _utils.translate)('Default'),
							value: 'default'
						},
						(hasDatePicker || hasStripe) && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
							property: (0, _utils.getThemePrefix)(this.props) + 'input-icon',
							defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
							label: (0, _utils.translate)('Icon color')
						})),
						hasCalculation && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
							property: (0, _utils.getThemePrefix)(this.props) + 'prefix-color',
							defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000"),
							label: (0, _utils.translate)('Prefix color')
						})),
						(hasCurrency || hasCalculation) && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
							property: (0, _utils.getThemePrefix)(this.props) + 'suffix-color',
							defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000"),
							label: (0, _utils.translate)('Suffix color')
						}))
					),
					_react2.default.createElement(
						_container2.default,
						{
							label: (0, _utils.translate)('Hover'),
							value: 'hover'
						},
						hasStripe && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
							property: (0, _utils.getThemePrefix)(this.props) + 'input-icon-hover',
							defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
							label: (0, _utils.translate)('Icon color')
						}))
					),
					_react2.default.createElement(
						_container2.default,
						{
							label: (0, _utils.translate)('Focus'),
							value: 'focus'
						},
						hasStripe && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
							property: (0, _utils.getThemePrefix)(this.props) + 'input-icon-focus',
							defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
							label: (0, _utils.translate)('Icon color')
						}))
					)
				);
			}

			return content;
		}
	}]);

	return InputExtraColors;
}(_react.Component);

exports.default = InputExtraColors;

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RadioColors = function (_Component) {
	_inherits(RadioColors, _Component);

	function RadioColors(props) {
		_classCallCheck(this, RadioColors);

		return _possibleConstructorReturn(this, (RadioColors.__proto__ || Object.getPrototypeOf(RadioColors)).call(this, props));
	}

	_createClass(RadioColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'default',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Default'),
						value: 'default'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
						property: (0, _utils.getThemePrefix)(this.props) + 'radio-border-static',
						label: (0, _utils.translate)('Border color'),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'radio-background-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#EDEDED"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'radio-label',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000")
					})),
					this.props.formDesign !== 'flat' || this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Image border'),
						property: (0, _utils.getThemePrefix)(this.props) + 'radio-image-border-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
						isAlpha: true
					})),
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Image background'),
						property: (0, _utils.getThemePrefix)(this.props) + 'radio-image-background',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#EDEDED"),
						isAlpha: true
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Checked'),
						value: 'checked'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'radio-border-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'radio-background-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#EDEDED"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Icon color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'radio-icon',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3")
					})),
					this.props.formDesign !== 'flat' || this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Image border'),
						property: (0, _utils.getThemePrefix)(this.props) + 'radio-image-border-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					})),
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Image background'),
						property: (0, _utils.getThemePrefix)(this.props) + 'radio-image-background-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E1F6FF"),
						isAlpha: true
					}))
				),
				this.props.formDesign !== 'material' && _react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Error'),
						value: 'error'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E04562"),
						property: (0, _utils.getThemePrefix)(this.props) + 'radio-border-error',
						label: (0, _utils.translate)('Border color'),
						isAlpha: true
					})),
					this.props.formDesign === 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'radio-background-error',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#F9E4E8"),
						isAlpha: true
					}))
				)
			);
		}
	}]);

	return RadioColors;
}(_react.Component);

exports.default = RadioColors;

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ConsentColors = function (_Component) {
	_inherits(ConsentColors, _Component);

	function ConsentColors(props) {
		_classCallCheck(this, ConsentColors);

		return _possibleConstructorReturn(this, (ConsentColors.__proto__ || Object.getPrototypeOf(ConsentColors)).call(this, props));
	}

	_createClass(ConsentColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'default',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Default'),
						value: 'default'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
						property: (0, _utils.getThemePrefix)(this.props) + 'consent-cbox-border-static',
						label: (0, _utils.translate)('Border color'),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'consent-cbox-background-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#EDEDED"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'consent-cbox-label',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Checked'),
						value: 'checked'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'consent-cbox-border-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'consent-cbox-background-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#EDEDED"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Icon color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'consent-cbox-icon',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3")
					}))
				),
				this.props.formDesign !== 'material' && _react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Error'),
						value: 'error'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E04562"),
						property: (0, _utils.getThemePrefix)(this.props) + 'consent-cbox-border-error',
						label: (0, _utils.translate)('Border color'),
						isAlpha: true
					})),
					this.props.formDesign === 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'consent-cbox-background-error',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#F9E4E8"),
						isAlpha: true
					}))
				)
			);
		}
	}]);

	return ConsentColors;
}(_react.Component);

exports.default = ConsentColors;

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SelectColors = function (_Component) {
	_inherits(SelectColors, _Component);

	function SelectColors(props) {
		_classCallCheck(this, SelectColors);

		return _possibleConstructorReturn(this, (SelectColors.__proto__ || Object.getPrototypeOf(SelectColors)).call(this, props));
	}

	_createClass(SelectColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'default',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Default'),
						value: 'default'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'select-border-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'select-background-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#EDEDED"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Icon color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'select-icon-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771")
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'select-value-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Hover'),
						value: 'hover'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'select-border-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					})),
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'select-background-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E6E6E6"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Icon color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'select-icon-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3")
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'select-value-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Focus'),
						value: 'focus'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'select-border-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					})),
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'select-background-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E6E6E6"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Icon color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'select-icon-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3")
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'select-value-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000")
					}))
				),
				this.props.formDesign !== 'material' && _react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Error'),
						value: 'error'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'select-border-error',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E04562"),
						isAlpha: true
					}))
				)
			);
		}
	}]);

	return SelectColors;
}(_react.Component);

exports.default = SelectColors;

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DropdownColors = function (_Component) {
	_inherits(DropdownColors, _Component);

	function DropdownColors(props) {
		_classCallCheck(this, DropdownColors);

		return _possibleConstructorReturn(this, (DropdownColors.__proto__ || Object.getPrototypeOf(DropdownColors)).call(this, props));
	}

	_createClass(DropdownColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'default',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Default'),
						value: 'default'
					},
					this.props.formDesign !== 'flat' && this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						property: (0, _utils.getThemePrefix)(this.props) + 'dropdown-border',
						label: (0, _utils.translate)('Container border'),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E6E6E6"),
						property: (0, _utils.getThemePrefix)(this.props) + 'dropdown-background',
						label: (0, _utils.translate)('Container BG'),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
						property: (0, _utils.getThemePrefix)(this.props) + 'dropdown-option-color-static',
						label: (0, _utils.translate)('Option color')
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Hover'),
						value: 'hover'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#DDDDDD"),
						property: (0, _utils.getThemePrefix)(this.props) + 'dropdown-option-background-hover',
						label: (0, _utils.translate)('Option background'),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000"),
						property: (0, _utils.getThemePrefix)(this.props) + 'dropdown-option-color-hover',
						label: (0, _utils.translate)('Option color')
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Selected'),
						value: 'selected'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						property: (0, _utils.getThemePrefix)(this.props) + 'dropdown-option-background-active',
						label: (0, _utils.translate)('Option background'),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF"),
						property: (0, _utils.getThemePrefix)(this.props) + 'dropdown-option-color-active',
						label: (0, _utils.translate)('Option color')
					}))
				)
			);
		}
	}]);

	return DropdownColors;
}(_react.Component);

exports.default = DropdownColors;

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchColors = function (_Component) {
	_inherits(SearchColors, _Component);

	function SearchColors(props) {
		_classCallCheck(this, SearchColors);

		return _possibleConstructorReturn(this, (SearchColors.__proto__ || Object.getPrototypeOf(SearchColors)).call(this, props));
	}

	_createClass(SearchColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				this.props.formDesign !== 'flat' && this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
					property: (0, _utils.getThemePrefix)(this.props) + 'dropdown-search-border',
					label: (0, _utils.translate)('Border color'),
					isAlpha: true
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF"),
					property: (0, _utils.getThemePrefix)(this.props) + 'dropdown-search-background',
					label: (0, _utils.translate)('Background color'),
					isAlpha: true
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000"),
					property: (0, _utils.getThemePrefix)(this.props) + 'dropdown-search-color',
					label: (0, _utils.translate)('Text color')
				}))
			);
		}
	}]);

	return SearchColors;
}(_react.Component);

exports.default = SearchColors;

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MultiSelectColors = function (_Component) {
	_inherits(MultiSelectColors, _Component);

	function MultiSelectColors(props) {
		_classCallCheck(this, MultiSelectColors);

		return _possibleConstructorReturn(this, (MultiSelectColors.__proto__ || Object.getPrototypeOf(MultiSelectColors)).call(this, props));
	}

	_createClass(MultiSelectColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'default',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Default'),
						value: 'default'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiselect-border',
						label: this.props.formDesign !== 'material' ? (0, _utils.translate)('Container border') : (0, _utils.translate)('Option border'),
						isAlpha: true
					})),
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E6E6E6"),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiselect-background',
						label: (0, _utils.translate)('Container BG'),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiselect-item-color-static',
						label: (0, _utils.translate)('Option color')
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Hover'),
						value: 'hover'
					},
					this.props.formDesign === 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000"),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiselect-border-hover',
						label: (0, _utils.translate)('Option border'),
						isAlpha: true
					})),
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#DDDDDD"),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiselect-item-bg-hover',
						label: (0, _utils.translate)('Option background'),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000"),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiselect-item-color-hover',
						label: (0, _utils.translate)('Option color')
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Selected'),
						value: 'selected'
					},
					this.props.formDesign === 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiselect-border-active',
						label: (0, _utils.translate)('Option border'),
						isAlpha: true
					})),
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiselect-item-bg-active',
						label: (0, _utils.translate)('Option background'),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: this.props.formDesign !== 'material' ? '#FFFFFF' : '#17A8E3',
						property: (0, _utils.getThemePrefix)(this.props) + 'multiselect-item-color-active',
						label: (0, _utils.translate)('Option color')
					}))
				),
				this.props.formDesign !== 'material' && _react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Error'),
						value: 'error'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E04562"),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiselect-border-error',
						label: (0, _utils.translate)('Container border'),
						isAlpha: true
					}))
				)
			);
		}
	}]);

	return MultiSelectColors;
}(_react.Component);

exports.default = MultiSelectColors;

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CalendarColors = function (_Component) {
	_inherits(CalendarColors, _Component);

	function CalendarColors(props) {
		_classCallCheck(this, CalendarColors);

		return _possibleConstructorReturn(this, (CalendarColors.__proto__ || Object.getPrototypeOf(CalendarColors)).call(this, props));
	}

	_createClass(CalendarColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'container',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Container'),
						value: 'container'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: this.props.formDesign !== '' ? (0, _utils.translate)('Border') : (0, _utils.translate)('Header background'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-border',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: this.props.formDesign !== '' ? (0, _utils.translate)('Background') : (0, _utils.translate)('Main background'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-background',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E6E6E6"),
						isAlpha: true
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Navigation'),
						value: 'navigation'
					},
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Arrows background'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-arrows-bg',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Arrows color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-arrows-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF"),
						isAlpha: true
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Select'),
						value: 'select'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-select-border',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#BBBBBB"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-select-bg',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-select-color',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
						isAlpha: true
					}))
				)
			);
		}
	}]);

	return CalendarColors;
}(_react.Component);

exports.default = CalendarColors;

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Signature = function (_Component) {
	_inherits(Signature, _Component);

	function Signature(props) {
		_classCallCheck(this, Signature);

		return _possibleConstructorReturn(this, (Signature.__proto__ || Object.getPrototypeOf(Signature)).call(this, props));
	}

	_createClass(Signature, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'default',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						value: 'default',
						label: (0, _utils.translate)('Default')
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'signature-border-default',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771")
					})),
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'signature-background-default',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#EDEDED")
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Placeholder'),
						property: (0, _utils.getThemePrefix)(this.props) + 'signature-placeholder',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#888888")
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Signature Color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'signature-color',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#000000")
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Reset icon color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'signature-reset-icon-default',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#888888")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'hover',
						label: (0, _utils.translate)('Hover')
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'signature-border-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3")
					})),
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'signature-background-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E6E6E6")
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Reset icon color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'signature-reset-icon-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'error',
						label: (0, _utils.translate)('Error')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'signature-border-error',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E04562")
					}))
				)
			);
		}
	}]);

	return Signature;
}(_react.Component);

exports.default = Signature;

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GroupColors = function (_Component) {
	_inherits(GroupColors, _Component);

	function GroupColors(props) {
		_classCallCheck(this, GroupColors);

		return _possibleConstructorReturn(this, (GroupColors.__proto__ || Object.getPrototypeOf(GroupColors)).call(this, props));
	}

	_createClass(GroupColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(248,248,248,.5)"),
					property: (0, _utils.getThemePrefix)(this.props) + 'group-background',
					label: (0, _utils.translate)('Background color'),
					isAlpha: true
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(221,221,221,.5)"),
					property: (0, _utils.getThemePrefix)(this.props) + 'group-border',
					label: (0, _utils.translate)('Border color'),
					isAlpha: true
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "rgba(170,170,170,.5)"),
					property: (0, _utils.getThemePrefix)(this.props) + 'group-divider',
					label: (0, _utils.translate)('Divider color'),
					isAlpha: true
				}))
			);
		}
	}]);

	return GroupColors;
}(_react.Component);

exports.default = GroupColors;

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _accordion = __webpack_require__(35);

var _accordion2 = _interopRequireDefault(_accordion);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RepeaterColors = function (_Component) {
	_inherits(RepeaterColors, _Component);

	function RepeaterColors(props) {
		_classCallCheck(this, RepeaterColors);

		return _possibleConstructorReturn(this, (RepeaterColors.__proto__ || Object.getPrototypeOf(RepeaterColors)).call(this, props));
	}

	_createClass(RepeaterColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'sui-box' },
				_react2.default.createElement(
					_accordion2.default,
					_extends({}, this.props, {
						label: (0, _utils.translate)('Button')
					}),
					_react2.default.createElement(
						_tabs2.default,
						{
							'default': 'default',
							extraClass: 'sui-tabs-flushed',
							type: 'tabs'
						},
						_react2.default.createElement(
							_container2.default,
							{
								value: 'default',
								label: (0, _utils.translate)('Default')
							},
							_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Background color'),
								property: (0, _utils.getThemePrefix)(this.props) + 'repeater-button-background',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#F8F8F8")
							})),
							_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Text color'),
								property: (0, _utils.getThemePrefix)(this.props) + 'repeater-button',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#666666")
							})),
							_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Border color'),
								property: (0, _utils.getThemePrefix)(this.props) + 'repeater-border',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#AAAAAA")
							}))
						),
						_react2.default.createElement(
							_container2.default,
							{
								value: 'hover',
								label: (0, _utils.translate)('Hover')
							},
							_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Background color'),
								property: (0, _utils.getThemePrefix)(this.props) + 'repeater-button-background-hover',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#F1F1F1")
							})),
							_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Text color'),
								property: (0, _utils.getThemePrefix)(this.props) + 'repeater-button-hover',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#666666")
							})),
							_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Border color'),
								property: (0, _utils.getThemePrefix)(this.props) + 'repeater-border-hover',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#AAAAAA")
							}))
						),
						_react2.default.createElement(
							_container2.default,
							{
								value: 'focus',
								label: (0, _utils.translate)('Focus')
							},
							_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Background color'),
								property: (0, _utils.getThemePrefix)(this.props) + 'repeater-button-background-focus',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#F1F1F1")
							})),
							_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Text color'),
								property: (0, _utils.getThemePrefix)(this.props) + 'repeater-button-focus',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#666666")
							})),
							_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Border color'),
								property: (0, _utils.getThemePrefix)(this.props) + 'repeater-border-focus',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#AAAAAA")
							}))
						)
					)
				),
				_react2.default.createElement(
					_accordion2.default,
					_extends({}, this.props, {
						label: (0, _utils.translate)('Icon')
					}),
					_react2.default.createElement(
						_tabs2.default,
						{
							'default': 'default',
							extraClass: 'sui-tabs-flushed',
							type: 'tabs'
						},
						_react2.default.createElement(
							_container2.default,
							{
								value: 'default',
								label: (0, _utils.translate)('Default')
							},
							_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Color'),
								property: (0, _utils.getThemePrefix)(this.props) + 'repeater-icon',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#888888")
							}))
						),
						_react2.default.createElement(
							_container2.default,
							{
								value: 'hover',
								label: (0, _utils.translate)('Hover')
							},
							_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Color'),
								property: (0, _utils.getThemePrefix)(this.props) + 'repeater-icon-hover',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#888888")
							}))
						),
						_react2.default.createElement(
							_container2.default,
							{
								value: 'focus',
								label: (0, _utils.translate)('Focus')
							},
							_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Color'),
								property: (0, _utils.getThemePrefix)(this.props) + 'repeater-icon-focus',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#888888")
							}))
						)
					)
				),
				_react2.default.createElement(
					_accordion2.default,
					_extends({}, this.props, {
						label: (0, _utils.translate)('Link')
					}),
					_react2.default.createElement(
						_tabs2.default,
						{
							'default': 'default',
							extraClass: 'sui-tabs-flushed',
							type: 'tabs'
						},
						_react2.default.createElement(
							_container2.default,
							{
								value: 'default',
								label: (0, _utils.translate)('Default')
							},
							_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Text color'),
								property: (0, _utils.getThemePrefix)(this.props) + 'repeater-link',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3")
							}))
						),
						_react2.default.createElement(
							_container2.default,
							{
								value: 'hover',
								label: (0, _utils.translate)('Hover')
							},
							_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Text color'),
								property: (0, _utils.getThemePrefix)(this.props) + 'repeater-link-hover',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3")
							}))
						),
						_react2.default.createElement(
							_container2.default,
							{
								value: 'focus',
								label: (0, _utils.translate)('Focus')
							},
							_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Text color'),
								property: (0, _utils.getThemePrefix)(this.props) + 'repeater-link-focus',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3")
							}))
						)
					)
				)
			);
		}
	}]);

	return RepeaterColors;
}(_react.Component);

exports.default = RepeaterColors;

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CalendarColors = function (_Component) {
	_inherits(CalendarColors, _Component);

	function CalendarColors(props) {
		_classCallCheck(this, CalendarColors);

		return _possibleConstructorReturn(this, (CalendarColors.__proto__ || Object.getPrototypeOf(CalendarColors)).call(this, props));
	}

	_createClass(CalendarColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'default',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Default'),
						value: 'default'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Table head color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-dweek',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#333333"),
						isAlpha: true
					})),
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Table cell border'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-days-border-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E6E6E6"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Table cell BG'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-days-background-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E6E6E6"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Table cell color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-days-color-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
						isAlpha: true
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Hover'),
						value: 'hover'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Table cell border'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-days-border-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#DDDDDD"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Table cell BG'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-days-background-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#DDDDDD"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Table cell color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-days-color-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Active'),
						value: 'active'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Table cell border'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-days-border-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Table cell BG'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-days-background-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Table cell color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-days-color-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Current'),
						value: 'current'
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Table cell border'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-days-border-current',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Table cell BG'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-days-background-current',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#C8DEE7"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Table cell color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'calendar-days-color-current',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3")
					}))
				)
			);
		}
	}]);

	return CalendarColors;
}(_react.Component);

exports.default = CalendarColors;

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _settingsRow = __webpack_require__(16);

var _settingsRow2 = _interopRequireDefault(_settingsRow);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var StepsColors = function (_Component) {
	_inherits(StepsColors, _Component);

	function StepsColors(props) {
		_classCallCheck(this, StepsColors);

		return _possibleConstructorReturn(this, (StepsColors.__proto__ || Object.getPrototypeOf(StepsColors)).call(this, props));
	}

	_createClass(StepsColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'border',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Border'),
						value: 'border'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Default'),
						property: (0, _utils.getThemePrefix)(this.props) + 'timeline-border',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
						isAlpha: true
					})),
					this.props.formDesign !== 'bold' && this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Current'),
						property: (0, _utils.getThemePrefix)(this.props) + 'timeline-border-current',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Label'),
						value: 'label'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Default'),
						property: (0, _utils.getThemePrefix)(this.props) + 'timeline-text',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771")
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Current'),
						property: (0, _utils.getThemePrefix)(this.props) + 'timeline-text-current',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Dot'),
						value: 'dot'
					},
					_react2.default.createElement(
						_settingsRow2.default,
						null,
						_react2.default.createElement(
							'div',
							{ className: 'sui-form-field' },
							_react2.default.createElement(
								'label',
								{ className: 'sui-settings-label sui-dark' },
								(0, _utils.translate)('Default state colors')
							)
						),
						this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Border'),
							property: (0, _utils.getThemePrefix)(this.props) + 'timeline-dot-border',
							defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
							isAlpha: true
						})),
						_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Background'),
							property: (0, _utils.getThemePrefix)(this.props) + 'timeline-dot-background',
							defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
							isAlpha: true
						})),
						this.props.formDesign === 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Page number color'),
							property: (0, _utils.getThemePrefix)(this.props) + 'timeline-dot-color',
							defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF")
						}))
					),
					_react2.default.createElement(
						_settingsRow2.default,
						null,
						_react2.default.createElement(
							'div',
							{ className: 'sui-form-field' },
							_react2.default.createElement(
								'label',
								{ className: 'sui-settings-label sui-dark' },
								(0, _utils.translate)('Current state colors')
							)
						),
						this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Border'),
							property: (0, _utils.getThemePrefix)(this.props) + 'timeline-dot-border-current',
							defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
							isAlpha: true
						})),
						_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Background'),
							property: (0, _utils.getThemePrefix)(this.props) + 'timeline-dot-background-current',
							defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
							isAlpha: true
						})),
						this.props.formDesign === 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Page number color'),
							property: (0, _utils.getThemePrefix)(this.props) + 'timeline-dot-color-current',
							defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF")
						}))
					)
				)
			);
		}
	}]);

	return StepsColors;
}(_react.Component);

exports.default = StepsColors;

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ProgressColors = function (_Component) {
	_inherits(ProgressColors, _Component);

	function ProgressColors(props) {
		_classCallCheck(this, ProgressColors);

		return _possibleConstructorReturn(this, (ProgressColors.__proto__ || Object.getPrototypeOf(ProgressColors)).call(this, props));
	}

	_createClass(ProgressColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('Label'),
					property: (0, _utils.getThemePrefix)(this.props) + 'progress-label',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771")
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('Progress bar BG'),
					property: (0, _utils.getThemePrefix)(this.props) + 'progress-background',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E6E6E6"),
					isAlpha: true
				})),
				_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
					label: (0, _utils.translate)('Progress status BG'),
					property: (0, _utils.getThemePrefix)(this.props) + 'progress-background-status',
					defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
					isAlpha: true
				}))
			);
		}
	}]);

	return ProgressColors;
}(_react.Component);

exports.default = ProgressColors;

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BackColors = function (_Component) {
	_inherits(BackColors, _Component);

	function BackColors(props) {
		_classCallCheck(this, BackColors);

		return _possibleConstructorReturn(this, (BackColors.__proto__ || Object.getPrototypeOf(BackColors)).call(this, props));
	}

	_createClass(BackColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'default',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Default'),
						value: 'default'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'prev-background-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#1ABCA1"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Label color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'prev-color-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Hover'),
						value: 'hover'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'prev-background-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#159C85"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Label color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'prev-color-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Focus'),
						value: 'focus'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'prev-background-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#159C85"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Label color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'prev-color-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF")
					}))
				)
			);
		}
	}]);

	return BackColors;
}(_react.Component);

exports.default = BackColors;

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NextColors = function (_Component) {
	_inherits(NextColors, _Component);

	function NextColors(props) {
		_classCallCheck(this, NextColors);

		return _possibleConstructorReturn(this, (NextColors.__proto__ || Object.getPrototypeOf(NextColors)).call(this, props));
	}

	_createClass(NextColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'default',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Default'),
						value: 'default'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'next-background-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#1ABCA1"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Label color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'next-color-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Hover'),
						value: 'hover'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'next-background-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#159C85"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Label color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'next-color-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Focus'),
						value: 'focus'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'next-background-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#159C85"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Label color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'next-color-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF")
					}))
				)
			);
		}
	}]);

	return NextColors;
}(_react.Component);

exports.default = NextColors;

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SubmitColors = function (_Component) {
	_inherits(SubmitColors, _Component);

	function SubmitColors(props) {
		_classCallCheck(this, SubmitColors);

		return _possibleConstructorReturn(this, (SubmitColors.__proto__ || Object.getPrototypeOf(SubmitColors)).call(this, props));
	}

	_createClass(SubmitColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'default',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Default'),
						value: 'default'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-submit-background-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-submit-color-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Hover'),
						value: 'hover'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-submit-background-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#008FCA"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-submit-color-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Focus'),
						value: 'focus'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-submit-background-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#008FCA"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-submit-color-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF")
					}))
				)
			);
		}
	}]);

	return SubmitColors;
}(_react.Component);

exports.default = SubmitColors;

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _accordion = __webpack_require__(35);

var _accordion2 = _interopRequireDefault(_accordion);

var _uploadPanelSingle = __webpack_require__(284);

var _uploadPanelSingle2 = _interopRequireDefault(_uploadPanelSingle);

var _uploadPanelMultiple = __webpack_require__(285);

var _uploadPanelMultiple2 = _interopRequireDefault(_uploadPanelMultiple);

var _uploadFileMultiple = __webpack_require__(286);

var _uploadFileMultiple2 = _interopRequireDefault(_uploadFileMultiple);

var _uploadFileDelete = __webpack_require__(287);

var _uploadFileDelete2 = _interopRequireDefault(_uploadFileDelete);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UploadedFilesColors = function (_Component) {
	_inherits(UploadedFilesColors, _Component);

	function UploadedFilesColors(props) {
		_classCallCheck(this, UploadedFilesColors);

		return _possibleConstructorReturn(this, (UploadedFilesColors.__proto__ || Object.getPrototypeOf(UploadedFilesColors)).call(this, props));
	}

	_createClass(UploadedFilesColors, [{
		key: 'render',
		value: function render() {
			var hasSingleUpload = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'upload', 'file-type', 'single') || (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'postdata', 'post_image', 'false');

			var hasMultiUpload = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'upload', 'file-type', 'multiple');

			return _react2.default.createElement(
				'div',
				{ className: 'sui-box' },
				hasSingleUpload && _react2.default.createElement(
					_react2.default.Fragment,
					null,
					_react2.default.createElement(
						_accordion2.default,
						_extends({}, this.props, {
							label: (0, _utils.translate)('Single File Uploader')
						}),
						_react2.default.createElement(_uploadPanelSingle2.default, this.props)
					)
				),
				hasMultiUpload && _react2.default.createElement(
					_react2.default.Fragment,
					null,
					_react2.default.createElement(
						_accordion2.default,
						_extends({}, this.props, {
							label: (0, _utils.translate)('Multiple Files Uploader')
						}),
						_react2.default.createElement(_uploadPanelMultiple2.default, this.props)
					),
					_react2.default.createElement(
						_accordion2.default,
						_extends({}, this.props, {
							label: (0, _utils.translate)('Uploaded File')
						}),
						_react2.default.createElement(_uploadFileMultiple2.default, this.props)
					)
				),
				_react2.default.createElement(
					_accordion2.default,
					_extends({}, this.props, {
						label: (0, _utils.translate)('Uploaded File Delete Button')
					}),
					_react2.default.createElement(_uploadFileDelete2.default, this.props)
				)
			);
		}
	}]);

	return UploadedFilesColors;
}(_react.Component);

exports.default = UploadedFilesColors;

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SingleUploadPanelColors = function (_Component) {
	_inherits(SingleUploadPanelColors, _Component);

	function SingleUploadPanelColors(props) {
		_classCallCheck(this, SingleUploadPanelColors);

		return _possibleConstructorReturn(this, (SingleUploadPanelColors.__proto__ || Object.getPrototypeOf(SingleUploadPanelColors)).call(this, props));
	}

	_createClass(SingleUploadPanelColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'default',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Default'),
						value: 'default'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-upload-background-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#1ABC9C"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-upload-color-static',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Hover'),
						value: 'hover'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-upload-background-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#01A383"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-upload-color-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Focus'),
						value: 'focus'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-upload-background-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#01A383"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-upload-color-active',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#FFFFFF")
					}))
				)
			);
		}
	}]);

	return SingleUploadPanelColors;
}(_react.Component);

exports.default = SingleUploadPanelColors;

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MultiUploadPanelColors = function (_Component) {
	_inherits(MultiUploadPanelColors, _Component);

	function MultiUploadPanelColors(props) {
		_classCallCheck(this, MultiUploadPanelColors);

		return _possibleConstructorReturn(this, (MultiUploadPanelColors.__proto__ || Object.getPrototypeOf(MultiUploadPanelColors)).call(this, props));
	}

	_createClass(MultiUploadPanelColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'default',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						value: 'default',
						label: (0, _utils.translate)('Default')
					},
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-panel-background-default',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#EDEDED"),
						isAlpha: true
					})),
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-panel-border-default',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Cloud icon color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-panel-icon-default',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Message text color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-panel-text-default',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#666666")
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Message link color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-panel-link-default',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'hover',
						label: (0, _utils.translate)('Hover')
					},
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-panel-background-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E6E6E6"),
						isAlpha: true
					})),
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-panel-border-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Cloud icon color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-panel-icon-hover',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
						isAlpha: true
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'drop',
						label: (0, _utils.translate)('Drop')
					},
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-panel-background-drop',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E1F6FF"),
						isAlpha: true
					})),
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-panel-border-drop',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Cloud icon color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-panel-icon-drop',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#17A8E3"),
						isAlpha: true
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'error',
						label: (0, _utils.translate)('Error')
					},
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-panel-background-error',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#EDEDED"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: this.props.formDesign === 'flat' ? (0, _utils.translate)('Left border color') : (0, _utils.translate)('Border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-panel-border-error',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E04562"),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Cloud icon color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-panel-icon-error',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771"),
						isAlpha: true
					}))
				)
			);
		}
	}]);

	return MultiUploadPanelColors;
}(_react.Component);

exports.default = MultiUploadPanelColors;

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MultiUploadFileColors = function (_Component) {
	_inherits(MultiUploadFileColors, _Component);

	function MultiUploadFileColors(props) {
		_classCallCheck(this, MultiUploadFileColors);

		return _possibleConstructorReturn(this, (MultiUploadFileColors.__proto__ || Object.getPrototypeOf(MultiUploadFileColors)).call(this, props));
	}

	_createClass(MultiUploadFileColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'default',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						value: 'default',
						label: (0, _utils.translate)('Default')
					},
					this.props.formDesign !== 'flat' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('File preview border color'),
						description: (0, _utils.translate)('Default state border will not appear when file ' + 'uploaded is an image.'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-file-preview-border-default',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771")
					})),
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('File preview background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-file-preview-background-default',
						defaultValue: this.props.formDesign === 'flat' ? '#EDEDED' : '#FFFFFF'
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('File preview icon color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-file-preview-icon-default',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771")
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('File name color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-file-name-default',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#333333")
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('File size color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-file-size-default',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#888888")
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('Loading icon color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-file-loader-color',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#888888")
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'error',
						label: (0, _utils.translate)('Error')
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('File preview border color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-file-preview-border-error',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E04562")
					})),
					this.props.formDesign !== 'material' && _react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('File preview background color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-file-preview-background-error',
						defaultValue: this.props.formDesign === 'flat' ? '#EDEDED' : '#FFFFFF'
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('File preview icon color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-file-preview-icon-error',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#777771")
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						label: (0, _utils.translate)('File size icon color'),
						property: (0, _utils.getThemePrefix)(this.props) + 'multiupload-file-error-color',
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E04562")
					}))
				)
			);
		}
	}]);

	return MultiUploadFileColors;
}(_react.Component);

exports.default = MultiUploadFileColors;

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _colorPicker = __webpack_require__(6);

var _colorPicker2 = _interopRequireDefault(_colorPicker);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FileDeleteButtonColors = function (_Component) {
	_inherits(FileDeleteButtonColors, _Component);

	function FileDeleteButtonColors(props) {
		_classCallCheck(this, FileDeleteButtonColors);

		return _possibleConstructorReturn(this, (FileDeleteButtonColors.__proto__ || Object.getPrototypeOf(FileDeleteButtonColors)).call(this, props));
	}

	_createClass(FileDeleteButtonColors, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_tabs2.default,
				{
					'default': 'default',
					type: 'tabs',
					extraClass: 'sui-tabs-flushed'
				},
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Default'),
						value: 'default'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#00000000"),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-upload-delete-background-static',
						label: (0, _utils.translate)('Background color'),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E04562"),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-upload-delete-color-static',
						label: (0, _utils.translate)('Icon color')
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Hover'),
						value: 'hover'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#F9E4E8"),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-upload-delete-background-hover',
						label: (0, _utils.translate)('Background color'),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E04562"),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-upload-delete-color-hover',
						label: (0, _utils.translate)('Icon color')
					}))
				),
				_react2.default.createElement(
					_container2.default,
					{
						label: (0, _utils.translate)('Focus'),
						value: 'focus'
					},
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#F9E4E8"),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-upload-delete-background-active',
						label: (0, _utils.translate)('Background color'),
						isAlpha: true
					})),
					_react2.default.createElement(_colorPicker2.default, _extends({}, this.props, {
						defaultValue: '' + (0, _utils.getDefaultValue)(this.props, "#E04562"),
						property: (0, _utils.getThemePrefix)(this.props) + 'button-upload-delete-color-active',
						label: (0, _utils.translate)('Icon color')
					}))
				)
			);
		}
	}]);

	return FileDeleteButtonColors;
}(_react.Component);

exports.default = FileDeleteButtonColors;

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _radioTabs = __webpack_require__(7);

var _radioTabs2 = _interopRequireDefault(_radioTabs);

var _accordion = __webpack_require__(35);

var _accordion2 = _interopRequireDefault(_accordion);

var _empty = __webpack_require__(12);

var _empty2 = _interopRequireDefault(_empty);

var _fonts = __webpack_require__(289);

var _fonts2 = _interopRequireDefault(_fonts);

var _settingsRow = __webpack_require__(16);

var _settingsRow2 = _interopRequireDefault(_settingsRow);

var _tabs = __webpack_require__(10);

var _tabs2 = _interopRequireDefault(_tabs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Fonts = function (_Component) {
	_inherits(Fonts, _Component);

	function Fonts(props) {
		_classCallCheck(this, Fonts);

		return _possibleConstructorReturn(this, (Fonts.__proto__ || Object.getPrototypeOf(Fonts)).call(this, props));
	}

	_createClass(Fonts, [{
		key: 'render',
		value: function render() {
			var hasPagination = (0, _utils.hasFieldType)('page-break', this.props.wrappers);

			var hasSection = (0, _utils.hasFieldType)('section', this.props.wrappers);

			var hasSingleRadio = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'radio', 'value_type', 'radio');

			var hasSingleDropdown = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'select', 'value_type', 'single');

			var hasMultiCheckbox = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'checkbox', 'value_type', 'checkbox');

			var hasMultiSelect = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'select', 'value_type', 'multiselect');

			var hasDatePicker = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'date', 'field_type', 'picker');

			var hasDateDropdown = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'date', 'field_type', 'select');

			var hasTimeDropdown = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'time', 'field_type', 'select') || (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'time', 'time_type', 'twelve');

			var hasAddresCountry = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'address', 'address_country', 'true');

			var hasNamePrefix = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'name', 'prefix', 'true');

			var hasGDPR = (0, _utils.hasFieldType)('gdprcheckbox', this.props.wrappers);

			var hasCurrency = (0, _utils.hasFieldType)('currency', this.props.wrappers);

			var hasSingleUpload = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'upload', 'file-type', 'single') || (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'postdata', 'post_image', 'false');

			var hasMultiUpload = (0, _utils.hasFieldWithAttribute)(this.props.wrappers, 'upload', 'file-type', 'multiple');

			var hasESign = (0, _utils.hasFieldType)('signature', this.props.wrappers);

			var hasCalculation = (0, _utils.hasFieldType)('calculation', this.props.wrappers);

			var hasGroup = (0, _utils.hasFieldType)('group', this.props.wrappers);

			var isPreset = !_.isUndefined(this.props.preset);

			var hasPaginationHeader = _.isUndefined(this.props.settings.paginationData) || _.isUndefined(this.props.settings.paginationData['pagination-header-design']) ? '' : this.props.settings.paginationData['pagination-header-design'];

			var paginationHeader = _.isUndefined(this.props.settings.paginationData) || _.isUndefined(this.props.settings.paginationData['pagination-header']) ? '' : this.props.settings.paginationData['pagination-header'];

			return _react2.default.createElement(
				_settingsRow2.default,
				{
					label: (0, _utils.translate)('Fonts'),
					description: (0, _utils.translate)('By default this form will inherit the fonts your theme uses. ' + 'You can overwrite these fonts with custom ones from ' + '{{link}}Bunny Fonts{{/link}}.', {
						components: {
							link: _react2.default.createElement('a', { href: 'https://fonts.bunny.net/about', target: '_blank' })
						}
					})
				},
				_react2.default.createElement(
					_radioTabs2.default,
					_extends({}, this.props, {
						property: 'form-font-family',
						'default': ''
					}),
					_react2.default.createElement(
						_empty2.default,
						{
							value: ''
						},
						(0, _utils.translate)('Use Theme Fonts')
					),
					_react2.default.createElement(
						_container2.default,
						{
							value: 'custom',
							label: (0, _utils.translate)('Custom')
						},
						_react2.default.createElement(
							'div',
							{ className: 'sui-accordion' },
							_react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Response Message')
								}),
								_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
									prefix: 'cform-response',
									defaultSize: '15',
									defaultFont: 'custom',
									defaultCustom: 'inherit',
									defaultWeight: '400'
								}))
							),
							(isPreset || hasPagination && hasPaginationHeader === 'show' && paginationHeader === 'nav') && _react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Pagination Steps')
								}),
								_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
									prefix: 'cform-timeline',
									defaultSize: '12',
									defaultFont: 'custom',
									defaultCustom: 'inherit',
									defaultWeight: '500'
								}))
							),
							(isPreset || hasPagination && hasPaginationHeader === 'show' && paginationHeader === 'bar') && _react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Pagination Progress Bar')
								}),
								_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
									prefix: 'cform-progress',
									defaultSize: '12',
									defaultFont: 'custom',
									defaultCustom: 'inherit',
									defaultWeight: '500'
								}))
							),
							_react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Fields Label')
								}),
								_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
									prefix: 'cform-label',
									defaultSize: '13',
									defaultFont: 'custom',
									defaultCustom: 'inherit',
									defaultWeight: '700'
								}))
							),
							_react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Fields Description')
								}),
								_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
									prefix: 'cform-description',
									defaultSize: '12',
									defaultFont: 'custom',
									defaultCustom: 'inherit',
									defaultWeight: '400'
								}))
							),
							_react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Fields Error Message')
								}),
								_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
									prefix: 'cform-validation',
									defaultSize: '12',
									defaultFont: 'custom',
									defaultCustom: 'inherit',
									defaultWeight: '500'
								}))
							),
							hasSection && _react2.default.createElement(
								_react2.default.Fragment,
								null,
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Section Title')
									}),
									_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
										prefix: 'cform-title',
										defaultSize: '45',
										defaultFont: 'custom',
										defaultCustom: 'inherit',
										defaultWeight: '400'
									}))
								),
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Section Subtitle')
									}),
									_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
										prefix: 'cform-subtitle',
										defaultSize: '18',
										defaultFont: 'custom',
										defaultCustom: 'inherit',
										defaultWeight: '400'
									}))
								)
							),
							_react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Input and Textarea')
								}),
								_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
									prefix: 'cform-input',
									defaultSize: '16',
									defaultFont: 'Roboto',
									defaultWeight: '400'
								}))
							),
							hasCalculation && _react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Input Prefix')
								}),
								_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
									prefix: 'cform-input-prefix',
									defaultSize: '16',
									defaultFont: 'custom',
									defaultCustom: 'inherit',
									defaultWeight: '500'
								}))
							),
							(hasCurrency || hasCalculation) && _react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Input Suffix')
								}),
								_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
									prefix: 'cform-input-suffix',
									defaultSize: '16',
									defaultFont: 'custom',
									defaultCustom: 'inherit',
									defaultWeight: '500'
								}))
							),
							(hasMultiCheckbox || hasSingleRadio || hasGDPR) && _react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Radio and Checkbox')
								}),
								_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
									prefix: 'cform-radio',
									defaultSize: '14',
									defaultFont: 'custom',
									defaultCustom: 'inherit',
									defaultWeight: '400'
								}))
							),
							(hasSingleDropdown || hasDateDropdown || hasTimeDropdown || hasAddresCountry || hasNamePrefix) && _react2.default.createElement(
								_react2.default.Fragment,
								null,
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Select')
									}),
									_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
										prefix: 'cform-select',
										defaultSize: '16',
										defaultFont: 'custom',
										defaultCustom: 'inherit',
										defaultWeight: '400'
									}))
								),
								_react2.default.createElement(
									_accordion2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Dropdown')
									}),
									_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
										prefix: 'cform-dropdown',
										defaultSize: '16',
										defaultFont: 'custom',
										defaultCustom: 'inherit',
										defaultWeight: '400'
									}))
								)
							),
							hasDatePicker && _react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Calendar')
								}),
								_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
									prefix: 'cform-calendar',
									defaultFont: 'custom',
									defaultCustom: 'inherit',
									familyOnly: true
								}))
							),
							hasMultiSelect && _react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Multi Select')
								}),
								_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
									prefix: 'cform-multiselect',
									defaultSize: '16',
									defaultFont: 'custom',
									defaultCustom: 'inherit',
									defaultWeight: '400'
								}))
							),
							hasSingleUpload && _react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Single File Upload')
								}),
								_react2.default.createElement(
									_tabs2.default,
									_extends({}, this.props, {
										type: 'tabs',
										'default': 'upload-single-button',
										extraClass: 'sui-tabs-flushed'
									}),
									_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
										value: 'upload-single-button',
										label: (0, _utils.translate)('Upload Button'),
										prefix: 'upload-single-button',
										defaultSize: '14',
										defaultFont: 'custom',
										defaultCustom: 'inherit',
										defaultWeight: '700'
									})),
									_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
										value: 'upload-single-text',
										label: (0, _utils.translate)('File Name'),
										prefix: 'upload-single-text',
										defaultSize: '12',
										defaultFont: 'custom',
										defaultCustom: 'inherit',
										defaultWeight: '700'
									}))
								)
							),
							hasMultiUpload && _react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Multiple Files Upload')
								}),
								_react2.default.createElement(
									_tabs2.default,
									_extends({}, this.props, {
										type: 'tabs',
										'default': 'upload-multiple-panel',
										extraClass: 'sui-tabs-flushed'
									}),
									_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
										value: 'upload-multiple-panel',
										label: (0, _utils.translate)('Upload Panel'),
										prefix: 'upload-multiple-panel',
										defaultSize: '13',
										defaultFont: 'custom',
										defaultCustom: 'inherit',
										defaultWeight: '400'
									})),
									_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
										value: 'upload-multiple-file-name',
										label: (0, _utils.translate)('File Name'),
										prefix: 'upload-multiple-file-name',
										defaultSize: '13',
										defaultFont: 'custom',
										defaultCustom: 'inherit',
										defaultWeight: '500'
									})),
									_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
										value: 'upload-multiple-file-size',
										label: (0, _utils.translate)('File Size'),
										prefix: 'upload-multiple-file-size',
										defaultSize: '12',
										defaultFont: 'custom',
										defaultCustom: 'inherit',
										defaultWeight: '500'
									}))
								)
							),
							hasESign && _react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('E-Signature Placeholder')
								}),
								_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
									prefix: 'cform-esign-placeholder',
									defaultSize: '16',
									defaultFont: 'custom',
									defaultCustom: 'inherit',
									defaultWeight: '400'
								}))
							),
							hasGroup && _react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Repeater Button')
								}),
								_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
									prefix: 'cform-repeater-button',
									defaultSize: '12',
									defaultFont: 'Roboto',
									defaultWeight: '500'
								}))
							),
							hasPagination && _react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Pagination Buttons')
								}),
								_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
									prefix: 'cform-pagination-buttons',
									defaultSize: '14',
									defaultFont: 'custom',
									defaultCustom: 'inherit',
									defaultWeight: '500'
								}))
							),
							_react2.default.createElement(
								_accordion2.default,
								_extends({}, this.props, {
									label: (0, _utils.translate)('Submit Button')
								}),
								_react2.default.createElement(_fonts2.default, _extends({}, this.props, {
									prefix: 'cform-button',
									defaultSize: '14',
									defaultFont: 'custom',
									defaultCustom: 'inherit',
									defaultWeight: '500'
								}))
							)
						)
					)
				)
			);
		}
	}]);

	return Fonts;
}(_react.Component);

exports.default = Fonts;

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _row = __webpack_require__(8);

var _row2 = _interopRequireDefault(_row);

var _col = __webpack_require__(5);

var _col2 = _interopRequireDefault(_col);

var _input = __webpack_require__(3);

var _input2 = _interopRequireDefault(_input);

var _suiSelect = __webpack_require__(17);

var _suiSelect2 = _interopRequireDefault(_suiSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SuFontSettingsiSelect = function (_Component) {
	_inherits(SuFontSettingsiSelect, _Component);

	function SuFontSettingsiSelect(props) {
		_classCallCheck(this, SuFontSettingsiSelect);

		return _possibleConstructorReturn(this, (SuFontSettingsiSelect.__proto__ || Object.getPrototypeOf(SuFontSettingsiSelect)).call(this, props));
	}

	_createClass(SuFontSettingsiSelect, [{
		key: 'backwardsCompat',
		value: function backwardsCompat(variant, variants) {
			if (!_.contains(variants, variant)) {
				variants.push(variant);
			}

			return variants;
		}
	}, {
		key: 'render',
		value: function render() {
			var prefixTheme = (0, _utils.getThemePrefix)(this.props);
			var prefix = prefixTheme + this.props.prefix;

			var defaultFont = 'basic-' === prefixTheme ? '' : this.props.defaultFont;
			var font = !_.isUndefined(this.props.settings[prefix + '-font-family']) ? this.props.settings[prefix + '-font-family'] : defaultFont;

			var fcus = !_.isUndefined(this.props.settings[prefix + '-custom-family']) ? this.props.settings[prefix + '-custom-family'] : this.props.defaultCustom;

			var defaultWeight = 'basic-' === prefixTheme ? '' : this.props.defaultWeight;
			var variant = !_.isUndefined(this.props.settings[prefix + '-font-weight']) ? this.props.settings[prefix + '-font-weight'] : defaultWeight;

			var defaultSize = 'basic-' === prefixTheme ? '' : this.props.defaultSize;
			var size = !_.isUndefined(this.props.settings[prefix + '-font-size']) ? this.props.settings[prefix + '-font-size'] : defaultSize;

			var fontVariants = (0, _utils.getFontVariants)(font, window.forminatorFonts);

			var variants = this.backwardsCompat(variant, fontVariants);

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					_row2.default,
					null,
					_react2.default.createElement(
						_col2.default,
						{ cols: '12' },
						_react2.default.createElement(
							_suiSelect2.default,
							_extends({}, this.props, {
								label: (0, _utils.translate)('Font Family'),
								placeholder: (0, _utils.translate)('Roboto'),
								property: prefix + '-font-family',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, font)
							}),
							_.map(window.forminatorFonts, function (fontData) {
								return _react2.default.createElement(
									'option',
									{
										value: fontData.family,
										key: fontData.family
									},
									fontData.family
								);
							}),
							_react2.default.createElement(
								'option',
								{
									value: '',
									key: 'inherit'
								},
								(0, _utils.translate)('inherit')
							),
							_react2.default.createElement(
								'option',
								{
									value: 'custom',
									key: 'custom'
								},
								(0, _utils.translate)('Custom user font')
							)
						),
						font === 'custom' && _react2.default.createElement(_input2.default, _extends({}, this.props, {
							type: 'text',
							property: prefix + '-custom-family',
							defaultValue: '' + (0, _utils.getDefaultValue)(this.props, fcus),
							placeholder: (0, _utils.translate)('E.g., Arial, sans-serif'),
							label: (0, _utils.translate)('Custom font family'),
							prefix: ''
						}))
					)
				),
				!this.props.familyOnly && _react2.default.createElement(
					_row2.default,
					null,
					_react2.default.createElement(
						_col2.default,
						{ cols: '6' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							type: 'number',
							property: prefix + '-font-size',
							defaultValue: '' + (0, _utils.getDefaultValue)(this.props, size),
							placeholder: (0, _utils.translate)('E.g., 16'),
							label: (0, _utils.translate)('Font Size'),
							note: 'in px',
							prefix: ''
						}))
					),
					_react2.default.createElement(
						_col2.default,
						{ cols: '6' },
						_react2.default.createElement(
							_suiSelect2.default,
							_extends({}, this.props, {
								label: (0, _utils.translate)('Font Weight'),
								placeholder: (0, _utils.translate)('Select font weight'),
								property: prefix + '-font-weight',
								defaultValue: '' + (0, _utils.getDefaultValue)(this.props, variant)
							}),
							_react2.default.createElement(
								'option',
								{
									value: '',
									key: 'inherit'
								},
								(0, _utils.translate)('inherit')
							),
							_.map(variants, function (fontVariant) {
								return _react2.default.createElement(
									'option',
									{
										value: fontVariant,
										key: fontVariant
									},
									fontVariant
								);
							})
						)
					)
				)
			);
		}
	}]);

	return SuFontSettingsiSelect;
}(_react.Component);

exports.default = SuFontSettingsiSelect;

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _empty = __webpack_require__(12);

var _empty2 = _interopRequireDefault(_empty);

var _paddingCustom = __webpack_require__(291);

var _paddingCustom2 = _interopRequireDefault(_paddingCustom);

var _borderCustom = __webpack_require__(292);

var _borderCustom2 = _interopRequireDefault(_borderCustom);

var _spacingCustom = __webpack_require__(293);

var _spacingCustom2 = _interopRequireDefault(_spacingCustom);

var _radioTabs = __webpack_require__(7);

var _radioTabs2 = _interopRequireDefault(_radioTabs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FormContainer = function (_Component) {
	_inherits(FormContainer, _Component);

	function FormContainer() {
		_classCallCheck(this, FormContainer);

		return _possibleConstructorReturn(this, (FormContainer.__proto__ || Object.getPrototypeOf(FormContainer)).apply(this, arguments));
	}

	_createClass(FormContainer, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Form Container')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)("Customize the form container's padding and border.")
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(
						_radioTabs2.default,
						_extends({}, this.props, {
							property: 'form-padding',
							settingsLabel: (0, _utils.translate)('Padding'),
							description: (0, _utils.translate)('By default the form will fill the available ' + 'space where you insert it. You can add some ' + 'padding here to better suit your theme.') }),
						_react2.default.createElement(
							_empty2.default,
							{ value: '' },
							(0, _utils.translate)('None')
						),
						_react2.default.createElement(
							_paddingCustom2.default,
							_extends({}, this.props, {
								value: 'custom',
								boxClass: 'sui-tab-boxed' }),
							(0, _utils.translate)('Custom')
						)
					),
					_react2.default.createElement(
						_radioTabs2.default,
						_extends({}, this.props, {
							property: 'form-border',
							settingsLabel: (0, _utils.translate)('Border'),
							description: (0, _utils.translate)('Add an optional border around the form.') }),
						_react2.default.createElement(
							_empty2.default,
							{ value: '' },
							(0, _utils.translate)('None')
						),
						_react2.default.createElement(
							_borderCustom2.default,
							_extends({}, this.props, {
								value: 'custom',
								boxClass: 'sui-tab-boxed' }),
							(0, _utils.translate)('Custom')
						)
					),
					_react2.default.createElement(
						_radioTabs2.default,
						_extends({}, this.props, {
							property: 'fields-style',
							settingsLabel: (0, _utils.translate)('Spacing'),
							'default': 'open',
							description: (0, _utils.translate)('Choose how much spacing you want between each form field.') }),
						_react2.default.createElement(
							_empty2.default,
							{ value: 'open' },
							(0, _utils.translate)('Comfortable')
						),
						_react2.default.createElement(
							_empty2.default,
							{ value: 'enclosed' },
							(0, _utils.translate)('Compact')
						),
						_react2.default.createElement(
							_spacingCustom2.default,
							_extends({}, this.props, {
								value: 'custom',
								boxClass: 'sui-tab-boxed'
							}),
							(0, _utils.translate)('Custom')
						)
					)
				)
			);
		}
	}]);

	return FormContainer;
}(_react.Component);

exports.default = FormContainer;

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _col = __webpack_require__(5);

var _col2 = _interopRequireDefault(_col);

var _input = __webpack_require__(3);

var _input2 = _interopRequireDefault(_input);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var paddingCustom = function (_Component) {
	_inherits(paddingCustom, _Component);

	function paddingCustom(props) {
		_classCallCheck(this, paddingCustom);

		return _possibleConstructorReturn(this, (paddingCustom.__proto__ || Object.getPrototypeOf(paddingCustom)).call(this, props));
	}

	_createClass(paddingCustom, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'div',
					{ className: 'sui-row',
						style: { marginBottom: '10px' } },
					_react2.default.createElement(
						_col2.default,
						{ cols: '3' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Top'),
							type: 'number',
							placeholder: '0',
							property: 'form-padding-top'
						}))
					),
					_react2.default.createElement(
						_col2.default,
						{ cols: '3' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Bottom'),
							type: 'number',
							placeholder: '0',
							property: 'form-padding-bottom'
						}))
					),
					_react2.default.createElement(
						_col2.default,
						{ cols: '3' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Left'),
							type: 'number',
							placeholder: '0',
							property: 'form-padding-left'
						}))
					),
					_react2.default.createElement(
						_col2.default,
						{ cols: '3' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Right'),
							type: 'number',
							placeholder: '0',
							property: 'form-padding-right'
						}))
					)
				),
				_react2.default.createElement(
					'span',
					{ className: 'sui-description' },
					(0, _utils.translate)('Set your custom padding in pixels.')
				)
			);
		}
	}]);

	return paddingCustom;
}(_react.Component);

exports.default = paddingCustom;

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _row = __webpack_require__(8);

var _row2 = _interopRequireDefault(_row);

var _col = __webpack_require__(5);

var _col2 = _interopRequireDefault(_col);

var _input = __webpack_require__(3);

var _input2 = _interopRequireDefault(_input);

var _suiSelect = __webpack_require__(17);

var _suiSelect2 = _interopRequireDefault(_suiSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var borderCustom = function (_Component) {
	_inherits(borderCustom, _Component);

	function borderCustom(props) {
		_classCallCheck(this, borderCustom);

		return _possibleConstructorReturn(this, (borderCustom.__proto__ || Object.getPrototypeOf(borderCustom)).call(this, props));
	}

	_createClass(borderCustom, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'div',
					{ className: 'sui-row',
						style: { marginBottom: '10px' } },
					_react2.default.createElement(
						_col2.default,
						{ cols: '4' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Radius'),
							note: (0, _utils.translate)('in px'),
							type: 'number',
							placeholder: '0',
							property: 'form-border-radius'
						}))
					),
					_react2.default.createElement(
						_col2.default,
						{ cols: '4' },
						_react2.default.createElement(_input2.default, _extends({}, this.props, {
							label: (0, _utils.translate)('Thickness'),
							note: (0, _utils.translate)('in px'),
							type: 'number',
							placeholder: '0',
							property: 'form-border-width'
						}))
					),
					_react2.default.createElement(
						_col2.default,
						{ cols: '4' },
						_react2.default.createElement(
							_suiSelect2.default,
							_extends({}, this.props, {
								property: 'form-border-style',
								label: (0, _utils.translate)('Style')
							}),
							_react2.default.createElement(
								'option',
								{ value: 'solid' },
								(0, _utils.translate)('Solid')
							),
							_react2.default.createElement(
								'option',
								{ value: 'dashed' },
								(0, _utils.translate)('Dashed')
							),
							_react2.default.createElement(
								'option',
								{ value: 'dotted' },
								(0, _utils.translate)('Dotted')
							),
							_react2.default.createElement(
								'option',
								{ value: 'none' },
								(0, _utils.translate)('None')
							)
						)
					)
				),
				_react2.default.createElement(
					'span',
					{ className: 'sui-description' },
					(0, _utils.translate)('Note: Set the color of the border in the Colors settings area above.')
				)
			);
		}
	}]);

	return borderCustom;
}(_react.Component);

exports.default = borderCustom;

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _input = __webpack_require__(3);

var _input2 = _interopRequireDefault(_input);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var spacingCustom = function (_Component) {
	_inherits(spacingCustom, _Component);

	function spacingCustom(props) {
		_classCallCheck(this, spacingCustom);

		return _possibleConstructorReturn(this, (spacingCustom.__proto__ || Object.getPrototypeOf(spacingCustom)).call(this, props));
	}

	_createClass(spacingCustom, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(_input2.default, _extends({}, this.props, {
				label: (0, _utils.translate)('Spacing'),
				note: (0, _utils.translate)('in pixels'),
				type: 'number',
				placeholder: (0, _utils.translate)('0'),
				property: (0, _utils.getThemePrefix)(this.props) + 'spacing'
			}));
		}
	}]);

	return spacingCustom;
}(_react.Component);

exports.default = spacingCustom;

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _toggle = __webpack_require__(25);

var _toggle2 = _interopRequireDefault(_toggle);

var _aceEditor = __webpack_require__(183);

var _aceEditor2 = _interopRequireDefault(_aceEditor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CustomCss = function (_Component) {
	_inherits(CustomCss, _Component);

	function CustomCss(props) {
		_classCallCheck(this, CustomCss);

		return _possibleConstructorReturn(this, (CustomCss.__proto__ || Object.getPrototypeOf(CustomCss)).call(this, props));
	}

	_createClass(CustomCss, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-settings-row' },
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-1' },
					_react2.default.createElement(
						'span',
						{ className: 'sui-settings-label' },
						(0, _utils.translate)('Custom CSS')
					),
					_react2.default.createElement(
						'span',
						{ className: 'sui-description' },
						(0, _utils.translate)('For more advanced customization options use custom CSS.')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-col-2' },
					_react2.default.createElement(
						'div',
						{ className: 'sui-form-field' },
						_react2.default.createElement(
							'div',
							{ style: { marginBottom: '10px' } },
							_react2.default.createElement(_toggle2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Enable custom CSS'),
								property: 'use-custom-css',
								unWrap: true
							}))
						),
						!_.isUndefined(this.props.settings['use-custom-css']) && this.props.settings['use-custom-css'] && _react2.default.createElement(_aceEditor2.default, _extends({}, this.props, {
							property: 'custom_css',
							type: 'form'
						}))
					)
				)
			);
		}
	}]);

	return CustomCss;
}(_react.Component);

exports.default = CustomCss;

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _suiSelect = __webpack_require__(17);

var _suiSelect2 = _interopRequireDefault(_suiSelect);

var _toggle = __webpack_require__(25);

var _toggle2 = _interopRequireDefault(_toggle);

var _col = __webpack_require__(5);

var _col2 = _interopRequireDefault(_col);

var _input = __webpack_require__(3);

var _input2 = _interopRequireDefault(_input);

var _pageMargin = __webpack_require__(296);

var _pageMargin2 = _interopRequireDefault(_pageMargin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PageSettings = function (_Component) {
	_inherits(PageSettings, _Component);

	function PageSettings(props) {
		_classCallCheck(this, PageSettings);

		return _possibleConstructorReturn(this, (PageSettings.__proto__ || Object.getPrototypeOf(PageSettings)).call(this, props));
	}

	_createClass(PageSettings, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'div',
					{
						role: 'alert',
						className: 'sui-notice sui-notice-blue sui-active',
						'aria-live': 'assertive',
						style: { display: 'block' }
					},
					_react2.default.createElement(
						'div',
						{ className: 'sui-notice-content' },
						_react2.default.createElement(
							'div',
							{ className: 'sui-notice-message' },
							_react2.default.createElement('span', { className: 'sui-notice-icon sui-icon-info', 'aria-hidden': 'true' }),
							_react2.default.createElement(
								'p',
								null,
								(0, _utils.translate)('Our PDF builder is constantly improving and we’ll be adding more features over time. ' + 'While the current release has limited customization options, ' + 'we appreciate your patience as we work to bring you the best experience possible. ' + 'Keep an eye out for updates. To manually adjust the appearance of the fields, ' + 'you can enable the Custom CSS option below.')
							)
						)
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-settings-row' },
					_react2.default.createElement(
						'div',
						{ className: 'sui-box-settings-col-1' },
						_react2.default.createElement(
							'span',
							{ className: 'sui-settings-label' },
							(0, _utils.translate)('Page settings')
						),
						_react2.default.createElement(
							'span',
							{ className: 'sui-description' },
							(0, _utils.translate)('Configure the PDF file settings')
						)
					),
					_react2.default.createElement(
						'div',
						{ className: 'sui-box-settings-col-2' },
						_react2.default.createElement(
							'label',
							{ className: 'sui-settings-label' },
							(0, _utils.translate)('Page size')
						),
						_react2.default.createElement(
							'span',
							{ className: 'sui-description', style: { marginBottom: '10px' } },
							(0, _utils.translate)('Choose the standard paper size for your PDF document. ' + 'The default resolution for each page is set at 96dpi.')
						),
						_react2.default.createElement(
							_suiSelect2.default,
							_extends({}, this.props, {
								property: 'paper_size',
								defaultValue: 'A4'
							}),
							_.map(forminatorData.pdf_page_sizes, function (size, key) {
								return _react2.default.createElement(
									'option',
									{ key: key, value: key },
									size
								);
							})
						),
						_react2.default.createElement(
							'div',
							{ className: 'sui-form-field' },
							_react2.default.createElement(_toggle2.default, _extends({}, this.props, {
								label: (0, _utils.translate)('Enable RTL (right-to-left)'),
								property: 'enable_rtl',
								unWrap: true
							}))
						),
						_react2.default.createElement('hr', null),
						_react2.default.createElement(_pageMargin2.default, this.props)
					)
				)
			);
		}
	}]);

	return PageSettings;
}(_react.Component);

exports.default = PageSettings;

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _col = __webpack_require__(5);

var _col2 = _interopRequireDefault(_col);

var _input = __webpack_require__(3);

var _input2 = _interopRequireDefault(_input);

var _radioTabs = __webpack_require__(7);

var _radioTabs2 = _interopRequireDefault(_radioTabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _suiSelect = __webpack_require__(17);

var _suiSelect2 = _interopRequireDefault(_suiSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var pageMargin = function (_Component) {
	_inherits(pageMargin, _Component);

	function pageMargin(props) {
		_classCallCheck(this, pageMargin);

		return _possibleConstructorReturn(this, (pageMargin.__proto__ || Object.getPrototypeOf(pageMargin)).call(this, props));
	}

	_createClass(pageMargin, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				_radioTabs2.default,
				_extends({}, this.props, {
					property: 'pdf_margin',
					divClass: 'pdf-page-margin',
					settingsLabel: (0, _utils.translate)('Page Margin'),
					'default': 'default',
					description: (0, _utils.translate)('Default margin for all paper sizes is 30px. ' + 'Use the custom tab to set a different value.')
				}),
				_react2.default.createElement(_container2.default, { value: 'default', label: (0, _utils.translate)('Default') }),
				_react2.default.createElement(
					_container2.default,
					{
						value: 'custom',
						label: (0, _utils.translate)('Custom')
					},
					_react2.default.createElement(
						'div',
						{ className: 'sui-border-frame' },
						_react2.default.createElement(
							'div',
							{ className: 'sui-row',
								style: { marginBottom: '10px' } },
							_react2.default.createElement(
								_col2.default,
								{ cols: '12' },
								_react2.default.createElement(
									_suiSelect2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Margin'),
										property: 'pdf_margin_unit',
										fieldClass: 'fui-select-inline',
										fieldsize: '100'
									}),
									_react2.default.createElement(
										'option',
										{ value: 'pt' },
										'pt'
									),
									_react2.default.createElement(
										'option',
										{ value: 'px' },
										'px'
									),
									_react2.default.createElement(
										'option',
										{ value: 'mm' },
										'mm'
									),
									_react2.default.createElement(
										'option',
										{ value: 'in' },
										'in'
									)
								)
							),
							_react2.default.createElement(
								_col2.default,
								{ cols: '3' },
								_react2.default.createElement(_input2.default, _extends({}, this.props, {
									label: (0, _utils.translate)('Top'),
									type: 'number',
									placeholder: '0',
									property: 'pdf_margin_top'
								}))
							),
							_react2.default.createElement(
								_col2.default,
								{ cols: '3' },
								_react2.default.createElement(_input2.default, _extends({}, this.props, {
									label: (0, _utils.translate)('Bottom'),
									type: 'number',
									placeholder: '0',
									property: 'pdf_margin_bottom'
								}))
							),
							_react2.default.createElement(
								_col2.default,
								{ cols: '3' },
								_react2.default.createElement(_input2.default, _extends({}, this.props, {
									label: (0, _utils.translate)('Left'),
									type: 'number',
									placeholder: '0',
									property: 'pdf_margin_left'
								}))
							),
							_react2.default.createElement(
								_col2.default,
								{ cols: '3' },
								_react2.default.createElement(_input2.default, _extends({}, this.props, {
									label: (0, _utils.translate)('Right'),
									type: 'number',
									placeholder: '0',
									property: 'pdf_margin_right'
								}))
							)
						)
					)
				)
			);
		}
	}]);

	return pageMargin;
}(_react.Component);

exports.default = pageMargin;

/***/ }),
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SuiTags = function (_Component) {
	_inherits(SuiTags, _Component);

	function SuiTags(props) {
		_classCallCheck(this, SuiTags);

		var _this = _possibleConstructorReturn(this, (SuiTags.__proto__ || Object.getPrototypeOf(SuiTags)).call(this, props));

		_this.handleChange = _this.handleChange.bind(_this);
		return _this;
	}

	_createClass(SuiTags, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var self = this;
			var value = _.isUndefined(this.props.settings[this.props.property]) ? [] : this.props.settings[this.props.property];

			this.$el = jQuery(this.el);
			var options = Object.assign({ allowClear: true, dropdownCssClass: 'sui-select-dropdown' }, this.props.options);

			if (typeof this.$el.SUIselect2 === 'function') {
				this.$el.SUIselect2(options);
			} else if (typeof this.$el.FUIselect2 === 'function') {
				this.$el.FUIselect2(options);
			} else {
				console.log('select2 not intiated');
			}

			this.$el.on('change.select2', this.handleChange);

			if (!_.isUndefined(this.props.settings.permission_type) && ('specific' === this.props.settings.permission_type || !_.isUndefined(this.props.settings.user_info))) {
				var userInfos = this.props.settings.user_info;

				// initial values append
				_.each(value, function (option) {
					if (!_.isUndefined(userInfos[option])) {
						self.$el.append(jQuery('<option value="' + option + '">' + userInfos[option].email + '</option>'));
					}
				});
			} else {

				// initial values append
				_.each(value, function (option) {
					self.$el.append(jQuery('<option value="' + option + '">' + option + '</option>'));
				});
			}

			// initial values on mount
			this.$el.val(value).trigger('change.select2');
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps, prevState) {
			if (!_.isUndefined(this.props.settings.user_role) && prevProps.settings.user_role !== this.props.settings.user_role) {
				this.$el.val([]).trigger('change.select2');
			}
		}
	}, {
		key: 'handleChange',
		value: function handleChange(e) {
			var value = jQuery(e.target).val();

			// Check if we're on field settings
			if (typeof this.props.updateProperty === 'function') {
				// Update field state
				this.props.updateProperty(this.props.property, value);
			} else {
				// Update store
				this.props.actions.settingsActions.updateSetting(this.props.property, value);
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.$el.off('change', this.handleChange);
			this.$el.unbind().removeData();
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var value = _.isUndefined(this.props.settings[this.props.property]) ? [] : this.props.settings[this.props.property];

			var fieldLabel = '';

			if (this.props.label) {
				fieldLabel = _react2.default.createElement(
					'label',
					{ htmlFor: 'forminator-field-' + this.props.property, className: 'sui-label' },
					this.props.label,
					this.props.note && _react2.default.createElement(
						'span',
						{ className: 'sui-label-note' },
						this.props.note
					)
				);
			}

			return _react2.default.createElement(
				'div',
				{ className: 'sui-form-field', style: this.props.style },
				fieldLabel,
				_react2.default.createElement(
					'select',
					{
						ref: function ref(el) {
							return _this2.el = el;
						},
						className: 'sui-select',
						defaultValue: value,
						multiple: 'multiple'
					},
					this.props.children
				)
			);
		}
	}]);

	return SuiTags;
}(_react.Component);

exports.default = SuiTags;

/***/ }),
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */,
/* 389 */,
/* 390 */,
/* 391 */,
/* 392 */,
/* 393 */,
/* 394 */,
/* 395 */,
/* 396 */,
/* 397 */,
/* 398 */,
/* 399 */,
/* 400 */,
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var showModal = exports.showModal = function showModal(modalProps, modalType) {
	return function (dispatch) {
		dispatch({
			type: 'SHOW_MODAL',
			modalProps: modalProps,
			modalType: modalType
		});
	};
};

var hideModal = exports.hideModal = function hideModal() {
	return function (dispatch) {
		dispatch({
			type: 'HIDE_MODAL'
		});
	};
};

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var updatePermissions = exports.updatePermissions = function updatePermissions(permissions) {
	return function (dispatch) {
		dispatch({
			type: 'UPDATE_PERMISSIONS',
			permissions: permissions
		});
	};
};

/***/ }),
/* 403 */,
/* 404 */,
/* 405 */,
/* 406 */,
/* 407 */,
/* 408 */,
/* 409 */,
/* 410 */,
/* 411 */,
/* 412 */,
/* 413 */,
/* 414 */,
/* 415 */,
/* 416 */,
/* 417 */,
/* 418 */,
/* 419 */,
/* 420 */,
/* 421 */,
/* 422 */,
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */,
/* 428 */,
/* 429 */,
/* 430 */,
/* 431 */,
/* 432 */,
/* 433 */,
/* 434 */,
/* 435 */,
/* 436 */,
/* 437 */,
/* 438 */,
/* 439 */,
/* 440 */,
/* 441 */,
/* 442 */,
/* 443 */,
/* 444 */,
/* 445 */,
/* 446 */,
/* 447 */,
/* 448 */,
/* 449 */,
/* 450 */,
/* 451 */,
/* 452 */,
/* 453 */,
/* 454 */,
/* 455 */,
/* 456 */,
/* 457 */,
/* 458 */,
/* 459 */,
/* 460 */,
/* 461 */,
/* 462 */,
/* 463 */,
/* 464 */,
/* 465 */,
/* 466 */,
/* 467 */,
/* 468 */,
/* 469 */,
/* 470 */,
/* 471 */,
/* 472 */,
/* 473 */,
/* 474 */,
/* 475 */,
/* 476 */,
/* 477 */,
/* 478 */,
/* 479 */,
/* 480 */,
/* 481 */,
/* 482 */,
/* 483 */,
/* 484 */,
/* 485 */,
/* 486 */,
/* 487 */,
/* 488 */,
/* 489 */,
/* 490 */,
/* 491 */,
/* 492 */,
/* 493 */,
/* 494 */,
/* 495 */,
/* 496 */,
/* 497 */,
/* 498 */,
/* 499 */,
/* 500 */,
/* 501 */,
/* 502 */,
/* 503 */,
/* 504 */,
/* 505 */,
/* 506 */,
/* 507 */,
/* 508 */,
/* 509 */,
/* 510 */,
/* 511 */,
/* 512 */,
/* 513 */,
/* 514 */,
/* 515 */,
/* 516 */,
/* 517 */,
/* 518 */,
/* 519 */,
/* 520 */,
/* 521 */,
/* 522 */,
/* 523 */,
/* 524 */,
/* 525 */,
/* 526 */,
/* 527 */,
/* 528 */,
/* 529 */,
/* 530 */,
/* 531 */,
/* 532 */,
/* 533 */,
/* 534 */,
/* 535 */,
/* 536 */,
/* 537 */,
/* 538 */,
/* 539 */,
/* 540 */,
/* 541 */,
/* 542 */,
/* 543 */,
/* 544 */,
/* 545 */,
/* 546 */,
/* 547 */,
/* 548 */,
/* 549 */,
/* 550 */,
/* 551 */,
/* 552 */,
/* 553 */,
/* 554 */,
/* 555 */,
/* 556 */,
/* 557 */,
/* 558 */,
/* 559 */,
/* 560 */,
/* 561 */,
/* 562 */,
/* 563 */,
/* 564 */,
/* 565 */,
/* 566 */,
/* 567 */,
/* 568 */,
/* 569 */,
/* 570 */,
/* 571 */,
/* 572 */,
/* 573 */,
/* 574 */,
/* 575 */,
/* 576 */,
/* 577 */,
/* 578 */,
/* 579 */,
/* 580 */,
/* 581 */,
/* 582 */,
/* 583 */,
/* 584 */,
/* 585 */,
/* 586 */,
/* 587 */,
/* 588 */,
/* 589 */,
/* 590 */,
/* 591 */,
/* 592 */,
/* 593 */,
/* 594 */,
/* 595 */,
/* 596 */,
/* 597 */,
/* 598 */,
/* 599 */,
/* 600 */,
/* 601 */,
/* 602 */,
/* 603 */,
/* 604 */,
/* 605 */,
/* 606 */,
/* 607 */,
/* 608 */,
/* 609 */,
/* 610 */,
/* 611 */,
/* 612 */,
/* 613 */,
/* 614 */,
/* 615 */,
/* 616 */,
/* 617 */,
/* 618 */,
/* 619 */,
/* 620 */,
/* 621 */,
/* 622 */,
/* 623 */,
/* 624 */,
/* 625 */,
/* 626 */,
/* 627 */,
/* 628 */,
/* 629 */,
/* 630 */,
/* 631 */,
/* 632 */,
/* 633 */,
/* 634 */,
/* 635 */,
/* 636 */,
/* 637 */,
/* 638 */,
/* 639 */,
/* 640 */,
/* 641 */,
/* 642 */,
/* 643 */,
/* 644 */,
/* 645 */,
/* 646 */,
/* 647 */,
/* 648 */,
/* 649 */,
/* 650 */,
/* 651 */,
/* 652 */,
/* 653 */,
/* 654 */,
/* 655 */,
/* 656 */,
/* 657 */,
/* 658 */,
/* 659 */,
/* 660 */,
/* 661 */,
/* 662 */,
/* 663 */,
/* 664 */,
/* 665 */,
/* 666 */,
/* 667 */,
/* 668 */,
/* 669 */,
/* 670 */,
/* 671 */,
/* 672 */,
/* 673 */,
/* 674 */,
/* 675 */,
/* 676 */,
/* 677 */,
/* 678 */,
/* 679 */,
/* 680 */,
/* 681 */,
/* 682 */,
/* 683 */,
/* 684 */,
/* 685 */,
/* 686 */,
/* 687 */,
/* 688 */,
/* 689 */,
/* 690 */,
/* 691 */,
/* 692 */,
/* 693 */,
/* 694 */,
/* 695 */,
/* 696 */,
/* 697 */,
/* 698 */,
/* 699 */,
/* 700 */,
/* 701 */,
/* 702 */,
/* 703 */,
/* 704 */,
/* 705 */,
/* 706 */,
/* 707 */,
/* 708 */,
/* 709 */,
/* 710 */,
/* 711 */,
/* 712 */,
/* 713 */,
/* 714 */,
/* 715 */,
/* 716 */,
/* 717 */,
/* 718 */,
/* 719 */,
/* 720 */,
/* 721 */,
/* 722 */,
/* 723 */,
/* 724 */,
/* 725 */,
/* 726 */,
/* 727 */,
/* 728 */,
/* 729 */,
/* 730 */,
/* 731 */,
/* 732 */,
/* 733 */,
/* 734 */,
/* 735 */,
/* 736 */,
/* 737 */,
/* 738 */,
/* 739 */,
/* 740 */,
/* 741 */,
/* 742 */,
/* 743 */,
/* 744 */,
/* 745 */,
/* 746 */,
/* 747 */,
/* 748 */,
/* 749 */,
/* 750 */,
/* 751 */,
/* 752 */,
/* 753 */,
/* 754 */,
/* 755 */,
/* 756 */,
/* 757 */,
/* 758 */,
/* 759 */,
/* 760 */,
/* 761 */,
/* 762 */,
/* 763 */,
/* 764 */,
/* 765 */,
/* 766 */,
/* 767 */,
/* 768 */,
/* 769 */,
/* 770 */,
/* 771 */,
/* 772 */,
/* 773 */,
/* 774 */,
/* 775 */,
/* 776 */,
/* 777 */,
/* 778 */,
/* 779 */,
/* 780 */,
/* 781 */,
/* 782 */,
/* 783 */,
/* 784 */,
/* 785 */,
/* 786 */,
/* 787 */,
/* 788 */,
/* 789 */,
/* 790 */,
/* 791 */,
/* 792 */,
/* 793 */,
/* 794 */,
/* 795 */,
/* 796 */,
/* 797 */,
/* 798 */,
/* 799 */,
/* 800 */,
/* 801 */,
/* 802 */,
/* 803 */,
/* 804 */,
/* 805 */,
/* 806 */,
/* 807 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(808);

__webpack_require__(809);

/***/ }),
/* 808 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /* jshint esversion: 6 */


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _renderBlock = __webpack_require__(89);

var _configureStore = __webpack_require__(222);

var _configureStore2 = _interopRequireDefault(_configureStore);

var _i18nWpPlugin = __webpack_require__(52);

var _i18nWpPlugin2 = _interopRequireDefault(_i18nWpPlugin);

var _axios = __webpack_require__(39);

var _axios2 = _interopRequireDefault(_axios);

var _qs = __webpack_require__(40);

var _qs2 = _interopRequireDefault(_qs);

var _reactRedux = __webpack_require__(13);

var _redux = __webpack_require__(11);

var _settings = __webpack_require__(109);

var settingsActions = _interopRequireWildcard(_settings);

var _utils = __webpack_require__(1);

var _design = __webpack_require__(251);

var _design2 = _interopRequireDefault(_design);

var _colors = __webpack_require__(258);

var _colors2 = _interopRequireDefault(_colors);

var _fonts = __webpack_require__(288);

var _fonts2 = _interopRequireDefault(_fonts);

var _formContainer = __webpack_require__(290);

var _formContainer2 = _interopRequireDefault(_formContainer);

var _customCss = __webpack_require__(294);

var _customCss2 = _interopRequireDefault(_customCss);

var _notifications = __webpack_require__(30);

var _notifications2 = _interopRequireDefault(_notifications);

var _pageSettings = __webpack_require__(295);

var _pageSettings2 = _interopRequireDefault(_pageSettings);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var presetId = jQuery('select[name="appearance_preset"]').val();
var currentPreset = !_.isUndefined(forminatorData.currentPreset) ? forminatorData.currentPreset : [];
var store = (0, _configureStore2.default)(currentPreset);

_i18nWpPlugin2.default.setLocale(forminatorl10n.locale);

// We need our own version of jQuery in case user click Preview with WPEditor enabled
// WPEditor instance breaks window.jQuery object and we should restore on modal close
window.jQueryFormi = jQuery.noConflict();

function mapStateToProps(state) {
	return {
		settings: state.settings,
		wrappers: state.wrappers,
		formDesign: state.settings['form-style'] || 'default'
	};
}

function mapDispatchToProps(dispatch) {
	return {
		actions: {
			settingsActions: (0, _redux.bindActionCreators)(settingsActions, dispatch)
		}
	};
}

function handleBeforeunload(e) {
	if (window.forminatorChanges && window.forminatorChanges.settings === true) {
		e.preventDefault();
		e.returnValue = (0, _utils.translate)('You have unsaved changes, are you sure want to leave this page');
		return (0, _utils.translate)('You have unsaved changes, are you sure want to leave this page');
	}
}

function saveAppearancePreset(props) {
	var $target = jQuery('.forminator-update-appearance-preset');
	$target.addClass('sui-button-onload');

	var object = {
		action: 'forminator_save_appearance_preset',
		_wpnonce: forminatorData.presetNonce,
		presetId: presetId,
		settings: JSON.stringify(props.settings)
	};

	_axios2.default.post(forminatorData.ajaxUrl, _qs2.default.stringify(object)).then(function (data) {
		if (data.data.success) {
			// Update status
			window.forminatorChanges.settings = false;
			props.setHasUpdated(false);

			if (data.data.data) {
				var custom = new _notifications2.default({
					type: 'success',
					text: data.data.data
				});

				custom.open();
			}
		} else {

			var _custom = new _notifications2.default({
				type: 'error',
				text: data.data.data
			});

			_custom.open();
		}
	}).catch(function (err) {
		var custom = new _notifications2.default({
			type: 'error',
			text: (0, _utils.translate)('Something went wrong. Please try again.')
		});

		custom.open();

		console.log(err);
	}).then(function () {
		$target.removeClass('sui-button-onload');
	});
}

function changePreset(e) {
	var presetId = e.currentTarget.value,
	    div_preloader = '<div class="sui-box-body sui-block-content-center" style="height: 420px;display: flex; justify-content: center; flex-direction: column;"><p class="" aria-label="Loading content">' + '<i class="sui-icon-loader sui-loading" aria-hidden="true"></i>' + '<br>' + (0, _utils.translate)('Loading Preset data...') + '</p></div>';

	jQuery('#forminator-appearance-preset').html(div_preloader);

	Forminator.openPreset(presetId);
}

function deletePreset() {
	var $target = jQuery('.popup-confirmation-confirm');
	$target.addClass('sui-button-onload');

	var presetId = jQuery('select[name="appearance_preset"]').val();

	var data = {
		action: 'forminator_delete_appearance_preset',
		_wpnonce: forminatorData.presetNonce,
		preset_id: presetId
	};

	jQuery.ajax({
		url: Forminator.Data.ajaxUrl,
		type: "POST",
		data: data,
		success: function success(result) {
			if (result && result.success) {
				Forminator.openPreset('default', 'preset_deleted');
			} else {
				Forminator.Notification.open('error', result.data, 4000);
				$target.removeClass('sui-button-onload');
			}
		},
		error: function error(_error) {
			Forminator.Notification.open('error', _error.data, 4000);
			$target.removeClass('sui-button-onload');
		}
	});

	return false;
}

function Appearance(props) {
	var _React$useState = _react2.default.useState(!!window.forminatorChanges.settings),
	    _React$useState2 = _slicedToArray(_React$useState, 2),
	    hasUpdated = _React$useState2[0],
	    setHasUpdated = _React$useState2[1];

	function save() {
		saveAppearancePreset(_extends({}, props, { setHasUpdated: setHasUpdated }));
	}

	_react2.default.useEffect(function () {
		setHasUpdated(!!window.forminatorChanges.settings);
	}, [window.forminatorChanges.settings]);

	_react2.default.useEffect(function () {
		window.addEventListener('deletePreset', deletePreset);
		window.jQuery('select[name="appearance_preset"]').off('change').on('change', changePreset);
		window.jQuery('.forminator-update-appearance-preset').off('click').on('click', save);
	}, [props]);

	var fontStyle = !_.isUndefined(props.settings['form-style']) ? props.settings['form-style'] : 'default',
	    title = jQuery('select[name="appearance_preset"] option:selected').first().text();

	return _react2.default.createElement(
		_react2.default.Fragment,
		null,
		_react2.default.createElement(
			'div',
			{ className: 'sui-box-header' },
			_react2.default.createElement(
				'h2',
				{ className: 'sui-box-title' },
				title
			),
			hasUpdated && _react2.default.createElement(
				'span',
				{ className: 'sui-tag' },
				(0, _utils.translate)('Unsaved Changes')
			)
		),
		_react2.default.createElement(
			'div',
			{ className: 'sui-box-body' },
			_react2.default.createElement(_design2.default, props),
			fontStyle !== 'none' && _react2.default.createElement(
				_react2.default.Fragment,
				{ key: (0, _utils.getThemePrefix)(props) + 'themeKey' },
				_react2.default.createElement(_colors2.default, _extends({}, props, { preset: 'true' })),
				_react2.default.createElement(_fonts2.default, _extends({}, props, { preset: 'true' })),
				_react2.default.createElement(_formContainer2.default, props)
			),
			_react2.default.createElement(_customCss2.default, props)
		)
	);
}

var AppearanceContainer = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(Appearance);

window.forminatorChanges = { settings: false };
window.addEventListener('beforeunload', handleBeforeunload);

(0, _renderBlock.renderBlock)('forminator-appearance-preset', _react2.default.createElement(
	_reactRedux.Provider,
	{ store: store },
	_react2.default.createElement(AppearanceContainer, null)
));

/***/ }),
/* 809 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _renderBlock = __webpack_require__(89);

var _reactRedux = __webpack_require__(13);

var _configureStore = __webpack_require__(810);

var _configureStore2 = _interopRequireDefault(_configureStore);

var _i18nWpPlugin = __webpack_require__(52);

var _i18nWpPlugin2 = _interopRequireDefault(_i18nWpPlugin);

var _main = __webpack_require__(814);

var _main2 = _interopRequireDefault(_main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* jshint esversion: 6 */
var store = (0, _configureStore2.default)(forminatorData.mainSettings);
// import { MemoryRouter, Route } from 'react-router-dom';


_i18nWpPlugin2.default.setLocale(forminatorl10n.locale);

window.forminatorChanges = {
	permissions: {}
};

// We need our own version of jQuery in case user click Preview with WPEditor enabled
// WPEditor instance breaks window.jQuery object and we should restore on modal close
window.jQueryFormi = jQuery.noConflict();

// Main.
(0, _renderBlock.renderBlock)('forminator-permissions', _react2.default.createElement(
	_reactRedux.Provider,
	{ store: store },
	_react2.default.createElement(_main2.default, null)
));

/***/ }),
/* 810 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = configureStore;

var _redux = __webpack_require__(11);

var _reduxThunk = __webpack_require__(112);

var _reduxThunk2 = _interopRequireDefault(_reduxThunk);

var _index = __webpack_require__(811);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var newCreateStore = (0, _redux.compose)((0, _redux.applyMiddleware)(_reduxThunk2.default))(_redux.createStore);

function configureStore(initialState) {
	return newCreateStore(_index2.default, initialState);
}

/***/ }),
/* 811 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _redux = __webpack_require__(11);

var _permissions = __webpack_require__(812);

var _permissions2 = _interopRequireDefault(_permissions);

var _modal = __webpack_require__(813);

var _modal2 = _interopRequireDefault(_modal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Import reducers
var appReducers = (0, _redux.combineReducers)({
	// List reducers
	permissions: _permissions2.default,
	modal: _modal2.default
});

exports.default = appReducers;

/***/ }),
/* 812 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = permissions;
function permissions() {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	var action = arguments[1];

	switch (action.type) {
		case 'UPDATE_PERMISSIONS':
			return action.permissions;
		default:
			return state;
	}
}

/***/ }),
/* 813 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var initialState = {
	modalType: null,
	modalProps: {}
};

exports.default = function () {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	var action = arguments[1];

	switch (action.type) {
		case 'SHOW_MODAL':
			return {
				modalProps: action.modalProps,
				modalType: action.modalType,
				type: action.type
			};
		case 'HIDE_MODAL':
			return initialState;
		default:
			return state;
	}
};

/***/ }),
/* 814 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _permissions = __webpack_require__(815);

var _permissions2 = _interopRequireDefault(_permissions);

var _modal = __webpack_require__(822);

var _modal2 = _interopRequireDefault(_modal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Main = function (_Component) {
	_inherits(Main, _Component);

	function Main(props) {
		_classCallCheck(this, Main);

		return _possibleConstructorReturn(this, (Main.__proto__ || Object.getPrototypeOf(Main)).call(this, props));
	}

	_createClass(Main, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.goToSectionFromUrl();

			window.addEventListener('beforeunload', this.handleBeforeunload);
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			window.removeEventListener('beforeunload', this.handleBeforeunload);
		}

		/*
   * If URL has param gotosection, upon page load,
   * the page will go to the specified tab on the gotosection param.
   * Useful when redirecting from another page that is not part of form editor.
  */

	}, {
		key: 'goToSectionFromUrl',
		value: function goToSectionFromUrl() {
			var goToSection = (0, _utils.parseQueryString)().gotosection;

			if (!_.isUndefined(goToSection)) {
				var theUrl = window.location.href;

				this.props.history.push('/' + (0, _utils.parseQueryString)().gotosection);
				window.history.replaceState({}, document.title, theUrl.slice(0, theUrl.indexOf('&gotosection')));
			}
		}
	}, {
		key: 'handleBeforeunload',
		value: function handleBeforeunload(e) {
			if (window.forminatorChanges.length > 0 || window.forminatorChanges.settings === true) {
				e.preventDefault();
				e.returnValue = (0, _utils.translate)('You have unsaved changes, are you sure want to leave this page');
				return (0, _utils.translate)('You have unsaved changes, are you sure want to leave this page');
			}
		}
	}, {
		key: 'render',
		value: function render() {

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(_permissions2.default, this.props),
				_react2.default.createElement(_modal2.default, this.props)
			);
		}
	}]);

	return Main;
}(_react.Component);

exports.default = Main;

/***/ }),
/* 815 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(13);

var _redux = __webpack_require__(11);

var _modal = __webpack_require__(401);

var modalActions = _interopRequireWildcard(_modal);

var _permissions = __webpack_require__(402);

var permissionActions = _interopRequireWildcard(_permissions);

var _permissions2 = __webpack_require__(816);

var _permissions3 = _interopRequireDefault(_permissions2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function mapStateToProps(state) {
	return {
		permissions: state.permissions || {},
		modal: state.modal
	};
}

function mapDispatchToProps(dispatch) {
	return {
		actions: {
			modalActions: (0, _redux.bindActionCreators)(modalActions, dispatch),
			permissionActions: (0, _redux.bindActionCreators)(permissionActions, dispatch)
		}
	};
}

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(_permissions3.default);

/***/ }),
/* 816 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _header = __webpack_require__(817);

var _header2 = _interopRequireDefault(_header);

var _footer = __webpack_require__(818);

var _footer2 = _interopRequireDefault(_footer);

var _permissionsTable = __webpack_require__(819);

var _permissionsTable2 = _interopRequireDefault(_permissionsTable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Permissions = function (_Component) {
	_inherits(Permissions, _Component);

	function Permissions(props) {
		_classCallCheck(this, Permissions);

		return _possibleConstructorReturn(this, (Permissions.__proto__ || Object.getPrototypeOf(Permissions)).call(this, props));
	}

	_createClass(Permissions, [{
		key: 'render',
		value: function render() {
			var tooltipWidth = { "--tooltip-width": "220px" };

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(_header2.default, _extends({}, this.props, { title: (0, _utils.translate)('Permissions') })),
				_react2.default.createElement(_permissionsTable2.default, this.props),
				_react2.default.createElement(_footer2.default, this.props)
			);
		}
	}]);

	return Permissions;
}(_react.Component);

exports.default = Permissions;

/***/ }),
/* 817 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Header = function (_Component) {
    _inherits(Header, _Component);

    function Header() {
        _classCallCheck(this, Header);

        return _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).apply(this, arguments));
    }

    _createClass(Header, [{
        key: 'render',
        value: function render() {
            var prop = this.props;

            return _react2.default.createElement(
                'div',
                { className: 'sui-box-header' },
                _react2.default.createElement(
                    'h2',
                    { className: 'sui-box-title' },
                    prop.title
                ),
                prop.hasUpdated && _react2.default.createElement(
                    'span',
                    { className: 'sui-tag' },
                    (0, _utils.translate)('Unsaved Changes')
                )
            );
        }
    }]);

    return Header;
}(_react.Component);

exports.default = Header;

/***/ }),
/* 818 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Footer = function (_Component) {
	_inherits(Footer, _Component);

	function Footer(props) {
		_classCallCheck(this, Footer);

		var _this = _possibleConstructorReturn(this, (Footer.__proto__ || Object.getPrototypeOf(Footer)).call(this, props));

		_this.showModal = _this.showModal.bind(_this);
		_this.closeModal = _this.closeModal.bind(_this);
		return _this;
	}

	_createClass(Footer, [{
		key: 'showModal',
		value: function showModal() {
			this.props.actions.modalActions.showModal({
				open: true,
				new: true,
				closeModal: this.closeModal
			}, 'permissions');
		}
	}, {
		key: 'closeModal',
		value: function closeModal() {
			this.props.actions.modalActions.showModal({
				open: false
			}, 'permissions');
		}
	}, {
		key: 'render',
		value: function render() {
			var prop = this.props;

			return _react2.default.createElement(
				'div',
				{ className: 'sui-box-footer' },
				_react2.default.createElement(
					'button',
					{
						className: 'sui-button sui-button-gray',
						onClick: this.showModal
					},
					_react2.default.createElement('span', { className: 'sui-icon-plus sui-', 'aria-hidden': 'true' }),
					(0, _utils.translate)('Add permissions')
				)
			);
		}
	}]);

	return Footer;
}(_react.Component);

exports.default = Footer;

/***/ }),
/* 819 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _permissionItem = __webpack_require__(820);

var _permissionItem2 = _interopRequireDefault(_permissionItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint esversion: 6 */


var PermissionsTable = function (_Component) {
	_inherits(PermissionsTable, _Component);

	function PermissionsTable(props) {
		_classCallCheck(this, PermissionsTable);

		return _possibleConstructorReturn(this, (PermissionsTable.__proto__ || Object.getPrototypeOf(PermissionsTable)).call(this, props));
	}

	_createClass(PermissionsTable, [{
		key: 'applySticky',
		value: function applySticky() {
			var node = this.refs.StickyHeader;
			var currentOffset = node.getBoundingClientRect().top;
			var stickyOffset = parseInt(window.getComputedStyle(node).top.replace('px', ''));
			var isStuck = currentOffset <= stickyOffset;

			if (isStuck) {
				node.classList.add('sui-is-sticky');
			} else {
				node.classList.remove('sui-is-sticky');
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-body' },
					_react2.default.createElement(
						'p',
						null,
						(0, _utils.translate)('By default, all administrators have complete access to Forminator. ' + 'You can provide and manage access to other user roles or to individual user(s) below.')
					)
				),
				_react2.default.createElement(
					'div',
					{ className: 'forminator-permissions-table' },
					_react2.default.createElement(
						'table',
						{ className: 'sui-table sui-table-flushed' },
						_react2.default.createElement(
							'thead',
							null,
							_react2.default.createElement(
								'tr',
								null,
								_react2.default.createElement(
									'th',
									{ colSpan: 4 },
									(0, _utils.translate)('User Role/User')
								),
								_react2.default.createElement(
									'th',
									{ colSpan: 2, className: 'fp-item-col' },
									(0, _utils.translate)('Modules')
								),
								_react2.default.createElement(
									'th',
									{ colSpan: 2, className: 'fp-item-col' },
									(0, _utils.translate)('Submissions')
								),
								_react2.default.createElement(
									'th',
									{ colSpan: 2, className: 'fp-item-col' },
									(0, _utils.translate)('Add-ons')
								),
								_react2.default.createElement(
									'th',
									{ colSpan: 2, className: 'fp-item-col' },
									(0, _utils.translate)('Integrations')
								),
								_react2.default.createElement(
									'th',
									{ colSpan: 2, className: 'fp-item-col' },
									(0, _utils.translate)('Reports')
								),
								_react2.default.createElement(
									'th',
									{ colSpan: 2, className: 'fp-item-col' },
									(0, _utils.translate)('Settings')
								),
								_react2.default.createElement('th', { colSpan: 1 })
							)
						),
						_react2.default.createElement(
							'tbody',
							null,
							_react2.default.createElement(_permissionItem2.default, _extends({}, this.props, { isAdmin: true })),
							_.map(this.props.permissions, function (permission, index) {
								return _react2.default.createElement(_permissionItem2.default, _extends({
									key: index,
									actions: _this2.props.actions,
									isAdmin: false
								}, permission));
							})
						)
					)
				)
			);
		}
	}]);

	return PermissionsTable;
}(_react.Component);

exports.default = PermissionsTable;

/***/ }),
/* 820 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

var _permissionIcon = __webpack_require__(821);

var _permissionIcon2 = _interopRequireDefault(_permissionIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint esversion: 6 */


var PermissionItem = function (_Component) {
	_inherits(PermissionItem, _Component);

	function PermissionItem(props) {
		_classCallCheck(this, PermissionItem);

		var _this = _possibleConstructorReturn(this, (PermissionItem.__proto__ || Object.getPrototypeOf(PermissionItem)).call(this, props));

		_this.permissionMenu = _react2.default.createRef();
		_this.showModal = _this.showModal.bind(_this);
		_this.deleteModal = _this.deleteModal.bind(_this);
		return _this;
	}

	_createClass(PermissionItem, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.$permission = jQuery(this.permissionMenu.current);

			this.$permission.on('click', function (e) {
				e.preventDefault();
				e.stopPropagation();

				jQuery('.fp-permission-actions .permission-menu').not(this).parent('.sui-dropdown.open').removeClass('open');
				jQuery(this).parent().toggleClass('open');
			});

			this.$permission.on('mouseout', function (e) {
				jQuery(this).trigger('blur');
			});

			// Remove this when more Forminator menu items are added in the future to enable accordion.
			var count = 0;
			this.accordionTimeout(count);
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.$permission.off();
		}

		/*
   * Removes the click event on sui-accordion until SUI has initialized.
   * This was added because SUI has no trigger event
   * when it has finished initializing that we could have used.
  */

	}, {
		key: 'accordionTimeout',
		value: function accordionTimeout(count) {
			var self = this;

			setTimeout(function () {
				jQuery('.forminator-permissions-table.sui-accordion').off('click');

				if (count < 10) {
					self.accordionTimeout(count);
				}
				count++;
			}, 200);
		}
	}, {
		key: 'showModal',
		value: function showModal() {
			var modalActions = this.props.actions.modalActions;
			var userIds = this.props.specific_user;

			modalActions.showModal(_extends({}, this.props, userIds && { currentUser: this.props.user_info[userIds[0]] }, {
				open: true,
				closeModal: function closeModal() {
					modalActions.showModal({
						open: false
					}, 'permissions');
				}
			}), 'permissions');
		}
	}, {
		key: 'deleteModal',
		value: function deleteModal() {
			var modalActions = this.props.actions.modalActions;

			modalActions.showModal(_extends({}, this.props, {
				open: true,
				closeModal: function closeModal() {
					modalActions.showModal({
						open: false
					}, 'permissionDelete');
				}
			}), 'permissionDelete');
		}
	}, {
		key: 'render',
		value: function render() {
			var prop = this.props;
			var isAdmin = prop.isAdmin;
			var tooltipWidth = { "--tooltip-width": "220px" };
			var accessList = ['manage_forminator_modules', 'manage_forminator_submissions', 'manage_forminator_addons', 'manage_forminator_integrations', 'manage_forminator_reports', 'manage_forminator_settings'];

			var roleImage = _react2.default.createElement('span', { className: 'sui-icon-community-people sui-md', 'aria-hidden': 'true' });
			var roleName = (0, _utils.translate)('Administrator');
			var roleDesc = (0, _utils.translate)('All');
			var itemName = '';

			// Set the role/user info.
			if (!isAdmin) {
				if ('role' === prop.permission_type) {
					var countExcluded = prop.exclude_users.length;

					roleName = forminatorData.userRoles[prop.user_role].name;
					roleDesc += 0 !== countExcluded ? (0, _utils.translate)(' except ') + countExcluded : '';
				} else {
					var users = prop.specific_user;
					var tooltipText = '';
					roleImage = _react2.default.createElement('img', { src: prop.avatar, width: '30', height: '30' });

					// If there are more than 1 chosen.
					if (users.length > 1) {
						roleName = prop.user_info[users[0]].name;
						roleName += ' +' + (users.length - 1) + ' ';
						roleName += (0, _utils.translate)('more');

						roleDesc = users.length + (0, _utils.translate)(' users');

						// Create tooltip text.
						var counter = 0;
						_.map(prop.user_info, function (info, userId) {
							counter++;
							tooltipText += info.name + ' - ' + '(' + info.email + ')';

							if (counter < users.length) {
								tooltipText += ', \n';
							}
						});

						itemName = _react2.default.createElement(
							'span',
							{
								className: 'sui-tooltip sui-tooltip-constrained sui-tooltip-right',
								style: tooltipWidth,
								'data-tooltip': tooltipText
							},
							_react2.default.createElement(
								'span',
								{ className: 'fp-item-name' },
								roleName
							)
						);
					} else {
						if (prop.user_info) {
							roleName = prop.user_info[users[0]].name;
						}
						roleDesc = prop.user_info[users[0]].email;
					}
				}
			}

			// Set item name here for no tooltips.
			if ('' === itemName) {
				itemName = _react2.default.createElement(
					'span',
					{ className: 'fp-item-name' },
					roleName
				);
			}

			return _react2.default.createElement(
				'tr',
				null,
				_react2.default.createElement(
					'td',
					{ colSpan: 4, className: ' fp-role-head' },
					_react2.default.createElement(
						'div',
						{ className: 'fp-role-box' },
						_react2.default.createElement(
							'div',
							{ className: 'fp-role-img' },
							roleImage
						),
						_react2.default.createElement(
							'div',
							{ className: 'fp-role-info' },
							itemName,
							_react2.default.createElement(
								'span',
								{ className: 'fp-item-subtitle' },
								roleDesc
							)
						)
					)
				),
				_.map(accessList, function (access, x) {
					return _react2.default.createElement(_permissionIcon2.default, _extends({ key: x }, prop, { access: access }));
				}),
				_react2.default.createElement(
					'td',
					{ colSpan: 1, className: 'fp-permission-actions' },
					!isAdmin && _react2.default.createElement(
						'div',
						{ className: 'fui-field--actions' },
						_react2.default.createElement(
							'div',
							{ className: 'sui-dropdown' },
							_react2.default.createElement(
								'button',
								{ ref: this.permissionMenu, className: 'permission-menu sui-button-icon sui-dropdown-anchor' },
								_react2.default.createElement('span', { className: 'sui-icon-widget-settings-config', 'aria-hidden': 'true' }),
								_react2.default.createElement(
									'span',
									{ className: 'sui-screen-reader-text' },
									(0, _utils.translate)('Permission options')
								)
							),
							_react2.default.createElement(
								'ul',
								null,
								_react2.default.createElement(
									'li',
									null,
									_react2.default.createElement(
										'button',
										{
											className: 'forminator-field-edit',
											onClick: this.showModal
										},
										_react2.default.createElement('span', { className: 'sui-icon-widget-settings-config', 'aria-hidden': 'true' }),
										(0, _utils.translate)('Edit')
									)
								),
								_react2.default.createElement(
									'li',
									null,
									_react2.default.createElement(
										'button',
										{
											className: 'forminator-field-remove sui-option-red',
											onClick: this.deleteModal
										},
										_react2.default.createElement('span', { className: 'sui-icon-trash', 'aria-hidden': 'true' }),
										(0, _utils.translate)('Delete')
									)
								)
							)
						)
					)
				)
			);
		}
	}]);

	return PermissionItem;
}(_react.Component);

exports.default = PermissionItem;

/***/ }),
/* 821 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* jshint esversion: 6 */


var PermissionIcon = function (_Component) {
	_inherits(PermissionIcon, _Component);

	function PermissionIcon(props) {
		_classCallCheck(this, PermissionIcon);

		return _possibleConstructorReturn(this, (PermissionIcon.__proto__ || Object.getPrototypeOf(PermissionIcon)).call(this, props));
	}

	_createClass(PermissionIcon, [{
		key: 'render',
		value: function render() {
			var prop = this.props;
			var isAdmin = prop.isAdmin;
			var tooltipWidth = { "--tooltip-width": "220px" };

			var icon = void 0,
			    tooltipText = void 0;
			if (isAdmin || (0, _utils.isTrue)(prop[prop.access])) {
				icon = 'sui-icon-check';
				tooltipText = (0, _utils.translate)('Can');
			} else {
				icon = 'sui-icon-lock';
				tooltipText = (0, _utils.translate)("Can't");
			}

			// Add space.
			tooltipText += ' ';

			// Set the tooltip text for each access.
			switch (prop.access) {
				case 'manage_forminator_modules':
					tooltipText += (0, _utils.translate)('create, edit, and delete modules (Forms, Polls, and Quizzes).');

					break;
				case 'manage_forminator_submissions':
					tooltipText += (0, _utils.translate)('view and delete submissions.');

					break;
				case 'manage_forminator_addons':
					tooltipText += (0, _utils.translate)('configure add-ons.');

					break;
				case 'manage_forminator_integrations':
					tooltipText += (0, _utils.translate)('configure integrations.');

					break;
				case 'manage_forminator_reports':
					tooltipText += (0, _utils.translate)('configure reports.');

					break;
				case 'manage_forminator_settings':
					if (isAdmin) {
						tooltipText += (0, _utils.translate)('configure all settings.');
					} else if (!(0, _utils.isTrue)(prop[prop.access])) {
						tooltipText += (0, _utils.translate)('configure settings.');
					} else {
						tooltipText += (0, _utils.translate)('configure settings except permissions.');
					}

					break;
			}

			return _react2.default.createElement(
				'td',
				{ colSpan: 2, className: 'fp-item-col' },
				_react2.default.createElement(
					'span',
					{
						className: 'sui-tooltip sui-tooltip-constrained',
						style: tooltipWidth,
						'data-tooltip': tooltipText
					},
					_react2.default.createElement('span', { className: icon + ' sui-sm', 'aria-hidden': 'true' })
				)
			);
		}
	}]);

	return PermissionIcon;
}(_react.Component);

exports.default = PermissionIcon;

/***/ }),
/* 822 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactRedux = __webpack_require__(13);

var _redux = __webpack_require__(11);

var _modal = __webpack_require__(823);

var _modal2 = _interopRequireDefault(_modal);

var _modal3 = __webpack_require__(401);

var modalActions = _interopRequireWildcard(_modal3);

var _permissions = __webpack_require__(402);

var permissionActions = _interopRequireWildcard(_permissions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function mapStateToProps(state) {
	return {
		permissions: state.permissions || {},
		modal: state.modal
	};
}

function mapDispatchToProps(dispatch) {
	return {
		actions: {
			permissionActions: (0, _redux.bindActionCreators)(permissionActions, dispatch),
			modalActions: (0, _redux.bindActionCreators)(modalActions, dispatch)
		}
	};
}

exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(_modal2.default);

/***/ }),
/* 823 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(23);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _index = __webpack_require__(824);

var _index2 = _interopRequireDefault(_index);

var _reactDisplace = __webpack_require__(182);

var _reactDisplace2 = _interopRequireDefault(_reactDisplace);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
// import FocusTrap from './modals/partials/focus-trap';


var MODAL_TYPES = {
	permissions: _index2.default.permissionsModal,
	permissionDelete: _index2.default.permissionDeleteModal
};

/* global setTimeout,clearTimeout */

var Modal = function (_Component) {
	_inherits(Modal, _Component);

	function Modal(props) {
		_classCallCheck(this, Modal);

		return _possibleConstructorReturn(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).call(this, props));
	}

	_createClass(Modal, [{
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps) {
			var _this2 = this;

			this.$el = jQuery(this.el);
			var self = this;

			if (!_.isEmpty(prevProps.modal) /* && ! _.isNull( this.props.modal.modalType ) */) {
					if (prevProps.modal.modalProps.open !== this.props.modal.modalProps.open) {
						var modalElement = _reactDom2.default.findDOMNode(this);

						if (this.props.modal.modalProps.open) {
							this.focusAfterClosed = this.props.modal.modalProps.activeElement;

							var focusFirst = this.props.modal.modalProps.focusFirst;

							setTimeout(function () {
								if ('string' === typeof focusFirst) {
									self.focusFirst = self.$el.find(focusFirst);
								} else if ('object' === (typeof focusFirst === 'undefined' ? 'undefined' : _typeof(focusFirst))) {
									self.focusFirst = focusFirst;
								} else {
									self.focusFirst = null;
								}

								if (self.focusFirst && self.focusFirst.length) {
									self.setFocus(self.focusFirst.first());
								}
							}, 320);

							jQuery('#wpwrap').attr('aria-hidden', 'true');
						}

						if (!this.props.modal.modalProps.open) {
							jQuery('#wpwrap').attr('aria-hidden', 'false');

							setTimeout(function () {
								self.setFocus(self.focusAfterClosed);
							}, 320);

							this.hideModalTimeout = setTimeout(function () {
								modalElement.setAttribute('aria-hidden', 'true');
								// cleanup
								_this2.props.modal.modalType = null;
								_this2.forceUpdate();
							}, 300);
						} else {
							modalElement.removeAttribute('aria-hidden');
						}
					}
				}
		}
	}, {
		key: 'setFocus',
		value: function setFocus(element) {
			var focusInterval = 10; // ms, time between function calls
			var focusTotalRepetitions = 10; // number of repetitions

			if (typeof element === 'undefined') {
				return;
			}

			element.attr('tabindex', '0');
			element.blur();

			var focusRepetitions = 0;
			var interval = window.setInterval(function () {
				element.focus();
				focusRepetitions++;

				if (focusRepetitions >= focusTotalRepetitions) {
					window.clearInterval(interval);
				}
			}, focusInterval);
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			clearTimeout(this.hideModalTimeout);
		}
	}, {
		key: 'render',
		value: function render() {
			var _this3 = this;

			if (_.isUndefined(this.props.modal) || _.isUndefined(this.props.modal.modalProps) || _.isNull(this.props.modal.modalType)) {
				return null;
			}

			var modalClass = 'sui-modal-lg';
			var overlayClass = ['sui-modal-content', 'sui-content-fade-in'];
			if (!this.props.modal.modalProps.open) {
				overlayClass = ['sui-modal-content', 'sui-content-fade-out'];
			}

			var modalType = this.props.modal.modalType;
			var SpecifiedModal = MODAL_TYPES[modalType];

			if ('publish' === modalType) {
				modalClass = 'sui-modal-sm fui-dialog-publish';
			}

			if ('shortcode' === modalType) {
				modalClass = 'sui-modal-sm fui-dialog-publish';
			}

			var smModalType = ['permissionDelete'];
			if (smModalType.includes(modalType)) {
				modalClass = 'sui-modal-sm';
			}

			if (!_.isUndefined(this.props.modal.modalProps) && !_.isUndefined(this.props.modal.modalProps.field) && !_.isUndefined(this.props.modal.modalProps.field.type)) {
				var fieldType = this.props.modal.modalProps.field.type;

				if (fieldType === 'radio' || fieldType === 'checkbox' || fieldType === 'select') {
					modalClass += ' multivalue-modal';
				} else {
					modalClass += ' ' + this.props.modal.modalProps.field.type + '-modal';
				}
			}

			var classes = jQuery('.sui-color-accessible').length ? 'sui-wrap sui-color-accessible' : 'sui-wrap';

			return _react2.default.createElement(
				'div',
				{ className: classes },
				_react2.default.createElement(
					'div',
					{ id: 'forminator-modal', className: 'sui-modal sui-active ' + modalClass + ' ' + modalType },
					_react2.default.createElement(
						'div',
						_extends({
							role: 'dialog',
							id: 'modal-' + this.props.modal.modalProps.id,
							className: '' + overlayClass.join(' '),
							'aria-modal': 'true',
							'aria-live': 'polite'
						}, this.props.modal.modalProps.labelledBy && { 'aria-labelledby': this.props.modal.modalProps.labelledBy }, this.props.modal.modalProps.describedBy && { 'aria-describedby': this.props.modal.modalProps.describedBy }, {
							ref: function ref(el) {
								return _this3.el = el;
							}
						}),
						_react2.default.createElement(
							'div',
							{ className: 'sui-box', style: { marginBottom: 0 } },
							_react2.default.createElement(SpecifiedModal, this.props)
						)
					)
				)
			);
		}
	}]);

	return Modal;
}(_react.Component);

var DisplacedModal = (0, _reactDisplace2.default)(Modal);

DisplacedModal.renderTo = function (input) {
	return (0, _reactDisplace2.default)(Modal, { renderTo: input });
};

module.exports = DisplacedModal;

/***/ }),
/* 824 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _permissions = __webpack_require__(825);

var _permissions2 = _interopRequireDefault(_permissions);

var _permissionDelete = __webpack_require__(826);

var _permissionDelete2 = _interopRequireDefault(_permissionDelete);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var modalTypes = {
	permissionsModal: _permissions2.default,
	permissionDeleteModal: _permissionDelete2.default
};

exports.default = modalTypes;

/***/ }),
/* 825 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _axios = __webpack_require__(39);

var _axios2 = _interopRequireDefault(_axios);

var _qs = __webpack_require__(40);

var _qs2 = _interopRequireDefault(_qs);

var _utils = __webpack_require__(1);

var _notifications = __webpack_require__(30);

var _notifications2 = _interopRequireDefault(_notifications);

var _header = __webpack_require__(64);

var _header2 = _interopRequireDefault(_header);

var _title = __webpack_require__(66);

var _title2 = _interopRequireDefault(_title);

var _footer = __webpack_require__(87);

var _footer2 = _interopRequireDefault(_footer);

var _close = __webpack_require__(65);

var _close2 = _interopRequireDefault(_close);

var _radioTabs = __webpack_require__(7);

var _radioTabs2 = _interopRequireDefault(_radioTabs);

var _container = __webpack_require__(4);

var _container2 = _interopRequireDefault(_container);

var _suiSelect = __webpack_require__(20);

var _suiSelect2 = _interopRequireDefault(_suiSelect);

var _suiTags = __webpack_require__(300);

var _suiTags2 = _interopRequireDefault(_suiTags);

var _checkbox = __webpack_require__(41);

var _checkbox2 = _interopRequireDefault(_checkbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var permissionsModal = function (_Component) {
	_inherits(permissionsModal, _Component);

	function permissionsModal(props) {
		_classCallCheck(this, permissionsModal);

		var _this = _possibleConstructorReturn(this, (permissionsModal.__proto__ || Object.getPrototypeOf(permissionsModal)).call(this, props));

		_this.saveBtn = _react2.default.createRef();
		_this.closeModal = _this.props.modal.modalProps.closeModal.bind(_this);
		_this.updateProperty = _this.updateProperty.bind(_this);
		_this.savePermission = _this.savePermission.bind(_this);
		_this.validator = _this.validator.bind(_this);
		_this.showNotification = _this.showNotification.bind(_this);

		_this.updated = false;
		_this.modalData = Object.assign({}, _this.props.modal.modalProps);
		_this.userRoles = _this.getUserRoles(Object.assign({}, forminatorData.userRoles));
		_this.defaultRole = Object.keys(_this.userRoles)[0];

		var defaultType = _.isEmpty(_this.userRoles) ? 'specific' : 'role';

		// For all additional access in the future,
		// make sure to add it also in the validator in render.
		_this.state = {
			pid: _this.modalData.pid || '',
			permission_type: _this.modalData.permission_type || defaultType,
			user_role: _this.modalData.user_role || _this.defaultRole,
			exclude_users: _this.modalData.exclude_users || [],
			specific_user: _this.modalData.specific_user || [],
			avatar: _this.modalData.avatar || '',
			user_info: _this.modalData.user_info || [],
			manage_forminator_modules: _this.modalData.manage_forminator_modules || false,
			manage_forminator_submissions: _this.modalData.manage_forminator_submissions || false,
			manage_forminator_addons: _this.modalData.manage_forminator_addons || false,
			manage_forminator_integrations: _this.modalData.manage_forminator_integrations || false,
			manage_forminator_reports: _this.modalData.manage_forminator_reports || false,
			manage_forminator_settings: _this.modalData.manage_forminator_settings || false,
			current_user: _this.modalData.currentUser || []
		};
		return _this;
	}

	_createClass(permissionsModal, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.$saveBtn = jQuery(this.saveBtn.current);
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps, prevState) {
			if (JSON.stringify(this.state) !== JSON.stringify(prevState)) {
				this.updated = true;
			} else {
				this.updated = false;
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.$saveBtn.off;
		}

		// Remove user roles that were already set.

	}, {
		key: 'getUserRoles',
		value: function getUserRoles(userRoles) {
			var self = this;

			// Remove admin first.
			delete userRoles['administrator'];

			_.forEach(userRoles, function (val, role) {
				if (!_.isUndefined(_.find(self.props.permissions, function (p) {
					return p.user_role === role;
				}))) {
					if (!self.modalData.new && role !== self.modalData.user_role || self.modalData.new) {
						delete userRoles[role];
					}
				}
			});

			return userRoles;
		}

		// Make it possible to update state from child components

	}, {
		key: 'updateProperty',
		value: function updateProperty(slug, value) {
			this.setState(_defineProperty({}, slug, value));
		}
	}, {
		key: 'getUserTagsOptions',
		value: function getUserTagsOptions($property) {
			var _this2 = this;

			var searchData = function searchData(params) {
				var args = {
					action: 'forminator_builder_search_emails',
					_wpnonce: forminatorData.searchNonce,
					exclude_admins: true,
					q: params.term,
					permission: 'forminator-settings',
					pid: _this2.state.pid,
					property: $property,
					is_permission: true
				};

				// Search users from chosen role.
				if ('role' === _this2.state.permission_type) {
					args.role = _this2.state.user_role;
				}

				return args;
			};

			return {
				tags: false,
				minimumInputLength: 1,
				tokenSeparators: [',', ' '],
				placeholder: (0, _utils.translate)('Click to search a user…'),
				language: {
					searching: function searching() {
						return (0, _utils.translate)('Searching');
					},
					noResults: function noResults() {
						return (0, _utils.translate)('User not found');
					}
				},
				ajax: {
					url: forminatorData.ajaxUrl,
					type: 'POST',
					delay: 150,
					data: function data(params) {
						return searchData(params);
					},
					processResults: function processResults(data) {
						return {
							results: data.data
						};
					},
					cache: true
				},
				templateResult: function templateResult(result) {
					if (!_.isUndefined(result.id) && !_.isUndefined(result.text) && !_.isUndefined(result.display_name)) {
						return jQuery('<span>' + result.display_name + ' ' + '(' + result.text + ')' + '</span>');
					}

					return result.text;
				},
				createTag: function createTag(params) {
					var term = params.term.trim();
					if (!(0, _utils.isEmailWp)(term)) {
						return null;
					}
					return {
						id: term,
						text: term
					};
				}
			};
		}
	}, {
		key: 'showNotification',
		value: function showNotification(type, msg) {
			var custom = new _notifications2.default({
				type: type,
				text: 'error' === type ? (0, _utils.translate)('Something went wrong. Please try again.') : msg
			});

			custom.open();

			if ('error' === type) {
				console.log(msg);
			}

			this.closeModal();
		}
	}, {
		key: 'savePermission',
		value: function savePermission() {
			var _this3 = this;

			// If no updates were made, just close the modal.
			if (!(0, _utils.isTrue)(this.modalData.new) && !this.updated) {
				this.closeModal();
				return;
			}

			// Apply onload class.
			this.$saveBtn.addClass('sui-button-onload');
			this.$saveBtn.prop('disabled', true);

			var permission = Object.assign({}, this.state);
			var newState = void 0;
			var permissionsData = {
				action: 'forminator_save_permissions',
				_wpnonce: forminatorData.permission_nonce
			};

			// Delete unnecessary data.
			if ('role' === permission.permission_type) {
				delete permission.specific_user;
			} else {
				delete permission.user_role;
				delete permission.exclude_users;
			}

			// We have a new permission, insert new one.
			if (this.modalData.new) {
				permissionsData.mode = 'new';

				// Add permission ID.
				permission.pid = 'pid-' + (0, _utils.randNumber)() + '-' + (0, _utils.randNumber)();

				newState = [].concat(_toConsumableArray(this.props.permissions), [permission]);

				// Replace edited permission.
			} else {
				permissionsData.mode = 'edit';
				permissionsData.pid = permission.pid;

				newState = this.props.permissions;
				var currentPermission = _.findIndex(newState, function (p) {
					return p.pid === permission.pid;
				});

				newState.splice(currentPermission, 1, permission);
			}

			permissionsData.permissions = JSON.stringify(newState);

			_axios2.default.post(forminatorData.ajaxUrl, _qs2.default.stringify(permissionsData)).then(function (data) {
				var notifType = void 0,
				    notifMessage = void 0;

				if (data.data.success) {
					_this3.props.actions.permissionActions.updatePermissions(data.data.data);

					notifType = 'success';
					notifMessage = _this3.modalData.new ? (0, _utils.translate)('New permission added successfully!') : (0, _utils.translate)('Permission updated successfully!');
				} else {
					notifType = 'error';
					notifMessage = data.data;
				}

				_this3.showNotification(notifType, notifMessage);
			}).catch(function (err) {
				_this3.showNotification('error', err);
			}).then(function () {
				// Close modal
				_this3.closeModal();
			});
		}

		// Validate modal.

	}, {
		key: 'validator',
		value: function validator() {
			var state = this.state;
			var isValid = false,
			    validationError = [],
			    isTypeValid = false,
			    isAccessValid = false;

			// Check if role or user is selected.
			if ('specific' === state.permission_type && _.isEmpty(state.specific_user)) {

				isTypeValid = false;
				validationError.push((0, _utils.translate)('no user selected'));
			} else if ('role' === state.permission_type && _.isEmpty(state.user_role)) {

				isTypeValid = false;
				validationError.push((0, _utils.translate)('no role selected'));
			} else {
				isTypeValid = true;
			}

			// Check if all access are unchecked.
			if (!(0, _utils.isTrue)(state.manage_forminator_modules) && !(0, _utils.isTrue)(state.manage_forminator_submissions) && !(0, _utils.isTrue)(state.manage_forminator_addons) && !(0, _utils.isTrue)(state.manage_forminator_integrations) && !(0, _utils.isTrue)(state.manage_forminator_reports) && !(0, _utils.isTrue)(state.manage_forminator_settings)) {
				isAccessValid = false;
				validationError.push((0, _utils.translate)('no permissions checked'));
			} else {
				isAccessValid = true;
			}

			if (isTypeValid && isAccessValid) {
				isValid = true;

				if (!_.isUndefined(this.$saveBtn)) {
					this.$saveBtn.parent('.btn-save-wrap').removeClass('sui-tooltip');
					this.$saveBtn.prop('disabled', false);
				}
			} else {
				isValid = false;
				validationError = validationError.join(', ');

				if (!_.isUndefined(this.$saveBtn)) {
					this.$saveBtn.parent('.btn-save-wrap').addClass('sui-tooltip');
					this.$saveBtn.prop('disabled', true);
				}
			}

			return {
				isValid: isValid,
				validationError: validationError
			};
		}
	}, {
		key: 'render',
		value: function render() {
			var titleTag = '',
			    editNotice = '',
			    saveBtn = (0, _utils.translate)('Add Permissions');

			var isNew = (0, _utils.isTrue)(this.modalData.new);
			var modalTitle = (0, _utils.translate)(isNew ? 'Add Permissions' : 'Edit Permissions');
			var permissionType = !_.isUndefined(this.modalData.permission_type) ? this.modalData.permission_type : 'role';

			// Set the text depending on permissionType.
			if (!isNew) {
				saveBtn = (0, _utils.translate)('Update Permissions');

				if ('role' === permissionType) {
					titleTag = (0, _utils.translate)('User Role');
					editNotice = (0, _utils.translate)('You are editing permissions for the {{b}}%(role)s{{/b}} user role.', {
						args: {
							role: this.userRoles[this.modalData.user_role].name
						},
						components: {
							b: _react2.default.createElement('b', null)
						}
					});
				} else {
					var userIds = this.state.specific_user;
					var numUsers = this.state.specific_user.length;
					var userName = !_.isUndefined(this.state.user_info[userIds[0]]) ? this.state.user_info[userIds[0]].name : this.state.current_user.name;
					var userEmail = !_.isUndefined(this.state.user_info[userIds[0]]) ? this.state.user_info[userIds[0]].email : this.state.current_user.email;

					titleTag = (0, _utils.translate)('Specific User');
					editNotice = (0, _utils.translate)('You are editing permissions for {{b}}%(userName)s{{/b}}', {
						args: {
							userName: userName
						},
						components: {
							b: _react2.default.createElement('b', null)
						}
					});

					// End of statement depends on the number of users.
					if (numUsers > 1) {
						editNotice = editNotice.concat(' (' + userEmail + ') + ' + (numUsers - 1));

						if (numUsers > 2) {
							editNotice = editNotice.concat((0, _utils.translate)(' others.'));
						} else {
							editNotice = editNotice.concat((0, _utils.translate)(' other.'));
						}
					} else {
						editNotice = editNotice.concat(' (' + userEmail + ').');
					}
				}
			}

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					_header2.default,
					{
						closeType: 'icon',
						closeModal: this.closeModal
					},
					_react2.default.createElement(_title2.default, {
						id: 'permissions-modal-title',
						label: modalTitle,
						tag: titleTag
					})
				),
				_react2.default.createElement(
					'div',
					{ className: 'sui-box-body' },
					isNew && _react2.default.createElement(
						'div',
						{ className: 'sui-box-settings-row' },
						_react2.default.createElement(
							'div',
							{ className: 'sui-box-settings-col-12' },
							_react2.default.createElement(
								'span',
								{ className: 'sui-settings-label sui-dark' },
								(0, _utils.translate)('User Role/Users')
							),
							_react2.default.createElement(
								'span',
								{ className: 'sui-description' },
								(0, _utils.translate)('Choose which user role or individual user(s) should have access ' + 'to the Forminator features selected in the Permissions section below.')
							),
							_react2.default.createElement(
								_radioTabs2.default,
								_extends({}, this.props, {
									settings: this.state,
									updateProperty: this.updateProperty,
									property: 'permission_type'
								}),
								!_.isEmpty(this.userRoles) && _react2.default.createElement(
									_container2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('User Role'),
										value: 'role',
										boxClass: 'sui-tab-boxed'
									}),
									_react2.default.createElement(
										_suiSelect2.default,
										_extends({}, this.props, {
											settings: this.state,
											updateProperty: this.updateProperty,
											property: 'user_role',
											label: (0, _utils.translate)('Choose user role'),
											defaultValue: this.defaultRole
										}),
										_.map(this.userRoles, function (role, id) {
											return _react2.default.createElement(
												'option',
												{ value: id, key: id },
												role.name
											);
										})
									),
									_react2.default.createElement(_suiTags2.default, _extends({}, this.props, {
										settings: this.state,
										updateProperty: this.updateProperty,
										property: 'exclude_users',
										style: { marginBottom: '10px' },
										options: this.getUserTagsOptions(),
										label: (0, _utils.translate)('Exclude users')
									})),
									_react2.default.createElement(
										'span',
										{ className: 'sui-description' },
										(0, _utils.translate)('Use this option to exclude specific ' + 'users with the selected role from accessing Forminator.')
									)
								),
								_react2.default.createElement(
									_container2.default,
									_extends({}, this.props, {
										label: (0, _utils.translate)('Specific User'),
										value: 'specific',
										boxClass: 'sui-tab-boxed'
									}),
									_react2.default.createElement(_suiTags2.default, _extends({}, this.props, {
										settings: this.state,
										updateProperty: this.updateProperty,
										property: 'specific_user',
										style: { marginBottom: '10px' },
										options: this.getUserTagsOptions('specific_user'),
										label: (0, _utils.translate)('Choose users')
									}))
								)
							)
						)
					),
					!isNew && _react2.default.createElement(
						_react2.default.Fragment,
						null,
						_react2.default.createElement(
							'div',
							{
								role: 'alert',
								className: 'sui-notice sui-active',
								style: { display: 'block' },
								'aria-live': 'assertive'
							},
							_react2.default.createElement(
								'div',
								{ className: 'sui-notice-content' },
								_react2.default.createElement(
									'div',
									{ className: 'sui-notice-message' },
									_react2.default.createElement('span', {
										className: 'sui-notice-icon sui-icon-info',
										'aria-hidden': 'true'
									}),
									_react2.default.createElement(
										'p',
										null,
										editNotice
									)
								)
							)
						),
						'role' === permissionType && _react2.default.createElement(
							_react2.default.Fragment,
							null,
							_react2.default.createElement(
								'span',
								{ className: 'sui-settings-label sui-dark' },
								(0, _utils.translate)('Exclude users')
							),
							_react2.default.createElement(
								'span',
								{ className: 'sui-description', style: { marginBottom: '10px' } },
								(0, _utils.translate)('Use this option to exclude specific ' + 'users with the selected role from accessing Forminator.')
							),
							_react2.default.createElement(_suiTags2.default, _extends({}, this.props, {
								settings: this.state,
								updateProperty: this.updateProperty,
								property: 'exclude_users',
								options: this.getUserTagsOptions()
								// label={ translate( 'Exclude users' ) }
							}))
						),
						'specific' === permissionType && _react2.default.createElement(
							_react2.default.Fragment,
							null,
							_react2.default.createElement(
								'span',
								{ className: 'sui-settings-label sui-dark' },
								(0, _utils.translate)('Choose users')
							),
							_react2.default.createElement(_suiTags2.default, _extends({}, this.props, {
								settings: this.state,
								updateProperty: this.updateProperty,
								property: 'specific_user',
								style: { marginBottom: '10px' },
								options: this.getUserTagsOptions('specific_user')
								// label={ translate( 'Choose users' ) }
							}))
						),
						_react2.default.createElement('hr', null)
					),
					_react2.default.createElement(
						'div',
						{ className: 'sui-box-settings-row' },
						_react2.default.createElement(
							'div',
							{ className: 'sui-box-settings-col' },
							_react2.default.createElement(
								'span',
								{ className: 'sui-settings-label sui-dark' },
								(0, _utils.translate)('Permissions')
							),
							_react2.default.createElement(
								'span',
								{ className: 'sui-description' },
								(0, _utils.translate)('Choose what permissions the selected user role or users will have.')
							),
							_react2.default.createElement(
								'div',
								{ className: 'sui-form-field permissions-checkboxes' },
								_react2.default.createElement(_checkbox2.default, _extends({}, this.props, {
									settings: this.state,
									updateProperty: this.updateProperty,
									property: 'manage_forminator_modules',
									label: (0, _utils.translate)('Modules'),
									itemClass: 'sui-checkbox-stacked sui-checkbox-sm'
								})),
								_react2.default.createElement(
									'span',
									{ className: 'sui-description permission-description' },
									(0, _utils.translate)('Create, edit, and delete modules (Forms, Polls, Quizzes).')
								),
								_react2.default.createElement(_checkbox2.default, _extends({}, this.props, {
									settings: this.state,
									updateProperty: this.updateProperty,
									property: 'manage_forminator_submissions',
									label: (0, _utils.translate)('Submissions'),
									itemClass: 'sui-checkbox-stacked sui-checkbox-sm'
								})),
								_react2.default.createElement(
									'span',
									{ className: 'sui-description permission-description' },
									(0, _utils.translate)('Access, export, and delete submissions.')
								),
								_react2.default.createElement(_checkbox2.default, _extends({}, this.props, {
									settings: this.state,
									updateProperty: this.updateProperty,
									property: 'manage_forminator_addons',
									label: (0, _utils.translate)('Add-ons'),
									itemClass: 'sui-checkbox-stacked sui-checkbox-sm'
								})),
								_react2.default.createElement(
									'span',
									{ className: 'sui-description permission-description' },
									(0, _utils.translate)('View, install/uninstall, and configure Add-ons.')
								),
								_react2.default.createElement(_checkbox2.default, _extends({}, this.props, {
									settings: this.state,
									updateProperty: this.updateProperty,
									property: 'manage_forminator_integrations',
									label: (0, _utils.translate)('Integrations'),
									itemClass: 'sui-checkbox-stacked sui-checkbox-sm'
								})),
								_react2.default.createElement(
									'span',
									{ className: 'sui-description permission-description' },
									(0, _utils.translate)('Access and configure global integrations.')
								),
								_react2.default.createElement(_checkbox2.default, _extends({}, this.props, {
									settings: this.state,
									updateProperty: this.updateProperty,
									property: 'manage_forminator_reports',
									label: (0, _utils.translate)('Reports'),
									itemClass: 'sui-checkbox-stacked sui-checkbox-sm'
								})),
								_react2.default.createElement(
									'span',
									{ className: 'sui-description permission-description' },
									(0, _utils.translate)('View reports and schedule email notifications for modules.')
								),
								_react2.default.createElement(_checkbox2.default, _extends({}, this.props, {
									settings: this.state,
									updateProperty: this.updateProperty,
									property: 'manage_forminator_settings',
									label: (0, _utils.translate)('Settings'),
									itemClass: 'sui-checkbox-stacked sui-checkbox-sm'
								})),
								_react2.default.createElement(
									'span',
									{ className: 'sui-description permission-description' },
									(0, _utils.translate)('Access and configure plugin settings.')
								)
							)
						)
					)
				),
				_react2.default.createElement(
					_footer2.default,
					{
						alignment: 'separated'
					},
					_react2.default.createElement(_close2.default, {
						label: (0, _utils.translate)('Cancel'),
						closeModal: this.closeModal,
						color: 'ghost'
					}),
					_react2.default.createElement(
						'div',
						{ className: 'btn-save-wrap', 'data-tooltip': this.validator().validationError },
						_react2.default.createElement(
							'button',
							{
								className: 'sui-button sui-button-blue forminator-save-field-settings',
								'data-tooltip': this.validator().validationError,
								onClick: this.savePermission,
								ref: this.saveBtn
							},
							_react2.default.createElement(
								'span',
								{ className: 'sui-loading-text' },
								saveBtn
							),
							_react2.default.createElement('i', { className: 'sui-icon-loader sui-loading', 'aria-hidden': 'true' })
						)
					)
				)
			);
		}
	}]);

	return permissionsModal;
}(_react.Component);

exports.default = permissionsModal;

/***/ }),
/* 826 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _axios = __webpack_require__(39);

var _axios2 = _interopRequireDefault(_axios);

var _qs = __webpack_require__(40);

var _qs2 = _interopRequireDefault(_qs);

var _utils = __webpack_require__(1);

var _notifications = __webpack_require__(30);

var _notifications2 = _interopRequireDefault(_notifications);

var _header = __webpack_require__(64);

var _header2 = _interopRequireDefault(_header);

var _title = __webpack_require__(66);

var _title2 = _interopRequireDefault(_title);

var _footer = __webpack_require__(87);

var _footer2 = _interopRequireDefault(_footer);

var _close = __webpack_require__(65);

var _close2 = _interopRequireDefault(_close);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var permissionDeleteModal = function (_Component) {
	_inherits(permissionDeleteModal, _Component);

	function permissionDeleteModal(props) {
		_classCallCheck(this, permissionDeleteModal);

		var _this = _possibleConstructorReturn(this, (permissionDeleteModal.__proto__ || Object.getPrototypeOf(permissionDeleteModal)).call(this, props));

		_this.closeModal = _this.props.modal.modalProps.closeModal.bind(_this);
		_this.deletePermission = _this.deletePermission.bind(_this);
		_this.showNotification = _this.showNotification.bind(_this);

		_this.userRoles = Object.assign({}, forminatorData.userRoles);
		_this.modalData = Object.assign({}, _this.props.modal.modalProps);
		return _this;
	}

	_createClass(permissionDeleteModal, [{
		key: 'showNotification',
		value: function showNotification(type, msg) {
			var custom = new _notifications2.default({
				type: type,
				text: 'error' === type ? (0, _utils.translate)('Something went wrong. Please try again.') : msg
			});

			custom.open();

			if ('error' === type) {
				console.log(msg);
			}

			this.closeModal();
		}
	}, {
		key: 'deletePermission',
		value: function deletePermission() {
			var _this2 = this;

			var permissions = this.props.permissions;

			permissions = permissions.filter(function (permission) {
				return permission.pid !== _this2.modalData.pid;
			});

			var permissionData = {
				action: 'forminator_save_permissions',
				_wpnonce: forminatorData.permission_nonce,
				mode: 'delete',
				pid: this.modalData.pid,
				permissions: JSON.stringify(permissions)
			};

			_axios2.default.post(forminatorData.ajaxUrl, _qs2.default.stringify(permissionData)).then(function (res) {
				if (res.data.success) {

					_this2.props.actions.permissionActions.updatePermissions(permissions);

					_this2.showNotification('success', (0, _utils.translate)('Permission successfully deleted.'));
				} else {
					_this2.showNotification('error', res.data.data);
				}
			}).catch(function (err) {
				_this2.showNotification('error', err);
			});
		}
	}, {
		key: 'render',
		value: function render() {
			var description = '';

			var permissionType = !_.isUndefined(this.modalData.permission_type) ? this.modalData.permission_type : 'role';

			if ('role' === permissionType) {

				description = (0, _utils.translate)('Are you sure you wish to delete the permissions rule for the {{b}}%(role)s{{/b}} user role?', {
					args: {
						role: this.userRoles[this.modalData.user_role].name
					},
					components: {
						b: _react2.default.createElement('b', null)
					}
				});
			} else {

				var descriptionPretext = (0, _utils.translate)('Are you sure you wish to delete the permissions for {{b}}%(firstName)s{{/b}} ', {
					args: {
						firstName: this.modalData.user_info[this.modalData.specific_user[0]].name
					},
					components: {
						b: _react2.default.createElement('b', null)
					}
				});

				if (this.modalData.specific_user.length > 1) {
					description = descriptionPretext.concat((0, _utils.translate)('and %(extra)s other user(s)?', {
						args: {
							extra: this.modalData.specific_user.length - 1
						}
					}));
				} else {
					description = descriptionPretext.concat('(' + this.modalData.user_info[this.modalData.specific_user[0]].email + ')?');
				}
			}

			return _react2.default.createElement(
				_react2.default.Fragment,
				null,
				_react2.default.createElement(
					_header2.default,
					{
						flatten: true,
						alignment: 'center',
						closeModal: this.closeModal,
						closeType: 'icon',
						customClass: 'sui-spacing-top--60'
					},
					_react2.default.createElement(_title2.default, {
						id: 'forminator-delete-permission-modal__title' // Missing id.
						, label: (0, _utils.translate)('Delete Permissions'),
						size: 'lg'
					}),
					_react2.default.createElement(
						'p',
						{ className: 'sui-description' },
						description
					)
				),
				_react2.default.createElement(
					_footer2.default,
					{
						customClass: 'sui-flatten sui-content-center'
					},
					_react2.default.createElement(_close2.default, {
						label: (0, _utils.translate)('Cancel'),
						closeModal: this.closeModal,
						customClass: 'sui-button-ghost'
					}),
					_react2.default.createElement(
						'button',
						{
							className: 'sui-button sui-button-ghost sui-button-red permission-delete-button',
							onClick: this.deletePermission
						},
						_react2.default.createElement(
							'span',
							{ className: 'sui-loading-text' },
							_react2.default.createElement('i', { className: 'sui-icon-trash', 'aria-hidden': 'true' }),
							(0, _utils.translate)('Delete')
						),
						_react2.default.createElement('i', { className: 'sui-icon-loader sui-loading', 'aria-hidden': 'true' })
					)
				)
			);
		}
	}]);

	return permissionDeleteModal;
}(_react.Component);

exports.default = permissionDeleteModal;

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYjk0NWM3YzRhNmI2NmM5OTA1MzMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiUmVhY3RcIiIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MvaW5wdXRzL2lucHV0LmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy9jb250YWluZXJzL2NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MvY29udGFpbmVycy9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzL2lucHV0cy9jb2xvci1waWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzL2lucHV0cy9yYWRpby10YWJzLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy9jb250YWluZXJzL3Jvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MvY29udGFpbmVycy90YWJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9yZWR1eC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MvY29udGFpbmVycy9lbXB0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzL2NvbnRhaW5lcnMvc2V0dGluZ3Mtcm93LmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy9pbnB1dHMvc3VpLXNlbGVjdDIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dhcm5pbmcvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MvaW5wdXRzL3N1aS1zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiUmVhY3RET01cIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MvaW5wdXRzL3RvZ2dsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9QYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vdGlmaWNhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3Rvcnkvbm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9Mb2NhdGlvblV0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy9jb250YWluZXJzL2FjY29yZGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MvaW5wdXRzL2NoZWNrYm94LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pMThuLXdwLXBsdWdpbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWluaW1hbGlzdGljLWFzc2VydC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbXBvbmVudHMvbW9kYWxzL3BhcnRpYWxzL2hlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL21vZGFscy9wYXJ0aWFscy9jbG9zZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL21vZGFscy9wYXJ0aWFscy90aXRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL2Nvbm5lY3RBZHZhbmNlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvd3JhcE1hcFRvUHJvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9ET01VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9MaW5rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JvdXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUm91dGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvZ2VuZXJhdGVQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXMvbGliL2Zvcm1hdHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9tb2RhbHMvcGFydGlhbHMvZm9vdGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJCbG9jay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2NsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2VtdmVyL3NlbXZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaTE4bi13cC1wbHVnaW4vbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pMThuLXdwLXBsdWdpbi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2kxOG4td3AtcGx1Z2luL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qZWQvamVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS8xLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvY29tbW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbnRlcnBvbGF0ZS1jb21wb25lbnRzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtYWRkb25zLWNyZWF0ZS1mcmFnbWVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW50ZXJwb2xhdGUtY29tcG9uZW50cy9saWIvdG9rZW5pemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xydS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaTE4bi13cC1wbHVnaW4vbGliL251bWJlci1mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2kxOG4td3AtcGx1Z2luL2xpYi9sb2NhbGl6ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JlYXRlLXJlYWN0LWNsYXNzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jcmVhdGUtcmVhY3QtY2xhc3MvZmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vYWN0aW9ucy9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVkdXgtdGh1bmsvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2NvbXBvbmVudHMvUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9TdWJzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvY29ubmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvc2hhbGxvd0VxdWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21hcERpc3BhdGNoVG9Qcm9wcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9lcy9wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyQXJnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tZXJnZVByb3BzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3NlbGVjdG9yRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC92ZXJpZnlTdWJzZWxlY3RvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvQnJvd3NlclJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVzb2x2ZS1wYXRobmFtZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFsdWUtZXF1YWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlSGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9IYXNoUm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL01lbW9yeVJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL01lbW9yeVJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9OYXZMaW5rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1Byb21wdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1Byb21wdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9SZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JlZGlyZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N0YXRpY1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1N0YXRpY1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Td2l0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Td2l0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvZ2VuZXJhdGVQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL21hdGNoUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy93aXRoUm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvd2l0aFJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idG9hLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXMvbGliL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kaXNwbGFjZS9kaXN0L2Rpc3BsYWNlLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy9pbnB1dHMvYWNlLWVkaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9zdG9yZS9jb25maWd1cmVTdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9yZWR1Y2Vycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9yZWR1Y2Vycy93cmFwcGVycy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9yZWR1Y2Vycy9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9yZWR1Y2Vycy9tb2RhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2xvYmFsL3JlZHVjZXJzL2ludGVncmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2xvYmFsL3JlZHVjZXJzL2JlaGF2aW9ycy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9yZWR1Y2Vycy9ub3RpZmljYXRpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL3JlZHVjZXJzL3BkZnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9tb2RhbHMvcGFydGlhbHMvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2Rlc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvZGVzaWduL2RlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2Rlc2lnbi9mbGF0LmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9kZXNpZ24vYm9sZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvZGVzaWduL21hdGVyaWFsLmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9kZXNpZ24vYmFzaWMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2Rlc2lnbi9ub25lLmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9mb3JtLWNvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2ZpZWxkcy1iYXNpY3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9yZXNwb25zZS1sb2FkaW5nLmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvcmVzcG9uc2UtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9yZXNwb25zZS1zdWNjZXNzLmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2lucHV0cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2lucHV0cy1leHRyYS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL3JhZGlvLmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvY29uc2VudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2Ryb3Bkb3duLmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvZHJvcGRvd24tc2VhcmNoLmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvbXVsdGktc2VsZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvY2FsZW5kYXItYmFzaWNzLmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvc2lnbmF0dXJlLmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvZ3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9yZXBlYXRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2NhbGVuZGFyLXRhYmxlLmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvcGFnaW5hdGlvbi1zdGVwcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL3BhZ2luYXRpb24tcHJvZ3Jlc3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9wYWdpbmF0aW9uLWJhY2suanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9wYWdpbmF0aW9uLW5leHQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9zdWJtaXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy91cGxvYWRlZC1maWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2ZpbGUtdXBsb2FkL3VwbG9hZC1wYW5lbC1zaW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9maWxlLXVwbG9hZC91cGxvYWQtcGFuZWwtbXVsdGlwbGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9maWxlLXVwbG9hZC91cGxvYWQtZmlsZS1tdWx0aXBsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2ZpbGUtdXBsb2FkL3VwbG9hZC1maWxlLWRlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvZm9udHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9zZXR0aW5ncy9mb250cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvZm9ybS1jb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2Zvcm0tY29udGFpbmVyL3BhZGRpbmctY3VzdG9tLmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9mb3JtLWNvbnRhaW5lci9ib3JkZXItY3VzdG9tLmpzIiwid2VicGFjazovLy8uL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9mb3JtLWNvbnRhaW5lci9zcGFjaW5nLWN1c3RvbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY3VzdG9tLWNzcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvcGFnZS1zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvcGRmL3BhZ2UtbWFyZ2luLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy9pbnB1dHMvc3VpLXRhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzLXBhZ2UvYWN0aW9ucy9tb2RhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MtcGFnZS9hY3Rpb25zL3Blcm1pc3Npb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy1wYWdlL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy1wYWdlL2FwcGVhcmFuY2UtcHJlc2V0cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MtcGFnZS9wZXJtaXNzaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MtcGFnZS9zdG9yZS9jb25maWd1cmVTdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MtcGFnZS9yZWR1Y2Vycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MtcGFnZS9yZWR1Y2Vycy9wZXJtaXNzaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MtcGFnZS9yZWR1Y2Vycy9tb2RhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MtcGFnZS9jb250YWluZXJzL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzLXBhZ2UvY29udGFpbmVycy9wZXJtaXNzaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MtcGFnZS9jb21wb25lbnRzL3Blcm1pc3Npb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy1wYWdlL2dsb2JhbC9oZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzLXBhZ2UvZ2xvYmFsL2Zvb3Rlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MtcGFnZS9jb21wb25lbnRzL3Blcm1pc3Npb25zL3Blcm1pc3Npb25zLXRhYmxlLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy1wYWdlL2NvbXBvbmVudHMvcGVybWlzc2lvbnMvcGVybWlzc2lvbi1pdGVtLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy1wYWdlL2NvbXBvbmVudHMvcGVybWlzc2lvbnMvcGVybWlzc2lvbi1pY29uLmpzIiwid2VicGFjazovLy8uL3NyYy9zZXR0aW5ncy1wYWdlL2NvbnRhaW5lcnMvbW9kYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NldHRpbmdzLXBhZ2UvY29tcG9uZW50cy9tb2RhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MtcGFnZS9jb21wb25lbnRzL21vZGFscy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MtcGFnZS9jb21wb25lbnRzL21vZGFscy9wZXJtaXNzaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2V0dGluZ3MtcGFnZS9jb21wb25lbnRzL21vZGFscy9wZXJtaXNzaW9uLWRlbGV0ZS5qcyJdLCJuYW1lcyI6WyJyYW5kTnVtYmVyIiwiZ2VuZXJhdGVXcmFwcGVySWQiLCJnZXRXcmFwcGVyIiwiZ2V0RGVmYXVsdFZhbHVlIiwiZ2V0VGhlbWVQcmVmaXgiLCJyZXN0cmljdGVkR3JvdXBGaWVsZHMiLCJsb25lckZpZWxkcyIsImdldFN1Ym1pc3Npb25CZWhhdmlvcnMiLCJjb3VudEZpZWxkc0J5VHlwZSIsImdldE1heElEQnlUeXBlIiwiZ2V0TWF4SUQiLCJnZW5lcmF0ZVZhbHVlIiwiaGFzRmllbGRUeXBlIiwiZ2V0RmllbGRzQnlUeXBlIiwibWFwRmllbGRzQnlUeXBlIiwiZ2V0RmllbGRMYWJlbCIsImZpZWxkRXhpc3QiLCJidWlsZEZpZWxkT2JqZWN0IiwiYnVpbGRGaWVsZE9iamVjdEZyb21TbHVnIiwiZ2V0RmllbGRUeXBlIiwiZ2V0Rm9ybWluYXRvckZpZWxkIiwiaW5zZXJ0SW5Qb3NpdGlvbiIsInJlcGxhY2VJblBvc2l0aW9uIiwidHJhbnNsYXRlIiwiZ2V0Rm9udFZhcmlhbnRzIiwidWNmaXJzdCIsImdldENvbmRpdGlvbkxhYmVsIiwiY29udmVydFRpbWVzdGFtcCIsImdldEZpZWxkcyIsImdldERhdGVGaWVsZHMiLCJnZXROYW1lRmllbGRzIiwiZ2V0UmFuZ2VTbGlkZXJGaWVsZHMiLCJmaWVsZEhhc051bWJlciIsImZpZWxkSGFzQ2FsY3MiLCJmaWVsZEZvcm11bGEiLCJmaWVsZEhhc09wdGlvbnMiLCJnZXRGaWVsZFZhbHVlcyIsImdldEFkZHJlc3NGaWVsZHMiLCJnZXRUaW1lRmllbGRzIiwiZ2V0RmllbGRBdXRvZmlsbFByb3ZpZGVycyIsImdldFJ1bGVMYWJlbCIsImlzRW1haWxXcCIsInN1aURlbGVnYXRlRXZlbnRzIiwiZ2V0Q2hhcnRUeXBlIiwiZ2V0Q2FsY3VsYXRpb25GaWVsZHMiLCJzZWxlY3QyVGFncyIsImlzRmllbGRSZXF1aXJlZCIsImhhc0ZpZWxkV2l0aEF0dHJpYnV0ZSIsImhhc1Bvc3RkYXRhRmllbGRXaXRoTXVsdGlzZWxlY3QiLCJnZXRQZXJzb25hbGl0eVF1ZXN0aW9ucyIsImdldFBsYW5WYWxpZGF0aW9uIiwiaXNUcnVlIiwicGFyc2VRdWVyeVN0cmluZyIsImdvVG9MaW5rIiwibWluIiwiTWF0aCIsImNlaWwiLCJtYXgiLCJmbG9vciIsInJhbmRvbSIsIndyYXBwZXJJRCIsIndyYXBwZXJzIiwid3JhcHBlck9iamVjdCIsIm1hcCIsIndyYXBwZXIiLCJ3cmFwcGVyX2lkIiwicHJvcHMiLCJnZXRUaGVtZU5hbWUiLCJmb3JtRGVzaWduIiwic2V0dGluZ3MiLCJxdWl6RGVzaWduIiwidHlwZSIsImNvdW50ZXIiLCJmaWVsZHMiLCJmaWVsZCIsImZpZWxkSURzIiwiZmllbGRJZCIsImVsZW1lbnRfaWQiLCJmaWVsZElkQXJyYXkiLCJzcGxpdCIsInB1c2giLCJwYXJzZUludCIsIm1heFZhbHVlIiwiXyIsImlzRW1wdHkiLCJ2YWx1ZXMiLCJpZHMiLCJ2YWx1ZSIsInRyaW0iLCJyZXBsYWNlIiwiaXNHbG9iYWxQcmVzZXQiLCJmaWVsZHNCeVR5cGUiLCJsYWJlbCIsImZpZWxkX2xhYmVsIiwiaWQiLCJleGlzdCIsImNvbHMiLCJ0ZW1wTmV3RmllbGRzIiwid3JhcHMiLCJmaWVsZE51bWJlciIsImV4dGVuZCIsImZvcm1JRCIsInNsdWciLCJmb3JtaW5hdG9yRGF0YSIsImZpbmQiLCJmaWVsZERhdGEiLCJvcHRpb25zIiwiY29uZGl0aW9ucyIsImNvbnRhaW5zIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiZGVmYXVsdHMiLCJmb3JtaW5hdG9yRmllbGQiLCJhcnJheSIsInBvc2l0aW9uIiwicmVwbGFjZW1lbnQiLCJzbGljZSIsImkxOG4iLCJhcHBseSIsImFyZ3VtZW50cyIsImZvbnRzIiwiZm9udE9iamVjdCIsImZpbHRlciIsImZvbnQiLCJmYW1pbHkiLCJpc1VuZGVmaW5lZCIsInZhcmlhbnRzIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJjb25kaXRpb24iLCJ2YWx1ZUxhYmVsIiwiaGFzT3B0aW9ucyIsImxlbmd0aCIsIndoZXJlIiwiZmllbGRfdHlwZSIsImluY2x1ZGVzIiwicnVsZSIsImlzTmFOIiwiTnVtYmVyIiwiZGF0ZSIsIkRhdGUiLCJkYXkiLCJtb250aCIsInllYXIiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJkaXNhYmxlZEZpZWxkcyIsImV4dHJhIiwiaW5jbHVkZWRGaWVsZHMiLCJleGNsdWRlU3ViRmllbGRzIiwiZmllbGRzQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJtYWluX2RhdGVfZmllbGQiLCJwYXJlbnRHcm91cCIsInBhcmVudF9ncm91cCIsImNvbmNhdCIsInNsaWRlcl90eXBlIiwicmVxdWlyZWQiLCJmaWVsZF9zbHVnIiwiaGFzQ2FsY3MiLCJmb3JtdWxhIiwiaXNOdW1iZXIiLCJmaWVsZExhYmVsIiwiZGF5X2xhYmVsIiwibW9udGhfbGFiZWwiLCJ5ZWFyX2xhYmVsIiwibXVsdGlwbGVfbmFtZSIsImF0dHIiLCJlbGVtZW50X3N1ZmZpeCIsImF0dHJpYnV0ZSIsInN1ZmZpeCIsImNhbGN1bGF0aW9ucyIsImhoX2xhYmVsIiwibW1fbGFiZWwiLCJ0aW1lX3R5cGUiLCJmaWVsZFR5cGUiLCJhdXRvZmlsbFByb3ZpZGVycyIsImZpZWxkU2V0dGluZ3MiLCJhdXRvZmlsbF9zZXR0aW5ncyIsInZhbCIsImluZGV4T2YiLCJwYXJ0cyIsIm1hdGNoIiwiZG9tYWluIiwic3VicyIsInN1YnNMZW4iLCJpIiwid2luZG93IiwiU1VJIiwic2V0VGltZW91dCIsInN1aUFjY29yZGlvbiIsImpRdWVyeSIsInN1aVRhYnMiLCJlYWNoIiwic2VsZWN0IiwiaW5pdEljb24iLCJpbml0Q29sb3IiLCJpbml0U2VhcmNoIiwiaW5pdCIsImluaXRWYXJzIiwibG9hZENpcmNsZVNjb3JlIiwic2hvd0hpZGVQYXNzd29yZCIsImRpc2FibGVkIiwiJGVsIiwiYWxsb3dDbGVhciIsImRyb3Bkb3duQ3NzQ2xhc3MiLCJvbiIsImUiLCJlbG0iLCJwYXJhbXMiLCJkYXRhIiwiZWxlbWVudCIsIiRlbG0iLCIkdCIsImFwcGVuZCIsInRyaWdnZXIiLCJTVUlzZWxlY3QyIiwicG9zdF9jYXRlZ29yeSIsInBvc3RDYXRlZ29yaWVzIiwicG9zdF90eXBlIiwiY2F0ZWdvcnlfa2V5IiwiY2F0ZWdvcnkiLCJjdXJyZW50UGVyc29uYWxpdHkiLCJxdWVzdGlvbnMiLCJwZXJzb25hbGl0eVNsdWciLCJxdWVzdGlvbnNBcnJheSIsInF1ZXN0aW9uIiwia2V5UXVlc3Rpb24iLCJhbnN3ZXJzIiwiYW5zd2VyIiwia2V5QW5zd2VyIiwicmVzdWx0IiwidGl0bGUiLCJ1bmlxIiwidmFsaWRhdGlvbiIsInBheW1lbnRzIiwicGF5bWVudEluZGV4IiwicGF5bWVudCIsImluZGV4IiwiYW1vdW50X3R5cGUiLCJwbGFuX25hbWUiLCJlcnJvciIsImlzVmFsaWQiLCJwYXltZW50X21ldGhvZCIsImFtb3VudCIsInZhcmlhYmxlIiwic3Vic2NyaXB0aW9uQW1vdW50Iiwic3Vic2NyaXB0aW9uX2Ftb3VudF90eXBlIiwic3Vic2NyaXB0aW9uUXVhbnRpdHkiLCJxdWFudGl0eV90eXBlIiwiUXVhbnRpdHkiLCJxdWFudGl0eSIsIkJpbGxJbnB1dCIsImJpbGxfaW5wdXQiLCJzdWJzY3JpcHRpb25fYW1vdW50Iiwic3Vic2NyaXB0aW9uX3ZhcmlhYmxlIiwidmFyaWFibGVfcXVhbnRpdHkiLCJwYXltZW50S2V5IiwidG9Mb3dlckNhc2UiLCJwYXJzZWRQYXJhbWV0ZXJzIiwidXJpUGFyYW1ldGVycyIsImxvY2F0aW9uIiwic2VhcmNoIiwic3Vic3RyaW5nIiwicGFyYW1ldGVyIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwibGluayIsInRhcmdldCIsIm9wZW4iLCJJbnB1dCIsInVwZGF0ZVZhbHVlIiwiYmluZCIsInVwZGF0ZVByb3BlcnR5IiwicHJvcGVydHkiLCJhY3Rpb25zIiwic2V0dGluZ3NBY3Rpb25zIiwidXBkYXRlU2V0dGluZyIsImlzUmVxdWlyZWQiLCJpc1Bvc2l0aXZlIiwiZGVmYXVsdFZhbHVlIiwicmVxdWlyZWRFcnJvciIsImhhc0Vycm9yQ2xhc3MiLCJmaWVsZENsYXNzIiwiaW5wdXRDbGFzcyIsInByZWZpeCIsImlucHV0SWQiLCJpbnB1dExhYmVsIiwiZGFya0xhYmVsIiwibm90ZSIsImlucHV0RmllbGQiLCJwbGFjZWhvbGRlciIsIm5vdFdyaXRhYmxlIiwicmVhZG9ubHkiLCJtaW5WYWx1ZSIsInN0ZXAiLCJtYXhMZW5ndGgiLCJpbnB1dFN0eWxlcyIsInN0eWxlIiwiY2FuVHJhc2giLCJkZXNjcmlwdGlvbiIsInNpbXBsZSIsIkNvbXBvbmVudCIsIkNvbnRhaW5lciIsImNoaWxkcmVuIiwiUmVhY3QiLCJDaGlsZHJlbiIsImNoaWxkIiwiQ29sIiwiY3VzdG9tQ2xhc3MiLCJDb2xvclBpY2tlciIsImVsIiwid3BDb2xvclBpY2tlciIsImNoYW5nZSIsImV2ZW50IiwidWkiLCIkdGhpcyIsImNvbG9yIiwidG9DU1MiLCJwYWxldHRlcyIsIiRzdWlQaWNrZXJJbnB1dCIsIiRzdWlQaWNrZXIiLCJjbG9zZXN0IiwiJHN1aVBpY2tlckNvbG9yIiwiJHN1aVBpY2tlclZhbHVlIiwiJHN1aVBpY2tlckNsZWFyIiwiJHdwUGlja2VyIiwiJHdwUGlja2VyQnV0dG9uIiwiJHdwUGlja2VyQWxwaGEiLCIkd3BQaWNrZXJDbGVhciIsIiRwaWNrZXJCYWNrZ3JvdW5kIiwiY3NzIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJjbGljayIsIm9mZiIsInVuYmluZCIsInJlbW92ZURhdGEiLCJpc0FscGhhIiwiYmFja2dyb3VuZENvbG9yIiwiUmFkaW9UYWJzIiwiZGVmYXVsdCIsInRhYlRpdGxlcyIsInRhYiIsIm9wYWNpdHkiLCJjdXJzb3IiLCJ0b2dnbGVWYWx1ZSIsImNvbnRlbnRDbGFzcyIsImRpdkNsYXNzIiwidGFiQ29udGVudHMiLCJib3hDbGFzcyIsIm5hbWUiLCJ0YWJzTGFiZWwiLCJzZXR0aW5nc0xhYmVsIiwibGFiZWxDbGFzcyIsIm1hcmdpbkJvdHRvbSIsIndyYXBwZXJDbGFzcyIsImJhc2ljVGFicyIsInRhYnNNYXJrdXAiLCJSb3ciLCJjb2x1bW5zIiwiY2xhc3MiLCJUYWJzIiwic3RhdGUiLCJhY3RpdmUiLCJzZXRTdGF0ZSIsImV4dHJhQ2xhc3MiLCJpc051bGwiLCJib3hDbGFzc1ZhbHVlIiwiRW1wdHkiLCJTZXR0aW5nc1JvdyIsImNvbnRlbnQiLCJsYWJlbERhcmsiLCJkZXNjcmlwdGlvblNwYWNpbmciLCJzaWRlYmFyIiwiY29uZGl0aW9uYWxTdHlsZXMiLCJsYXN0Q2hpbGQiLCJib3JkZXJCb3R0b20iLCJTdWlTZWxlY3QyIiwiYWZ0ZXJTYXZlIiwicGFyZW50IiwicGFyZW50SWQiLCJoYXNTZWFyY2giLCJPYmplY3QiLCJhc3NpZ24iLCJkcm9wZG93blBhcmVudCIsIm1pbmltdW1SZXN1bHRzRm9yU2VhcmNoIiwiaGFzQ2xhc3MiLCJ3aWR0aCIsIkZVSXNlbGVjdDIiLCJFcnJvciIsInRyaWdnZXJDaGFuZ2UiLCJzZWxlY3RJZCIsImVsZW1lbnRJZCIsIm11bHRpcGxlIiwiZm9ybVR5cGUiLCJub1dyYXBwZXIiLCJzdGF0aWNDb250ZXh0IiwiZmllbGRTaXplIiwic2VsZWN0UHJvcHMiLCJnZXRTZWxlY3QiLCJnZXRFbGVtZW50IiwiZmllbGRzaXplIiwibWF4V2lkdGgiLCJtYXJnaW5Ub3AiLCJTdWlTZWxlY3QiLCJzZWxlY3RDbGFzcyIsImVsZW1lbnRDbGFzcyIsInNlbGVjdExhYmVsIiwic2VsZWN0RmllbGQiLCJnZXRGaWVsZCIsIlRvZ2dsZSIsImNoZWNrZWQiLCJ0b2dnbGVDb250ZW50Iiwic3ViVG9nZ2xlIiwidW5XcmFwIiwiTm90aWZpY2F0aW9uIiwicHJlcGVuZCIsInJlbW92ZSIsImluaXRpYWxpemUiLCIkbm90aWZpY2F0aW9uIiwibm90aWNlSWQiLCJub3RpY2VNZXNzYWdlIiwidGV4dCIsIm5vdGljZU9wdGlvbnMiLCJhdXRvY2xvc2UiLCJ0aW1lb3V0IiwidGltZSIsImRpc21pc3MiLCJzaG93Iiwib3Blbk5vdGljZSIsImNsb3NlTm90aWNlIiwiQWNjb3JkaW9uIiwiZXhwYW5kZWQiLCJ0b2dnbGVTdGF0ZSIsImJveGVkQ29udGVudCIsImRlZmF1bHRDb250ZW50UmVuZGVyIiwiYWNjb3JkaW9uQ29udGVudHMiLCJDaGVja2JveCIsIml0ZW1DbGFzcyIsInRvb2x0aXAiLCJtYXJnaW5MZWZ0IiwidmVydGljYWxBbGlnbiIsInBvaW50ZXJFdmVudHMiLCJNb2RhbEhlYWRlciIsImNsb3NlTW9kYWwiLCJhbGlnbm1lbnQiLCJmbGF0dGVuIiwiaGFzQ2xvc2UiLCJjYW5DbG9zZSIsImNsb3NlVHlwZSIsImNsb3NlQ29sb3IiLCJoYXNJbWFnZSIsImltYWdlTmFtZSIsImlzTG9nbyIsImltYWdlTG9nbyIsImhhc0FsdCIsImltYWdlQWx0IiwiZWxDbGFzcyIsIm1hcmt1cCIsIk1vZGFsQ2xvc2UiLCJpc0ljb24iLCJpc0hpZGRlbiIsInNyb25seSIsImhhc0ljb24iLCJpY29uIiwiZmxvYXRzTGVmdCIsImZsb2F0IiwiZmxvYXRzUmlnaHQiLCJoYXNDdXN0b21DbGFzcyIsIk1vZGFsVGl0bGUiLCJ0aXRsZUlkIiwidGl0bGVMYWJlbCIsInRpdGxlVGFnIiwidGFnIiwidGl0bGVUYWdDb2xvciIsInRhZ0NvbG9yIiwidGl0bGVDbGFzcyIsInNpemUiLCJNb2RhbEZvb3RlciIsImZvb3RlckNoaWxkcmVuIiwicmVuZGVyQmxvY2siLCJjb250YWluZXJJZCIsImNvbnRhaW5lciIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJzZW12ZXIiLCJndGUiLCJ2ZXJzaW9uIiwicm9vdCIsInJlbmRlciIsInNldHRpbmciLCJmb3JtaW5hdG9yQ2hhbmdlcyIsImRpc3BhdGNoIiwidXBkYXRlU2V0dGluZ3MiLCJyZXNldFNldHRpbmdzIiwic2F2ZUJ1aWxkZXIiLCJzYXZlZCIsIkFjZUVkaXRvciIsImluc2VydFNlbGVjdG9yIiwiZWRpdG9yIiwiYWNlIiwiZWRpdCIsInNlc3Npb24iLCJnZXRTZXNzaW9uIiwic2V0VXNlV29ya2VyIiwic2V0U2hvd1ByaW50TWFyZ2luIiwic2V0TW9kZSIsInNldFRoZW1lIiwicmVuZGVyZXIiLCJzZXRTaG93R3V0dGVyIiwic2V0SGlnaGxpZ2h0QWN0aXZlTGluZSIsImZvY3VzIiwiZGVzdHJveSIsInNlbGVjdG9yIiwibmF2aWdhdGVGaWxlRW5kIiwiaW5zZXJ0IiwibmF2aWdhdGVMZWZ0IiwiZ2V0VmFsdWUiLCJiYXNpY1NlbGVjdG9ycyIsInBvbGxTZWxlY3RvcnMiLCJxdWl6U2VsZWN0b3JzIiwicGRmU2VsZWN0b3JzIiwiaGVpZ2h0IiwiY29uZmlndXJlU3RvcmUiLCJuZXdDcmVhdGVTdG9yZSIsInRodW5rIiwiY3JlYXRlU3RvcmUiLCJpbml0aWFsU3RhdGUiLCJhcHBSZWR1Y2VycyIsIm1vZGFsIiwiaW50ZWdyYXRpb25Db25kaXRpb25zIiwiYmVoYXZpb3JBcnJheSIsIm5vdGlmaWNhdGlvbnMiLCJwZGZzIiwidXBkYXRlRmllbGQiLCJhY3Rpb24iLCJ3cmFwcGVySW5kZXgiLCJmaW5kSW5kZXgiLCJ3cmFwIiwidXBkYXRlVGl0bGUiLCJmb3JtTmFtZSIsIm5ld1N0YXRlIiwibW9kYWxUeXBlIiwibW9kYWxQcm9wcyIsImJlaGF2aW9ycyIsInVwZGF0ZUJlaGF2aW9yQXJyYXkiLCJiZWhhdmlvciIsImJlaGF2aW9ySW5kZXgiLCJub3RpZnkiLCJ1cGRhdGVOb3RpZmljYXRpb24iLCJub3RpZmljYXRpb24iLCJub3RpZmljYXRpb25JbmRleCIsIk1vZGFsSW1hZ2UiLCJpbWFnZSIsImZpbGVuYW1lIiwiZ2V0Y2xhc3MiLCJnZXRhbHQiLCJsb2dvIiwiYWx0IiwiaW1hZ2VzVXJsIiwiRGVzaWduU3R5bGUiLCJkZXNpZ25EZWZhdWx0IiwiZGVzaWduRmxhdCIsImRlc2lnbkJvbGQiLCJkZXNpZ25NYXRlcmlhbCIsIkRlc2lnbkJhc2ljIiwiZGVzaWduTm9uZSIsImRpc3BsYXkiLCJDb2xvcnMiLCJsb2FkRm9udHMiLCJmb3JtaW5hdG9yRm9udHMiLCJpc09iamVjdCIsIl93cG5vbmNlIiwiZ0ZvbnROb25jZSIsImF4aW9zIiwicG9zdCIsImFqYXhVcmwiLCJxcyIsInRoZW4iLCJyZXNwb25zZSIsImNhdGNoIiwiZXJyIiwiY29uc29sZSIsImxvZyIsImhhc1BhZ2luYXRpb24iLCJoYXNTZWN0aW9uIiwiaGFzU2luZ2xlUmFkaW8iLCJoYXNTaW5nbGVEcm9wZG93biIsImhhc011bHRpQ2hlY2tib3giLCJoYXNNdWx0aVNlbGVjdCIsImhhc0RhdGVQaWNrZXIiLCJoYXNFU2lnbiIsImhhc0dyb3VwIiwiaGFzRGF0ZURyb3Bkb3duIiwiaGFzVGltZURyb3Bkb3duIiwiaGFzQWRkcmVzQ291bnRyeSIsImhhc05hbWVQcmVmaXgiLCJoYXNHRFBSIiwiaGFzRmlsZVVwbG9hZCIsImhhc0N1cnJlbmN5IiwiaGFzU3RyaXBlIiwiaGFzQ2FsY3VsYXRpb24iLCJoYXNDb25zZW50IiwicG9zdGRhdGFfbXVsdGlwbGUiLCJpc1ByZXNldCIsInByZXNldCIsImhhc0luZGljYXRvciIsImhhc0luZGljYXRvckVuYWJsZWQiLCJoYXNQYWdpbmF0aW9uSGVhZGVyIiwicGFnaW5hdGlvbkRhdGEiLCJwYWdpbmF0aW9uSGVhZGVyIiwiQmFzaWNDb2xvcnMiLCJHbG9iYWxDb2xvcnMiLCJSZXNwb25zZUxvYWRpbmdDb2xvcnMiLCJSZXNwb25zZUVycm9yQ29sb3JzIiwiUmVzcG9uc2VTdWNjZXNzQ29sb3JzIiwiU2VjdGlvbkNvbG9ycyIsIklucHV0c0NvbG9ycyIsIklucHV0RXh0cmFDb2xvcnMiLCJSYWRpb0NvbG9ycyIsIkNvbnNlbnRDb2xvcnMiLCJTZWxlY3RDb2xvcnMiLCJEcm9wZG93bkNvbG9ycyIsIlNlYXJjaENvbG9ycyIsIk11bHRpU2VsZWN0Q29sb3JzIiwiQ2FsZW5kYXJDb2xvcnMiLCJTaWduYXR1cmUiLCJHcm91cENvbG9ycyIsIlJlcGVhdGVyQ29sb3JzIiwiU3RlcHNDb2xvcnMiLCJQcm9ncmVzc0NvbG9ycyIsIkJhY2tDb2xvcnMiLCJOZXh0Q29sb3JzIiwiU3VibWl0Q29sb3JzIiwiVXBsb2FkZWRGaWxlc0NvbG9ycyIsImhhc1NpbmdsZVVwbG9hZCIsImhhc011bHRpVXBsb2FkIiwiU2luZ2xlVXBsb2FkUGFuZWxDb2xvcnMiLCJNdWx0aVVwbG9hZFBhbmVsQ29sb3JzIiwiTXVsdGlVcGxvYWRGaWxlQ29sb3JzIiwiRmlsZURlbGV0ZUJ1dHRvbkNvbG9ycyIsIkZvbnRzIiwiY29tcG9uZW50cyIsIlN1Rm9udFNldHRpbmdzaVNlbGVjdCIsInZhcmlhbnQiLCJwcmVmaXhUaGVtZSIsImRlZmF1bHRGb250IiwiZmN1cyIsImRlZmF1bHRDdXN0b20iLCJkZWZhdWx0V2VpZ2h0IiwiZGVmYXVsdFNpemUiLCJmb250VmFyaWFudHMiLCJiYWNrd2FyZHNDb21wYXQiLCJmb250RGF0YSIsImZhbWlseU9ubHkiLCJmb250VmFyaWFudCIsIkZvcm1Db250YWluZXIiLCJwYWRkaW5nQ3VzdG9tIiwiYm9yZGVyQ3VzdG9tIiwic3BhY2luZ0N1c3RvbSIsIkN1c3RvbUNzcyIsIlBhZ2VTZXR0aW5ncyIsInBkZl9wYWdlX3NpemVzIiwia2V5IiwicGFnZU1hcmdpbiIsIlN1aVRhZ3MiLCJoYW5kbGVDaGFuZ2UiLCJzZWxmIiwicGVybWlzc2lvbl90eXBlIiwidXNlcl9pbmZvIiwidXNlckluZm9zIiwib3B0aW9uIiwiZW1haWwiLCJwcmV2UHJvcHMiLCJwcmV2U3RhdGUiLCJ1c2VyX3JvbGUiLCJzaG93TW9kYWwiLCJoaWRlTW9kYWwiLCJ1cGRhdGVQZXJtaXNzaW9ucyIsInBlcm1pc3Npb25zIiwicHJlc2V0SWQiLCJjdXJyZW50UHJlc2V0Iiwic3RvcmUiLCJzZXRMb2NhbGUiLCJmb3JtaW5hdG9ybDEwbiIsImxvY2FsZSIsImpRdWVyeUZvcm1pIiwibm9Db25mbGljdCIsIm1hcFN0YXRlVG9Qcm9wcyIsIm1hcERpc3BhdGNoVG9Qcm9wcyIsImhhbmRsZUJlZm9yZXVubG9hZCIsInJldHVyblZhbHVlIiwic2F2ZUFwcGVhcmFuY2VQcmVzZXQiLCIkdGFyZ2V0IiwiYWRkQ2xhc3MiLCJvYmplY3QiLCJwcmVzZXROb25jZSIsInN1Y2Nlc3MiLCJzZXRIYXNVcGRhdGVkIiwiY3VzdG9tIiwicmVtb3ZlQ2xhc3MiLCJjaGFuZ2VQcmVzZXQiLCJjdXJyZW50VGFyZ2V0IiwiZGl2X3ByZWxvYWRlciIsImh0bWwiLCJGb3JtaW5hdG9yIiwib3BlblByZXNldCIsImRlbGV0ZVByZXNldCIsInByZXNldF9pZCIsImFqYXgiLCJ1cmwiLCJEYXRhIiwiQXBwZWFyYW5jZSIsInVzZVN0YXRlIiwiaGFzVXBkYXRlZCIsInNhdmUiLCJ1c2VFZmZlY3QiLCJhZGRFdmVudExpc3RlbmVyIiwiZm9udFN0eWxlIiwiZmlyc3QiLCJBcHBlYXJhbmNlQ29udGFpbmVyIiwibWFpblNldHRpbmdzIiwiTWFpbiIsImdvVG9TZWN0aW9uRnJvbVVybCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJnb1RvU2VjdGlvbiIsImdvdG9zZWN0aW9uIiwidGhlVXJsIiwiaHJlZiIsImhpc3RvcnkiLCJyZXBsYWNlU3RhdGUiLCJtb2RhbEFjdGlvbnMiLCJwZXJtaXNzaW9uQWN0aW9ucyIsIlBlcm1pc3Npb25zIiwidG9vbHRpcFdpZHRoIiwiSGVhZGVyIiwicHJvcCIsIkZvb3RlciIsIm5ldyIsIlBlcm1pc3Npb25zVGFibGUiLCJub2RlIiwicmVmcyIsIlN0aWNreUhlYWRlciIsImN1cnJlbnRPZmZzZXQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3AiLCJzdGlja3lPZmZzZXQiLCJnZXRDb21wdXRlZFN0eWxlIiwiaXNTdHVjayIsImNsYXNzTGlzdCIsImFkZCIsInBlcm1pc3Npb24iLCJQZXJtaXNzaW9uSXRlbSIsInBlcm1pc3Npb25NZW51IiwiY3JlYXRlUmVmIiwiZGVsZXRlTW9kYWwiLCIkcGVybWlzc2lvbiIsImN1cnJlbnQiLCJub3QiLCJ0b2dnbGVDbGFzcyIsImNvdW50IiwiYWNjb3JkaW9uVGltZW91dCIsInVzZXJJZHMiLCJzcGVjaWZpY191c2VyIiwiY3VycmVudFVzZXIiLCJpc0FkbWluIiwiYWNjZXNzTGlzdCIsInJvbGVJbWFnZSIsInJvbGVOYW1lIiwicm9sZURlc2MiLCJpdGVtTmFtZSIsImNvdW50RXhjbHVkZWQiLCJleGNsdWRlX3VzZXJzIiwidXNlclJvbGVzIiwidXNlcnMiLCJ0b29sdGlwVGV4dCIsImF2YXRhciIsImluZm8iLCJ1c2VySWQiLCJhY2Nlc3MiLCJ4IiwiUGVybWlzc2lvbkljb24iLCJNb2RhbCIsIk1PREFMX1RZUEVTIiwibW9kYWxUeXBlcyIsInBlcm1pc3Npb25zTW9kYWwiLCJwZXJtaXNzaW9uRGVsZXRlIiwicGVybWlzc2lvbkRlbGV0ZU1vZGFsIiwibW9kYWxFbGVtZW50IiwiUmVhY3RET00iLCJmaW5kRE9NTm9kZSIsImZvY3VzQWZ0ZXJDbG9zZWQiLCJhY3RpdmVFbGVtZW50IiwiZm9jdXNGaXJzdCIsInNldEZvY3VzIiwiaGlkZU1vZGFsVGltZW91dCIsInNldEF0dHJpYnV0ZSIsImZvcmNlVXBkYXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiZm9jdXNJbnRlcnZhbCIsImZvY3VzVG90YWxSZXBldGl0aW9ucyIsImJsdXIiLCJmb2N1c1JlcGV0aXRpb25zIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJjbGVhclRpbWVvdXQiLCJtb2RhbENsYXNzIiwib3ZlcmxheUNsYXNzIiwiU3BlY2lmaWVkTW9kYWwiLCJzbU1vZGFsVHlwZSIsImNsYXNzZXMiLCJqb2luIiwibGFiZWxsZWRCeSIsImRlc2NyaWJlZEJ5IiwiRGlzcGxhY2VkTW9kYWwiLCJyZW5kZXJUbyIsImlucHV0IiwibW9kdWxlIiwiZXhwb3J0cyIsInNhdmVCdG4iLCJzYXZlUGVybWlzc2lvbiIsInZhbGlkYXRvciIsInNob3dOb3RpZmljYXRpb24iLCJ1cGRhdGVkIiwibW9kYWxEYXRhIiwiZ2V0VXNlclJvbGVzIiwiZGVmYXVsdFJvbGUiLCJrZXlzIiwiZGVmYXVsdFR5cGUiLCJwaWQiLCJtYW5hZ2VfZm9ybWluYXRvcl9tb2R1bGVzIiwibWFuYWdlX2Zvcm1pbmF0b3Jfc3VibWlzc2lvbnMiLCJtYW5hZ2VfZm9ybWluYXRvcl9hZGRvbnMiLCJtYW5hZ2VfZm9ybWluYXRvcl9pbnRlZ3JhdGlvbnMiLCJtYW5hZ2VfZm9ybWluYXRvcl9yZXBvcnRzIiwibWFuYWdlX2Zvcm1pbmF0b3Jfc2V0dGluZ3MiLCJjdXJyZW50X3VzZXIiLCIkc2F2ZUJ0biIsImZvckVhY2giLCJyb2xlIiwicCIsIiRwcm9wZXJ0eSIsInNlYXJjaERhdGEiLCJhcmdzIiwic2VhcmNoTm9uY2UiLCJleGNsdWRlX2FkbWlucyIsInEiLCJ0ZXJtIiwiaXNfcGVybWlzc2lvbiIsInRhZ3MiLCJtaW5pbXVtSW5wdXRMZW5ndGgiLCJ0b2tlblNlcGFyYXRvcnMiLCJsYW5ndWFnZSIsInNlYXJjaGluZyIsIm5vUmVzdWx0cyIsImRlbGF5IiwicHJvY2Vzc1Jlc3VsdHMiLCJyZXN1bHRzIiwiY2FjaGUiLCJ0ZW1wbGF0ZVJlc3VsdCIsImRpc3BsYXlfbmFtZSIsImNyZWF0ZVRhZyIsIm1zZyIsInBlcm1pc3Npb25zRGF0YSIsInBlcm1pc3Npb25fbm9uY2UiLCJtb2RlIiwiY3VycmVudFBlcm1pc3Npb24iLCJzcGxpY2UiLCJub3RpZlR5cGUiLCJub3RpZk1lc3NhZ2UiLCJ2YWxpZGF0aW9uRXJyb3IiLCJpc1R5cGVWYWxpZCIsImlzQWNjZXNzVmFsaWQiLCJlZGl0Tm90aWNlIiwiaXNOZXciLCJtb2RhbFRpdGxlIiwicGVybWlzc2lvblR5cGUiLCJiIiwibnVtVXNlcnMiLCJ1c2VyTmFtZSIsInVzZXJFbWFpbCIsImdldFVzZXJUYWdzT3B0aW9ucyIsImRlbGV0ZVBlcm1pc3Npb24iLCJwZXJtaXNzaW9uRGF0YSIsInJlcyIsImRlc2NyaXB0aW9uUHJldGV4dCIsImZpcnN0TmFtZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDN0RBLHVCOzs7Ozs7Ozs7Ozs7Ozs7UUNNZ0JBLFUsR0FBQUEsVTtRQVlBQyxpQixHQUFBQSxpQjtRQVlBQyxVLEdBQUFBLFU7UUFtQkFDLGUsR0FBQUEsZTtRQVVBQyxjLEdBQUFBLGM7UUE2QkFDLHFCLEdBQUFBLHFCO1FBVUFDLFcsR0FBQUEsVztRQVNBQyxzQixHQUFBQSxzQjtRQWdCQUMsaUIsR0FBQUEsaUI7UUFzQkFDLGMsR0FBQUEsYztRQWtDQUMsUSxHQUFBQSxRO1FBMEJBQyxhLEdBQUFBLGE7UUF3QkFDLFksR0FBQUEsWTtRQTBCQUMsZSxHQUFBQSxlO1FBc0JBQyxlLEdBQUFBLGU7UUE0QkFDLGEsR0FBQUEsYTtRQW9CQUMsVSxHQUFBQSxVO1FBeUJBQyxnQixHQUFBQSxnQjtRQXFCQUMsd0IsR0FBQUEsd0I7UUFpQ0FDLFksR0FBQUEsWTtRQWVBQyxrQixHQUFBQSxrQjtRQWFBQyxnQixHQUFBQSxnQjtRQWFBQyxpQixHQUFBQSxpQjtRQVdBQyxTLEdBQUFBLFM7UUFZQUMsZSxHQUFBQSxlO1FBa0JBQyxPLEdBQUFBLE87UUFTQUMsaUIsR0FBQUEsaUI7UUF5Q0FDLGdCLEdBQUFBLGdCO1FBa0JBQyxTLEdBQUFBLFM7UUFrRkFDLGEsR0FBQUEsYTtRQTBHQUMsYSxHQUFBQSxhO1FBMEZBQyxvQixHQUFBQSxvQjtRQTRCQUMsYyxHQUFBQSxjO1FBV0FDLGEsR0FBQUEsYTtRQVFBQyxZLEdBQUFBLFk7UUFXQUMsZSxHQUFBQSxlO1FBV0FDLGMsR0FBQUEsYztRQWdCQUMsZ0IsR0FBQUEsZ0I7UUFvRkFDLGEsR0FBQUEsYTtRQWdFQUMseUIsR0FBQUEseUI7UUEwQkFDLFksR0FBQUEsWTtRQXlEQUMsUyxHQUFBQSxTO1FBNkNBQyxpQixHQUFBQSxpQjtRQWtEQUMsWSxHQUFBQSxZO1FBbUJBQyxvQixHQUFBQSxvQjtRQW1CQUMsVyxHQUFBQSxXO1FBNkJBQyxlLEdBQUFBLGU7UUF3Q0FDLHFCLEdBQUFBLHFCO1FBcUJBQywrQixHQUFBQSwrQjtRQStCQUMsdUIsR0FBQUEsdUI7UUFnQ0FDLGlCLEdBQUFBLGlCO1FBd0VBQyxNLEdBQUFBLE07UUEwQkFDLGdCLEdBQUFBLGdCO1FBaUJBQyxRLEdBQUFBLFE7O0FBN2dEaEI7Ozs7Ozs7O0FBQ0E7Ozs7O0FBS08sU0FBU3JELFVBQVQsR0FBc0I7QUFDNUI7QUFDQSxLQUFJc0QsTUFBTUMsS0FBS0MsSUFBTCxDQUFXLElBQVgsQ0FBVjtBQUNBLEtBQUlDLE1BQU1GLEtBQUtHLEtBQUwsQ0FBWSxJQUFaLENBQVY7QUFDQSxRQUFPSCxLQUFLRyxLQUFMLENBQVlILEtBQUtJLE1BQUwsTUFBa0JGLE1BQU1ILEdBQXhCLElBQWdDQSxHQUE1QyxDQUFQO0FBQ0E7O0FBRUQ7Ozs7O0FBS08sU0FBU3JELGlCQUFULEdBQTZCO0FBQ25DLFFBQU8sYUFBYUQsWUFBYixHQUE0QixHQUE1QixHQUFrQ0EsWUFBekM7QUFDQTs7QUFFRDs7Ozs7Ozs7QUFRTyxTQUFTRSxVQUFULENBQXFCMEQsU0FBckIsRUFBZ0NDLFFBQWhDLEVBQTJDO0FBQ2pELEtBQUlDLHNCQUFKOztBQUVBRCxVQUFTRSxHQUFULENBQWMsbUJBQVc7QUFDeEIsTUFBS0MsUUFBUUMsVUFBUixLQUF1QkwsU0FBNUIsRUFBd0M7QUFDdkNFLG1CQUFnQkUsT0FBaEI7QUFDQTtBQUNELEVBSkQ7O0FBTUEsUUFBT0YsYUFBUDtBQUNBOztBQUVEOzs7Ozs7O0FBT08sU0FBUzNELGVBQVQsQ0FBMEIrRCxLQUExQixFQUFpQy9ELGVBQWpDLEVBQW1EO0FBQ3pELFFBQU9nRSxhQUFjRCxLQUFkLE1BQTBCLE9BQTFCLEdBQW9DL0QsZUFBcEMsR0FBc0QsRUFBN0Q7QUFDQTs7QUFFRDs7Ozs7O0FBTU8sU0FBU0MsY0FBVCxDQUF5QjhELEtBQXpCLEVBQWlDO0FBQ3ZDLFFBQU9DLGFBQWNELEtBQWQsTUFBMEIsT0FBMUIsR0FBb0MsUUFBcEMsR0FBK0MsRUFBdEQ7QUFDQTs7QUFFRDs7Ozs7O0FBTUEsU0FBU0MsWUFBVCxDQUF1QkQsS0FBdkIsRUFBK0I7QUFDOUIsS0FBSyxnQkFBZ0IsT0FBT0EsTUFBTUUsVUFBbEMsRUFBK0M7QUFDOUMsU0FBT0YsTUFBTUUsVUFBYjtBQUNBOztBQUVELEtBQUssZ0JBQWdCLE9BQU9GLE1BQU1HLFFBQTdCLElBQXlDLGdCQUFnQixPQUFPSCxNQUFNRyxRQUFOLENBQWUsd0JBQWYsQ0FBckUsRUFDQyxPQUFPSCxNQUFNRyxRQUFOLENBQWUsd0JBQWYsQ0FBUDs7QUFFRCxLQUFLLGdCQUFnQixPQUFPSCxNQUFNSSxVQUFsQyxFQUNDLE9BQU9KLE1BQU1JLFVBQWI7O0FBRUQsUUFBTyxFQUFQO0FBQ0E7O0FBRUQ7Ozs7O0FBS08sU0FBU2pFLHFCQUFULEdBQWlDO0FBQ3ZDLFFBQU8sQ0FBRSxZQUFGLEVBQWdCLFFBQWhCLEVBQTBCLFFBQTFCLEVBQW9DLFdBQXBDLEVBQWlELFNBQWpELEVBQTRELFVBQTVELEVBQXdFLE9BQXhFLENBQVA7QUFDQTs7QUFFRDs7Ozs7O0FBTU8sU0FBU0MsV0FBVCxHQUF1QjtBQUM3QixRQUFPLENBQUUsZ0JBQUYsRUFBb0IsZUFBcEIsQ0FBUDtBQUNBOztBQUVEOzs7OztBQUtPLFNBQVNDLHNCQUFULEdBQWtDO0FBQ3hDLFFBQU87QUFDTix3QkFBc0JnQixVQUFXLGdCQUFYLENBRGhCO0FBRU4sd0JBQXNCQSxVQUFXLHdCQUFYLENBRmhCO0FBR04sb0JBQWtCQSxVQUFXLFdBQVg7QUFIWixFQUFQO0FBS0E7O0FBRUQ7Ozs7Ozs7O0FBUU8sU0FBU2YsaUJBQVQsQ0FBNEIrRCxJQUE1QixFQUFrQ1YsUUFBbEMsRUFBNkM7QUFDbkQsS0FBSVcsVUFBVSxDQUFkOztBQUVBWCxVQUFTRSxHQUFULENBQWMsbUJBQVc7QUFDeEJDLFVBQVFTLE1BQVIsQ0FBZVYsR0FBZixDQUFvQixpQkFBUztBQUM1QixPQUFLVyxNQUFNSCxJQUFOLEtBQWVBLElBQXBCLEVBQTJCO0FBQzFCQztBQUNBO0FBQ0QsR0FKRDtBQUtBLEVBTkQ7O0FBUUEsUUFBT0EsT0FBUDtBQUNBOztBQUVEOzs7Ozs7OztBQVFPLFNBQVMvRCxjQUFULENBQXlCOEQsSUFBekIsRUFBK0JWLFFBQS9CLEVBQTBDO0FBQ2hELEtBQU1jLFdBQVcsRUFBakI7O0FBRUFkLFVBQVNFLEdBQVQsQ0FBYyxtQkFBVztBQUN4QkMsVUFBUVMsTUFBUixDQUFlVixHQUFmLENBQW9CLGlCQUFTO0FBQzVCLE9BQUtXLE1BQU1ILElBQU4sS0FBZUEsSUFBcEIsRUFBMkI7QUFDMUIsUUFBTUssVUFBVUYsTUFBTUcsVUFBdEI7QUFDQSxRQUFNQyxlQUFlRixRQUFRRyxLQUFSLENBQWUsR0FBZixDQUFyQjtBQUNBLFlBQVNMLE1BQU1ILElBQWY7QUFDQyxVQUFLLFlBQUw7QUFDQSxVQUFLLFdBQUw7QUFDQ0ksZUFBU0ssSUFBVCxDQUFlQyxTQUFVSCxhQUFjLENBQWQsQ0FBVixDQUFmO0FBQ0E7QUFDRCxVQUFLLGVBQUw7QUFDQSxVQUFLLGdCQUFMO0FBQ0NILGVBQVNLLElBQVQsQ0FBZUMsU0FBVUgsYUFBYyxDQUFkLENBQVYsQ0FBZjtBQUNBO0FBQ0Q7QUFDQ0gsZUFBU0ssSUFBVCxDQUFlQyxTQUFVSCxhQUFjLENBQWQsQ0FBVixDQUFmO0FBQ0E7QUFYRjtBQWFBO0FBQ0QsR0FsQkQ7QUFtQkEsRUFwQkQ7O0FBc0JBLEtBQUlJLFdBQVcsQ0FBZjs7QUFFQSxLQUFLLENBQUVDLEVBQUVDLE9BQUYsQ0FBV1QsUUFBWCxDQUFQLEVBQStCO0FBQzlCTyxhQUFXQyxFQUFFMUIsR0FBRixDQUFPa0IsUUFBUCxDQUFYO0FBQ0E7O0FBRUQsUUFBT00sU0FBVUMsUUFBVixJQUF1QixDQUE5QjtBQUNBOztBQUVNLFNBQVN4RSxRQUFULENBQW1CNkQsSUFBbkIsRUFBeUJjLE1BQXpCLEVBQWtDO0FBQ3hDLEtBQU1DLE1BQU0sRUFBWjs7QUFFQUgsR0FBRXBCLEdBQUYsQ0FBT3NCLE1BQVAsRUFBZSxpQkFBUztBQUN2QixNQUFNVCxVQUFVVyxNQUFNVixVQUF0QjtBQUNBLE1BQU1DLGVBQWVGLFFBQVFHLEtBQVIsQ0FBZSxHQUFmLENBQXJCOztBQUVBTyxNQUFJTixJQUFKLENBQVVDLFNBQVVILGFBQWMsQ0FBZCxDQUFWLENBQVY7QUFDQSxFQUxEOztBQU9BLEtBQUlJLFdBQVcsQ0FBZjs7QUFFQSxLQUFLLENBQUVDLEVBQUVDLE9BQUYsQ0FBV0UsR0FBWCxDQUFQLEVBQTBCO0FBQ3pCSixhQUFXQyxFQUFFMUIsR0FBRixDQUFPNkIsR0FBUCxDQUFYO0FBQ0E7O0FBRUQsUUFBT0wsU0FBVUMsUUFBVixJQUF1QixDQUE5QjtBQUNBOztBQUVEOzs7Ozs7O0FBT08sU0FBU3ZFLGFBQVQsQ0FBd0I0RSxLQUF4QixFQUFnQztBQUN0Q0EsU0FBUUEsTUFBTUMsSUFBTixHQUFhQyxPQUFiLENBQXNCLFNBQXRCLEVBQWlDLEdBQWpDLENBQVI7O0FBRUEsUUFBT0YsS0FBUDtBQUNBOztBQUVEOzs7Ozs7QUFNQSxTQUFTRyxjQUFULENBQXlCN0IsUUFBekIsRUFBb0M7QUFDbkMsUUFBTyxTQUFTQSxRQUFoQjtBQUNBOztBQUVEOzs7Ozs7OztBQVFPLFNBQVNqRCxZQUFULENBQXVCMkQsSUFBdkIsRUFBNkJWLFFBQTdCLEVBQXdDO0FBQzlDLEtBQUlXLFVBQVUsQ0FBZDs7QUFFQSxLQUFLa0IsZUFBZ0I3QixRQUFoQixDQUFMLEVBQWtDO0FBQ2pDLFNBQU8sSUFBUDtBQUNBOztBQUVEQSxVQUFTRSxHQUFULENBQWMsbUJBQVc7QUFDeEJDLFVBQVFTLE1BQVIsQ0FBZVYsR0FBZixDQUFvQixpQkFBUztBQUM1QixPQUFLVyxNQUFNSCxJQUFOLEtBQWVBLElBQXBCLEVBQTJCO0FBQzFCQztBQUNBO0FBQ0QsR0FKRDtBQUtBLEVBTkQ7O0FBUUEsUUFBT0EsVUFBVSxDQUFqQjtBQUNBOztBQUVEOzs7Ozs7OztBQVFPLFNBQVMzRCxlQUFULENBQTBCMEQsSUFBMUIsRUFBZ0NWLFFBQWhDLEVBQTJDO0FBQ2pELEtBQU1ZLFNBQVMsRUFBZjs7QUFFQVosVUFBU0UsR0FBVCxDQUFjLG1CQUFXO0FBQ3hCQyxVQUFRUyxNQUFSLENBQWVWLEdBQWYsQ0FBb0IsaUJBQVM7QUFDNUIsT0FBS1csTUFBTUgsSUFBTixLQUFlQSxJQUFwQixFQUEyQjtBQUMxQkUsV0FBT08sSUFBUCxDQUFhTixLQUFiO0FBQ0E7QUFDRCxHQUpEO0FBS0EsRUFORDs7QUFRQSxRQUFPRCxNQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7O0FBUU8sU0FBUzNELGVBQVQsQ0FBMEJ5RCxJQUExQixFQUFnQ1YsUUFBaEMsRUFBMkM7QUFDakQsS0FBTVksU0FBUyxFQUFmO0FBQ0EsS0FBTWtCLGVBQWU5RSxnQkFBaUIwRCxJQUFqQixFQUF1QlYsUUFBdkIsQ0FBckI7QUFDQThCLGNBQWE1QixHQUFiLENBQWtCLGlCQUFTO0FBQzFCLE1BQUk2QixRQUFRbEIsTUFBTW1CLFdBQWxCOztBQUVBLE1BQUt0QixTQUFTLFNBQWQsRUFBMEI7QUFDekJxQixXQUFRbEIsTUFBTUcsVUFBZDtBQUNBOztBQUVESixTQUFPTyxJQUFQLENBQWE7QUFDWk8sVUFBT2IsTUFBTUcsVUFERDtBQUVaZSxVQUFPQSxLQUZLO0FBR1pmLGVBQVlILE1BQU1HO0FBSE4sR0FBYjtBQUtBLEVBWkQ7O0FBY0EsUUFBT0osTUFBUDtBQUNBOztBQUVEOzs7Ozs7OztBQVFPLFNBQVMxRCxhQUFULENBQXdCK0UsRUFBeEIsRUFBNEJqQyxRQUE1QixFQUF1QztBQUM3QyxLQUFJK0IsUUFBUSxFQUFaO0FBQ0EvQixVQUFTRSxHQUFULENBQWMsbUJBQVc7QUFDeEJDLFVBQVFTLE1BQVIsQ0FBZVYsR0FBZixDQUFvQixpQkFBUztBQUM1QixPQUFLVyxNQUFNRyxVQUFOLEtBQXFCaUIsRUFBMUIsRUFBK0I7QUFDOUJGLFlBQVFsQixNQUFNbUIsV0FBZDtBQUNBO0FBQ0QsR0FKRDtBQUtBLEVBTkQ7O0FBUUEsUUFBT0QsS0FBUDtBQUNBO0FBQ0Q7Ozs7Ozs7O0FBUU8sU0FBUzVFLFVBQVQsQ0FBcUI4RSxFQUFyQixFQUF5QmpDLFFBQXpCLEVBQW9DO0FBQzFDLEtBQUlrQyxRQUFRLENBQVo7O0FBRUFsQyxVQUFTRSxHQUFULENBQWMsbUJBQVc7QUFDeEJDLFVBQVFTLE1BQVIsQ0FBZVYsR0FBZixDQUFvQixpQkFBUztBQUM1QixPQUFLVyxNQUFNRyxVQUFOLEtBQXFCaUIsRUFBMUIsRUFBK0I7QUFDOUJDO0FBQ0E7QUFDRCxHQUpEO0FBS0EsRUFORDs7QUFRQSxRQUFPQSxRQUFRLENBQWY7QUFDQTs7QUFFRDs7Ozs7Ozs7Ozs7QUFXTyxTQUFTOUUsZ0JBQVQsQ0FBMkJ5RCxLQUEzQixFQUFrQ2QsU0FBbEMsRUFBNkNvQyxJQUE3QyxFQUFtRG5DLFFBQW5ELEVBQTZEb0MsYUFBN0QsRUFBNkU7QUFDbkZBLGlCQUFnQkEsaUJBQWlCLEVBQWpDO0FBQ0EsS0FBTUMscUNBQWFyQyxRQUFiLElBQXVCLEVBQUVZLFFBQVF3QixhQUFWLEVBQXZCLEVBQU47QUFDQSxLQUFNRSxjQUFjMUYsZUFBZ0JpRSxNQUFNSCxJQUF0QixFQUE0QjJCLEtBQTVCLENBQXBCOztBQUVBLFFBQU9mLEVBQUVpQixNQUFGLENBQVUxQixLQUFWLEVBQWlCO0FBQ3ZCRyxjQUFZSCxNQUFNSCxJQUFOLEdBQWEsR0FBYixHQUFtQjRCLFdBRFI7QUFFdkJFLFVBQVF6QyxTQUZlO0FBR3ZCb0MsUUFBTUE7QUFIaUIsRUFBakIsQ0FBUDtBQUtBOztBQUVEOzs7Ozs7Ozs7QUFTTyxTQUFTOUUsd0JBQVQsQ0FBbUNvRixJQUFuQyxFQUF5Q3pDLFFBQXpDLEVBQW1ERCxTQUFuRCxFQUErRDtBQUNyRSxLQUFNYyxRQUFRNkIsZUFBZTlCLE1BQWYsQ0FBc0IrQixJQUF0QixDQUE0QixxQkFBYTtBQUN0RCxTQUFPQyxVQUFVSCxJQUFWLEtBQW1CQSxJQUExQjtBQUNBLEVBRmEsQ0FBZDs7QUFJQSxLQUFNSCxjQUFjMUYsZUFBZ0JpRSxNQUFNSCxJQUF0QixFQUE0QlYsUUFBNUIsQ0FBcEI7O0FBRUEsS0FBTUssUUFBUTtBQUNiVyxjQUFZSCxNQUFNSCxJQUFOLEdBQWEsR0FBYixHQUFtQjRCLFdBRGxCO0FBRWI1QixRQUFNRyxNQUFNSCxJQUZDO0FBR2JtQyxXQUFTaEMsTUFBTWdDLE9BSEY7QUFJYlYsUUFBTSxFQUpPO0FBS2JXLGNBQVksRUFMQztBQU1iMUMsY0FBWUw7QUFOQyxFQUFkOztBQVNBLEtBQU11QixFQUFFeUIsUUFBRixDQUFZLENBQUUsYUFBRixFQUFpQixRQUFqQixFQUEyQixRQUEzQixFQUFxQyxPQUFyQyxFQUE4QyxVQUE5QyxFQUEwRCxRQUExRCxFQUFvRSxVQUFwRSxDQUFaLEVBQThGbEMsTUFBTUgsSUFBcEcsQ0FBTixFQUFtSDtBQUNsSEwsUUFBTSxpQkFBTixJQUEyQixNQUEzQjtBQUNBOztBQUVELFFBQU9pQixFQUFFaUIsTUFBRixDQUNObEMsS0FETSxFQUVOMkMsS0FBS0MsS0FBTCxDQUFZRCxLQUFLRSxTQUFMLENBQWdCckMsTUFBTXNDLFFBQXRCLENBQVosQ0FGTSxDQUFQO0FBSUE7O0FBRUQ7Ozs7Ozs7QUFPTyxTQUFTN0YsWUFBVCxDQUF1QnVELEtBQXZCLEVBQStCO0FBQUEsS0FDN0JILElBRDZCLEdBQ3BCRyxLQURvQixDQUM3QkgsSUFENkI7OztBQUdyQyxRQUFPQSxJQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7OztBQVNPLFNBQVNuRCxrQkFBVCxDQUE2QnNELEtBQTdCLEVBQXFDO0FBQzNDLFFBQU82QixlQUFlOUIsTUFBZixDQUFzQitCLElBQXRCLENBQTRCO0FBQUEsU0FBbUJTLGdCQUFnQjFDLElBQWhCLEtBQXlCRyxNQUFNSCxJQUFsRDtBQUFBLEVBQTVCLENBQVA7QUFDQTs7QUFFRDs7Ozs7Ozs7O0FBU08sU0FBU2xELGdCQUFULENBQTJCNkYsS0FBM0IsRUFBa0NDLFFBQWxDLEVBQTRDQyxXQUE1QyxFQUEwRDtBQUNoRSxxQ0FBWUYsTUFBTUcsS0FBTixDQUFhLENBQWIsRUFBZ0JGLFFBQWhCLENBQVosSUFBd0NDLFdBQXhDLHNCQUF3REYsTUFBTUcsS0FBTixDQUFhRixRQUFiLENBQXhEO0FBQ0E7O0FBRUQ7Ozs7Ozs7OztBQVNPLFNBQVM3RixpQkFBVCxDQUE0QjRGLEtBQTVCLEVBQW1DQyxRQUFuQyxFQUE2Q0MsV0FBN0MsRUFBMkQ7QUFDakUscUNBQVlGLE1BQU1HLEtBQU4sQ0FBYSxDQUFiLEVBQWdCRixRQUFoQixDQUFaLElBQXdDQyxXQUF4QyxzQkFBd0RGLE1BQU1HLEtBQU4sQ0FBYUYsV0FBVyxDQUF4QixDQUF4RDtBQUNBOztBQUVEOzs7Ozs7O0FBT08sU0FBUzVGLFNBQVQsR0FBcUI7QUFDM0IsUUFBTytGLHVCQUFLL0YsU0FBTCxDQUFlZ0csS0FBZixDQUFzQixJQUF0QixFQUE0QkMsU0FBNUIsQ0FBUDtBQUNBOztBQUVEOzs7Ozs7OztBQVFPLFNBQVNoRyxlQUFULENBQTBCK0QsS0FBMUIsRUFBaUNrQyxLQUFqQyxFQUF5QztBQUMvQyxLQUFNQyxhQUFhdkMsRUFBRXdDLE1BQUYsQ0FBVUYsS0FBVixFQUFpQixVQUFVRyxJQUFWLEVBQWlCO0FBQ3BELFNBQU9BLEtBQUtDLE1BQUwsS0FBZ0J0QyxLQUF2QjtBQUNBLEVBRmtCLENBQW5COztBQUlBLEtBQUssQ0FBRUosRUFBRTJDLFdBQUYsQ0FBZUosV0FBWSxDQUFaLENBQWYsQ0FBRixJQUFzQyxDQUFFdkMsRUFBRTJDLFdBQUYsQ0FBZUosV0FBWSxDQUFaLEVBQWdCSyxRQUEvQixDQUE3QyxFQUF5RjtBQUN4RixTQUFPTCxXQUFZLENBQVosRUFBZ0JLLFFBQXZCO0FBQ0E7O0FBRUQsUUFBTyxDQUFFeEcsVUFBVyxNQUFYLENBQUYsQ0FBUDtBQUNBOztBQUVEOzs7Ozs7QUFNTyxTQUFTRSxPQUFULENBQWtCOEQsS0FBbEIsRUFBMEI7QUFDaEMsUUFBT0EsTUFBTXlDLE1BQU4sQ0FBYyxDQUFkLEVBQWtCQyxXQUFsQixLQUFrQzFDLE1BQU04QixLQUFOLENBQWEsQ0FBYixDQUF6QztBQUNBOztBQUVEOzs7OztBQUtPLFNBQVMzRixpQkFBVCxDQUE0QmdELEtBQTVCLEVBQW1Dd0QsU0FBbkMsRUFBK0M7QUFDckQsS0FBTTNDLFFBQVEyQyxVQUFVM0MsS0FBeEI7QUFDQSxLQUFJNEMsbUJBQUo7O0FBRUE7QUFDQTtBQUNBLEtBQUt6RCxNQUFNMEQsVUFBTixJQUFvQjFELE1BQU1XLE1BQU4sQ0FBYWdELE1BQWIsR0FBc0IsQ0FBL0MsRUFBbUQ7QUFDbEQsTUFBSXpDLGNBQUo7O0FBRUE7QUFDQUEsVUFBUVQsRUFBRW1ELEtBQUYsQ0FBUzVELE1BQU1XLE1BQWYsRUFBdUIsRUFBRUUsT0FBT0EsS0FBVCxFQUF2QixFQUEyQyxDQUEzQyxDQUFSOztBQUVBO0FBQ0EsTUFBSyxDQUFFSyxLQUFQLEVBQWU7QUFDZEEsV0FBUVQsRUFBRW1ELEtBQUYsQ0FBUzVELE1BQU1XLE1BQWYsRUFBdUIsRUFBRU8sT0FBT0wsS0FBVCxFQUF2QixFQUEyQyxDQUEzQyxDQUFSO0FBQ0E7O0FBRUQ7QUFDQSxNQUFLLENBQUVLLEtBQVAsRUFBZTtBQUNkO0FBQ0E7O0FBRUR1QyxlQUFhdkMsTUFBTUEsS0FBbkI7QUFDQSxFQWpCRCxNQWlCTyxJQUFLLFdBQVdsQixNQUFNNkQsVUFBakIsSUFBK0IsQ0FBRSxXQUFGLEVBQWUsVUFBZixFQUE0QkMsUUFBNUIsQ0FBc0NOLFVBQVVPLElBQWhELENBQXBDLEVBQThGO0FBQ3BHO0FBQ0FOLGVBQWF4RyxpQkFBa0I0RCxLQUFsQixDQUFiO0FBQ0EsRUFITSxNQUdBO0FBQ040QyxlQUFhNUMsS0FBYjtBQUNBOztBQUVEO0FBQ0EsS0FBS0osRUFBRUMsT0FBRixDQUFXK0MsVUFBWCxDQUFMLEVBQStCO0FBQzlCLFNBQU81RyxVQUFXLE1BQVgsQ0FBUDtBQUNBOztBQUVELFFBQU80RyxVQUFQO0FBQ0E7O0FBRUQ7OztBQUdPLFNBQVN4RyxnQkFBVCxDQUEyQjRELEtBQTNCLEVBQW1DO0FBQ3pDLEtBQUssQ0FBRW1ELE1BQU9DLE9BQVFwRCxLQUFSLENBQVAsQ0FBUCxFQUFrQztBQUNqQztBQUNBLE1BQU1xRCxPQUFPLElBQUlDLElBQUosQ0FBVXRELFFBQU0sQ0FBaEIsQ0FBYjs7QUFFQTtBQUNBLE1BQU1tQixVQUFVLEVBQUVvQyxLQUFLLFNBQVAsRUFBa0JDLE9BQU8sU0FBekIsRUFBb0NDLE1BQU0sU0FBMUMsRUFBaEI7O0FBRUE7QUFDQXpELFVBQVFxRCxLQUFLSyxrQkFBTCxDQUF5QixPQUF6QixFQUFrQ3ZDLE9BQWxDLENBQVI7QUFDQTs7QUFFRCxRQUFPbkIsS0FBUDtBQUNBOztBQUVEOzs7QUFHTyxTQUFTM0QsU0FBVCxDQUFvQmlDLFFBQXBCLEVBQThCcUYsY0FBOUIsRUFBOENDLEtBQTlDLEVBQXFEQyxjQUFyRCxFQUFxRUMsZ0JBQXJFLEVBQXdGO0FBQzlGLEtBQUlDLGNBQWMsRUFBbEI7O0FBRUEsS0FBS25FLEVBQUUyQyxXQUFGLENBQWVvQixjQUFmLENBQUwsRUFBdUM7QUFDdENBLG1CQUFpQixDQUFFLFlBQUYsRUFBZ0IsVUFBaEIsRUFBNEIsT0FBNUIsRUFBcUMsU0FBckMsRUFBZ0QsU0FBaEQsQ0FBakI7QUFDQTtBQUNELEtBQUtLLE1BQU1DLE9BQU4sQ0FBZU4sY0FBZixLQUFtQyxDQUFFL0YsT0FBUWtHLGdCQUFSLENBQTFDLEVBQXVFO0FBQ3RFSCxpQkFBZWxFLElBQWYsQ0FBcUIsT0FBckI7QUFDQTtBQUNELEtBQUl5RSxrQkFBa0IsS0FBdEI7O0FBRUEsS0FBSyxDQUFFdEUsRUFBRTJDLFdBQUYsQ0FBZXFCLEtBQWYsQ0FBRixJQUE0QixDQUFFaEUsRUFBRTJDLFdBQUYsQ0FBZXFCLE1BQU1NLGVBQXJCLENBQTlCLElBQXdFTixNQUFNTSxlQUFOLEtBQTBCLElBQXZHLEVBQThHO0FBQzdHQSxvQkFBa0IsSUFBbEI7QUFDQTs7QUFHRDtBQUNBNUYsVUFBU0UsR0FBVCxDQUFjLG1CQUFXO0FBQ3hCLE1BQU1VLFNBQVNULFFBQVFTLE1BQXZCO0FBQUEsTUFDQ2lGLGNBQWMxRixRQUFRMkYsWUFEdkI7QUFFQWxGLFNBQU9WLEdBQVAsQ0FBWSxpQkFBUztBQUNwQjtBQUNBLE9BQUssQ0FBRW9CLEVBQUUyQyxXQUFGLENBQWVzQixjQUFmLENBQVAsRUFBeUM7QUFDeEMsUUFBSyxDQUFFakUsRUFBRXlCLFFBQUYsQ0FBWXdDLGNBQVosRUFBNEIxRSxNQUFNSCxJQUFsQyxDQUFQLEVBQWtEO0FBQ2pEO0FBQ0E7QUFDRCxJQUpELE1BSU8sSUFBS1ksRUFBRXlCLFFBQUYsQ0FBWXNDLGNBQVosRUFBNEJ4RSxNQUFNSCxJQUFsQyxDQUFMLEVBQWdEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFRCxPQUFJcUIsY0FBSjs7QUFFQTtBQUNBLE9BQUssQ0FBRVQsRUFBRTJDLFdBQUYsQ0FBZXBELE1BQU1tQixXQUFyQixDQUFGLElBQXdDLENBQUVWLEVBQUVDLE9BQUYsQ0FBV1YsTUFBTW1CLFdBQWpCLENBQS9DLEVBQWdGO0FBQy9FRCxZQUFRbEIsTUFBTW1CLFdBQWQ7QUFDQSxJQUZELE1BRU87QUFDTkQsWUFBUWxCLE1BQU1ILElBQWQ7QUFDQXFCLFlBQVFuRSxRQUFTbUUsS0FBVCxDQUFSO0FBQ0E7O0FBRUQ7QUFDQSxPQUFLbEIsTUFBTUgsSUFBTixLQUFlLE1BQWYsSUFBeUIsQ0FBRXBCLE9BQVFrRyxnQkFBUixDQUFoQyxFQUE2RDtBQUM1REMsa0JBQWNBLFlBQVlNLE1BQVosQ0FBb0I5SCxjQUFlNEMsS0FBZixFQUFzQmtCLEtBQXRCLEVBQTZCOEQsV0FBN0IsQ0FBcEIsQ0FBZDtBQUNBLElBRkQsTUFFTyxJQUFLaEYsTUFBTUgsSUFBTixLQUFlLFNBQWYsSUFBNEIsQ0FBRXBCLE9BQVFrRyxnQkFBUixDQUFuQyxFQUFnRTtBQUN0RUMsa0JBQWNBLFlBQVlNLE1BQVosQ0FBb0J2SCxpQkFBa0JxQyxLQUFsQixFQUF5QmtCLEtBQXpCLEVBQWdDOEQsV0FBaEMsQ0FBcEIsQ0FBZDtBQUNBLElBRk0sTUFFQSxJQUFLaEYsTUFBTUgsSUFBTixLQUFlLFFBQWYsSUFBMkJHLE1BQU1tRixXQUFOLEtBQXNCLE9BQXRELEVBQWdFO0FBQ3RFUCxrQkFBY0EsWUFBWU0sTUFBWixDQUFvQjdILHFCQUFzQjJDLEtBQXRCLEVBQTZCa0IsS0FBN0IsRUFBb0M4RCxXQUFwQyxDQUFwQixDQUFkO0FBQ0EsSUFGTSxNQUVBLElBQUtoRixNQUFNSCxJQUFOLEtBQWUsTUFBZixJQUF5QixDQUFFcEIsT0FBUWtHLGdCQUFSLENBQWhDLEVBQTZEO0FBQ25FQyxrQkFBY0EsWUFBWU0sTUFBWixDQUFvQnRILGNBQWVvQyxLQUFmLEVBQXNCa0IsS0FBdEIsRUFBNkI4RCxXQUE3QixDQUFwQixDQUFkO0FBQ0EsSUFGTSxNQUVELElBQUtoRixNQUFNSCxJQUFOLEtBQWUsTUFBZixJQUF5QkcsTUFBTTZELFVBQU4sS0FBcUIsUUFBOUMsSUFBMERrQixvQkFBb0IsS0FBbkYsRUFBMkY7QUFDaEc7QUFDQSxJQUZLLE1BRUM7QUFDTkgsZ0JBQVl0RSxJQUFaLENBQWtCO0FBQ2pCSCxpQkFBWUgsTUFBTUcsVUFERDtBQUVqQjhFLG1CQUFjRCxXQUZHO0FBR2pCSSxlQUFVcEYsTUFBTW9GLFFBSEM7QUFJakJ2QixpQkFBWTdELE1BQU1ILElBSkQ7QUFLakJ3RixpQkFBWXJGLE1BQU1ILElBTEQ7QUFNakJxQixZQUFPQSxLQU5VO0FBT2pCUCxhQUFRakQsZUFBZ0JzQyxLQUFoQixDQVBTO0FBUWpCMEQsaUJBQVlqRyxnQkFBaUJ1QyxLQUFqQixDQVJLO0FBU2pCc0YsZUFBVS9ILGNBQWV5QyxLQUFmLENBVE87QUFVakJ1RixjQUFTL0gsYUFBY3dDLEtBQWQsQ0FWUTtBQVdqQndGLGVBQVVsSSxlQUFnQjBDLEtBQWhCLENBWE87QUFZakIrQixnQkFBVy9CO0FBWk0sS0FBbEI7QUFjQTtBQUNELE9BQUtBLE1BQU1ILElBQU4sS0FBZSxNQUFmLElBQXlCRyxNQUFNNkQsVUFBTixLQUFxQixRQUE5QyxJQUEwRCxDQUFFcEYsT0FBUWtHLGdCQUFSLENBQWpFLEVBQThGO0FBQzdGQyxrQkFBY0EsWUFBWU0sTUFBWixDQUFvQi9ILGNBQWU2QyxLQUFmLEVBQXNCa0IsS0FBdEIsRUFBNkI4RCxXQUE3QixDQUFwQixDQUFkO0FBQ0E7QUFFRCxHQXBERDtBQXFEQSxFQXhERDtBQXlEQSxRQUFPSixXQUFQO0FBQ0E7QUFDRDs7Ozs7O0FBTU8sU0FBU3pILGFBQVQsQ0FBd0I2QyxLQUF4QixFQUErQnlGLFVBQS9CLEVBQTJDVCxXQUEzQyxFQUF5RDtBQUMvRCxLQUFNSixjQUFjLEVBQXBCOztBQUVBLEtBQUljLGtCQUFKO0FBQ0EsS0FBSyxDQUFFakYsRUFBRTJDLFdBQUYsQ0FBZXBELE1BQU0wRixTQUFyQixDQUFGLElBQXNDLENBQUVqRixFQUFFQyxPQUFGLENBQVdWLE1BQU0wRixTQUFqQixDQUE3QyxFQUE0RTtBQUMzRUEsY0FBWUQsYUFBYSxLQUFiLEdBQXFCekYsTUFBTTBGLFNBQXZDO0FBQ0EsRUFGRCxNQUVPO0FBQ05BLGNBQVlELGFBQWEsS0FBYixHQUFxQjVJLFVBQVcsS0FBWCxDQUFqQztBQUNBOztBQUVELEtBQUk4SSxvQkFBSjtBQUNBLEtBQUssQ0FBRWxGLEVBQUUyQyxXQUFGLENBQWVwRCxNQUFNMkYsV0FBckIsQ0FBRixJQUF3QyxDQUFFbEYsRUFBRUMsT0FBRixDQUFXVixNQUFNMkYsV0FBakIsQ0FBL0MsRUFBZ0Y7QUFDL0VBLGdCQUFjRixhQUFhLEtBQWIsR0FBcUJ6RixNQUFNMkYsV0FBekM7QUFDQSxFQUZELE1BRU87QUFDTkEsZ0JBQWNGLGFBQWEsS0FBYixHQUFxQjVJLFVBQVcsT0FBWCxDQUFuQztBQUNBOztBQUVELEtBQUkrSSxtQkFBSjtBQUNBLEtBQUssQ0FBRW5GLEVBQUUyQyxXQUFGLENBQWVwRCxNQUFNNEYsVUFBckIsQ0FBRixJQUF1QyxDQUFFbkYsRUFBRUMsT0FBRixDQUFXVixNQUFNNEYsVUFBakIsQ0FBOUMsRUFBOEU7QUFDN0VBLGVBQWFILGFBQWEsS0FBYixHQUFxQnpGLE1BQU00RixVQUF4QztBQUNBLEVBRkQsTUFFTztBQUNOQSxlQUFhSCxhQUFhLEtBQWIsR0FBcUI1SSxVQUFXLE1BQVgsQ0FBbEM7QUFDQTtBQUNELEtBQUltRCxNQUFNNkQsVUFBTixLQUFxQixPQUF6QixFQUFrQztBQUNqQ2UsY0FBWXRFLElBQVosQ0FDQztBQUNDSCxlQUFZSCxNQUFNRyxVQUFOLEdBQW1CLE1BRGhDO0FBRUM4RSxpQkFBY0QsV0FGZjtBQUdDSSxhQUFVcEYsTUFBTW9GLFFBSGpCO0FBSUN2QixlQUFZN0QsTUFBTUgsSUFKbkI7QUFLQ3dGLGVBQVlyRixNQUFNSCxJQUFOLEdBQWEsTUFMMUI7QUFNQ3FCLFVBQU93RSxTQU5SO0FBT0MvRSxXQUFRLEtBUFQ7QUFRQytDLGVBQVksS0FSYjtBQVNDOEIsYUFBVTtBQVRYLEdBREQsRUFZQztBQUNDckYsZUFBWUgsTUFBTUcsVUFBTixHQUFtQixRQURoQztBQUVDOEUsaUJBQWNELFdBRmY7QUFHQ0ksYUFBVXBGLE1BQU1vRixRQUhqQjtBQUlDdkIsZUFBWTdELE1BQU1ILElBSm5CO0FBS0N3RixlQUFZckYsTUFBTUgsSUFBTixHQUFhLFFBTDFCO0FBTUNxQixVQUFPeUUsV0FOUjtBQU9DaEYsV0FBUSxLQVBUO0FBUUMrQyxlQUFZLEtBUmI7QUFTQzhCLGFBQVU7QUFUWCxHQVpELEVBdUJDO0FBQ0NyRixlQUFZSCxNQUFNRyxVQUFOLEdBQW1CLE9BRGhDO0FBRUM4RSxpQkFBY0QsV0FGZjtBQUdDSSxhQUFVcEYsTUFBTW9GLFFBSGpCO0FBSUN2QixlQUFZN0QsTUFBTUgsSUFKbkI7QUFLQ3dGLGVBQVlyRixNQUFNSCxJQUFOLEdBQWEsT0FMMUI7QUFNQ3FCLFVBQU8wRSxVQU5SO0FBT0NqRixXQUFRLEtBUFQ7QUFRQytDLGVBQVksS0FSYjtBQVNDOEIsYUFBVTtBQVRYLEdBdkJEO0FBbUNBLEVBcENELE1Bb0NLO0FBQ0paLGNBQVl0RSxJQUFaLENBQ0M7QUFDQ0gsZUFBWUgsTUFBTUcsVUFBTixHQUFtQixNQURoQztBQUVDOEUsaUJBQWNELFdBRmY7QUFHQ0ksYUFBVXBGLE1BQU1vRixRQUhqQjtBQUlDdkIsZUFBWTdELE1BQU1ILElBSm5CO0FBS0N3RixlQUFZckYsTUFBTUgsSUFBTixHQUFhLE1BTDFCO0FBTUNxQixVQUFPd0UsU0FOUjtBQU9DL0UsV0FBUWpELGVBQWdCc0MsS0FBaEIsQ0FQVDtBQVFDMEQsZUFBWWpHLGdCQUFpQnVDLEtBQWpCLENBUmI7QUFTQ3dGLGFBQVVsSSxlQUFnQjBDLEtBQWhCO0FBVFgsR0FERCxFQVlDO0FBQ0NHLGVBQVlILE1BQU1HLFVBQU4sR0FBbUIsUUFEaEM7QUFFQzhFLGlCQUFjRCxXQUZmO0FBR0NJLGFBQVVwRixNQUFNb0YsUUFIakI7QUFJQ3ZCLGVBQVk3RCxNQUFNSCxJQUpuQjtBQUtDd0YsZUFBWXJGLE1BQU1ILElBQU4sR0FBYSxRQUwxQjtBQU1DcUIsVUFBT3lFLFdBTlI7QUFPQ2hGLFdBQVFqRCxlQUFnQnNDLEtBQWhCLENBUFQ7QUFRQzBELGVBQVlqRyxnQkFBaUJ1QyxLQUFqQixDQVJiO0FBU0N3RixhQUFVbEksZUFBZ0IwQyxLQUFoQjtBQVRYLEdBWkQsRUF1QkM7QUFDQ0csZUFBWUgsTUFBTUcsVUFBTixHQUFtQixPQURoQztBQUVDOEUsaUJBQWNELFdBRmY7QUFHQ0ksYUFBVXBGLE1BQU1vRixRQUhqQjtBQUlDdkIsZUFBWTdELE1BQU1ILElBSm5CO0FBS0N3RixlQUFZckYsTUFBTUgsSUFBTixHQUFhLE9BTDFCO0FBTUNxQixVQUFPMEUsVUFOUjtBQU9DakYsV0FBUWpELGVBQWdCc0MsS0FBaEIsQ0FQVDtBQVFDMEQsZUFBWWpHLGdCQUFpQnVDLEtBQWpCLENBUmI7QUFTQ3dGLGFBQVVsSSxlQUFnQjBDLEtBQWhCO0FBVFgsR0F2QkQ7QUFtQ0E7O0FBRUQsUUFBTzRFLFdBQVA7QUFDQTs7QUFFRDs7Ozs7O0FBTU8sU0FBU3hILGFBQVQsQ0FBd0I0QyxLQUF4QixFQUErQnlGLFVBQS9CLEVBQTJDVCxXQUEzQyxFQUF5RDtBQUMvRCxLQUFNSixjQUFjLEVBQXBCO0FBQ0E7QUFDQSxLQUFLNUUsTUFBTTZGLGFBQU4sS0FBd0IsTUFBeEIsSUFBa0MsU0FBUzdGLE1BQU02RixhQUF0RCxFQUFzRTtBQUNyRSxHQUNDO0FBQ0NDLFNBQU0sUUFEUDtBQUVDNUUsVUFBTyxjQUZSO0FBR0M2RSxtQkFBZ0IsUUFIakI7QUFJQ3JDLGVBQVksSUFKYjtBQUtDL0MsV0FBUSxDQUNQLEVBQUVPLE9BQU8sS0FBVCxFQUFnQkwsT0FBTyxJQUF2QixFQURPLEVBRVAsRUFBRUssT0FBTyxNQUFULEVBQWlCTCxPQUFPLEtBQXhCLEVBRk8sRUFHUCxFQUFFSyxPQUFPLEtBQVQsRUFBZ0JMLE9BQU8sSUFBdkIsRUFITyxFQUlQLEVBQUVLLE9BQU8sS0FBVCxFQUFnQkwsT0FBTyxJQUF2QixFQUpPLEVBS1AsRUFBRUssT0FBTyxNQUFULEVBQWlCTCxPQUFPLE1BQXhCLEVBTE8sRUFNUCxFQUFFSyxPQUFPLEtBQVQsRUFBZ0JMLE9BQU8sSUFBdkIsRUFOTyxFQU9QLEVBQUVLLE9BQU8sT0FBVCxFQUFrQkwsT0FBTyxNQUF6QixFQVBPLENBTFQ7QUFjQzJFLGFBQVU7QUFkWCxHQURELEVBaUJDO0FBQ0NNLFNBQU0sT0FEUDtBQUVDNUUsVUFBTyxhQUZSO0FBR0M2RSxtQkFBZ0IsWUFIakI7QUFJQ3JDLGVBQVksS0FKYjtBQUtDL0MsV0FBUSxLQUxUO0FBTUM2RSxhQUFVO0FBTlgsR0FqQkQsRUF5QkM7QUFDQ00sU0FBTSxPQURQO0FBRUM1RSxVQUFPLGFBRlI7QUFHQzZFLG1CQUFnQixhQUhqQjtBQUlDckMsZUFBWSxLQUpiO0FBS0MvQyxXQUFRLEtBTFQ7QUFNQzZFLGFBQVU7QUFOWCxHQXpCRCxFQWlDQztBQUNDTSxTQUFNLE9BRFA7QUFFQzVFLFVBQU8sYUFGUjtBQUdDNkUsbUJBQWdCLFdBSGpCO0FBSUNyQyxlQUFZLEtBSmI7QUFLQy9DLFdBQVEsS0FMVDtBQU1DNkUsYUFBVTtBQU5YLEdBakNELEVBeUNFbkcsR0F6Q0YsQ0F5Q08scUJBQWE7QUFDbkIsT0FBS1csTUFBT2dHLFVBQVVGLElBQWpCLE1BQTRCLE1BQTVCLElBQXNDOUYsTUFBT2dHLFVBQVVGLElBQWpCLE1BQTRCLElBQXZFLEVBQThFO0FBQzdFLFFBQUk1RSxjQUFKO0FBQ0EsUUFBSyxDQUFFVCxFQUFFMkMsV0FBRixDQUFlcEQsTUFBT2dHLFVBQVU5RSxLQUFqQixDQUFmLENBQUYsSUFBK0MsQ0FBRVQsRUFBRUMsT0FBRixDQUFXVixNQUFPZ0csVUFBVTlFLEtBQWpCLENBQVgsQ0FBdEQsRUFBOEY7QUFDN0ZBLGFBQVF1RSxhQUFhLEtBQWIsR0FBcUJ6RixNQUFPZ0csVUFBVTlFLEtBQWpCLENBQTdCO0FBQ0EsS0FGRCxNQUVPO0FBQ05BLGFBQVF1RSxhQUFhLEtBQXJCO0FBQ0E7O0FBRURiLGdCQUFZdEUsSUFBWixDQUFrQjtBQUNqQkgsaUJBQVlILE1BQU1HLFVBQU4sR0FBbUIsR0FBbkIsR0FBeUI2RixVQUFVRCxjQUQ5QjtBQUVqQmQsbUJBQWNELFdBRkc7QUFHakJJLGVBQVVwRixNQUFNb0YsUUFIQztBQUlqQnZCLGlCQUFZN0QsTUFBTUgsSUFKRDtBQUtqQndGLGlCQUFZckYsTUFBTUgsSUFBTixHQUFhLEdBQWIsR0FBbUJtRyxVQUFVRCxjQUx4QjtBQU1qQjdFLFlBQU9BLEtBTlU7QUFPakJQLGFBQVFxRixVQUFVckYsTUFQRDtBQVFqQitDLGlCQUFZc0MsVUFBVXRDLFVBUkw7QUFTakI4QixlQUFVUSxVQUFVUjtBQVRILEtBQWxCO0FBV0E7QUFDRCxHQTlERDtBQStEQSxFQWhFRCxNQWdFTztBQUNOWixjQUFZdEUsSUFBWixDQUFrQjtBQUNqQkgsZUFBWUgsTUFBTUcsVUFERDtBQUVqQjhFLGlCQUFjRCxXQUZHO0FBR2pCSSxhQUFVcEYsTUFBTW9GLFFBSEM7QUFJakJ2QixlQUFZN0QsTUFBTUgsSUFKRDtBQUtqQndGLGVBQVlyRixNQUFNSCxJQUxEO0FBTWpCcUIsVUFBT3VFLFVBTlU7QUFPakI5RSxXQUFRakQsZUFBZ0JzQyxLQUFoQixDQVBTO0FBUWpCMEQsZUFBWWpHLGdCQUFpQnVDLEtBQWpCLENBUks7QUFTakJ3RixhQUFVbEksZUFBZ0IwQyxLQUFoQjtBQVRPLEdBQWxCO0FBV0E7O0FBRUQsUUFBTzRFLFdBQVA7QUFDQTs7QUFFRDs7Ozs7O0FBTU8sU0FBU3ZILG9CQUFULENBQStCMkMsS0FBL0IsRUFBc0N5RixVQUF0QyxFQUFrRFQsV0FBbEQsRUFBZ0U7QUFDdEUsS0FBTUosY0FBYyxFQUFwQjtBQUNDLEVBQ0M7QUFDQ3FCLFVBQVE7QUFEVCxFQURELEVBSUM7QUFDQ0EsVUFBUTtBQURULEVBSkQsRUFPRTVHLEdBUEYsQ0FPTyxxQkFBYTtBQUNuQnVGLGNBQVl0RSxJQUFaLENBQWtCO0FBQ2pCSCxlQUFZSCxNQUFNRyxVQUFOLEdBQW1CLEdBQW5CLEdBQXlCNkYsVUFBVUMsTUFEOUI7QUFFakJoQixpQkFBY0QsV0FGRztBQUdqQkksYUFBVXBGLE1BQU1vRixRQUhDO0FBSWpCdkIsZUFBWTdELE1BQU1ILElBSkQ7QUFLakJ3RixlQUFZckYsTUFBTUgsSUFBTixHQUFhLEdBQWIsR0FBbUJtRyxVQUFVQyxNQUx4QjtBQU1qQi9FLFVBQU91RSxhQUFhLEtBQWIsR0FBcUJPLFVBQVVDLE1BTnJCO0FBT2pCVCxhQUFVLElBUE87QUFRakJGLGFBQVUvSCxjQUFleUMsS0FBZjtBQVJPLEdBQWxCO0FBVUEsRUFsQkQ7O0FBb0JELFFBQU80RSxXQUFQO0FBQ0E7O0FBRUQ7OztBQUdPLFNBQVN0SCxjQUFULENBQXlCMEMsS0FBekIsRUFBaUM7QUFDdkMsS0FBS1MsRUFBRXlCLFFBQUYsQ0FBWSxDQUFFLGFBQUYsRUFBaUIsUUFBakIsRUFBMkIsUUFBM0IsRUFBcUMsT0FBckMsRUFBOEMsVUFBOUMsQ0FBWixFQUF3RWxDLE1BQU1ILElBQTlFLENBQUwsRUFBNEY7QUFDM0YsU0FBTyxJQUFQO0FBQ0E7O0FBRUQsUUFBTyxLQUFQO0FBQ0E7O0FBRUQ7OztBQUdPLFNBQVN0QyxhQUFULENBQXdCeUMsS0FBeEIsRUFBZ0M7QUFDdEMsS0FBS0EsTUFBTWtHLFlBQU4sS0FBdUIsTUFBdkIsSUFBaUNsRyxNQUFNa0csWUFBTixLQUF1QixJQUE3RCxFQUFvRTtBQUNuRSxTQUFPLElBQVA7QUFDQTs7QUFFRCxRQUFPLEtBQVA7QUFDQTs7QUFFTSxTQUFTMUksWUFBVCxDQUF1QndDLEtBQXZCLEVBQStCO0FBQ3JDLEtBQUtBLE1BQU11RixPQUFYLEVBQXFCO0FBQ3BCLFNBQU92RixNQUFNdUYsT0FBYjtBQUNBOztBQUVELFFBQU8sS0FBUDtBQUNBOztBQUVEOzs7QUFHTyxTQUFTOUgsZUFBVCxDQUEwQnVDLEtBQTFCLEVBQWtDO0FBQ3hDLEtBQUtBLE1BQU1ILElBQU4sS0FBZSxRQUFmLElBQTJCRyxNQUFNSCxJQUFOLEtBQWUsVUFBMUMsSUFBd0RHLE1BQU1ILElBQU4sS0FBZSxPQUE1RSxFQUFzRjtBQUNyRixTQUFPLElBQVA7QUFDQTs7QUFFRCxRQUFPLEtBQVA7QUFDQTs7QUFFRDs7O0FBR08sU0FBU25DLGNBQVQsQ0FBeUJzQyxLQUF6QixFQUFpQztBQUN2QyxLQUFNSCxPQUFPRyxNQUFNSCxJQUFuQjs7QUFFQSxLQUFLQSxTQUFTLFFBQVQsSUFBcUJBLFNBQVMsVUFBOUIsSUFBNENBLFNBQVMsT0FBMUQsRUFBb0U7QUFDbkUsU0FBT0csTUFBTWdDLE9BQWI7QUFDQTs7QUFFRCxRQUFPLEtBQVA7QUFDQTs7QUFFRDs7Ozs7O0FBTU8sU0FBU3JFLGdCQUFULENBQTJCcUMsS0FBM0IsRUFBa0N5RixVQUFsQyxFQUE4Q1QsV0FBOUMsRUFBNEQ7QUFDbEUsS0FBTUosY0FBYyxFQUFwQjs7QUFFQSxFQUNDO0FBQ0NrQixRQUFNLGdCQURQO0FBRUM1RSxTQUFPLHNCQUZSO0FBR0M2RSxrQkFBZ0IsZ0JBSGpCO0FBSUNyQyxjQUFZLEtBSmI7QUFLQy9DLFVBQVEsS0FMVDtBQU1DNkUsWUFBVTtBQU5YLEVBREQsRUFTQztBQUNDTSxRQUFNLGNBRFA7QUFFQzVFLFNBQU8sb0JBRlI7QUFHQzZFLGtCQUFnQixjQUhqQjtBQUlDckMsY0FBWSxLQUpiO0FBS0MvQyxVQUFRLEtBTFQ7QUFNQzZFLFlBQVU7QUFOWCxFQVRELEVBaUJDO0FBQ0NNLFFBQU0sY0FEUDtBQUVDNUUsU0FBTyxvQkFGUjtBQUdDNkUsa0JBQWdCLE1BSGpCO0FBSUNyQyxjQUFZLEtBSmI7QUFLQy9DLFVBQVEsS0FMVDtBQU1DNkUsWUFBVTtBQU5YLEVBakJELEVBeUJDO0FBQ0NNLFFBQU0sZUFEUDtBQUVDNUUsU0FBTyxxQkFGUjtBQUdDNkUsa0JBQWdCLE9BSGpCO0FBSUNyQyxjQUFZLEtBSmI7QUFLQy9DLFVBQVEsS0FMVDtBQU1DNkUsWUFBVTtBQU5YLEVBekJELEVBaUNDO0FBQ0NNLFFBQU0sYUFEUDtBQUVDNUUsU0FBTyxtQkFGUjtBQUdDNkUsa0JBQWdCLEtBSGpCO0FBSUNyQyxjQUFZLEtBSmI7QUFLQy9DLFVBQVEsS0FMVDtBQU1DNkUsWUFBVTtBQU5YLEVBakNELEVBeUNDO0FBQ0NNLFFBQU0saUJBRFA7QUFFQzVFLFNBQU8sdUJBRlI7QUFHQzZFLGtCQUFnQixTQUhqQjtBQUlDckMsY0FBWSxLQUpiO0FBS0MvQyxVQUFRLEtBTFQ7QUFNQzZFLFlBQVU7QUFOWCxFQXpDRCxFQWlERW5HLEdBakRGLENBaURPLHFCQUFhO0FBQ25CLE1BQUtaLE9BQVF1QixNQUFPZ0csVUFBVUYsSUFBakIsQ0FBUixDQUFMLEVBQXlDO0FBQ3hDLE9BQUk1RSxjQUFKO0FBQ0EsT0FBSyxDQUFFVCxFQUFFMkMsV0FBRixDQUFlcEQsTUFBT2dHLFVBQVU5RSxLQUFqQixDQUFmLENBQUYsSUFBK0MsQ0FBRVQsRUFBRUMsT0FBRixDQUFXVixNQUFPZ0csVUFBVTlFLEtBQWpCLENBQVgsQ0FBdEQsRUFBOEY7QUFDN0ZBLFlBQVF1RSxhQUFhLEtBQWIsR0FBcUJ6RixNQUFPZ0csVUFBVTlFLEtBQWpCLENBQTdCO0FBQ0EsSUFGRCxNQUVPO0FBQ05BLFlBQVF1RSxhQUFhLEtBQXJCO0FBQ0E7O0FBRURiLGVBQVl0RSxJQUFaLENBQWtCO0FBQ2pCSCxnQkFBWUgsTUFBTUcsVUFBTixHQUFtQixHQUFuQixHQUF5QjZGLFVBQVVELGNBRDlCO0FBRWpCZCxrQkFBY0QsV0FGRztBQUdqQkksY0FBVXBGLE1BQU1vRixRQUhDO0FBSWpCdkIsZ0JBQVk3RCxNQUFNSCxJQUpEO0FBS2pCd0YsZ0JBQVlyRixNQUFNSCxJQUFOLEdBQWEsR0FBYixHQUFtQm1HLFVBQVVELGNBTHhCO0FBTWpCN0UsV0FBT0EsS0FOVTtBQU9qQlAsWUFBUXFGLFVBQVVyRixNQVBEO0FBUWpCK0MsZ0JBQVlzQyxVQUFVdEMsVUFSTDtBQVNqQjhCLGNBQVVRLFVBQVVSO0FBVEgsSUFBbEI7QUFXQTtBQUNELEVBdEVEOztBQXdFQSxRQUFPWixXQUFQO0FBQ0E7O0FBRUQ7Ozs7OztBQU1PLFNBQVNoSCxhQUFULENBQXdCb0MsS0FBeEIsRUFBK0J5RixVQUEvQixFQUEyQ1QsV0FBM0MsRUFBeUQ7QUFDL0QsS0FBTUosY0FBYyxFQUFwQjs7QUFFQSxLQUFJdUIsaUJBQUo7QUFDQSxLQUFLLENBQUUxRixFQUFFMkMsV0FBRixDQUFlcEQsTUFBTW1HLFFBQXJCLENBQUYsSUFBcUMsQ0FBRTFGLEVBQUVDLE9BQUYsQ0FBV1YsTUFBTW1HLFFBQWpCLENBQTVDLEVBQTBFO0FBQ3pFQSxhQUFXVixhQUFhLEtBQWIsR0FBcUJ6RixNQUFNbUcsUUFBdEM7QUFDQSxFQUZELE1BRU87QUFDTkEsYUFBV1YsYUFBYSxLQUFiLEdBQXFCNUksVUFBVyxNQUFYLENBQWhDO0FBQ0E7O0FBRUQsS0FBSXVKLGlCQUFKO0FBQ0EsS0FBSyxDQUFFM0YsRUFBRTJDLFdBQUYsQ0FBZXBELE1BQU1vRyxRQUFyQixDQUFGLElBQXFDLENBQUUzRixFQUFFQyxPQUFGLENBQVdWLE1BQU1vRyxRQUFqQixDQUE1QyxFQUEwRTtBQUN6RUEsYUFBV1gsYUFBYSxLQUFiLEdBQXFCekYsTUFBTW9HLFFBQXRDO0FBQ0EsRUFGRCxNQUVPO0FBQ05BLGFBQVdYLGFBQWEsS0FBYixHQUFxQjVJLFVBQVcsUUFBWCxDQUFoQztBQUNBOztBQUVEK0gsYUFBWXRFLElBQVosQ0FDQztBQUNDSCxjQUFZSCxNQUFNRyxVQUFOLEdBQW1CLFFBRGhDO0FBRUM4RSxnQkFBY0QsV0FGZjtBQUdDSSxZQUFVcEYsTUFBTW9GLFFBSGpCO0FBSUN2QixjQUFZN0QsTUFBTUgsSUFKbkI7QUFLQ3dGLGNBQVlyRixNQUFNSCxJQUFOLEdBQWEsUUFMMUI7QUFNQ3FCLFNBQU9pRixRQU5SO0FBT0N4RixVQUFRLEtBUFQ7QUFRQytDLGNBQVksS0FSYjtBQVNDOEIsWUFBVTtBQVRYLEVBREQsRUFZQztBQUNDckYsY0FBWUgsTUFBTUcsVUFBTixHQUFtQixVQURoQztBQUVDOEUsZ0JBQWNELFdBRmY7QUFHQ0ksWUFBVXBGLE1BQU1vRixRQUhqQjtBQUlDdkIsY0FBWTdELE1BQU1ILElBSm5CO0FBS0N3RixjQUFZckYsTUFBTUgsSUFBTixHQUFhLFVBTDFCO0FBTUNxQixTQUFPa0YsUUFOUjtBQU9DekYsVUFBUSxLQVBUO0FBUUMrQyxjQUFZLEtBUmI7QUFTQzhCLFlBQVU7QUFUWCxFQVpEOztBQXlCQSxLQUFLeEYsTUFBTXFHLFNBQU4sS0FBb0IsUUFBekIsRUFBb0M7QUFDbkN6QixjQUFZdEUsSUFBWixDQUFrQjtBQUNqQkgsZUFBWUgsTUFBTUcsVUFBTixHQUFtQixPQURkO0FBRWpCOEUsaUJBQWNELFdBRkc7QUFHakJJLGFBQVVwRixNQUFNb0YsUUFIQztBQUlqQnZCLGVBQVk3RCxNQUFNSCxJQUpEO0FBS2pCd0YsZUFBWXJGLE1BQU1ILElBQU4sR0FBYSxPQUxSO0FBTWpCcUIsVUFBT3VFLGFBQWEsUUFOSDtBQU9qQjlFLFdBQVEsQ0FBRSxFQUFFTyxPQUFPLElBQVQsRUFBZUwsT0FBTyxJQUF0QixFQUFGLEVBQWdDLEVBQUVLLE9BQU8sSUFBVCxFQUFlTCxPQUFPLElBQXRCLEVBQWhDLENBUFM7QUFRakI2QyxlQUFZLElBUks7QUFTakI4QixhQUFVO0FBVE8sR0FBbEI7QUFXQTs7QUFFRCxRQUFPWixXQUFQO0FBQ0E7O0FBRUQ7Ozs7O0FBS08sU0FBUy9HLHlCQUFULENBQW9DeUksU0FBcEMsRUFBZ0Q7QUFDdEQsS0FBSUMsb0JBQW9CLEVBQXhCO0FBQ0EsS0FBSUMsZ0JBQWdCM0UsZUFBZTlCLE1BQWYsQ0FBc0JrRCxNQUF0QixDQUE4QixpQkFBUztBQUMxRCxTQUFPakQsTUFBTUgsSUFBTixLQUFleUcsU0FBdEI7QUFDQSxFQUZtQixDQUFwQjs7QUFJQSxLQUFLRSxjQUFjN0MsTUFBZCxHQUF1QixDQUE1QixFQUFnQztBQUMvQixTQUFPLEVBQVA7QUFDQTs7QUFFRDZDLGlCQUFnQkEsY0FBZSxDQUFmLENBQWhCO0FBQ0EsS0FBSyxDQUFFL0YsRUFBRTJDLFdBQUYsQ0FBZW9ELGNBQWNDLGlCQUE3QixDQUFQLEVBQTBEO0FBQ3pERixzQkFBb0JDLGNBQWNDLGlCQUFsQztBQUNBOztBQUVELFFBQU9GLGlCQUFQO0FBQ0E7O0FBRUQ7Ozs7Ozs7O0FBUU8sU0FBU3pJLFlBQVQsQ0FBdUJpRyxJQUF2QixFQUE2QmxFLElBQTdCLEVBQW9DZ0IsS0FBcEMsRUFBNEM7QUFDbEQsS0FBSTZGLE1BQVEsQ0FBQ2pHLEVBQUUyQyxXQUFGLENBQWV2QyxLQUFmLENBQUgsR0FBOEJBLEtBQTlCLEdBQXNDLEVBQWhEO0FBQ0EsU0FBU2tELElBQVQ7QUFDQyxPQUFLLElBQUw7QUFDQyxVQUFPbEgsVUFBVyxJQUFYLENBQVA7QUFDRCxPQUFLLFFBQUw7QUFDQyxVQUFPQSxVQUFXLFFBQVgsQ0FBUDtBQUNELE9BQUssUUFBTDtBQUNDLFVBQU9BLFVBQVcsUUFBWCxDQUFQO0FBQ0QsT0FBSyxZQUFMO0FBQ0MsVUFBT0EsVUFBVyxZQUFYLENBQVA7QUFDRCxPQUFLLGNBQUw7QUFDQyxVQUFPQSxVQUFXLGNBQVgsQ0FBUDtBQUNELE9BQUssVUFBTDtBQUNDLFVBQU9BLFVBQVcsVUFBWCxDQUFQO0FBQ0QsT0FBSyxXQUFMO0FBQ0MsVUFBT0EsVUFBVyxXQUFYLENBQVA7QUFDRCxPQUFLLFVBQUw7QUFDQyxVQUFPQSxVQUFXLFVBQVgsQ0FBUDtBQUNELE9BQUssMEJBQUw7QUFDQyxVQUFPQSxVQUFXLDZDQUFYLEVBQTJEa0UsT0FBM0QsQ0FBb0UsSUFBcEUsRUFBMEUyRixHQUExRSxDQUFQO0FBQ0QsT0FBSyw0QkFBTDtBQUNDLFVBQU83SixVQUFXLCtDQUFYLEVBQTZEa0UsT0FBN0QsQ0FBc0UsSUFBdEUsRUFBNEUyRixHQUE1RSxDQUFQO0FBQ0QsT0FBSyx5QkFBTDtBQUNDLFVBQU83SixVQUFXLDRDQUFYLEVBQTBEa0UsT0FBMUQsQ0FBbUUsSUFBbkUsRUFBeUUyRixHQUF6RSxDQUFQO0FBQ0QsT0FBSywyQkFBTDtBQUNDLFVBQU83SixVQUFXLDhDQUFYLEVBQTREa0UsT0FBNUQsQ0FBcUUsSUFBckUsRUFBMkUyRixHQUEzRSxDQUFQO0FBQ0QsT0FBSyxVQUFMO0FBQ0MsVUFBTzdKLFVBQVcsaUJBQVgsQ0FBUDtBQUNELE9BQUssU0FBTDtBQUNDLFVBQU9BLFVBQVcsY0FBWCxDQUFQO0FBQ0QsT0FBSyxVQUFMO0FBQ0MsVUFBT0EsVUFBVyxVQUFYLENBQVA7QUFDRCxPQUFLLFFBQUw7QUFDQyxVQUFPQSxVQUFXLGFBQVgsQ0FBUDtBQUNELE9BQUssTUFBTDtBQUNDLFVBQU9BLFVBQVcsV0FBWCxDQUFQO0FBQ0QsT0FBSyxZQUFMO0FBQ0MsVUFBT0EsVUFBVyxZQUFYLENBQVA7QUFDRCxPQUFLLGNBQUw7QUFDQyxVQUFPQSxVQUFXLGNBQVgsQ0FBUDtBQUNEO0FBQ0EsT0FBSyxpQkFBTDtBQUNDLFVBQU9BLFVBQVcsaUJBQVgsQ0FBUDtBQUNELE9BQUsscUJBQUw7QUFDQyxVQUFPQSxVQUFXLHFCQUFYLENBQVA7QUFDRDtBQUNDLFVBQU8sR0FBUDtBQTdDRjtBQStDQTs7QUFFRDs7Ozs7O0FBTU8sU0FBU2tCLFNBQVQsQ0FBb0I4QyxLQUFwQixFQUE0QjtBQUNsQyxLQUFLQSxNQUFNOEMsTUFBTixHQUFlLENBQXBCLEVBQXdCO0FBQ3ZCLFNBQU8sS0FBUDtBQUNBOztBQUVEO0FBQ0EsS0FBSzlDLE1BQU04RixPQUFOLENBQWUsR0FBZixFQUFvQixDQUFwQixJQUEwQixDQUEvQixFQUFtQztBQUNsQyxTQUFPLEtBQVA7QUFDQTs7QUFFRDtBQUNBLEtBQU1DLFFBQVEvRixNQUFNUixLQUFOLENBQWEsR0FBYixFQUFrQixDQUFsQixDQUFkOztBQUVBO0FBQ0E7QUFDQSxLQUFLLENBQUV1RyxNQUFPLENBQVAsRUFBV0MsS0FBWCxDQUFrQixzQ0FBbEIsQ0FBUCxFQUFvRTtBQUNuRSxTQUFPLEtBQVA7QUFDQTs7QUFFRDtBQUNBO0FBQ0EsS0FBS0QsTUFBTyxDQUFQLEVBQVdDLEtBQVgsQ0FBa0IsUUFBbEIsQ0FBTCxFQUFvQztBQUNuQyxTQUFPLEtBQVA7QUFDQTs7QUFFRCxLQUFNQyxTQUFTRixNQUFPLENBQVAsQ0FBZjtBQUNBO0FBQ0EsS0FBTUcsT0FBT0QsT0FBT3pHLEtBQVAsQ0FBYyxHQUFkLENBQWI7QUFDQSxLQUFLMEcsS0FBS3BELE1BQUwsR0FBYyxDQUFuQixFQUF1QjtBQUN0QixTQUFPLEtBQVA7QUFDQTs7QUFFRCxLQUFNcUQsVUFBVUQsS0FBS3BELE1BQXJCO0FBQ0EsTUFBTSxJQUFJc0QsSUFBSSxDQUFkLEVBQWlCQSxJQUFJRCxPQUFyQixFQUE4QkMsR0FBOUIsRUFBb0M7QUFDbkM7QUFDQSxNQUFLLENBQUVGLEtBQU1FLENBQU4sRUFBVUosS0FBVixDQUFpQixlQUFqQixDQUFQLEVBQTRDO0FBQzNDLFVBQU8sS0FBUDtBQUNBO0FBQ0Q7QUFDRCxRQUFPLElBQVA7QUFDQTs7QUFFRDs7O0FBR08sU0FBUzdJLGlCQUFULEdBQTZCO0FBQ25DLEtBQUsscUJBQW9Ca0osT0FBT0MsR0FBM0IsQ0FBTCxFQUFzQztBQUNyQztBQUNBOztBQUVEO0FBQ0FDLFlBQVksWUFBVztBQUN0QjtBQUNBRCxNQUFJRSxZQUFKLENBQWtCQyxPQUFRLGdCQUFSLENBQWxCOztBQUVBO0FBQ0FILE1BQUlJLE9BQUosQ0FBYUQsT0FBUSxXQUFSLENBQWI7O0FBRUE7QUFDQUEsU0FBUSxzQ0FBUixFQUFpREUsSUFBakQsQ0FBdUQsWUFBVztBQUNqRUwsT0FBSU0sTUFBSixDQUFXQyxRQUFYLENBQXFCSixPQUFRLElBQVIsQ0FBckI7QUFDQSxHQUZEOztBQUlBQSxTQUFRLHVDQUFSLEVBQWtERSxJQUFsRCxDQUF3RCxZQUFXO0FBQ2xFTCxPQUFJTSxNQUFKLENBQVdFLFNBQVgsQ0FBc0JMLE9BQVEsSUFBUixDQUF0QjtBQUNBLEdBRkQ7O0FBSUFBLFNBQVEsd0NBQVIsRUFBbURFLElBQW5ELENBQXlELFlBQVc7QUFDbkVMLE9BQUlNLE1BQUosQ0FBV0csVUFBWCxDQUF1Qk4sT0FBUSxJQUFSLENBQXZCO0FBQ0EsR0FGRDs7QUFJQUEsU0FBUSxpRkFBUixFQUE0RkUsSUFBNUYsQ0FBa0csWUFBVztBQUM1R0wsT0FBSU0sTUFBSixDQUFXSSxJQUFYLENBQWlCUCxPQUFRLElBQVIsQ0FBakI7QUFDQSxHQUZEOztBQUlBO0FBQ0FBLFNBQVEsc0JBQVIsRUFBaUNFLElBQWpDLENBQXVDLFlBQVc7QUFDakRMLE9BQUlNLE1BQUosQ0FBV0ssUUFBWCxDQUFxQlIsT0FBUSxJQUFSLENBQXJCO0FBQ0EsR0FGRDs7QUFJQTtBQUNBSCxNQUFJWSxlQUFKLENBQXFCVCxPQUFRLG1CQUFSLENBQXJCOztBQUVBO0FBQ0FILE1BQUlhLGdCQUFKO0FBQ0EsRUFsQ0QsRUFrQ0csRUFsQ0g7QUFtQ0E7O0FBRUQ7Ozs7Ozs7QUFPTyxTQUFTL0osWUFBVCxDQUF1QjBCLFFBQXZCLEVBQWtDO0FBQ3hDLEtBQUlFLE9BQU8sTUFBWDs7QUFFQSxLQUFLLFFBQU9GLFNBQVUsZUFBVixDQUFQLGFBQTZDQSxTQUFVLGVBQVYsQ0FBN0MsQ0FBTCxFQUFnRjtBQUMvRSxNQUFLQSxTQUFVLGVBQVYsTUFBZ0MsU0FBaEMsSUFBNkNBLFNBQVUsZUFBVixNQUFnQyxZQUFsRixFQUFpRztBQUNoR0UsVUFBT0YsU0FBVSxlQUFWLENBQVA7QUFDQTtBQUNEOztBQUVELFFBQU9FLElBQVA7QUFDQTs7QUFFRDs7Ozs7OztBQU9PLFNBQVMzQixvQkFBVCxDQUErQmlCLFFBQS9CLEVBQTBDO0FBQ2hELEtBQU04SSxXQUFXLEVBQWpCOztBQUVBO0FBQ0F4SCxHQUFFK0csSUFBRixDQUFRM0YsZUFBZTlCLE1BQXZCLEVBQStCLGlCQUFTO0FBQ3ZDLE1BQUtDLE1BQU1ILElBQU4sS0FBZSxhQUFwQixFQUFvQztBQUNuQ29JLFlBQVMzSCxJQUFULENBQWVOLE1BQU1ILElBQXJCO0FBQ0E7QUFDRCxFQUpEOztBQU1BLFFBQU8zQyxVQUFXaUMsUUFBWCxFQUFxQjhJLFFBQXJCLENBQVA7QUFDQTs7QUFFRDs7Ozs7O0FBTU8sU0FBUzlKLFdBQVQsQ0FBc0IrSixHQUF0QixFQUEyQmxHLE9BQTNCLEVBQXFDO0FBQzNDQSxXQUFVdkIsRUFBRTZCLFFBQUYsQ0FBWU4sT0FBWixFQUFxQjtBQUM5Qm1HLGNBQVksSUFEa0I7QUFFOUJDLG9CQUFrQjtBQUZZLEVBQXJCLENBQVY7O0FBS0E7QUFDQUYsS0FBSXBHLElBQUosQ0FBVSxvQ0FBVixFQUFpRDBGLElBQWpELENBQXVELFlBQVc7QUFDakU7QUFDQSxNQUFLRixPQUFRLElBQVIsRUFBZXhCLElBQWYsQ0FBcUIsY0FBckIsQ0FBTCxFQUE2QztBQUM1Q3dCLFVBQVEsSUFBUixFQUFlZSxFQUFmLENBQW1CLGdCQUFuQixFQUFxQyxVQUFVQyxDQUFWLEVBQWM7QUFDbEQsUUFBTUMsTUFBTUQsRUFBRUUsTUFBRixDQUFTQyxJQUFULENBQWNDLE9BQTFCO0FBQUEsUUFDQ0MsT0FBT3JCLE9BQVFpQixHQUFSLENBRFI7QUFBQSxRQUVDSyxLQUFLdEIsT0FBUSxJQUFSLENBRk47QUFHQXNCLE9BQUdDLE1BQUgsQ0FBV0YsSUFBWDtBQUNBQyxPQUFHRSxPQUFILENBQVksZ0JBQVo7QUFDQSxJQU5EO0FBT0E7QUFDRHhCLFNBQVEsSUFBUixFQUFleUIsVUFBZixDQUEyQi9HLE9BQTNCO0FBQ0EsRUFaRDtBQWFBOztBQUVEOzs7Ozs7O0FBT08sU0FBUzVELGVBQVQsQ0FBMEI0QixLQUExQixFQUFrQztBQUN4QztBQUNBLEtBQUtBLE1BQU1ILElBQU4sS0FBZSxNQUFwQixFQUE2QjtBQUM1QixNQUFLRyxNQUFNNkYsYUFBTixLQUF3QixNQUF4QixJQUFrQzdGLE1BQU02RixhQUFOLEtBQXdCLElBQS9ELEVBQXNFO0FBQ3JFOztBQUVBLE9BQUs3RixNQUFPLGlCQUFQLEtBQ0pBLE1BQU8sZ0JBQVAsQ0FESSxJQUVKQSxNQUFPLGdCQUFQLENBRkksSUFHSkEsTUFBTyxnQkFBUCxDQUhELEVBSUU7QUFDRCxXQUFPLElBQVA7QUFDQSxJQU5ELE1BTU87QUFDTixXQUFPLEtBQVA7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQSxLQUFLQSxNQUFNSCxJQUFOLEtBQWUsU0FBcEIsRUFBZ0M7QUFDL0IsTUFBS0csTUFBTyx5QkFBUCxLQUNKQSxNQUFPLHVCQUFQLENBREksSUFFSkEsTUFBTyx1QkFBUCxDQUZJLElBR0pBLE1BQU8sd0JBQVAsQ0FISSxJQUlKQSxNQUFPLHNCQUFQLENBSkksSUFLSkEsTUFBTywwQkFBUCxDQUxELEVBTUU7QUFDRCxVQUFPLElBQVA7QUFDQSxHQVJELE1BUU87QUFDTixVQUFPLEtBQVA7QUFDQTtBQUNEOztBQUVEO0FBQ0EsUUFBT0EsTUFBTW9GLFFBQWI7QUFDQTs7QUFFRDs7O0FBR08sU0FBUy9HLHFCQUFULENBQWdDYyxRQUFoQyxFQUEwQ1UsSUFBMUMsRUFBZ0RtRyxTQUFoRCxFQUEyRG5GLEtBQTNELEVBQW1FO0FBQ3pFLEtBQUlmLFVBQVUsQ0FBZDs7QUFFQSxLQUFLa0IsZUFBZ0I3QixRQUFoQixDQUFMLEVBQWtDO0FBQ2pDLFNBQU8sSUFBUDtBQUNBOztBQUVEQSxVQUFTRSxHQUFULENBQWMsbUJBQVc7QUFDeEJDLFVBQVFTLE1BQVIsQ0FBZVYsR0FBZixDQUFvQixpQkFBUztBQUM1QixPQUFLUSxTQUFTRyxNQUFNSCxJQUFmLElBQXVCZ0IsVUFBVWIsTUFBT2dHLFNBQVAsQ0FBdEMsRUFBMkQ7QUFDMURsRztBQUNBO0FBQ0QsR0FKRDtBQUtBLEVBTkQ7O0FBUUEsUUFBT0EsVUFBVSxDQUFqQjtBQUNBOztBQUVEOzs7QUFHTyxTQUFTeEIsK0JBQVQsQ0FBMENhLFFBQTFDLEVBQXFEO0FBQzNELEtBQUlXLFVBQVUsQ0FBZDs7QUFFQSxLQUFLa0IsZUFBZ0I3QixRQUFoQixDQUFMLEVBQWtDO0FBQ2pDLFNBQU8sSUFBUDtBQUNBOztBQUVEQSxVQUFTRSxHQUFULENBQWMsbUJBQVc7QUFDeEJDLFVBQVFTLE1BQVIsQ0FBZVYsR0FBZixDQUFvQixpQkFBUztBQUM1QixPQUFNMkosZ0JBQWdCbkgsZUFBZW9ILGNBQWYsQ0FBK0JqSixNQUFNa0osU0FBckMsQ0FBdEI7QUFDQSxPQUFJLE9BQU9GLGFBQVAsS0FBeUIsV0FBN0IsRUFBMkM7QUFDMUNBLGtCQUFjM0osR0FBZCxDQUFtQixvQkFBWTtBQUM5QixTQUFNOEosZUFBZUMsU0FBU3ZJLEtBQVQsR0FBaUIsV0FBdEM7QUFDQSxTQUFJLE1BQU1OLFNBQVVQLE1BQU9tSixZQUFQLENBQVYsQ0FBVixFQUE4QztBQUM3Q3JKO0FBQ0E7QUFDRCxLQUxEO0FBTUE7QUFDRCxHQVZEO0FBV0EsRUFaRDs7QUFjQSxRQUFPQSxVQUFVLENBQWpCO0FBQ0E7O0FBRUQ7Ozs7Ozs7QUFPTyxTQUFTdkIsdUJBQVQsQ0FBa0M4SyxrQkFBbEMsRUFBc0RDLFNBQXRELEVBQWtFO0FBQ3hFLEtBQU1DLGtCQUFrQkYsbUJBQW1CekgsSUFBM0M7QUFDQSxLQUFJNEgsaUJBQWlCLEVBQXJCOztBQUVBLEtBQUssQ0FBRS9JLEVBQUVDLE9BQUYsQ0FBVzRJLFNBQVgsQ0FBUCxFQUFnQztBQUMvQjdJLElBQUUrRyxJQUFGLENBQVE4QixTQUFSLEVBQW1CLFVBQVVHLFFBQVYsRUFBb0JDLFdBQXBCLEVBQWtDO0FBQ3BELE9BQUssQ0FBRWpKLEVBQUVDLE9BQUYsQ0FBVytJLFNBQVNFLE9BQXBCLENBQVAsRUFBdUM7QUFDdENsSixNQUFFK0csSUFBRixDQUFRaUMsU0FBU0UsT0FBakIsRUFBMEIsVUFBVUMsTUFBVixFQUFrQkMsU0FBbEIsRUFBOEI7QUFDdkQsU0FBS0QsT0FBT0UsTUFBUCxLQUFrQlAsZUFBdkIsRUFBeUM7QUFDeENDLHFCQUFlbEosSUFBZixDQUFxQjtBQUNwQnlKLGNBQU9OLFNBQVNNLEtBREk7QUFFcEJuSSxhQUFNNkgsU0FBUzdILElBRks7QUFHcEI2SCxpQkFBVUE7QUFIVSxPQUFyQjtBQUtBO0FBQ0QsS0FSRDtBQVNBO0FBQ0QsR0FaRDtBQWFBRCxtQkFBaUIvSSxFQUFFdUosSUFBRixDQUFRUixjQUFSLEVBQXdCLE1BQXhCLENBQWpCO0FBQ0E7O0FBRUQsUUFBT0EsY0FBUDtBQUNBOztBQUVEOzs7Ozs7OztBQVFPLFNBQVNoTCxpQkFBVCxDQUE0QnlMLFVBQTVCLEVBQXdDQyxRQUF4QyxFQUFtRDs7QUFFekQsS0FBSUMsZUFBZSxFQUFuQjs7QUFFQTFKLEdBQUUrRyxJQUFGLENBQVEwQyxRQUFSLEVBQWtCLFVBQVVFLE9BQVYsRUFBbUJDLEtBQW5CLEVBQTJCO0FBQzVDLE1BQUssQ0FBRUQsUUFBUUUsV0FBVixJQUF5QixDQUFFRixRQUFRRyxTQUF4QyxFQUFvRDtBQUNuRE4sY0FBV08sS0FBWCxHQUFtQjNOLFVBQVcsOENBQVgsQ0FBbkI7QUFDQW9OLGNBQVdRLE9BQVgsR0FBcUIsS0FBckI7QUFDQU4sZ0JBQWE3SixJQUFiLENBQW1CK0osS0FBbkI7QUFDQTs7QUFFRCxNQUFLLGFBQWFELFFBQVFNLGNBQXJCLEtBQ0EsWUFBWU4sUUFBUUUsV0FBcEIsSUFBbUM3SixFQUFFQyxPQUFGLENBQVcwSixRQUFRTyxNQUFuQixDQUFyQyxJQUNDLGVBQWVQLFFBQVFFLFdBQXZCLElBQXNDN0osRUFBRUMsT0FBRixDQUFXMEosUUFBUVEsUUFBbkIsQ0FGckMsQ0FBTCxFQUlFO0FBQ0RYLGNBQVdPLEtBQVgsR0FBbUIzTixVQUFXLDhDQUFYLENBQW5CO0FBQ0FvTixjQUFXUSxPQUFYLEdBQXFCLEtBQXJCO0FBQ0FOLGdCQUFhN0osSUFBYixDQUFtQitKLEtBQW5CO0FBQ0EsR0FSRCxNQVFPLElBQUssbUJBQW1CRCxRQUFRTSxjQUFoQyxFQUFpRDtBQUN2RCxPQUFNRyxxQkFBcUIsQ0FBRXBLLEVBQUUyQyxXQUFGLENBQWVnSCxRQUFRVSx3QkFBdkIsQ0FBRixHQUN4QlYsUUFBUVUsd0JBRGdCLEdBRXhCLE9BRkg7QUFHQSxPQUFNQyx1QkFBdUIsQ0FBRXRLLEVBQUUyQyxXQUFGLENBQWVnSCxRQUFRWSxhQUF2QixDQUFGLEdBQzFCWixRQUFRWSxhQURrQixHQUUxQixPQUZIO0FBR0EsT0FBTUMsV0FBVyxDQUFFeEssRUFBRTJDLFdBQUYsQ0FBZWdILFFBQVFjLFFBQXZCLENBQUYsR0FDZGQsUUFBUWMsUUFETSxHQUVkLENBRkg7QUFHQSxPQUFNQyxZQUFZLENBQUUxSyxFQUFFMkMsV0FBRixDQUFlZ0gsUUFBUWdCLFVBQXZCLENBQUYsR0FDZmhCLFFBQVFnQixVQURPLEdBRWYsQ0FGSDtBQUdBLE9BQU8sWUFBWVAsa0JBQVosSUFBa0NwSyxFQUFFQyxPQUFGLENBQVcwSixRQUFRaUIsbUJBQW5CLENBQXBDLElBQ0YsZUFBZVIsa0JBQWYsSUFBcUNwSyxFQUFFQyxPQUFGLENBQVcwSixRQUFRa0IscUJBQW5CLENBRHhDLEVBRUU7QUFDRHJCLGVBQVdPLEtBQVgsR0FBbUIzTixVQUFXLDhDQUFYLENBQW5CO0FBQ0FvTixlQUFXUSxPQUFYLEdBQXFCLEtBQXJCO0FBQ0FOLGlCQUFhN0osSUFBYixDQUFtQitKLEtBQW5CO0FBQ0E7QUFDRCxPQUFPLFlBQVlVLG9CQUFaLElBQW9DLENBQUVFLFFBQXhDLElBQ0YsZUFBZUYsb0JBQWYsSUFBdUN0SyxFQUFFQyxPQUFGLENBQVcwSixRQUFRbUIsaUJBQW5CLENBRDFDLEVBRUU7QUFDRHRCLGVBQVdPLEtBQVgsR0FBbUIzTixVQUFXLDhDQUFYLENBQW5CO0FBQ0FvTixlQUFXUSxPQUFYLEdBQXFCLEtBQXJCO0FBQ0FOLGlCQUFhN0osSUFBYixDQUFtQitKLEtBQW5CO0FBQ0E7QUFDRCxPQUFLLENBQUVjLFNBQVAsRUFBbUI7QUFDbEJsQixlQUFXTyxLQUFYLEdBQW1CM04sVUFBVyw4Q0FBWCxDQUFuQjtBQUNBb04sZUFBV1EsT0FBWCxHQUFxQixLQUFyQjtBQUNBTixpQkFBYTdKLElBQWIsQ0FBbUIrSixLQUFuQjtBQUNBLElBSkQsTUFJTyxJQUFLYyxhQUFhLENBQWxCLEVBQXNCO0FBQzVCbEIsZUFBV08sS0FBWCxHQUFtQjNOLFVBQVcsd0RBQVgsQ0FBbkI7QUFDQW9OLGVBQVdRLE9BQVgsR0FBcUIsS0FBckI7QUFDQU4saUJBQWE3SixJQUFiLENBQW1CK0osS0FBbkI7QUFDQTtBQUNEO0FBQ0QsRUFwREQ7O0FBc0RBLEtBQUtGLGFBQWF4RyxNQUFiLEdBQXNCLENBQTNCLEVBQStCO0FBQzlCc0csYUFBV3VCLFVBQVgsR0FBd0JyQixZQUF4QjtBQUNBOztBQUVELFFBQU9GLFVBQVA7QUFDQTs7QUFFRDs7Ozs7OztBQU9PLFNBQVN4TCxNQUFULENBQWtCb0MsS0FBbEIsRUFBeUI7QUFDNUIsS0FBSyxnQkFBZ0IsT0FBUUEsS0FBN0IsRUFBdUM7QUFDekMsU0FBTyxLQUFQO0FBQ0c7QUFDRCxLQUFLLGFBQWEsT0FBUUEsS0FBMUIsRUFBb0M7QUFDbkNBLFVBQVFBLE1BQU1DLElBQU4sR0FBYTJLLFdBQWIsRUFBUjtBQUNBOztBQUVELFNBQVE1SyxLQUFSO0FBQ0ksT0FBSyxJQUFMO0FBQ0EsT0FBSyxNQUFMO0FBQ0EsT0FBSyxDQUFMO0FBQ0EsT0FBSyxHQUFMO0FBQ0EsT0FBSyxJQUFMO0FBQ0EsT0FBSyxLQUFMO0FBQ0ksVUFBTyxJQUFQO0FBQ0o7QUFDSSxVQUFPLEtBQVA7QUFUUjtBQVdIOztBQUVEOzs7OztBQUtPLFNBQVNuQyxnQkFBVCxHQUE2QjtBQUNuQyxLQUFJZ04sbUJBQW1CLEVBQXZCO0FBQUEsS0FDQ0MsZ0JBQWdCQyxTQUFTQyxNQUFULENBQWdCQyxTQUFoQixDQUEwQixDQUExQixFQUE2QnpMLEtBQTdCLENBQW1DLEdBQW5DLENBRGpCOztBQUdBLE1BQUssSUFBSTRHLElBQUksQ0FBYixFQUFnQkEsSUFBSTBFLGNBQWNoSSxNQUFsQyxFQUEwQ3NELEdBQTFDLEVBQStDO0FBQzlDLE1BQUk4RSxZQUFZSixjQUFjMUUsQ0FBZCxFQUFpQjVHLEtBQWpCLENBQXVCLEdBQXZCLENBQWhCO0FBQ0FxTCxtQkFBaUJLLFVBQVUsQ0FBVixDQUFqQixJQUFpQ0MsbUJBQW1CRCxVQUFVLENBQVYsQ0FBbkIsQ0FBakM7QUFDQTs7QUFFRCxRQUFPTCxnQkFBUDtBQUNBOztBQUVEOzs7OztBQUtPLFNBQVMvTSxRQUFULENBQW9Cc04sSUFBcEIsRUFBOEM7QUFBQSxLQUFwQkMsTUFBb0IsdUVBQVgsUUFBVzs7QUFDcERoRixRQUFPaUYsSUFBUCxDQUFhRixJQUFiLEVBQW1CQyxNQUFuQjtBQUNBLEM7Ozs7OztBQy9nREQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkx0Qzs7OztBQUNBOzs7Ozs7Ozs7O0lBRXFCRSxLOzs7QUFDcEIsZ0JBQWE1TSxLQUFiLEVBQXFCO0FBQUE7O0FBQUEsNEdBQ2JBLEtBRGE7O0FBR3BCLFFBQUs2TSxXQUFMLEdBQW1CLE1BQUtBLFdBQUwsQ0FBaUJDLElBQWpCLE9BQW5CO0FBSG9CO0FBSXBCOzs7OzhCQUVZekwsSyxFQUFRO0FBQ3BCO0FBQ0EsT0FBSyxPQUFPLEtBQUtyQixLQUFMLENBQVcrTSxjQUFsQixLQUFxQyxVQUExQyxFQUF1RDtBQUN0RDtBQUNBLFNBQUsvTSxLQUFMLENBQVcrTSxjQUFYLENBQTJCLEtBQUsvTSxLQUFMLENBQVdnTixRQUF0QyxFQUFnRDNMLEtBQWhEO0FBQ0EsSUFIRCxNQUdPO0FBQ047QUFDQSxTQUFLckIsS0FBTCxDQUFXaU4sT0FBWCxDQUFtQkMsZUFBbkIsQ0FBbUNDLGFBQW5DLENBQWtELEtBQUtuTixLQUFMLENBQVdnTixRQUE3RCxFQUF1RTNMLEtBQXZFO0FBQ0E7QUFDRDs7OzBCQUVRQSxLLEVBQVE7QUFDaEIsT0FBSyxLQUFLckIsS0FBTCxDQUFXb04sVUFBaEIsRUFBNkI7QUFDNUIsV0FBTyxLQUFLcE4sS0FBTCxDQUFXb04sVUFBWCxJQUF5QixDQUFFbk0sRUFBRUMsT0FBRixDQUFXRyxLQUFYLENBQWxDO0FBQ0EsSUFGRCxNQUVPLElBQUssQ0FBRUosRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXcU4sVUFBMUIsQ0FBUCxFQUFnRDtBQUN0RCxXQUFPcE0sRUFBRUMsT0FBRixDQUFXRyxLQUFYLEtBQXNCQSxTQUFTLENBQXRDO0FBQ0E7O0FBRUQsVUFBTyxJQUFQO0FBQ0E7OzsyQkFFUTtBQUFBOztBQUNSLE9BQU1BLFFBQVFKLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV0csUUFBWCxDQUFxQixLQUFLSCxLQUFMLENBQVdnTixRQUFoQyxDQUFmLElBQ1gsS0FBS2hOLEtBQUwsQ0FBV3NOLFlBREEsR0FFWCxLQUFLdE4sS0FBTCxDQUFXRyxRQUFYLENBQXFCLEtBQUtILEtBQUwsQ0FBV2dOLFFBQWhDLENBRkg7O0FBSUEsT0FBTTNNLE9BQU8sQ0FBRVksRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXSyxJQUExQixDQUFGLEdBQXFDLEtBQUtMLEtBQUwsQ0FBV0ssSUFBaEQsR0FBdUQsTUFBcEU7O0FBRUEsT0FBTWtOLGdCQUFnQixDQUFFdE0sRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXdU4sYUFBMUIsQ0FBRixHQUE4QyxLQUFLdk4sS0FBTCxDQUFXdU4sYUFBekQsR0FBeUUsc0JBQVcseUJBQVgsQ0FBL0Y7O0FBRUEsT0FBTUMsZ0JBQWdCLENBQUUsS0FBS3ZDLE9BQUwsQ0FBYzVKLEtBQWQsQ0FBRixHQUEwQixzQkFBMUIsR0FBbUQsRUFBekU7O0FBRUEsT0FBTW9NLGFBQWEsQ0FBRXhNLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV3lOLFVBQTFCLENBQUYsR0FDaEIsb0JBQW9CLEtBQUt6TixLQUFMLENBQVd5TixVQURmLEdBRWhCLGdCQUZIOztBQUlBLE9BQUlDLGFBQWEsa0JBQWpCOztBQUVBLE9BQUssQ0FBRXpNLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBVzBOLFVBQTFCLENBQUYsSUFBNEMsT0FBTyxLQUFLMU4sS0FBTCxDQUFXME4sVUFBbkUsRUFBZ0Y7QUFDL0VBLGtCQUFjLE1BQU0sS0FBSzFOLEtBQUwsQ0FBVzBOLFVBQS9CO0FBQ0E7O0FBRUQsT0FBSyxDQUFFek0sRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXMk4sTUFBMUIsQ0FBRixJQUF3QyxPQUFPLEtBQUszTixLQUFMLENBQVcyTixNQUEvRCxFQUF3RTtBQUN2RUQsa0JBQWMsdUJBQWQ7QUFDQTs7QUFFRCxPQUFLLENBQUV6TSxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVd5RyxNQUExQixDQUFGLElBQXdDLE9BQU8sS0FBS3pHLEtBQUwsQ0FBV3lHLE1BQS9ELEVBQXdFO0FBQ3ZFaUgsa0JBQWMsdUJBQWQ7QUFDQTs7QUFFRCxPQUFNRSxVQUFVLENBQUUzTSxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVc0TixPQUExQixDQUFGLEdBQ2IsS0FBSzVOLEtBQUwsQ0FBVzROLE9BREUsR0FFYixLQUFLNU4sS0FBTCxDQUFXZ04sUUFGZDs7QUFJQSxPQUFJYSxtQkFBSjs7QUFFQSxPQUFLLEtBQUs3TixLQUFMLENBQVcwQixLQUFoQixFQUF3QjtBQUN2Qm1NLGlCQUNDO0FBQUE7QUFBQTtBQUNDLHFDQUErQkQsT0FEaEM7QUFFQyxpQkFBWSxLQUFLNU4sS0FBTCxDQUFXOE4sU0FBWCxHQUNULDZCQURTLEdBRVQ7QUFKSjtBQU9HLFVBQUs5TixLQUFMLENBQVcwQixLQVBkO0FBUUcsVUFBSzFCLEtBQUwsQ0FBV29OLFVBQVgsSUFDRDtBQUFDLHFCQUFELENBQU8sUUFBUDtBQUFBO0FBQUE7QUFDTztBQUFBO0FBQUEsU0FBTSxXQUFVLFdBQWhCO0FBQUE7QUFBQTtBQURQLE1BVEY7QUFhRyxVQUFLcE4sS0FBTCxDQUFXK04sSUFBWCxJQUNEO0FBQUE7QUFBQSxRQUFNLFdBQVUsZ0JBQWhCO0FBQW1DLFdBQUsvTixLQUFMLENBQVcrTjtBQUE5QztBQWRGLEtBREQ7QUFtQkE7O0FBRUQsT0FBTUMsYUFDTCxrREFBTyxNQUFPM04sSUFBZDtBQUNDLGlCQUFjLEtBQUtMLEtBQUwsQ0FBV2lPLFdBRDFCO0FBRUMsV0FBUTVNLFNBQVMsRUFGbEI7QUFHQyw4QkFBMEJ1TSxPQUgzQjtBQUlDLGVBQVlGO0FBSmIsTUFLTyxLQUFLMU4sS0FBTCxDQUFXa08sV0FBWCxJQUEwQixFQUFFQyxVQUFVLEVBQVosRUFMakMsRUFNTyxLQUFLbk8sS0FBTCxDQUFXb08sUUFBWCxJQUF1QixFQUFFaFAsS0FBSyxLQUFLWSxLQUFMLENBQVdvTyxRQUFsQixFQU45QixFQU9PLEtBQUtwTyxLQUFMLENBQVdnQixRQUFYLElBQXVCLEVBQUV6QixLQUFLLEtBQUtTLEtBQUwsQ0FBV2dCLFFBQWxCLEVBUDlCLEVBUU8sS0FBS2hCLEtBQUwsQ0FBV3FPLElBQVgsSUFBbUIsRUFBRUEsTUFBTSxLQUFLck8sS0FBTCxDQUFXcU8sSUFBbkIsRUFSMUIsRUFTTyxLQUFLck8sS0FBTCxDQUFXc08sU0FBWCxJQUF3QixFQUFFQSxXQUFXLEtBQUt0TyxLQUFMLENBQVdzTyxTQUF4QixFQVQvQixFQVVPLEtBQUt0TyxLQUFMLENBQVd1TyxXQUFYLElBQTBCLEVBQUVDLE9BQU8sS0FBS3hPLEtBQUwsQ0FBV3VPLFdBQXBCLEVBVmpDO0FBV0MsY0FBVyxLQUFLdk8sS0FBTCxDQUFXeUksUUFBWCxHQUFzQixJQUF0QixHQUE2QixLQVh6QztBQVlDLGNBQVcscUJBQUs7QUFDZixZQUFLb0UsV0FBTCxDQUFrQi9ELEVBQUU0RCxNQUFGLENBQVNyTCxLQUEzQjtBQUNBO0FBZEYsTUFERDs7QUFtQkEsT0FBTTNELFlBQ0w7QUFBQTtBQUFBLE1BQUssV0FBZ0IrUCxVQUFoQixTQUFnQ0QsYUFBckM7QUFDR0ssY0FESDtBQUVLLEtBQUU1TSxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVcyTixNQUExQixDQUFGLElBQXdDLE9BQU8sS0FBSzNOLEtBQUwsQ0FBVzJOLE1BQTVELElBQ0Q7QUFBQTtBQUFBLE9BQU0sV0FBVSxrQkFBaEI7QUFBcUMsVUFBSzNOLEtBQUwsQ0FBVzJOO0FBQWhELEtBSEY7QUFLSyxLQUFFLEtBQUszTixLQUFMLENBQVd5TyxRQUFiLEdBQ0RULFVBREMsR0FFRDtBQUFBO0FBQUEsT0FBSyxXQUFVLHNDQUFmO0FBQ0NBLGVBREQ7QUFFRDtBQUFBO0FBQUEsUUFBUSxXQUFVLG1EQUFsQjtBQUNDLHVCQUFlLHNCQUFXLFFBQVgsQ0FEaEI7QUFFQywyQ0FBRyxXQUFVLGdCQUFiLEVBQThCLGVBQVksTUFBMUM7QUFGRDtBQUZDLEtBUEo7QUFlRyxTQUFLaE8sS0FBTCxDQUFXeUcsTUFBWCxJQUNEO0FBQUE7QUFBQSxPQUFNLFdBQVUsa0JBQWhCO0FBQXFDLFVBQUt6RyxLQUFMLENBQVd5RztBQUFoRCxLQWhCRjtBQWtCRyxTQUFLekcsS0FBTCxDQUFXb04sVUFBWCxJQUF5QixDQUFFLEtBQUtuQyxPQUFMLENBQWM1SixLQUFkLENBQTNCLElBQ0Q7QUFBQTtBQUFBLE9BQU0sV0FBVSxtQkFBaEI7QUFBc0NrTTtBQUF0QyxLQW5CRjtBQXFCRyxLQUFFdE0sRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXcU4sVUFBMUIsQ0FBRixJQUE0QyxDQUFFLEtBQUtwQyxPQUFMLENBQWM1SixLQUFkLENBQTlDLElBQ0Q7QUFBQTtBQUFBLE9BQU0sV0FBVSxtQkFBaEI7QUFBc0MsMkJBQVcsNEJBQVg7QUFBdEMsS0F0QkY7QUF3QkcsU0FBS3JCLEtBQUwsQ0FBVzBPLFdBQVgsSUFDRDtBQUFBO0FBQUEsT0FBTSxXQUFVLGlCQUFoQjtBQUFvQyxVQUFLMU8sS0FBTCxDQUFXME87QUFBL0M7QUF6QkYsSUFERDs7QUErQkEsT0FBSyxLQUFLMU8sS0FBTCxDQUFXMk8sTUFBaEIsRUFBeUI7QUFDeEIsV0FBT1gsVUFBUDtBQUNBOztBQUVELFVBQU90USxTQUFQO0FBQ0E7Ozs7RUE1SWlDa1IsZ0I7O2tCQUFkaEMsSzs7Ozs7Ozs7Ozs7Ozs7O0FDSHJCOzs7Ozs7Ozs7Ozs7SUFFcUJpQyxTOzs7QUFDcEIsb0JBQWE3TyxLQUFiLEVBQXFCO0FBQUE7O0FBQUEsK0dBQ2JBLEtBRGE7QUFFcEI7Ozs7MkJBRVE7QUFDUixPQUFNOE8sV0FBV0MsZ0JBQU1DLFFBQU4sQ0FBZW5QLEdBQWYsQ0FBb0IsS0FBS0csS0FBTCxDQUFXOE8sUUFBL0IsRUFBeUMsaUJBQVM7QUFDbEUsV0FBT0csS0FBUDtBQUNBLElBRmdCLENBQWpCOztBQUlBLFVBQ0M7QUFBQTtBQUFBO0FBQ0dIO0FBREgsSUFERDtBQUtBOzs7O0VBZnFDRixnQjs7a0JBQWxCQyxTOzs7Ozs7Ozs7Ozs7Ozs7QUNGckI7Ozs7Ozs7Ozs7OztJQUVxQkssRzs7O0FBQ3BCLGNBQWFsUCxLQUFiLEVBQXFCO0FBQUE7O0FBQUEsbUdBQ2JBLEtBRGE7QUFFcEI7Ozs7MkJBRVE7QUFDUixPQUFNOE8sV0FBV0MsZ0JBQU1DLFFBQU4sQ0FBZW5QLEdBQWYsQ0FBb0IsS0FBS0csS0FBTCxDQUFXOE8sUUFBL0IsRUFBeUMsb0JBQVk7QUFDckUsV0FBT0EsUUFBUDtBQUNBLElBRmdCLENBQWpCOztBQUlBLE9BQU1LLGNBQWMsS0FBS25QLEtBQUwsQ0FBV21QLFdBQVgsR0FBeUIsS0FBS25QLEtBQUwsQ0FBV21QLFdBQXBDLEdBQWtELEVBQXRFOztBQUVBLFVBQ0M7QUFBQTtBQUFBLE1BQUssMkJBQTJCLEtBQUtuUCxLQUFMLENBQVc4QixJQUF0QyxTQUFnRHFOLFdBQXJEO0FBQ0dMO0FBREgsSUFERDtBQUtBOzs7O0VBakIrQkYsZ0I7O2tCQUFaTSxHOzs7Ozs7Ozs7Ozs7Ozs7QUNGckI7Ozs7QUFDQTs7Ozs7Ozs7OztJQUVxQkUsVzs7O0FBQ3BCLHNCQUFhcFAsS0FBYixFQUFxQjtBQUFBOztBQUFBLHdIQUNiQSxLQURhOztBQUdwQixRQUFLNk0sV0FBTCxHQUFtQixNQUFLQSxXQUFMLENBQWlCQyxJQUFqQixPQUFuQjtBQUhvQjtBQUlwQjs7OztzQ0FFbUI7QUFDbkIsUUFBS3BFLEdBQUwsR0FBV1osT0FBUSxLQUFLdUgsRUFBYixDQUFYO0FBQ0EsUUFBSzNHLEdBQUwsQ0FBUzRHLGFBQVQsQ0FBd0I7QUFDdkJDLFlBQVEsZ0JBQVVDLEtBQVYsRUFBaUJDLEVBQWpCLEVBQXNCO0FBQzdCLFNBQU1DLFFBQVE1SCxPQUFRLElBQVIsQ0FBZDtBQUNBNEgsV0FBTXhJLEdBQU4sQ0FBV3VJLEdBQUdFLEtBQUgsQ0FBU0MsS0FBVCxFQUFYLEVBQThCdEcsT0FBOUIsQ0FBdUMsUUFBdkM7QUFDQSxLQUpzQjtBQUt2QnVHLGNBQVUsQ0FDVCxTQURTLEVBRVQsU0FGUyxFQUdULFNBSFMsRUFJVCxTQUpTLEVBS1QsU0FMUyxFQU1ULFNBTlMsRUFPVCxTQVBTO0FBTGEsSUFBeEI7O0FBZ0JBLE9BQU1DLGtCQUFrQixLQUFLcEgsR0FBN0I7QUFBQSxPQUNDcUgsYUFBYUQsZ0JBQWdCRSxPQUFoQixDQUF5Qix1QkFBekIsQ0FEZDtBQUFBLE9BRUNDLGtCQUFrQkYsV0FBV3pOLElBQVgsQ0FBaUIsMENBQWpCLENBRm5CO0FBQUEsT0FHQzROLGtCQUFrQkgsV0FBV3pOLElBQVgsQ0FBaUIsd0JBQWpCLENBSG5CO0FBQUEsT0FJQzZOLGtCQUFrQkQsZ0JBQWdCNU4sSUFBaEIsQ0FBc0IsUUFBdEIsQ0FKbkI7O0FBT0EsT0FBTThOLFlBQVlOLGdCQUFnQkUsT0FBaEIsQ0FBeUIsc0JBQXpCLENBQWxCO0FBQUEsT0FDQ0ssa0JBQWtCRCxVQUFVOU4sSUFBVixDQUFnQixrQkFBaEIsQ0FEbkI7QUFBQSxPQUVDZ08saUJBQWlCRCxnQkFBZ0IvTixJQUFoQixDQUFzQixjQUF0QixDQUZsQjtBQUFBLE9BR0NpTyxpQkFBaUJILFVBQVU5TixJQUFWLENBQWdCLGtCQUFoQixDQUhsQjs7QUFNQSxPQUFJa08sb0JBQW9CRixjQUF4Qjs7QUFFQTtBQUNBLE9BQUtSLGdCQUFnQjdHLElBQWhCLENBQXNCLE9BQXRCLE1BQW9DLElBQXpDLEVBQWdEO0FBQy9DdUgsd0JBQW9CRixjQUFwQjtBQUNBLElBRkQsTUFFTztBQUNORSx3QkFBb0JILGVBQXBCO0FBQ0E7O0FBRUQ7QUFDQVAsbUJBQWdCaEQsSUFBaEIsQ0FBc0IsUUFBdEIsRUFBZ0MsWUFBVztBQUMxQztBQUNBbUQsb0JBQWdCM04sSUFBaEIsQ0FBc0IsTUFBdEIsRUFBK0JtTyxHQUEvQixDQUFvQztBQUNuQyx5QkFBb0JELGtCQUFrQkMsR0FBbEIsQ0FBdUIsa0JBQXZCO0FBRGUsS0FBcEM7O0FBSUE7QUFDQVAsb0JBQWdCNU4sSUFBaEIsQ0FBc0IsT0FBdEIsRUFBZ0M0RSxHQUFoQyxDQUFxQzRJLGdCQUFnQjVJLEdBQWhCLEVBQXJDO0FBQ0EsSUFSRDs7QUFVQTtBQUNBNkksY0FBV3pOLElBQVgsQ0FBaUIsZ0NBQWpCLEVBQW9EdUcsRUFBcEQsQ0FBd0QsT0FBeEQsRUFBaUUsVUFBVUMsQ0FBVixFQUFjO0FBQzlFQSxNQUFFNEgsY0FBRjtBQUNBNUgsTUFBRTZILGVBQUY7QUFDQU4sb0JBQWdCTyxLQUFoQjtBQUNBLElBSkQ7O0FBTUE7QUFDQVQsbUJBQWdCdEgsRUFBaEIsQ0FBb0IsT0FBcEIsRUFBNkIsVUFBVUMsQ0FBVixFQUFjO0FBQzFDQSxNQUFFNEgsY0FBRjtBQUNBNUgsTUFBRTZILGVBQUY7O0FBRUFKLG1CQUFlSyxLQUFmO0FBQ0FWLG9CQUFnQjVOLElBQWhCLENBQXNCLE9BQXRCLEVBQWdDNEUsR0FBaEMsQ0FBcUMsRUFBckM7QUFDQStJLG9CQUFnQjNOLElBQWhCLENBQXNCLE1BQXRCLEVBQStCbU8sR0FBL0IsQ0FBb0M7QUFDbkMseUJBQW9CO0FBRGUsS0FBcEM7QUFHQSxJQVREOztBQVdBLFFBQUs1RCxXQUFMLEdBQW1CLEtBQUtBLFdBQUwsQ0FBaUJDLElBQWpCLENBQXVCLElBQXZCLENBQW5CO0FBQ0EsUUFBS3BFLEdBQUwsQ0FBU0csRUFBVCxDQUFhLFFBQWIsRUFBdUIsS0FBS2dFLFdBQTVCO0FBQ0E7Ozs4QkFFWS9ELEMsRUFBSTtBQUNoQixPQUFNekgsUUFBUXlILEVBQUU0RCxNQUFGLENBQVNyTCxLQUF2Qjs7QUFFQTtBQUNBLE9BQUssT0FBTyxLQUFLckIsS0FBTCxDQUFXK00sY0FBbEIsS0FBcUMsVUFBMUMsRUFBdUQ7QUFDdEQ7QUFDQSxTQUFLL00sS0FBTCxDQUFXK00sY0FBWCxDQUNDLEtBQUsvTSxLQUFMLENBQVdnTixRQURaLEVBRUMzTCxLQUZEO0FBSUEsSUFORCxNQU1PO0FBQ047QUFDQSxTQUFLckIsS0FBTCxDQUFXaU4sT0FBWCxDQUFtQkMsZUFBbkIsQ0FBbUNDLGFBQW5DLENBQWtELEtBQUtuTixLQUFMLENBQVdnTixRQUE3RCxFQUF1RTNMLEtBQXZFO0FBQ0E7QUFDRDs7O3lDQUVzQjtBQUN0QixRQUFLcUgsR0FBTCxDQUFTbUksR0FBVCxDQUFjLFFBQWQsRUFBd0IsS0FBS2hFLFdBQTdCO0FBQ0EsUUFBS25FLEdBQUwsQ0FBU29JLE1BQVQsR0FBa0JDLFVBQWxCO0FBQ0E7OzsyQkFFUTtBQUFBOztBQUNSLE9BQU0xUCxRQUFVSixFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdHLFFBQVgsQ0FBcUIsS0FBS0gsS0FBTCxDQUFXZ04sUUFBaEMsQ0FBZixLQUErRCxLQUFLaE4sS0FBTCxDQUFXRyxRQUFYLENBQXFCLEtBQUtILEtBQUwsQ0FBV2dOLFFBQWhDLE1BQStDLElBQWhILEdBQ1gsS0FBS2hOLEtBQUwsQ0FBV3NOLFlBREEsR0FFWCxLQUFLdE4sS0FBTCxDQUFXRyxRQUFYLENBQXFCLEtBQUtILEtBQUwsQ0FBV2dOLFFBQWhDLENBRkg7O0FBSUEsT0FBSS9HLGFBQWEsRUFBakI7O0FBRUEsT0FBSyxLQUFLakcsS0FBTCxDQUFXMEIsS0FBaEIsRUFBd0I7QUFDdkJ1RSxpQkFDQztBQUFBO0FBQUEsT0FBTyxXQUFVLFdBQWpCO0FBQ0MscUNBQStCLEtBQUtqRyxLQUFMLENBQVdnTixRQUQzQztBQUVHLFVBQUtoTixLQUFMLENBQVcwQixLQUZkO0FBR0csVUFBSzFCLEtBQUwsQ0FBVytOLElBQVgsSUFDRDtBQUFBO0FBQUEsUUFBTSxXQUFVLGdCQUFoQjtBQUFBO0FBQW9DLFdBQUsvTixLQUFMLENBQVcrTjtBQUEvQztBQUpGLEtBREQ7QUFTQTs7QUFFRCxVQUNDO0FBQUE7QUFBQSxNQUFLLFdBQVUsZ0JBQWY7QUFDRzlILGNBREg7QUFFQztBQUFBO0FBQUEsT0FBSyxXQUFVLHNCQUFmO0FBQ0M7QUFBQTtBQUFBO0FBQ0Msd0RBQWdELEtBQUtqRyxLQUFMLENBQVdnUixPQUFYLEdBQzdDLE1BRDZDLEdBRTdDLEtBRkgsQ0FERDtBQUtDLHNCQUFZLE1BTGI7QUFNQztBQUFBO0FBQUEsU0FBSyxXQUFVLHVCQUFmO0FBQ0M7QUFBQTtBQUFBLFVBQU0sTUFBSyxRQUFYO0FBQ0MsZ0RBQU0sT0FBUSxFQUFFQyxpQkFBaUI1UCxLQUFuQixFQUFkO0FBREQsUUFERDtBQUlDLGdEQUFPLE1BQUssTUFBWixFQUFtQixjQUFlQSxLQUFsQztBQUNDLGtCQUFTLFVBRFYsR0FKRDtBQU1DO0FBQUE7QUFBQTtBQUNDLDZDQUFHLFdBQVUsZ0JBQWIsRUFBOEIsZUFBWSxNQUExQztBQUREO0FBTkQsT0FORDtBQWdCQztBQUFBO0FBQUEsU0FBUSxXQUFVLFlBQWxCO0FBQWlDLDZCQUFXLFFBQVg7QUFBakM7QUFoQkQsTUFERDtBQW1CQyw4Q0FBTyxLQUFNO0FBQUEsY0FBUSxPQUFLZ08sRUFBTCxHQUFVQSxFQUFsQjtBQUFBLE9BQWI7QUFDQyxvQkFBZWhPLEtBRGhCO0FBRUMsZ0NBQTBCLEtBQUtyQixLQUFMLENBQVdnTixRQUZ0QztBQUdDLGlCQUFVLHVCQUhYO0FBSUMsb0JBQWEsS0FBS2hOLEtBQUwsQ0FBV2dSLE9BQVgsR0FBcUIsTUFBckIsR0FBOEI7QUFKNUM7QUFuQkQsS0FGRDtBQTRCSyxTQUFLaFIsS0FBTCxDQUFXME8sV0FBWCxJQUEwQixPQUFPLEtBQUsxTyxLQUFMLENBQVcwTyxXQUE5QyxJQUNEO0FBQUE7QUFBQSxPQUFNLFdBQVUsaUJBQWhCO0FBQW9DLFVBQUsxTyxLQUFMLENBQVcwTztBQUEvQztBQTdCRixJQUREO0FBa0NBOzs7O0VBM0p1Q0UsZ0I7O2tCQUFwQlEsVzs7Ozs7Ozs7Ozs7Ozs7O0FDSHJCOzs7Ozs7Ozs7Ozs7SUFFcUI4QixTOzs7QUFDcEIsb0JBQWFsUixLQUFiLEVBQXFCO0FBQUE7O0FBQUEsK0dBQ2JBLEtBRGE7QUFFcEI7Ozs7OEJBRVlxQixLLEVBQVE7QUFDcEI7QUFDQSxPQUFLLE9BQU8sS0FBS3JCLEtBQUwsQ0FBVytNLGNBQWxCLEtBQXFDLFVBQTFDLEVBQXVEO0FBQ3REO0FBQ0EsU0FBSy9NLEtBQUwsQ0FBVytNLGNBQVgsQ0FDQyxLQUFLL00sS0FBTCxDQUFXZ04sUUFEWixFQUVDM0wsS0FGRDtBQUlBLElBTkQsTUFNTztBQUNOO0FBQ0EsU0FBS3JCLEtBQUwsQ0FBV2lOLE9BQVgsQ0FBbUJDLGVBQW5CLENBQW1DQyxhQUFuQyxDQUFrRCxLQUFLbk4sS0FBTCxDQUFXZ04sUUFBN0QsRUFBdUUzTCxLQUF2RTtBQUNBO0FBQ0Q7OztvQ0FFaUI7QUFDakIsT0FBTWlNLGVBQWUsS0FBS3ROLEtBQUwsQ0FBV21SLE9BQVgsR0FBcUIsS0FBS25SLEtBQUwsQ0FBV21SLE9BQWhDLEdBQTBDLEVBQS9EOztBQUVBLE9BQU05UCxRQUFRSixFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdHLFFBQVgsQ0FBcUIsS0FBS0gsS0FBTCxDQUFXZ04sUUFBaEMsQ0FBZixJQUNYTSxZQURXLEdBRVgsS0FBS3ROLEtBQUwsQ0FBV0csUUFBWCxDQUFxQixLQUFLSCxLQUFMLENBQVdnTixRQUFoQyxDQUZIOztBQUlBLFVBQU8zTCxLQUFQO0FBQ0E7OzsyQkFFUTtBQUFBOztBQUNSLE9BQU1BLFFBQVEsS0FBS3BGLGVBQUwsRUFBZDs7QUFFQSxPQUFNbVYsWUFBWXJDLGdCQUFNQyxRQUFOLENBQWVuUCxHQUFmLENBQW9CLEtBQUtHLEtBQUwsQ0FBVzhPLFFBQS9CLEVBQXlDLGVBQU87QUFDakUsUUFBSyxDQUFFdUMsR0FBUCxFQUFhO0FBQ1osWUFDQyw4QkFBQyxlQUFELENBQU8sUUFBUCxPQUREO0FBR0E7O0FBRUQsUUFBTTNQLFFBQVEsQ0FBRVQsRUFBRTJDLFdBQUYsQ0FBZXlOLElBQUlyUixLQUFKLENBQVUwQixLQUF6QixDQUFGLEdBQ1gyUCxJQUFJclIsS0FBSixDQUFVMEIsS0FEQyxHQUVYMlAsSUFBSXJSLEtBQUosQ0FBVThPLFFBRmI7O0FBSUEsUUFBSyxPQUFLOU8sS0FBTCxDQUFXeUksUUFBaEIsRUFBMkI7QUFDMUIsWUFDQztBQUFBO0FBQUEsUUFBSyxXQUFZLGtCQUFtQjRJLElBQUlyUixLQUFKLENBQVVxQixLQUFWLEtBQW9CQSxLQUFwQixHQUE0QixTQUE1QixHQUF3QyxFQUEzRCxDQUFqQjtBQUNDLGNBQVE7QUFDUGlRLGlCQUFTLEdBREY7QUFFUEMsZ0JBQVE7QUFGRDtBQURUO0FBTUc3UDtBQU5ILE1BREQ7QUFVQTs7QUFFRCxRQUFLLENBQUUsT0FBSzFCLEtBQUwsQ0FBV3lJLFFBQWxCLEVBQTZCO0FBQzVCLFlBQ0M7QUFBQTtBQUFBLFFBQUssV0FBWSxrQkFBbUI0SSxJQUFJclIsS0FBSixDQUFVcUIsS0FBVixLQUFvQkEsS0FBcEIsR0FBNEIsU0FBNUIsR0FBd0MsRUFBM0QsQ0FBakI7QUFDQyxnQkFBVSxPQUFLbVEsV0FBTCxDQUFpQjFFLElBQWpCLENBQXVCLE1BQXZCLEVBQTZCdUUsSUFBSXJSLEtBQUosQ0FBVXFCLEtBQXZDO0FBRFg7QUFHR0s7QUFISCxNQUREO0FBT0E7QUFDRCxJQWpDaUIsQ0FBbEI7O0FBbUNBLE9BQU0rUCxlQUFlLENBQUV4USxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVcwUixRQUExQixDQUFGLEdBQ2xCLHNCQUFzQixLQUFLMVIsS0FBTCxDQUFXMFIsUUFEZixHQUVsQixrQkFGSDs7QUFJQSxPQUFNQyxjQUFjNUMsZ0JBQU1DLFFBQU4sQ0FBZW5QLEdBQWYsQ0FBb0IsS0FBS0csS0FBTCxDQUFXOE8sUUFBL0IsRUFBeUMsZUFBTztBQUNuRSxRQUFLLENBQUV1QyxHQUFQLEVBQWE7QUFDWixZQUNDLDhCQUFDLGVBQUQsQ0FBTyxRQUFQLE9BREQ7QUFHQTs7QUFFRCxRQUFNTyxXQUFXLENBQUUzUSxFQUFFMkMsV0FBRixDQUFleU4sSUFBSXJSLEtBQUosQ0FBVTRSLFFBQXpCLENBQUYsR0FDZFAsSUFBSXJSLEtBQUosQ0FBVTRSLFFBREksR0FFZCxFQUZIOztBQUlBLFFBQUtQLElBQUloUixJQUFKLENBQVN3UixJQUFULEtBQWtCLE9BQXZCLEVBQWlDO0FBQ2hDLFlBQ0M7QUFBQTtBQUFBLFFBQUssV0FDSkQsV0FBVyxrQkFBWCxJQUFrQ1AsSUFBSXJSLEtBQUosQ0FBVXFCLEtBQVYsS0FBb0JBLEtBQXBCLEdBQTRCLFNBQTVCLEdBQXdDLEVBQTFFLENBREQ7QUFHR2dRLFVBQUlyUixLQUFKLENBQVVxQixLQUFWLEtBQW9CQSxLQUFwQixJQUE2QmdRO0FBSGhDLE1BREQ7QUFPQTs7QUFFRCxXQUNDLDhCQUFDLGVBQUQsQ0FBTyxRQUFQLE9BREQ7QUFHQSxJQXhCbUIsQ0FBcEI7O0FBMEJBLE9BQUlTLFlBQVksRUFBaEI7O0FBRUEsT0FBSyxLQUFLOVIsS0FBTCxDQUFXMEIsS0FBWCxJQUFvQixPQUFPLEtBQUsxQixLQUFMLENBQVcwQixLQUEzQyxFQUFtRDtBQUNsRG9RLGdCQUNDO0FBQUE7QUFBQSxPQUFPLCtCQUErQixLQUFLOVIsS0FBTCxDQUFXZ04sUUFBakQ7QUFDQyxpQkFBVSxXQURYO0FBRUcsVUFBS2hOLEtBQUwsQ0FBVzBCLEtBRmQ7QUFHRyxVQUFLMUIsS0FBTCxDQUFXK04sSUFBWCxJQUNEO0FBQUE7QUFBQSxRQUFNLFdBQVUsZ0JBQWhCO0FBQUE7QUFBb0MsV0FBSy9OLEtBQUwsQ0FBVytOO0FBQS9DO0FBSkYsS0FERDtBQVNBOztBQUVELE9BQUlnRSxnQkFBZ0IsRUFBcEI7O0FBRUEsT0FBSyxLQUFLL1IsS0FBTCxDQUFXK1IsYUFBWCxJQUE0QixPQUFPLEtBQUsvUixLQUFMLENBQVcrUixhQUFuRCxFQUFtRTtBQUNsRSxRQUFNQyxhQUFhLEtBQUtoUyxLQUFMLENBQVdnUyxVQUFYLEdBQXdCLEtBQUtoUyxLQUFMLENBQVdnUyxVQUFuQyxHQUFnRCxvQkFBbkU7QUFDQUQsb0JBQ0M7QUFBQTtBQUFBLE9BQU8sV0FBWUMsVUFBbkI7QUFDRyxVQUFLaFMsS0FBTCxDQUFXK1I7QUFEZCxLQUREO0FBS0E7O0FBRUQsT0FBSXJELGNBQWMsRUFBbEI7O0FBRUEsT0FBSyxLQUFLMU8sS0FBTCxDQUFXME8sV0FBWCxJQUEwQixPQUFPLEtBQUsxTyxLQUFMLENBQVcwTyxXQUFqRCxFQUErRDtBQUM5REEsa0JBQ0M7QUFBQTtBQUFBO0FBQ0MsaUJBQVUsaUJBRFg7QUFFQyxhQUFRLEVBQUV1RCxjQUFjLEVBQWhCO0FBRlQ7QUFJRyxVQUFLalMsS0FBTCxDQUFXME87QUFKZCxLQUREO0FBUUE7O0FBRUQsT0FBSXdELGVBQWUsQ0FBRWpSLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV2tTLFlBQTFCLENBQUYsR0FDaEIsS0FBS2xTLEtBQUwsQ0FBV2tTLFlBREssR0FFaEIsRUFGSDs7QUFJQUEsa0JBQWUsS0FBS2xTLEtBQUwsQ0FBV21TLFNBQVgsbUNBQ21CRCxZQURuQixzQkFFTUEsWUFGckI7O0FBSUEsT0FBSUUsYUFDSDtBQUFBO0FBQUEsTUFBSyxXQUFZRixZQUFqQjtBQUVDO0FBQUE7QUFBQSxPQUFLLFdBQVUsZUFBZjtBQUNHZDtBQURILEtBRkQ7QUFNQztBQUFBO0FBQUEsT0FBSyxXQUFZSyxZQUFqQjtBQUNHRTtBQURIO0FBTkQsSUFERDs7QUFjQSxPQUFLLENBQUUsS0FBSzNSLEtBQUwsQ0FBVzJPLE1BQWxCLEVBQTJCO0FBQzFCeUQsaUJBQ0M7QUFBQTtBQUFBLE9BQUssV0FBVSxnQkFBZjtBQUVHTCxrQkFGSDtBQUlHRCxjQUpIO0FBTUdwRCxnQkFOSDtBQVFDO0FBQUE7QUFBQSxRQUFLLFdBQVl3RCxZQUFqQjtBQUVDO0FBQUE7QUFBQSxTQUFLLFdBQVUsZUFBZjtBQUNHZDtBQURILE9BRkQ7QUFNQztBQUFBO0FBQUEsU0FBSyxXQUFZSyxZQUFqQjtBQUNHRTtBQURIO0FBTkQ7QUFSRCxLQUREO0FBdUJBOztBQUVELFVBQU9TLFVBQVA7QUFDQTs7OztFQXhMcUN4RCxnQjs7a0JBQWxCc0MsUzs7Ozs7Ozs7Ozs7Ozs7O0FDRnJCOzs7Ozs7Ozs7Ozs7SUFFcUJtQixHOzs7QUFDcEIsY0FBYXJTLEtBQWIsRUFBcUI7QUFBQTs7QUFBQSxtR0FDYkEsS0FEYTtBQUVwQjs7OzsyQkFFUTtBQUNSLE9BQU1zUyxVQUFVdkQsZ0JBQU1DLFFBQU4sQ0FBZW5QLEdBQWYsQ0FDZixLQUFLRyxLQUFMLENBQVc4TyxRQURJLEVBRWYsb0JBQVk7QUFDWCxXQUFPQSxRQUFQO0FBQ0EsSUFKYyxDQUFoQjs7QUFPQSxVQUNDO0FBQUE7QUFBQSxNQUFLLFdBQVksYUFBYyxDQUFFN04sRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXdVMsS0FBMUIsQ0FBRixHQUM1QixNQUFNLEtBQUt2UyxLQUFMLENBQVd1UyxLQURXLEdBRTVCLEVBRmMsQ0FBakI7QUFJR0Q7QUFKSCxJQUREO0FBUUE7Ozs7RUFyQitCMUQsZ0I7O2tCQUFaeUQsRzs7Ozs7O0FDRnJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0JBOzs7Ozs7Ozs7Ozs7SUFFcUJHLEk7OztBQUNwQixlQUFheFMsS0FBYixFQUFxQjtBQUFBOztBQUFBLDBHQUNiQSxLQURhOztBQUdwQixRQUFLeVMsS0FBTCxHQUFhO0FBQ1pDLFdBQVEsTUFBSzFTLEtBQUwsQ0FBV21SLE9BQVgsR0FBcUIsTUFBS25SLEtBQUwsQ0FBV21SLE9BQWhDLEdBQTBDO0FBRHRDLEdBQWI7QUFIb0I7QUFNcEI7Ozs7OEJBRVk5UCxLLEVBQVE7QUFDcEIsUUFBS3NSLFFBQUwsQ0FBZTtBQUNkRCxZQUFRclI7QUFETSxJQUFmO0FBR0E7OzsyQkFFUTtBQUFBOztBQUNSLE9BQU1pTSxlQUFlLEtBQUt0TixLQUFMLENBQVdtUixPQUFYLEdBQXFCLEtBQUtuUixLQUFMLENBQVdtUixPQUFoQyxHQUEwQyxFQUEvRDs7QUFFQSxPQUFNOVEsT0FBTyxLQUFLTCxLQUFMLENBQVdLLElBQVgsR0FBa0IsS0FBS0wsS0FBTCxDQUFXSyxJQUE3QixHQUFvQyxXQUFqRDs7QUFFQSxPQUFNdVMsYUFBYSxLQUFLNVMsS0FBTCxDQUFXNFMsVUFBWCxHQUF3QixLQUFLNVMsS0FBTCxDQUFXNFMsVUFBbkMsR0FBZ0QsRUFBbkU7O0FBRUEsT0FBTXhCLFlBQVlyQyxnQkFBTUMsUUFBTixDQUFlblAsR0FBZixDQUFvQixLQUFLRyxLQUFMLENBQVc4TyxRQUEvQixFQUF5QyxlQUFPO0FBQ2pFLFFBQUs3TixFQUFFMkMsV0FBRixDQUFleU4sR0FBZixLQUF3QnBRLEVBQUU0UixNQUFGLENBQVV4QixHQUFWLENBQTdCLEVBQStDO0FBQzlDO0FBQ0E7O0FBRUQsV0FDQztBQUFBO0FBQUE7QUFDQyxpQkFBWSxvQ0FDWEEsSUFBSXJSLEtBQUosQ0FBVXFCLEtBQVYsS0FBb0IsT0FBS29SLEtBQUwsQ0FBV0MsTUFBL0IsR0FBd0MsU0FBeEMsR0FBb0QsRUFEekMsQ0FEYjtBQUlDLGVBQVUsT0FBS2xCLFdBQUwsQ0FBaUIxRSxJQUFqQixDQUF1QixNQUF2QixFQUE2QnVFLElBQUlyUixLQUFKLENBQVVxQixLQUF2QztBQUpYO0FBTUdnUSxTQUFJclIsS0FBSixDQUFVMEIsS0FOYjtBQUFBO0FBTXVCMlAsU0FBSXJSLEtBQUosQ0FBVTRGLFFBQVYsSUFDckI7QUFBQTtBQUFBLFFBQU0sV0FBVSxXQUFoQjtBQUFBO0FBQUE7QUFQRixLQUREO0FBWUEsSUFqQmlCLENBQWxCOztBQW1CQSxPQUFNK0wsY0FBYzVDLGdCQUFNQyxRQUFOLENBQWVuUCxHQUFmLENBQW9CLEtBQUtHLEtBQUwsQ0FBVzhPLFFBQS9CLEVBQXlDLGVBQU87QUFDbkUsUUFBSzdOLEVBQUUyQyxXQUFGLENBQWV5TixHQUFmLEtBQXdCcFEsRUFBRTRSLE1BQUYsQ0FBVXhCLEdBQVYsQ0FBN0IsRUFBK0M7QUFDOUM7QUFDQTs7QUFFRCxRQUFNeUIsZ0JBQWdCLENBQUU3UixFQUFFMkMsV0FBRixDQUFleU4sSUFBSXJSLEtBQUosQ0FBVTRSLFFBQXpCLENBQUYsR0FDckJQLElBQUlyUixLQUFKLENBQVU0UixRQURXLEdBQ0EsaUJBRHRCOztBQUdBLFdBQ0M7QUFBQTtBQUFBLE9BQUssV0FBWWtCLGlCQUFrQnpCLElBQUlyUixLQUFKLENBQVVxQixLQUFWLEtBQW9CLE9BQUtvUixLQUFMLENBQVdDLE1BQS9CLEdBQXdDLFNBQXhDLEdBQW9ELEVBQXRFLENBQWpCO0FBQ0dyQixTQUFJclIsS0FBSixDQUFVcUIsS0FBVixLQUFvQixPQUFLb1IsS0FBTCxDQUFXQyxNQUEvQixJQUF5Q3JCO0FBRDVDLEtBREQ7QUFLQSxJQWJtQixDQUFwQjs7QUFlQSxVQUNDO0FBQUE7QUFBQSxNQUFLLG9CQUFvQmhSLElBQXBCLFNBQThCdVMsVUFBbkM7QUFDQztBQUFBO0FBQUEsT0FBSyxXQUFVLGVBQWY7QUFDR3hCO0FBREgsS0FERDtBQUtDO0FBQUE7QUFBQSxPQUFLLFdBQVUsa0JBQWY7QUFDR087QUFESDtBQUxELElBREQ7QUFXQTs7OztFQW5FZ0MvQyxnQjs7a0JBQWI0RCxJOzs7Ozs7Ozs7Ozs7Ozs7QUNGckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsSUFBSTtBQUNmLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5Qjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsYUFBYTtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUVBQW1FO0FBQ25FOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx5QkFBeUI7O0FBRXBFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0UsYUFBYTtBQUMvRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0VBQXdFLGVBQWU7QUFDdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRVE7Ozs7Ozs7Ozs7Ozs7O2tCQ3prQmdCTyxLOztBQUZ4Qjs7Ozs7O0FBRWUsU0FBU0EsS0FBVCxHQUFpQjtBQUMvQixRQUFPLEVBQVA7QUFDQSxDOzs7Ozs7Ozs7Ozs7Ozs7QUNKa0M7QUFDbkM7QUFDQTs7Ozs7Ozs7O0FDRkE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTLEdBQUcsU0FBUztBQUM1QywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMseUJBQXlCLEVBQUU7QUFDckU7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaERBOzs7Ozs7Ozs7Ozs7SUFFcUJDLFc7OztBQUNwQixzQkFBYWhULEtBQWIsRUFBcUI7QUFBQTs7QUFBQSxtSEFDYkEsS0FEYTtBQUVwQjs7OzsyQkFFUTtBQUNSLE9BQU1pVCxVQUFVbEUsZ0JBQU1DLFFBQU4sQ0FBZW5QLEdBQWYsQ0FDZixLQUFLRyxLQUFMLENBQVc4TyxRQURJLEVBRWYsb0JBQVk7QUFDWCxXQUFPQSxRQUFQO0FBQ0EsSUFKYyxDQUFoQjs7QUFPQSxPQUFJcE4sUUFBUSxFQUFaOztBQUVBLE9BQUssS0FBSzFCLEtBQUwsQ0FBVzBCLEtBQVgsSUFBb0IsT0FBTyxLQUFLMUIsS0FBTCxDQUFXMEIsS0FBM0MsRUFBbUQ7QUFDbERBLFlBQ0M7QUFBQTtBQUFBLE9BQU0sV0FDTCw4QkFDSSxLQUFLMUIsS0FBTCxDQUFXa1QsU0FBWCxLQUF5QixJQUF6QixHQUFnQyxXQUFoQyxHQUE4QyxFQURsRCxFQUREO0FBSUcsVUFBS2xULEtBQUwsQ0FBVzBCO0FBSmQsS0FERDtBQVFBOztBQUVELE9BQUlnTixjQUFjLEVBQWxCO0FBQ0EsT0FBSXlFLHFCQUFxQixFQUF6Qjs7QUFFQSxPQUFLLENBQUVsUyxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdtVCxrQkFBMUIsQ0FBRixJQUFvRCxPQUFPLEtBQUtuVCxLQUFMLENBQVdtVCxrQkFBM0UsRUFBZ0c7QUFDL0ZBLHlCQUFxQixLQUFLblQsS0FBTCxDQUFXbVQsa0JBQWhDO0FBQ0E7O0FBRUQsT0FBSyxDQUFFbFMsRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXME8sV0FBMUIsQ0FBRixJQUE2QyxPQUFPLEtBQUsxTyxLQUFMLENBQVcwTyxXQUFwRSxFQUFrRjtBQUNqRixRQUFLLEtBQUsxTyxLQUFMLENBQVdvVCxPQUFYLEtBQXVCLEtBQTVCLEVBQW9DO0FBQ25DMUUsbUJBQ0M7QUFBQTtBQUFBO0FBQ0Msa0JBQVUsaUJBRFg7QUFFQyxjQUFRLEVBQUV1RCxjQUFja0IscUJBQXFCLElBQXJDO0FBRlQ7QUFJRyxXQUFLblQsS0FBTCxDQUFXME87QUFKZCxNQUREO0FBUUEsS0FURCxNQVNPO0FBQ05BLG1CQUNDO0FBQUE7QUFBQSxRQUFNLFdBQVUsaUJBQWhCO0FBQW9DLFdBQUsxTyxLQUFMLENBQVcwTztBQUEvQyxNQUREO0FBR0E7QUFDRDs7QUFFRCxPQUFJMEUsVUFBVSxFQUFkOztBQUVBLE9BQ0csS0FBS3BULEtBQUwsQ0FBVzBCLEtBQVgsSUFBb0IsT0FBTyxLQUFLMUIsS0FBTCxDQUFXMEIsS0FBeEMsSUFDRSxLQUFLMUIsS0FBTCxDQUFXME8sV0FBWCxJQUEwQixPQUFPLEtBQUsxTyxLQUFMLENBQVcwTyxXQUYvQyxFQUdFO0FBQ0QwRSxjQUNDO0FBQUE7QUFBQSxPQUFLLFdBQVUsd0JBQWY7QUFDRzFSLFVBREg7QUFFR2dOO0FBRkgsS0FERDtBQU1BOztBQUVELE9BQU0yRSxvQkFBb0IsS0FBS3JULEtBQUwsQ0FBV3NULFNBQVgsR0FDdkIsRUFBRXJCLGNBQWMsQ0FBaEIsRUFBbUJzQixjQUFjLE9BQWpDLEVBRHVCLEdBRXZCLEVBRkg7O0FBSUEsVUFDQztBQUFBO0FBQUEsTUFBSyxXQUFVLHNCQUFmLEVBQXNDLE9BQVFGLGlCQUE5QztBQUNHLEtBQUVwUyxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdvVCxPQUExQixLQUF1QyxLQUFLcFQsS0FBTCxDQUFXb1QsT0FBWCxLQUF1QixLQUFoRSxLQUNEQSxPQUZGO0FBSUM7QUFBQTtBQUFBLE9BQUssV0FBVSx3QkFBZjtBQUNLLE1BQUVuUyxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdvVCxPQUExQixDQUFGLElBQXlDLEtBQUtwVCxLQUFMLENBQVdvVCxPQUFYLEtBQXVCLEtBQWxFLElBQ0QxUixLQUZGO0FBSUssTUFBRVQsRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXb1QsT0FBMUIsQ0FBRixJQUF5QyxLQUFLcFQsS0FBTCxDQUFXb1QsT0FBWCxLQUF1QixLQUFsRSxJQUNEMUUsV0FMRjtBQU9HdUU7QUFQSDtBQUpELElBREQ7QUFnQkE7Ozs7RUFwRnVDckUsZ0I7O2tCQUFwQm9FLFc7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRnJCOzs7Ozs7Ozs7Ozs7OztJQUVxQlEsVTs7O0FBQ3BCLHFCQUFheFQsS0FBYixFQUFxQjtBQUFBOztBQUFBLHNIQUNiQSxLQURhOztBQUdwQixRQUFLNk0sV0FBTCxHQUFtQixNQUFLQSxXQUFMLENBQWlCQyxJQUFqQixPQUFuQjtBQUNBLFFBQUsyRyxTQUFMLEdBQWlCLE1BQUtBLFNBQUwsQ0FBZTNHLElBQWYsT0FBakI7QUFKb0I7QUFLcEI7Ozs7c0NBRW1CO0FBQ25CLFFBQUtwRSxHQUFMLEdBQVdaLE9BQVEsS0FBS3VILEVBQWIsQ0FBWDs7QUFFQSxPQUFNcUUsU0FBUyxLQUFLaEwsR0FBTCxDQUFTc0gsT0FBVCxDQUFrQixvQkFBbEIsQ0FBZjtBQUNBLE9BQU0yRCxXQUFXRCxPQUFPcE4sSUFBUCxDQUFhLElBQWIsQ0FBakI7QUFDQSxPQUFNc04sWUFBWSxLQUFLNVQsS0FBTCxDQUFXNFQsU0FBWCxHQUF1QixDQUF2QixHQUEyQixDQUFDLENBQTlDOztBQUVBLE9BQU1wUixVQUFVcVIsT0FBT0MsTUFBUCxDQUNmO0FBQ0NDLG9CQUFrQkwsT0FBT3ZQLE1BQVQsR0FDYjJELE9BQVEsTUFBTTZMLFFBQWQsQ0FEYSxHQUViN0wsT0FBUSxxQkFBUixDQUhKO0FBSUNrTSw2QkFBeUJKLFNBSjFCO0FBS0NoTCxzQkFBa0IsS0FBS0YsR0FBTCxDQUFTdUwsUUFBVCxDQUFtQixlQUFuQixJQUNmLHdCQURlLEdBRWYsRUFQSjtBQVFDQyxXQUFPO0FBUlIsSUFEZSxFQVdmLEtBQUtsVSxLQUFMLENBQVd3QyxPQVhJLENBQWhCOztBQWNBLE9BQUssT0FBTyxLQUFLa0csR0FBTCxDQUFTYSxVQUFoQixLQUErQixVQUFwQyxFQUFpRDtBQUNoRCxTQUFLYixHQUFMLENBQVNhLFVBQVQsQ0FBcUIvRyxPQUFyQjtBQUNBLElBRkQsTUFFTyxJQUFLLE9BQU8sS0FBS2tHLEdBQUwsQ0FBU3lMLFVBQWhCLEtBQStCLFVBQXBDLEVBQWlEO0FBQ3ZELFNBQUt6TCxHQUFMLENBQVN5TCxVQUFULENBQXFCM1IsT0FBckI7QUFDQSxJQUZNLE1BRUE7QUFDTixVQUFNNFIsTUFBTywyQkFBUCxDQUFOO0FBQ0E7O0FBRUQsUUFBS3ZILFdBQUwsR0FBbUIsS0FBS0EsV0FBTCxDQUFpQkMsSUFBakIsQ0FBdUIsSUFBdkIsQ0FBbkI7QUFDQSxRQUFLcEUsR0FBTCxDQUFTRyxFQUFULENBQWEsUUFBYixFQUF1QixLQUFLZ0UsV0FBNUI7O0FBRUEsT0FBSyxLQUFLN00sS0FBTCxDQUFXcVUsYUFBaEIsRUFBZ0M7QUFDL0IsU0FBSzNMLEdBQUwsQ0FBU1ksT0FBVCxDQUFrQixRQUFsQjtBQUNBO0FBQ0Q7Ozs4QkFFWVIsQyxFQUFJO0FBQ2hCLE9BQU16SCxRQUFReUcsT0FBUWdCLEVBQUU0RCxNQUFWLEVBQW1CeEYsR0FBbkIsRUFBZDs7QUFFQTtBQUNBLE9BQUssT0FBTyxLQUFLbEgsS0FBTCxDQUFXK00sY0FBbEIsS0FBcUMsVUFBMUMsRUFBdUQ7QUFDdEQ7QUFDQSxTQUFLL00sS0FBTCxDQUFXK00sY0FBWCxDQUEyQixLQUFLL00sS0FBTCxDQUFXZ04sUUFBdEMsRUFBZ0QzTCxLQUFoRDtBQUNBLElBSEQsTUFHTztBQUNOO0FBQ0EsU0FBS3JCLEtBQUwsQ0FBV2lOLE9BQVgsQ0FBbUJDLGVBQW5CLENBQW1DQyxhQUFuQyxDQUFrRCxLQUFLbk4sS0FBTCxDQUFXZ04sUUFBN0QsRUFBdUUzTCxLQUF2RTtBQUNBOztBQUVELFFBQUtvUyxTQUFMLENBQWdCcFMsS0FBaEI7QUFDQTs7OzhCQUVXO0FBQ1gsVUFBTyxLQUFQO0FBQ0E7Ozt5Q0FFc0I7QUFDdEIsUUFBS3FILEdBQUwsQ0FBU21JLEdBQVQsQ0FBYyxRQUFkLEVBQXdCLEtBQUtoRSxXQUE3QjtBQUNBLFFBQUtuRSxHQUFMLENBQVNvSSxNQUFULEdBQWtCQyxVQUFsQjtBQUNBOzs7MkJBRVE7QUFBQTs7QUFDUixPQUFNMVAsUUFBUUosRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXRyxRQUFYLENBQXFCLEtBQUtILEtBQUwsQ0FBV2dOLFFBQWhDLENBQWYsSUFDWCxLQUFLaE4sS0FBTCxDQUFXc04sWUFEQSxHQUVYLEtBQUt0TixLQUFMLENBQVdHLFFBQVgsQ0FBcUIsS0FBS0gsS0FBTCxDQUFXZ04sUUFBaEMsQ0FGSDs7QUFJQSxPQUFNMEUsV0FBVyxDQUFFelEsRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXeU4sVUFBMUIsQ0FBRixHQUNkLG9CQUFvQixLQUFLek4sS0FBTCxDQUFXeU4sVUFEakIsR0FFZCxnQkFGSDs7QUFJQSxPQUFNNkcsV0FBVyxDQUFFclQsRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXdVUsU0FBMUIsQ0FBRixHQUNkLEtBQUt2VSxLQUFMLENBQVd1VSxTQURHLEdBRWQsS0FBS3ZVLEtBQUwsQ0FBV2dOLFFBRmQ7O0FBSUEsT0FBSWEsbUJBQUo7O0FBRUEsT0FBSyxLQUFLN04sS0FBTCxDQUFXMEIsS0FBaEIsRUFBd0I7QUFDdkJtTSxpQkFDQztBQUFBO0FBQUE7QUFDQyxxQ0FBK0IsS0FBSzdOLEtBQUwsQ0FBV2dOLFFBRDNDO0FBRUMsaUJBQVU7QUFGWDtBQUlHLFVBQUtoTixLQUFMLENBQVcwQixLQUpkO0FBQUE7QUFJNkIsVUFBSzFCLEtBQUwsQ0FBVzRGLFFBQVgsSUFDM0I7QUFBQTtBQUFBLFFBQU0sV0FBVSxXQUFoQjtBQUFBO0FBQUEsTUFMRjtBQU9HLFVBQUs1RixLQUFMLENBQVcrTixJQUFYLElBQ0Q7QUFBQTtBQUFBLFFBQU0sV0FBVSxnQkFBaEI7QUFBbUMsV0FBSy9OLEtBQUwsQ0FBVytOO0FBQTlDO0FBUkYsS0FERDtBQWFBOztBQUVELE9BQU15RyxXQUFXLEtBQUt4VSxLQUFMLENBQVd3VSxRQUE1Qjs7QUEvQlEsZ0JBZ0MwRyxLQUFLeFUsS0FoQy9HO0FBQUEsT0FnQ0F5VSxRQWhDQSxVQWdDQUEsUUFoQ0E7QUFBQSxPQWdDVTFILGNBaENWLFVBZ0NVQSxjQWhDVjtBQUFBLE9BZ0MwQjJILFNBaEMxQixVQWdDMEJBLFNBaEMxQjtBQUFBLE9BZ0NxQ2pILFVBaENyQyxVQWdDcUNBLFVBaENyQztBQUFBLE9BZ0NpRGtILGFBaENqRCxVQWdDaURBLGFBaENqRDtBQUFBLE9BZ0NnRXpVLFVBaENoRSxVQWdDZ0VBLFVBaENoRTtBQUFBLE9BZ0M0RTBVLFNBaEM1RSxVQWdDNEVBLFNBaEM1RTtBQUFBLE9BZ0MwRkMsV0FoQzFGOztBQWtDUixPQUFNQyxZQUNMO0FBQUE7QUFBQTtBQUNDLCtCQUEwQlIsUUFEM0I7QUFFQyxnQkFBVSxZQUZYO0FBR0MsVUFBTTtBQUFBLGFBQVEsT0FBS2pGLEVBQUwsR0FBVUEsRUFBbEI7QUFBQSxNQUhQO0FBSUMsbUJBQWVoTyxLQUpoQjtBQUtDLGVBQVdtVDtBQUxaLE9BTU1LLFdBTk47QUFRRSxTQUFLN1UsS0FBTCxDQUFXOE87QUFSYixJQUREOztBQWFBLE9BQUlpRyxhQUNIO0FBQUE7QUFBQTtBQUNDLCtCQUEwQlQsUUFEM0I7QUFFQyxnQkFBVSxZQUZYO0FBR0MsVUFBTTtBQUFBLGFBQVEsT0FBS2pGLEVBQUwsR0FBVUEsRUFBbEI7QUFBQSxNQUhQO0FBSUMsbUJBQWVoTyxLQUpoQjtBQUtDLGVBQVdtVDtBQUxaO0FBT0UsU0FBS3hVLEtBQUwsQ0FBVzhPO0FBUGIsSUFERDs7QUFZQSxPQUFLLFNBQVMsS0FBSzlPLEtBQUwsQ0FBV2dWLFNBQXBCLElBQWlDLGFBQWEsS0FBS2hWLEtBQUwsQ0FBV2dWLFNBQTlELEVBQTBFO0FBQ3pFRCxpQkFDQztBQUFBO0FBQUEsT0FBSyxXQUFVLDZCQUFmO0FBQ0dEO0FBREgsS0FERDtBQUtBLElBTkQsTUFNTyxJQUFLLFNBQVMsS0FBSzlVLEtBQUwsQ0FBV2dWLFNBQXBCLElBQWlDLFlBQVksS0FBS2hWLEtBQUwsQ0FBV2dWLFNBQTdELEVBQXlFO0FBQy9FRCxpQkFDQztBQUFBO0FBQUEsT0FBSyxXQUFVLDZCQUFmO0FBQ0dEO0FBREgsS0FERDtBQUtBLElBTk0sTUFNQSxJQUFLLENBQUU3VCxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdnVixTQUExQixDQUFGLElBQTJDLE9BQU8sS0FBS2hWLEtBQUwsQ0FBV2dWLFNBQWxFLEVBQThFO0FBQ3BGRCxpQkFDQztBQUFBO0FBQUEsT0FBSyxPQUFRLEVBQUViLE9BQU8sTUFBVCxFQUFpQmUsVUFBVSxLQUFLalYsS0FBTCxDQUFXZ1YsU0FBWCxHQUF1QixJQUFsRCxFQUFiO0FBQ0dGO0FBREgsS0FERDtBQUtBOztBQUVELE9BQUssS0FBSzlVLEtBQUwsQ0FBVzBVLFNBQWhCLEVBQTRCO0FBQzNCLFdBQU9JLFNBQVA7QUFDQTs7QUFFRCxVQUNDO0FBQUE7QUFBQSxNQUFLLFdBQVlwRCxRQUFqQjtBQUVHN0QsY0FGSDtBQUlHa0gsY0FKSDtBQU1HLFNBQUsvVSxLQUFMLENBQVcwTyxXQUFYLElBQ0Q7QUFBQTtBQUFBO0FBQ0MsaUJBQVUsaUJBRFg7QUFFQyxhQUFRLEVBQUV3RyxXQUFXLE1BQWI7QUFGVDtBQUlHLFVBQUtsVixLQUFMLENBQVcwTztBQUpkO0FBUEYsSUFERDtBQWtCQTs7OztFQTFLc0NFLGdCOztrQkFBbkI0RSxVOzs7Ozs7OztBQ0ZyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQy9EQTs7Ozs7Ozs7Ozs7O0lBRXFCMkIsUzs7O0FBQ3BCLG9CQUFhblYsS0FBYixFQUFxQjtBQUFBOztBQUFBLG9IQUNiQSxLQURhOztBQUdwQixRQUFLNk0sV0FBTCxHQUFtQixNQUFLQSxXQUFMLENBQWlCQyxJQUFqQixPQUFuQjtBQUhvQjtBQUlwQjs7OztzQ0FFbUI7QUFDbkIsUUFBS3BFLEdBQUwsR0FBV1osT0FBUSxLQUFLdUgsRUFBYixDQUFYO0FBQ0E7O0FBRUEsUUFBS3hDLFdBQUwsR0FBbUIsS0FBS0EsV0FBTCxDQUFpQkMsSUFBakIsQ0FBdUIsSUFBdkIsQ0FBbkI7QUFDQSxRQUFLcEUsR0FBTCxDQUFTRyxFQUFULENBQWEsUUFBYixFQUF1QixLQUFLZ0UsV0FBNUI7QUFDQTs7OzhCQUVZL0QsQyxFQUFJO0FBQ2hCLE9BQU16SCxRQUFReUgsRUFBRTRELE1BQUYsQ0FBU3JMLEtBQXZCOztBQUVBO0FBQ0EsT0FBSyxPQUFPLEtBQUtyQixLQUFMLENBQVcrTSxjQUFsQixLQUFxQyxVQUExQyxFQUF1RDtBQUN0RDtBQUNBLFNBQUsvTSxLQUFMLENBQVcrTSxjQUFYLENBQTJCLEtBQUsvTSxLQUFMLENBQVdnTixRQUF0QyxFQUFnRDNMLEtBQWhEO0FBQ0EsSUFIRCxNQUdPO0FBQ047QUFDQSxTQUFLckIsS0FBTCxDQUFXaU4sT0FBWCxDQUFtQkMsZUFBbkIsQ0FBbUNDLGFBQW5DLENBQWtELEtBQUtuTixLQUFMLENBQVdnTixRQUE3RCxFQUF1RTNMLEtBQXZFO0FBQ0E7QUFDRDs7O3lDQUVzQjtBQUN0QixRQUFLcUgsR0FBTCxDQUFTbUksR0FBVCxDQUFjLFFBQWQsRUFBd0IsS0FBS2hFLFdBQTdCO0FBQ0EsUUFBS25FLEdBQUwsQ0FBU29JLE1BQVQsR0FBa0JDLFVBQWxCO0FBQ0E7OzsyQkFFUTtBQUFBOztBQUNSLE9BQUkxUCxRQUFRSixFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdHLFFBQVgsQ0FBcUIsS0FBS0gsS0FBTCxDQUFXZ04sUUFBaEMsQ0FBZixJQUNULEtBQUtoTixLQUFMLENBQVdzTixZQURGLEdBRVQsS0FBS3ROLEtBQUwsQ0FBV0csUUFBWCxDQUFxQixLQUFLSCxLQUFMLENBQVdnTixRQUFoQyxDQUZIOztBQUlBLE9BQU1TLGFBQWEsQ0FBRXhNLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV3lOLFVBQTFCLENBQUYsR0FDaEIsb0JBQW9CLEtBQUt6TixLQUFMLENBQVd5TixVQURmLEdBRWhCLGdCQUZIOztBQUlBLE9BQU0ySCxjQUFjLENBQUVuVSxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdxVixZQUExQixDQUFGLEdBQ2pCLEtBQUtyVixLQUFMLENBQVdxVixZQURNLEdBRWpCLEVBRkg7O0FBSUEsT0FBTWYsV0FBVyxDQUFFclQsRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXdVUsU0FBMUIsQ0FBRixHQUNkLEtBQUt2VSxLQUFMLENBQVd1VSxTQURHLEdBRWQsS0FBS3ZVLEtBQUwsQ0FBV2dOLFFBRmQ7O0FBSUEsT0FBSXNJLGNBQWMsRUFBbEI7O0FBRUEsT0FBSyxLQUFLdFYsS0FBTCxDQUFXMEIsS0FBaEIsRUFBd0I7QUFDdkI0VCxrQkFDQztBQUFBO0FBQUE7QUFDQyxxQ0FBK0IsS0FBS3RWLEtBQUwsQ0FBV2dOLFFBRDNDO0FBRUMsZ0NBQTBCLEtBQUtoTixLQUFMLENBQVdnTixRQUFyQyxXQUZEO0FBR0MsaUJBQVU7QUFIWDtBQUtHLFVBQUtoTixLQUFMLENBQVcwQixLQUxkO0FBQUE7QUFLNkIsVUFBSzFCLEtBQUwsQ0FBVzRGLFFBQVgsSUFDM0I7QUFBQTtBQUFBLFFBQU0sV0FBVSxXQUFoQjtBQUFBO0FBQUEsTUFORjtBQVFHLFVBQUs1RixLQUFMLENBQVcrTixJQUFYLElBQ0Q7QUFBQTtBQUFBLFFBQU0sV0FBVSxnQkFBaEI7QUFBa0MsV0FBSy9OLEtBQUwsQ0FBVytOO0FBQTdDO0FBVEYsS0FERDtBQWNBOztBQUVEO0FBQ0EsT0FDQyxDQUFFOU0sRUFBRTJDLFdBQUYsQ0FBZXZDLEtBQWYsQ0FBRixLQUNFLDZCQUE2QixLQUFLckIsS0FBTCxDQUFXZ04sUUFBeEMsSUFBb0Qsa0NBQWtDLEtBQUtoTixLQUFMLENBQVdnTixRQURuRyxDQURELEVBR0U7QUFDRDNMLFlBQVFBLE1BQU00SyxXQUFOLEVBQVI7QUFDQTs7QUFFRCxPQUFNc0osY0FDTDtBQUFBO0FBQUE7QUFDQyxtQkFBZWxVLEtBRGhCO0FBRUMsK0JBQTBCaVQsUUFGM0I7QUFHQyxnQkFBWWMsV0FIYjtBQUlDLDhDQUF1Q2QsUUFBdkMsV0FKRDtBQUtDLFVBQU07QUFBQSxhQUFRLE9BQUtqRixFQUFMLEdBQVVBLEVBQWxCO0FBQUEsTUFMUDtBQU1DLFlBQVEsRUFBRTRGLFVBQVUsTUFBWjtBQU5UO0FBUUcsU0FBS2pWLEtBQUwsQ0FBVzhPO0FBUmQsSUFERDs7QUFhQSxPQUFJaUcsYUFBYVEsV0FBakI7O0FBRUEsT0FBSyxTQUFTLEtBQUt2VixLQUFMLENBQVdnVixTQUFwQixJQUFpQyxhQUFhLEtBQUtoVixLQUFMLENBQVdnVixTQUE5RCxFQUEwRTtBQUN6RUQsaUJBQ0M7QUFBQTtBQUFBLE9BQUssV0FBVSw2QkFBZjtBQUNHUTtBQURILEtBREQ7QUFLQSxJQU5ELE1BTU8sSUFBSyxTQUFTLEtBQUt2VixLQUFMLENBQVdnVixTQUFwQixJQUFpQyxZQUFZLEtBQUtoVixLQUFMLENBQVdnVixTQUE3RCxFQUF5RTtBQUMvRUQsaUJBQ0M7QUFBQTtBQUFBLE9BQUssV0FBVSw2QkFBZjtBQUNHUTtBQURILEtBREQ7QUFLQSxJQU5NLE1BTUEsSUFBSyxPQUFPLEtBQUt2VixLQUFMLENBQVdnVixTQUF2QixFQUFtQztBQUN6Q0QsaUJBQ0M7QUFBQTtBQUFBLE9BQUssT0FBUSxFQUFFYixPQUFPLE1BQVQsRUFBaUJlLFVBQVUsS0FBS2pWLEtBQUwsQ0FBV2dWLFNBQVgsR0FBdUIsSUFBbEQsRUFBYjtBQUNHTztBQURILEtBREQ7QUFLQTs7QUFFRCxPQUFJQyxXQUFXVCxVQUFmOztBQUVBLE9BQUssQ0FBRSxLQUFLL1UsS0FBTCxDQUFXMk8sTUFBbEIsRUFBMkI7QUFDMUI2RyxlQUNDO0FBQUE7QUFBQSxPQUFLLFdBQVkvSCxVQUFqQjtBQUVHNkgsZ0JBRkg7QUFJR1AsZUFKSDtBQU1HLFVBQUsvVSxLQUFMLENBQVcwTyxXQUFYLElBQ0Q7QUFBQTtBQUFBO0FBQ0Msa0JBQVUsaUJBRFg7QUFFQyxjQUFRLEVBQUV3RyxXQUFXLE1BQWI7QUFGVDtBQUlHLFdBQUtsVixLQUFMLENBQVcwTztBQUpkO0FBUEYsS0FERDtBQWtCQTs7QUFFRCxVQUFPOEcsUUFBUDtBQUNBOzs7O0VBeElxQzVHLGdCOztrQkFBbEJ1RyxTOzs7Ozs7OztBQ0ZyQiwwQjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ1E7QUFDUjtBQUNRO0FBQ1I7QUFDUTs7QUFFb0M7Ozs7Ozs7Ozs7Ozs7Ozs7QUNQNUM7Ozs7QUFDQTs7Ozs7Ozs7OztJQUVxQk0sTTs7O0FBQ3BCLGlCQUFhelYsS0FBYixFQUFxQjtBQUFBOztBQUFBLDhHQUNiQSxLQURhOztBQUdwQixRQUFLNk0sV0FBTCxHQUFtQixNQUFLQSxXQUFMLENBQWlCQyxJQUFqQixPQUFuQjtBQUhvQjtBQUlwQjs7Ozs4QkFFWXpMLEssRUFBUTtBQUNwQjtBQUNBLE9BQUssT0FBTyxLQUFLckIsS0FBTCxDQUFXK00sY0FBbEIsS0FBcUMsVUFBMUMsRUFBdUQ7QUFDdEQ7QUFDQSxTQUFLL00sS0FBTCxDQUFXK00sY0FBWCxDQUEyQixLQUFLL00sS0FBTCxDQUFXZ04sUUFBdEMsRUFBZ0QzTCxLQUFoRDtBQUNBLElBSEQsTUFHTztBQUNOO0FBQ0EsU0FBS3JCLEtBQUwsQ0FBV2lOLE9BQVgsQ0FBbUJDLGVBQW5CLENBQW1DQyxhQUFuQyxDQUFrRCxLQUFLbk4sS0FBTCxDQUFXZ04sUUFBN0QsRUFBdUUzTCxLQUF2RTtBQUNBO0FBQ0Q7OzsyQkFFUTtBQUFBOztBQUNSLE9BQU1BLFFBQVFKLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV0csUUFBWCxDQUFxQixLQUFLSCxLQUFMLENBQVdnTixRQUFoQyxDQUFmLElBQ1gsRUFEVyxHQUVYLEtBQUtoTixLQUFMLENBQVdHLFFBQVgsQ0FBcUIsS0FBS0gsS0FBTCxDQUFXZ04sUUFBaEMsQ0FGSDs7QUFLQSxPQUFNbUMsY0FBYyxDQUFFbE8sRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXbVAsV0FBMUIsQ0FBRixHQUNqQixLQUFLblAsS0FBTCxDQUFXbVAsV0FETSxHQUVqQixrQkFGSDs7QUFLQSxPQUFNMUcsV0FBVyxDQUFFeEgsRUFBRTJDLFdBQUYsQ0FBZSxLQUFLNUQsS0FBTCxDQUFXeUksUUFBMUIsQ0FBRixJQUEwQyxLQUFLekksS0FBTCxDQUFXeUksUUFBdEU7QUFDQSxPQUFNaU4sVUFBVXJVLFNBQVMsQ0FBRW9ILFFBQTNCOztBQUVBLE9BQU1rTixnQkFDTDtBQUFBO0FBQUEsTUFBTywrQkFBK0IsS0FBSzNWLEtBQUwsQ0FBV2dOLFFBQWpEO0FBQ0MsZ0JBQVU7QUFEWDtBQUdDLDZDQUFPLE1BQUssVUFBWjtBQUNDLFlBQU0sTUFEUDtBQUVDLCtCQUEwQixLQUFLaE4sS0FBTCxDQUFXZ04sUUFGdEM7QUFHQyxnQkFBWW1DLFdBSGI7QUFJQyxlQUFXMUcsV0FBVyxVQUFYLEdBQXdCLEVBSnBDO0FBS0MsY0FBVWlOLFVBQVUsU0FBVixHQUFzQixFQUxqQztBQU1DLGVBQVcscUJBQUs7QUFDZixhQUFLN0ksV0FBTCxDQUFrQi9ELEVBQUU0RCxNQUFGLENBQVNnSixPQUEzQjtBQUNBO0FBUkYsTUFIRDtBQWFDLDRDQUFNLFdBQVUsbUJBQWhCLEdBYkQ7QUFjRyxTQUFLMVYsS0FBTCxDQUFXMEIsS0FBWCxJQUNEO0FBQUMsb0JBQUQsQ0FBTyxRQUFQO0FBQUE7QUFDQztBQUFBO0FBQUEsUUFBTSxXQUFVLHdCQUFoQjtBQUNHLDRCQUFXLFFBQVgsQ0FESDtBQUFBO0FBQzZCLFdBQUsxQixLQUFMLENBQVcwQjtBQUR4QyxNQUREO0FBSUM7QUFBQTtBQUFBLFFBQU0sV0FBVSxrQkFBaEI7QUFDRyxXQUFLMUIsS0FBTCxDQUFXMEI7QUFEZDtBQUpELEtBZkY7QUF3QkcsU0FBSzFCLEtBQUwsQ0FBVzBPLFdBQVgsSUFDRDtBQUFBO0FBQUEsT0FBTSxXQUFVLHdDQUFoQjtBQUNHLFVBQUsxTyxLQUFMLENBQVcwTztBQURkO0FBekJGLElBREQ7O0FBaUNBLE9BQUlrSCxZQUFZLEVBQWhCOztBQUVBLE9BQUssS0FBSzVWLEtBQUwsQ0FBVzhPLFFBQVgsSUFBdUIsS0FBSzlPLEtBQUwsQ0FBV0csUUFBWCxDQUFxQixLQUFLSCxLQUFMLENBQVdnTixRQUFoQyxDQUE1QixFQUF5RTtBQUN4RTRJLGdCQUNDO0FBQUMsb0JBQUQsQ0FBTyxRQUFQO0FBQUE7QUFDQztBQUFBO0FBQUE7QUFDQyxpQkFBUyxHQURWO0FBRUMsa0JBQVUscUNBRlg7QUFHQyxxQkFBYSxLQUFLNVYsS0FBTCxDQUFXMEI7QUFIekI7QUFLRyxXQUFLMUIsS0FBTCxDQUFXOE87QUFMZDtBQURELEtBREQ7QUFXQTs7QUFFRCxPQUFLLEtBQUs5TyxLQUFMLENBQVc2VixNQUFoQixFQUF5QjtBQUN4QixXQUNDO0FBQUMsb0JBQUQsQ0FBTyxRQUFQO0FBQUE7QUFDR0Ysa0JBREg7QUFFR0M7QUFGSCxLQUREO0FBTUE7O0FBRUQsT0FBSyxDQUFFLEtBQUs1VixLQUFMLENBQVc2VixNQUFsQixFQUEyQjtBQUMxQixXQUNDO0FBQUE7QUFBQSxPQUFLLFdBQVUsZ0JBQWY7QUFDR0Ysa0JBREg7QUFFR0M7QUFGSCxLQUREO0FBTUE7QUFDRDs7OztFQWxHa0NoSCxnQjs7a0JBQWY2RyxNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSHJCO0FBQ1E7QUFDUjtBQUNRO0FBQ1I7QUFDUTtBQUNSO0FBQ1E7QUFDUjtBQUNRO0FBQ1I7QUFDUTtBQUNSO0FBQ1E7QUFDUjtBQUNRO0FBQ1I7QUFDUTtBQUNSO0FBQ1E7QUFDUjtBQUNRO0FBQ1I7QUFDUTtBQUNSO0FBQ1E7QUFDUjs7Ozs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxFOzs7Ozs7Ozs7Ozs7Ozs7O0FDekRBOzs7Ozs7Ozs7Ozs7SUFFcUJLLFk7OztBQUNwQix1QkFBYTlWLEtBQWIsRUFBcUI7QUFBQTs7QUFBQSxxSEFDYkEsS0FEYTtBQUVwQjs7OzsrQkFFWTtBQUNaLE9BQUssQ0FBRThILE9BQVEsdUJBQVIsRUFBa0MzRCxNQUF6QyxFQUFrRDtBQUNqRDJELFdBQVEsZUFBUixFQUEwQmlPLE9BQTFCLENBQW1DLDBDQUFuQztBQUNBOztBQUVELE9BQUssQ0FBRWpPLE9BQVEsMEJBQVIsRUFBcUMzRCxNQUE1QyxFQUFxRDtBQUNwRDJELFdBQVEsdUJBQVIsRUFBa0N1QixNQUFsQyxDQUNDLGdHQUREO0FBR0EsSUFKRCxNQUlPO0FBQ052QixXQUFRLDBCQUFSLEVBQXFDa08sTUFBckM7QUFDQSxTQUFLQyxVQUFMO0FBQ0E7O0FBRUQsUUFBS0MsYUFBTCxHQUFxQnBPLE9BQVEsMEJBQVIsQ0FBckI7QUFDQTs7O3lCQUVNO0FBQ04sUUFBS21PLFVBQUw7O0FBRUEsT0FBTUUsV0FBVyx5QkFBakI7QUFDQSxPQUFNQyxnQkFBZ0IsUUFBUSxLQUFLcFcsS0FBTCxDQUFXcVcsSUFBbkIsR0FBMEIsTUFBaEQ7QUFDQSxPQUFNQyxnQkFBZ0I7QUFDckJqVyxVQUFNLEtBQUtMLEtBQUwsQ0FBV0ssSUFBWCxJQUFtQixTQURKO0FBRXJCa1csZUFBVztBQUNWQyxjQUFTLEtBQUt4VyxLQUFMLENBQVd5VyxJQUFYLElBQW1CO0FBRGxCLEtBRlU7QUFLckJDLGFBQVM7QUFDUkMsV0FBTSxLQUFLM1csS0FBTCxDQUFXMFcsT0FBWCxJQUFzQjtBQURwQjtBQUxZLElBQXRCOztBQVVBL08sT0FBSWlQLFVBQUosQ0FBZ0JULFFBQWhCLEVBQTBCQyxhQUExQixFQUF5Q0UsYUFBekM7QUFDQTs7OzBCQUVPO0FBQ1AsT0FBTUgsV0FBVyx5QkFBakI7QUFDQXhPLE9BQUlrUCxXQUFKLENBQWlCVixRQUFqQjtBQUNBOzs7O0VBM0N3Q3ZILGdCOztrQkFBckJrSCxZOzs7Ozs7Ozs7QUNGckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQzNEQTtBQUFBLG1EQUFtRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWU7O0FBRTlQO0FBQ0E7QUFDb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEU7Ozs7Ozs7Ozs7Ozs7OztBQ2hFQTs7OztBQUNBOzs7Ozs7Ozs7O0lBRXFCZ0IsUzs7O0FBQ3BCLG9CQUFhOVcsS0FBYixFQUFxQjtBQUFBOztBQUFBLG9IQUNiQSxLQURhOztBQUdwQixRQUFLeVMsS0FBTCxHQUFhO0FBQ1o5RixTQUFNM00sTUFBTStXLFFBQU4sSUFBa0I7QUFEWixHQUFiOztBQUlBLFFBQUtDLFdBQUwsR0FBbUIsTUFBS0EsV0FBTCxDQUFpQmxLLElBQWpCLE9BQW5CO0FBUG9CO0FBUXBCOzs7O2dDQUVhO0FBQ2IsUUFBSzZGLFFBQUwsQ0FBZTtBQUNkaEcsVUFBTSxDQUFFLEtBQUs4RixLQUFMLENBQVc5RjtBQURMLElBQWY7QUFHQTs7OzJCQUVRO0FBQUE7O0FBQUEsT0FDQWpMLEtBREEsR0FDVSxLQUFLMUIsS0FEZixDQUNBMEIsS0FEQTtBQUFBLE9BRUFpTCxJQUZBLEdBRVMsS0FBSzhGLEtBRmQsQ0FFQTlGLElBRkE7O0FBR1IsT0FBSStFLFdBQVcsRUFBZjs7QUFFQSxPQUFLL0UsSUFBTCxFQUFZO0FBQ1grRSxlQUFXLDBCQUFYO0FBQ0E7O0FBRUQ7QUFDQSxPQUFNdUYsZUFBaUIsQ0FBRWhXLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV2lYLFlBQTFCLENBQUYsSUFBOEMsT0FBTyxLQUFLalgsS0FBTCxDQUFXaVgsWUFBbEUsR0FDbEIsS0FBS2pYLEtBQUwsQ0FBV2lYLFlBRE8sR0FFbEIsSUFGSDs7QUFJQSxPQUFNQyx1QkFBeUIsQ0FBRWpXLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBV2tYLG9CQUExQixDQUFKLEdBQzFCLEtBQUtsWCxLQUFMLENBQVdrWCxvQkFEZSxHQUUxQixLQUZIOztBQUlBLE9BQU1DLG9CQUFvQnBJLGdCQUFNQyxRQUFOLENBQWVuUCxHQUFmLENBQW9CLEtBQUtHLEtBQUwsQ0FBVzhPLFFBQS9CLEVBQXlDLGVBQU87QUFDekUsV0FBT3VDLEdBQVA7QUFDQSxJQUZ5QixDQUExQjs7QUFJQTtBQUNBLFVBQ0M7QUFBQTtBQUFBLE1BQUssV0FBWSx3QkFBd0JLLFFBQXpDO0FBQ0M7QUFBQTtBQUFBLE9BQU0sV0FBVSwyQkFBaEIsRUFBNEMsU0FBVTtBQUFBLGNBQU0sT0FBS3NGLFdBQUwsRUFBTjtBQUFBLE9BQXREO0FBQ0M7QUFBQTtBQUFBLFFBQUssV0FBVSwwQkFBZjtBQUNDO0FBQUE7QUFBQTtBQUFRdFY7QUFBUixPQUREO0FBRUM7QUFBQTtBQUFBO0FBQ0MsbUJBQVUsOENBRFg7QUFFQyxpQkFBVTtBQUFBLGdCQUFNLE9BQUtzVixXQUFMLEVBQU47QUFBQTtBQUZYO0FBSUMsNENBQUcsV0FBVSx1QkFBYixFQUFxQyxlQUFZLE1BQWpELEdBSkQ7QUFLQztBQUFBO0FBQUEsVUFBTSxXQUFVLHdCQUFoQjtBQUNHLGtCQUFVLEtBQUt2RSxLQUFMLENBQVc5RixJQUFyQixHQUE0QixNQUE1QixHQUFxQztBQUR4QztBQUxEO0FBRkQ7QUFERCxLQUREO0FBZUM7QUFBQTtBQUFBLE9BQUssV0FBVSx5QkFBZjtBQUNHLGVBQVVzSyxZQUFWLEdBQ0MsQ0FBRUMsd0JBQXdCdkssSUFBMUIsS0FBb0N3SyxpQkFEckMsR0FHQTtBQUFBO0FBQUEsUUFBSyxXQUFVLFNBQWY7QUFDQztBQUFBO0FBQUEsU0FBSyxXQUFVLGNBQWY7QUFDRyxRQUFFRCx3QkFBd0J2SyxJQUExQixLQUFvQ3dLO0FBRHZDLE9BREQ7QUFJR0Y7QUFKSDtBQUpIO0FBZkQsSUFERDtBQStCQTs7OztFQXZFcUNySSxnQjs7a0JBQWxCa0ksUzs7Ozs7Ozs7QUNIckI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDNVBBLDBD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Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNILG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQzdTQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0I7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQSwyQjs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBYTtBQUNuRztBQUNBOztB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDOztBQUVBLHVFOzs7Ozs7O0FDcENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7K0NDVkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7O0FDbkxBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakJBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNKQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FDbEJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixPQUFPLFdBQVcsYUFBYTtBQUNqRDs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwTkE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQkE7Ozs7Ozs7Ozs7OztJQUVxQlMsVzs7O0FBQ3BCLHNCQUFhN1osS0FBYixFQUFxQjtBQUFBOztBQUFBLG1IQUNiQSxLQURhO0FBRXBCOzs7OzJCQUVRO0FBQ1IsT0FBTThPLFdBQVdDLGdCQUFNQyxRQUFOLENBQWVuUCxHQUFmLENBQW9CLEtBQUtHLEtBQUwsQ0FBVzhPLFFBQS9CLEVBQXlDLDBCQUFrQjtBQUMzRSxXQUFPZ0wsY0FBUDtBQUNBLElBRmdCLENBQWpCOztBQUlBLE9BQU1sQyxZQUFjLENBQUUzVyxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVc0WCxTQUExQixDQUFGLElBQTJDLE9BQU8sS0FBSzVYLEtBQUwsQ0FBVzRYLFNBQS9ELEdBQ2YsS0FBSzVYLEtBQUwsQ0FBVzRYLFNBREksR0FFZixFQUZIOztBQUlBLE9BQU1DLFVBQVksQ0FBRTVXLEVBQUUyQyxXQUFGLENBQWUsS0FBSzVELEtBQUwsQ0FBVzZYLE9BQTFCLENBQUYsSUFBeUMsU0FBUyxLQUFLN1gsS0FBTCxDQUFXNlgsT0FBL0QsR0FDYixJQURhLEdBRWIsS0FGSDs7QUFJQTtBQUNBLE9BQU01RCxXQUFhLENBQUVoVCxFQUFFMkMsV0FBRixDQUFlLEtBQUs1RCxLQUFMLENBQVdtUCxXQUExQixDQUFGLElBQTZDLE9BQU8sS0FBS25QLEtBQUwsQ0FBV21QLFdBQWpFLEdBQ2QsSUFEYyxHQUVkLEtBRkg7O0FBSUEsT0FBSXFKLFVBQVUsZ0JBQWQ7O0FBRUEsT0FBSyxTQUFTWCxPQUFkLEVBQXdCO0FBQ3ZCVyxlQUFXLGNBQVg7QUFDQTs7QUFFRCxPQUFLLE9BQU9aLFNBQVosRUFBd0I7QUFDdkJZLGVBQVcsa0JBQWtCWixTQUE3QjtBQUNBOztBQUVELE9BQUssU0FBUzNELFFBQWQsRUFBeUI7QUFDeEJ1RSxlQUFXLE1BQU0sS0FBS3hZLEtBQUwsQ0FBV21QLFdBQTVCO0FBQ0E7O0FBRUQsVUFDQztBQUFBO0FBQUEsTUFBSyxXQUFZcUosT0FBakI7QUFDRzFKO0FBREgsSUFERDtBQUtBOzs7O0VBMUN1Q0YsZ0I7O2tCQUFwQmlMLFc7Ozs7Ozs7Ozs7Ozs7UUNLTEUsVyxHQUFBQSxXOztBQVBoQjs7QUFDQTs7QUFDQTs7Ozs7O0FBRUE7OztBQUdPLFNBQVNBLFdBQVQsQ0FBc0JDLFdBQXRCLEVBQW1DOVEsT0FBbkMsRUFBNkM7QUFDbkQsS0FBTStRLFlBQVlDLFNBQVNDLGNBQVQsQ0FBeUJILFdBQXpCLENBQWxCOztBQUVBO0FBQ0EsS0FBSy9ZLEVBQUU0UixNQUFGLENBQVVvSCxTQUFWLENBQUwsRUFBNkI7QUFDNUI7QUFDQTs7QUFFRCxLQUFJRyxpQkFBT0MsR0FBUCxDQUFXQyxpQkFBWCxFQUFvQixRQUFwQixDQUFKLEVBQW1DO0FBQ2xDO0FBQ0EsTUFBTUMsT0FBTyx3QkFBWU4sU0FBWixDQUFiO0FBQ0FNLE9BQUtDLE1BQUwsQ0FDQ3RSLE9BREQ7QUFHQSxFQU5ELE1BTU87QUFDTix3QkFDQ0EsT0FERCxFQUVDK1EsU0FGRDtBQUlBO0FBQ0QsQzs7Ozs7OzsrQ0MzQkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RCwwQkFBMEIsb0NBQW9DO0FBQzlELDBCQUEwQixvQ0FBb0M7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELHNDQUFzQztBQUN0QyxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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RUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBLE9BQU87QUFDUCxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlDQUF5QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFlBQVk7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQzFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztB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QUFDLHFCQUFEO0FBQUE7QUFDQyxlQUFVLElBRFg7QUFFQyxpQkFBVSxRQUZYO0FBR0Msa0JBQWEsS0FBS3BPLFVBSG5CO0FBSUMsaUJBQVUsTUFKWDtBQUtDLG1CQUFZO0FBTGI7QUFRQyxtQ0FBQyxlQUFEO0FBQ0MsVUFBRywyQ0FESixDQUNnRDtBQURoRCxRQUVDLE9BQVEsc0JBQVcsb0JBQVgsQ0FGVDtBQUdDLFlBQUs7QUFITixPQVJEO0FBY0M7QUFBQTtBQUFBLFFBQUcsV0FBVSxpQkFBYjtBQUFpQ2pKO0FBQWpDO0FBZEQsS0FGRDtBQW9CQztBQUFDLHFCQUFEO0FBQUE7QUFDQyxtQkFBWTtBQURiO0FBSUMsbUNBQUMsZUFBRDtBQUNDLGFBQVEsc0JBQVcsUUFBWCxDQURUO0FBRUMsa0JBQWEsS0FBS2lKLFVBRm5CO0FBR0MsbUJBQVk7QUFIYixPQUpEO0FBVUM7QUFBQTtBQUFBO0FBQ0Msa0JBQVUscUVBRFg7QUFFQyxnQkFBVSxLQUFLdWI7QUFGaEI7QUFLQztBQUFBO0FBQUEsU0FBTSxXQUFVLGtCQUFoQjtBQUNDLDRDQUFHLFdBQVUsZ0JBQWIsRUFBOEIsZUFBWSxNQUExQyxHQUREO0FBRUcsNkJBQVcsUUFBWDtBQUZILE9BTEQ7QUFVQywyQ0FBRyxXQUFVLDZCQUFiLEVBQTJDLGVBQVksTUFBdkQ7QUFWRDtBQVZEO0FBcEJELElBREQ7QUFpREE7Ozs7RUF2S2lEdGtCLGdCOztrQkFBOUJzZSxxQiIsImZpbGUiOiJzZXR0aW5ncy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDgwNyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYjk0NWM3YzRhNmI2NmM5OTA1MzMiLCJtb2R1bGUuZXhwb3J0cyA9IFJlYWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiUmVhY3RcIlxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiaW1wb3J0IGkxOG4gZnJvbSAnaTE4bi13cC1wbHVnaW4nO1xuLyoqXG4gKiBSZXR1cm5zIHVuaXF1ZSA0IGRpZ2l0IG51bWJlclxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kTnVtYmVyKCkge1xuXHQvL3JldHVybiBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogOTk5OSApO1xuXHR2YXIgbWluID0gTWF0aC5jZWlsKCAxMDAwICk7XG5cdHZhciBtYXggPSBNYXRoLmZsb29yKCA5OTk5ICk7XG5cdHJldHVybiBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogKCBtYXggLSBtaW4gKSArIG1pbiApO1xufVxuXG4vKipcbiAqIFJldHVybnMgd3JhcHBlciB1bmlxIElEXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlV3JhcHBlcklkKCkge1xuXHRyZXR1cm4gJ3dyYXBwZXItJyArIHJhbmROdW1iZXIoKSArICctJyArIHJhbmROdW1iZXIoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdyYXBwZXIgb2JqZWN0IGJ5IHdyYXBwZXIgSURcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gd3JhcHBlcklEIElEIG9mIHRoZSB3cmFwcGVyXG4gKiBAcGFyYW0ge2FycmF5fSB3cmFwcGVycyBjdXJyZW50IHdyYXBwZXJzXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdyYXBwZXIoIHdyYXBwZXJJRCwgd3JhcHBlcnMgKSB7XG5cdGxldCB3cmFwcGVyT2JqZWN0O1xuXG5cdHdyYXBwZXJzLm1hcCggd3JhcHBlciA9PiB7XG5cdFx0aWYgKCB3cmFwcGVyLndyYXBwZXJfaWQgPT09IHdyYXBwZXJJRCApIHtcblx0XHRcdHdyYXBwZXJPYmplY3QgPSB3cmFwcGVyO1xuXHRcdH1cblx0fSApO1xuXG5cdHJldHVybiB3cmFwcGVyT2JqZWN0O1xufVxuXG4vKipcbiAqIFJldHVybiBwYXNzZWQgZGVmYXVsdCB2YWx1ZSBvciBlbXB0eSBpZiBpdCdzIEJhc2ljIHRoZW1lXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGdldERlZmF1bHRWYWx1ZSBEZWZhdWx0IHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gZm9ybURlc2lnbiBQcm9wZXJ0eVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFZhbHVlKCBwcm9wcywgZ2V0RGVmYXVsdFZhbHVlICkge1xuXHRyZXR1cm4gZ2V0VGhlbWVOYW1lKCBwcm9wcyApICE9PSAnYmFzaWMnID8gZ2V0RGVmYXVsdFZhbHVlIDogJyc7XG59XG5cbi8qKlxuICogR2V0IHByZWZpeCBmb3IgcHJvcGVydGllcyBpZiBpdCdzIEJhc2ljIHRoZW1lXG4gKlxuICogQHBhcmFtIHt0eXBlfSBmb3JtRGVzaWduIFByb3BlcnR5XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUaGVtZVByZWZpeCggcHJvcHMgKSB7XG5cdHJldHVybiBnZXRUaGVtZU5hbWUoIHByb3BzICkgPT09ICdiYXNpYycgPyAnYmFzaWMtJyA6ICcnO1xufVxuXG4vKipcbiAqIEdldCBkZXNpZ24gdGhlbWUgbmFtZVxuICpcbiAqIEBwYXJhbSB7dHlwZX0gcHJvcHNQcm9wZXJ0aWVzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFRoZW1lTmFtZSggcHJvcHMgKSB7XG5cdGlmICggXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHByb3BzLmZvcm1EZXNpZ24gKSB7XG5cdFx0cmV0dXJuIHByb3BzLmZvcm1EZXNpZ247XG5cdH1cblxuXHRpZiAoIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBwcm9wcy5zZXR0aW5ncyAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgcHJvcHMuc2V0dGluZ3NbJ2Zvcm1pbmF0b3ItcG9sbC1kZXNpZ24nXSApXG5cdFx0cmV0dXJuIHByb3BzLnNldHRpbmdzWydmb3JtaW5hdG9yLXBvbGwtZGVzaWduJ107XG5cblx0aWYgKCBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgcHJvcHMucXVpekRlc2lnbiApXG5cdFx0cmV0dXJuIHByb3BzLnF1aXpEZXNpZ247XG5cblx0cmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFJldHVybnMgYWxsIGZpZWxkIHR5cGVzIGRpc2FibGVkIGluc2lkZSBHcm91cCBGaWVsZHNcbiAqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc3RyaWN0ZWRHcm91cEZpZWxkcygpIHtcblx0cmV0dXJuIFsgJ3BhZ2UtYnJlYWsnLCAncGF5cGFsJywgJ3N0cmlwZScsICdzaWduYXR1cmUnLCAnY2FwdGNoYScsICdwb3N0ZGF0YScsICdncm91cCcgXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBmaWVsZCB0eXBlcyB0aGF0IHNob3VsZCBvbmx5IG9jY3VweSBhIHNpbmdsZSByb3cuIDsoXG4gKiBGaWVsZCBjYW4gb25seSBiZSBhZGRlZCBmb3IgbmV3L3VucmVsZWFzZWQgZmllbGQgdHlwZXMuXG4gKlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb25lckZpZWxkcygpIHtcblx0cmV0dXJuIFsgJ3BkZi1wYWdlLWJyZWFrJywgJ2FsbC1mb3JtLWRhdGEnIF07XG59XG5cbi8qKlxuICogUmV0dXJucyBhbGwgYmVoYXZpb3IgdHlwZXNcbiAqXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdWJtaXNzaW9uQmVoYXZpb3JzKCkge1xuXHRyZXR1cm4ge1xuXHRcdCdiZWhhdmlvdXItdGhhbmt5b3UnOiB0cmFuc2xhdGUoICdJbmxpbmUgTWVzc2FnZScgKSxcblx0XHQnYmVoYXZpb3VyLXJlZGlyZWN0JzogdHJhbnNsYXRlKCAnUmVkaXJlY3QgdXNlciB0byBhIFVSTCcgKSxcblx0XHQnYmVoYXZpb3VyLWhpZGUnOiB0cmFuc2xhdGUoICdIaWRlIGZvcm0nIClcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGNvdW50IG9mIGV4aXN0aW5nIGZpZWxkcyBieSB0eXBlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgdHlwZSBvZiBmaWVsZFxuICogQHBhcmFtIHthcnJheX0gd3JhcHBlcnMgY3VycmVudCB3cmFwcGVyc1xuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3VudEZpZWxkc0J5VHlwZSggdHlwZSwgd3JhcHBlcnMgKSB7XG5cdGxldCBjb3VudGVyID0gMDtcblxuXHR3cmFwcGVycy5tYXAoIHdyYXBwZXIgPT4ge1xuXHRcdHdyYXBwZXIuZmllbGRzLm1hcCggZmllbGQgPT4ge1xuXHRcdFx0aWYgKCBmaWVsZC50eXBlID09PSB0eXBlICkge1xuXHRcdFx0XHRjb3VudGVyKys7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cblx0cmV0dXJuIGNvdW50ZXI7XG59XG5cbi8qKlxuICogUmV0dXJucyBtYXggSUQgbnVtYmVyIGJ5IHR5cGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSB0eXBlIG9mIGZpZWxkXG4gKiBAcGFyYW0ge2FycmF5fSB3cmFwcGVycyBjdXJyZW50IHdyYXBwZXJzXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1heElEQnlUeXBlKCB0eXBlLCB3cmFwcGVycyApIHtcblx0Y29uc3QgZmllbGRJRHMgPSBbXTtcblxuXHR3cmFwcGVycy5tYXAoIHdyYXBwZXIgPT4ge1xuXHRcdHdyYXBwZXIuZmllbGRzLm1hcCggZmllbGQgPT4ge1xuXHRcdFx0aWYgKCBmaWVsZC50eXBlID09PSB0eXBlICkge1xuXHRcdFx0XHRjb25zdCBmaWVsZElkID0gZmllbGQuZWxlbWVudF9pZDtcblx0XHRcdFx0Y29uc3QgZmllbGRJZEFycmF5ID0gZmllbGRJZC5zcGxpdCggJy0nICk7XG5cdFx0XHRcdHN3aXRjaCAoIGZpZWxkLnR5cGUgKSB7XG5cdFx0XHRcdFx0Y2FzZSAncGFnZS1icmVhayc6XG5cdFx0XHRcdFx0Y2FzZSAncmljaC10ZXh0Jzpcblx0XHRcdFx0XHRcdGZpZWxkSURzLnB1c2goIHBhcnNlSW50KCBmaWVsZElkQXJyYXlbIDIgXSApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdhbGwtZm9ybS1kYXRhJzpcblx0XHRcdFx0XHRjYXNlICdwZGYtcGFnZS1icmVhayc6XG5cdFx0XHRcdFx0XHRmaWVsZElEcy5wdXNoKCBwYXJzZUludCggZmllbGRJZEFycmF5WyAzIF0gKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGZpZWxkSURzLnB1c2goIHBhcnNlSW50KCBmaWVsZElkQXJyYXlbIDEgXSApIClcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cblx0bGV0IG1heFZhbHVlID0gMDtcblxuXHRpZiAoICEgXy5pc0VtcHR5KCBmaWVsZElEcyApICkge1xuXHRcdG1heFZhbHVlID0gXy5tYXgoIGZpZWxkSURzICk7XG5cdH1cblxuXHRyZXR1cm4gcGFyc2VJbnQoIG1heFZhbHVlICkgKyAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF4SUQoIHR5cGUsIHZhbHVlcyApIHtcblx0Y29uc3QgaWRzID0gW107XG5cblx0Xy5tYXAoIHZhbHVlcywgdmFsdWUgPT4ge1xuXHRcdGNvbnN0IGZpZWxkSWQgPSB2YWx1ZS5lbGVtZW50X2lkO1xuXHRcdGNvbnN0IGZpZWxkSWRBcnJheSA9IGZpZWxkSWQuc3BsaXQoICctJyApO1xuXG5cdFx0aWRzLnB1c2goIHBhcnNlSW50KCBmaWVsZElkQXJyYXlbIDEgXSApICk7XG5cdH0gKTtcblxuXHRsZXQgbWF4VmFsdWUgPSAwO1xuXG5cdGlmICggISBfLmlzRW1wdHkoIGlkcyApICkge1xuXHRcdG1heFZhbHVlID0gXy5tYXgoIGlkcyApO1xuXHR9XG5cblx0cmV0dXJuIHBhcnNlSW50KCBtYXhWYWx1ZSApICsgMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIExhYmVsIGNvbnZlcnRlZCB0byB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBlbnRlcmVkIGxhYmVsXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVmFsdWUoIHZhbHVlICkge1xuXHR2YWx1ZSA9IHZhbHVlLnRyaW0oKS5yZXBsYWNlKCAvXFxzK3xcXC8vZywgJy0nICk7XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIGl0J3MgR2xvYmFsIEFwcGVhcmFuY2UgUHJlc2V0XG4gKlxuICogQHBhcmFtIHthcnJheX0gd3JhcHBlcnMgY3VycmVudCB3cmFwcGVyc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNHbG9iYWxQcmVzZXQoIHdyYXBwZXJzICkge1xuXHRyZXR1cm4gbnVsbCA9PT0gd3JhcHBlcnM7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGZpZWxkIGV4aXN0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgdHlwZSBvZiBmaWVsZFxuICogQHBhcmFtIHthcnJheX0gd3JhcHBlcnMgY3VycmVudCB3cmFwcGVyc1xuICpcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gaGFzRmllbGRUeXBlKCB0eXBlLCB3cmFwcGVycyApIHtcblx0bGV0IGNvdW50ZXIgPSAwO1xuXG5cdGlmICggaXNHbG9iYWxQcmVzZXQoIHdyYXBwZXJzICkgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHR3cmFwcGVycy5tYXAoIHdyYXBwZXIgPT4ge1xuXHRcdHdyYXBwZXIuZmllbGRzLm1hcCggZmllbGQgPT4ge1xuXHRcdFx0aWYgKCBmaWVsZC50eXBlID09PSB0eXBlICkge1xuXHRcdFx0XHRjb3VudGVyKys7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cblx0cmV0dXJuIGNvdW50ZXIgPiAwO1xufVxuXG4vKipcbiAqIFJldHVybnMgYXJyYXkgb2YgZmllbGRzIGJ5IHR5cGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSB0eXBlIG9mIGZpZWxkXG4gKiBAcGFyYW0ge2FycmF5fSB3cmFwcGVycyBjdXJyZW50IHdyYXBwZXJzXG4gKlxuICogQHJldHVybiB7YXJyYXl9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRzQnlUeXBlKCB0eXBlLCB3cmFwcGVycyApIHtcblx0Y29uc3QgZmllbGRzID0gW107XG5cblx0d3JhcHBlcnMubWFwKCB3cmFwcGVyID0+IHtcblx0XHR3cmFwcGVyLmZpZWxkcy5tYXAoIGZpZWxkID0+IHtcblx0XHRcdGlmICggZmllbGQudHlwZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0ZmllbGRzLnB1c2goIGZpZWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cblx0cmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIGZpZWxkcyBieSB0eXBlIG1hcHBlZCBmb3Igc2VsZWN0IGZpZWxkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgdHlwZSBvZiBmaWVsZFxuICogQHBhcmFtIHthcnJheX0gd3JhcHBlcnMgY3VycmVudCB3cmFwcGVyc1xuICpcbiAqIEByZXR1cm4ge2FycmF5fVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEZpZWxkc0J5VHlwZSggdHlwZSwgd3JhcHBlcnMgKSB7XG5cdGNvbnN0IGZpZWxkcyA9IFtdO1xuXHRjb25zdCBmaWVsZHNCeVR5cGUgPSBnZXRGaWVsZHNCeVR5cGUoIHR5cGUsIHdyYXBwZXJzICk7XG5cdGZpZWxkc0J5VHlwZS5tYXAoIGZpZWxkID0+IHtcblx0XHRsZXQgbGFiZWwgPSBmaWVsZC5maWVsZF9sYWJlbDtcblxuXHRcdGlmICggdHlwZSA9PT0gJ2FkZHJlc3MnICkge1xuXHRcdFx0bGFiZWwgPSBmaWVsZC5lbGVtZW50X2lkO1xuXHRcdH1cblxuXHRcdGZpZWxkcy5wdXNoKCB7XG5cdFx0XHR2YWx1ZTogZmllbGQuZWxlbWVudF9pZCxcblx0XHRcdGxhYmVsOiBsYWJlbCxcblx0XHRcdGVsZW1lbnRfaWQ6IGZpZWxkLmVsZW1lbnRfaWQsXG5cdFx0fSApO1xuXHR9ICk7XG5cblx0cmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGZpZWxkIGxhYmVsIGJ5IElEXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIGZpZWxkIElEXG4gKiBAcGFyYW0ge2FycmF5fSB3cmFwcGVycyBjdXJyZW50IHdyYXBwZXJzXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkTGFiZWwoIGlkLCB3cmFwcGVycyApIHtcblx0bGV0IGxhYmVsID0gJyc7XG5cdHdyYXBwZXJzLm1hcCggd3JhcHBlciA9PiB7XG5cdFx0d3JhcHBlci5maWVsZHMubWFwKCBmaWVsZCA9PiB7XG5cdFx0XHRpZiAoIGZpZWxkLmVsZW1lbnRfaWQgPT09IGlkICkge1xuXHRcdFx0XHRsYWJlbCA9IGZpZWxkLmZpZWxkX2xhYmVsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSApO1xuXG5cdHJldHVybiBsYWJlbDtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIGZpZWxkIGV4aXN0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIGZpZWxkIElEXG4gKiBAcGFyYW0ge2FycmF5fSB3cmFwcGVycyBjdXJyZW50IHdyYXBwZXJzXG4gKlxuICogQHJldHVybiB7Ym9vbH1cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWVsZEV4aXN0KCBpZCwgd3JhcHBlcnMgKSB7XG5cdGxldCBleGlzdCA9IDA7XG5cblx0d3JhcHBlcnMubWFwKCB3cmFwcGVyID0+IHtcblx0XHR3cmFwcGVyLmZpZWxkcy5tYXAoIGZpZWxkID0+IHtcblx0XHRcdGlmICggZmllbGQuZWxlbWVudF9pZCA9PT0gaWQgKSB7XG5cdFx0XHRcdGV4aXN0Kys7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cblx0cmV0dXJuIGV4aXN0ID4gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGZpZWxkIG9iamVjdCB3aXRoIGRlZmF1bHRzIGZyb20gc2x1Z1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBmaWVsZCBmaWVsZFxuICogQHBhcmFtIHtzdHJpbmd9IHdyYXBwZXJJRCB3cmFwcGVyIGlkXG4gKiBAcGFyYW0ge251bWJlcn0gY29scyBjb2x1bW5zXG4gKiBAcGFyYW0ge2FycmF5fSB3cmFwcGVycyB3cmFwcGVyc1xuICogQHBhcmFtIHthcnJheX0gdGVtcE5ld0ZpZWxkcyBOZXcgU2libGluZ3MgRmllbGRzIHRoYXQgYXJlbid0IGluY2x1ZGVkIGluIHdyYXBwZXJzIHlldFxuICpcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEZpZWxkT2JqZWN0KCBmaWVsZCwgd3JhcHBlcklELCBjb2xzLCB3cmFwcGVycywgdGVtcE5ld0ZpZWxkcyApIHtcblx0dGVtcE5ld0ZpZWxkcyA9IHRlbXBOZXdGaWVsZHMgfHwgW107XG5cdGNvbnN0IHdyYXBzID0gWyAuLi53cmFwcGVycywgeyBmaWVsZHM6IHRlbXBOZXdGaWVsZHMgfSBdO1xuXHRjb25zdCBmaWVsZE51bWJlciA9IGdldE1heElEQnlUeXBlKCBmaWVsZC50eXBlLCB3cmFwcyApO1xuXG5cdHJldHVybiBfLmV4dGVuZCggZmllbGQsIHtcblx0XHRlbGVtZW50X2lkOiBmaWVsZC50eXBlICsgJy0nICsgZmllbGROdW1iZXIsXG5cdFx0Zm9ybUlEOiB3cmFwcGVySUQsXG5cdFx0Y29sczogY29scyxcblx0fSApO1xufVxuXG4vKipcbiAqIFJldHVybnMgZmllbGQgb2JqZWN0IHdpdGggZGVmYXVsdHMgZnJvbSBzbHVnXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNsdWcgZmllbGQgc2x1Z1xuICogQHBhcmFtIHthcnJheX0gd3JhcHBlcnMgd3JhcHBlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSB3cmFwZXByIElEXG4gKlxuICogQHJldHVybiB7b2JqZWN0fVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRmllbGRPYmplY3RGcm9tU2x1Zyggc2x1Zywgd3JhcHBlcnMsIHdyYXBwZXJJRCApIHtcblx0Y29uc3QgZmllbGQgPSBmb3JtaW5hdG9yRGF0YS5maWVsZHMuZmluZCggZmllbGREYXRhID0+IHtcblx0XHRyZXR1cm4gZmllbGREYXRhLnNsdWcgPT09IHNsdWc7XG5cdH0gKTtcblxuXHRjb25zdCBmaWVsZE51bWJlciA9IGdldE1heElEQnlUeXBlKCBmaWVsZC50eXBlLCB3cmFwcGVycyApO1xuXG5cdGNvbnN0IHByb3BzID0ge1xuXHRcdGVsZW1lbnRfaWQ6IGZpZWxkLnR5cGUgKyAnLScgKyBmaWVsZE51bWJlcixcblx0XHR0eXBlOiBmaWVsZC50eXBlLFxuXHRcdG9wdGlvbnM6IGZpZWxkLm9wdGlvbnMsXG5cdFx0Y29sczogMTIsXG5cdFx0Y29uZGl0aW9uczoge30sXG5cdFx0d3JhcHBlcl9pZDogd3JhcHBlcklELFxuXHR9O1xuXG5cdGlmICggIF8uY29udGFpbnMoIFsgJ2NhbGN1bGF0aW9uJywgJ251bWJlcicsICdzbGlkZXInLCAncmFkaW8nLCAnY3VycmVuY3knLCAnc2VsZWN0JywgJ2NoZWNrYm94JyBdLCBmaWVsZC50eXBlICkgKSB7XG5cdFx0cHJvcHNbJ2hpZGRlbl9iZWhhdmlvciddID0gJ3plcm8nO1xuXHR9XG5cblx0cmV0dXJuIF8uZXh0ZW5kKFxuXHRcdHByb3BzLFxuXHRcdEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBmaWVsZC5kZWZhdWx0cyApIClcblx0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGZpZWxkIHR5cGUgYnkgZmllbGQgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGZpZWxkIGZpZWxkXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkVHlwZSggZmllbGQgKSB7XG5cdGNvbnN0IHsgdHlwZSB9ID0gZmllbGQ7XG5cblx0cmV0dXJuIHR5cGU7XG59XG5cbi8qKlxuICogUmV0dXJucyBmb3JtaW5hdG9yRGF0YS5maWVsZHMoUEhQKSBmcm9tIGZpZWxkIG9iamVjdCBmcm9tIGJ1aWxkZXJcbiAqXG4gKiBDb21wYXJpbmcgYHR5cGVgXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGZpZWxkIGZpZWxkXG4gKlxuICogQHJldHVybiB7b2JqZWN0fVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZvcm1pbmF0b3JGaWVsZCggZmllbGQgKSB7XG5cdHJldHVybiBmb3JtaW5hdG9yRGF0YS5maWVsZHMuZmluZCggZm9ybWluYXRvckZpZWxkID0+IGZvcm1pbmF0b3JGaWVsZC50eXBlID09PSBmaWVsZC50eXBlICk7XG59XG5cbi8qKlxuICogSW5zZXJ0IGl0ZW0gaW50byBhcnJheSBpbiBzcGVjaWZpYyBwb3NpdGlvblxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IGFycmF5IGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gcG9zaXRpb25cbiAqIEBwYXJhbSB7YW55fSByZXBsYWNlbWVudCByZXBsYWNlbWVudFxuICpcbiAqIEByZXR1cm4ge2FycmF5fSBhcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0SW5Qb3NpdGlvbiggYXJyYXksIHBvc2l0aW9uLCByZXBsYWNlbWVudCApIHtcblx0cmV0dXJuIFsgLi4uYXJyYXkuc2xpY2UoIDAsIHBvc2l0aW9uICksIHJlcGxhY2VtZW50LCAuLi5hcnJheS5zbGljZSggcG9zaXRpb24gKSBdO1xufVxuXG4vKipcbiAqIFJlcGxhY2UgaXRlbSBpbiBhcnJheSBpbiBzcGVjaWZpYyBwb3NpdGlvblxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IGFycmF5IGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gcG9zaXRpb25cbiAqIEBwYXJhbSB7YW55fSByZXBsYWNlbWVudCByZXBsYWNlbWVudFxuICpcbiAqIEByZXR1cm4ge2FycmF5fSBhcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZUluUG9zaXRpb24oIGFycmF5LCBwb3NpdGlvbiwgcmVwbGFjZW1lbnQgKSB7XG5cdHJldHVybiBbIC4uLmFycmF5LnNsaWNlKCAwLCBwb3NpdGlvbiApLCByZXBsYWNlbWVudCwgLi4uYXJyYXkuc2xpY2UoIHBvc2l0aW9uICsgMSApIF07XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIHN0cmluZ1xuICpcbiAqIEBzZWUgaTE4bi50cmFuc2xhdGVcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRyYW5zbGF0ZWQgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUoKSB7XG5cdHJldHVybiBpMThuLnRyYW5zbGF0ZS5hcHBseSggbnVsbCwgYXJndW1lbnRzICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB2YXJpYW50cyBmb3Igc2VsZWN0ZWQgZm9udFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBmb250XG4gKiBAcGFyYW0ge2FycmF5fSBmb250cyBmb250c1xuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGb250VmFyaWFudHMoIHZhbHVlLCBmb250cyApIHtcblx0Y29uc3QgZm9udE9iamVjdCA9IF8uZmlsdGVyKCBmb250cywgZnVuY3Rpb24oIGZvbnQgKSB7XG5cdFx0cmV0dXJuIGZvbnQuZmFtaWx5ID09PSB2YWx1ZTtcblx0fSApO1xuXG5cdGlmICggISBfLmlzVW5kZWZpbmVkKCBmb250T2JqZWN0WyAwIF0gKSAmJiAhIF8uaXNVbmRlZmluZWQoIGZvbnRPYmplY3RbIDAgXS52YXJpYW50cyApICkge1xuXHRcdHJldHVybiBmb250T2JqZWN0WyAwIF0udmFyaWFudHM7XG5cdH1cblxuXHRyZXR1cm4gWyB0cmFuc2xhdGUoICdOb25lJyApIF07XG59XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gdWNmaXJzdCggdmFsdWUgKSB7XG5cdHJldHVybiB2YWx1ZS5jaGFyQXQoIDAgKS50b1VwcGVyQ2FzZSgpICsgdmFsdWUuc2xpY2UoIDEgKTtcbn1cblxuLyoqXG4gKiBHZXQgY29uZGl0aW9uIGxhYmVsXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbmRpdGlvbkxhYmVsKCBmaWVsZCwgY29uZGl0aW9uICkge1xuXHRjb25zdCB2YWx1ZSA9IGNvbmRpdGlvbi52YWx1ZTtcblx0bGV0IHZhbHVlTGFiZWw7XG5cblx0Ly8gSWYgb3B0aW9uIGZpZWxkIGFuZCBoYXZlIHZhbHVlcywgd2UgbmVlZCB0aGUgb3B0aW9uIHVwZGF0ZVZhbHVlXG5cdC8vIEVsc2UgcmV0dXJuIHRoZSBmaWVsZCB2YWx1ZVxuXHRpZiAoIGZpZWxkLmhhc09wdGlvbnMgJiYgZmllbGQudmFsdWVzLmxlbmd0aCA+IDAgKSB7XG5cdFx0bGV0IGxhYmVsO1xuXG5cdFx0Ly8gQ2hlY2sgaW4gdmFsdWVzXG5cdFx0bGFiZWwgPSBfLndoZXJlKCBmaWVsZC52YWx1ZXMsIHsgdmFsdWU6IHZhbHVlIH0gKVsgMCBdO1xuXG5cdFx0Ly8gSWYgbGFiZWwgaXMgbm90IHNldCwgY2hlY2sgaW4gbGFiZWxzXG5cdFx0aWYgKCAhIGxhYmVsICkge1xuXHRcdFx0bGFiZWwgPSBfLndoZXJlKCBmaWVsZC52YWx1ZXMsIHsgbGFiZWw6IHZhbHVlIH0gKVsgMCBdO1xuXHRcdH1cblxuXHRcdC8vIElmIGxhYmVsIGlzIHN0aWxsIG5vdCBmb3VuZCwgcmV0dXJuXG5cdFx0aWYgKCAhIGxhYmVsICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhbHVlTGFiZWwgPSBsYWJlbC5sYWJlbDtcblx0fSBlbHNlIGlmICggJ2RhdGUnID09PSBmaWVsZC5maWVsZF90eXBlICYmIFsgJ2lzX2JlZm9yZScsICdpc19hZnRlcicgXS5pbmNsdWRlcyggY29uZGl0aW9uLnJ1bGUgKSAgKSB7XG5cdFx0Ly8gR2V0IGZvcm1hdHRlZCBkYXRlIHN0cmluZ1xuXHRcdHZhbHVlTGFiZWwgPSBjb252ZXJ0VGltZXN0YW1wKCB2YWx1ZSApO1xuXHR9IGVsc2Uge1xuXHRcdHZhbHVlTGFiZWwgPSB2YWx1ZTtcblx0fVxuXG5cdC8vIElmIGxhYmVsIGVtcHR5LCByZXR1cm4gbnVsbFxuXHRpZiAoIF8uaXNFbXB0eSggdmFsdWVMYWJlbCApICkge1xuXHRcdHJldHVybiB0cmFuc2xhdGUoICdudWxsJyApO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlTGFiZWw7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGRhdGUgZnJvbSB0aW1lc3RhbXBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUaW1lc3RhbXAoIHZhbHVlICkge1xuXHRpZiAoICEgaXNOYU4oIE51bWJlciggdmFsdWUgKSApICkge1xuXHRcdC8vIENvbnZlcnQgdGltZXN0YW1wIHRvIERhdGUgb2JqZWN0XG5cdFx0Y29uc3QgZGF0ZSA9IG5ldyBEYXRlKCB2YWx1ZSoxICk7XG5cblx0XHQvLyBPcHRpb25zIGZvciBmb3JtYXR0aW5nIHRoZSBkYXRlXG5cdFx0Y29uc3Qgb3B0aW9ucyA9IHsgZGF5OiAnbnVtZXJpYycsIG1vbnRoOiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9O1xuXG5cdFx0Ly8gR2V0IHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmdcblx0XHR2YWx1ZSA9IGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCAnZW4tVVMnLCBvcHRpb25zICk7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qXG4gKiBSZXR1cm5zIGJ1aWxkZXIgZmllbGRzIGZyb20gd3JhcHBlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkcyggd3JhcHBlcnMsIGRpc2FibGVkRmllbGRzLCBleHRyYSwgaW5jbHVkZWRGaWVsZHMsIGV4Y2x1ZGVTdWJGaWVsZHMgKSB7XG5cdGxldCBmaWVsZHNBcnJheSA9IFtdO1xuXG5cdGlmICggXy5pc1VuZGVmaW5lZCggZGlzYWJsZWRGaWVsZHMgKSApIHtcblx0XHRkaXNhYmxlZEZpZWxkcyA9IFsgJ3BhZ2UtYnJlYWsnLCAncG9zdGRhdGEnLCAndG90YWwnLCAncHJvZHVjdCcsICdjYXB0Y2hhJyBdO1xuXHR9XG5cdGlmICggQXJyYXkuaXNBcnJheSggZGlzYWJsZWRGaWVsZHMgKSAmJiAhIGlzVHJ1ZSggZXhjbHVkZVN1YkZpZWxkcyApICkge1xuXHRcdGRpc2FibGVkRmllbGRzLnB1c2goICdncm91cCcgKTtcblx0fVxuXHRsZXQgbWFpbl9kYXRlX2ZpZWxkID0gZmFsc2U7XG5cblx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIGV4dHJhICkgJiYgISBfLmlzVW5kZWZpbmVkKCBleHRyYS5tYWluX2RhdGVfZmllbGQgKSAmJiBleHRyYS5tYWluX2RhdGVfZmllbGQgPT09IHRydWUgKSB7XG5cdFx0bWFpbl9kYXRlX2ZpZWxkID0gdHJ1ZTtcblx0fVxuXG5cblx0Ly8gTG9vcCBhbGwgd3JhcHBlcnMgd2UgaGF2ZVxuXHR3cmFwcGVycy5tYXAoIHdyYXBwZXIgPT4ge1xuXHRcdGNvbnN0IGZpZWxkcyA9IHdyYXBwZXIuZmllbGRzLFxuXHRcdFx0cGFyZW50R3JvdXAgPSB3cmFwcGVyLnBhcmVudF9ncm91cDtcblx0XHRmaWVsZHMubWFwKCBmaWVsZCA9PiB7XG5cdFx0XHQvLyBDaGVjayBpZiBmaWVsZCBpcyBpbmNsdWRlZFxuXHRcdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIGluY2x1ZGVkRmllbGRzICkgKSB7XG5cdFx0XHRcdGlmICggISBfLmNvbnRhaW5zKCBpbmNsdWRlZEZpZWxkcywgZmllbGQudHlwZSApICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggXy5jb250YWlucyggZGlzYWJsZWRGaWVsZHMsIGZpZWxkLnR5cGUgKSApIHtcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgZmllbGQgaXMgZGlzYWJsZWRcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgbGFiZWw7XG5cblx0XHRcdC8vIEdldCBmaWVsZCBsYWJlbFxuXHRcdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIGZpZWxkLmZpZWxkX2xhYmVsICkgJiYgISBfLmlzRW1wdHkoIGZpZWxkLmZpZWxkX2xhYmVsICkgKSB7XG5cdFx0XHRcdGxhYmVsID0gZmllbGQuZmllbGRfbGFiZWw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsYWJlbCA9IGZpZWxkLnR5cGU7XG5cdFx0XHRcdGxhYmVsID0gdWNmaXJzdCggbGFiZWwgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZmllbGQgaXMgbmFtZSwgZ2V0IGFsbCBleGlzdGluZyBzdWIgZmllbGRzXG5cdFx0XHRpZiAoIGZpZWxkLnR5cGUgPT09ICduYW1lJyAmJiAhIGlzVHJ1ZSggZXhjbHVkZVN1YkZpZWxkcyApICkge1xuXHRcdFx0XHRmaWVsZHNBcnJheSA9IGZpZWxkc0FycmF5LmNvbmNhdCggZ2V0TmFtZUZpZWxkcyggZmllbGQsIGxhYmVsLCBwYXJlbnRHcm91cCApICk7XG5cdFx0XHR9IGVsc2UgaWYgKCBmaWVsZC50eXBlID09PSAnYWRkcmVzcycgJiYgISBpc1RydWUoIGV4Y2x1ZGVTdWJGaWVsZHMgKSApIHtcblx0XHRcdFx0ZmllbGRzQXJyYXkgPSBmaWVsZHNBcnJheS5jb25jYXQoIGdldEFkZHJlc3NGaWVsZHMoIGZpZWxkLCBsYWJlbCwgcGFyZW50R3JvdXAgKSApO1xuXHRcdFx0fSBlbHNlIGlmICggZmllbGQudHlwZSA9PT0gJ3NsaWRlcicgJiYgZmllbGQuc2xpZGVyX3R5cGUgPT09ICdyYW5nZScgKSB7XG5cdFx0XHRcdGZpZWxkc0FycmF5ID0gZmllbGRzQXJyYXkuY29uY2F0KCBnZXRSYW5nZVNsaWRlckZpZWxkcyggZmllbGQsIGxhYmVsLCBwYXJlbnRHcm91cCApICk7XG5cdFx0XHR9IGVsc2UgaWYgKCBmaWVsZC50eXBlID09PSAndGltZScgJiYgISBpc1RydWUoIGV4Y2x1ZGVTdWJGaWVsZHMgKSApIHtcblx0XHRcdFx0ZmllbGRzQXJyYXkgPSBmaWVsZHNBcnJheS5jb25jYXQoIGdldFRpbWVGaWVsZHMoIGZpZWxkLCBsYWJlbCwgcGFyZW50R3JvdXAgKSApO1xuXHRcdFx0fWVsc2UgaWYgKCBmaWVsZC50eXBlID09PSAnZGF0ZScgJiYgZmllbGQuZmllbGRfdHlwZSAhPT0gJ3BpY2tlcicgJiYgbWFpbl9kYXRlX2ZpZWxkID09PSBmYWxzZSApIHtcblx0XHRcdFx0Ly9za2lwIG5vd1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZmllbGRzQXJyYXkucHVzaCgge1xuXHRcdFx0XHRcdGVsZW1lbnRfaWQ6IGZpZWxkLmVsZW1lbnRfaWQsXG5cdFx0XHRcdFx0cGFyZW50X2dyb3VwOiBwYXJlbnRHcm91cCxcblx0XHRcdFx0XHRyZXF1aXJlZDogZmllbGQucmVxdWlyZWQsXG5cdFx0XHRcdFx0ZmllbGRfdHlwZTogZmllbGQudHlwZSxcblx0XHRcdFx0XHRmaWVsZF9zbHVnOiBmaWVsZC50eXBlLFxuXHRcdFx0XHRcdGxhYmVsOiBsYWJlbCxcblx0XHRcdFx0XHR2YWx1ZXM6IGdldEZpZWxkVmFsdWVzKCBmaWVsZCApLFxuXHRcdFx0XHRcdGhhc09wdGlvbnM6IGZpZWxkSGFzT3B0aW9ucyggZmllbGQgKSxcblx0XHRcdFx0XHRoYXNDYWxjczogZmllbGRIYXNDYWxjcyggZmllbGQgKSxcblx0XHRcdFx0XHRmb3JtdWxhOiBmaWVsZEZvcm11bGEoIGZpZWxkICksXG5cdFx0XHRcdFx0aXNOdW1iZXI6IGZpZWxkSGFzTnVtYmVyKCBmaWVsZCApLFxuXHRcdFx0XHRcdGZpZWxkRGF0YTogZmllbGQsXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggZmllbGQudHlwZSA9PT0gJ2RhdGUnICYmIGZpZWxkLmZpZWxkX3R5cGUgIT09ICdwaWNrZXInICYmICEgaXNUcnVlKCBleGNsdWRlU3ViRmllbGRzICkgKSB7XG5cdFx0XHRcdGZpZWxkc0FycmF5ID0gZmllbGRzQXJyYXkuY29uY2F0KCBnZXREYXRlRmllbGRzKCBmaWVsZCwgbGFiZWwsIHBhcmVudEdyb3VwICkgKTtcblx0XHRcdH1cblxuXHRcdH0gKTtcblx0fSApO1xuXHRyZXR1cm4gZmllbGRzQXJyYXk7XG59XG4vKipcbiAqIEdldCBuYW1lX2ZpZWxkcyAoc3VwcG9ydCBkcm9wZG93biAmIGlucHV0IGRhdGUgZmllbGRzKVxuICogQHBhcmFtIHtvYmplY3R9IGZpZWxkIGZpZWxkIHRvIHBhcnNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGRMYWJlbCBwYXJlbnQgbGFiZWxcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRlRmllbGRzKCBmaWVsZCwgZmllbGRMYWJlbCwgcGFyZW50R3JvdXAgKSB7XG5cdGNvbnN0IGZpZWxkc0FycmF5ID0gW107XG5cblx0bGV0IGRheV9sYWJlbDtcblx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIGZpZWxkLmRheV9sYWJlbCApICYmICEgXy5pc0VtcHR5KCBmaWVsZC5kYXlfbGFiZWwgKSApIHtcblx0XHRkYXlfbGFiZWwgPSBmaWVsZExhYmVsICsgJyAtICcgKyBmaWVsZC5kYXlfbGFiZWw7XG5cdH0gZWxzZSB7XG5cdFx0ZGF5X2xhYmVsID0gZmllbGRMYWJlbCArICcgLSAnICsgdHJhbnNsYXRlKCAnRGF5JyApO1xuXHR9XG5cblx0bGV0IG1vbnRoX2xhYmVsO1xuXHRpZiAoICEgXy5pc1VuZGVmaW5lZCggZmllbGQubW9udGhfbGFiZWwgKSAmJiAhIF8uaXNFbXB0eSggZmllbGQubW9udGhfbGFiZWwgKSApIHtcblx0XHRtb250aF9sYWJlbCA9IGZpZWxkTGFiZWwgKyAnIC0gJyArIGZpZWxkLm1vbnRoX2xhYmVsO1xuXHR9IGVsc2Uge1xuXHRcdG1vbnRoX2xhYmVsID0gZmllbGRMYWJlbCArICcgLSAnICsgdHJhbnNsYXRlKCAnTW9udGgnICk7XG5cdH1cblxuXHRsZXQgeWVhcl9sYWJlbDtcblx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIGZpZWxkLnllYXJfbGFiZWwgKSAmJiAhIF8uaXNFbXB0eSggZmllbGQueWVhcl9sYWJlbCApICkge1xuXHRcdHllYXJfbGFiZWwgPSBmaWVsZExhYmVsICsgJyAtICcgKyBmaWVsZC55ZWFyX2xhYmVsO1xuXHR9IGVsc2Uge1xuXHRcdHllYXJfbGFiZWwgPSBmaWVsZExhYmVsICsgJyAtICcgKyB0cmFuc2xhdGUoICdZZWFyJyApO1xuXHR9XG5cdGlmKCBmaWVsZC5maWVsZF90eXBlID09PSAnaW5wdXQnICl7XG5cdFx0ZmllbGRzQXJyYXkucHVzaChcblx0XHRcdHtcblx0XHRcdFx0ZWxlbWVudF9pZDogZmllbGQuZWxlbWVudF9pZCArICctZGF5Jyxcblx0XHRcdFx0cGFyZW50X2dyb3VwOiBwYXJlbnRHcm91cCxcblx0XHRcdFx0cmVxdWlyZWQ6IGZpZWxkLnJlcXVpcmVkLFxuXHRcdFx0XHRmaWVsZF90eXBlOiBmaWVsZC50eXBlLFxuXHRcdFx0XHRmaWVsZF9zbHVnOiBmaWVsZC50eXBlICsgJy1kYXknLFxuXHRcdFx0XHRsYWJlbDogZGF5X2xhYmVsLFxuXHRcdFx0XHR2YWx1ZXM6IGZhbHNlLFxuXHRcdFx0XHRoYXNPcHRpb25zOiBmYWxzZSxcblx0XHRcdFx0aXNOdW1iZXI6IHRydWUsXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRlbGVtZW50X2lkOiBmaWVsZC5lbGVtZW50X2lkICsgJy1tb250aCcsXG5cdFx0XHRcdHBhcmVudF9ncm91cDogcGFyZW50R3JvdXAsXG5cdFx0XHRcdHJlcXVpcmVkOiBmaWVsZC5yZXF1aXJlZCxcblx0XHRcdFx0ZmllbGRfdHlwZTogZmllbGQudHlwZSxcblx0XHRcdFx0ZmllbGRfc2x1ZzogZmllbGQudHlwZSArICctbW9udGgnLFxuXHRcdFx0XHRsYWJlbDogbW9udGhfbGFiZWwsXG5cdFx0XHRcdHZhbHVlczogZmFsc2UsXG5cdFx0XHRcdGhhc09wdGlvbnM6IGZhbHNlLFxuXHRcdFx0XHRpc051bWJlcjogdHJ1ZSxcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdGVsZW1lbnRfaWQ6IGZpZWxkLmVsZW1lbnRfaWQgKyAnLXllYXInLFxuXHRcdFx0XHRwYXJlbnRfZ3JvdXA6IHBhcmVudEdyb3VwLFxuXHRcdFx0XHRyZXF1aXJlZDogZmllbGQucmVxdWlyZWQsXG5cdFx0XHRcdGZpZWxkX3R5cGU6IGZpZWxkLnR5cGUsXG5cdFx0XHRcdGZpZWxkX3NsdWc6IGZpZWxkLnR5cGUgKyAnLXllYXInLFxuXHRcdFx0XHRsYWJlbDogeWVhcl9sYWJlbCxcblx0XHRcdFx0dmFsdWVzOiBmYWxzZSxcblx0XHRcdFx0aGFzT3B0aW9uczogZmFsc2UsXG5cdFx0XHRcdGlzTnVtYmVyOiB0cnVlLFxuXHRcdFx0fVxuXHRcdCk7XG5cdH1lbHNle1xuXHRcdGZpZWxkc0FycmF5LnB1c2goXG5cdFx0XHR7XG5cdFx0XHRcdGVsZW1lbnRfaWQ6IGZpZWxkLmVsZW1lbnRfaWQgKyAnLWRheScsXG5cdFx0XHRcdHBhcmVudF9ncm91cDogcGFyZW50R3JvdXAsXG5cdFx0XHRcdHJlcXVpcmVkOiBmaWVsZC5yZXF1aXJlZCxcblx0XHRcdFx0ZmllbGRfdHlwZTogZmllbGQudHlwZSxcblx0XHRcdFx0ZmllbGRfc2x1ZzogZmllbGQudHlwZSArICctZGF5Jyxcblx0XHRcdFx0bGFiZWw6IGRheV9sYWJlbCxcblx0XHRcdFx0dmFsdWVzOiBnZXRGaWVsZFZhbHVlcyggZmllbGQgKSxcblx0XHRcdFx0aGFzT3B0aW9uczogZmllbGRIYXNPcHRpb25zKCBmaWVsZCApLFxuXHRcdFx0XHRpc051bWJlcjogZmllbGRIYXNOdW1iZXIoIGZpZWxkICksXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRlbGVtZW50X2lkOiBmaWVsZC5lbGVtZW50X2lkICsgJy1tb250aCcsXG5cdFx0XHRcdHBhcmVudF9ncm91cDogcGFyZW50R3JvdXAsXG5cdFx0XHRcdHJlcXVpcmVkOiBmaWVsZC5yZXF1aXJlZCxcblx0XHRcdFx0ZmllbGRfdHlwZTogZmllbGQudHlwZSxcblx0XHRcdFx0ZmllbGRfc2x1ZzogZmllbGQudHlwZSArICctbW9udGgnLFxuXHRcdFx0XHRsYWJlbDogbW9udGhfbGFiZWwsXG5cdFx0XHRcdHZhbHVlczogZ2V0RmllbGRWYWx1ZXMoIGZpZWxkICksXG5cdFx0XHRcdGhhc09wdGlvbnM6IGZpZWxkSGFzT3B0aW9ucyggZmllbGQgKSxcblx0XHRcdFx0aXNOdW1iZXI6IGZpZWxkSGFzTnVtYmVyKCBmaWVsZCApLFxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZWxlbWVudF9pZDogZmllbGQuZWxlbWVudF9pZCArICcteWVhcicsXG5cdFx0XHRcdHBhcmVudF9ncm91cDogcGFyZW50R3JvdXAsXG5cdFx0XHRcdHJlcXVpcmVkOiBmaWVsZC5yZXF1aXJlZCxcblx0XHRcdFx0ZmllbGRfdHlwZTogZmllbGQudHlwZSxcblx0XHRcdFx0ZmllbGRfc2x1ZzogZmllbGQudHlwZSArICcteWVhcicsXG5cdFx0XHRcdGxhYmVsOiB5ZWFyX2xhYmVsLFxuXHRcdFx0XHR2YWx1ZXM6IGdldEZpZWxkVmFsdWVzKCBmaWVsZCApLFxuXHRcdFx0XHRoYXNPcHRpb25zOiBmaWVsZEhhc09wdGlvbnMoIGZpZWxkICksXG5cdFx0XHRcdGlzTnVtYmVyOiBmaWVsZEhhc051bWJlciggZmllbGQgKSxcblx0XHRcdH1cblx0XHQpO1xuXHR9XG5cblx0cmV0dXJuIGZpZWxkc0FycmF5O1xufVxuXG4vKipcbiAqIEdldCBuYW1lX2ZpZWxkcyAoc3VwcG9ydCBtdWx0aXBsZSBuYW1lIGZpZWxkcylcbiAqIEBwYXJhbSB7b2JqZWN0fSBmaWVsZCBmaWVsZCB0byBwYXJzZVxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTGFiZWwgcGFyZW50IGxhYmVsXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmFtZUZpZWxkcyggZmllbGQsIGZpZWxkTGFiZWwsIHBhcmVudEdyb3VwICkge1xuXHRjb25zdCBmaWVsZHNBcnJheSA9IFtdO1xuXHQvL2hhbmRsZSBtdWx0aXBsZSBuYW1lXG5cdGlmICggZmllbGQubXVsdGlwbGVfbmFtZSA9PT0gJ3RydWUnIHx8IHRydWUgPT09IGZpZWxkLm11bHRpcGxlX25hbWUgKSB7XG5cdFx0W1xuXHRcdFx0e1xuXHRcdFx0XHRhdHRyOiAncHJlZml4Jyxcblx0XHRcdFx0bGFiZWw6ICdwcmVmaXhfbGFiZWwnLFxuXHRcdFx0XHRlbGVtZW50X3N1ZmZpeDogJ3ByZWZpeCcsXG5cdFx0XHRcdGhhc09wdGlvbnM6IHRydWUsXG5cdFx0XHRcdHZhbHVlczogW1xuXHRcdFx0XHRcdHsgbGFiZWw6ICdNci4nLCB2YWx1ZTogJ01yJyB9LFxuXHRcdFx0XHRcdHsgbGFiZWw6ICdNcnMuJywgdmFsdWU6ICdNcnMnIH0sXG5cdFx0XHRcdFx0eyBsYWJlbDogJ01zLicsIHZhbHVlOiAnTXMnIH0sXG5cdFx0XHRcdFx0eyBsYWJlbDogJ014LicsIHZhbHVlOiAnTXgnIH0sXG5cdFx0XHRcdFx0eyBsYWJlbDogJ01pc3MnLCB2YWx1ZTogJ01pc3MnIH0sXG5cdFx0XHRcdFx0eyBsYWJlbDogJ0RyLicsIHZhbHVlOiAnRHInIH0sXG5cdFx0XHRcdFx0eyBsYWJlbDogJ1Byb2YuJywgdmFsdWU6ICdQcm9mJyB9LFxuXHRcdFx0XHRdLFxuXHRcdFx0XHRpc051bWJlcjogZmFsc2UsXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRhdHRyOiAnZm5hbWUnLFxuXHRcdFx0XHRsYWJlbDogJ2ZuYW1lX2xhYmVsJyxcblx0XHRcdFx0ZWxlbWVudF9zdWZmaXg6ICdmaXJzdC1uYW1lJyxcblx0XHRcdFx0aGFzT3B0aW9uczogZmFsc2UsXG5cdFx0XHRcdHZhbHVlczogZmFsc2UsXG5cdFx0XHRcdGlzTnVtYmVyOiBmYWxzZSxcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdGF0dHI6ICdtbmFtZScsXG5cdFx0XHRcdGxhYmVsOiAnbW5hbWVfbGFiZWwnLFxuXHRcdFx0XHRlbGVtZW50X3N1ZmZpeDogJ21pZGRsZS1uYW1lJyxcblx0XHRcdFx0aGFzT3B0aW9uczogZmFsc2UsXG5cdFx0XHRcdHZhbHVlczogZmFsc2UsXG5cdFx0XHRcdGlzTnVtYmVyOiBmYWxzZSxcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdGF0dHI6ICdsbmFtZScsXG5cdFx0XHRcdGxhYmVsOiAnbG5hbWVfbGFiZWwnLFxuXHRcdFx0XHRlbGVtZW50X3N1ZmZpeDogJ2xhc3QtbmFtZScsXG5cdFx0XHRcdGhhc09wdGlvbnM6IGZhbHNlLFxuXHRcdFx0XHR2YWx1ZXM6IGZhbHNlLFxuXHRcdFx0XHRpc051bWJlcjogZmFsc2UsXG5cdFx0XHR9LFxuXHRcdF0ubWFwKCBhdHRyaWJ1dGUgPT4ge1xuXHRcdFx0aWYgKCBmaWVsZFsgYXR0cmlidXRlLmF0dHIgXSA9PT0gJ3RydWUnIHx8IGZpZWxkWyBhdHRyaWJ1dGUuYXR0ciBdID09PSB0cnVlICkge1xuXHRcdFx0XHRsZXQgbGFiZWw7XG5cdFx0XHRcdGlmICggISBfLmlzVW5kZWZpbmVkKCBmaWVsZFsgYXR0cmlidXRlLmxhYmVsIF0gKSAmJiAhIF8uaXNFbXB0eSggZmllbGRbIGF0dHJpYnV0ZS5sYWJlbCBdICkgKSB7XG5cdFx0XHRcdFx0bGFiZWwgPSBmaWVsZExhYmVsICsgJyAtICcgKyBmaWVsZFsgYXR0cmlidXRlLmxhYmVsIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGFiZWwgPSBmaWVsZExhYmVsICsgJyAtICc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmaWVsZHNBcnJheS5wdXNoKCB7XG5cdFx0XHRcdFx0ZWxlbWVudF9pZDogZmllbGQuZWxlbWVudF9pZCArICctJyArIGF0dHJpYnV0ZS5lbGVtZW50X3N1ZmZpeCxcblx0XHRcdFx0XHRwYXJlbnRfZ3JvdXA6IHBhcmVudEdyb3VwLFxuXHRcdFx0XHRcdHJlcXVpcmVkOiBmaWVsZC5yZXF1aXJlZCxcblx0XHRcdFx0XHRmaWVsZF90eXBlOiBmaWVsZC50eXBlLFxuXHRcdFx0XHRcdGZpZWxkX3NsdWc6IGZpZWxkLnR5cGUgKyAnLScgKyBhdHRyaWJ1dGUuZWxlbWVudF9zdWZmaXgsXG5cdFx0XHRcdFx0bGFiZWw6IGxhYmVsLFxuXHRcdFx0XHRcdHZhbHVlczogYXR0cmlidXRlLnZhbHVlcyxcblx0XHRcdFx0XHRoYXNPcHRpb25zOiBhdHRyaWJ1dGUuaGFzT3B0aW9ucyxcblx0XHRcdFx0XHRpc051bWJlcjogYXR0cmlidXRlLmlzTnVtYmVyLFxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9IGVsc2Uge1xuXHRcdGZpZWxkc0FycmF5LnB1c2goIHtcblx0XHRcdGVsZW1lbnRfaWQ6IGZpZWxkLmVsZW1lbnRfaWQsXG5cdFx0XHRwYXJlbnRfZ3JvdXA6IHBhcmVudEdyb3VwLFxuXHRcdFx0cmVxdWlyZWQ6IGZpZWxkLnJlcXVpcmVkLFxuXHRcdFx0ZmllbGRfdHlwZTogZmllbGQudHlwZSxcblx0XHRcdGZpZWxkX3NsdWc6IGZpZWxkLnR5cGUsXG5cdFx0XHRsYWJlbDogZmllbGRMYWJlbCxcblx0XHRcdHZhbHVlczogZ2V0RmllbGRWYWx1ZXMoIGZpZWxkICksXG5cdFx0XHRoYXNPcHRpb25zOiBmaWVsZEhhc09wdGlvbnMoIGZpZWxkICksXG5cdFx0XHRpc051bWJlcjogZmllbGRIYXNOdW1iZXIoIGZpZWxkICksXG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIGZpZWxkc0FycmF5O1xufVxuXG4vKipcbiAqIEdldCBSYW5nZSBTbGlkZXIgZmllbGRzXG4gKiBAcGFyYW0ge29iamVjdH0gZmllbGQgZmllbGQgdG8gcGFyc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZExhYmVsIHBhcmVudCBsYWJlbFxuICogQHJldHVybnMge0FycmF5fVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmdlU2xpZGVyRmllbGRzKCBmaWVsZCwgZmllbGRMYWJlbCwgcGFyZW50R3JvdXAgKSB7XG5cdGNvbnN0IGZpZWxkc0FycmF5ID0gW107XG5cdFx0W1xuXHRcdFx0e1xuXHRcdFx0XHRzdWZmaXg6ICdtaW4nLFxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0c3VmZml4OiAnbWF4Jyxcblx0XHRcdH0sXG5cdFx0XS5tYXAoIGF0dHJpYnV0ZSA9PiB7XG5cdFx0XHRmaWVsZHNBcnJheS5wdXNoKCB7XG5cdFx0XHRcdGVsZW1lbnRfaWQ6IGZpZWxkLmVsZW1lbnRfaWQgKyAnLScgKyBhdHRyaWJ1dGUuc3VmZml4LFxuXHRcdFx0XHRwYXJlbnRfZ3JvdXA6IHBhcmVudEdyb3VwLFxuXHRcdFx0XHRyZXF1aXJlZDogZmllbGQucmVxdWlyZWQsXG5cdFx0XHRcdGZpZWxkX3R5cGU6IGZpZWxkLnR5cGUsXG5cdFx0XHRcdGZpZWxkX3NsdWc6IGZpZWxkLnR5cGUgKyAnLScgKyBhdHRyaWJ1dGUuc3VmZml4LFxuXHRcdFx0XHRsYWJlbDogZmllbGRMYWJlbCArICcgLSAnICsgYXR0cmlidXRlLnN1ZmZpeCxcblx0XHRcdFx0aXNOdW1iZXI6IHRydWUsXG5cdFx0XHRcdGhhc0NhbGNzOiBmaWVsZEhhc0NhbGNzKCBmaWVsZCApLFxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gZmllbGRzQXJyYXk7XG59XG5cbi8qXG4gKiBSZXR1cm5zIGlmIGZpZWxkIGhhcyBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpZWxkSGFzTnVtYmVyKCBmaWVsZCApIHtcblx0aWYgKCBfLmNvbnRhaW5zKCBbICdjYWxjdWxhdGlvbicsICdudW1iZXInLCAnc2xpZGVyJywgJ3Bob25lJywgJ2N1cnJlbmN5JyBdLCBmaWVsZC50eXBlICkgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8qXG4gKiBSZXR1cm5zIGlmIGZpZWxkIGhhcyBjYWxjdWxhdGlvbnMgZW5hYmxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmllbGRIYXNDYWxjcyggZmllbGQgKSB7XG5cdGlmICggZmllbGQuY2FsY3VsYXRpb25zID09PSAndHJ1ZScgfHwgZmllbGQuY2FsY3VsYXRpb25zID09PSB0cnVlICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmllbGRGb3JtdWxhKCBmaWVsZCApIHtcblx0aWYgKCBmaWVsZC5mb3JtdWxhICkge1xuXHRcdHJldHVybiBmaWVsZC5mb3JtdWxhO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vKlxuICogUmV0dXJucyBpZiBmaWVsZCBoYXMgb3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmllbGRIYXNPcHRpb25zKCBmaWVsZCApIHtcblx0aWYgKCBmaWVsZC50eXBlID09PSAnc2VsZWN0JyB8fCBmaWVsZC50eXBlID09PSAnY2hlY2tib3gnIHx8IGZpZWxkLnR5cGUgPT09ICdyYWRpbycgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8qXG4gKiBSZXR1cm5zIGZpZWxkIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRWYWx1ZXMoIGZpZWxkICkge1xuXHRjb25zdCB0eXBlID0gZmllbGQudHlwZTtcblxuXHRpZiAoIHR5cGUgPT09ICdzZWxlY3QnIHx8IHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJyApIHtcblx0XHRyZXR1cm4gZmllbGQub3B0aW9ucztcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXQgYWRkcmVzc19maWVsZHMgKHN1cHBvcnQgbXVsdGkgc3ViIGZpZWxkcylcbiAqIEBwYXJhbSB7b2JqZWN0fSBmaWVsZCBmaWVsZFxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTGFiZWwgbGJlbFxuICogQHJldHVybnMge2FycmF5fVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFkZHJlc3NGaWVsZHMoIGZpZWxkLCBmaWVsZExhYmVsLCBwYXJlbnRHcm91cCApIHtcblx0Y29uc3QgZmllbGRzQXJyYXkgPSBbXTtcblxuXHRbXG5cdFx0e1xuXHRcdFx0YXR0cjogJ3N0cmVldF9hZGRyZXNzJyxcblx0XHRcdGxhYmVsOiAnc3RyZWV0X2FkZHJlc3NfbGFiZWwnLFxuXHRcdFx0ZWxlbWVudF9zdWZmaXg6ICdzdHJlZXRfYWRkcmVzcycsXG5cdFx0XHRoYXNPcHRpb25zOiBmYWxzZSxcblx0XHRcdHZhbHVlczogZmFsc2UsXG5cdFx0XHRpc051bWJlcjogZmFsc2UsXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRhdHRyOiAnYWRkcmVzc19saW5lJyxcblx0XHRcdGxhYmVsOiAnYWRkcmVzc19saW5lX2xhYmVsJyxcblx0XHRcdGVsZW1lbnRfc3VmZml4OiAnYWRkcmVzc19saW5lJyxcblx0XHRcdGhhc09wdGlvbnM6IGZhbHNlLFxuXHRcdFx0dmFsdWVzOiBmYWxzZSxcblx0XHRcdGlzTnVtYmVyOiBmYWxzZSxcblx0XHR9LFxuXHRcdHtcblx0XHRcdGF0dHI6ICdhZGRyZXNzX2NpdHknLFxuXHRcdFx0bGFiZWw6ICdhZGRyZXNzX2NpdHlfbGFiZWwnLFxuXHRcdFx0ZWxlbWVudF9zdWZmaXg6ICdjaXR5Jyxcblx0XHRcdGhhc09wdGlvbnM6IGZhbHNlLFxuXHRcdFx0dmFsdWVzOiBmYWxzZSxcblx0XHRcdGlzTnVtYmVyOiBmYWxzZSxcblx0XHR9LFxuXHRcdHtcblx0XHRcdGF0dHI6ICdhZGRyZXNzX3N0YXRlJyxcblx0XHRcdGxhYmVsOiAnYWRkcmVzc19zdGF0ZV9sYWJlbCcsXG5cdFx0XHRlbGVtZW50X3N1ZmZpeDogJ3N0YXRlJyxcblx0XHRcdGhhc09wdGlvbnM6IGZhbHNlLFxuXHRcdFx0dmFsdWVzOiBmYWxzZSxcblx0XHRcdGlzTnVtYmVyOiBmYWxzZSxcblx0XHR9LFxuXHRcdHtcblx0XHRcdGF0dHI6ICdhZGRyZXNzX3ppcCcsXG5cdFx0XHRsYWJlbDogJ2FkZHJlc3NfemlwX2xhYmVsJyxcblx0XHRcdGVsZW1lbnRfc3VmZml4OiAnemlwJyxcblx0XHRcdGhhc09wdGlvbnM6IGZhbHNlLFxuXHRcdFx0dmFsdWVzOiBmYWxzZSxcblx0XHRcdGlzTnVtYmVyOiBmYWxzZSxcblx0XHR9LFxuXHRcdHtcblx0XHRcdGF0dHI6ICdhZGRyZXNzX2NvdW50cnknLFxuXHRcdFx0bGFiZWw6ICdhZGRyZXNzX2NvdW50cnlfbGFiZWwnLFxuXHRcdFx0ZWxlbWVudF9zdWZmaXg6ICdjb3VudHJ5Jyxcblx0XHRcdGhhc09wdGlvbnM6IGZhbHNlLFxuXHRcdFx0dmFsdWVzOiBmYWxzZSxcblx0XHRcdGlzTnVtYmVyOiBmYWxzZSxcblx0XHR9LFxuXHRdLm1hcCggYXR0cmlidXRlID0+IHtcblx0XHRpZiAoIGlzVHJ1ZSggZmllbGRbIGF0dHJpYnV0ZS5hdHRyIF0gKSApIHtcblx0XHRcdGxldCBsYWJlbDtcblx0XHRcdGlmICggISBfLmlzVW5kZWZpbmVkKCBmaWVsZFsgYXR0cmlidXRlLmxhYmVsIF0gKSAmJiAhIF8uaXNFbXB0eSggZmllbGRbIGF0dHJpYnV0ZS5sYWJlbCBdICkgKSB7XG5cdFx0XHRcdGxhYmVsID0gZmllbGRMYWJlbCArICcgLSAnICsgZmllbGRbIGF0dHJpYnV0ZS5sYWJlbCBdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGFiZWwgPSBmaWVsZExhYmVsICsgJyAtICc7XG5cdFx0XHR9XG5cblx0XHRcdGZpZWxkc0FycmF5LnB1c2goIHtcblx0XHRcdFx0ZWxlbWVudF9pZDogZmllbGQuZWxlbWVudF9pZCArICctJyArIGF0dHJpYnV0ZS5lbGVtZW50X3N1ZmZpeCxcblx0XHRcdFx0cGFyZW50X2dyb3VwOiBwYXJlbnRHcm91cCxcblx0XHRcdFx0cmVxdWlyZWQ6IGZpZWxkLnJlcXVpcmVkLFxuXHRcdFx0XHRmaWVsZF90eXBlOiBmaWVsZC50eXBlLFxuXHRcdFx0XHRmaWVsZF9zbHVnOiBmaWVsZC50eXBlICsgJy0nICsgYXR0cmlidXRlLmVsZW1lbnRfc3VmZml4LFxuXHRcdFx0XHRsYWJlbDogbGFiZWwsXG5cdFx0XHRcdHZhbHVlczogYXR0cmlidXRlLnZhbHVlcyxcblx0XHRcdFx0aGFzT3B0aW9uczogYXR0cmlidXRlLmhhc09wdGlvbnMsXG5cdFx0XHRcdGlzTnVtYmVyOiBhdHRyaWJ1dGUuaXNOdW1iZXIsXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0cmV0dXJuIGZpZWxkc0FycmF5O1xufVxuXG4vKipcbiAqIEdldCB0aW1lX2ZpZWxkcyAoc3VwcG9ydCBtdWx0aSBzdWIgZmllbGRzKVxuICogQHBhcmFtIHtvYmplY3R9IGZpZWxkIGZpZWxkXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGRMYWJlbCBsYWJlbFxuICogQHJldHVybnMge2FycmF5fVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRpbWVGaWVsZHMoIGZpZWxkLCBmaWVsZExhYmVsLCBwYXJlbnRHcm91cCApIHtcblx0Y29uc3QgZmllbGRzQXJyYXkgPSBbXTtcblxuXHRsZXQgaGhfbGFiZWw7XG5cdGlmICggISBfLmlzVW5kZWZpbmVkKCBmaWVsZC5oaF9sYWJlbCApICYmICEgXy5pc0VtcHR5KCBmaWVsZC5oaF9sYWJlbCApICkge1xuXHRcdGhoX2xhYmVsID0gZmllbGRMYWJlbCArICcgLSAnICsgZmllbGQuaGhfbGFiZWw7XG5cdH0gZWxzZSB7XG5cdFx0aGhfbGFiZWwgPSBmaWVsZExhYmVsICsgJyAtICcgKyB0cmFuc2xhdGUoICdIb3VyJyApO1xuXHR9XG5cblx0bGV0IG1tX2xhYmVsO1xuXHRpZiAoICEgXy5pc1VuZGVmaW5lZCggZmllbGQubW1fbGFiZWwgKSAmJiAhIF8uaXNFbXB0eSggZmllbGQubW1fbGFiZWwgKSApIHtcblx0XHRtbV9sYWJlbCA9IGZpZWxkTGFiZWwgKyAnIC0gJyArIGZpZWxkLm1tX2xhYmVsO1xuXHR9IGVsc2Uge1xuXHRcdG1tX2xhYmVsID0gZmllbGRMYWJlbCArICcgLSAnICsgdHJhbnNsYXRlKCAnTWludXRlJyApO1xuXHR9XG5cblx0ZmllbGRzQXJyYXkucHVzaChcblx0XHR7XG5cdFx0XHRlbGVtZW50X2lkOiBmaWVsZC5lbGVtZW50X2lkICsgJy1ob3VycycsXG5cdFx0XHRwYXJlbnRfZ3JvdXA6IHBhcmVudEdyb3VwLFxuXHRcdFx0cmVxdWlyZWQ6IGZpZWxkLnJlcXVpcmVkLFxuXHRcdFx0ZmllbGRfdHlwZTogZmllbGQudHlwZSxcblx0XHRcdGZpZWxkX3NsdWc6IGZpZWxkLnR5cGUgKyAnLWhvdXJzJyxcblx0XHRcdGxhYmVsOiBoaF9sYWJlbCxcblx0XHRcdHZhbHVlczogZmFsc2UsXG5cdFx0XHRoYXNPcHRpb25zOiBmYWxzZSxcblx0XHRcdGlzTnVtYmVyOiB0cnVlLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0ZWxlbWVudF9pZDogZmllbGQuZWxlbWVudF9pZCArICctbWludXRlcycsXG5cdFx0XHRwYXJlbnRfZ3JvdXA6IHBhcmVudEdyb3VwLFxuXHRcdFx0cmVxdWlyZWQ6IGZpZWxkLnJlcXVpcmVkLFxuXHRcdFx0ZmllbGRfdHlwZTogZmllbGQudHlwZSxcblx0XHRcdGZpZWxkX3NsdWc6IGZpZWxkLnR5cGUgKyAnLW1pbnV0ZXMnLFxuXHRcdFx0bGFiZWw6IG1tX2xhYmVsLFxuXHRcdFx0dmFsdWVzOiBmYWxzZSxcblx0XHRcdGhhc09wdGlvbnM6IGZhbHNlLFxuXHRcdFx0aXNOdW1iZXI6IHRydWUsXG5cdFx0fVxuXHQpO1xuXG5cdGlmICggZmllbGQudGltZV90eXBlID09PSAndHdlbHZlJyApIHtcblx0XHRmaWVsZHNBcnJheS5wdXNoKCB7XG5cdFx0XHRlbGVtZW50X2lkOiBmaWVsZC5lbGVtZW50X2lkICsgJy1hbXBtJyxcblx0XHRcdHBhcmVudF9ncm91cDogcGFyZW50R3JvdXAsXG5cdFx0XHRyZXF1aXJlZDogZmllbGQucmVxdWlyZWQsXG5cdFx0XHRmaWVsZF90eXBlOiBmaWVsZC50eXBlLFxuXHRcdFx0ZmllbGRfc2x1ZzogZmllbGQudHlwZSArICctYW1wbScsXG5cdFx0XHRsYWJlbDogZmllbGRMYWJlbCArICctQU0vUE0nLFxuXHRcdFx0dmFsdWVzOiBbIHsgbGFiZWw6ICdBTScsIHZhbHVlOiAnYW0nIH0sIHsgbGFiZWw6ICdQTScsIHZhbHVlOiAncG0nIH0gXSxcblx0XHRcdGhhc09wdGlvbnM6IHRydWUsXG5cdFx0XHRpc051bWJlcjogZmFsc2UsXG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIGZpZWxkc0FycmF5O1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGRUeXBlIGZpZWxkVHlwZVxuICogQHJldHVybnMge2FycmF5fVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkQXV0b2ZpbGxQcm92aWRlcnMoIGZpZWxkVHlwZSApIHtcblx0bGV0IGF1dG9maWxsUHJvdmlkZXJzID0gW107XG5cdGxldCBmaWVsZFNldHRpbmdzID0gZm9ybWluYXRvckRhdGEuZmllbGRzLmZpbHRlciggZmllbGQgPT4ge1xuXHRcdHJldHVybiBmaWVsZC50eXBlID09PSBmaWVsZFR5cGU7XG5cdH0gKTtcblxuXHRpZiAoIGZpZWxkU2V0dGluZ3MubGVuZ3RoIDwgMSApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHRmaWVsZFNldHRpbmdzID0gZmllbGRTZXR0aW5nc1sgMCBdO1xuXHRpZiAoICEgXy5pc1VuZGVmaW5lZCggZmllbGRTZXR0aW5ncy5hdXRvZmlsbF9zZXR0aW5ncyApICkge1xuXHRcdGF1dG9maWxsUHJvdmlkZXJzID0gZmllbGRTZXR0aW5ncy5hdXRvZmlsbF9zZXR0aW5ncztcblx0fVxuXG5cdHJldHVybiBhdXRvZmlsbFByb3ZpZGVycztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGxhYmVsIGJ5IHJ1bGUgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZSBydWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSB0eXBlXG4gKiBAcGFyYW0ge21peH0gdHlwZSB2YWx1ZSAoIG9wdGlvbmFsIClcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UnVsZUxhYmVsKCBydWxlLCB0eXBlICwgdmFsdWUgKSB7XG5cdGxldCB2YWwgPSAoICFfLmlzVW5kZWZpbmVkKCB2YWx1ZSApICkgPyB2YWx1ZSA6ICcnO1xuXHRzd2l0Y2ggKCBydWxlICkge1xuXHRcdGNhc2UgJ2lzJzpcblx0XHRcdHJldHVybiB0cmFuc2xhdGUoICdpcycgKTtcblx0XHRjYXNlICdpc19ub3QnOlxuXHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ2lzIG5vdCcgKTtcblx0XHRjYXNlICdkYXlfaXMnOlxuXHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ2RheSBpcycgKTtcblx0XHRjYXNlICdkYXlfaXNfbm90Jzpcblx0XHRcdHJldHVybiB0cmFuc2xhdGUoICdkYXkgaXMgbm90JyApO1xuXHRcdGNhc2UgJ21vbnRoX2lzX25vdCc6XG5cdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnbW9udGggaXMgbm90JyApO1xuXHRcdGNhc2UgJ21vbnRoX2lzJzpcblx0XHRcdHJldHVybiB0cmFuc2xhdGUoICdtb250aCBpcycgKTtcblx0XHRjYXNlICdpc19iZWZvcmUnOlxuXHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ2lzIGJlZm9yZScgKTtcblx0XHRjYXNlICdpc19hZnRlcic6XG5cdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnaXMgYWZ0ZXInICk7XG5cdFx0Y2FzZSAnaXNfYmVmb3JlX25fb3JfbW9yZV9kYXlzJzpcblx0XHRcdHJldHVybiB0cmFuc2xhdGUoICdpcyBiZWZvcmUgJXMgb3IgbW9yZSBkYXlzIGZyb20gY3VycmVudCBkYXRlJyApLnJlcGxhY2UoICclcycsIHZhbCApO1xuXHRcdGNhc2UgJ2lzX2JlZm9yZV9sZXNzX3RoYW5fbl9kYXlzJzpcblx0XHRcdHJldHVybiB0cmFuc2xhdGUoICdpcyBiZWZvcmUgbGVzcyB0aGFuICVzIGRheXMgZnJvbSBjdXJyZW50IGRhdGUnICkucmVwbGFjZSggJyVzJywgdmFsICk7XG5cdFx0Y2FzZSAnaXNfYWZ0ZXJfbl9vcl9tb3JlX2RheXMnOlxuXHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ2lzIGFmdGVyICVzIG9yIG1vcmUgZGF5cyBmcm9tIGN1cnJlbnQgZGF0ZScgKS5yZXBsYWNlKCAnJXMnLCB2YWwgKTtcblx0XHRjYXNlICdpc19hZnRlcl9sZXNzX3RoYW5fbl9kYXlzJzpcblx0XHRcdHJldHVybiB0cmFuc2xhdGUoICdpcyBhZnRlciBsZXNzIHRoYW4gJXMgZGF5cyBmcm9tIGN1cnJlbnQgZGF0ZScgKS5yZXBsYWNlKCAnJXMnLCB2YWwgKTtcblx0XHRjYXNlICdpc19ncmVhdCc6XG5cdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnaXMgZ3JlYXRlciB0aGFuJyApO1xuXHRcdGNhc2UgJ2lzX2xlc3MnOlxuXHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ2lzIGxlc3MgdGhhbicgKTtcblx0XHRjYXNlICdjb250YWlucyc6XG5cdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnY29udGFpbnMnICk7XG5cdFx0Y2FzZSAnc3RhcnRzJzpcblx0XHRcdHJldHVybiB0cmFuc2xhdGUoICdzdGFydHMgd2l0aCcgKTtcblx0XHRjYXNlICdlbmRzJzpcblx0XHRcdHJldHVybiB0cmFuc2xhdGUoICdlbmRzIHdpdGgnICk7XG5cdFx0Y2FzZSAnaXNfY29ycmVjdCc6XG5cdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnaXMgY29ycmVjdCcgKTtcblx0XHRjYXNlICdpc19pbmNvcnJlY3QnOlxuXHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ2lzIGluY29ycmVjdCcgKTtcblx0XHQvLyBQZXJzb25hbGl0eSBxdWl6IHJ1bGVzLlxuXHRcdGNhc2UgJ2lzX2ZpbmFsX3Jlc3VsdCc6XG5cdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnaXMgZmluYWwgcmVzdWx0JyApO1xuXHRcdGNhc2UgJ2lzX25vdF9maW5hbF9yZXN1bHQnOlxuXHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ2lzIG5vdCBmaW5hbCByZXN1bHQnICk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiAnLSc7XG5cdH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gaWYgdmFsdWUgaXMgdmFsaWQgZW1haWwgd3BcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgdmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sfVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1haWxXcCggdmFsdWUgKSB7XG5cdGlmICggdmFsdWUubGVuZ3RoIDwgNiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBUZXN0IGZvciBhbiBAIGNoYXJhY3RlciBhZnRlciB0aGUgZmlyc3QgcG9zaXRpb25cblx0aWYgKCB2YWx1ZS5pbmRleE9mKCAnQCcsIDEgKSA8IDAgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gU3BsaXQgb3V0IHRoZSBsb2NhbCBhbmQgZG9tYWluIHBhcnRzXG5cdGNvbnN0IHBhcnRzID0gdmFsdWUuc3BsaXQoICdAJywgMiApO1xuXG5cdC8vIExPQ0FMIFBBUlRcblx0Ly8gVGVzdCBmb3IgaW52YWxpZCBjaGFyYWN0ZXJzXG5cdGlmICggISBwYXJ0c1sgMCBdLm1hdGNoKCAvXlthLXpBLVowLTkhIyQlJicqK1xcLz0/Xl9ge3x9flxcLi1dKyQvICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gRE9NQUlOIFBBUlRcblx0Ly8gVGVzdCBmb3Igc2VxdWVuY2VzIG9mIHBlcmlvZHNcblx0aWYgKCBwYXJ0c1sgMSBdLm1hdGNoKCAvXFwuezIsfS8gKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRjb25zdCBkb21haW4gPSBwYXJ0c1sgMSBdO1xuXHQvLyBTcGxpdCB0aGUgZG9tYWluIGludG8gc3Vic1xuXHRjb25zdCBzdWJzID0gZG9tYWluLnNwbGl0KCAnLicgKTtcblx0aWYgKCBzdWJzLmxlbmd0aCA8IDIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Y29uc3Qgc3Vic0xlbiA9IHN1YnMubGVuZ3RoO1xuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzdWJzTGVuOyBpKysgKSB7XG5cdFx0Ly8gVGVzdCBmb3IgaW52YWxpZCBjaGFyYWN0ZXJzXG5cdFx0aWYgKCAhIHN1YnNbIGkgXS5tYXRjaCggL15bYS16MC05LV0rJC9pICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIERpc3BsYXkgU1VJIEpTIEVsZW1lbnRzXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gc3VpRGVsZWdhdGVFdmVudHMoKSB7XG5cdGlmICggJ29iamVjdCcgIT09IHR5cGVvZiB3aW5kb3cuU1VJICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFRpbWUgaXQgb3V0XG5cdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdC8vIFJlYmluZCBBY2NvcmRpb24gc2NyaXB0c1xuXHRcdFNVSS5zdWlBY2NvcmRpb24oIGpRdWVyeSggJy5zdWktYWNjb3JkaW9uJyApICk7XG5cblx0XHQvLyBSZWJpbmQgVGFicyBzY3JpcHRzXG5cdFx0U1VJLnN1aVRhYnMoIGpRdWVyeSggJy5zdWktdGFicycgKSApO1xuXG5cdFx0Ly8gUmViaW5kIFNlbGVjdDIgc2NyaXB0cy5cblx0XHRqUXVlcnkoICdzZWxlY3Quc3VpLXNlbGVjdFtkYXRhLXRoZW1lPVwiaWNvblwiXScgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFNVSS5zZWxlY3QuaW5pdEljb24oIGpRdWVyeSggdGhpcyApICk7XG5cdFx0fSApO1xuXG5cdFx0alF1ZXJ5KCAnc2VsZWN0LnN1aS1zZWxlY3RbZGF0YS10aGVtZT1cImNvbG9yXCJdJyApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0U1VJLnNlbGVjdC5pbml0Q29sb3IoIGpRdWVyeSggdGhpcyApICk7XG5cdFx0fSApO1xuXG5cdFx0alF1ZXJ5KCAnc2VsZWN0LnN1aS1zZWxlY3RbZGF0YS10aGVtZT1cInNlYXJjaFwiXScgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFNVSS5zZWxlY3QuaW5pdFNlYXJjaCggalF1ZXJ5KCB0aGlzICkgKTtcblx0XHR9ICk7XG5cblx0XHRqUXVlcnkoICdzZWxlY3Quc3VpLXNlbGVjdDpub3QoW2RhdGEtdGhlbWVdKTpub3QoLmN1c3RvbS1zZWxlY3QyKTpub3QoLmZ1aS1tdWx0aS1zZWxlY3QpJyApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0U1VJLnNlbGVjdC5pbml0KCBqUXVlcnkoIHRoaXMgKSApO1xuXHRcdH0gKTtcblxuXHRcdC8vIFJlYmluZCBWYXJpYWJsZXMgc2NyaXB0cy5cblx0XHRqUXVlcnkoICdzZWxlY3Quc3VpLXZhcmlhYmxlcycgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFNVSS5zZWxlY3QuaW5pdFZhcnMoIGpRdWVyeSggdGhpcyApICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gUmViaW5kIENpcmNsZSBzY3JpcHRzXG5cdFx0U1VJLmxvYWRDaXJjbGVTY29yZSggalF1ZXJ5KCAnLnN1aS1jaXJjbGUtc2NvcmUnICkgKTtcblxuXHRcdC8vIFJlYmluZCBQYXNzd29yZCBzY3JpcHRzXG5cdFx0U1VJLnNob3dIaWRlUGFzc3dvcmQoKTtcblx0fSwgNTAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGNoYXJ0IHR5cGUgZnJvbSBzZXR0aW5nc1xuICpcbiAqIEBwYXJhbSB7YXJyYXl9IHNldHRpbmdzIFNldHRpbmdzIGFycmF5XG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBDaGFydCB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFydFR5cGUoIHNldHRpbmdzICkge1xuXHRsZXQgdHlwZSA9ICdub25lJztcblxuXHRpZiAoIHR5cGVvZiBzZXR0aW5nc1sgJ3Jlc3VsdHMtYmVoYXYnIF0gJiYgdHlwZW9mIHNldHRpbmdzWyAncmVzdWx0cy1zdHlsZScgXSApIHtcblx0XHRpZiAoIHNldHRpbmdzWyAncmVzdWx0cy1iZWhhdicgXSA9PT0gJ2xpbmtfb24nIHx8IHNldHRpbmdzWyAncmVzdWx0cy1iZWhhdicgXSA9PT0gJ3Nob3dfYWZ0ZXInICkge1xuXHRcdFx0dHlwZSA9IHNldHRpbmdzWyAncmVzdWx0cy1zdHlsZScgXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHlwZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIGNhbGN1bGF0aW9uIGZpZWxkc1xuICpcbiAqIEBwYXJhbSB7YXJyYXl9IHdyYXBwZXJzIGN1cnJlbnQgd3JhcHBlcnNcbiAqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYWxjdWxhdGlvbkZpZWxkcyggd3JhcHBlcnMgKSB7XG5cdGNvbnN0IGRpc2FibGVkID0gW107XG5cblx0Ly8gUHVzaCBkaXNhYmxlZCBmaWVsZHNcblx0Xy5lYWNoKCBmb3JtaW5hdG9yRGF0YS5maWVsZHMsIGZpZWxkID0+IHtcblx0XHRpZiAoIGZpZWxkLnR5cGUgIT09ICdjYWxjdWxhdGlvbicgKSB7XG5cdFx0XHRkaXNhYmxlZC5wdXNoKCBmaWVsZC50eXBlICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0cmV0dXJuIGdldEZpZWxkcyggd3JhcHBlcnMsIGRpc2FibGVkICk7XG59XG5cbi8qKlxuICogRGlzcGxheSBTZWxlY3QyIHdpdGggbXVsdGlwbGUgdGFnc1xuICpcbiAqIEBwYXJhbSB7alF1ZXJ5fSAkZWwgalF1ZXJ5IHdyYXBwZXIgZWwgdG8gZmluZFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgU2VsZWN0MiBvcHRpb25zXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0MlRhZ3MoICRlbCwgb3B0aW9ucyApIHtcblx0b3B0aW9ucyA9IF8uZGVmYXVsdHMoIG9wdGlvbnMsIHtcblx0XHRhbGxvd0NsZWFyOiB0cnVlLFxuXHRcdGRyb3Bkb3duQ3NzQ2xhc3M6ICdzdWktc2VsZWN0LWRyb3Bkb3duJyxcblx0fSApO1xuXG5cdC8vIFNFTEVDVDIgZm9ybWluYXRvci11aS10YWdzXG5cdCRlbC5maW5kKCAnc2VsZWN0LnN1aS1zZWxlY3QuZnVpLW11bHRpLXNlbGVjdCcgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHQvLyByZW9yZGVyLXN1cHBvcnQsIGl0IHdpbGwgcHJlc2VydmUgb3JkZXIgYmFzZWQgb24gdXNlciB0YWdzIGFkZGVkXG5cdFx0aWYgKCBqUXVlcnkoIHRoaXMgKS5hdHRyKCAnZGF0YS1yZW9yZGVyJyApICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkub24oICdzZWxlY3QyOnNlbGVjdCcsIGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0XHRjb25zdCBlbG0gPSBlLnBhcmFtcy5kYXRhLmVsZW1lbnQsXG5cdFx0XHRcdFx0JGVsbSA9IGpRdWVyeSggZWxtICksXG5cdFx0XHRcdFx0JHQgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0JHQuYXBwZW5kKCAkZWxtICk7XG5cdFx0XHRcdCR0LnRyaWdnZXIoICdjaGFuZ2Uuc2VsZWN0MicgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0alF1ZXJ5KCB0aGlzICkuU1VJc2VsZWN0Miggb3B0aW9ucyApO1xuXHR9ICk7XG59XG5cbi8qKlxuICogUmV0dXJucyBpZiBmaWVsZCBpcyByZXF1aXJlZFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBmaWVsZCBmaWVsZFxuICpcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gaXNGaWVsZFJlcXVpcmVkKCBmaWVsZCApIHtcblx0Ly8gSGFuZGxlIG5hbWUgZmllbGQgc3ViIGZpZWxkc1xuXHRpZiAoIGZpZWxkLnR5cGUgPT09ICduYW1lJyApIHtcblx0XHRpZiAoIGZpZWxkLm11bHRpcGxlX25hbWUgPT09ICd0cnVlJyB8fCBmaWVsZC5tdWx0aXBsZV9uYW1lID09PSB0cnVlICkge1xuXHRcdFx0Ly8gV2UgaGF2ZSBtdWx0aSBmaWVsZFxuXG5cdFx0XHRpZiAoIGZpZWxkWyAncHJlZml4X3JlcXVpcmVkJyBdIHx8XG5cdFx0XHRcdGZpZWxkWyAnZm5hbWVfcmVxdWlyZWQnIF0gfHxcblx0XHRcdFx0ZmllbGRbICdtbmFtZV9yZXF1aXJlZCcgXSB8fFxuXHRcdFx0XHRmaWVsZFsgJ2xuYW1lX3JlcXVpcmVkJyBdXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gSGFuZGxlIG5hbWUgZmllbGQgc3ViIGZpZWxkc1xuXHRpZiAoIGZpZWxkLnR5cGUgPT09ICdhZGRyZXNzJyApIHtcblx0XHRpZiAoIGZpZWxkWyAnc3RyZWV0X2FkZHJlc3NfcmVxdWlyZWQnIF0gfHxcblx0XHRcdGZpZWxkWyAnYWRkcmVzc19saW5lX3JlcXVpcmVkJyBdIHx8XG5cdFx0XHRmaWVsZFsgJ2FkZHJlc3NfY2l0eV9yZXF1aXJlZCcgXSB8fFxuXHRcdFx0ZmllbGRbICdhZGRyZXNzX3N0YXRlX3JlcXVpcmVkJyBdIHx8XG5cdFx0XHRmaWVsZFsgJ2FkZHJlc3NfemlwX3JlcXVpcmVkJyBdIHx8XG5cdFx0XHRmaWVsZFsgJ2FkZHJlc3NfY291bnRyeV9yZXF1aXJlZCcgXVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvLyBGYWxsYmFjayB0byBkZWZhdWx0IHJlcXVpcmVkIHByb3Bcblx0cmV0dXJuIGZpZWxkLnJlcXVpcmVkO1xufVxuXG4vKlxuICogUmV0dXJucyBpZiBmb3JtIGhhcyBhIGZpZWxkIHdpdGggcmVxdWVzdGVkIGF0dHJpYnV0ZSBhbmQgdGhlIHJlcXVlc3RlZCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzRmllbGRXaXRoQXR0cmlidXRlKCB3cmFwcGVycywgdHlwZSwgYXR0cmlidXRlLCB2YWx1ZSApIHtcblx0bGV0IGNvdW50ZXIgPSAwO1xuXG5cdGlmICggaXNHbG9iYWxQcmVzZXQoIHdyYXBwZXJzICkgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHR3cmFwcGVycy5tYXAoIHdyYXBwZXIgPT4ge1xuXHRcdHdyYXBwZXIuZmllbGRzLm1hcCggZmllbGQgPT4ge1xuXHRcdFx0aWYgKCB0eXBlID09PSBmaWVsZC50eXBlICYmIHZhbHVlID09PSBmaWVsZFsgYXR0cmlidXRlIF0gKSB7XG5cdFx0XHRcdGNvdW50ZXIrKztcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gY291bnRlciA+IDA7XG59XG5cbi8qXG4gKiBSZXR1cm5zIGlmIGZvcm0gaGFzIGEgZmllbGQgd2l0aCBtdWx0aXBsZSBjYXRlZ29yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzUG9zdGRhdGFGaWVsZFdpdGhNdWx0aXNlbGVjdCggd3JhcHBlcnMgKSB7XG5cdGxldCBjb3VudGVyID0gMDtcblxuXHRpZiAoIGlzR2xvYmFsUHJlc2V0KCB3cmFwcGVycyApICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0d3JhcHBlcnMubWFwKCB3cmFwcGVyID0+IHtcblx0XHR3cmFwcGVyLmZpZWxkcy5tYXAoIGZpZWxkID0+IHtcblx0XHRcdGNvbnN0IHBvc3RfY2F0ZWdvcnkgPSBmb3JtaW5hdG9yRGF0YS5wb3N0Q2F0ZWdvcmllc1sgZmllbGQucG9zdF90eXBlIF07XG5cdFx0XHRpZiggdHlwZW9mIHBvc3RfY2F0ZWdvcnkgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0XHRwb3N0X2NhdGVnb3J5Lm1hcCggY2F0ZWdvcnkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGNhdGVnb3J5X2tleSA9IGNhdGVnb3J5LnZhbHVlICsgJ19tdWx0aXBsZSc7XG5cdFx0XHRcdFx0aWYoIDEgPT09IHBhcnNlSW50KCBmaWVsZFsgY2F0ZWdvcnlfa2V5IF0gKSApIHtcblx0XHRcdFx0XHRcdGNvdW50ZXIrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gY291bnRlciA+IDA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhcnJheSBvZiBwZXJzb25hbGl0eSBxdWVzdGlvbnNcbiAqXG4gKiBAcGFyYW0ge2FycmF5fVxuICpcbiAqIEByZXR1cm4ge2FycmF5fVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBlcnNvbmFsaXR5UXVlc3Rpb25zKCBjdXJyZW50UGVyc29uYWxpdHksIHF1ZXN0aW9ucyApIHtcblx0Y29uc3QgcGVyc29uYWxpdHlTbHVnID0gY3VycmVudFBlcnNvbmFsaXR5LnNsdWc7XG5cdGxldCBxdWVzdGlvbnNBcnJheSA9IFtdO1xuXG5cdGlmICggISBfLmlzRW1wdHkoIHF1ZXN0aW9ucyApICkge1xuXHRcdF8uZWFjaCggcXVlc3Rpb25zLCBmdW5jdGlvbiggcXVlc3Rpb24sIGtleVF1ZXN0aW9uICkge1xuXHRcdFx0aWYgKCAhIF8uaXNFbXB0eSggcXVlc3Rpb24uYW5zd2VycyApICkge1xuXHRcdFx0XHRfLmVhY2goIHF1ZXN0aW9uLmFuc3dlcnMsIGZ1bmN0aW9uKCBhbnN3ZXIsIGtleUFuc3dlciApIHtcblx0XHRcdFx0XHRpZiAoIGFuc3dlci5yZXN1bHQgPT09IHBlcnNvbmFsaXR5U2x1ZyApIHtcblx0XHRcdFx0XHRcdHF1ZXN0aW9uc0FycmF5LnB1c2goIHtcblx0XHRcdFx0XHRcdFx0dGl0bGU6IHF1ZXN0aW9uLnRpdGxlLFxuXHRcdFx0XHRcdFx0XHRzbHVnOiBxdWVzdGlvbi5zbHVnLFxuXHRcdFx0XHRcdFx0XHRxdWVzdGlvbjogcXVlc3Rpb24sXG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHF1ZXN0aW9uc0FycmF5ID0gXy51bmlxKCBxdWVzdGlvbnNBcnJheSwgJ3NsdWcnICk7XG5cdH1cblxuXHRyZXR1cm4gcXVlc3Rpb25zQXJyYXk7XG59XG5cbi8qKlxuICogR2V0IHBheW1lbnQgcGxhbiB2YWxpZGF0aW9uXG4gKlxuICogQHBhcmFtIHthcnJheX0gdmFsaWRhdGlvblxuICogQHBhcmFtIHthcnJheX0gcGF5bWVudHNcbiAqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYW5WYWxpZGF0aW9uKCB2YWxpZGF0aW9uLCBwYXltZW50cyApIHtcblxuXHRsZXQgcGF5bWVudEluZGV4ID0gW107XG5cblx0Xy5lYWNoKCBwYXltZW50cywgZnVuY3Rpb24oIHBheW1lbnQsIGluZGV4ICkge1xuXHRcdGlmICggISBwYXltZW50LmFtb3VudF90eXBlIHx8ICEgcGF5bWVudC5wbGFuX25hbWUgKSB7XG5cdFx0XHR2YWxpZGF0aW9uLmVycm9yID0gdHJhbnNsYXRlKCAnUGxlYXNlIGZpeCB0aGUgZXJyb3IocykgaW4gdGhlIFNFVFRJTkdTIHRhYi4nICk7XG5cdFx0XHR2YWxpZGF0aW9uLmlzVmFsaWQgPSBmYWxzZTtcblx0XHRcdHBheW1lbnRJbmRleC5wdXNoKCBpbmRleCApO1xuXHRcdH1cblxuXHRcdGlmICggJ3NpbmdsZScgPT09IHBheW1lbnQucGF5bWVudF9tZXRob2QgJiZcblx0XHRcdCggKCAnZml4ZWQnID09PSBwYXltZW50LmFtb3VudF90eXBlICYmIF8uaXNFbXB0eSggcGF5bWVudC5hbW91bnQgKSApIHx8XG5cdFx0XHRcdCggJ3ZhcmlhYmxlJyA9PT0gcGF5bWVudC5hbW91bnRfdHlwZSAmJiBfLmlzRW1wdHkoIHBheW1lbnQudmFyaWFibGUgKSApXG5cdFx0XHQpXG5cdFx0KSB7XG5cdFx0XHR2YWxpZGF0aW9uLmVycm9yID0gdHJhbnNsYXRlKCAnUGxlYXNlIGZpeCB0aGUgZXJyb3IocykgaW4gdGhlIFNFVFRJTkdTIHRhYi4nICk7XG5cdFx0XHR2YWxpZGF0aW9uLmlzVmFsaWQgPSBmYWxzZTtcblx0XHRcdHBheW1lbnRJbmRleC5wdXNoKCBpbmRleCApO1xuXHRcdH0gZWxzZSBpZiAoICdzdWJzY3JpcHRpb24nID09PSBwYXltZW50LnBheW1lbnRfbWV0aG9kICkge1xuXHRcdFx0Y29uc3Qgc3Vic2NyaXB0aW9uQW1vdW50ID0gISBfLmlzVW5kZWZpbmVkKCBwYXltZW50LnN1YnNjcmlwdGlvbl9hbW91bnRfdHlwZSApXG5cdFx0XHRcdD8gcGF5bWVudC5zdWJzY3JpcHRpb25fYW1vdW50X3R5cGVcblx0XHRcdFx0OiAnZml4ZWQnO1xuXHRcdFx0Y29uc3Qgc3Vic2NyaXB0aW9uUXVhbnRpdHkgPSAhIF8uaXNVbmRlZmluZWQoIHBheW1lbnQucXVhbnRpdHlfdHlwZSApXG5cdFx0XHRcdD8gcGF5bWVudC5xdWFudGl0eV90eXBlXG5cdFx0XHRcdDogJ2ZpeGVkJztcblx0XHRcdGNvbnN0IFF1YW50aXR5ID0gISBfLmlzVW5kZWZpbmVkKCBwYXltZW50LnF1YW50aXR5IClcblx0XHRcdFx0PyBwYXltZW50LnF1YW50aXR5XG5cdFx0XHRcdDogMTtcblx0XHRcdGNvbnN0IEJpbGxJbnB1dCA9ICEgXy5pc1VuZGVmaW5lZCggcGF5bWVudC5iaWxsX2lucHV0IClcblx0XHRcdFx0PyBwYXltZW50LmJpbGxfaW5wdXRcblx0XHRcdFx0OiAxO1xuXHRcdFx0aWYgKCAoICdmaXhlZCcgPT09IHN1YnNjcmlwdGlvbkFtb3VudCAmJiBfLmlzRW1wdHkoIHBheW1lbnQuc3Vic2NyaXB0aW9uX2Ftb3VudCApICkgfHxcblx0XHRcdFx0KCAndmFyaWFibGUnID09PSBzdWJzY3JpcHRpb25BbW91bnQgJiYgXy5pc0VtcHR5KCBwYXltZW50LnN1YnNjcmlwdGlvbl92YXJpYWJsZSApIClcblx0XHRcdCkge1xuXHRcdFx0XHR2YWxpZGF0aW9uLmVycm9yID0gdHJhbnNsYXRlKCAnUGxlYXNlIGZpeCB0aGUgZXJyb3IocykgaW4gdGhlIFNFVFRJTkdTIHRhYi4nICk7XG5cdFx0XHRcdHZhbGlkYXRpb24uaXNWYWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRwYXltZW50SW5kZXgucHVzaCggaW5kZXggKTtcblx0XHRcdH1cblx0XHRcdGlmICggKCAnZml4ZWQnID09PSBzdWJzY3JpcHRpb25RdWFudGl0eSAmJiAhIFF1YW50aXR5ICkgfHxcblx0XHRcdFx0KCAndmFyaWFibGUnID09PSBzdWJzY3JpcHRpb25RdWFudGl0eSAmJiBfLmlzRW1wdHkoIHBheW1lbnQudmFyaWFibGVfcXVhbnRpdHkgKSApXG5cdFx0XHQpIHtcblx0XHRcdFx0dmFsaWRhdGlvbi5lcnJvciA9IHRyYW5zbGF0ZSggJ1BsZWFzZSBmaXggdGhlIGVycm9yKHMpIGluIHRoZSBTRVRUSU5HUyB0YWIuJyApO1xuXHRcdFx0XHR2YWxpZGF0aW9uLmlzVmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0cGF5bWVudEluZGV4LnB1c2goIGluZGV4ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICEgQmlsbElucHV0ICkge1xuXHRcdFx0XHR2YWxpZGF0aW9uLmVycm9yID0gdHJhbnNsYXRlKCAnUGxlYXNlIGZpeCB0aGUgZXJyb3IocykgaW4gdGhlIFNFVFRJTkdTIHRhYi4nICk7XG5cdFx0XHRcdHZhbGlkYXRpb24uaXNWYWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRwYXltZW50SW5kZXgucHVzaCggaW5kZXggKTtcblx0XHRcdH0gZWxzZSBpZiAoIEJpbGxJbnB1dCA8PSAwICkge1xuXHRcdFx0XHR2YWxpZGF0aW9uLmVycm9yID0gdHJhbnNsYXRlKCAnQmlsbGluZyBmcmVxdWVuY3kgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyApO1xuXHRcdFx0XHR2YWxpZGF0aW9uLmlzVmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0cGF5bWVudEluZGV4LnB1c2goIGluZGV4ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG5cblx0aWYgKCBwYXltZW50SW5kZXgubGVuZ3RoID4gMCApIHtcblx0XHR2YWxpZGF0aW9uLnBheW1lbnRLZXkgPSBwYXltZW50SW5kZXg7XG5cdH1cblxuXHRyZXR1cm4gdmFsaWRhdGlvbjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBldmFsdWF0ZXMgdG8gdHJ1ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICpcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1RydWUgKCB2YWx1ZSApe1xuICAgIGlmICggJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICggJ3N0cmluZycgPT09IHR5cGVvZiggdmFsdWUgKSApIHtcbiAgICBcdHZhbHVlID0gdmFsdWUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgc3dpdGNoKCB2YWx1ZSApe1xuICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgIGNhc2UgXCJ0cnVlXCI6XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgY2FzZSBcIm9uXCI6XG4gICAgICAgIGNhc2UgXCJ5ZXNcIjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBxdWVyeSBzdHJpbmdcbiAqICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmcgKCkge1xuXHR2YXIgcGFyc2VkUGFyYW1ldGVycyA9IHt9LFxuXHRcdHVyaVBhcmFtZXRlcnMgPSBsb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpLnNwbGl0KCcmJyk7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB1cmlQYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHBhcmFtZXRlciA9IHVyaVBhcmFtZXRlcnNbaV0uc3BsaXQoJz0nKTtcblx0XHRwYXJzZWRQYXJhbWV0ZXJzW3BhcmFtZXRlclswXV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFyYW1ldGVyWzFdKTtcblx0fVxuXG5cdHJldHVybiBwYXJzZWRQYXJhbWV0ZXJzO1xufVxuXG4vKiogR28gdG8gbGlua1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdvVG9MaW5rICggbGluaywgdGFyZ2V0ID0gJ19ibGFuaycgKSB7XG5cdHdpbmRvdy5vcGVuKCBsaW5rLCB0YXJnZXQgKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy5qcyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUuYmluZCggdGhpcyApO1xuXHR9XG5cblx0dXBkYXRlVmFsdWUoIHZhbHVlICkge1xuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIG9uIGZpZWxkIHNldHRpbmdzXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5wcm9wcy51cGRhdGVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdC8vIFVwZGF0ZSBmaWVsZCBzdGF0ZVxuXHRcdFx0dGhpcy5wcm9wcy51cGRhdGVQcm9wZXJ0eSggdGhpcy5wcm9wcy5wcm9wZXJ0eSwgdmFsdWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVXBkYXRlIHN0b3JlXG5cdFx0XHR0aGlzLnByb3BzLmFjdGlvbnMuc2V0dGluZ3NBY3Rpb25zLnVwZGF0ZVNldHRpbmcoIHRoaXMucHJvcHMucHJvcGVydHksIHZhbHVlICk7XG5cdFx0fVxuXHR9XG5cblx0aXNWYWxpZCggdmFsdWUgKSB7XG5cdFx0aWYgKCB0aGlzLnByb3BzLmlzUmVxdWlyZWQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wcm9wcy5pc1JlcXVpcmVkICYmICEgXy5pc0VtcHR5KCB2YWx1ZSApO1xuXHRcdH0gZWxzZSBpZiAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5pc1Bvc2l0aXZlICkgKSB7XG5cdFx0XHRyZXR1cm4gXy5pc0VtcHR5KCB2YWx1ZSApIHx8IHZhbHVlID49IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF0gKVxuXHRcdFx0PyB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZVxuXHRcdFx0OiB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF07XG5cblx0XHRjb25zdCB0eXBlID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnR5cGUgKSA/IHRoaXMucHJvcHMudHlwZSA6ICd0ZXh0JztcblxuXHRcdGNvbnN0IHJlcXVpcmVkRXJyb3IgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMucmVxdWlyZWRFcnJvciApID8gdGhpcy5wcm9wcy5yZXF1aXJlZEVycm9yIDogdHJhbnNsYXRlKCAnVGhpcyBmaWVsZCBpcyByZXF1aXJlZCEnICk7XG5cblx0XHRjb25zdCBoYXNFcnJvckNsYXNzID0gISB0aGlzLmlzVmFsaWQoIHZhbHVlICkgPyAnc3VpLWZvcm0tZmllbGQtZXJyb3InIDogJyc7XG5cblx0XHRjb25zdCBmaWVsZENsYXNzID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmZpZWxkQ2xhc3MgKVxuXHRcdFx0PyAnc3VpLWZvcm0tZmllbGQgJyArIHRoaXMucHJvcHMuZmllbGRDbGFzc1xuXHRcdFx0OiAnc3VpLWZvcm0tZmllbGQnO1xuXG5cdFx0bGV0IGlucHV0Q2xhc3MgPSAnc3VpLWZvcm0tY29udHJvbCc7XG5cblx0XHRpZiAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5pbnB1dENsYXNzICkgJiYgJycgIT09IHRoaXMucHJvcHMuaW5wdXRDbGFzcyApIHtcblx0XHRcdGlucHV0Q2xhc3MgKz0gJyAnICsgdGhpcy5wcm9wcy5pbnB1dENsYXNzO1xuXHRcdH1cblxuXHRcdGlmICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnByZWZpeCApICYmICcnICE9PSB0aGlzLnByb3BzLnByZWZpeCApIHtcblx0XHRcdGlucHV0Q2xhc3MgKz0gJyBzdWktZmllbGQtaGFzLXByZWZpeCc7XG5cdFx0fVxuXG5cdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc3VmZml4ICkgJiYgJycgIT09IHRoaXMucHJvcHMuc3VmZml4ICkge1xuXHRcdFx0aW5wdXRDbGFzcyArPSAnIHN1aS1maWVsZC1oYXMtc3VmZml4Jztcblx0XHR9XG5cblx0XHRjb25zdCBpbnB1dElkID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmlucHV0SWQgKVxuXHRcdFx0PyB0aGlzLnByb3BzLmlucHV0SWRcblx0XHRcdDogdGhpcy5wcm9wcy5wcm9wZXJ0eTtcblxuXHRcdGxldCBpbnB1dExhYmVsO1xuXG5cdFx0aWYgKCB0aGlzLnByb3BzLmxhYmVsICkge1xuXHRcdFx0aW5wdXRMYWJlbCA9IChcblx0XHRcdFx0PGxhYmVsXG5cdFx0XHRcdFx0aHRtbEZvcj17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IGlucHV0SWQgfWAgfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT17IHRoaXMucHJvcHMuZGFya0xhYmVsXG5cdFx0XHRcdFx0XHQ/ICdzdWktc2V0dGluZ3MtbGFiZWwgc3VpLWRhcmsnXG5cdFx0XHRcdFx0XHQ6ICdzdWktbGFiZWwnXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmxhYmVsIH1cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuaXNSZXF1aXJlZCAmJlxuXHRcdFx0XHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHRcdFx0XHQmbmJzcDs8c3BhbiBjbGFzc05hbWU9XCJzdWktZXJyb3JcIj4qPC9zcGFuPlxuXHRcdFx0XHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLm5vdGUgJiZcblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1sYWJlbC1ub3RlXCI+eyB0aGlzLnByb3BzLm5vdGUgfTwvc3Bhbj5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdDwvbGFiZWw+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGlucHV0RmllbGQgPSAoXG5cdFx0XHQ8aW5wdXQgdHlwZT17IHR5cGUgfVxuXHRcdFx0XHRwbGFjZWhvbGRlcj17IHRoaXMucHJvcHMucGxhY2Vob2xkZXIgfVxuXHRcdFx0XHR2YWx1ZT17IHZhbHVlIHx8ICcnIH1cblx0XHRcdFx0aWQ9eyBgZm9ybWluYXRvci1maWVsZC0keyBpbnB1dElkIH1gIH1cblx0XHRcdFx0Y2xhc3NOYW1lPXsgaW5wdXRDbGFzcyB9XG5cdFx0XHRcdHsgLi4uIHRoaXMucHJvcHMubm90V3JpdGFibGUgJiYgeyByZWFkb25seTogJycgfSB9XG5cdFx0XHRcdHsgLi4uIHRoaXMucHJvcHMubWluVmFsdWUgJiYgeyBtaW46IHRoaXMucHJvcHMubWluVmFsdWUgfSB9XG5cdFx0XHRcdHsgLi4uIHRoaXMucHJvcHMubWF4VmFsdWUgJiYgeyBtYXg6IHRoaXMucHJvcHMubWF4VmFsdWUgfSB9XG5cdFx0XHRcdHsgLi4uIHRoaXMucHJvcHMuc3RlcCAmJiB7IHN0ZXA6IHRoaXMucHJvcHMuc3RlcCB9IH1cblx0XHRcdFx0eyAuLi4gdGhpcy5wcm9wcy5tYXhMZW5ndGggJiYgeyBtYXhMZW5ndGg6IHRoaXMucHJvcHMubWF4TGVuZ3RoIH0gfVxuXHRcdFx0XHR7IC4uLiB0aGlzLnByb3BzLmlucHV0U3R5bGVzICYmIHsgc3R5bGU6IHRoaXMucHJvcHMuaW5wdXRTdHlsZXMgfSB9XG5cdFx0XHRcdGRpc2FibGVkPXsgdGhpcy5wcm9wcy5kaXNhYmxlZCA/IHRydWUgOiBmYWxzZSB9XG5cdFx0XHRcdG9uQ2hhbmdlPXsgZSA9PiB7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGVWYWx1ZSggZS50YXJnZXQudmFsdWUgKTtcblx0XHRcdFx0fSB9XG5cdFx0XHQvPlxuXHRcdCk7XG5cblx0XHRjb25zdCBnZXRGaWVsZHMgPSAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT17IGAkeyBmaWVsZENsYXNzIH0gJHsgaGFzRXJyb3JDbGFzcyB9YCB9PlxuXHRcdFx0XHR7IGlucHV0TGFiZWwgfVxuXHRcdFx0XHR7ICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnByZWZpeCApICYmICcnICE9PSB0aGlzLnByb3BzLnByZWZpeCApICYmIChcblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZmllbGQtcHJlZml4XCI+eyB0aGlzLnByb3BzLnByZWZpeCB9PC9zcGFuPlxuXHRcdFx0XHQpIH1cblx0XHRcdFx0eyAoICEgdGhpcy5wcm9wcy5jYW5UcmFzaFxuXHRcdFx0XHRcdD8gaW5wdXRGaWVsZFxuXHRcdFx0XHRcdDogPGRpdiBjbGFzc05hbWU9XCJzdWktd2l0aC1idXR0b24gc3VpLXdpdGgtYnV0dG9uLWljb25cIj5cblx0XHRcdFx0XHRcdHsgaW5wdXRGaWVsZCB9XG5cdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzTmFtZT1cInN1aS1idXR0b24taWNvbiBzdWktdG9vbHRpcCBzdWktdG9vbHRpcC10b3AtcmlnaHRcIlxuXHRcdFx0XHRcdFx0XHRkYXRhLXRvb2x0aXA9eyB0cmFuc2xhdGUoICdEZWxldGUnICkgfT5cblx0XHRcdFx0XHRcdFx0PGkgY2xhc3NOYW1lPVwic3VpLWljb24tdHJhc2hcIiBhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuXHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdCkgfVxuXHRcdFx0XHR7IHRoaXMucHJvcHMuc3VmZml4ICYmIChcblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZmllbGQtc3VmZml4XCI+eyB0aGlzLnByb3BzLnN1ZmZpeCB9PC9zcGFuPlxuXHRcdFx0XHQpIH1cblx0XHRcdFx0eyB0aGlzLnByb3BzLmlzUmVxdWlyZWQgJiYgISB0aGlzLmlzVmFsaWQoIHZhbHVlICkgJiYgKFxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1lcnJvci1tZXNzYWdlXCI+eyByZXF1aXJlZEVycm9yIH08L3NwYW4+XG5cdFx0XHRcdCkgfVxuXHRcdFx0XHR7ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5pc1Bvc2l0aXZlICkgJiYgISB0aGlzLmlzVmFsaWQoIHZhbHVlICkgJiYgKFxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1lcnJvci1tZXNzYWdlXCI+eyB0cmFuc2xhdGUoICdQbGVhc2UgZW50ZXIgdmFsaWQgbnVtYmVyLicgKSB9PC9zcGFuPlxuXHRcdFx0XHQpIH1cblx0XHRcdFx0eyB0aGlzLnByb3BzLmRlc2NyaXB0aW9uICYmIChcblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj57IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gfTwvc3Bhbj5cblx0XHRcdFx0KSB9XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXG5cdFx0aWYgKCB0aGlzLnByb3BzLnNpbXBsZSApIHtcblx0XHRcdHJldHVybiBpbnB1dEZpZWxkO1xuXHRcdH1cblxuXHRcdHJldHVybiBnZXRGaWVsZHM7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9pbnB1dHMvaW5wdXQuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250YWluZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbi5tYXAoIHRoaXMucHJvcHMuY2hpbGRyZW4sIGNoaWxkID0+IHtcblx0XHRcdHJldHVybiBjaGlsZDtcblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdj5cblx0XHRcdFx0eyBjaGlsZHJlbiB9XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MvY29udGFpbmVycy9jb250YWluZXIuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2wgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbi5tYXAoIHRoaXMucHJvcHMuY2hpbGRyZW4sIGNoaWxkcmVuID0+IHtcblx0XHRcdHJldHVybiBjaGlsZHJlbjtcblx0XHR9ICk7XG5cblx0XHRjb25zdCBjdXN0b21DbGFzcyA9IHRoaXMucHJvcHMuY3VzdG9tQ2xhc3MgPyB0aGlzLnByb3BzLmN1c3RvbUNsYXNzIDogJyc7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9eyBgc3VpLWNvbC1tZC0keyB0aGlzLnByb3BzLmNvbHMgfSAkeyBjdXN0b21DbGFzcyB9YCB9PlxuXHRcdFx0XHR7IGNoaWxkcmVuIH1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9jb250YWluZXJzL2NvbC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9yUGlja2VyIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUuYmluZCggdGhpcyApO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0dGhpcy4kZWwgPSBqUXVlcnkoIHRoaXMuZWwgKTtcblx0XHR0aGlzLiRlbC53cENvbG9yUGlja2VyKCB7XG5cdFx0XHRjaGFuZ2U6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0XHRcdGNvbnN0ICR0aGlzID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdCR0aGlzLnZhbCggdWkuY29sb3IudG9DU1MoKSApLnRyaWdnZXIoICdjaGFuZ2UnICk7XG5cdFx0XHR9LFxuXHRcdFx0cGFsZXR0ZXM6IFtcblx0XHRcdFx0JyMzMzMzMzMnLFxuXHRcdFx0XHQnI0ZGRkZGRicsXG5cdFx0XHRcdCcjMTdBOEUzJyxcblx0XHRcdFx0JyNFMUY2RkYnLFxuXHRcdFx0XHQnIzY2NjY2NicsXG5cdFx0XHRcdCcjQUFBQUFBJyxcblx0XHRcdFx0JyNFNkU2RTYnLFxuXHRcdFx0XSxcblx0XHR9ICk7XG5cblx0XHRjb25zdCAkc3VpUGlja2VySW5wdXQgPSB0aGlzLiRlbCxcblx0XHRcdCRzdWlQaWNrZXIgPSAkc3VpUGlja2VySW5wdXQuY2xvc2VzdCggJy5zdWktY29sb3JwaWNrZXItd3JhcCcgKSxcblx0XHRcdCRzdWlQaWNrZXJDb2xvciA9ICRzdWlQaWNrZXIuZmluZCggJy5zdWktY29sb3JwaWNrZXItdmFsdWUgc3Bhbltyb2xlPWJ1dHRvbl0nICksXG5cdFx0XHQkc3VpUGlja2VyVmFsdWUgPSAkc3VpUGlja2VyLmZpbmQoICcuc3VpLWNvbG9ycGlja2VyLXZhbHVlJyApLFxuXHRcdFx0JHN1aVBpY2tlckNsZWFyID0gJHN1aVBpY2tlclZhbHVlLmZpbmQoICdidXR0b24nIClcblx0XHQ7XG5cblx0XHRjb25zdCAkd3BQaWNrZXIgPSAkc3VpUGlja2VySW5wdXQuY2xvc2VzdCggJy53cC1waWNrZXItY29udGFpbmVyJyApLFxuXHRcdFx0JHdwUGlja2VyQnV0dG9uID0gJHdwUGlja2VyLmZpbmQoICcud3AtY29sb3ItcmVzdWx0JyApLFxuXHRcdFx0JHdwUGlja2VyQWxwaGEgPSAkd3BQaWNrZXJCdXR0b24uZmluZCggJy5jb2xvci1hbHBoYScgKSxcblx0XHRcdCR3cFBpY2tlckNsZWFyID0gJHdwUGlja2VyLmZpbmQoICcud3AtcGlja2VyLWNsZWFyJyApXG5cdFx0O1xuXG5cdFx0bGV0ICRwaWNrZXJCYWNrZ3JvdW5kID0gJHdwUGlja2VyQWxwaGE7XG5cblx0XHQvLyBDaGVjayBpZiBhbHBoYSBleGlzdHNcblx0XHRpZiAoICRzdWlQaWNrZXJJbnB1dC5kYXRhKCAnYWxwaGEnICkgPT09IHRydWUgKSB7XG5cdFx0XHQkcGlja2VyQmFja2dyb3VuZCA9ICR3cFBpY2tlckFscGhhO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkcGlja2VyQmFja2dyb3VuZCA9ICR3cFBpY2tlckJ1dHRvbjtcblx0XHR9XG5cblx0XHQvLyBMaXN0ZW4gdG8gY29sb3IgY2hhbmdlXG5cdFx0JHN1aVBpY2tlcklucHV0LmJpbmQoICdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcblx0XHRcdC8vIENoYW5nZSBjb2xvciBwcmV2aWV3XG5cdFx0XHQkc3VpUGlja2VyQ29sb3IuZmluZCggJ3NwYW4nICkuY3NzKCB7XG5cdFx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzogJHBpY2tlckJhY2tncm91bmQuY3NzKCAnYmFja2dyb3VuZC1jb2xvcicgKSxcblx0XHRcdH0gKTtcblxuXHRcdFx0Ly8gQ2hhbmdlIGNvbG9yIHZhbHVlXG5cdFx0XHQkc3VpUGlja2VyVmFsdWUuZmluZCggJ2lucHV0JyApLnZhbCggJHN1aVBpY2tlcklucHV0LnZhbCgpICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gT3BlbiBpcmlzIHBpY2tlclxuXHRcdCRzdWlQaWNrZXIuZmluZCggJy5zdWktYnV0dG9uLCBzcGFuW3JvbGU9YnV0dG9uXScgKS5vbiggJ2NsaWNrJywgZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0JHdwUGlja2VyQnV0dG9uLmNsaWNrKCk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gQ2xlYXIgY29sb3IgdmFsdWVcblx0XHQkc3VpUGlja2VyQ2xlYXIub24oICdjbGljaycsIGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdFx0JHdwUGlja2VyQ2xlYXIuY2xpY2soKTtcblx0XHRcdCRzdWlQaWNrZXJWYWx1ZS5maW5kKCAnaW5wdXQnICkudmFsKCAnJyApO1xuXHRcdFx0JHN1aVBpY2tlckNvbG9yLmZpbmQoICdzcGFuJyApLmNzcygge1xuXHRcdFx0XHQnYmFja2dyb3VuZC1jb2xvcic6ICcnLFxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblxuXHRcdHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLiRlbC5vbiggJ2NoYW5nZScsIHRoaXMudXBkYXRlVmFsdWUgKTtcblx0fVxuXG5cdHVwZGF0ZVZhbHVlKCBlICkge1xuXHRcdGNvbnN0IHZhbHVlID0gZS50YXJnZXQudmFsdWU7XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBvbiBmaWVsZCBzZXR0aW5nc1xuXHRcdGlmICggdHlwZW9mIHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHQvLyBVcGRhdGUgZmllbGQgc3RhdGVcblx0XHRcdHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkoXG5cdFx0XHRcdHRoaXMucHJvcHMucHJvcGVydHksXG5cdFx0XHRcdHZhbHVlXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBVcGRhdGUgc3RvcmVcblx0XHRcdHRoaXMucHJvcHMuYWN0aW9ucy5zZXR0aW5nc0FjdGlvbnMudXBkYXRlU2V0dGluZyggdGhpcy5wcm9wcy5wcm9wZXJ0eSwgdmFsdWUgKTtcblx0XHR9XG5cdH1cblxuXHRjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0XHR0aGlzLiRlbC5vZmYoICdjaGFuZ2UnLCB0aGlzLnVwZGF0ZVZhbHVlICk7XG5cdFx0dGhpcy4kZWwudW5iaW5kKCkucmVtb3ZlRGF0YSgpO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IHZhbHVlID0gKCBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF0gKSB8fCB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF0gPT09IG51bGwgKVxuXHRcdFx0PyB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZVxuXHRcdFx0OiB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF07XG5cblx0XHRsZXQgZmllbGRMYWJlbCA9ICcnO1xuXG5cdFx0aWYgKCB0aGlzLnByb3BzLmxhYmVsICkge1xuXHRcdFx0ZmllbGRMYWJlbCA9IChcblx0XHRcdFx0PGxhYmVsIGNsYXNzTmFtZT1cInN1aS1sYWJlbFwiXG5cdFx0XHRcdFx0aHRtbEZvcj17IGBmb3JtaW5hdG9yLWNvbG9yLSR7IHRoaXMucHJvcHMucHJvcGVydHkgfWAgfT5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMubGFiZWwgfVxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5ub3RlICYmXG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktbGFiZWwtbm90ZVwiPiB7IHRoaXMucHJvcHMubm90ZSB9PC9zcGFuPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGRcIj5cblx0XHRcdFx0eyBmaWVsZExhYmVsIH1cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktY29sb3JwaWNrZXItd3JhcFwiPlxuXHRcdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRcdGNsYXNzTmFtZT17IGBzdWktY29sb3JwaWNrZXIgc3VpLWNvbG9ycGlja2VyLSR7IHRoaXMucHJvcHMuaXNBbHBoYVxuXHRcdFx0XHRcdFx0XHQ/ICdyZ2JhJ1xuXHRcdFx0XHRcdFx0XHQ6ICdoZXgnXG5cdFx0XHRcdFx0XHR9YCB9XG5cdFx0XHRcdFx0XHRhcmlhLWhpZGRlbj1cInRydWVcIj5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWNvbG9ycGlja2VyLXZhbHVlXCI+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIHJvbGU9XCJidXR0b25cIj5cblx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBzdHlsZT17IHsgYmFja2dyb3VuZENvbG9yOiB2YWx1ZSB9IH0+PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxpbnB1dCB0eXBlPVwidGV4dFwiIGRlZmF1bHRWYWx1ZT17IHZhbHVlIH1cblx0XHRcdFx0XHRcdFx0XHRyZWFkT25seT1cInJlYWRvbmx5XCIgLz5cblx0XHRcdFx0XHRcdFx0PGJ1dHRvbj5cblx0XHRcdFx0XHRcdFx0XHQ8aSBjbGFzc05hbWU9XCJzdWktaWNvbi1jbG9zZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cblx0XHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDxidXR0b24gY2xhc3NOYW1lPVwic3VpLWJ1dHRvblwiPnsgdHJhbnNsYXRlKCAnU2VsZWN0JyApIH08L2J1dHRvbj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8aW5wdXQgcmVmPXsgZWwgPT4gKCB0aGlzLmVsID0gZWwgKSB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9eyB2YWx1ZSB9XG5cdFx0XHRcdFx0XHRpZD17IGBmb3JtaW5hdG9yLWNvbG9yLSR7IHRoaXMucHJvcHMucHJvcGVydHkgfWAgfVxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWNvbG9ycGlja2VyLWlucHV0XCJcblx0XHRcdFx0XHRcdGRhdGEtYWxwaGE9eyB0aGlzLnByb3BzLmlzQWxwaGEgPyAndHJ1ZScgOiAnZmFsc2UnIH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0eyAoIHRoaXMucHJvcHMuZGVzY3JpcHRpb24gJiYgJycgIT09IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gKSAmJiAoXG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCI+eyB0aGlzLnByb3BzLmRlc2NyaXB0aW9uIH08L3NwYW4+XG5cdFx0XHRcdCkgfVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzL2lucHV0cy9jb2xvci1waWNrZXIuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRpb1RhYnMgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHR0b2dnbGVWYWx1ZSggdmFsdWUgKSB7XG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgb24gZmllbGQgc2V0dGluZ3Ncblx0XHRpZiAoIHR5cGVvZiB0aGlzLnByb3BzLnVwZGF0ZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0Ly8gVXBkYXRlIGZpZWxkIHN0YXRlXG5cdFx0XHR0aGlzLnByb3BzLnVwZGF0ZVByb3BlcnR5KFxuXHRcdFx0XHR0aGlzLnByb3BzLnByb3BlcnR5LFxuXHRcdFx0XHR2YWx1ZVxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVXBkYXRlIHN0b3JlXG5cdFx0XHR0aGlzLnByb3BzLmFjdGlvbnMuc2V0dGluZ3NBY3Rpb25zLnVwZGF0ZVNldHRpbmcoIHRoaXMucHJvcHMucHJvcGVydHksIHZhbHVlICk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0RGVmYXVsdFZhbHVlKCkge1xuXHRcdGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMucHJvcHMuZGVmYXVsdCA/IHRoaXMucHJvcHMuZGVmYXVsdCA6ICcnO1xuXG5cdFx0Y29uc3QgdmFsdWUgPSBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF0gKVxuXHRcdFx0PyBkZWZhdWx0VmFsdWVcblx0XHRcdDogdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdO1xuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IHZhbHVlID0gdGhpcy5nZXREZWZhdWx0VmFsdWUoKTtcblxuXHRcdGNvbnN0IHRhYlRpdGxlcyA9IFJlYWN0LkNoaWxkcmVuLm1hcCggdGhpcy5wcm9wcy5jaGlsZHJlbiwgdGFiID0+IHtcblx0XHRcdGlmICggISB0YWIgKSB7XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0PFJlYWN0LkZyYWdtZW50IC8+XG5cdFx0XHRcdClcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbGFiZWwgPSAhIF8uaXNVbmRlZmluZWQoIHRhYi5wcm9wcy5sYWJlbCApXG5cdFx0XHRcdD8gdGFiLnByb3BzLmxhYmVsXG5cdFx0XHRcdDogdGFiLnByb3BzLmNoaWxkcmVuO1xuXG5cdFx0XHRpZiAoIHRoaXMucHJvcHMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9eyAnc3VpLXRhYi1pdGVtJyArICggdGFiLnByb3BzLnZhbHVlID09PSB2YWx1ZSA/ICcgYWN0aXZlJyA6ICcnICkgfVxuXHRcdFx0XHRcdFx0c3R5bGU9eyB7XG5cdFx0XHRcdFx0XHRcdG9wYWNpdHk6IDAuNSxcblx0XHRcdFx0XHRcdFx0Y3Vyc29yOiAnbm90LWFsbG93ZWQnLFxuXHRcdFx0XHRcdFx0fSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyBsYWJlbCB9XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggISB0aGlzLnByb3BzLmRpc2FibGVkICkge1xuXHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXsgJ3N1aS10YWItaXRlbScgKyAoIHRhYi5wcm9wcy52YWx1ZSA9PT0gdmFsdWUgPyAnIGFjdGl2ZScgOiAnJyApIH1cblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLnRvZ2dsZVZhbHVlLmJpbmQoIHRoaXMsIHRhYi5wcm9wcy52YWx1ZSApIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IGxhYmVsIH1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHRjb25zdCBjb250ZW50Q2xhc3MgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZGl2Q2xhc3MgKVxuXHRcdFx0PyAnc3VpLXRhYnMtY29udGVudCAnICsgdGhpcy5wcm9wcy5kaXZDbGFzc1xuXHRcdFx0OiAnc3VpLXRhYnMtY29udGVudCc7XG5cblx0XHRjb25zdCB0YWJDb250ZW50cyA9IFJlYWN0LkNoaWxkcmVuLm1hcCggdGhpcy5wcm9wcy5jaGlsZHJlbiwgdGFiID0+IHtcblx0XHRcdGlmICggISB0YWIgKSB7XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0PFJlYWN0LkZyYWdtZW50IC8+XG5cdFx0XHRcdClcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYm94Q2xhc3MgPSAhIF8uaXNVbmRlZmluZWQoIHRhYi5wcm9wcy5ib3hDbGFzcyApXG5cdFx0XHRcdD8gdGFiLnByb3BzLmJveENsYXNzXG5cdFx0XHRcdDogJyc7XG5cblx0XHRcdGlmICggdGFiLnR5cGUubmFtZSAhPT0gJ0VtcHR5JyApIHtcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17XG5cdFx0XHRcdFx0XHRib3hDbGFzcyArICcgc3VpLXRhYi1jb250ZW50JyArICggdGFiLnByb3BzLnZhbHVlID09PSB2YWx1ZSA/ICcgYWN0aXZlJyA6ICcnIClcblx0XHRcdFx0XHR9PlxuXHRcdFx0XHRcdFx0eyB0YWIucHJvcHMudmFsdWUgPT09IHZhbHVlICYmIHRhYiB9XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxSZWFjdC5GcmFnbWVudCAvPlxuXHRcdFx0KTtcblx0XHR9ICk7XG5cblx0XHRsZXQgdGFic0xhYmVsID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMubGFiZWwgJiYgJycgIT09IHRoaXMucHJvcHMubGFiZWwgKSB7XG5cdFx0XHR0YWJzTGFiZWwgPSAoXG5cdFx0XHRcdDxsYWJlbCBodG1sRm9yPXsgYGZvcm1pbmF0b3ItZmllbGQtJHsgdGhpcy5wcm9wcy5wcm9wZXJ0eSB9YCB9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWxhYmVsXCI+XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmxhYmVsIH1cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMubm90ZSAmJlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWxhYmVsLW5vdGVcIj4geyB0aGlzLnByb3BzLm5vdGUgfTwvc3Bhbj5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdDwvbGFiZWw+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGxldCBzZXR0aW5nc0xhYmVsID0gJyc7XG5cblx0XHRpZiAoIHRoaXMucHJvcHMuc2V0dGluZ3NMYWJlbCAmJiAnJyAhPT0gdGhpcy5wcm9wcy5zZXR0aW5nc0xhYmVsICkge1xuXHRcdFx0Y29uc3QgbGFiZWxDbGFzcyA9IHRoaXMucHJvcHMubGFiZWxDbGFzcyA/IHRoaXMucHJvcHMubGFiZWxDbGFzcyA6ICdzdWktc2V0dGluZ3MtbGFiZWwnO1xuXHRcdFx0c2V0dGluZ3NMYWJlbCA9IChcblx0XHRcdFx0PGxhYmVsIGNsYXNzTmFtZT17IGxhYmVsQ2xhc3MgfT5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuc2V0dGluZ3NMYWJlbCB9XG5cdFx0XHRcdDwvbGFiZWw+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGxldCBkZXNjcmlwdGlvbiA9ICcnO1xuXG5cdFx0aWYgKCB0aGlzLnByb3BzLmRlc2NyaXB0aW9uICYmICcnICE9PSB0aGlzLnByb3BzLmRlc2NyaXB0aW9uICkge1xuXHRcdFx0ZGVzY3JpcHRpb24gPSAoXG5cdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCJcblx0XHRcdFx0XHRzdHlsZT17IHsgbWFyZ2luQm90dG9tOiAxMCB9IH1cblx0XHRcdFx0PlxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5kZXNjcmlwdGlvbiB9XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0bGV0IHdyYXBwZXJDbGFzcyA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy53cmFwcGVyQ2xhc3MgKVxuXHRcdFx0PyB0aGlzLnByb3BzLndyYXBwZXJDbGFzc1xuXHRcdFx0OiAnJztcblxuXHRcdHdyYXBwZXJDbGFzcyA9IHRoaXMucHJvcHMuYmFzaWNUYWJzXG5cdFx0XHQ/IGBzdWktdGFicyBzdWktdGFicy1vdmVyZmxvdyAkeyB3cmFwcGVyQ2xhc3MgfWBcblx0XHRcdDogYHN1aS1zaWRlLXRhYnMgJHsgd3JhcHBlckNsYXNzIH1gO1xuXG5cdFx0bGV0IHRhYnNNYXJrdXAgPSAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT17IHdyYXBwZXJDbGFzcyB9PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLXRhYnMtbWVudVwiPlxuXHRcdFx0XHRcdHsgdGFiVGl0bGVzIH1cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9eyBjb250ZW50Q2xhc3MgfT5cblx0XHRcdFx0XHR7IHRhYkNvbnRlbnRzIH1cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cblx0XHRpZiAoICEgdGhpcy5wcm9wcy5zaW1wbGUgKSB7XG5cdFx0XHR0YWJzTWFya3VwID0gKFxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1mb3JtLWZpZWxkXCI+XG5cblx0XHRcdFx0XHR7IHNldHRpbmdzTGFiZWwgfVxuXG5cdFx0XHRcdFx0eyB0YWJzTGFiZWwgfVxuXG5cdFx0XHRcdFx0eyBkZXNjcmlwdGlvbiB9XG5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17IHdyYXBwZXJDbGFzcyB9PlxuXG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS10YWJzLW1lbnVcIj5cblx0XHRcdFx0XHRcdFx0eyB0YWJUaXRsZXMgfVxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXsgY29udGVudENsYXNzIH0+XG5cdFx0XHRcdFx0XHRcdHsgdGFiQ29udGVudHMgfVxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhYnNNYXJrdXA7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9pbnB1dHMvcmFkaW8tdGFicy5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvdyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjb2x1bW5zID0gUmVhY3QuQ2hpbGRyZW4ubWFwKFxuXHRcdFx0dGhpcy5wcm9wcy5jaGlsZHJlbixcblx0XHRcdGNoaWxkcmVuID0+IHtcblx0XHRcdFx0cmV0dXJuIGNoaWxkcmVuO1xuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9eyAnc3VpLXJvdycgKyAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5jbGFzcyApXG5cdFx0XHRcdD8gJyAnICsgdGhpcy5wcm9wcy5jbGFzc1xuXHRcdFx0XHQ6ICcnXG5cdFx0XHQpIH0+XG5cdFx0XHRcdHsgY29sdW1ucyB9XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MvY29udGFpbmVycy9yb3cuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFicyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblxuXHRcdHRoaXMuc3RhdGUgPSB7XG5cdFx0XHRhY3RpdmU6IHRoaXMucHJvcHMuZGVmYXVsdCA/IHRoaXMucHJvcHMuZGVmYXVsdCA6ICcnLFxuXHRcdH07XG5cdH1cblxuXHR0b2dnbGVWYWx1ZSggdmFsdWUgKSB7XG5cdFx0dGhpcy5zZXRTdGF0ZSgge1xuXHRcdFx0YWN0aXZlOiB2YWx1ZSxcblx0XHR9ICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgZGVmYXVsdFZhbHVlID0gdGhpcy5wcm9wcy5kZWZhdWx0ID8gdGhpcy5wcm9wcy5kZWZhdWx0IDogJyc7XG5cblx0XHRjb25zdCB0eXBlID0gdGhpcy5wcm9wcy50eXBlID8gdGhpcy5wcm9wcy50eXBlIDogJ3NpZGUtdGFicyc7XG5cblx0XHRjb25zdCBleHRyYUNsYXNzID0gdGhpcy5wcm9wcy5leHRyYUNsYXNzID8gdGhpcy5wcm9wcy5leHRyYUNsYXNzIDogJyc7XG5cblx0XHRjb25zdCB0YWJUaXRsZXMgPSBSZWFjdC5DaGlsZHJlbi5tYXAoIHRoaXMucHJvcHMuY2hpbGRyZW4sIHRhYiA9PiB7XG5cdFx0XHRpZiAoIF8uaXNVbmRlZmluZWQoIHRhYiApIHx8IF8uaXNOdWxsKCB0YWIgKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPXsgJ2Zvcm1pbmF0b3ItdG9nZ2xlIHN1aS10YWItaXRlbScgKyAoXG5cdFx0XHRcdFx0XHR0YWIucHJvcHMudmFsdWUgPT09IHRoaXMuc3RhdGUuYWN0aXZlID8gJyBhY3RpdmUnIDogJydcblx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHRvbkNsaWNrPXsgdGhpcy50b2dnbGVWYWx1ZS5iaW5kKCB0aGlzLCB0YWIucHJvcHMudmFsdWUgKSB9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7IHRhYi5wcm9wcy5sYWJlbCB9IHsgdGFiLnByb3BzLnJlcXVpcmVkICYmXG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZXJyb3JcIj4qPC9zcGFuPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQpO1xuXHRcdH0gKTtcblxuXHRcdGNvbnN0IHRhYkNvbnRlbnRzID0gUmVhY3QuQ2hpbGRyZW4ubWFwKCB0aGlzLnByb3BzLmNoaWxkcmVuLCB0YWIgPT4ge1xuXHRcdFx0aWYgKCBfLmlzVW5kZWZpbmVkKCB0YWIgKSB8fCBfLmlzTnVsbCggdGFiICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYm94Q2xhc3NWYWx1ZSA9ICEgXy5pc1VuZGVmaW5lZCggdGFiLnByb3BzLmJveENsYXNzICkgP1xuXHRcdFx0XHR0YWIucHJvcHMuYm94Q2xhc3MgOiAnc3VpLXRhYi1jb250ZW50JztcblxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9eyBib3hDbGFzc1ZhbHVlICsgKCB0YWIucHJvcHMudmFsdWUgPT09IHRoaXMuc3RhdGUuYWN0aXZlID8gJyBhY3RpdmUnIDogJycgKSB9PlxuXHRcdFx0XHRcdHsgdGFiLnByb3BzLnZhbHVlID09PSB0aGlzLnN0YXRlLmFjdGl2ZSAmJiB0YWIgfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdCk7XG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPXsgYHN1aS0keyB0eXBlIH0gJHsgZXh0cmFDbGFzcyB9YCB9PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS10YWJzLW1lbnVcIj5cblx0XHRcdFx0XHR7IHRhYlRpdGxlcyB9XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLXRhYnMtY29udGVudFwiPlxuXHRcdFx0XHRcdHsgdGFiQ29udGVudHMgfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9jb250YWluZXJzL3RhYnMuanMiLCJpbXBvcnQgJCRvYnNlcnZhYmxlIGZyb20gJ3N5bWJvbC1vYnNlcnZhYmxlJztcblxuLyoqXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICogSWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXG4gKi9cbnZhciBBY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogJ0BAcmVkdXgvSU5JVCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoJycpLmpvaW4oJy4nKSxcbiAgUkVQTEFDRTogJ0BAcmVkdXgvUkVQTEFDRScgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoJycpLmpvaW4oJy4nKVxufTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmogVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGFyZ3VtZW50IGFwcGVhcnMgdG8gYmUgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICgodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBwcm90byA9IG9iajtcbiAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBSZWR1eCBzdG9yZSB0aGF0IGhvbGRzIHRoZSBzdGF0ZSB0cmVlLlxuICogVGhlIG9ubHkgd2F5IHRvIGNoYW5nZSB0aGUgZGF0YSBpbiB0aGUgc3RvcmUgaXMgdG8gY2FsbCBgZGlzcGF0Y2goKWAgb24gaXQuXG4gKlxuICogVGhlcmUgc2hvdWxkIG9ubHkgYmUgYSBzaW5nbGUgc3RvcmUgaW4geW91ciBhcHAuIFRvIHNwZWNpZnkgaG93IGRpZmZlcmVudFxuICogcGFydHMgb2YgdGhlIHN0YXRlIHRyZWUgcmVzcG9uZCB0byBhY3Rpb25zLCB5b3UgbWF5IGNvbWJpbmUgc2V2ZXJhbCByZWR1Y2Vyc1xuICogaW50byBhIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIGJ5IHVzaW5nIGBjb21iaW5lUmVkdWNlcnNgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZHVjZXIgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5leHQgc3RhdGUgdHJlZSwgZ2l2ZW5cbiAqIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBhY3Rpb24gdG8gaGFuZGxlLlxuICpcbiAqIEBwYXJhbSB7YW55fSBbcHJlbG9hZGVkU3RhdGVdIFRoZSBpbml0aWFsIHN0YXRlLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gaHlkcmF0ZSB0aGUgc3RhdGUgZnJvbSB0aGUgc2VydmVyIGluIHVuaXZlcnNhbCBhcHBzLCBvciB0byByZXN0b3JlIGFcbiAqIHByZXZpb3VzbHkgc2VyaWFsaXplZCB1c2VyIHNlc3Npb24uXG4gKiBJZiB5b3UgdXNlIGBjb21iaW5lUmVkdWNlcnNgIHRvIHByb2R1Y2UgdGhlIHJvb3QgcmVkdWNlciBmdW5jdGlvbiwgdGhpcyBtdXN0IGJlXG4gKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBgY29tYmluZVJlZHVjZXJzYCBrZXlzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtlbmhhbmNlcl0gVGhlIHN0b3JlIGVuaGFuY2VyLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gZW5oYW5jZSB0aGUgc3RvcmUgd2l0aCB0aGlyZC1wYXJ0eSBjYXBhYmlsaXRpZXMgc3VjaCBhcyBtaWRkbGV3YXJlLFxuICogdGltZSB0cmF2ZWwsIHBlcnNpc3RlbmNlLCBldGMuIFRoZSBvbmx5IHN0b3JlIGVuaGFuY2VyIHRoYXQgc2hpcHMgd2l0aCBSZWR1eFxuICogaXMgYGFwcGx5TWlkZGxld2FyZSgpYC5cbiAqXG4gKiBAcmV0dXJucyB7U3RvcmV9IEEgUmVkdXggc3RvcmUgdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBzdGF0ZSwgZGlzcGF0Y2ggYWN0aW9uc1xuICogYW5kIHN1YnNjcmliZSB0byBjaGFuZ2VzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgdmFyIF9yZWYyO1xuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGVuaGFuY2VyID0gcHJlbG9hZGVkU3RhdGU7XG4gICAgcHJlbG9hZGVkU3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIGVuaGFuY2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICB2YXIgY3VycmVudFN0YXRlID0gcHJlbG9hZGVkU3RhdGU7XG4gIHZhciBjdXJyZW50TGlzdGVuZXJzID0gW107XG4gIHZhciBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycztcbiAgdmFyIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCkge1xuICAgIGlmIChuZXh0TGlzdGVuZXJzID09PSBjdXJyZW50TGlzdGVuZXJzKSB7XG4gICAgICBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycy5zbGljZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgc3RhdGUgdHJlZSBtYW5hZ2VkIGJ5IHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHJldHVybnMge2FueX0gVGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG1heSBub3QgY2FsbCBzdG9yZS5nZXRTdGF0ZSgpIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gJyArICdUaGUgcmVkdWNlciBoYXMgYWxyZWFkeSByZWNlaXZlZCB0aGUgc3RhdGUgYXMgYW4gYXJndW1lbnQuICcgKyAnUGFzcyBpdCBkb3duIGZyb20gdGhlIHRvcCByZWR1Y2VyIGluc3RlYWQgb2YgcmVhZGluZyBpdCBmcm9tIHRoZSBzdG9yZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbWF5IG5vdCBjYWxsIHN0b3JlLnN1YnNjcmliZSgpIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gJyArICdJZiB5b3Ugd291bGQgbGlrZSB0byBiZSBub3RpZmllZCBhZnRlciB0aGUgc3RvcmUgaGFzIGJlZW4gdXBkYXRlZCwgc3Vic2NyaWJlIGZyb20gYSAnICsgJ2NvbXBvbmVudCBhbmQgaW52b2tlIHN0b3JlLmdldFN0YXRlKCkgaW4gdGhlIGNhbGxiYWNrIHRvIGFjY2VzcyB0aGUgbGF0ZXN0IHN0YXRlLiAnICsgJ1NlZSBodHRwczovL3JlZHV4LmpzLm9yZy9hcGktcmVmZXJlbmNlL3N0b3JlI3N1YnNjcmliZShsaXN0ZW5lcikgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcblxuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICBuZXh0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgaWYgKCFpc1N1YnNjcmliZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtYXkgbm90IHVuc3Vic2NyaWJlIGZyb20gYSBzdG9yZSBsaXN0ZW5lciB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuICcgKyAnU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS1yZWZlcmVuY2Uvc3RvcmUjc3Vic2NyaWJlKGxpc3RlbmVyKSBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICAgICAgfVxuXG4gICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcblxuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgICAgdmFyIGluZGV4ID0gbmV4dExpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIG5leHRMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gYWN0aW9uLiBJdCBpcyB0aGUgb25seSB3YXkgdG8gdHJpZ2dlciBhIHN0YXRlIGNoYW5nZS5cbiAgICpcbiAgICogVGhlIGByZWR1Y2VyYCBmdW5jdGlvbiwgdXNlZCB0byBjcmVhdGUgdGhlIHN0b3JlLCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuICAgKiBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBnaXZlbiBgYWN0aW9uYC4gSXRzIHJldHVybiB2YWx1ZSB3aWxsXG4gICAqIGJlIGNvbnNpZGVyZWQgdGhlICoqbmV4dCoqIHN0YXRlIG9mIHRoZSB0cmVlLCBhbmQgdGhlIGNoYW5nZSBsaXN0ZW5lcnNcbiAgICogd2lsbCBiZSBub3RpZmllZC5cbiAgICpcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBwbGFpbiBvYmplY3QgYWN0aW9ucy4gSWYgeW91IHdhbnQgdG9cbiAgICogZGlzcGF0Y2ggYSBQcm9taXNlLCBhbiBPYnNlcnZhYmxlLCBhIHRodW5rLCBvciBzb21ldGhpbmcgZWxzZSwgeW91IG5lZWQgdG9cbiAgICogd3JhcCB5b3VyIHN0b3JlIGNyZWF0aW5nIGZ1bmN0aW9uIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbWlkZGxld2FyZS4gRm9yXG4gICAqIGV4YW1wbGUsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGByZWR1eC10aHVua2AgcGFja2FnZS4gRXZlbiB0aGVcbiAgICogbWlkZGxld2FyZSB3aWxsIGV2ZW50dWFsbHkgZGlzcGF0Y2ggcGxhaW4gb2JqZWN0IGFjdGlvbnMgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gQSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIOKAnHdoYXQgY2hhbmdlZOKAnS4gSXQgaXNcbiAgICogYSBnb29kIGlkZWEgdG8ga2VlcCBhY3Rpb25zIHNlcmlhbGl6YWJsZSBzbyB5b3UgY2FuIHJlY29yZCBhbmQgcmVwbGF5IHVzZXJcbiAgICogc2Vzc2lvbnMsIG9yIHVzZSB0aGUgdGltZSB0cmF2ZWxsaW5nIGByZWR1eC1kZXZ0b29sc2AuIEFuIGFjdGlvbiBtdXN0IGhhdmVcbiAgICogYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggbWF5IG5vdCBiZSBgdW5kZWZpbmVkYC4gSXQgaXMgYSBnb29kIGlkZWEgdG8gdXNlXG4gICAqIHN0cmluZyBjb25zdGFudHMgZm9yIGFjdGlvbiB0eXBlcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gRm9yIGNvbnZlbmllbmNlLCB0aGUgc2FtZSBhY3Rpb24gb2JqZWN0IHlvdSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQsIGlmIHlvdSB1c2UgYSBjdXN0b20gbWlkZGxld2FyZSwgaXQgbWF5IHdyYXAgYGRpc3BhdGNoKClgIHRvXG4gICAqIHJldHVybiBzb21ldGhpbmcgZWxzZSAoZm9yIGV4YW1wbGUsIGEgUHJvbWlzZSB5b3UgY2FuIGF3YWl0KS5cbiAgICovXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiAnICsgJ1VzZSBjdXN0b20gbWlkZGxld2FyZSBmb3IgYXN5bmMgYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuICcgKyAnSGF2ZSB5b3UgbWlzc3BlbGxlZCBhIGNvbnN0YW50PycpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXJzIG1heSBub3QgZGlzcGF0Y2ggYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50UmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycyA9IG5leHRMaXN0ZW5lcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgcmVkdWNlciBjdXJyZW50bHkgdXNlZCBieSB0aGUgc3RvcmUgdG8gY2FsY3VsYXRlIHRoZSBzdGF0ZS5cbiAgICpcbiAgICogWW91IG1pZ2h0IG5lZWQgdGhpcyBpZiB5b3VyIGFwcCBpbXBsZW1lbnRzIGNvZGUgc3BsaXR0aW5nIGFuZCB5b3Ugd2FudCB0b1xuICAgKiBsb2FkIHNvbWUgb2YgdGhlIHJlZHVjZXJzIGR5bmFtaWNhbGx5LiBZb3UgbWlnaHQgYWxzbyBuZWVkIHRoaXMgaWYgeW91XG4gICAqIGltcGxlbWVudCBhIGhvdCByZWxvYWRpbmcgbWVjaGFuaXNtIGZvciBSZWR1eC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFJlZHVjZXIgVGhlIHJlZHVjZXIgZm9yIHRoZSBzdG9yZSB0byB1c2UgaW5zdGVhZC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlUmVkdWNlcihuZXh0UmVkdWNlcikge1xuICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgY3VycmVudFJlZHVjZXIgPSBuZXh0UmVkdWNlcjtcbiAgICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLlJFUExBQ0UgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJvcGVyYWJpbGl0eSBwb2ludCBmb3Igb2JzZXJ2YWJsZS9yZWFjdGl2ZSBsaWJyYXJpZXMuXG4gICAqIEByZXR1cm5zIHtvYnNlcnZhYmxlfSBBIG1pbmltYWwgb2JzZXJ2YWJsZSBvZiBzdGF0ZSBjaGFuZ2VzLlxuICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBvYnNlcnZhYmxlIHByb3Bvc2FsOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYnNlcnZhYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyB7c3Vic2NyaXB0aW9ufSBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICgodHlwZW9mIG9ic2VydmVyID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYnNlcnZlcikpICE9PSAnb2JqZWN0JyB8fCBvYnNlcnZlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvYnNlcnZlU3RhdGUoKSB7XG4gICAgICAgICAgaWYgKG9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JzZXJ2ZVN0YXRlKCk7XG4gICAgICAgIHZhciB1bnN1YnNjcmliZSA9IG91dGVyU3Vic2NyaWJlKG9ic2VydmVTdGF0ZSk7XG4gICAgICAgIHJldHVybiB7IHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSB9O1xuICAgICAgfVxuICAgIH0sIF9yZWZbJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9yZWY7XG4gIH1cblxuICAvLyBXaGVuIGEgc3RvcmUgaXMgY3JlYXRlZCwgYW4gXCJJTklUXCIgYWN0aW9uIGlzIGRpc3BhdGNoZWQgc28gdGhhdCBldmVyeVxuICAvLyByZWR1Y2VyIHJldHVybnMgdGhlaXIgaW5pdGlhbCBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgLy8gdGhlIGluaXRpYWwgc3RhdGUgdHJlZS5cbiAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMlskJG9ic2VydmFibGVdID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59XG5cbi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGlmIHlvdSBlbmFibGVcbiAgICAvLyBcImJyZWFrIG9uIGFsbCBleGNlcHRpb25zXCIgaW4geW91ciBjb25zb2xlLFxuICAgIC8vIGl0IHdvdWxkIHBhdXNlIHRoZSBleGVjdXRpb24gYXQgdGhpcyBsaW5lLlxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfSBjYXRjaCAoZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxufVxuXG5mdW5jdGlvbiBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbikge1xuICB2YXIgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgdmFyIGFjdGlvbkRlc2NyaXB0aW9uID0gYWN0aW9uVHlwZSAmJiAnYWN0aW9uIFwiJyArIFN0cmluZyhhY3Rpb25UeXBlKSArICdcIicgfHwgJ2FuIGFjdGlvbic7XG5cbiAgcmV0dXJuICdHaXZlbiAnICsgYWN0aW9uRGVzY3JpcHRpb24gKyAnLCByZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQuICcgKyAnVG8gaWdub3JlIGFuIGFjdGlvbiwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIHByZXZpb3VzIHN0YXRlLiAnICsgJ0lmIHlvdSB3YW50IHRoaXMgcmVkdWNlciB0byBob2xkIG5vIHZhbHVlLCB5b3UgY2FuIHJldHVybiBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLic7XG59XG5cbmZ1bmN0aW9uIGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2UoaW5wdXRTdGF0ZSwgcmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGFyZ3VtZW50TmFtZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gQWN0aW9uVHlwZXMuSU5JVCA/ICdwcmVsb2FkZWRTdGF0ZSBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU3RvcmUnIDogJ3ByZXZpb3VzIHN0YXRlIHJlY2VpdmVkIGJ5IHRoZSByZWR1Y2VyJztcblxuICBpZiAocmVkdWNlcktleXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdTdG9yZSBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgcmVkdWNlci4gTWFrZSBzdXJlIHRoZSBhcmd1bWVudCBwYXNzZWQgJyArICd0byBjb21iaW5lUmVkdWNlcnMgaXMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgcmVkdWNlcnMuJztcbiAgfVxuXG4gIGlmICghaXNQbGFpbk9iamVjdChpbnB1dFN0YXRlKSkge1xuICAgIHJldHVybiAnVGhlICcgKyBhcmd1bWVudE5hbWUgKyAnIGhhcyB1bmV4cGVjdGVkIHR5cGUgb2YgXCInICsge30udG9TdHJpbmcuY2FsbChpbnB1dFN0YXRlKS5tYXRjaCgvXFxzKFthLXp8QS1aXSspLylbMV0gKyAnXCIuIEV4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgJyArICgna2V5czogXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCInKTtcbiAgfVxuXG4gIHZhciB1bmV4cGVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGlucHV0U3RhdGUpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICFyZWR1Y2Vycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICF1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XTtcbiAgfSk7XG5cbiAgdW5leHBlY3RlZEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlW2tleV0gPSB0cnVlO1xuICB9KTtcblxuICBpZiAoYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBBY3Rpb25UeXBlcy5SRVBMQUNFKSByZXR1cm47XG5cbiAgaWYgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gJ1VuZXhwZWN0ZWQgJyArICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gJ2tleXMnIDogJ2tleScpICsgJyAnICsgKCdcIicgKyB1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKSArICdcIiBmb3VuZCBpbiAnICsgYXJndW1lbnROYW1lICsgJy4gJykgKyAnRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiAnICsgKCdcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRSZWR1Y2VyU2hhcGUocmVkdWNlcnMpIHtcbiAgT2JqZWN0LmtleXMocmVkdWNlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciByZWR1Y2VyID0gcmVkdWNlcnNba2V5XTtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICAgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLiAnICsgJ0lmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCAnICsgJ2V4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgJyArICdub3QgYmUgdW5kZWZpbmVkLiBJZiB5b3UgZG9uXFwndCB3YW50IHRvIHNldCBhIHZhbHVlIGZvciB0aGlzIHJlZHVjZXIsICcgKyAneW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9ICdAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OXycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoJycpLmpvaW4oJy4nKTtcbiAgICBpZiAodHlwZW9mIHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IHR5cGUgfSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIHByb2JlZCB3aXRoIGEgcmFuZG9tIHR5cGUuICcgKyAoJ0RvblxcJ3QgdHJ5IHRvIGhhbmRsZSAnICsgQWN0aW9uVHlwZXMuSU5JVCArICcgb3Igb3RoZXIgYWN0aW9ucyBpbiBcInJlZHV4LypcIiAnKSArICduYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSAnICsgJ2N1cnJlbnQgc3RhdGUgZm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsICcgKyAnaW4gd2hpY2ggY2FzZSB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUsIHJlZ2FyZGxlc3Mgb2YgdGhlICcgKyAnYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLCBidXQgY2FuIGJlIG51bGwuJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgcmVkdWNlciBmdW5jdGlvbnMsIGludG8gYSBzaW5nbGVcbiAqIHJlZHVjZXIgZnVuY3Rpb24uIEl0IHdpbGwgY2FsbCBldmVyeSBjaGlsZCByZWR1Y2VyLCBhbmQgZ2F0aGVyIHRoZWlyIHJlc3VsdHNcbiAqIGludG8gYSBzaW5nbGUgc3RhdGUgb2JqZWN0LCB3aG9zZSBrZXlzIGNvcnJlc3BvbmQgdG8gdGhlIGtleXMgb2YgdGhlIHBhc3NlZFxuICogcmVkdWNlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlZHVjZXJzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgY29ycmVzcG9uZCB0byBkaWZmZXJlbnRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW5cbiAqIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzIHJlZHVjZXJzYCBzeW50YXguIFRoZSByZWR1Y2VycyBtYXkgbmV2ZXIgcmV0dXJuXG4gKiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpciBpbml0aWFsIHN0YXRlXG4gKiBpZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZW0gd2FzIHVuZGVmaW5lZCwgYW5kIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnlcbiAqIHVucmVjb2duaXplZCBhY3Rpb24uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHJlZHVjZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGV2ZXJ5IHJlZHVjZXIgaW5zaWRlIHRoZVxuICogcGFzc2VkIG9iamVjdCwgYW5kIGJ1aWxkcyBhIHN0YXRlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICovXG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IHJlZHVjZXJLZXlzW2ldO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2FybmluZygnTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcblxuICB2YXIgdW5leHBlY3RlZEtleUNhY2hlID0gdm9pZCAwO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIHNoYXBlQXNzZXJ0aW9uRXJyb3IgPSB2b2lkIDA7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UmVkdWNlclNoYXBlKGZpbmFsUmVkdWNlcnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2hhcGVBc3NlcnRpb25FcnJvciA9IGU7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gY29tYmluYXRpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzWzFdO1xuXG4gICAgaWYgKHNoYXBlQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICB3YXJuaW5nKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0U3RhdGUgPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfa2V5ID0gZmluYWxSZWR1Y2VyS2V5c1tfaV07XG4gICAgICB2YXIgcmVkdWNlciA9IGZpbmFsUmVkdWNlcnNbX2tleV07XG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW19rZXldO1xuICAgICAgdmFyIG5leHRTdGF0ZUZvcktleSA9IHJlZHVjZXIocHJldmlvdXNTdGF0ZUZvcktleSwgYWN0aW9uKTtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2UoX2tleSwgYWN0aW9uKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGVbX2tleV0gPSBuZXh0U3RhdGVGb3JLZXk7XG4gICAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBuZXh0U3RhdGVGb3JLZXkgIT09IHByZXZpb3VzU3RhdGVGb3JLZXk7XG4gICAgfVxuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uIGNyZWF0b3JzLCBpbnRvIGFuIG9iamVjdCB3aXRoIHRoZVxuICogc2FtZSBrZXlzLCBidXQgd2l0aCBldmVyeSBmdW5jdGlvbiB3cmFwcGVkIGludG8gYSBgZGlzcGF0Y2hgIGNhbGwgc28gdGhleVxuICogbWF5IGJlIGludm9rZWQgZGlyZWN0bHkuIFRoaXMgaXMganVzdCBhIGNvbnZlbmllbmNlIG1ldGhvZCwgYXMgeW91IGNhbiBjYWxsXG4gKiBgc3RvcmUuZGlzcGF0Y2goTXlBY3Rpb25DcmVhdG9ycy5kb1NvbWV0aGluZygpKWAgeW91cnNlbGYganVzdCBmaW5lLlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgeW91IGNhbiBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxuICogYW5kIGdldCBhIGZ1bmN0aW9uIGluIHJldHVybi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXG4gKiBjcmVhdG9yIGZ1bmN0aW9ucy4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXNgXG4gKiBzeW50YXguIFlvdSBtYXkgYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3BhdGNoIFRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiB5b3VyIFJlZHV4XG4gKiBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBUaGUgb2JqZWN0IG1pbWlja2luZyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBidXQgd2l0aFxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcbiAgfVxuXG4gIGlmICgodHlwZW9mIGFjdGlvbkNyZWF0b3JzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhY3Rpb25DcmVhdG9ycykpICE9PSAnb2JqZWN0JyB8fCBhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmluZEFjdGlvbkNyZWF0b3JzIGV4cGVjdGVkIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uLCBpbnN0ZWFkIHJlY2VpdmVkICcgKyAoYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGFjdGlvbkNyZWF0b3JzKSkgKyAnLiAnICsgJ0RpZCB5b3Ugd3JpdGUgXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiIGluc3RlYWQgb2YgXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXCI/Jyk7XG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFjdGlvbkNyZWF0b3JzKTtcbiAgdmFyIGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFyIGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn1cblxuLyoqXG4gKiBDb21wb3NlcyBzaW5nbGUtYXJndW1lbnQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC4gVGhlIHJpZ2h0bW9zdFxuICogZnVuY3Rpb24gY2FuIHRha2UgbXVsdGlwbGUgYXJndW1lbnRzIGFzIGl0IHByb3ZpZGVzIHRoZSBzaWduYXR1cmUgZm9yXG4gKiB0aGUgcmVzdWx0aW5nIGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jcyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gb2J0YWluZWQgYnkgY29tcG9zaW5nIHRoZSBhcmd1bWVudCBmdW5jdGlvbnNcbiAqIGZyb20gcmlnaHQgdG8gbGVmdC4gRm9yIGV4YW1wbGUsIGNvbXBvc2UoZiwgZywgaCkgaXMgaWRlbnRpY2FsIHRvIGRvaW5nXG4gKiAoLi4uYXJncykgPT4gZihnKGgoLi4uYXJncykpKS5cbiAqL1xuXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9O1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmdW5jc1swXTtcbiAgfVxuXG4gIHJldHVybiBmdW5jcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGEoYi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdG9yZSBlbmhhbmNlciB0aGF0IGFwcGxpZXMgbWlkZGxld2FyZSB0byB0aGUgZGlzcGF0Y2ggbWV0aG9kXG4gKiBvZiB0aGUgUmVkdXggc3RvcmUuIFRoaXMgaXMgaGFuZHkgZm9yIGEgdmFyaWV0eSBvZiB0YXNrcywgc3VjaCBhcyBleHByZXNzaW5nXG4gKiBhc3luY2hyb25vdXMgYWN0aW9ucyBpbiBhIGNvbmNpc2UgbWFubmVyLCBvciBsb2dnaW5nIGV2ZXJ5IGFjdGlvbiBwYXlsb2FkLlxuICpcbiAqIFNlZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UgYXMgYW4gZXhhbXBsZSBvZiB0aGUgUmVkdXggbWlkZGxld2FyZS5cbiAqXG4gKiBCZWNhdXNlIG1pZGRsZXdhcmUgaXMgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzLCB0aGlzIHNob3VsZCBiZSB0aGUgZmlyc3RcbiAqIHN0b3JlIGVuaGFuY2VyIGluIHRoZSBjb21wb3NpdGlvbiBjaGFpbi5cbiAqXG4gKiBOb3RlIHRoYXQgZWFjaCBtaWRkbGV3YXJlIHdpbGwgYmUgZ2l2ZW4gdGhlIGBkaXNwYXRjaGAgYW5kIGBnZXRTdGF0ZWAgZnVuY3Rpb25zXG4gKiBhcyBuYW1lZCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gbWlkZGxld2FyZXMgVGhlIG1pZGRsZXdhcmUgY2hhaW4gdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBzdG9yZSBlbmhhbmNlciBhcHBseWluZyB0aGUgbWlkZGxld2FyZS5cbiAqL1xuZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaWRkbGV3YXJlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY3JlYXRlU3RvcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RvcmUgPSBjcmVhdGVTdG9yZS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgdmFyIF9kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rpc3BhdGNoaW5nIHdoaWxlIGNvbnN0cnVjdGluZyB5b3VyIG1pZGRsZXdhcmUgaXMgbm90IGFsbG93ZWQuICcgKyAnT3RoZXIgbWlkZGxld2FyZSB3b3VsZCBub3QgYmUgYXBwbGllZCB0byB0aGlzIGRpc3BhdGNoLicpO1xuICAgICAgfTtcblxuICAgICAgdmFyIG1pZGRsZXdhcmVBUEkgPSB7XG4gICAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICAgICAgICAgIHJldHVybiBfZGlzcGF0Y2guYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGNoYWluID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgICAgIHJldHVybiBtaWRkbGV3YXJlKG1pZGRsZXdhcmVBUEkpO1xuICAgICAgfSk7XG4gICAgICBfZGlzcGF0Y2ggPSBjb21wb3NlLmFwcGx5KHVuZGVmaW5lZCwgY2hhaW4pKHN0b3JlLmRpc3BhdGNoKTtcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdG9yZSwge1xuICAgICAgICBkaXNwYXRjaDogX2Rpc3BhdGNoXG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xufVxuXG4vKlxuICogVGhpcyBpcyBhIGR1bW15IGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBmdW5jdGlvbiBuYW1lIGhhcyBiZWVuIGFsdGVyZWQgYnkgbWluaWZpY2F0aW9uLlxuICogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxuICovXG5mdW5jdGlvbiBpc0NydXNoZWQoKSB7fVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgaXNDcnVzaGVkLm5hbWUgPT09ICdzdHJpbmcnICYmIGlzQ3J1c2hlZC5uYW1lICE9PSAnaXNDcnVzaGVkJykge1xuICB3YXJuaW5nKFwiWW91IGFyZSBjdXJyZW50bHkgdXNpbmcgbWluaWZpZWQgY29kZSBvdXRzaWRlIG9mIE5PREVfRU5WID09PSAncHJvZHVjdGlvbicuIFwiICsgJ1RoaXMgbWVhbnMgdGhhdCB5b3UgYXJlIHJ1bm5pbmcgYSBzbG93ZXIgZGV2ZWxvcG1lbnQgYnVpbGQgb2YgUmVkdXguICcgKyAnWW91IGNhbiB1c2UgbG9vc2UtZW52aWZ5IChodHRwczovL2dpdGh1Yi5jb20vemVydG9zaC9sb29zZS1lbnZpZnkpIGZvciBicm93c2VyaWZ5ICcgKyAnb3IgRGVmaW5lUGx1Z2luIGZvciB3ZWJwYWNrIChodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMwMDMwMDMxKSAnICsgJ3RvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVN0b3JlLCBjb21iaW5lUmVkdWNlcnMsIGJpbmRBY3Rpb25DcmVhdG9ycywgYXBwbHlNaWRkbGV3YXJlLCBjb21wb3NlLCBBY3Rpb25UeXBlcyBhcyBfX0RPX05PVF9VU0VfX0FjdGlvblR5cGVzIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9yZWR1eC5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFbXB0eSgpIHtcblx0cmV0dXJuICcnO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzL2NvbnRhaW5lcnMvZW1wdHkuanMiLCJpbXBvcnQgUHJvdmlkZXIsIHsgY3JlYXRlUHJvdmlkZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvUHJvdmlkZXInO1xuaW1wb3J0IGNvbm5lY3RBZHZhbmNlZCBmcm9tICcuL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkJztcbmltcG9ydCBjb25uZWN0IGZyb20gJy4vY29ubmVjdC9jb25uZWN0JztcblxuZXhwb3J0IHsgUHJvdmlkZXIsIGNyZWF0ZVByb3ZpZGVyLCBjb25uZWN0QWR2YW5jZWQsIGNvbm5lY3QgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBpc0J1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpO1xuXG4vKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0W2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNldHRpbmdzUm93IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNvbnRlbnQgPSBSZWFjdC5DaGlsZHJlbi5tYXAoXG5cdFx0XHR0aGlzLnByb3BzLmNoaWxkcmVuLFxuXHRcdFx0Y2hpbGRyZW4gPT4ge1xuXHRcdFx0XHRyZXR1cm4gY2hpbGRyZW47XG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGxldCBsYWJlbCA9ICcnO1xuXG5cdFx0aWYgKCB0aGlzLnByb3BzLmxhYmVsICYmICcnICE9PSB0aGlzLnByb3BzLmxhYmVsICkge1xuXHRcdFx0bGFiZWwgPSAoXG5cdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT17XG5cdFx0XHRcdFx0J3N1aS1zZXR0aW5ncy1sYWJlbCcgK1xuXHRcdFx0XHRcdGAkeyB0aGlzLnByb3BzLmxhYmVsRGFyayA9PT0gdHJ1ZSA/ICcgc3VpLWRhcmsnIDogJycgfWBcblx0XHRcdFx0fT5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMubGFiZWwgfVxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGxldCBkZXNjcmlwdGlvbiA9ICcnO1xuXHRcdGxldCBkZXNjcmlwdGlvblNwYWNpbmcgPSAxMDtcblxuXHRcdGlmICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmRlc2NyaXB0aW9uU3BhY2luZyApICYmICcnICE9PSB0aGlzLnByb3BzLmRlc2NyaXB0aW9uU3BhY2luZyApIHtcblx0XHRcdGRlc2NyaXB0aW9uU3BhY2luZyA9IHRoaXMucHJvcHMuZGVzY3JpcHRpb25TcGFjaW5nO1xuXHRcdH1cblxuXHRcdGlmICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmRlc2NyaXB0aW9uICkgJiYgJycgIT09IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gKSB7XG5cdFx0XHRpZiAoIHRoaXMucHJvcHMuc2lkZWJhciA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGRlc2NyaXB0aW9uID0gKFxuXHRcdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIlxuXHRcdFx0XHRcdFx0c3R5bGU9eyB7IG1hcmdpbkJvdHRvbTogZGVzY3JpcHRpb25TcGFjaW5nICsgJ3B4JyB9IH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlc2NyaXB0aW9uID0gKFxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPnsgdGhpcy5wcm9wcy5kZXNjcmlwdGlvbiB9PC9zcGFuPlxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCBzaWRlYmFyID0gJyc7XG5cblx0XHRpZiAoXG5cdFx0XHQoIHRoaXMucHJvcHMubGFiZWwgJiYgJycgIT09IHRoaXMucHJvcHMubGFiZWwgKSB8fFxuXHRcdFx0KCB0aGlzLnByb3BzLmRlc2NyaXB0aW9uICYmICcnICE9PSB0aGlzLnByb3BzLmRlc2NyaXB0aW9uIClcblx0XHQpIHtcblx0XHRcdHNpZGViYXIgPSAoXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMVwiPlxuXHRcdFx0XHRcdHsgbGFiZWwgfVxuXHRcdFx0XHRcdHsgZGVzY3JpcHRpb24gfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgY29uZGl0aW9uYWxTdHlsZXMgPSB0aGlzLnByb3BzLmxhc3RDaGlsZFxuXHRcdFx0PyB7IG1hcmdpbkJvdHRvbTogMCwgYm9yZGVyQm90dG9tOiAndW5zZXQnIH1cblx0XHRcdDoge307XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLXJvd1wiIHN0eWxlPXsgY29uZGl0aW9uYWxTdHlsZXMgfT5cblx0XHRcdFx0eyAoIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2lkZWJhciApIHx8IHRoaXMucHJvcHMuc2lkZWJhciAhPT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRcdHNpZGViYXJcblx0XHRcdFx0fVxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3MtY29sLTJcIj5cblx0XHRcdFx0XHR7ICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNpZGViYXIgKSAmJiB0aGlzLnByb3BzLnNpZGViYXIgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0XHRcdGxhYmVsXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHsgKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2lkZWJhciApICYmIHRoaXMucHJvcHMuc2lkZWJhciA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRcdFx0ZGVzY3JpcHRpb25cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0eyBjb250ZW50IH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MvY29udGFpbmVycy9zZXR0aW5ncy1yb3cuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWlTZWxlY3QyIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUuYmluZCggdGhpcyApO1xuXHRcdHRoaXMuYWZ0ZXJTYXZlID0gdGhpcy5hZnRlclNhdmUuYmluZCggdGhpcyApO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0dGhpcy4kZWwgPSBqUXVlcnkoIHRoaXMuZWwgKTtcblxuXHRcdGNvbnN0IHBhcmVudCA9IHRoaXMuJGVsLmNsb3Nlc3QoICcuc3VpLW1vZGFsLWNvbnRlbnQnICk7XG5cdFx0Y29uc3QgcGFyZW50SWQgPSBwYXJlbnQuYXR0ciggJ2lkJyApO1xuXHRcdGNvbnN0IGhhc1NlYXJjaCA9IHRoaXMucHJvcHMuaGFzU2VhcmNoID8gMCA6IC0xO1xuXG5cdFx0Y29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG5cdFx0XHR7XG5cdFx0XHRcdGRyb3Bkb3duUGFyZW50OiAoIHBhcmVudC5sZW5ndGggKVxuXHRcdFx0XHRcdD8galF1ZXJ5KCAnIycgKyBwYXJlbnRJZCApXG5cdFx0XHRcdFx0OiBqUXVlcnkoICdib2R5W2NsYXNzKj1cInN1aS1cIl0nICksXG5cdFx0XHRcdG1pbmltdW1SZXN1bHRzRm9yU2VhcmNoOiBoYXNTZWFyY2gsXG5cdFx0XHRcdGRyb3Bkb3duQ3NzQ2xhc3M6IHRoaXMuJGVsLmhhc0NsYXNzKCAnc3VpLXNlbGVjdC1zbScgKVxuXHRcdFx0XHRcdD8gJ3N1aS1zZWxlY3QtZHJvcGRvd24tc20nXG5cdFx0XHRcdFx0OiAnJyxcblx0XHRcdFx0d2lkdGg6ICcxMDAlJyxcblx0XHRcdH0sXG5cdFx0XHR0aGlzLnByb3BzLm9wdGlvbnNcblx0XHQpO1xuXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy4kZWwuU1VJc2VsZWN0MiA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHRoaXMuJGVsLlNVSXNlbGVjdDIoIG9wdGlvbnMgKTtcblx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdGhpcy4kZWwuRlVJc2VsZWN0MiA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHRoaXMuJGVsLkZVSXNlbGVjdDIoIG9wdGlvbnMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgRXJyb3IoICdTVUkgU2VsZWN0MiBub3QgaW5pdGlhdGVkJyApO1xuXHRcdH1cblxuXHRcdHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLiRlbC5vbiggJ2NoYW5nZScsIHRoaXMudXBkYXRlVmFsdWUgKTtcblxuXHRcdGlmICggdGhpcy5wcm9wcy50cmlnZ2VyQ2hhbmdlICkge1xuXHRcdFx0dGhpcy4kZWwudHJpZ2dlciggJ2NoYW5nZScgKTtcblx0XHR9XG5cdH1cblxuXHR1cGRhdGVWYWx1ZSggZSApIHtcblx0XHRjb25zdCB2YWx1ZSA9IGpRdWVyeSggZS50YXJnZXQgKS52YWwoKTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIG9uIGZpZWxkIHNldHRpbmdzXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5wcm9wcy51cGRhdGVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdC8vIFVwZGF0ZSBmaWVsZCBzdGF0ZVxuXHRcdFx0dGhpcy5wcm9wcy51cGRhdGVQcm9wZXJ0eSggdGhpcy5wcm9wcy5wcm9wZXJ0eSwgdmFsdWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVXBkYXRlIHN0b3JlXG5cdFx0XHR0aGlzLnByb3BzLmFjdGlvbnMuc2V0dGluZ3NBY3Rpb25zLnVwZGF0ZVNldHRpbmcoIHRoaXMucHJvcHMucHJvcGVydHksIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5hZnRlclNhdmUoIHZhbHVlICk7XG5cdH1cblxuXHRhZnRlclNhdmUoKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Y29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0dGhpcy4kZWwub2ZmKCAnY2hhbmdlJywgdGhpcy51cGRhdGVWYWx1ZSApO1xuXHRcdHRoaXMuJGVsLnVuYmluZCgpLnJlbW92ZURhdGEoKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCB2YWx1ZSA9IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXSApXG5cdFx0XHQ/IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlXG5cdFx0XHQ6IHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXTtcblxuXHRcdGNvbnN0IGRpdkNsYXNzID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmZpZWxkQ2xhc3MgKVxuXHRcdFx0PyAnc3VpLWZvcm0tZmllbGQgJyArIHRoaXMucHJvcHMuZmllbGRDbGFzc1xuXHRcdFx0OiAnc3VpLWZvcm0tZmllbGQnO1xuXG5cdFx0Y29uc3Qgc2VsZWN0SWQgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZWxlbWVudElkIClcblx0XHRcdD8gdGhpcy5wcm9wcy5lbGVtZW50SWRcblx0XHRcdDogdGhpcy5wcm9wcy5wcm9wZXJ0eTtcblxuXHRcdGxldCBpbnB1dExhYmVsO1xuXG5cdFx0aWYgKCB0aGlzLnByb3BzLmxhYmVsICkge1xuXHRcdFx0aW5wdXRMYWJlbCA9IChcblx0XHRcdFx0PGxhYmVsXG5cdFx0XHRcdFx0aHRtbEZvcj17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHRoaXMucHJvcHMucHJvcGVydHkgfWAgfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1sYWJlbFwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMubGFiZWwgfSZuYnNwO3sgdGhpcy5wcm9wcy5yZXF1aXJlZCAmJlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWVycm9yXCI+ICo8L3NwYW4+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5ub3RlICYmXG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktbGFiZWwtbm90ZVwiPnsgdGhpcy5wcm9wcy5ub3RlIH08L3NwYW4+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQ8L2xhYmVsPlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRjb25zdCBtdWx0aXBsZSA9IHRoaXMucHJvcHMubXVsdGlwbGU7XG5cdFx0Y29uc3QgeyBmb3JtVHlwZSwgdXBkYXRlUHJvcGVydHksIG5vV3JhcHBlciwgZmllbGRDbGFzcywgc3RhdGljQ29udGV4dCwgZm9ybURlc2lnbiwgZmllbGRTaXplLCAuLi5zZWxlY3RQcm9wcyB9ID0gdGhpcy5wcm9wcztcblxuXHRcdGNvbnN0IGdldFNlbGVjdCA9IChcblx0XHRcdDxzZWxlY3Rcblx0XHRcdFx0aWQ9eyBgZm9ybWluYXRvci1maWVsZC0keyBzZWxlY3RJZCB9YCB9XG5cdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1zZWxlY3RcIlxuXHRcdFx0XHRyZWY9eyBlbCA9PiAoIHRoaXMuZWwgPSBlbCApIH1cblx0XHRcdFx0ZGVmYXVsdFZhbHVlPXsgdmFsdWUgfVxuXHRcdFx0XHRtdWx0aXBsZT17IG11bHRpcGxlIH1cblx0XHRcdFx0eyAuLi5zZWxlY3RQcm9wcyB9XG5cdFx0XHQ+XG5cdFx0XHRcdHt0aGlzLnByb3BzLmNoaWxkcmVufVxuXHRcdFx0PC9zZWxlY3Q+XG5cdFx0KTtcblxuXHRcdGxldCBnZXRFbGVtZW50ID0gKFxuXHRcdFx0PHNlbGVjdFxuXHRcdFx0XHRpZD17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHNlbGVjdElkIH1gIH1cblx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLXNlbGVjdFwiXG5cdFx0XHRcdHJlZj17IGVsID0+ICggdGhpcy5lbCA9IGVsICkgfVxuXHRcdFx0XHRkZWZhdWx0VmFsdWU9eyB2YWx1ZSB9XG5cdFx0XHRcdG11bHRpcGxlPXsgbXVsdGlwbGUgfVxuXHRcdFx0PlxuXHRcdFx0XHR7dGhpcy5wcm9wcy5jaGlsZHJlbn1cblx0XHRcdDwvc2VsZWN0PlxuXHRcdCk7XG5cblx0XHRpZiAoICdtZCcgPT09IHRoaXMucHJvcHMuZmllbGRzaXplIHx8ICdtZWRpdW0nID09PSB0aGlzLnByb3BzLmZpZWxkc2l6ZSApIHtcblx0XHRcdGdldEVsZW1lbnQgPSAoXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGQgc3VpLWlucHV0LW1kXCI+XG5cdFx0XHRcdFx0eyBnZXRTZWxlY3QgfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmICggJ3NtJyA9PT0gdGhpcy5wcm9wcy5maWVsZHNpemUgfHwgJ3NtYWxsJyA9PT0gdGhpcy5wcm9wcy5maWVsZHNpemUgKSB7XG5cdFx0XHRnZXRFbGVtZW50ID0gKFxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1mb3JtLWZpZWxkIHN1aS1pbnB1dC1zbVwiPlxuXHRcdFx0XHRcdHsgZ2V0U2VsZWN0IH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQpO1xuXHRcdH0gZWxzZSBpZiAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5maWVsZHNpemUgKSAmJiAnJyAhPT0gdGhpcy5wcm9wcy5maWVsZHNpemUgKSB7XG5cdFx0XHRnZXRFbGVtZW50ID0gKFxuXHRcdFx0XHQ8ZGl2IHN0eWxlPXsgeyB3aWR0aDogJzEwMCUnLCBtYXhXaWR0aDogdGhpcy5wcm9wcy5maWVsZHNpemUgKyAncHgnIH0gfT5cblx0XHRcdFx0XHR7IGdldFNlbGVjdCB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMucHJvcHMubm9XcmFwcGVyICkge1xuXHRcdFx0cmV0dXJuIGdldFNlbGVjdDtcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9eyBkaXZDbGFzcyB9PlxuXG5cdFx0XHRcdHsgaW5wdXRMYWJlbCB9XG5cblx0XHRcdFx0eyBnZXRFbGVtZW50IH1cblxuXHRcdFx0XHR7IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gJiYgKFxuXHRcdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIlxuXHRcdFx0XHRcdFx0c3R5bGU9eyB7IG1hcmdpblRvcDogJzEwcHgnIH0gfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5kZXNjcmlwdGlvbiB9XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQpIH1cblxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzL2lucHV0cy9zdWktc2VsZWN0Mi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHdhcm5pbmdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBfX0RFVl9fID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJztcblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAoX19ERVZfXykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfVxuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkobnVsbCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3dhcm5pbmcvd2FybmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWlTZWxlY3QgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cblx0XHR0aGlzLnVwZGF0ZVZhbHVlID0gdGhpcy51cGRhdGVWYWx1ZS5iaW5kKCB0aGlzICk7XG5cdH1cblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLiRlbCA9IGpRdWVyeSggdGhpcy5lbCApO1xuXHRcdC8vIFNVSS5zZWxlY3QuaW5pdCggdGhpcy4kZWwgKTtcblxuXHRcdHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLiRlbC5vbiggJ2NoYW5nZScsIHRoaXMudXBkYXRlVmFsdWUgKTtcblx0fVxuXG5cdHVwZGF0ZVZhbHVlKCBlICkge1xuXHRcdGNvbnN0IHZhbHVlID0gZS50YXJnZXQudmFsdWU7XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBvbiBmaWVsZCBzZXR0aW5nc1xuXHRcdGlmICggdHlwZW9mIHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHQvLyBVcGRhdGUgZmllbGQgc3RhdGVcblx0XHRcdHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkoIHRoaXMucHJvcHMucHJvcGVydHksIHZhbHVlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFVwZGF0ZSBzdG9yZVxuXHRcdFx0dGhpcy5wcm9wcy5hY3Rpb25zLnNldHRpbmdzQWN0aW9ucy51cGRhdGVTZXR0aW5nKCB0aGlzLnByb3BzLnByb3BlcnR5LCB2YWx1ZSApO1xuXHRcdH1cblx0fVxuXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdHRoaXMuJGVsLm9mZiggJ2NoYW5nZScsIHRoaXMudXBkYXRlVmFsdWUgKTtcblx0XHR0aGlzLiRlbC51bmJpbmQoKS5yZW1vdmVEYXRhKCk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IHZhbHVlID0gXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdIClcblx0XHRcdD8gdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWVcblx0XHRcdDogdGhpcy5wcm9wcy5zZXR0aW5nc1sgdGhpcy5wcm9wcy5wcm9wZXJ0eSBdO1xuXG5cdFx0Y29uc3QgZmllbGRDbGFzcyA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5maWVsZENsYXNzIClcblx0XHRcdD8gJ3N1aS1mb3JtLWZpZWxkICcgKyB0aGlzLnByb3BzLmZpZWxkQ2xhc3Ncblx0XHRcdDogJ3N1aS1mb3JtLWZpZWxkJztcblxuXHRcdGNvbnN0IHNlbGVjdENsYXNzID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmVsZW1lbnRDbGFzcyApXG5cdFx0XHQ/IHRoaXMucHJvcHMuZWxlbWVudENsYXNzXG5cdFx0XHQ6ICcnO1xuXG5cdFx0Y29uc3Qgc2VsZWN0SWQgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZWxlbWVudElkIClcblx0XHRcdD8gdGhpcy5wcm9wcy5lbGVtZW50SWRcblx0XHRcdDogdGhpcy5wcm9wcy5wcm9wZXJ0eTtcblxuXHRcdGxldCBzZWxlY3RMYWJlbCA9ICcnO1xuXG5cdFx0aWYgKCB0aGlzLnByb3BzLmxhYmVsICkge1xuXHRcdFx0c2VsZWN0TGFiZWwgPSAoXG5cdFx0XHRcdDxsYWJlbFxuXHRcdFx0XHRcdGh0bWxGb3I9eyBgZm9ybWluYXRvci1maWVsZC0keyB0aGlzLnByb3BzLnByb3BlcnR5IH1gIH1cblx0XHRcdFx0XHRpZD17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHRoaXMucHJvcHMucHJvcGVydHkgfS1sYWJlbGAgfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1sYWJlbFwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMubGFiZWwgfSZuYnNwO3sgdGhpcy5wcm9wcy5yZXF1aXJlZCAmJlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWVycm9yXCI+ICo8L3NwYW4+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5ub3RlICYmXG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktbGFiZWwtbm90ZVwiPnt0aGlzLnByb3BzLm5vdGV9PC9zcGFuPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHRcdGlmIChcblx0XHRcdCEgXy5pc1VuZGVmaW5lZCggdmFsdWUgKSAmJlxuXHRcdFx0KCAncGhvbmVfbmF0aW9uYWxfY291bnRyeScgPT09IHRoaXMucHJvcHMucHJvcGVydHkgfHwgJ3Bob25lX2ludGVybmF0aW9uYWxfY291bnRyeScgPT09IHRoaXMucHJvcHMucHJvcGVydHkgKVxuXHRcdCkge1xuXHRcdFx0dmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHNlbGVjdEZpZWxkID0gKFxuXHRcdFx0PHNlbGVjdFxuXHRcdFx0XHRkZWZhdWx0VmFsdWU9eyB2YWx1ZSB9XG5cdFx0XHRcdGlkPXsgYGZvcm1pbmF0b3ItZmllbGQtJHsgc2VsZWN0SWQgfWAgfVxuXHRcdFx0XHRjbGFzc05hbWU9eyBzZWxlY3RDbGFzcyB9XG5cdFx0XHRcdGFyaWEtbGFiZWxsZWRieT17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHNlbGVjdElkIH0tbGFiZWxgIH1cblx0XHRcdFx0cmVmPXsgZWwgPT4gKCB0aGlzLmVsID0gZWwgKSB9XG5cdFx0XHRcdHN0eWxlPXsgeyBtYXhXaWR0aDogJ25vbmUnIH0gfVxuXHRcdFx0PlxuXHRcdFx0XHR7IHRoaXMucHJvcHMuY2hpbGRyZW4gfVxuXHRcdFx0PC9zZWxlY3Q+XG5cdFx0KTtcblxuXHRcdGxldCBnZXRFbGVtZW50ID0gc2VsZWN0RmllbGQ7XG5cblx0XHRpZiAoICdtZCcgPT09IHRoaXMucHJvcHMuZmllbGRzaXplIHx8ICdtZWRpdW0nID09PSB0aGlzLnByb3BzLmZpZWxkc2l6ZSApIHtcblx0XHRcdGdldEVsZW1lbnQgPSAoXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGQgc3VpLWlucHV0LW1kXCI+XG5cdFx0XHRcdFx0eyBzZWxlY3RGaWVsZCB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKCAnc20nID09PSB0aGlzLnByb3BzLmZpZWxkc2l6ZSB8fCAnc21hbGwnID09PSB0aGlzLnByb3BzLmZpZWxkc2l6ZSApIHtcblx0XHRcdGdldEVsZW1lbnQgPSAoXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGQgc3VpLWlucHV0LXNtXCI+XG5cdFx0XHRcdFx0eyBzZWxlY3RGaWVsZCB9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKCAnJyAhPT0gdGhpcy5wcm9wcy5maWVsZHNpemUgKSB7XG5cdFx0XHRnZXRFbGVtZW50ID0gKFxuXHRcdFx0XHQ8ZGl2IHN0eWxlPXsgeyB3aWR0aDogJzEwMCUnLCBtYXhXaWR0aDogdGhpcy5wcm9wcy5maWVsZHNpemUgKyAncHgnIH0gfT5cblx0XHRcdFx0XHR7IHNlbGVjdEZpZWxkIH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGxldCBnZXRGaWVsZCA9IGdldEVsZW1lbnQ7XG5cblx0XHRpZiAoICEgdGhpcy5wcm9wcy5zaW1wbGUgKSB7XG5cdFx0XHRnZXRGaWVsZCA9IChcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9eyBmaWVsZENsYXNzIH0+XG5cblx0XHRcdFx0XHR7IHNlbGVjdExhYmVsIH1cblxuXHRcdFx0XHRcdHsgZ2V0RWxlbWVudCB9XG5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gJiYgKFxuXHRcdFx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCJcblx0XHRcdFx0XHRcdFx0c3R5bGU9eyB7IG1hcmdpblRvcDogJzEwcHgnIH0gfVxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZGVzY3JpcHRpb24gfVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdCkgfVxuXG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZ2V0RmllbGQ7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9pbnB1dHMvc3VpLXNlbGVjdC5qcyIsIm1vZHVsZS5leHBvcnRzID0gUmVhY3RET007XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJSZWFjdERPTVwiXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiaW1wb3J0IF9jcmVhdGVCcm93c2VySGlzdG9yeSBmcm9tICcuL2NyZWF0ZUJyb3dzZXJIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVCcm93c2VySGlzdG9yeSBhcyBjcmVhdGVCcm93c2VySGlzdG9yeSB9O1xuaW1wb3J0IF9jcmVhdGVIYXNoSGlzdG9yeSBmcm9tICcuL2NyZWF0ZUhhc2hIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVIYXNoSGlzdG9yeSBhcyBjcmVhdGVIYXNoSGlzdG9yeSB9O1xuaW1wb3J0IF9jcmVhdGVNZW1vcnlIaXN0b3J5IGZyb20gJy4vY3JlYXRlTWVtb3J5SGlzdG9yeSc7XG5leHBvcnQgeyBfY3JlYXRlTWVtb3J5SGlzdG9yeSBhcyBjcmVhdGVNZW1vcnlIaXN0b3J5IH07XG5cbmV4cG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5leHBvcnQgeyBwYXJzZVBhdGgsIGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb2dnbGUgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cblx0XHR0aGlzLnVwZGF0ZVZhbHVlID0gdGhpcy51cGRhdGVWYWx1ZS5iaW5kKCB0aGlzICk7XG5cdH1cblxuXHR1cGRhdGVWYWx1ZSggdmFsdWUgKSB7XG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgb24gZmllbGQgc2V0dGluZ3Ncblx0XHRpZiAoIHR5cGVvZiB0aGlzLnByb3BzLnVwZGF0ZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0Ly8gVXBkYXRlIGZpZWxkIHN0YXRlXG5cdFx0XHR0aGlzLnByb3BzLnVwZGF0ZVByb3BlcnR5KCB0aGlzLnByb3BzLnByb3BlcnR5LCB2YWx1ZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBVcGRhdGUgc3RvcmVcblx0XHRcdHRoaXMucHJvcHMuYWN0aW9ucy5zZXR0aW5nc0FjdGlvbnMudXBkYXRlU2V0dGluZyggdGhpcy5wcm9wcy5wcm9wZXJ0eSwgdmFsdWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF0gKVxuXHRcdFx0PyAnJ1xuXHRcdFx0OiB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF1cblx0XHRcdDtcblxuXHRcdGNvbnN0IGN1c3RvbUNsYXNzID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmN1c3RvbUNsYXNzIClcblx0XHRcdD8gdGhpcy5wcm9wcy5jdXN0b21DbGFzc1xuXHRcdFx0OiAnc3VpLWZvcm0tY29udHJvbCdcblx0XHRcdDtcblxuXHRcdGNvbnN0IGRpc2FibGVkID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmRpc2FibGVkICkgJiYgdGhpcy5wcm9wcy5kaXNhYmxlZDtcblx0XHRjb25zdCBjaGVja2VkID0gdmFsdWUgJiYgISBkaXNhYmxlZDtcblxuXHRcdGNvbnN0IHRvZ2dsZUNvbnRlbnQgPSAoXG5cdFx0XHQ8bGFiZWwgaHRtbEZvcj17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHRoaXMucHJvcHMucHJvcGVydHkgfWAgfVxuXHRcdFx0XHRjbGFzc05hbWU9XCJzdWktdG9nZ2xlXCJcblx0XHRcdD5cblx0XHRcdFx0PGlucHV0IHR5cGU9XCJjaGVja2JveFwiXG5cdFx0XHRcdFx0dmFsdWU9XCJ0cnVlXCJcblx0XHRcdFx0XHRpZD17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IHRoaXMucHJvcHMucHJvcGVydHkgfWAgfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT17IGN1c3RvbUNsYXNzIH1cblx0XHRcdFx0XHRkaXNhYmxlZD17IGRpc2FibGVkID8gJ2Rpc2FibGVkJyA6ICcnIH1cblx0XHRcdFx0XHRjaGVja2VkPXsgY2hlY2tlZCA/ICdjaGVja2VkJyA6ICcnIH1cblx0XHRcdFx0XHRvbkNoYW5nZT17IGUgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy51cGRhdGVWYWx1ZSggZS50YXJnZXQuY2hlY2tlZCApO1xuXHRcdFx0XHRcdH0gfVxuXHRcdFx0XHQvPlxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktdG9nZ2xlLXNsaWRlclwiIC8+XG5cdFx0XHRcdHsgdGhpcy5wcm9wcy5sYWJlbCAmJiAoXG5cdFx0XHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXNjcmVlbi1yZWFkZXItdGV4dFwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0VuYWJsZScgKSB9IHsgdGhpcy5wcm9wcy5sYWJlbCB9XG5cdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktdG9nZ2xlLWxhYmVsXCI+XG5cdFx0XHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5sYWJlbCB9XG5cdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0KSB9XG5cdFx0XHRcdHsgdGhpcy5wcm9wcy5kZXNjcmlwdGlvbiAmJiAoXG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uIHN1aS10b2dnbGUtZGVzY3JpcHRpb25cIj5cblx0XHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5kZXNjcmlwdGlvbiB9XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQpIH1cblx0XHRcdDwvbGFiZWw+XG5cdFx0KTtcblxuXHRcdGxldCBzdWJUb2dnbGUgPSAnJztcblxuXHRcdGlmICggdGhpcy5wcm9wcy5jaGlsZHJlbiAmJiB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF0gKSB7XG5cdFx0XHRzdWJUb2dnbGUgPSAoXG5cdFx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHR0YWJJbmRleD1cIjBcIlxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLXRvZ2dsZS1jb250ZW50IHN1aS1ib3JkZXItZnJhbWVcIlxuXHRcdFx0XHRcdFx0YXJpYS1sYWJlbD17IHRoaXMucHJvcHMubGFiZWwgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5jaGlsZHJlbiB9XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5wcm9wcy51bldyYXAgKSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdFx0eyB0b2dnbGVDb250ZW50IH1cblx0XHRcdFx0XHR7IHN1YlRvZ2dsZSB9XG5cdFx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmICggISB0aGlzLnByb3BzLnVuV3JhcCApIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGRcIj5cblx0XHRcdFx0XHR7IHRvZ2dsZUNvbnRlbnQgfVxuXHRcdFx0XHRcdHsgc3ViVG9nZ2xlIH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzL2lucHV0cy90b2dnbGUuanMiLCJpbXBvcnQgX0Jyb3dzZXJSb3V0ZXIgZnJvbSBcIi4vQnJvd3NlclJvdXRlclwiO1xuZXhwb3J0IHsgX0Jyb3dzZXJSb3V0ZXIgYXMgQnJvd3NlclJvdXRlciB9O1xuaW1wb3J0IF9IYXNoUm91dGVyIGZyb20gXCIuL0hhc2hSb3V0ZXJcIjtcbmV4cG9ydCB7IF9IYXNoUm91dGVyIGFzIEhhc2hSb3V0ZXIgfTtcbmltcG9ydCBfTGluayBmcm9tIFwiLi9MaW5rXCI7XG5leHBvcnQgeyBfTGluayBhcyBMaW5rIH07XG5pbXBvcnQgX01lbW9yeVJvdXRlciBmcm9tIFwiLi9NZW1vcnlSb3V0ZXJcIjtcbmV4cG9ydCB7IF9NZW1vcnlSb3V0ZXIgYXMgTWVtb3J5Um91dGVyIH07XG5pbXBvcnQgX05hdkxpbmsgZnJvbSBcIi4vTmF2TGlua1wiO1xuZXhwb3J0IHsgX05hdkxpbmsgYXMgTmF2TGluayB9O1xuaW1wb3J0IF9Qcm9tcHQgZnJvbSBcIi4vUHJvbXB0XCI7XG5leHBvcnQgeyBfUHJvbXB0IGFzIFByb21wdCB9O1xuaW1wb3J0IF9SZWRpcmVjdCBmcm9tIFwiLi9SZWRpcmVjdFwiO1xuZXhwb3J0IHsgX1JlZGlyZWN0IGFzIFJlZGlyZWN0IH07XG5pbXBvcnQgX1JvdXRlIGZyb20gXCIuL1JvdXRlXCI7XG5leHBvcnQgeyBfUm91dGUgYXMgUm91dGUgfTtcbmltcG9ydCBfUm91dGVyIGZyb20gXCIuL1JvdXRlclwiO1xuZXhwb3J0IHsgX1JvdXRlciBhcyBSb3V0ZXIgfTtcbmltcG9ydCBfU3RhdGljUm91dGVyIGZyb20gXCIuL1N0YXRpY1JvdXRlclwiO1xuZXhwb3J0IHsgX1N0YXRpY1JvdXRlciBhcyBTdGF0aWNSb3V0ZXIgfTtcbmltcG9ydCBfU3dpdGNoIGZyb20gXCIuL1N3aXRjaFwiO1xuZXhwb3J0IHsgX1N3aXRjaCBhcyBTd2l0Y2ggfTtcbmltcG9ydCBfZ2VuZXJhdGVQYXRoIGZyb20gXCIuL2dlbmVyYXRlUGF0aFwiO1xuZXhwb3J0IHsgX2dlbmVyYXRlUGF0aCBhcyBnZW5lcmF0ZVBhdGggfTtcbmltcG9ydCBfbWF0Y2hQYXRoIGZyb20gXCIuL21hdGNoUGF0aFwiO1xuZXhwb3J0IHsgX21hdGNoUGF0aCBhcyBtYXRjaFBhdGggfTtcbmltcG9ydCBfd2l0aFJvdXRlciBmcm9tIFwiLi93aXRoUm91dGVyXCI7XG5leHBvcnQgeyBfd2l0aFJvdXRlciBhcyB3aXRoUm91dGVyIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJleHBvcnQgdmFyIGFkZExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIGFkZExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aCA6ICcvJyArIHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIHN0cmlwTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gc3RyaXBMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgaGFzQmFzZW5hbWUgPSBmdW5jdGlvbiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcHJlZml4ICsgJyhcXFxcL3xcXFxcP3wjfCQpJywgJ2knKS50ZXN0KHBhdGgpO1xufTtcblxuZXhwb3J0IHZhciBzdHJpcEJhc2VuYW1lID0gZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkgPyBwYXRoLnN1YnN0cihwcmVmaXgubGVuZ3RoKSA6IHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIHN0cmlwVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdChwYXRoLmxlbmd0aCAtIDEpID09PSAnLycgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIHBhcnNlUGF0aCA9IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBwYXRobmFtZSA9IHBhdGggfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gJyc7XG4gIHZhciBoYXNoID0gJyc7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBoYXNoID0gcGF0aG5hbWUuc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBzZWFyY2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJz8nKTtcbiAgaWYgKHNlYXJjaEluZGV4ICE9PSAtMSkge1xuICAgIHNlYXJjaCA9IHBhdGhuYW1lLnN1YnN0cihzZWFyY2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgc2VhcmNoSW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2ggPT09ICc/JyA/ICcnIDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2ggPT09ICcjJyA/ICcnIDogaGFzaFxuICB9O1xufTtcblxuZXhwb3J0IHZhciBjcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG5cbiAgdmFyIHBhdGggPSBwYXRobmFtZSB8fCAnLyc7XG5cbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09ICc/JykgcGF0aCArPSBzZWFyY2guY2hhckF0KDApID09PSAnPycgPyBzZWFyY2ggOiAnPycgKyBzZWFyY2g7XG5cbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gJyMnKSBwYXRoICs9IGhhc2guY2hhckF0KDApID09PSAnIycgPyBoYXNoIDogJyMnICsgaGFzaDtcblxuICByZXR1cm4gcGF0aDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9QYXRoVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm90aWZpY2F0aW9uIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0aW5pdGlhbGl6ZSgpIHtcblx0XHRpZiAoICEgalF1ZXJ5KCAnLnN1aS1mbG9hdGluZy1ub3RpY2VzJyApLmxlbmd0aCApIHtcblx0XHRcdGpRdWVyeSggJ21haW4uc3VpLXdyYXAnICkucHJlcGVuZCggJzxkaXYgY2xhc3M9XCJzdWktZmxvYXRpbmctbm90aWNlc1wiPjwvZGl2PicgKTtcblx0XHR9XG5cblx0XHRpZiAoICEgalF1ZXJ5KCAnI2Zvcm1pbmF0b3Itbm90aWZpY2F0aW9uJyApLmxlbmd0aCApIHtcblx0XHRcdGpRdWVyeSggJy5zdWktZmxvYXRpbmctbm90aWNlcycgKS5hcHBlbmQoXG5cdFx0XHRcdCc8ZGl2IHJvbGU9XCJhbGVydFwiIGlkPVwiZm9ybWluYXRvci1ub3RpZmljYXRpb25cIiBjbGFzcz1cInN1aS1ub3RpY2VcIiBhcmlhLWxpdmU9XCJhc3NlcnRpdmVcIj48L2Rpdj4nXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkoICcjZm9ybWluYXRvci1ub3RpZmljYXRpb24nICkucmVtb3ZlKCk7XG5cdFx0XHR0aGlzLmluaXRpYWxpemUoKTtcblx0XHR9XG5cblx0XHR0aGlzLiRub3RpZmljYXRpb24gPSBqUXVlcnkoICcjZm9ybWluYXRvci1ub3RpZmljYXRpb24nICk7XG5cdH1cblxuXHRvcGVuKCkge1xuXHRcdHRoaXMuaW5pdGlhbGl6ZSgpO1xuXG5cdFx0Y29uc3Qgbm90aWNlSWQgPSAnZm9ybWluYXRvci1ub3RpZmljYXRpb24nO1xuXHRcdGNvbnN0IG5vdGljZU1lc3NhZ2UgPSAnPHA+JyArIHRoaXMucHJvcHMudGV4dCArICc8L3A+Jztcblx0XHRjb25zdCBub3RpY2VPcHRpb25zID0ge1xuXHRcdFx0dHlwZTogdGhpcy5wcm9wcy50eXBlIHx8ICdkZWZhdWx0Jyxcblx0XHRcdGF1dG9jbG9zZToge1xuXHRcdFx0XHR0aW1lb3V0OiB0aGlzLnByb3BzLnRpbWUgfHwgNTAwMCxcblx0XHRcdH0sXG5cdFx0XHRkaXNtaXNzOiB7XG5cdFx0XHRcdHNob3c6IHRoaXMucHJvcHMuZGlzbWlzcyB8fCBmYWxzZVxuXHRcdFx0fSxcblx0XHR9O1xuXG5cdFx0U1VJLm9wZW5Ob3RpY2UoIG5vdGljZUlkLCBub3RpY2VNZXNzYWdlLCBub3RpY2VPcHRpb25zICk7XG5cdH1cblxuXHRjbG9zZSgpIHtcblx0XHRjb25zdCBub3RpY2VJZCA9ICdmb3JtaW5hdG9yLW5vdGlmaWNhdGlvbic7XG5cdFx0U1VJLmNsb3NlTm90aWNlKCBub3RpY2VJZCApO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbm90aWZpY2F0aW9ucy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDIgPyBsZW4gLSAyIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAyXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5sZW5ndGggPCAxMCB8fCAoL15bc1xcV10qJC8pLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHdhcm5pbmcgZm9ybWF0IHNob3VsZCBiZSBhYmxlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgJyArXG4gICAgICAgICd3YXJuaW5nLiBQbGVhc2UsIHVzZSBhIG1vcmUgZGVzY3JpcHRpdmUgZm9ybWF0IHRoYW46ICcgKyBmb3JtYXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9ub2RlX21vZHVsZXMvd2FybmluZy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCByZXNvbHZlUGF0aG5hbWUgZnJvbSAncmVzb2x2ZS1wYXRobmFtZSc7XG5pbXBvcnQgdmFsdWVFcXVhbCBmcm9tICd2YWx1ZS1lcXVhbCc7XG5pbXBvcnQgeyBwYXJzZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5cbmV4cG9ydCB2YXIgY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5LCBjdXJyZW50TG9jYXRpb24pIHtcbiAgdmFyIGxvY2F0aW9uID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVHdvLWFyZyBmb3JtOiBwdXNoKHBhdGgsIHN0YXRlKVxuICAgIGxvY2F0aW9uID0gcGFyc2VQYXRoKHBhdGgpO1xuICAgIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gT25lLWFyZyBmb3JtOiBwdXNoKGxvY2F0aW9uKVxuICAgIGxvY2F0aW9uID0gX2V4dGVuZHMoe30sIHBhdGgpO1xuXG4gICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnBhdGhuYW1lID0gJyc7XG5cbiAgICBpZiAobG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBsb2NhdGlvbi5zZWFyY2ggPSAnPycgKyBsb2NhdGlvbi5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLnNlYXJjaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgbG9jYXRpb24uaGFzaCA9ICcjJyArIGxvY2F0aW9uLmhhc2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBsb2NhdGlvbi5zdGF0ZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGRlY29kZVVSSShsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFVSSUVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgVVJJRXJyb3IoJ1BhdGhuYW1lIFwiJyArIGxvY2F0aW9uLnBhdGhuYW1lICsgJ1wiIGNvdWxkIG5vdCBiZSBkZWNvZGVkLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBhbiBpbnZhbGlkIHBlcmNlbnQtZW5jb2RpbmcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGtleSkgbG9jYXRpb24ua2V5ID0ga2V5O1xuXG4gIGlmIChjdXJyZW50TG9jYXRpb24pIHtcbiAgICAvLyBSZXNvbHZlIGluY29tcGxldGUvcmVsYXRpdmUgcGF0aG5hbWUgcmVsYXRpdmUgdG8gY3VycmVudCBsb2NhdGlvbi5cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IHJlc29sdmVQYXRobmFtZShsb2NhdGlvbi5wYXRobmFtZSwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBwcmlvciBsb2NhdGlvbiBhbmQgcGF0aG5hbWUgaXMgZW1wdHksIHNldCBpdCB0byAvXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxvY2F0aW9uO1xufTtcblxuZXhwb3J0IHZhciBsb2NhdGlvbnNBcmVFcXVhbCA9IGZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmIGEuaGFzaCA9PT0gYi5oYXNoICYmIGEua2V5ID09PSBiLmtleSAmJiB2YWx1ZUVxdWFsKGEuc3RhdGUsIGIuc3RhdGUpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0xvY2F0aW9uVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWNjb3JkaW9uIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy5zdGF0ZSA9IHtcblx0XHRcdG9wZW46IHByb3BzLmV4cGFuZGVkIHx8IGZhbHNlLFxuXHRcdH07XG5cblx0XHR0aGlzLnRvZ2dsZVN0YXRlID0gdGhpcy50b2dnbGVTdGF0ZS5iaW5kKCB0aGlzICk7XG5cdH1cblxuXHR0b2dnbGVTdGF0ZSgpIHtcblx0XHR0aGlzLnNldFN0YXRlKCB7XG5cdFx0XHRvcGVuOiAhIHRoaXMuc3RhdGUub3Blbixcblx0XHR9ICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgeyBsYWJlbCB9ID0gdGhpcy5wcm9wcztcblx0XHRjb25zdCB7IG9wZW4gfSA9IHRoaXMuc3RhdGU7XG5cdFx0bGV0IGRpdkNsYXNzID0gJyc7XG5cblx0XHRpZiAoIG9wZW4gKSB7XG5cdFx0XHRkaXZDbGFzcyA9ICdzdWktYWNjb3JkaW9uLWl0ZW0tLW9wZW4nO1xuXHRcdH1cblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5cdFx0Y29uc3QgYm94ZWRDb250ZW50ID0gKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuYm94ZWRDb250ZW50ICkgJiYgJycgIT09IHRoaXMucHJvcHMuYm94ZWRDb250ZW50IClcblx0XHRcdD8gdGhpcy5wcm9wcy5ib3hlZENvbnRlbnRcblx0XHRcdDogdHJ1ZTtcblxuXHRcdGNvbnN0IGRlZmF1bHRDb250ZW50UmVuZGVyID0gKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZGVmYXVsdENvbnRlbnRSZW5kZXIgKSApXG5cdFx0XHQ/IHRoaXMucHJvcHMuZGVmYXVsdENvbnRlbnRSZW5kZXJcblx0XHRcdDogZmFsc2U7XG5cblx0XHRjb25zdCBhY2NvcmRpb25Db250ZW50cyA9IFJlYWN0LkNoaWxkcmVuLm1hcCggdGhpcy5wcm9wcy5jaGlsZHJlbiwgdGFiID0+IHtcblx0XHRcdHJldHVybiB0YWI7XG5cdFx0fSApO1xuXG5cdFx0Ly8gSXQncyBpbnRlbnRpb25hbGx5IHdlIHVzZSBzcGFuIGhlcmUgdG8gYXZvaWQgdW53YW50ZWQgaGFuZGxlcnMgZnJvbSBTVUkgb24gZGl2LnN1aS1hY2NvcmRpb24taXRlbS1oZWFkZXIuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPXsgJ3N1aS1hY2NvcmRpb24taXRlbSAnICsgZGl2Q2xhc3MgfT5cblx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWFjY29yZGlvbi1pdGVtLWhlYWRlclwiIG9uQ2xpY2s9eyAoKSA9PiB0aGlzLnRvZ2dsZVN0YXRlKCkgfT5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1hY2NvcmRpb24taXRlbS10aXRsZVwiPlxuXHRcdFx0XHRcdFx0PHNwYW4+eyBsYWJlbCB9PC9zcGFuPlxuXHRcdFx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktYnV0dG9uLWljb24gc3VpLWFjY29yZGlvbi1vcGVuLWluZGljYXRvclwiXG5cdFx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLnRvZ2dsZVN0YXRlKCkgfVxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHQ8aSBjbGFzc05hbWU9XCJzdWktaWNvbi1jaGV2cm9uLWRvd25cIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1zY3JlZW4tcmVhZGVyLXRleHRcIj5cblx0XHRcdFx0XHRcdFx0XHR7IGZhbHNlID09PSB0aGlzLnN0YXRlLm9wZW4gPyAnT3BlbicgOiAnQ2xvc2UnIH1cblx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYWNjb3JkaW9uLWl0ZW0tYm9keVwiPlxuXHRcdFx0XHRcdHsgZmFsc2UgPT09IGJveGVkQ29udGVudFxuXHRcdFx0XHRcdFx0PyAoIGRlZmF1bHRDb250ZW50UmVuZGVyIHx8IG9wZW4gKSAmJiBhY2NvcmRpb25Db250ZW50c1xuXHRcdFx0XHRcdFx0OiAoXG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveFwiPlxuXHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1ib2R5XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHR7ICggZGVmYXVsdENvbnRlbnRSZW5kZXIgfHwgb3BlbiApICYmIGFjY29yZGlvbkNvbnRlbnRzIH1cblx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdFx0XHR7IGJveGVkQ29udGVudCB9XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MvY29udGFpbmVycy9hY2NvcmRpb24uanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLmluaGVyaXRzID0gaW5oZXJpdHM7XG5cbmZ1bmN0aW9uIHRvQXJyYXkobXNnLCBlbmMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSlcbiAgICByZXR1cm4gbXNnLnNsaWNlKCk7XG4gIGlmICghbXNnKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHJlcyA9IFtdO1xuICBpZiAodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIWVuYykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGhpID0gYyA+PiA4O1xuICAgICAgICB2YXIgbG8gPSBjICYgMHhmZjtcbiAgICAgICAgaWYgKGhpKVxuICAgICAgICAgIHJlcy5wdXNoKGhpLCBsbyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXMucHVzaChsbyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbmMgPT09ICdoZXgnKSB7XG4gICAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgJycpO1xuICAgICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgICBtc2cgPSAnMCcgKyBtc2c7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgICAgcmVzW2ldID0gbXNnW2ldIHwgMDtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcblxuZnVuY3Rpb24gdG9IZXgobXNnKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgcmVzICs9IHplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO1xuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuXG5mdW5jdGlvbiBodG9ubCh3KSB7XG4gIHZhciByZXMgPSAodyA+Pj4gMjQpIHxcbiAgICAgICAgICAgICgodyA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAgICAgICAgICgodyA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAgICAgICAoKHcgJiAweGZmKSA8PCAyNCk7XG4gIHJldHVybiByZXMgPj4+IDA7XG59XG5leHBvcnRzLmh0b25sID0gaHRvbmw7XG5cbmZ1bmN0aW9uIHRvSGV4MzIobXNnLCBlbmRpYW4pIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB3ID0gbXNnW2ldO1xuICAgIGlmIChlbmRpYW4gPT09ICdsaXR0bGUnKVxuICAgICAgdyA9IGh0b25sKHcpO1xuICAgIHJlcyArPSB6ZXJvOCh3LnRvU3RyaW5nKDE2KSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMudG9IZXgzMiA9IHRvSGV4MzI7XG5cbmZ1bmN0aW9uIHplcm8yKHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG5leHBvcnRzLnplcm8yID0gemVybzI7XG5cbmZ1bmN0aW9uIHplcm84KHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSA3KVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNilcbiAgICByZXR1cm4gJzAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA1KVxuICAgIHJldHVybiAnMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA0KVxuICAgIHJldHVybiAnMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMylcbiAgICByZXR1cm4gJzAwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAyKVxuICAgIHJldHVybiAnMDAwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMDAwMDAwMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG5leHBvcnRzLnplcm84ID0gemVybzg7XG5cbmZ1bmN0aW9uIGpvaW4zMihtc2csIHN0YXJ0LCBlbmQsIGVuZGlhbikge1xuICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIGFzc2VydChsZW4gJSA0ID09PSAwKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4gLyA0KTtcbiAgZm9yICh2YXIgaSA9IDAsIGsgPSBzdGFydDsgaSA8IHJlcy5sZW5ndGg7IGkrKywgayArPSA0KSB7XG4gICAgdmFyIHc7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JpZycpXG4gICAgICB3ID0gKG1zZ1trXSA8PCAyNCkgfCAobXNnW2sgKyAxXSA8PCAxNikgfCAobXNnW2sgKyAyXSA8PCA4KSB8IG1zZ1trICsgM107XG4gICAgZWxzZVxuICAgICAgdyA9IChtc2dbayArIDNdIDw8IDI0KSB8IChtc2dbayArIDJdIDw8IDE2KSB8IChtc2dbayArIDFdIDw8IDgpIHwgbXNnW2tdO1xuICAgIHJlc1tpXSA9IHcgPj4+IDA7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuam9pbjMyID0gam9pbjMyO1xuXG5mdW5jdGlvbiBzcGxpdDMyKG1zZywgZW5kaWFuKSB7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobXNnLmxlbmd0aCAqIDQpO1xuICBmb3IgKHZhciBpID0gMCwgayA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuICAgIHZhciBtID0gbXNnW2ldO1xuICAgIGlmIChlbmRpYW4gPT09ICdiaWcnKSB7XG4gICAgICByZXNba10gPSBtID4+PiAyNDtcbiAgICAgIHJlc1trICsgMV0gPSAobSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgIHJlc1trICsgMl0gPSAobSA+Pj4gOCkgJiAweGZmO1xuICAgICAgcmVzW2sgKyAzXSA9IG0gJiAweGZmO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbayArIDNdID0gbSA+Pj4gMjQ7XG4gICAgICByZXNbayArIDJdID0gKG0gPj4+IDE2KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDFdID0gKG0gPj4+IDgpICYgMHhmZjtcbiAgICAgIHJlc1trXSA9IG0gJiAweGZmO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5zcGxpdDMyID0gc3BsaXQzMjtcblxuZnVuY3Rpb24gcm90cjMyKHcsIGIpIHtcbiAgcmV0dXJuICh3ID4+PiBiKSB8ICh3IDw8ICgzMiAtIGIpKTtcbn1cbmV4cG9ydHMucm90cjMyID0gcm90cjMyO1xuXG5mdW5jdGlvbiByb3RsMzIodywgYikge1xuICByZXR1cm4gKHcgPDwgYikgfCAodyA+Pj4gKDMyIC0gYikpO1xufVxuZXhwb3J0cy5yb3RsMzIgPSByb3RsMzI7XG5cbmZ1bmN0aW9uIHN1bTMyKGEsIGIpIHtcbiAgcmV0dXJuIChhICsgYikgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyID0gc3VtMzI7XG5cbmZ1bmN0aW9uIHN1bTMyXzMoYSwgYiwgYykge1xuICByZXR1cm4gKGEgKyBiICsgYykgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyXzMgPSBzdW0zMl8zO1xuXG5mdW5jdGlvbiBzdW0zMl80KGEsIGIsIGMsIGQpIHtcbiAgcmV0dXJuIChhICsgYiArIGMgKyBkKSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtMzJfNCA9IHN1bTMyXzQ7XG5cbmZ1bmN0aW9uIHN1bTMyXzUoYSwgYiwgYywgZCwgZSkge1xuICByZXR1cm4gKGEgKyBiICsgYyArIGQgKyBlKSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtMzJfNSA9IHN1bTMyXzU7XG5cbmZ1bmN0aW9uIHN1bTY0KGJ1ZiwgcG9zLCBhaCwgYWwpIHtcbiAgdmFyIGJoID0gYnVmW3Bvc107XG4gIHZhciBibCA9IGJ1Zltwb3MgKyAxXTtcblxuICB2YXIgbG8gPSAoYWwgKyBibCkgPj4+IDA7XG4gIHZhciBoaSA9IChsbyA8IGFsID8gMSA6IDApICsgYWggKyBiaDtcbiAgYnVmW3Bvc10gPSBoaSA+Pj4gMDtcbiAgYnVmW3BvcyArIDFdID0gbG87XG59XG5leHBvcnRzLnN1bTY0ID0gc3VtNjQ7XG5cbmZ1bmN0aW9uIHN1bTY0X2hpKGFoLCBhbCwgYmgsIGJsKSB7XG4gIHZhciBsbyA9IChhbCArIGJsKSA+Pj4gMDtcbiAgdmFyIGhpID0gKGxvIDwgYWwgPyAxIDogMCkgKyBhaCArIGJoO1xuICByZXR1cm4gaGkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0X2hpID0gc3VtNjRfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0X2xvKGFoLCBhbCwgYmgsIGJsKSB7XG4gIHZhciBsbyA9IGFsICsgYmw7XG4gIHJldHVybiBsbyA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfbG8gPSBzdW02NF9sbztcblxuZnVuY3Rpb24gc3VtNjRfNF9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGxvID0gYWw7XG4gIGxvID0gKGxvICsgYmwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgY2wpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZGwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG5cbiAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBjYXJyeTtcbiAgcmV0dXJuIGhpID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF80X2hpID0gc3VtNjRfNF9oaTtcblxuZnVuY3Rpb24gc3VtNjRfNF9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwpIHtcbiAgdmFyIGxvID0gYWwgKyBibCArIGNsICsgZGw7XG4gIHJldHVybiBsbyA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfNF9sbyA9IHN1bTY0XzRfbG87XG5cbmZ1bmN0aW9uIHN1bTY0XzVfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsLCBlaCwgZWwpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGxvID0gYWw7XG4gIGxvID0gKGxvICsgYmwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgY2wpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZGwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZWwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGVsID8gMSA6IDA7XG5cbiAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBlaCArIGNhcnJ5O1xuICByZXR1cm4gaGkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0XzVfaGkgPSBzdW02NF81X2hpO1xuXG5mdW5jdGlvbiBzdW02NF81X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCwgZWgsIGVsKSB7XG4gIHZhciBsbyA9IGFsICsgYmwgKyBjbCArIGRsICsgZWw7XG5cbiAgcmV0dXJuIGxvID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF81X2xvID0gc3VtNjRfNV9sbztcblxuZnVuY3Rpb24gcm90cjY0X2hpKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFsIDw8ICgzMiAtIG51bSkpIHwgKGFoID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn1cbmV4cG9ydHMucm90cjY0X2hpID0gcm90cjY0X2hpO1xuXG5mdW5jdGlvbiByb3RyNjRfbG8oYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWggPDwgKDMyIC0gbnVtKSkgfCAoYWwgPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufVxuZXhwb3J0cy5yb3RyNjRfbG8gPSByb3RyNjRfbG87XG5cbmZ1bmN0aW9uIHNocjY0X2hpKGFoLCBhbCwgbnVtKSB7XG4gIHJldHVybiBhaCA+Pj4gbnVtO1xufVxuZXhwb3J0cy5zaHI2NF9oaSA9IHNocjY0X2hpO1xuXG5mdW5jdGlvbiBzaHI2NF9sbyhhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhaCA8PCAoMzIgLSBudW0pKSB8IChhbCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59XG5leHBvcnRzLnNocjY0X2xvID0gc2hyNjRfbG87XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5Jyk7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBmb3JtYXRzOiBmb3JtYXRzLFxuICAgIHBhcnNlOiBwYXJzZSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3FzL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGVja2JveCBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblxuXHRcdHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlLmJpbmQoIHRoaXMgKTtcblx0fVxuXG5cdHVwZGF0ZVZhbHVlKCB2YWx1ZSApIHtcblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBvbiBmaWVsZCBzZXR0aW5nc1xuXHRcdGlmICggdHlwZW9mIHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHQvLyBVcGRhdGUgZmllbGQgc3RhdGVcblx0XHRcdHRoaXMucHJvcHMudXBkYXRlUHJvcGVydHkoIHRoaXMucHJvcHMucHJvcGVydHksIHZhbHVlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFVwZGF0ZSBzdG9yZVxuXHRcdFx0dGhpcy5wcm9wcy5hY3Rpb25zLnNldHRpbmdzQWN0aW9ucy51cGRhdGVTZXR0aW5nKCB0aGlzLnByb3BzLnByb3BlcnR5LCB2YWx1ZSApO1xuXHRcdH1cblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCB2YWx1ZSA9IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXSApXG5cdFx0XHQ/IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlXG5cdFx0XHQ6IHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXTtcblxuXHRcdGNvbnN0IGZpZWxkSWQgPSBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmZpZWxkSWQgKVxuXHRcdFx0PyB0aGlzLnByb3BzLnByb3BlcnR5XG5cdFx0XHQ6IHRoaXMucHJvcHMuZmllbGRJZDtcblxuXHRcdGNvbnN0IGRpc2FibGVkID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmRpc2FibGVkICkgJiZcblx0XHRcdHRoaXMucHJvcHMuZGlzYWJsZWQgPyB0cnVlIDogZmFsc2U7XG5cblx0XHRsZXQgZXh0cmFDbGFzcyA9ICcnO1xuXG5cdFx0aWYgKCB0aGlzLnByb3BzLml0ZW1DbGFzcyAmJiAnJyAhPT0gdGhpcy5wcm9wcy5pdGVtQ2xhc3MgKSB7XG5cdFx0XHRleHRyYUNsYXNzID0gJyAnICsgdGhpcy5wcm9wcy5pdGVtQ2xhc3M7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxsYWJlbFxuXHRcdFx0XHRodG1sRm9yPXsgYGZvcm1pbmF0b3ItZmllbGQtJHsgZmllbGRJZCB9YCB9XG5cdFx0XHRcdGNsYXNzTmFtZT17IGBzdWktY2hlY2tib3gkeyBleHRyYUNsYXNzIH1gIH1cblx0XHRcdD5cblx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0dHlwZT1cImNoZWNrYm94XCJcblx0XHRcdFx0XHRpZD17IGBmb3JtaW5hdG9yLWZpZWxkLSR7IGZpZWxkSWQgfWAgfVxuXHRcdFx0XHRcdHZhbHVlPVwidHJ1ZVwiXG5cdFx0XHRcdFx0Y2hlY2tlZD17IHZhbHVlID8gJ2NoZWNrZWQnIDogJycgfVxuXHRcdFx0XHRcdGRpc2FibGVkPXsgZGlzYWJsZWQgfVxuXHRcdFx0XHRcdG9uQ2hhbmdlPXsgZSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZVZhbHVlKCBlLnRhcmdldC5jaGVja2VkICk7XG5cdFx0XHRcdFx0fSB9XG5cdFx0XHRcdC8+XG5cdFx0XHRcdDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cblx0XHRcdFx0eyB0aGlzLnByb3BzLmxhYmVsICYmXG5cdFx0XHRcdFx0PHNwYW4+XG5cdFx0XHRcdFx0XHR7IHRoaXMucHJvcHMubGFiZWwgfVxuXHRcdFx0XHRcdFx0eyAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMudG9vbHRpcCApICYmICcnICE9PSB0aGlzLnByb3BzLnRvb2x0aXAgJiYgKFxuXHRcdFx0XHRcdFx0XHQ8c3BhblxuXHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS10b29sdGlwIHN1aS10b29sdGlwLWNvbnN0cmFpbmVkXCJcblx0XHRcdFx0XHRcdFx0XHRzdHlsZT17IHtcblx0XHRcdFx0XHRcdFx0XHRcdG1hcmdpbkxlZnQ6IDEwLFxuXHRcdFx0XHRcdFx0XHRcdFx0dmVydGljYWxBbGlnbjogJ21pZGRsZScsXG5cdFx0XHRcdFx0XHRcdFx0XHQnLS10b29sdGlwLXdpZHRoJzogJzE2NXB4J1xuXHRcdFx0XHRcdFx0XHRcdH0gfVxuXHRcdFx0XHRcdFx0XHRcdGRhdGEtdG9vbHRpcD17IHRoaXMucHJvcHMudG9vbHRpcCB9XG5cdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHQ8c3BhblxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLWljb24taW5mb1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRhcmlhLWhpZGRlbj1cInRydWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0c3R5bGU9eyB7IHBvaW50ZXJFdmVudHM6ICdub25lJyB9IH1cblx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHQpfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0fVxuXHRcdFx0PC9sYWJlbD5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MvaW5wdXRzL2NoZWNrYm94LmpzIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy93YXJuaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuXG52YXIgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpIHtcbiAgdmFyIHByb21wdCA9IG51bGw7XG5cbiAgdmFyIHNldFByb21wdCA9IGZ1bmN0aW9uIHNldFByb21wdChuZXh0UHJvbXB0KSB7XG4gICAgd2FybmluZyhwcm9tcHQgPT0gbnVsbCwgJ0EgaGlzdG9yeSBzdXBwb3J0cyBvbmx5IG9uZSBwcm9tcHQgYXQgYSB0aW1lJyk7XG5cbiAgICBwcm9tcHQgPSBuZXh0UHJvbXB0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9tcHQgPT09IG5leHRQcm9tcHQpIHByb21wdCA9IG51bGw7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY29uZmlybVRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiBJZiBhbm90aGVyIHRyYW5zaXRpb24gc3RhcnRzIHdoaWxlIHdlJ3JlIHN0aWxsIGNvbmZpcm1pbmdcbiAgICAvLyB0aGUgcHJldmlvdXMgb25lLCB3ZSBtYXkgZW5kIHVwIGluIGEgd2VpcmQgc3RhdGUuIEZpZ3VyZSBvdXQgdGhlXG4gICAgLy8gYmVzdCB3YXkgdG8gaGFuZGxlIHRoaXMuXG4gICAgaWYgKHByb21wdCAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHlwZW9mIHByb21wdCA9PT0gJ2Z1bmN0aW9uJyA/IHByb21wdChsb2NhdGlvbiwgYWN0aW9uKSA6IHByb21wdDtcblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0VXNlckNvbmZpcm1hdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGdldFVzZXJDb25maXJtYXRpb24ocmVzdWx0LCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0EgaGlzdG9yeSBuZWVkcyBhIGdldFVzZXJDb25maXJtYXRpb24gZnVuY3Rpb24gaW4gb3JkZXIgdG8gdXNlIGEgcHJvbXB0IG1lc3NhZ2UnKTtcblxuICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gZmFsc2UgZnJvbSBhIHRyYW5zaXRpb24gaG9vayB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdCAhPT0gZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gIHZhciBhcHBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFwcGVuZExpc3RlbmVyKGZuKSB7XG4gICAgdmFyIGlzQWN0aXZlID0gdHJ1ZTtcblxuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgaWYgKGlzQWN0aXZlKSBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBub3RpZnlMaXN0ZW5lcnMgPSBmdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHNldFByb21wdDogc2V0UHJvbXB0LFxuICAgIGNvbmZpcm1UcmFuc2l0aW9uVG86IGNvbmZpcm1UcmFuc2l0aW9uVG8sXG4gICAgYXBwZW5kTGlzdGVuZXI6IGFwcGVuZExpc3RlbmVyLFxuICAgIG5vdGlmeUxpc3RlbmVyczogbm90aWZ5TGlzdGVuZXJzXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgUm91dGVyIGZyb20gXCJyZWFjdC1yb3V0ZXIvZXMvUm91dGVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IFJvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gXCJ3YXJuaW5nXCI7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gXCJpbnZhcmlhbnRcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcHV0dGluZyBoaXN0b3J5IG9uIGNvbnRleHQuXG4gKi9cblxudmFyIFJvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBtYXRjaDogX3RoaXMuY29tcHV0ZU1hdGNoKF90aGlzLnByb3BzLmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWUpXG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBSb3V0ZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGVyOiBfZXh0ZW5kcyh7fSwgdGhpcy5jb250ZXh0LnJvdXRlciwge1xuICAgICAgICBoaXN0b3J5OiB0aGlzLnByb3BzLmhpc3RvcnksXG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgbG9jYXRpb246IHRoaXMucHJvcHMuaGlzdG9yeS5sb2NhdGlvbixcbiAgICAgICAgICBtYXRjaDogdGhpcy5zdGF0ZS5tYXRjaFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wdXRlTWF0Y2ggPSBmdW5jdGlvbiBjb21wdXRlTWF0Y2gocGF0aG5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogXCIvXCIsXG4gICAgICB1cmw6IFwiL1wiLFxuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIGlzRXhhY3Q6IHBhdGhuYW1lID09PSBcIi9cIlxuICAgIH07XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGhpc3RvcnkgPSBfcHJvcHMuaGlzdG9yeTtcblxuXG4gICAgaW52YXJpYW50KGNoaWxkcmVuID09IG51bGwgfHwgUmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pID09PSAxLCBcIkEgPFJvdXRlcj4gbWF5IGhhdmUgb25seSBvbmUgY2hpbGQgZWxlbWVudFwiKTtcblxuICAgIC8vIERvIHRoaXMgaGVyZSBzbyB3ZSBjYW4gc2V0U3RhdGUgd2hlbiBhIDxSZWRpcmVjdD4gY2hhbmdlcyB0aGVcbiAgICAvLyBsb2NhdGlvbiBpbiBjb21wb25lbnRXaWxsTW91bnQuIFRoaXMgaGFwcGVucyBlLmcuIHdoZW4gZG9pbmdcbiAgICAvLyBzZXJ2ZXIgcmVuZGVyaW5nIHVzaW5nIGEgPFN0YXRpY1JvdXRlcj4uXG4gICAgdGhpcy51bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMi5zZXRTdGF0ZSh7XG4gICAgICAgIG1hdGNoOiBfdGhpczIuY29tcHV0ZU1hdGNoKGhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWUpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHdhcm5pbmcodGhpcy5wcm9wcy5oaXN0b3J5ID09PSBuZXh0UHJvcHMuaGlzdG9yeSwgXCJZb3UgY2Fubm90IGNoYW5nZSA8Um91dGVyIGhpc3Rvcnk+XCIpO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnVubGlzdGVuKCk7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcblxuICAgIHJldHVybiBjaGlsZHJlbiA/IFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Sb3V0ZXIucHJvcFR5cGVzID0ge1xuICBoaXN0b3J5OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufTtcblJvdXRlci5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdFxufTtcblJvdXRlci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IHBhdGhUb1JlZ2V4cCBmcm9tIFwicGF0aC10by1yZWdleHBcIjtcblxudmFyIHBhdHRlcm5DYWNoZSA9IHt9O1xudmFyIGNhY2hlTGltaXQgPSAxMDAwMDtcbnZhciBjYWNoZUNvdW50ID0gMDtcblxudmFyIGNvbXBpbGVQYXRoID0gZnVuY3Rpb24gY29tcGlsZVBhdGgocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgY2FjaGVLZXkgPSBcIlwiICsgb3B0aW9ucy5lbmQgKyBvcHRpb25zLnN0cmljdCArIG9wdGlvbnMuc2Vuc2l0aXZlO1xuICB2YXIgY2FjaGUgPSBwYXR0ZXJuQ2FjaGVbY2FjaGVLZXldIHx8IChwYXR0ZXJuQ2FjaGVbY2FjaGVLZXldID0ge30pO1xuXG4gIGlmIChjYWNoZVtwYXR0ZXJuXSkgcmV0dXJuIGNhY2hlW3BhdHRlcm5dO1xuXG4gIHZhciBrZXlzID0gW107XG4gIHZhciByZSA9IHBhdGhUb1JlZ2V4cChwYXR0ZXJuLCBrZXlzLCBvcHRpb25zKTtcbiAgdmFyIGNvbXBpbGVkUGF0dGVybiA9IHsgcmU6IHJlLCBrZXlzOiBrZXlzIH07XG5cbiAgaWYgKGNhY2hlQ291bnQgPCBjYWNoZUxpbWl0KSB7XG4gICAgY2FjaGVbcGF0dGVybl0gPSBjb21waWxlZFBhdHRlcm47XG4gICAgY2FjaGVDb3VudCsrO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBpbGVkUGF0dGVybjtcbn07XG5cbi8qKlxuICogUHVibGljIEFQSSBmb3IgbWF0Y2hpbmcgYSBVUkwgcGF0aG5hbWUgdG8gYSBwYXRoIHBhdHRlcm4uXG4gKi9cbnZhciBtYXRjaFBhdGggPSBmdW5jdGlvbiBtYXRjaFBhdGgocGF0aG5hbWUpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgcGFyZW50ID0gYXJndW1lbnRzWzJdO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikgb3B0aW9ucyA9IHsgcGF0aDogb3B0aW9ucyB9O1xuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwYXRoID0gX29wdGlvbnMucGF0aCxcbiAgICAgIF9vcHRpb25zJGV4YWN0ID0gX29wdGlvbnMuZXhhY3QsXG4gICAgICBleGFjdCA9IF9vcHRpb25zJGV4YWN0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJGV4YWN0LFxuICAgICAgX29wdGlvbnMkc3RyaWN0ID0gX29wdGlvbnMuc3RyaWN0LFxuICAgICAgc3RyaWN0ID0gX29wdGlvbnMkc3RyaWN0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJHN0cmljdCxcbiAgICAgIF9vcHRpb25zJHNlbnNpdGl2ZSA9IF9vcHRpb25zLnNlbnNpdGl2ZSxcbiAgICAgIHNlbnNpdGl2ZSA9IF9vcHRpb25zJHNlbnNpdGl2ZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfb3B0aW9ucyRzZW5zaXRpdmU7XG5cblxuICBpZiAocGF0aCA9PSBudWxsKSByZXR1cm4gcGFyZW50O1xuXG4gIHZhciBfY29tcGlsZVBhdGggPSBjb21waWxlUGF0aChwYXRoLCB7IGVuZDogZXhhY3QsIHN0cmljdDogc3RyaWN0LCBzZW5zaXRpdmU6IHNlbnNpdGl2ZSB9KSxcbiAgICAgIHJlID0gX2NvbXBpbGVQYXRoLnJlLFxuICAgICAga2V5cyA9IF9jb21waWxlUGF0aC5rZXlzO1xuXG4gIHZhciBtYXRjaCA9IHJlLmV4ZWMocGF0aG5hbWUpO1xuXG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gIHZhciB1cmwgPSBtYXRjaFswXSxcbiAgICAgIHZhbHVlcyA9IG1hdGNoLnNsaWNlKDEpO1xuXG4gIHZhciBpc0V4YWN0ID0gcGF0aG5hbWUgPT09IHVybDtcblxuICBpZiAoZXhhY3QgJiYgIWlzRXhhY3QpIHJldHVybiBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aDogcGF0aCwgLy8gdGhlIHBhdGggcGF0dGVybiB1c2VkIHRvIG1hdGNoXG4gICAgdXJsOiBwYXRoID09PSBcIi9cIiAmJiB1cmwgPT09IFwiXCIgPyBcIi9cIiA6IHVybCwgLy8gdGhlIG1hdGNoZWQgcG9ydGlvbiBvZiB0aGUgVVJMXG4gICAgaXNFeGFjdDogaXNFeGFjdCwgLy8gd2hldGhlciBvciBub3Qgd2UgbWF0Y2hlZCBleGFjdGx5XG4gICAgcGFyYW1zOiBrZXlzLnJlZHVjZShmdW5jdGlvbiAobWVtbywga2V5LCBpbmRleCkge1xuICAgICAgbWVtb1trZXkubmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwge30pXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtYXRjaFBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7IC8qIElnbm9yZSAqLyB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5kZWZhdWx0cy5oZWFkZXJzID0ge1xuICBjb21tb246IHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIvKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG52YXIgSTE4TiA9IHJlcXVpcmUoICcuL2xpYicgKSxcblx0aTE4biA9IG5ldyBJMThOKCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRudW1iZXJGb3JtYXQ6IGkxOG4ubnVtYmVyRm9ybWF0LmJpbmQoIGkxOG4gKSxcblx0dHJhbnNsYXRlOiBpMThuLnRyYW5zbGF0ZS5iaW5kKCBpMThuICksXG5cdGNvbmZpZ3VyZTogaTE4bi5jb25maWd1cmUuYmluZCggaTE4biApLFxuXHRzZXRMb2NhbGU6IGkxOG4uc2V0TG9jYWxlLmJpbmQoIGkxOG4gKSxcblx0Z2V0TG9jYWxlOiBpMThuLmdldExvY2FsZS5iaW5kKCBpMThuICksXG5cdGdldExvY2FsZVNsdWc6IGkxOG4uZ2V0TG9jYWxlU2x1Zy5iaW5kKCBpMThuICksXG5cdGFkZFRyYW5zbGF0aW9uczogaTE4bi5hZGRUcmFuc2xhdGlvbnMuYmluZCggaTE4biApLFxuXHRyZVJlbmRlclRyYW5zbGF0aW9uczogaTE4bi5yZVJlbmRlclRyYW5zbGF0aW9ucy5iaW5kKCBpMThuICksXG5cdHJlZ2lzdGVyQ29tcG9uZW50VXBkYXRlSG9vazogaTE4bi5yZWdpc3RlckNvbXBvbmVudFVwZGF0ZUhvb2suYmluZCggaTE4biApLFxuXHRyZWdpc3RlclRyYW5zbGF0ZUhvb2s6IGkxOG4ucmVnaXN0ZXJUcmFuc2xhdGVIb29rLmJpbmQoIGkxOG4gKSxcblx0c3RhdGU6IGkxOG4uc3RhdGUsXG5cdHN0YXRlT2JzZXJ2ZXI6IGkxOG4uc3RhdGVPYnNlcnZlcixcblx0b246IGkxOG4uc3RhdGVPYnNlcnZlci5vbi5iaW5kKGkxOG4uc3RhdGVPYnNlcnZlciksXG5cdG9mZjogaTE4bi5zdGF0ZU9ic2VydmVyLnJlbW92ZUxpc3RlbmVyLmJpbmQoaTE4bi5zdGF0ZU9ic2VydmVyKSxcblx0ZW1pdDogaTE4bi5zdGF0ZU9ic2VydmVyLmVtaXQuYmluZChpMThuLnN0YXRlT2JzZXJ2ZXIpLFxuXHRsb2NhbGl6ZTogcmVxdWlyZSggJy4vbGliL2xvY2FsaXplJyApKCBpMThuICksXG5cdCR0aGlzOiBpMThuLFxuXHRJMThOOiBJMThOXG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pMThuLXdwLXBsdWdpbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsIm1vZHVsZS5leHBvcnRzID0gYXNzZXJ0O1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcbiAgaWYgKCF2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xufVxuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBhc3NlcnRFcXVhbChsLCByLCBtc2cpIHtcbiAgaWYgKGwgIT0gcilcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICgnQXNzZXJ0aW9uIGZhaWxlZDogJyArIGwgKyAnICE9ICcgKyByKSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWluaW1hbGlzdGljLWFzc2VydC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKiogRGV0ZWN0IGlmIHByb3BlcnRpZXMgc2hhZG93aW5nIHRob3NlIG9uIGBPYmplY3QucHJvdG90eXBlYCBhcmUgbm9uLWVudW1lcmFibGUuICovXG52YXIgbm9uRW51bVNoYWRvd3MgPSAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7ICd2YWx1ZU9mJzogMSB9LCAndmFsdWVPZicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgLy8gU2FmYXJpIDkgbWFrZXMgYGFyZ3VtZW50cy5sZW5ndGhgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHZhciByZXN1bHQgPSAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKVxuICAgID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKVxuICAgIDogW107XG5cbiAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGgsXG4gICAgICBza2lwSW5kZXhlcyA9ICEhbGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKGtleSA9PSAnbGVuZ3RoJyB8fCBpc0luZGV4KGtleSwgbGVuZ3RoKSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gYXJyYXk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkID8gc291cmNlW2tleV0gOiBuZXdWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICghcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIHx8IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YCBhbmQgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEwLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25JblxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gQmFyKCkge1xuICogICB0aGlzLmMgPSAzO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gKi9cbnZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICBpZiAobm9uRW51bVNoYWRvd3MgfHwgaXNQcm90b3R5cGUoc291cmNlKSB8fCBpc0FycmF5TGlrZShzb3VyY2UpKSB7XG4gICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IE1vZGFsQ2xvc2UgZnJvbSAnLi9jbG9zZSc7XG5pbXBvcnQgTW9kYWxJbWFnZSBmcm9tICcuL2ltYWdlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kYWxIZWFkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdFx0dGhpcy5jbG9zZU1vZGFsID0gdGhpcy5wcm9wcy5jbG9zZU1vZGFsLmJpbmQoIHRoaXMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLm1hcCggdGhpcy5wcm9wcy5jaGlsZHJlbiwgY29udGVudCA9PiB7XG5cdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHR9ICk7XG5cblx0XHRjb25zdCBhbGlnbm1lbnQgPSAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5hbGlnbm1lbnQgKSAmJiAnJyAhPT0gdGhpcy5wcm9wcy5hbGlnbm1lbnQgKVxuXHRcdFx0PyB0aGlzLnByb3BzLmFsaWdubWVudFxuXHRcdFx0OiAnJztcblxuXHRcdGNvbnN0IGZsYXR0ZW4gPSAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5mbGF0dGVuICkgJiYgdHJ1ZSA9PT0gdGhpcy5wcm9wcy5mbGF0dGVuIClcblx0XHRcdD8gdHJ1ZVxuXHRcdFx0OiBmYWxzZTtcblxuXHRcdGNvbnN0IGhhc0Nsb3NlID0gKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuY2FuQ2xvc2UgKSAmJiBmYWxzZSA9PT0gdGhpcy5wcm9wcy5jYW5DbG9zZSApXG5cdFx0XHQ/IGZhbHNlXG5cdFx0XHQ6IHRydWU7XG5cblx0XHRjb25zdCBjbG9zZVR5cGUgPSAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5jbG9zZVR5cGUgKSAmJiAnJyAhPT0gdGhpcy5wcm9wcy5jbG9zZVR5cGUgKVxuXHRcdFx0PyB0aGlzLnByb3BzLmNsb3NlVHlwZVxuXHRcdFx0OiAnJztcblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5cdFx0Y29uc3QgY2xvc2VDb2xvciA9ICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmNsb3NlQ29sb3IgKSAmJiAnJyAhPT0gdGhpcy5wcm9wcy5jbG9zZUNvbG9yIClcblx0XHRcdD8gdGhpcy5wcm9wcy5jbG9zZUNvbG9yXG5cdFx0XHQ6ICdkZWZhdWx0JztcblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5cdFx0Y29uc3QgaGFzSW1hZ2UgPSAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5pbWFnZU5hbWUgKSAmJiAnJyAhPT0gdGhpcy5wcm9wcy5pbWFnZU5hbWUgKVxuXHRcdFx0PyB0cnVlXG5cdFx0XHQ6IGZhbHNlO1xuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cblx0XHRjb25zdCBpc0xvZ28gPSAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5pbWFnZUxvZ28gKSAmJiB0cnVlID09PSB0aGlzLnByb3BzLmltYWdlTG9nbyApXG5cdFx0XHQ/IHRydWVcblx0XHRcdDogZmFsc2U7XG5cblx0XHRjb25zdCBoYXNBbHQgPSAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5pbWFnZUFsdCApICYmIHRydWUgPT09IHRoaXMucHJvcHMuaW1hZ2VBbHQgKVxuXHRcdFx0PyB0aGlzLnByb3BzLmltYWdlQWx0XG5cdFx0XHQ6ICcnO1xuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cblx0XHRjb25zdCBoYXNDbGFzcyA9ICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmN1c3RvbUNsYXNzICkgJiYgJycgIT09IHRoaXMucHJvcHMuY3VzdG9tQ2xhc3MgKVxuXHRcdFx0PyB0cnVlXG5cdFx0XHQ6IGZhbHNlO1xuXG5cdFx0bGV0IGVsQ2xhc3MgPSAnc3VpLWJveC1oZWFkZXInO1xuXG5cdFx0aWYgKCAnJyAhPT0gYWxpZ25tZW50ICkge1xuXHRcdFx0ZWxDbGFzcyArPSAnIHN1aS1jb250ZW50LScgKyBhbGlnbm1lbnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCB0cnVlID09PSBmbGF0dGVuICkge1xuXHRcdFx0ZWxDbGFzcyArPSAnIHN1aS1mbGF0dGVuJztcblx0XHR9XG5cblx0XHRpZiAoIHRydWUgPT09IGhhc0ltYWdlICkge1xuXHRcdFx0ZWxDbGFzcyArPSAnIHN1aS1zcGFjaW5nLXRvcC0tNjAnO1xuXHRcdH1cblxuXHRcdGlmICggdHJ1ZSA9PT0gaGFzQ2xhc3MgKSB7XG5cdFx0XHRlbENsYXNzICs9ICcgJyArIHRoaXMucHJvcHMuY3VzdG9tQ2xhc3M7XG5cdFx0fVxuXG5cdFx0bGV0IG1hcmt1cCA9IChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPXsgZWxDbGFzcyB9PlxuXG5cdFx0XHRcdHsgdHJ1ZSA9PT0gaGFzQ2xvc2UgJiZcblx0XHRcdFx0XHQ8TW9kYWxDbG9zZVxuXHRcdFx0XHRcdFx0dHlwZT17IGNsb3NlVHlwZSB9XG5cdFx0XHRcdFx0XHRmbG9hdD1cInJpZ2h0XCJcblx0XHRcdFx0XHRcdGNvbG9yPXsgY2xvc2VDb2xvciB9XG5cdFx0XHRcdFx0XHR7IC4uLiBoYXNDbG9zZSAmJiB7IGNsb3NlTW9kYWw6IHRoaXMuY2xvc2VNb2RhbCB9IH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHR9XG5cblx0XHRcdFx0eyB0cnVlID09PSBoYXNJbWFnZSAmJlxuXHRcdFx0XHRcdDxNb2RhbEltYWdlXG5cdFx0XHRcdFx0XHRsb2dvPXsgaXNMb2dvIH1cblx0XHRcdFx0XHRcdGZpbGVuYW1lPXsgdGhpcy5wcm9wcy5pbWFnZU5hbWUgfVxuXHRcdFx0XHRcdFx0YWx0PXsgaGFzQWx0IH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHR9XG5cblx0XHRcdFx0eyBjaGlsZHJlbiB9XG5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cblx0XHRpZiAoICdjZW50ZXInICE9PSBhbGlnbm1lbnQgKSB7XG5cdFx0XHRtYXJrdXAgPSAoXG5cdFx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblxuXHRcdFx0XHRcdHsgdHJ1ZSA9PT0gaGFzQ2xvc2UgJiZcblx0XHRcdFx0XHRcdDxNb2RhbENsb3NlXG5cdFx0XHRcdFx0XHRcdHNyb25seT17IHRydWUgfVxuXHRcdFx0XHRcdFx0XHR7IC4uLiBoYXNDbG9zZSAmJiB7IGNsb3NlTW9kYWw6IHRoaXMuY2xvc2VNb2RhbCB9IH1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9eyBlbENsYXNzIH0+XG5cblx0XHRcdFx0XHRcdHsgdHJ1ZSA9PT0gaGFzSW1hZ2UgJiZcblx0XHRcdFx0XHRcdFx0PE1vZGFsSW1hZ2Vcblx0XHRcdFx0XHRcdFx0XHRsb2dvPXsgaXNMb2dvIH1cblx0XHRcdFx0XHRcdFx0XHRmaWxlbmFtZT17IHRoaXMucHJvcHMuaW1hZ2VOYW1lIH1cblx0XHRcdFx0XHRcdFx0XHRhbHQ9eyBoYXNBbHQgfVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR7IGNoaWxkcmVuIH1cblxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYWN0aW9ucy1yaWdodFwiPlxuXG5cdFx0XHRcdFx0XHRcdHsgdHJ1ZSA9PT0gaGFzQ2xvc2UgJiZcblx0XHRcdFx0XHRcdFx0XHQ8TW9kYWxDbG9zZVxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZT17IGNsb3NlVHlwZSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRjb2xvcj17IGNsb3NlQ29sb3IgfVxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VNb2RhbD17IHRoaXMuY2xvc2VNb2RhbCB9XG5cdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXJrdXA7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvbW9kYWxzL3BhcnRpYWxzL2hlYWRlci5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGFsQ2xvc2UgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdFx0dGhpcy5jbG9zZU1vZGFsID0gdGhpcy5wcm9wcy5jbG9zZU1vZGFsLmJpbmQoIHRoaXMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBsYWJlbCA9ICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmxhYmVsICkgJiYgJycgIT09IHRoaXMucHJvcHMubGFiZWwgKVxuXHRcdFx0PyB0aGlzLnByb3BzLmxhYmVsXG5cdFx0XHQ6IHRyYW5zbGF0ZSggJ0Nsb3NlIHRoaXMgZGlhbG9nJyApO1xuXG5cdFx0Y29uc3QgY29sb3IgPSAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5jb2xvciApICYmICcnICE9PSB0aGlzLnByb3BzLmNvbG9yIClcblx0XHRcdD8gdGhpcy5wcm9wcy5jb2xvclxuXHRcdFx0OiAnJztcblxuXHRcdGNvbnN0IGlzSWNvbiA9ICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnR5cGUgKSAmJiAnaWNvbicgPT09IHRoaXMucHJvcHMudHlwZSApXG5cdFx0XHQ/IHRydWVcblx0XHRcdDogZmFsc2U7XG5cblx0XHRjb25zdCBpc0hpZGRlbiA9ICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNyb25seSApICYmIHRydWUgPT09IHRoaXMucHJvcHMuc3Jvbmx5IClcblx0XHRcdD8gdHJ1ZVxuXHRcdFx0OiBmYWxzZTtcblxuXHRcdGNvbnN0IGhhc0ljb24gPSAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5pY29uICkgJiYgJycgIT09IHRoaXMucHJvcHMuaWNvbiApXG5cdFx0XHQ/IHRydWVcblx0XHRcdDogZmFsc2U7XG5cblx0XHRjb25zdCBmbG9hdHNMZWZ0ID0gKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZmxvYXQgKSAmJiAnbGVmdCcgPT09IHRoaXMucHJvcHMuZmxvYXQgKVxuXHRcdFx0PyB0cnVlXG5cdFx0XHQ6IGZhbHNlO1xuXG5cdFx0Y29uc3QgZmxvYXRzUmlnaHQgPSAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5mbG9hdCApICYmICdyaWdodCcgPT09IHRoaXMucHJvcHMuZmxvYXQgKVxuXHRcdFx0PyB0cnVlXG5cdFx0XHQ6IGZhbHNlO1xuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cblx0XHRjb25zdCBoYXNDdXN0b21DbGFzcyA9ICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLmN1c3RvbUNsYXNzICkgJiYgJycgIT09IHRoaXMucHJvcHMuY3VzdG9tQ2xhc3MgKVxuXHRcdFx0PyB0cnVlXG5cdFx0XHQ6IGZhbHNlO1xuXG5cdFx0bGV0IGVsQ2xhc3MgPSAnc3VpLWJ1dHRvbic7XG5cblx0XHRpZiAoIHRydWUgPT09IGlzSGlkZGVuICkge1xuXHRcdFx0ZWxDbGFzcyA9ICdzdWktc2NyZWVuLXJlYWRlci10ZXh0Jztcblx0XHR9IGVsc2UgaWYgKCBmYWxzZSA9PT0gaXNIaWRkZW4gJiYgdHJ1ZSA9PT0gaXNJY29uICkge1xuXHRcdFx0ZWxDbGFzcyA9ICdzdWktYnV0dG9uLWljb24nO1xuXHRcdH1cblxuXHRcdGlmICggZmFsc2UgPT09IGlzSGlkZGVuICYmICcnICE9PSBjb2xvciApIHtcblx0XHRcdGVsQ2xhc3MgKz0gJyBzdWktYnV0dG9uLScgKyBjb2xvcjtcblx0XHR9XG5cblx0XHRpZiAoIGZhbHNlID09PSBpc0hpZGRlbiAmJiAoIHRydWUgPT09IGZsb2F0c0xlZnQgfHwgdHJ1ZSA9PT0gZmxvYXRzUmlnaHQgKSApIHtcblx0XHRcdGVsQ2xhc3MgKz0gJyBzdWktYnV0dG9uLWZsb2F0LS0nICsgdGhpcy5wcm9wcy5mbG9hdDtcblx0XHR9XG5cblx0XHRpZiAoIHRydWUgPT09IGhhc0N1c3RvbUNsYXNzICkge1xuXHRcdFx0ZWxDbGFzcyArPSAnICcgKyB0aGlzLnByb3BzLmN1c3RvbUNsYXNzO1xuXHRcdH1cblxuXHRcdGVsQ2xhc3MgKz0gJyBtb2RhbC1jbG9zZS1idXR0b24nO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b24gY2xhc3NOYW1lPXsgZWxDbGFzcyB9IG9uQ2xpY2s9eyB0aGlzLmNsb3NlTW9kYWwgfT5cblx0XHRcdFx0eyB0cnVlID09PSBpc0ljb24gJiZcblx0XHRcdFx0XHQ8aSBjbGFzc05hbWU9XCJzdWktaWNvbi1jbG9zZSBzdWktbWRcIiBhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuXHRcdFx0XHR9XG5cdFx0XHRcdHsgdHJ1ZSA9PT0gaGFzSWNvbiAmJlxuXHRcdFx0XHRcdDxpIGNsYXNzTmFtZT17ICdzdWktaWNvbi0nICsgdGhpcy5wcm9wcy5pY29uIH0gYXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cblx0XHRcdFx0fVxuXHRcdFx0XHR7ICggdHJ1ZSA9PT0gaXNJY29uIClcblx0XHRcdFx0XHQ/IDxzcGFuIGNsYXNzTmFtZT1cInN1aS1zY3JlZW4tcmVhZGVyLXRleHRcIj57IGxhYmVsIH08L3NwYW4+XG5cdFx0XHRcdFx0OiBsYWJlbFxuXHRcdFx0XHR9XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL21vZGFscy9wYXJ0aWFscy9jbG9zZS5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGFsVGl0bGUgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgdGl0bGVJZCA9IHRoaXMucHJvcHMuaWRcblx0XHRcdD8gJ21vZGFsLScgKyB0aGlzLnByb3BzLmlkICsgJy0tdGl0bGUnXG5cdFx0XHQ6ICd1bmlxdWUtaWQtcmVxdWlyZWQnO1xuXG5cdFx0Y29uc3QgdGl0bGVMYWJlbCA9IHRoaXMucHJvcHMubGFiZWxcblx0XHRcdD8gdGhpcy5wcm9wcy5sYWJlbFxuXHRcdFx0OiAnQSB0aXRsZSBpcyByZXF1aXJlZCBmb3IgeW91ciBtb2RhbHMnO1xuXG5cdFx0Y29uc3QgdGl0bGVUYWcgPSAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy50YWcgKSAmJiAnJyAhPT0gdGhpcy5wcm9wcy50YWcgKVxuXHRcdFx0PyB0aGlzLnByb3BzLnRhZ1xuXHRcdFx0OiAnJztcblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5cdFx0Y29uc3QgdGl0bGVUYWdDb2xvciA9ICggISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnRhZ0NvbG9yICkgJiYgJycgIT09IHRoaXMucHJvcHMudGFnQ29sb3IgKVxuXHRcdFx0PyAnIHN1aS10YWctJyArIHRoaXMucHJvcHMudGl0bGVUYWdDb2xvclxuXHRcdFx0OiAnJztcblxuXHRcdGxldCB0aXRsZUNsYXNzID0gJ3N1aS1ib3gtdGl0bGUnO1xuXG5cdFx0aWYgKCAnbGcnID09PSB0aGlzLnByb3BzLnNpemUgKSB7XG5cdFx0XHR0aXRsZUNsYXNzICs9ICcgc3VpLWxnJztcblx0XHR9XG5cblx0XHRpZiAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5jdXN0b21DbGFzcyApICYmICcnICE9PSB0aGlzLnByb3BzLmN1c3RvbUNsYXNzICkge1xuXHRcdFx0dGl0bGVDbGFzcyArPSAnICcgKyB0aGlzLnByb3BzLmN1c3RvbUNsYXNzO1xuXHRcdH1cblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8aDMgaWQ9eyB0aXRsZUlkIH0gY2xhc3NOYW1lPXsgdGl0bGVDbGFzcyB9PlxuXHRcdFx0XHR7IHRpdGxlTGFiZWwgfVxuXHRcdFx0XHR7ICcnICE9PSB0aXRsZVRhZyAmJlxuXHRcdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9eyAnc3VpLXRhZycgKyB0aXRsZVRhZ0NvbG9yIH1cblx0XHRcdFx0XHRcdHN0eWxlPXsgeyBtYXJnaW5Ub3A6ICctMnB4JywgbWFyZ2luTGVmdDogJzEwcHgnIH0gfVxuXHRcdFx0XHRcdD57IHRpdGxlVGFnIH08L3NwYW4+XG5cdFx0XHRcdH1cblx0XHRcdDwvaDM+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Zvcm0vY29tcG9uZW50cy9tb2RhbHMvcGFydGlhbHMvdGl0bGUuanMiLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5leHBvcnQgdmFyIHN1YnNjcmlwdGlvblNoYXBlID0gUHJvcFR5cGVzLnNoYXBlKHtcbiAgdHJ5U3Vic2NyaWJlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB0cnlVbnN1YnNjcmliZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgbm90aWZ5TmVzdGVkU3ViczogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgaXNTdWJzY3JpYmVkOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59KTtcblxuZXhwb3J0IHZhciBzdG9yZVNoYXBlID0gUHJvcFR5cGVzLnNoYXBlKHtcbiAgc3Vic2NyaWJlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBkaXNwYXRjaDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZ2V0U3RhdGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL1Byb3BUeXBlcy5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IGhvaXN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgeyBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBTdWJzY3JpcHRpb24gZnJvbSAnLi4vdXRpbHMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IHN0b3JlU2hhcGUsIHN1YnNjcmlwdGlvblNoYXBlIH0gZnJvbSAnLi4vdXRpbHMvUHJvcFR5cGVzJztcblxudmFyIGhvdFJlbG9hZGluZ1ZlcnNpb24gPSAwO1xudmFyIGR1bW15U3RhdGUgPSB7fTtcbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZnVuY3Rpb24gbWFrZVNlbGVjdG9yU3RhdGVmdWwoc291cmNlU2VsZWN0b3IsIHN0b3JlKSB7XG4gIC8vIHdyYXAgdGhlIHNlbGVjdG9yIGluIGFuIG9iamVjdCB0aGF0IHRyYWNrcyBpdHMgcmVzdWx0cyBiZXR3ZWVuIHJ1bnMuXG4gIHZhciBzZWxlY3RvciA9IHtcbiAgICBydW46IGZ1bmN0aW9uIHJ1bkNvbXBvbmVudFNlbGVjdG9yKHByb3BzKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmV4dFByb3BzID0gc291cmNlU2VsZWN0b3Ioc3RvcmUuZ2V0U3RhdGUoKSwgcHJvcHMpO1xuICAgICAgICBpZiAobmV4dFByb3BzICE9PSBzZWxlY3Rvci5wcm9wcyB8fCBzZWxlY3Rvci5lcnJvcikge1xuICAgICAgICAgIHNlbGVjdG9yLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgc2VsZWN0b3IucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICAgICAgc2VsZWN0b3IuZXJyb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSB0cnVlO1xuICAgICAgICBzZWxlY3Rvci5lcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZWN0b3I7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbm5lY3RBZHZhbmNlZChcbi8qXG4gIHNlbGVjdG9yRmFjdG9yeSBpcyBhIGZ1bmMgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgcmV0dXJuaW5nIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB1c2VkIHRvXG4gIGNvbXB1dGUgbmV3IHByb3BzIGZyb20gc3RhdGUsIHByb3BzLCBhbmQgZGlzcGF0Y2guIEZvciBleGFtcGxlOlxuICAgICBleHBvcnQgZGVmYXVsdCBjb25uZWN0QWR2YW5jZWQoKGRpc3BhdGNoLCBvcHRpb25zKSA9PiAoc3RhdGUsIHByb3BzKSA9PiAoe1xuICAgICAgdGhpbmc6IHN0YXRlLnRoaW5nc1twcm9wcy50aGluZ0lkXSxcbiAgICAgIHNhdmVUaGluZzogZmllbGRzID0+IGRpc3BhdGNoKGFjdGlvbkNyZWF0b3JzLnNhdmVUaGluZyhwcm9wcy50aGluZ0lkLCBmaWVsZHMpKSxcbiAgICB9KSkoWW91ckNvbXBvbmVudClcbiAgIEFjY2VzcyB0byBkaXNwYXRjaCBpcyBwcm92aWRlZCB0byB0aGUgZmFjdG9yeSBzbyBzZWxlY3RvckZhY3RvcmllcyBjYW4gYmluZCBhY3Rpb25DcmVhdG9yc1xuICBvdXRzaWRlIG9mIHRoZWlyIHNlbGVjdG9yIGFzIGFuIG9wdGltaXphdGlvbi4gT3B0aW9ucyBwYXNzZWQgdG8gY29ubmVjdEFkdmFuY2VkIGFyZSBwYXNzZWQgdG9cbiAgdGhlIHNlbGVjdG9yRmFjdG9yeSwgYWxvbmcgd2l0aCBkaXNwbGF5TmFtZSBhbmQgV3JhcHBlZENvbXBvbmVudCwgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgIE5vdGUgdGhhdCBzZWxlY3RvckZhY3RvcnkgaXMgcmVzcG9uc2libGUgZm9yIGFsbCBjYWNoaW5nL21lbW9pemF0aW9uIG9mIGluYm91bmQgYW5kIG91dGJvdW5kXG4gIHByb3BzLiBEbyBub3QgdXNlIGNvbm5lY3RBZHZhbmNlZCBkaXJlY3RseSB3aXRob3V0IG1lbW9pemluZyByZXN1bHRzIGJldHdlZW4gY2FsbHMgdG8geW91clxuICBzZWxlY3Rvciwgb3RoZXJ3aXNlIHRoZSBDb25uZWN0IGNvbXBvbmVudCB3aWxsIHJlLXJlbmRlciBvbiBldmVyeSBzdGF0ZSBvciBwcm9wcyBjaGFuZ2UuXG4qL1xuc2VsZWN0b3JGYWN0b3J5KSB7XG4gIHZhciBfY29udGV4dFR5cGVzLCBfY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgX3JlZiRnZXREaXNwbGF5TmFtZSA9IF9yZWYuZ2V0RGlzcGxheU5hbWUsXG4gICAgICBnZXREaXNwbGF5TmFtZSA9IF9yZWYkZ2V0RGlzcGxheU5hbWUgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICdDb25uZWN0QWR2YW5jZWQoJyArIG5hbWUgKyAnKSc7XG4gIH0gOiBfcmVmJGdldERpc3BsYXlOYW1lLFxuICAgICAgX3JlZiRtZXRob2ROYW1lID0gX3JlZi5tZXRob2ROYW1lLFxuICAgICAgbWV0aG9kTmFtZSA9IF9yZWYkbWV0aG9kTmFtZSA9PT0gdW5kZWZpbmVkID8gJ2Nvbm5lY3RBZHZhbmNlZCcgOiBfcmVmJG1ldGhvZE5hbWUsXG4gICAgICBfcmVmJHJlbmRlckNvdW50UHJvcCA9IF9yZWYucmVuZGVyQ291bnRQcm9wLFxuICAgICAgcmVuZGVyQ291bnRQcm9wID0gX3JlZiRyZW5kZXJDb3VudFByb3AgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF9yZWYkcmVuZGVyQ291bnRQcm9wLFxuICAgICAgX3JlZiRzaG91bGRIYW5kbGVTdGF0ID0gX3JlZi5zaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMgPSBfcmVmJHNob3VsZEhhbmRsZVN0YXQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmJHNob3VsZEhhbmRsZVN0YXQsXG4gICAgICBfcmVmJHN0b3JlS2V5ID0gX3JlZi5zdG9yZUtleSxcbiAgICAgIHN0b3JlS2V5ID0gX3JlZiRzdG9yZUtleSA9PT0gdW5kZWZpbmVkID8gJ3N0b3JlJyA6IF9yZWYkc3RvcmVLZXksXG4gICAgICBfcmVmJHdpdGhSZWYgPSBfcmVmLndpdGhSZWYsXG4gICAgICB3aXRoUmVmID0gX3JlZiR3aXRoUmVmID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkd2l0aFJlZixcbiAgICAgIGNvbm5lY3RPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnZ2V0RGlzcGxheU5hbWUnLCAnbWV0aG9kTmFtZScsICdyZW5kZXJDb3VudFByb3AnLCAnc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzJywgJ3N0b3JlS2V5JywgJ3dpdGhSZWYnXSk7XG5cbiAgdmFyIHN1YnNjcmlwdGlvbktleSA9IHN0b3JlS2V5ICsgJ1N1YnNjcmlwdGlvbic7XG4gIHZhciB2ZXJzaW9uID0gaG90UmVsb2FkaW5nVmVyc2lvbisrO1xuXG4gIHZhciBjb250ZXh0VHlwZXMgPSAoX2NvbnRleHRUeXBlcyA9IHt9LCBfY29udGV4dFR5cGVzW3N0b3JlS2V5XSA9IHN0b3JlU2hhcGUsIF9jb250ZXh0VHlwZXNbc3Vic2NyaXB0aW9uS2V5XSA9IHN1YnNjcmlwdGlvblNoYXBlLCBfY29udGV4dFR5cGVzKTtcbiAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gKF9jaGlsZENvbnRleHRUeXBlcyA9IHt9LCBfY2hpbGRDb250ZXh0VHlwZXNbc3Vic2NyaXB0aW9uS2V5XSA9IHN1YnNjcmlwdGlvblNoYXBlLCBfY2hpbGRDb250ZXh0VHlwZXMpO1xuXG4gIHJldHVybiBmdW5jdGlvbiB3cmFwV2l0aENvbm5lY3QoV3JhcHBlZENvbXBvbmVudCkge1xuICAgIGludmFyaWFudCh0eXBlb2YgV3JhcHBlZENvbXBvbmVudCA9PSAnZnVuY3Rpb24nLCAnWW91IG11c3QgcGFzcyBhIGNvbXBvbmVudCB0byB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgJyArIChtZXRob2ROYW1lICsgJy4gSW5zdGVhZCByZWNlaXZlZCAnICsgSlNPTi5zdHJpbmdpZnkoV3JhcHBlZENvbXBvbmVudCkpKTtcblxuICAgIHZhciB3cmFwcGVkQ29tcG9uZW50TmFtZSA9IFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xuXG4gICAgdmFyIGRpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWUod3JhcHBlZENvbXBvbmVudE5hbWUpO1xuXG4gICAgdmFyIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgY29ubmVjdE9wdGlvbnMsIHtcbiAgICAgIGdldERpc3BsYXlOYW1lOiBnZXREaXNwbGF5TmFtZSxcbiAgICAgIG1ldGhvZE5hbWU6IG1ldGhvZE5hbWUsXG4gICAgICByZW5kZXJDb3VudFByb3A6IHJlbmRlckNvdW50UHJvcCxcbiAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlczogc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgc3RvcmVLZXk6IHN0b3JlS2V5LFxuICAgICAgd2l0aFJlZjogd2l0aFJlZixcbiAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgIHdyYXBwZWRDb21wb25lbnROYW1lOiB3cmFwcGVkQ29tcG9uZW50TmFtZSxcbiAgICAgIFdyYXBwZWRDb21wb25lbnQ6IFdyYXBwZWRDb21wb25lbnRcbiAgICB9KTtcblxuICAgIHZhciBDb25uZWN0ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICAgIF9pbmhlcml0cyhDb25uZWN0LCBfQ29tcG9uZW50KTtcblxuICAgICAgZnVuY3Rpb24gQ29ubmVjdChwcm9wcywgY29udGV4dCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29ubmVjdCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSk7XG5cbiAgICAgICAgX3RoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIF90aGlzLnN0YXRlID0ge307XG4gICAgICAgIF90aGlzLnJlbmRlckNvdW50ID0gMDtcbiAgICAgICAgX3RoaXMuc3RvcmUgPSBwcm9wc1tzdG9yZUtleV0gfHwgY29udGV4dFtzdG9yZUtleV07XG4gICAgICAgIF90aGlzLnByb3BzTW9kZSA9IEJvb2xlYW4ocHJvcHNbc3RvcmVLZXldKTtcbiAgICAgICAgX3RoaXMuc2V0V3JhcHBlZEluc3RhbmNlID0gX3RoaXMuc2V0V3JhcHBlZEluc3RhbmNlLmJpbmQoX3RoaXMpO1xuXG4gICAgICAgIGludmFyaWFudChfdGhpcy5zdG9yZSwgJ0NvdWxkIG5vdCBmaW5kIFwiJyArIHN0b3JlS2V5ICsgJ1wiIGluIGVpdGhlciB0aGUgY29udGV4dCBvciBwcm9wcyBvZiAnICsgKCdcIicgKyBkaXNwbGF5TmFtZSArICdcIi4gRWl0aGVyIHdyYXAgdGhlIHJvb3QgY29tcG9uZW50IGluIGEgPFByb3ZpZGVyPiwgJykgKyAoJ29yIGV4cGxpY2l0bHkgcGFzcyBcIicgKyBzdG9yZUtleSArICdcIiBhcyBhIHByb3AgdG8gXCInICsgZGlzcGxheU5hbWUgKyAnXCIuJykpO1xuXG4gICAgICAgIF90aGlzLmluaXRTZWxlY3RvcigpO1xuICAgICAgICBfdGhpcy5pbml0U3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgICB2YXIgX3JlZjI7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBjb21wb25lbnQgcmVjZWl2ZWQgc3RvcmUgZnJvbSBwcm9wcywgaXRzIHN1YnNjcmlwdGlvbiBzaG91bGQgYmUgdHJhbnNwYXJlbnRcbiAgICAgICAgLy8gdG8gYW55IGRlc2NlbmRhbnRzIHJlY2VpdmluZyBzdG9yZStzdWJzY3JpcHRpb24gZnJvbSBjb250ZXh0OyBpdCBwYXNzZXMgYWxvbmdcbiAgICAgICAgLy8gc3Vic2NyaXB0aW9uIHBhc3NlZCB0byBpdC4gT3RoZXJ3aXNlLCBpdCBzaGFkb3dzIHRoZSBwYXJlbnQgc3Vic2NyaXB0aW9uLCB3aGljaCBhbGxvd3NcbiAgICAgICAgLy8gQ29ubmVjdCB0byBjb250cm9sIG9yZGVyaW5nIG9mIG5vdGlmaWNhdGlvbnMgdG8gZmxvdyB0b3AtZG93bi5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMucHJvcHNNb2RlID8gbnVsbCA6IHRoaXMuc3Vic2NyaXB0aW9uO1xuICAgICAgICByZXR1cm4gX3JlZjIgPSB7fSwgX3JlZjJbc3Vic2NyaXB0aW9uS2V5XSA9IHN1YnNjcmlwdGlvbiB8fCB0aGlzLmNvbnRleHRbc3Vic2NyaXB0aW9uS2V5XSwgX3JlZjI7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuO1xuXG4gICAgICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBmaXJlcyBkdXJpbmcgc2VydmVyIHNpZGUgcmVuZGVyaW5nLCBidXQgY29tcG9uZW50RGlkTW91bnQgYW5kXG4gICAgICAgIC8vIGNvbXBvbmVudFdpbGxVbm1vdW50IGRvIG5vdC4gQmVjYXVzZSBvZiB0aGlzLCB0cnlTdWJzY3JpYmUgaGFwcGVucyBkdXJpbmcgLi4uZGlkTW91bnQuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdW5zdWJzY3JpcHRpb24gd291bGQgbmV2ZXIgdGFrZSBwbGFjZSBkdXJpbmcgU1NSLCBjYXVzaW5nIGEgbWVtb3J5IGxlYWsuXG4gICAgICAgIC8vIFRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhIGNoaWxkIGNvbXBvbmVudCBtYXkgaGF2ZSB0cmlnZ2VyZWQgYSBzdGF0ZSBjaGFuZ2UgYnlcbiAgICAgICAgLy8gZGlzcGF0Y2hpbmcgYW4gYWN0aW9uIGluIGl0cyBjb21wb25lbnRXaWxsTW91bnQsIHdlIGhhdmUgdG8gcmUtcnVuIHRoZSBzZWxlY3QgYW5kIG1heWJlXG4gICAgICAgIC8vIHJlLXJlbmRlci5cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IucnVuKHRoaXMucHJvcHMpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUpIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bihuZXh0UHJvcHMpO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGU7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHRoaXMuc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzID0gbm9vcDtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IucnVuID0gbm9vcDtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmdldFdyYXBwZWRJbnN0YW5jZSA9IGZ1bmN0aW9uIGdldFdyYXBwZWRJbnN0YW5jZSgpIHtcbiAgICAgICAgaW52YXJpYW50KHdpdGhSZWYsICdUbyBhY2Nlc3MgdGhlIHdyYXBwZWQgaW5zdGFuY2UsIHlvdSBuZWVkIHRvIHNwZWNpZnkgJyArICgneyB3aXRoUmVmOiB0cnVlIH0gaW4gdGhlIG9wdGlvbnMgYXJndW1lbnQgb2YgdGhlICcgKyBtZXRob2ROYW1lICsgJygpIGNhbGwuJykpO1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVkSW5zdGFuY2U7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5zZXRXcmFwcGVkSW5zdGFuY2UgPSBmdW5jdGlvbiBzZXRXcmFwcGVkSW5zdGFuY2UocmVmKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZEluc3RhbmNlID0gcmVmO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuaW5pdFNlbGVjdG9yID0gZnVuY3Rpb24gaW5pdFNlbGVjdG9yKCkge1xuICAgICAgICB2YXIgc291cmNlU2VsZWN0b3IgPSBzZWxlY3RvckZhY3RvcnkodGhpcy5zdG9yZS5kaXNwYXRjaCwgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBtYWtlU2VsZWN0b3JTdGF0ZWZ1bChzb3VyY2VTZWxlY3RvciwgdGhpcy5zdG9yZSk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IucnVuKHRoaXMucHJvcHMpO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuaW5pdFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIGluaXRTdWJzY3JpcHRpb24oKSB7XG4gICAgICAgIGlmICghc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSByZXR1cm47XG5cbiAgICAgICAgLy8gcGFyZW50U3ViJ3Mgc291cmNlIHNob3VsZCBtYXRjaCB3aGVyZSBzdG9yZSBjYW1lIGZyb206IHByb3BzIHZzLiBjb250ZXh0LiBBIGNvbXBvbmVudFxuICAgICAgICAvLyBjb25uZWN0ZWQgdG8gdGhlIHN0b3JlIHZpYSBwcm9wcyBzaG91bGRuJ3QgdXNlIHN1YnNjcmlwdGlvbiBmcm9tIGNvbnRleHQsIG9yIHZpY2UgdmVyc2EuXG4gICAgICAgIHZhciBwYXJlbnRTdWIgPSAodGhpcy5wcm9wc01vZGUgPyB0aGlzLnByb3BzIDogdGhpcy5jb250ZXh0KVtzdWJzY3JpcHRpb25LZXldO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGhpcy5zdG9yZSwgcGFyZW50U3ViLCB0aGlzLm9uU3RhdGVDaGFuZ2UuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gYG5vdGlmeU5lc3RlZFN1YnNgIGlzIGR1cGxpY2F0ZWQgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBjb21wb25lbnQgaXMgIHVubW91bnRlZCBpblxuICAgICAgICAvLyB0aGUgbWlkZGxlIG9mIHRoZSBub3RpZmljYXRpb24gbG9vcCwgd2hlcmUgYHRoaXMuc3Vic2NyaXB0aW9uYCB3aWxsIHRoZW4gYmUgbnVsbC4gQW5cbiAgICAgICAgLy8gZXh0cmEgbnVsbCBjaGVjayBldmVyeSBjaGFuZ2UgY2FuIGJlIGF2b2lkZWQgYnkgY29weWluZyB0aGUgbWV0aG9kIG9udG8gYHRoaXNgIGFuZCB0aGVuXG4gICAgICAgIC8vIHJlcGxhY2luZyBpdCB3aXRoIGEgbm8tb3Agb24gdW5tb3VudC4gVGhpcyBjYW4gcHJvYmFibHkgYmUgYXZvaWRlZCBpZiBTdWJzY3JpcHRpb24nc1xuICAgICAgICAvLyBsaXN0ZW5lcnMgbG9naWMgaXMgY2hhbmdlZCB0byBub3QgY2FsbCBsaXN0ZW5lcnMgdGhhdCBoYXZlIGJlZW4gdW5zdWJzY3JpYmVkIGluIHRoZVxuICAgICAgICAvLyBtaWRkbGUgb2YgdGhlIG5vdGlmaWNhdGlvbiBsb29wLlxuICAgICAgICB0aGlzLm5vdGlmeU5lc3RlZFN1YnMgPSB0aGlzLnN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzLmJpbmQodGhpcy5zdWJzY3JpcHRpb24pO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUub25TdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIG9uU3RhdGVDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IucnVuKHRoaXMucHJvcHMpO1xuXG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSA9IHRoaXMubm90aWZ5TmVzdGVkU3Vic09uQ29tcG9uZW50RGlkVXBkYXRlO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoZHVtbXlTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLm5vdGlmeU5lc3RlZFN1YnNPbkNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnNPbkNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgLy8gYGNvbXBvbmVudERpZFVwZGF0ZWAgaXMgY29uZGl0aW9uYWxseSBpbXBsZW1lbnRlZCB3aGVuIGBvblN0YXRlQ2hhbmdlYCBkZXRlcm1pbmVzIGl0XG4gICAgICAgIC8vIG5lZWRzIHRvIG5vdGlmeSBuZXN0ZWQgc3Vicy4gT25jZSBjYWxsZWQsIGl0IHVuaW1wbGVtZW50cyBpdHNlbGYgdW50aWwgZnVydGhlciBzdGF0ZVxuICAgICAgICAvLyBjaGFuZ2VzIG9jY3VyLiBEb2luZyBpdCB0aGlzIHdheSB2cyBoYXZpbmcgYSBwZXJtYW5lbnQgYGNvbXBvbmVudERpZFVwZGF0ZWAgdGhhdCBkb2VzXG4gICAgICAgIC8vIGEgYm9vbGVhbiBjaGVjayBldmVyeSB0aW1lIGF2b2lkcyBhbiBleHRyYSBtZXRob2QgY2FsbCBtb3N0IG9mIHRoZSB0aW1lLCByZXN1bHRpbmdcbiAgICAgICAgLy8gaW4gc29tZSBwZXJmIGJvb3N0LlxuICAgICAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5pc1N1YnNjcmliZWQgPSBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuc3Vic2NyaXB0aW9uKSAmJiB0aGlzLnN1YnNjcmlwdGlvbi5pc1N1YnNjcmliZWQoKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmFkZEV4dHJhUHJvcHMgPSBmdW5jdGlvbiBhZGRFeHRyYVByb3BzKHByb3BzKSB7XG4gICAgICAgIGlmICghd2l0aFJlZiAmJiAhcmVuZGVyQ291bnRQcm9wICYmICEodGhpcy5wcm9wc01vZGUgJiYgdGhpcy5zdWJzY3JpcHRpb24pKSByZXR1cm4gcHJvcHM7XG4gICAgICAgIC8vIG1ha2UgYSBzaGFsbG93IGNvcHkgc28gdGhhdCBmaWVsZHMgYWRkZWQgZG9uJ3QgbGVhayB0byB0aGUgb3JpZ2luYWwgc2VsZWN0b3IuXG4gICAgICAgIC8vIHRoaXMgaXMgZXNwZWNpYWxseSBpbXBvcnRhbnQgZm9yICdyZWYnIHNpbmNlIHRoYXQncyBhIHJlZmVyZW5jZSBiYWNrIHRvIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gaW5zdGFuY2UuIGEgc2luZ2xldG9uIG1lbW9pemVkIHNlbGVjdG9yIHdvdWxkIHRoZW4gYmUgaG9sZGluZyBhIHJlZmVyZW5jZSB0byB0aGVcbiAgICAgICAgLy8gaW5zdGFuY2UsIHByZXZlbnRpbmcgdGhlIGluc3RhbmNlIGZyb20gYmVpbmcgZ2FyYmFnZSBjb2xsZWN0ZWQsIGFuZCB0aGF0IHdvdWxkIGJlIGJhZFxuICAgICAgICB2YXIgd2l0aEV4dHJhcyA9IF9leHRlbmRzKHt9LCBwcm9wcyk7XG4gICAgICAgIGlmICh3aXRoUmVmKSB3aXRoRXh0cmFzLnJlZiA9IHRoaXMuc2V0V3JhcHBlZEluc3RhbmNlO1xuICAgICAgICBpZiAocmVuZGVyQ291bnRQcm9wKSB3aXRoRXh0cmFzW3JlbmRlckNvdW50UHJvcF0gPSB0aGlzLnJlbmRlckNvdW50Kys7XG4gICAgICAgIGlmICh0aGlzLnByb3BzTW9kZSAmJiB0aGlzLnN1YnNjcmlwdGlvbikgd2l0aEV4dHJhc1tzdWJzY3JpcHRpb25LZXldID0gdGhpcy5zdWJzY3JpcHRpb247XG4gICAgICAgIHJldHVybiB3aXRoRXh0cmFzO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuICAgICAgICBzZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc2VsZWN0b3IuZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBzZWxlY3Rvci5lcnJvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCB0aGlzLmFkZEV4dHJhUHJvcHMoc2VsZWN0b3IucHJvcHMpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbm5lY3Q7XG4gICAgfShDb21wb25lbnQpO1xuXG4gICAgQ29ubmVjdC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICBDb25uZWN0LmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgQ29ubmVjdC5jaGlsZENvbnRleHRUeXBlcyA9IGNoaWxkQ29udGV4dFR5cGVzO1xuICAgIENvbm5lY3QuY29udGV4dFR5cGVzID0gY29udGV4dFR5cGVzO1xuICAgIENvbm5lY3QucHJvcFR5cGVzID0gY29udGV4dFR5cGVzO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAvLyBXZSBhcmUgaG90IHJlbG9hZGluZyFcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbiAhPT0gdmVyc2lvbikge1xuICAgICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgdGhpcy5pbml0U2VsZWN0b3IoKTtcblxuICAgICAgICAgIC8vIElmIGFueSBjb25uZWN0ZWQgZGVzY2VuZGFudHMgZG9uJ3QgaG90IHJlbG9hZCAoYW5kIHJlc3Vic2NyaWJlIGluIHRoZSBwcm9jZXNzKSwgdGhlaXJcbiAgICAgICAgICAvLyBsaXN0ZW5lcnMgd2lsbCBiZSBsb3N0IHdoZW4gd2UgdW5zdWJzY3JpYmUuIFVuZm9ydHVuYXRlbHksIGJ5IGNvcHlpbmcgb3ZlciBhbGxcbiAgICAgICAgICAvLyBsaXN0ZW5lcnMsIHRoaXMgZG9lcyBtZWFuIHRoYXQgdGhlIG9sZCB2ZXJzaW9ucyBvZiBjb25uZWN0ZWQgZGVzY2VuZGFudHMgd2lsbCBzdGlsbCBiZVxuICAgICAgICAgIC8vIG5vdGlmaWVkIG9mIHN0YXRlIGNoYW5nZXM7IGhvd2V2ZXIsIHRoZWlyIG9uU3RhdGVDaGFuZ2UgZnVuY3Rpb24gaXMgYSBuby1vcCBzbyB0aGlzXG4gICAgICAgICAgLy8gaXNuJ3QgYSBodWdlIGRlYWwuXG4gICAgICAgICAgdmFyIG9sZExpc3RlbmVycyA9IFtdO1xuXG4gICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBvbGRMaXN0ZW5lcnMgPSB0aGlzLnN1YnNjcmlwdGlvbi5saXN0ZW5lcnMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmluaXRTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICBpZiAoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIG9sZExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLnN1YnNjcmlwdGlvbi5saXN0ZW5lcnMuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9pc3RTdGF0aWNzKENvbm5lY3QsIFdyYXBwZWRDb21wb25lbnQpO1xuICB9O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gICAgY29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gICAgbmFtZTogdHJ1ZSxcbiAgICBsZW5ndGg6IHRydWUsXG4gICAgcHJvdG90eXBlOiB0cnVlLFxuICAgIGNhbGxlcjogdHJ1ZSxcbiAgICBjYWxsZWU6IHRydWUsXG4gICAgYXJndW1lbnRzOiB0cnVlLFxuICAgIGFyaXR5OiB0cnVlXG59O1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiAmJiBnZXRQcm90b3R5cGVPZihPYmplY3QpO1xuXG5mdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgYmxhY2tsaXN0KSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG5cbiAgICAgICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQsIGJsYWNrbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghUkVBQ1RfU1RBVElDU1trZXldICYmICFLTk9XTl9TVEFUSUNTW2tleV0gJiYgKCFibGFja2xpc3QgfHwgIWJsYWNrbGlzdFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgICAgICAgICB0cnkgeyAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhvaXN0Tm9uUmVhY3RTdGF0aWNzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IHZlcmlmeVBsYWluT2JqZWN0IGZyb20gJy4uL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0JztcblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZ2V0Q29uc3RhbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRDb25zdGFudFNlbGVjdG9yKGRpc3BhdGNoLCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnN0YW50ID0gZ2V0Q29uc3RhbnQoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuXG4gICAgZnVuY3Rpb24gY29uc3RhbnRTZWxlY3RvcigpIHtcbiAgICAgIHJldHVybiBjb25zdGFudDtcbiAgICB9XG4gICAgY29uc3RhbnRTZWxlY3Rvci5kZXBlbmRzT25Pd25Qcm9wcyA9IGZhbHNlO1xuICAgIHJldHVybiBjb25zdGFudFNlbGVjdG9yO1xuICB9O1xufVxuXG4vLyBkZXBlbmRzT25Pd25Qcm9wcyBpcyB1c2VkIGJ5IGNyZWF0ZU1hcFRvUHJvcHNQcm94eSB0byBkZXRlcm1pbmUgd2hldGhlciB0byBwYXNzIHByb3BzIGFzIGFyZ3Ncbi8vIHRvIHRoZSBtYXBUb1Byb3BzIGZ1bmN0aW9uIGJlaW5nIHdyYXBwZWQuIEl0IGlzIGFsc28gdXNlZCBieSBtYWtlUHVyZVByb3BzU2VsZWN0b3IgdG8gZGV0ZXJtaW5lXG4vLyB3aGV0aGVyIG1hcFRvUHJvcHMgbmVlZHMgdG8gYmUgaW52b2tlZCB3aGVuIHByb3BzIGhhdmUgY2hhbmdlZC5cbi8vIFxuLy8gQSBsZW5ndGggb2Ygb25lIHNpZ25hbHMgdGhhdCBtYXBUb1Byb3BzIGRvZXMgbm90IGRlcGVuZCBvbiBwcm9wcyBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuLy8gQSBsZW5ndGggb2YgemVybyBpcyBhc3N1bWVkIHRvIG1lYW4gbWFwVG9Qcm9wcyBpcyBnZXR0aW5nIGFyZ3MgdmlhIGFyZ3VtZW50cyBvciAuLi5hcmdzIGFuZFxuLy8gdGhlcmVmb3JlIG5vdCByZXBvcnRpbmcgaXRzIGxlbmd0aCBhY2N1cmF0ZWx5Li5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZXBlbmRzT25Pd25Qcm9wcyhtYXBUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzICE9PSBudWxsICYmIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMgIT09IHVuZGVmaW5lZCA/IEJvb2xlYW4obWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgOiBtYXBUb1Byb3BzLmxlbmd0aCAhPT0gMTtcbn1cblxuLy8gVXNlZCBieSB3aGVuTWFwU3RhdGVUb1Byb3BzSXNGdW5jdGlvbiBhbmQgd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzRnVuY3Rpb24sXG4vLyB0aGlzIGZ1bmN0aW9uIHdyYXBzIG1hcFRvUHJvcHMgaW4gYSBwcm94eSBmdW5jdGlvbiB3aGljaCBkb2VzIHNldmVyYWwgdGhpbmdzOlxuLy8gXG4vLyAgKiBEZXRlY3RzIHdoZXRoZXIgdGhlIG1hcFRvUHJvcHMgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIGRlcGVuZHMgb24gcHJvcHMsIHdoaWNoXG4vLyAgICBpcyB1c2VkIGJ5IHNlbGVjdG9yRmFjdG9yeSB0byBkZWNpZGUgaWYgaXQgc2hvdWxkIHJlaW52b2tlIG9uIHByb3BzIGNoYW5nZXMuXG4vLyAgICBcbi8vICAqIE9uIGZpcnN0IGNhbGwsIGhhbmRsZXMgbWFwVG9Qcm9wcyBpZiByZXR1cm5zIGFub3RoZXIgZnVuY3Rpb24sIGFuZCB0cmVhdHMgdGhhdFxuLy8gICAgbmV3IGZ1bmN0aW9uIGFzIHRoZSB0cnVlIG1hcFRvUHJvcHMgZm9yIHN1YnNlcXVlbnQgY2FsbHMuXG4vLyAgICBcbi8vICAqIE9uIGZpcnN0IGNhbGwsIHZlcmlmaWVzIHRoZSBmaXJzdCByZXN1bHQgaXMgYSBwbGFpbiBvYmplY3QsIGluIG9yZGVyIHRvIHdhcm5cbi8vICAgIHRoZSBkZXZlbG9wZXIgdGhhdCB0aGVpciBtYXBUb1Byb3BzIGZ1bmN0aW9uIGlzIG5vdCByZXR1cm5pbmcgYSB2YWxpZCByZXN1bHQuXG4vLyAgICBcbmV4cG9ydCBmdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwVG9Qcm9wcywgbWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdFByb3h5U2VsZWN0b3IoZGlzcGF0Y2gsIF9yZWYpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBfcmVmLmRpc3BsYXlOYW1lO1xuXG4gICAgdmFyIHByb3h5ID0gZnVuY3Rpb24gbWFwVG9Qcm9wc1Byb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA/IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykgOiBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCk7XG4gICAgfTtcblxuICAgIC8vIGFsbG93IGRldGVjdEZhY3RvcnlBbmRWZXJpZnkgdG8gZ2V0IG93blByb3BzXG4gICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSB0cnVlO1xuXG4gICAgcHJveHkubWFwVG9Qcm9wcyA9IGZ1bmN0aW9uIGRldGVjdEZhY3RvcnlBbmRWZXJpZnkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IG1hcFRvUHJvcHM7XG4gICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpO1xuICAgICAgdmFyIHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IHByb3BzO1xuICAgICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKHByb3BzKTtcbiAgICAgICAgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHZlcmlmeVBsYWluT2JqZWN0KHByb3BzLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSk7XG5cbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHByb3h5O1xuICB9O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvd3JhcE1hcFRvUHJvcHMuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi93YXJuaW5nJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmVyaWZ5UGxhaW5PYmplY3QodmFsdWUsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuaW5nKG1ldGhvZE5hbWUgKyAnKCkgaW4gJyArIGRpc3BsYXlOYW1lICsgJyBtdXN0IHJldHVybiBhIHBsYWluIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZCAnICsgdmFsdWUgKyAnLicpO1xuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJleHBvcnQgdmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbmV4cG9ydCB2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLmFkZEV2ZW50TGlzdGVuZXIgPyBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxuZXhwb3J0IHZhciByZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG5leHBvcnQgdmFyIGdldENvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uIGdldENvbmZpcm1hdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICByZXR1cm4gY2FsbGJhY2sod2luZG93LmNvbmZpcm0obWVzc2FnZSkpO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzSGlzdG9yeSA9IGZ1bmN0aW9uIHN1cHBvcnRzSGlzdG9yeSgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgaWYgKCh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJiB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJiB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYnJvd3NlciBmaXJlcyBwb3BzdGF0ZSBvbiBoYXNoIGNoYW5nZS5cbiAqIElFMTAgYW5kIElFMTEgZG8gbm90LlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiBwb3BzdGF0ZSBldmVudCBpcyBhbiBleHRyYW5lb3VzIFdlYktpdCBldmVudC5cbiAqIEFjY291bnRzIGZvciB0aGUgZmFjdCB0aGF0IENocm9tZSBvbiBpT1MgZmlyZXMgcmVhbCBwb3BzdGF0ZSBldmVudHNcbiAqIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHN0YXRlIHdoZW4gcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlxuICovXG5leHBvcnQgdmFyIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgPSBmdW5jdGlvbiBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5zdGF0ZSA9PT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ3JpT1MnKSA9PT0gLTE7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvRE9NVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSBcImludmFyaWFudFwiO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24gfSBmcm9tIFwiaGlzdG9yeVwiO1xuXG52YXIgaXNNb2RpZmllZEV2ZW50ID0gZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn07XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgPGE+LlxuICovXG5cbnZhciBMaW5rID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKExpbmssIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIExpbmsoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5rKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uQ2xpY2spIF90aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuXG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiYgLy8gb25DbGljayBwcmV2ZW50ZWQgZGVmYXVsdFxuICAgICAgZXZlbnQuYnV0dG9uID09PSAwICYmIC8vIGlnbm9yZSBldmVyeXRoaW5nIGJ1dCBsZWZ0IGNsaWNrc1xuICAgICAgIV90aGlzLnByb3BzLnRhcmdldCAmJiAvLyBsZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAgICAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gaWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgICAgICkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICB2YXIgaGlzdG9yeSA9IF90aGlzLmNvbnRleHQucm91dGVyLmhpc3Rvcnk7XG4gICAgICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgICAgIHJlcGxhY2UgPSBfdGhpcyRwcm9wcy5yZXBsYWNlLFxuICAgICAgICAgICAgICB0byA9IF90aGlzJHByb3BzLnRvO1xuXG5cbiAgICAgICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICAgICAgaGlzdG9yeS5yZXBsYWNlKHRvKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlzdG9yeS5wdXNoKHRvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIExpbmsucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgcmVwbGFjZSA9IF9wcm9wcy5yZXBsYWNlLFxuICAgICAgICB0byA9IF9wcm9wcy50byxcbiAgICAgICAgaW5uZXJSZWYgPSBfcHJvcHMuaW5uZXJSZWYsXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgW1wicmVwbGFjZVwiLCBcInRvXCIsIFwiaW5uZXJSZWZcIl0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICBpbnZhcmlhbnQodGhpcy5jb250ZXh0LnJvdXRlciwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPExpbms+IG91dHNpZGUgYSA8Um91dGVyPlwiKTtcblxuICAgIGludmFyaWFudCh0byAhPT0gdW5kZWZpbmVkLCAnWW91IG11c3Qgc3BlY2lmeSB0aGUgXCJ0b1wiIHByb3BlcnR5Jyk7XG5cbiAgICB2YXIgaGlzdG9yeSA9IHRoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeTtcblxuICAgIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IGNyZWF0ZUxvY2F0aW9uKHRvLCBudWxsLCBudWxsLCBoaXN0b3J5LmxvY2F0aW9uKSA6IHRvO1xuXG4gICAgdmFyIGhyZWYgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgb25DbGljazogdGhpcy5oYW5kbGVDbGljaywgaHJlZjogaHJlZiwgcmVmOiBpbm5lclJlZiB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIExpbms7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkxpbmsucHJvcFR5cGVzID0ge1xuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICByZXBsYWNlOiBQcm9wVHlwZXMuYm9vbCxcbiAgdG86IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKS5pc1JlcXVpcmVkLFxuICBpbm5lclJlZjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKVxufTtcbkxpbmsuZGVmYXVsdFByb3BzID0ge1xuICByZXBsYWNlOiBmYWxzZVxufTtcbkxpbmsuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIHB1c2g6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICByZXBsYWNlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgY3JlYXRlSHJlZjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBMaW5rO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTGluay5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFJvdXRlIGZyb20gXCJyZWFjdC1yb3V0ZXIvZXMvUm91dGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgUm91dGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gXCJ3YXJuaW5nXCI7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gXCJpbnZhcmlhbnRcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCBtYXRjaFBhdGggZnJvbSBcIi4vbWF0Y2hQYXRoXCI7XG5cbnZhciBpc0VtcHR5Q2hpbGRyZW4gPSBmdW5jdGlvbiBpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA9PT0gMDtcbn07XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIG1hdGNoaW5nIGEgc2luZ2xlIHBhdGggYW5kIHJlbmRlcmluZy5cbiAqL1xuXG52YXIgUm91dGUgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUm91dGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJvdXRlKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuICAgICAgbWF0Y2g6IF90aGlzLmNvbXB1dGVNYXRjaChfdGhpcy5wcm9wcywgX3RoaXMuY29udGV4dC5yb3V0ZXIpXG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBSb3V0ZS5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IF9leHRlbmRzKHt9LCB0aGlzLmNvbnRleHQucm91dGVyLCB7XG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgbG9jYXRpb246IHRoaXMucHJvcHMubG9jYXRpb24gfHwgdGhpcy5jb250ZXh0LnJvdXRlci5yb3V0ZS5sb2NhdGlvbixcbiAgICAgICAgICBtYXRjaDogdGhpcy5zdGF0ZS5tYXRjaFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXB1dGVNYXRjaCA9IGZ1bmN0aW9uIGNvbXB1dGVNYXRjaChfcmVmLCByb3V0ZXIpIHtcbiAgICB2YXIgY29tcHV0ZWRNYXRjaCA9IF9yZWYuY29tcHV0ZWRNYXRjaCxcbiAgICAgICAgbG9jYXRpb24gPSBfcmVmLmxvY2F0aW9uLFxuICAgICAgICBwYXRoID0gX3JlZi5wYXRoLFxuICAgICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgICAgZXhhY3QgPSBfcmVmLmV4YWN0LFxuICAgICAgICBzZW5zaXRpdmUgPSBfcmVmLnNlbnNpdGl2ZTtcblxuICAgIGlmIChjb21wdXRlZE1hdGNoKSByZXR1cm4gY29tcHV0ZWRNYXRjaDsgLy8gPFN3aXRjaD4gYWxyZWFkeSBjb21wdXRlZCB0aGUgbWF0Y2ggZm9yIHVzXG5cbiAgICBpbnZhcmlhbnQocm91dGVyLCBcIllvdSBzaG91bGQgbm90IHVzZSA8Um91dGU+IG9yIHdpdGhSb3V0ZXIoKSBvdXRzaWRlIGEgPFJvdXRlcj5cIik7XG5cbiAgICB2YXIgcm91dGUgPSByb3V0ZXIucm91dGU7XG5cbiAgICB2YXIgcGF0aG5hbWUgPSAobG9jYXRpb24gfHwgcm91dGUubG9jYXRpb24pLnBhdGhuYW1lO1xuXG4gICAgcmV0dXJuIG1hdGNoUGF0aChwYXRobmFtZSwgeyBwYXRoOiBwYXRoLCBzdHJpY3Q6IHN0cmljdCwgZXhhY3Q6IGV4YWN0LCBzZW5zaXRpdmU6IHNlbnNpdGl2ZSB9LCByb3V0ZS5tYXRjaCk7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCEodGhpcy5wcm9wcy5jb21wb25lbnQgJiYgdGhpcy5wcm9wcy5yZW5kZXIpLCBcIllvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgY29tcG9uZW50PiBhbmQgPFJvdXRlIHJlbmRlcj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSByZW5kZXI+IHdpbGwgYmUgaWdub3JlZFwiKTtcblxuICAgIHdhcm5pbmcoISh0aGlzLnByb3BzLmNvbXBvbmVudCAmJiB0aGlzLnByb3BzLmNoaWxkcmVuICYmICFpc0VtcHR5Q2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbikpLCBcIllvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgY29tcG9uZW50PiBhbmQgPFJvdXRlIGNoaWxkcmVuPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIGNoaWxkcmVuPiB3aWxsIGJlIGlnbm9yZWRcIik7XG5cbiAgICB3YXJuaW5nKCEodGhpcy5wcm9wcy5yZW5kZXIgJiYgdGhpcy5wcm9wcy5jaGlsZHJlbiAmJiAhaXNFbXB0eUNoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4pKSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlIHJlbmRlcj4gYW5kIDxSb3V0ZSBjaGlsZHJlbj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSBjaGlsZHJlbj4gd2lsbCBiZSBpZ25vcmVkXCIpO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAgd2FybmluZyghKG5leHRQcm9wcy5sb2NhdGlvbiAmJiAhdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8Um91dGU+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgaW5pdGlhbGx5IHVzZWQgbm8gXCJsb2NhdGlvblwiIHByb3AgYW5kIHRoZW4gcHJvdmlkZWQgb25lIG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG5cbiAgICB3YXJuaW5nKCEoIW5leHRQcm9wcy5sb2NhdGlvbiAmJiB0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxSb3V0ZT4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBwcm92aWRlZCBhIFwibG9jYXRpb25cIiBwcm9wIGluaXRpYWxseSBidXQgb21pdHRlZCBpdCBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtYXRjaDogdGhpcy5jb21wdXRlTWF0Y2gobmV4dFByb3BzLCBuZXh0Q29udGV4dC5yb3V0ZXIpXG4gICAgfSk7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgbWF0Y2ggPSB0aGlzLnN0YXRlLm1hdGNoO1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgY29tcG9uZW50ID0gX3Byb3BzLmNvbXBvbmVudCxcbiAgICAgICAgcmVuZGVyID0gX3Byb3BzLnJlbmRlcjtcbiAgICB2YXIgX2NvbnRleHQkcm91dGVyID0gdGhpcy5jb250ZXh0LnJvdXRlcixcbiAgICAgICAgaGlzdG9yeSA9IF9jb250ZXh0JHJvdXRlci5oaXN0b3J5LFxuICAgICAgICByb3V0ZSA9IF9jb250ZXh0JHJvdXRlci5yb3V0ZSxcbiAgICAgICAgc3RhdGljQ29udGV4dCA9IF9jb250ZXh0JHJvdXRlci5zdGF0aWNDb250ZXh0O1xuXG4gICAgdmFyIGxvY2F0aW9uID0gdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbjtcbiAgICB2YXIgcHJvcHMgPSB7IG1hdGNoOiBtYXRjaCwgbG9jYXRpb246IGxvY2F0aW9uLCBoaXN0b3J5OiBoaXN0b3J5LCBzdGF0aWNDb250ZXh0OiBzdGF0aWNDb250ZXh0IH07XG5cbiAgICBpZiAoY29tcG9uZW50KSByZXR1cm4gbWF0Y2ggPyBSZWFjdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpIDogbnVsbDtcblxuICAgIGlmIChyZW5kZXIpIHJldHVybiBtYXRjaCA/IHJlbmRlcihwcm9wcykgOiBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY2hpbGRyZW4ocHJvcHMpO1xuXG4gICAgaWYgKGNoaWxkcmVuICYmICFpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pKSByZXR1cm4gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUm91dGU7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJvdXRlLnByb3BUeXBlcyA9IHtcbiAgY29tcHV0ZWRNYXRjaDogUHJvcFR5cGVzLm9iamVjdCwgLy8gcHJpdmF0ZSwgZnJvbSA8U3dpdGNoPlxuICBwYXRoOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBleGFjdDogUHJvcFR5cGVzLmJvb2wsXG4gIHN0cmljdDogUHJvcFR5cGVzLmJvb2wsXG4gIHNlbnNpdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIHJlbmRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm5vZGVdKSxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3Rcbn07XG5Sb3V0ZS5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgcm91dGU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICBzdGF0aWNDb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0XG4gIH0pXG59O1xuUm91dGUuY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFJvdXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgaXNhcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoVG9SZWdleHBcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2Vcbm1vZHVsZS5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvblxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cFxuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpXG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXVxuICB2YXIga2V5ID0gMFxuICB2YXIgaW5kZXggPSAwXG4gIHZhciBwYXRoID0gJydcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJ1xuICB2YXIgcmVzXG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICB2YXIgbSA9IHJlc1swXVxuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdXG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleFxuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aFxuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF1cbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdXG4gICAgdmFyIG5hbWUgPSByZXNbM11cbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XVxuICAgIHZhciBncm91cCA9IHJlc1s1XVxuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XVxuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XVxuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aClcbiAgICAgIHBhdGggPSAnJ1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJlZml4ICE9IG51bGwgJiYgbmV4dCAhPSBudWxsICYmIG5leHQgIT09IHByZWZpeFxuICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgZGVsaW1pdGVyID0gcmVzWzJdIHx8IGRlZmF1bHREZWxpbWl0ZXJcbiAgICB2YXIgcGF0dGVybiA9IGNhcHR1cmUgfHwgZ3JvdXBcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSlcbiAgfVxuXG4gIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHBhdGggKz0gc3RyLnN1YnN0cihpbmRleClcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXG4gIGlmIChwYXRoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aClcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKVxuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICB2YXIgcGF0aCA9ICcnXG4gICAgdmFyIGRhdGEgPSBvYmogfHwge31cbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge31cbiAgICB2YXIgZW5jb2RlID0gb3B0aW9ucy5wcmV0dHkgPyBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgOiBlbmNvZGVVUklDb21wb25lbnRcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCArPSB0b2tlblxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV1cbiAgICAgIHZhciBzZWdtZW50XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgIC8vIFByZXBlbmQgcGFydGlhbCBzZWdtZW50IHByZWZpeGVzLlxuICAgICAgICAgIGlmICh0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNhcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSlcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSB0b2tlbi5hc3RlcmlzayA/IGVuY29kZUFzdGVyaXNrKHZhbHVlKSA6IGVuY29kZSh2YWx1ZSlcblxuICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXG4gICAgICB9XG5cbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudFxuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXxcXC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzXG4gIHJldHVybiByZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZsYWdzIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKVxuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgcGFydGlhbDogZmFsc2UsXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcbiAgICAgICAgcGF0dGVybjogbnVsbFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpXG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpXG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3RcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZVxuICB2YXIgcm91dGUgPSAnJ1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeClcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknXG5cbiAgICAgIGtleXMucHVzaCh0b2tlbilcblxuICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuICAgICAgICBjYXB0dXJlICs9ICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKidcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyk/J1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJ1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlXG4gICAgfVxuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLycpXG4gIHZhciBlbmRzV2l0aERlbGltaXRlciA9IHJvdXRlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyXG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPydcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCdcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoRGVsaW1pdGVyID8gJycgOiAnKD89JyArIGRlbGltaXRlciArICd8JCknXG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucylcbiAgICBrZXlzID0gW11cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IHBhdGhUb1JlZ2V4cCBmcm9tIFwicGF0aC10by1yZWdleHBcIjtcblxudmFyIHBhdHRlcm5DYWNoZSA9IHt9O1xudmFyIGNhY2hlTGltaXQgPSAxMDAwMDtcbnZhciBjYWNoZUNvdW50ID0gMDtcblxudmFyIGNvbXBpbGVHZW5lcmF0b3IgPSBmdW5jdGlvbiBjb21waWxlR2VuZXJhdG9yKHBhdHRlcm4pIHtcbiAgdmFyIGNhY2hlS2V5ID0gcGF0dGVybjtcbiAgdmFyIGNhY2hlID0gcGF0dGVybkNhY2hlW2NhY2hlS2V5XSB8fCAocGF0dGVybkNhY2hlW2NhY2hlS2V5XSA9IHt9KTtcblxuICBpZiAoY2FjaGVbcGF0dGVybl0pIHJldHVybiBjYWNoZVtwYXR0ZXJuXTtcblxuICB2YXIgY29tcGlsZWRHZW5lcmF0b3IgPSBwYXRoVG9SZWdleHAuY29tcGlsZShwYXR0ZXJuKTtcblxuICBpZiAoY2FjaGVDb3VudCA8IGNhY2hlTGltaXQpIHtcbiAgICBjYWNoZVtwYXR0ZXJuXSA9IGNvbXBpbGVkR2VuZXJhdG9yO1xuICAgIGNhY2hlQ291bnQrKztcbiAgfVxuXG4gIHJldHVybiBjb21waWxlZEdlbmVyYXRvcjtcbn07XG5cbi8qKlxuICogUHVibGljIEFQSSBmb3IgZ2VuZXJhdGluZyBhIFVSTCBwYXRobmFtZSBmcm9tIGEgcGF0dGVybiBhbmQgcGFyYW1ldGVycy5cbiAqL1xudmFyIGdlbmVyYXRlUGF0aCA9IGZ1bmN0aW9uIGdlbmVyYXRlUGF0aCgpIHtcbiAgdmFyIHBhdHRlcm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwiL1wiO1xuICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICBpZiAocGF0dGVybiA9PT0gXCIvXCIpIHtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICB2YXIgZ2VuZXJhdG9yID0gY29tcGlsZUdlbmVyYXRvcihwYXR0ZXJuKTtcbiAgcmV0dXJuIGdlbmVyYXRvcihwYXJhbXMsIHsgcHJldHR5OiB0cnVlIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZ2VuZXJhdGVQYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9nZW5lcmF0ZVBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xudmFyIGJ0b2EgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmJ0b2EgJiYgd2luZG93LmJ0b2EuYmluZCh3aW5kb3cpKSB8fCByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnRvYScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHZhciBsb2FkRXZlbnQgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbiAgICB2YXIgeERvbWFpbiA9IGZhbHNlO1xuXG4gICAgLy8gRm9yIElFIDgvOSBDT1JTIHN1cHBvcnRcbiAgICAvLyBPbmx5IHN1cHBvcnRzIFBPU1QgYW5kIEdFVCBjYWxscyBhbmQgZG9lc24ndCByZXR1cm5zIHRoZSByZXNwb25zZSBoZWFkZXJzLlxuICAgIC8vIERPTidUIGRvIHRoaXMgZm9yIHRlc3RpbmcgYi9jIFhNTEh0dHBSZXF1ZXN0IGlzIG1vY2tlZCwgbm90IFhEb21haW5SZXF1ZXN0LlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXG4gICAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHdpbmRvdy5YRG9tYWluUmVxdWVzdCAmJiAhKCd3aXRoQ3JlZGVudGlhbHMnIGluIHJlcXVlc3QpICYmXG4gICAgICAgICFpc1VSTFNhbWVPcmlnaW4oY29uZmlnLnVybCkpIHtcbiAgICAgIHJlcXVlc3QgPSBuZXcgd2luZG93LlhEb21haW5SZXF1ZXN0KCk7XG4gICAgICBsb2FkRXZlbnQgPSAnb25sb2FkJztcbiAgICAgIHhEb21haW4gPSB0cnVlO1xuICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gZnVuY3Rpb24gaGFuZGxlUHJvZ3Jlc3MoKSB7fTtcbiAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHt9O1xuICAgIH1cblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgfHwgJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZVxuICAgIHJlcXVlc3RbbG9hZEV2ZW50XSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QgfHwgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCAmJiAheERvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhY29uZmlnLnJlc3BvbnNlVHlwZSB8fCBjb25maWcucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgLy8gSUUgc2VuZHMgMTIyMyBpbnN0ZWFkIG9mIDIwNCAoaHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9zL2lzc3Vlcy8yMDEpXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAnTm8gQ29udGVudCcgOiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIHZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcblxuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBoZXhUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICBhcnJheS5wdXNoKCclJyArICgoaSA8IDE2ID8gJzAnIDogJycpICsgaS50b1N0cmluZygxNikpLnRvVXBwZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbn0oKSk7XG5cbnZhciBjb21wYWN0UXVldWUgPSBmdW5jdGlvbiBjb21wYWN0UXVldWUocXVldWUpIHtcbiAgICB2YXIgb2JqO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgaXRlbSA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICBvYmogPSBpdGVtLm9ialtpdGVtLnByb3BdO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIHZhciBjb21wYWN0ZWQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmoubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ialtqXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFjdGVkLnB1c2gob2JqW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW0ub2JqW2l0ZW0ucHJvcF0gPSBjb21wYWN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIGFycmF5VG9PYmplY3QgPSBmdW5jdGlvbiBhcnJheVRvT2JqZWN0KHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHZhciBvYmogPSBvcHRpb25zICYmIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlW2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb2JqW2ldID0gc291cmNlW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goc291cmNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGxhaW5PYmplY3RzIHx8IG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzIHx8ICFoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3NvdXJjZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt0YXJnZXQsIHNvdXJjZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gW3RhcmdldF0uY29uY2F0KHNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIG1lcmdlVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgIUFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBtZXJnZVRhcmdldCA9IGFycmF5VG9PYmplY3QodGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgICAgaWYgKGhhcy5jYWxsKHRhcmdldCwgaSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W2ldICYmIHR5cGVvZiB0YXJnZXRbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IG1lcmdlKHRhcmdldFtpXSwgaXRlbSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICAgIGlmIChoYXMuY2FsbChhY2MsIGtleSkpIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gbWVyZ2UoYWNjW2tleV0sIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBtZXJnZVRhcmdldCk7XG59O1xuXG52YXIgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduU2luZ2xlU291cmNlKHRhcmdldCwgc291cmNlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICBhY2Nba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHRhcmdldCk7XG59O1xuXG52YXIgZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufTtcblxudmFyIGVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShzdHIpIHtcbiAgICAvLyBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBieSBCcmlhbiBXaGl0ZSAobXNjZGV4KSBmb3IgdGhlIGlvLmpzIGNvcmUgcXVlcnlzdHJpbmcgbGlicmFyeS5cbiAgICAvLyBJdCBoYXMgYmVlbiBhZGFwdGVkIGhlcmUgZm9yIHN0cmljdGVyIGFkaGVyZW5jZSB0byBSRkMgMzk4NlxuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgdmFyIHN0cmluZyA9IHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gc3RyIDogU3RyaW5nKHN0cik7XG5cbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjID09PSAweDJEIC8vIC1cbiAgICAgICAgICAgIHx8IGMgPT09IDB4MkUgLy8gLlxuICAgICAgICAgICAgfHwgYyA9PT0gMHg1RiAvLyBfXG4gICAgICAgICAgICB8fCBjID09PSAweDdFIC8vIH5cbiAgICAgICAgICAgIHx8IChjID49IDB4MzAgJiYgYyA8PSAweDM5KSAvLyAwLTlcbiAgICAgICAgICAgIHx8IChjID49IDB4NDEgJiYgYyA8PSAweDVBKSAvLyBhLXpcbiAgICAgICAgICAgIHx8IChjID49IDB4NjEgJiYgYyA8PSAweDdBKSAvLyBBLVpcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvdXQgKz0gc3RyaW5nLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyBoZXhUYWJsZVtjXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgKGhleFRhYmxlWzB4QzAgfCAoYyA+PiA2KV0gKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4RDgwMCB8fCBjID49IDB4RTAwMCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgKGhleFRhYmxlWzB4RTAgfCAoYyA+PiAxMildICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXSArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKChjICYgMHgzRkYpIDw8IDEwKSB8IChzdHJpbmcuY2hhckNvZGVBdChpKSAmIDB4M0ZGKSk7XG4gICAgICAgIG91dCArPSBoZXhUYWJsZVsweEYwIHwgKGMgPj4gMTgpXVxuICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKChjID4+IDEyKSAmIDB4M0YpXVxuICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKChjID4+IDYpICYgMHgzRildXG4gICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxudmFyIGNvbXBhY3QgPSBmdW5jdGlvbiBjb21wYWN0KHZhbHVlKSB7XG4gICAgdmFyIHF1ZXVlID0gW3sgb2JqOiB7IG86IHZhbHVlIH0sIHByb3A6ICdvJyB9XTtcbiAgICB2YXIgcmVmcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgaXRlbSA9IHF1ZXVlW2ldO1xuICAgICAgICB2YXIgb2JqID0gaXRlbS5vYmpbaXRlbS5wcm9wXTtcblxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbal07XG4gICAgICAgICAgICB2YXIgdmFsID0gb2JqW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsICYmIHJlZnMuaW5kZXhPZih2YWwpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goeyBvYmo6IG9iaiwgcHJvcDoga2V5IH0pO1xuICAgICAgICAgICAgICAgIHJlZnMucHVzaCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBhY3RRdWV1ZShxdWV1ZSk7XG59O1xuXG52YXIgaXNSZWdFeHAgPSBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxudmFyIGlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhKG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXJyYXlUb09iamVjdDogYXJyYXlUb09iamVjdCxcbiAgICBhc3NpZ246IGFzc2lnbixcbiAgICBjb21wYWN0OiBjb21wYWN0LFxuICAgIGRlY29kZTogZGVjb2RlLFxuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgICBpc1JlZ0V4cDogaXNSZWdFeHAsXG4gICAgbWVyZ2U6IG1lcmdlXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXMvbGliL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG52YXIgcGVyY2VudFR3ZW50aWVzID0gLyUyMC9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnZGVmYXVsdCc6ICdSRkMzOTg2JyxcbiAgICBmb3JtYXR0ZXJzOiB7XG4gICAgICAgIFJGQzE3Mzg6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2UuY2FsbCh2YWx1ZSwgcGVyY2VudFR3ZW50aWVzLCAnKycpO1xuICAgICAgICB9LFxuICAgICAgICBSRkMzOTg2OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgUkZDMTczODogJ1JGQzE3MzgnLFxuICAgIFJGQzM5ODY6ICdSRkMzOTg2J1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3FzL2xpYi9mb3JtYXRzLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGFsRm9vdGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNoaWxkcmVuID0gUmVhY3QuQ2hpbGRyZW4ubWFwKCB0aGlzLnByb3BzLmNoaWxkcmVuLCBmb290ZXJDaGlsZHJlbiA9PiB7XG5cdFx0XHRyZXR1cm4gZm9vdGVyQ2hpbGRyZW47XG5cdFx0fSApO1xuXG5cdFx0Y29uc3QgYWxpZ25tZW50ID0gKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuYWxpZ25tZW50ICkgJiYgJycgIT09IHRoaXMucHJvcHMuYWxpZ25tZW50IClcblx0XHRcdD8gdGhpcy5wcm9wcy5hbGlnbm1lbnRcblx0XHRcdDogJyc7XG5cblx0XHRjb25zdCBmbGF0dGVuID0gKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuZmxhdHRlbiApICYmIHRydWUgPT09IHRoaXMucHJvcHMuZmxhdHRlbiApXG5cdFx0XHQ/IHRydWVcblx0XHRcdDogZmFsc2U7XG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuXHRcdGNvbnN0IGhhc0NsYXNzID0gKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuY3VzdG9tQ2xhc3MgKSAmJiAnJyAhPT0gdGhpcy5wcm9wcy5jdXN0b21DbGFzcyApXG5cdFx0XHQ/IHRydWVcblx0XHRcdDogZmFsc2U7XG5cblx0XHRsZXQgZWxDbGFzcyA9ICdzdWktYm94LWZvb3Rlcic7XG5cblx0XHRpZiAoIHRydWUgPT09IGZsYXR0ZW4gKSB7XG5cdFx0XHRlbENsYXNzICs9ICcgc3VpLWZsYXR0ZW4nO1xuXHRcdH1cblxuXHRcdGlmICggJycgIT09IGFsaWdubWVudCApIHtcblx0XHRcdGVsQ2xhc3MgKz0gJyBzdWktY29udGVudC0nICsgYWxpZ25tZW50O1xuXHRcdH1cblxuXHRcdGlmICggdHJ1ZSA9PT0gaGFzQ2xhc3MgKSB7XG5cdFx0XHRlbENsYXNzICs9ICcgJyArIHRoaXMucHJvcHMuY3VzdG9tQ2xhc3M7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPXsgZWxDbGFzcyB9PlxuXHRcdFx0XHR7IGNoaWxkcmVuIH1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvbW9kYWxzL3BhcnRpYWxzL2Zvb3Rlci5qcyIsImltcG9ydCB7IHJlbmRlciwgdmVyc2lvbiB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBjcmVhdGVSb290IH0gZnJvbSAncmVhY3QtZG9tL2NsaWVudCc7XG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5cbi8qKlxuICogcmVuZGVyIEJsb2NrXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyQmxvY2soIGNvbnRhaW5lcklkLCBlbGVtZW50ICkge1xuXHRjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggY29udGFpbmVySWQgKTtcblxuXHQvLyBJZiBjb250YWluZXIgaXMgaGlkZGVuIGluIFBIUC5cblx0aWYgKCBfLmlzTnVsbCggY29udGFpbmVyICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKHNlbXZlci5ndGUodmVyc2lvbiwgJzE4LjAuMCcpKSB7XG5cdFx0Ly8gUmVhY3QgMTggb3IgaGlnaGVyLlxuXHRcdGNvbnN0IHJvb3QgPSBjcmVhdGVSb290KCBjb250YWluZXIgKTtcblx0XHRyb290LnJlbmRlcihcblx0XHRcdGVsZW1lbnRcblx0XHQpO1xuXHR9IGVsc2Uge1xuXHRcdHJlbmRlcihcblx0XHRcdGVsZW1lbnQsXG5cdFx0XHRjb250YWluZXJcblx0XHQpO1xuXHR9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlckJsb2NrLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgZXhwb3J0cy5jcmVhdGVSb290ID0gbS5jcmVhdGVSb290O1xuICBleHBvcnRzLmh5ZHJhdGVSb290ID0gbS5oeWRyYXRlUm9vdDtcbn0gZWxzZSB7XG4gIHZhciBpID0gbS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgZXhwb3J0cy5jcmVhdGVSb290ID0gZnVuY3Rpb24oYywgbykge1xuICAgIGkudXNpbmdDbGllbnRFbnRyeVBvaW50ID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG0uY3JlYXRlUm9vdChjLCBvKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaS51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGV4cG9ydHMuaHlkcmF0ZVJvb3QgPSBmdW5jdGlvbihjLCBoLCBvKSB7XG4gICAgaS51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbS5oeWRyYXRlUm9vdChjLCBoLCBvKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaS51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2xpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU2VtVmVyO1xuXG4vLyBUaGUgZGVidWcgZnVuY3Rpb24gaXMgZXhjbHVkZWQgZW50aXJlbHkgZnJvbSB0aGUgbWluaWZpZWQgdmVyc2lvbi5cbi8qIG5vbWluICovIHZhciBkZWJ1Zztcbi8qIG5vbWluICovIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgICAvKiBub21pbiAqLyBwcm9jZXNzLmVudiAmJlxuICAgIC8qIG5vbWluICovIHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiZcbiAgICAvKiBub21pbiAqLyAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSlcbiAgLyogbm9taW4gKi8gZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBub21pbiAqLyB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgLyogbm9taW4gKi8gYXJncy51bnNoaWZ0KCdTRU1WRVInKTtcbiAgICAvKiBub21pbiAqLyBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICAvKiBub21pbiAqLyB9O1xuLyogbm9taW4gKi8gZWxzZVxuICAvKiBub21pbiAqLyBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5cbi8vIE5vdGU6IHRoaXMgaXMgdGhlIHNlbXZlci5vcmcgdmVyc2lvbiBvZiB0aGUgc3BlYyB0aGF0IGl0IGltcGxlbWVudHNcbi8vIE5vdCBuZWNlc3NhcmlseSB0aGUgcGFja2FnZSB2ZXJzaW9uIG9mIHRoaXMgY29kZS5cbmV4cG9ydHMuU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCc7XG5cbnZhciBNQVhfTEVOR1RIID0gMjU2O1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vLyBNYXggc2FmZSBzZWdtZW50IGxlbmd0aCBmb3IgY29lcmNpb24uXG52YXIgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCA9IDE2O1xuXG4vLyBUaGUgYWN0dWFsIHJlZ2V4cHMgZ28gb24gZXhwb3J0cy5yZVxudmFyIHJlID0gZXhwb3J0cy5yZSA9IFtdO1xudmFyIHNyYyA9IGV4cG9ydHMuc3JjID0gW107XG52YXIgUiA9IDA7XG5cbi8vIFRoZSBmb2xsb3dpbmcgUmVndWxhciBFeHByZXNzaW9ucyBjYW4gYmUgdXNlZCBmb3IgdG9rZW5pemluZyxcbi8vIHZhbGlkYXRpbmcsIGFuZCBwYXJzaW5nIFNlbVZlciB2ZXJzaW9uIHN0cmluZ3MuXG5cbi8vICMjIE51bWVyaWMgSWRlbnRpZmllclxuLy8gQSBzaW5nbGUgYDBgLCBvciBhIG5vbi16ZXJvIGRpZ2l0IGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBkaWdpdHMuXG5cbnZhciBOVU1FUklDSURFTlRJRklFUiA9IFIrKztcbnNyY1tOVU1FUklDSURFTlRJRklFUl0gPSAnMHxbMS05XVxcXFxkKic7XG52YXIgTlVNRVJJQ0lERU5USUZJRVJMT09TRSA9IFIrKztcbnNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSA9ICdbMC05XSsnO1xuXG5cbi8vICMjIE5vbi1udW1lcmljIElkZW50aWZpZXJcbi8vIFplcm8gb3IgbW9yZSBkaWdpdHMsIGZvbGxvd2VkIGJ5IGEgbGV0dGVyIG9yIGh5cGhlbiwgYW5kIHRoZW4gemVybyBvclxuLy8gbW9yZSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGh5cGhlbnMuXG5cbnZhciBOT05OVU1FUklDSURFTlRJRklFUiA9IFIrKztcbnNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gPSAnXFxcXGQqW2EtekEtWi1dW2EtekEtWjAtOS1dKic7XG5cblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbnZhciBNQUlOVkVSU0lPTiA9IFIrKztcbnNyY1tNQUlOVkVSU0lPTl0gPSAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArICcpJztcblxudmFyIE1BSU5WRVJTSU9OTE9PU0UgPSBSKys7XG5zcmNbTUFJTlZFUlNJT05MT09TRV0gPSAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKSc7XG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb24gSWRlbnRpZmllclxuLy8gQSBudW1lcmljIGlkZW50aWZpZXIsIG9yIGEgbm9uLW51bWVyaWMgaWRlbnRpZmllci5cblxudmFyIFBSRVJFTEVBU0VJREVOVElGSUVSID0gUisrO1xuc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSXSA9ICcoPzonICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3wnICsgc3JjW05PTk5VTUVSSUNJREVOVElGSUVSXSArICcpJztcblxudmFyIFBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0UgPSBSKys7XG5zcmNbUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gPSAnKD86JyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBzcmNbTk9OTlVNRVJJQ0lERU5USUZJRVJdICsgJyknO1xuXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxudmFyIFBSRVJFTEVBU0UgPSBSKys7XG5zcmNbUFJFUkVMRUFTRV0gPSAnKD86LSgnICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSXSArICcpKikpJztcblxudmFyIFBSRVJFTEVBU0VMT09TRSA9IFIrKztcbnNyY1tQUkVSRUxFQVNFTE9PU0VdID0gJyg/Oi0/KCcgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdICsgJykqKSknO1xuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YSBJZGVudGlmaWVyXG4vLyBBbnkgY29tYmluYXRpb24gb2YgZGlnaXRzLCBsZXR0ZXJzLCBvciBoeXBoZW5zLlxuXG52YXIgQlVJTERJREVOVElGSUVSID0gUisrO1xuc3JjW0JVSUxESURFTlRJRklFUl0gPSAnWzAtOUEtWmEtei1dKyc7XG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhXG4vLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGFcbi8vIGlkZW50aWZpZXJzLlxuXG52YXIgQlVJTEQgPSBSKys7XG5zcmNbQlVJTERdID0gJyg/OlxcXFwrKCcgKyBzcmNbQlVJTERJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgJyg/OlxcXFwuJyArIHNyY1tCVUlMRElERU5USUZJRVJdICsgJykqKSknO1xuXG5cbi8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbi8vIEEgbWFpbiB2ZXJzaW9uLCBmb2xsb3dlZCBvcHRpb25hbGx5IGJ5IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiBhbmRcbi8vIGJ1aWxkIG1ldGFkYXRhLlxuXG4vLyBOb3RlIHRoYXQgdGhlIG9ubHkgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIHByZS1yZWxlYXNlIHNlY3Rpb25zIG9mXG4vLyB0aGUgdmVyc2lvbiBzdHJpbmcgYXJlIGNhcHR1cmluZyBncm91cHMuICBUaGUgYnVpbGQgbWV0YWRhdGEgaXMgbm90IGFcbi8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4vLyBjb21wYXJpc29uLlxuXG52YXIgRlVMTCA9IFIrKztcbnZhciBGVUxMUExBSU4gPSAndj8nICsgc3JjW01BSU5WRVJTSU9OXSArXG4gICAgICAgICAgICAgICAgc3JjW1BSRVJFTEVBU0VdICsgJz8nICtcbiAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nO1xuXG5zcmNbRlVMTF0gPSAnXicgKyBGVUxMUExBSU4gKyAnJCc7XG5cbi8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbi8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5XG4vLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cbnZhciBMT09TRVBMQUlOID0gJ1t2PVxcXFxzXSonICsgc3JjW01BSU5WRVJTSU9OTE9PU0VdICtcbiAgICAgICAgICAgICAgICAgc3JjW1BSRVJFTEVBU0VMT09TRV0gKyAnPycgK1xuICAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nO1xuXG52YXIgTE9PU0UgPSBSKys7XG5zcmNbTE9PU0VdID0gJ14nICsgTE9PU0VQTEFJTiArICckJztcblxudmFyIEdUTFQgPSBSKys7XG5zcmNbR1RMVF0gPSAnKCg/Ojx8Pik/PT8pJztcblxuLy8gU29tZXRoaW5nIGxpa2UgXCIyLipcIiBvciBcIjEuMi54XCIuXG4vLyBOb3RlIHRoYXQgXCJ4LnhcIiBpcyBhIHZhbGlkIHhSYW5nZSBpZGVudGlmZXIsIG1lYW5pbmcgXCJhbnkgdmVyc2lvblwiXG4vLyBPbmx5IHRoZSBmaXJzdCBpdGVtIGlzIHN0cmljdGx5IHJlcXVpcmVkLlxudmFyIFhSQU5HRUlERU5USUZJRVJMT09TRSA9IFIrKztcbnNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdID0gc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJ3x4fFh8XFxcXConO1xudmFyIFhSQU5HRUlERU5USUZJRVIgPSBSKys7XG5zcmNbWFJBTkdFSURFTlRJRklFUl0gPSBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJ3x4fFh8XFxcXConO1xuXG52YXIgWFJBTkdFUExBSU4gPSBSKys7XG5zcmNbWFJBTkdFUExBSU5dID0gJ1t2PVxcXFxzXSooJyArIHNyY1tYUkFOR0VJREVOVElGSUVSXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnKD86JyArIHNyY1tQUkVSRUxFQVNFXSArICcpPycgK1xuICAgICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPycgK1xuICAgICAgICAgICAgICAgICAgICcpPyk/JztcblxudmFyIFhSQU5HRVBMQUlOTE9PU0UgPSBSKys7XG5zcmNbWFJBTkdFUExBSU5MT09TRV0gPSAnW3Y9XFxcXHNdKignICsgc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzonICsgc3JjW1BSRVJFTEVBU0VMT09TRV0gKyAnKT8nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyk/KT8nO1xuXG52YXIgWFJBTkdFID0gUisrO1xuc3JjW1hSQU5HRV0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxcXHMqJyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnJCc7XG52YXIgWFJBTkdFTE9PU0UgPSBSKys7XG5zcmNbWFJBTkdFTE9PU0VdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKicgKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7XG5cbi8vIENvZXJjaW9uLlxuLy8gRXh0cmFjdCBhbnl0aGluZyB0aGF0IGNvdWxkIGNvbmNlaXZhYmx5IGJlIGEgcGFydCBvZiBhIHZhbGlkIHNlbXZlclxudmFyIENPRVJDRSA9IFIrKztcbnNyY1tDT0VSQ0VdID0gJyg/Ol58W15cXFxcZF0pJyArXG4gICAgICAgICAgICAgICcoXFxcXGR7MSwnICsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCArICd9KScgK1xuICAgICAgICAgICAgICAnKD86XFxcXC4oXFxcXGR7MSwnICsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCArICd9KSk/JyArXG4gICAgICAgICAgICAgICcoPzpcXFxcLihcXFxcZHsxLCcgKyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIICsgJ30pKT8nICtcbiAgICAgICAgICAgICAgJyg/OiR8W15cXFxcZF0pJztcblxuLy8gVGlsZGUgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcInJlYXNvbmFibHkgYXQgb3IgZ3JlYXRlciB0aGFuXCJcbnZhciBMT05FVElMREUgPSBSKys7XG5zcmNbTE9ORVRJTERFXSA9ICcoPzp+Pj8pJztcblxudmFyIFRJTERFVFJJTSA9IFIrKztcbnNyY1tUSUxERVRSSU1dID0gJyhcXFxccyopJyArIHNyY1tMT05FVElMREVdICsgJ1xcXFxzKyc7XG5yZVtUSUxERVRSSU1dID0gbmV3IFJlZ0V4cChzcmNbVElMREVUUklNXSwgJ2cnKTtcbnZhciB0aWxkZVRyaW1SZXBsYWNlID0gJyQxfic7XG5cbnZhciBUSUxERSA9IFIrKztcbnNyY1tUSUxERV0gPSAnXicgKyBzcmNbTE9ORVRJTERFXSArIHNyY1tYUkFOR0VQTEFJTl0gKyAnJCc7XG52YXIgVElMREVMT09TRSA9IFIrKztcbnNyY1tUSUxERUxPT1NFXSA9ICdeJyArIHNyY1tMT05FVElMREVdICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyQnO1xuXG4vLyBDYXJldCByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwiYXQgbGVhc3QgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGhcIlxudmFyIExPTkVDQVJFVCA9IFIrKztcbnNyY1tMT05FQ0FSRVRdID0gJyg/OlxcXFxeKSc7XG5cbnZhciBDQVJFVFRSSU0gPSBSKys7XG5zcmNbQ0FSRVRUUklNXSA9ICcoXFxcXHMqKScgKyBzcmNbTE9ORUNBUkVUXSArICdcXFxccysnO1xucmVbQ0FSRVRUUklNXSA9IG5ldyBSZWdFeHAoc3JjW0NBUkVUVFJJTV0sICdnJyk7XG52YXIgY2FyZXRUcmltUmVwbGFjZSA9ICckMV4nO1xuXG52YXIgQ0FSRVQgPSBSKys7XG5zcmNbQ0FSRVRdID0gJ14nICsgc3JjW0xPTkVDQVJFVF0gKyBzcmNbWFJBTkdFUExBSU5dICsgJyQnO1xudmFyIENBUkVUTE9PU0UgPSBSKys7XG5zcmNbQ0FSRVRMT09TRV0gPSAnXicgKyBzcmNbTE9ORUNBUkVUXSArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICckJztcblxuLy8gQSBzaW1wbGUgZ3QvbHQvZXEgdGhpbmcsIG9yIGp1c3QgXCJcIiB0byBpbmRpY2F0ZSBcImFueSB2ZXJzaW9uXCJcbnZhciBDT01QQVJBVE9STE9PU0UgPSBSKys7XG5zcmNbQ09NUEFSQVRPUkxPT1NFXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyooJyArIExPT1NFUExBSU4gKyAnKSR8XiQnO1xudmFyIENPTVBBUkFUT1IgPSBSKys7XG5zcmNbQ09NUEFSQVRPUl0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxcXHMqKCcgKyBGVUxMUExBSU4gKyAnKSR8XiQnO1xuXG5cbi8vIEFuIGV4cHJlc3Npb24gdG8gc3RyaXAgYW55IHdoaXRlc3BhY2UgYmV0d2VlbiB0aGUgZ3RsdCBhbmQgdGhlIHRoaW5nXG4vLyBpdCBtb2RpZmllcywgc28gdGhhdCBgPiAxLjIuM2AgPT0+IGA+MS4yLjNgXG52YXIgQ09NUEFSQVRPUlRSSU0gPSBSKys7XG5zcmNbQ09NUEFSQVRPUlRSSU1dID0gJyhcXFxccyopJyArIHNyY1tHVExUXSArXG4gICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKignICsgTE9PU0VQTEFJTiArICd8JyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnKSc7XG5cbi8vIHRoaXMgb25lIGhhcyB0byB1c2UgdGhlIC9nIGZsYWdcbnJlW0NPTVBBUkFUT1JUUklNXSA9IG5ldyBSZWdFeHAoc3JjW0NPTVBBUkFUT1JUUklNXSwgJ2cnKTtcbnZhciBjb21wYXJhdG9yVHJpbVJlcGxhY2UgPSAnJDEkMiQzJztcblxuXG4vLyBTb21ldGhpbmcgbGlrZSBgMS4yLjMgLSAxLjIuNGBcbi8vIE5vdGUgdGhhdCB0aGVzZSBhbGwgdXNlIHRoZSBsb29zZSBmb3JtLCBiZWNhdXNlIHRoZXknbGwgYmVcbi8vIGNoZWNrZWQgYWdhaW5zdCBlaXRoZXIgdGhlIHN0cmljdCBvciBsb29zZSBjb21wYXJhdG9yIGZvcm1cbi8vIGxhdGVyLlxudmFyIEhZUEhFTlJBTkdFID0gUisrO1xuc3JjW0hZUEhFTlJBTkdFXSA9ICdeXFxcXHMqKCcgKyBzcmNbWFJBTkdFUExBSU5dICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnXFxcXHMrLVxcXFxzKycgK1xuICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICdcXFxccyokJztcblxudmFyIEhZUEhFTlJBTkdFTE9PU0UgPSBSKys7XG5zcmNbSFlQSEVOUkFOR0VMT09TRV0gPSAnXlxcXFxzKignICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXFxccystXFxcXHMrJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKiQnO1xuXG4vLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG52YXIgU1RBUiA9IFIrKztcbnNyY1tTVEFSXSA9ICcoPHw+KT89P1xcXFxzKlxcXFwqJztcblxuLy8gQ29tcGlsZSB0byBhY3R1YWwgcmVnZXhwIG9iamVjdHMuXG4vLyBBbGwgYXJlIGZsYWctZnJlZSwgdW5sZXNzIHRoZXkgd2VyZSBjcmVhdGVkIGFib3ZlIHdpdGggYSBmbGFnLlxuZm9yICh2YXIgaSA9IDA7IGkgPCBSOyBpKyspIHtcbiAgZGVidWcoaSwgc3JjW2ldKTtcbiAgaWYgKCFyZVtpXSlcbiAgICByZVtpXSA9IG5ldyBSZWdFeHAoc3JjW2ldKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZnVuY3Rpb24gcGFyc2UodmVyc2lvbiwgbG9vc2UpIHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpXG4gICAgcmV0dXJuIHZlcnNpb247XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJylcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciByID0gbG9vc2UgPyByZVtMT09TRV0gOiByZVtGVUxMXTtcbiAgaWYgKCFyLnRlc3QodmVyc2lvbikpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBsb29zZSk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0cy52YWxpZCA9IHZhbGlkO1xuZnVuY3Rpb24gdmFsaWQodmVyc2lvbiwgbG9vc2UpIHtcbiAgdmFyIHYgPSBwYXJzZSh2ZXJzaW9uLCBsb29zZSk7XG4gIHJldHVybiB2ID8gdi52ZXJzaW9uIDogbnVsbDtcbn1cblxuXG5leHBvcnRzLmNsZWFuID0gY2xlYW47XG5mdW5jdGlvbiBjbGVhbih2ZXJzaW9uLCBsb29zZSkge1xuICB2YXIgcyA9IHBhcnNlKHZlcnNpb24udHJpbSgpLnJlcGxhY2UoL15bPXZdKy8sICcnKSwgbG9vc2UpO1xuICByZXR1cm4gcyA/IHMudmVyc2lvbiA6IG51bGw7XG59XG5cbmV4cG9ydHMuU2VtVmVyID0gU2VtVmVyO1xuXG5mdW5jdGlvbiBTZW1WZXIodmVyc2lvbiwgbG9vc2UpIHtcbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICBpZiAodmVyc2lvbi5sb29zZSA9PT0gbG9vc2UpXG4gICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICBlbHNlXG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbi52ZXJzaW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgVmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2ZXJzaW9uIGlzIGxvbmdlciB0aGFuICcgKyBNQVhfTEVOR1RIICsgJyBjaGFyYWN0ZXJzJylcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBsb29zZSk7XG5cbiAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIGxvb3NlKTtcbiAgdGhpcy5sb29zZSA9IGxvb3NlO1xuICB2YXIgbSA9IHZlcnNpb24udHJpbSgpLm1hdGNoKGxvb3NlID8gcmVbTE9PU0VdIDogcmVbRlVMTF0pO1xuXG4gIGlmICghbSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFZlcnNpb246ICcgKyB2ZXJzaW9uKTtcblxuICB0aGlzLnJhdyA9IHZlcnNpb247XG5cbiAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgdGhpcy5tYWpvciA9ICttWzFdO1xuICB0aGlzLm1pbm9yID0gK21bMl07XG4gIHRoaXMucGF0Y2ggPSArbVszXTtcblxuICBpZiAodGhpcy5tYWpvciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5tYWpvciA8IDApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcblxuICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtaW5vciB2ZXJzaW9uJylcblxuICBpZiAodGhpcy5wYXRjaCA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5wYXRjaCA8IDApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwYXRjaCB2ZXJzaW9uJylcblxuICAvLyBudW1iZXJpZnkgYW55IHByZXJlbGVhc2UgbnVtZXJpYyBpZHNcbiAgaWYgKCFtWzRdKVxuICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICBlbHNlXG4gICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcChmdW5jdGlvbihpZCkge1xuICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgdmFyIG51bSA9ICtpZDtcbiAgICAgICAgaWYgKG51bSA+PSAwICYmIG51bSA8IE1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpZDtcbiAgICB9KTtcblxuICB0aGlzLmJ1aWxkID0gbVs1XSA/IG1bNV0uc3BsaXQoJy4nKSA6IFtdO1xuICB0aGlzLmZvcm1hdCgpO1xufVxuXG5TZW1WZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnZlcnNpb24gPSB0aGlzLm1ham9yICsgJy4nICsgdGhpcy5taW5vciArICcuJyArIHRoaXMucGF0Y2g7XG4gIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHRoaXMudmVyc2lvbiArPSAnLScgKyB0aGlzLnByZXJlbGVhc2Uuam9pbignLicpO1xuICByZXR1cm4gdGhpcy52ZXJzaW9uO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy52ZXJzaW9uO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgZGVidWcoJ1NlbVZlci5jb21wYXJlJywgdGhpcy52ZXJzaW9uLCB0aGlzLmxvb3NlLCBvdGhlcik7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMubG9vc2UpO1xuXG4gIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlTWFpbiA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMubG9vc2UpO1xuXG4gIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlUHJlID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKVxuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5sb29zZSk7XG5cbiAgLy8gTk9UIGhhdmluZyBhIHByZXJlbGVhc2UgaXMgPiBoYXZpbmcgb25lXG4gIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aClcbiAgICByZXR1cm4gLTE7XG4gIGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmIG90aGVyLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHJldHVybiAxO1xuICBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpXG4gICAgcmV0dXJuIDA7XG5cbiAgdmFyIGkgPSAwO1xuICBkbyB7XG4gICAgdmFyIGEgPSB0aGlzLnByZXJlbGVhc2VbaV07XG4gICAgdmFyIGIgPSBvdGhlci5wcmVyZWxlYXNlW2ldO1xuICAgIGRlYnVnKCdwcmVyZWxlYXNlIGNvbXBhcmUnLCBpLCBhLCBiKTtcbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAwO1xuICAgIGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhID09PSBiKVxuICAgICAgY29udGludWU7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKTtcbiAgfSB3aGlsZSAoKytpKTtcbn07XG5cbi8vIHByZW1pbm9yIHdpbGwgYnVtcCB0aGUgdmVyc2lvbiB1cCB0byB0aGUgbmV4dCBtaW5vciByZWxlYXNlLCBhbmQgaW1tZWRpYXRlbHlcbi8vIGRvd24gdG8gcHJlLXJlbGVhc2UuIHByZW1ham9yIGFuZCBwcmVwYXRjaCB3b3JrIHRoZSBzYW1lIHdheS5cblNlbVZlci5wcm90b3R5cGUuaW5jID0gZnVuY3Rpb24ocmVsZWFzZSwgaWRlbnRpZmllcikge1xuICBzd2l0Y2ggKHJlbGVhc2UpIHtcbiAgICBjYXNlICdwcmVtYWpvcic6XG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5taW5vciA9IDA7XG4gICAgICB0aGlzLm1ham9yKys7XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5taW5vcisrO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHJlcGF0Y2gnOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb25cbiAgICAgIC8vIGRyb3AgYW55IHByZXJlbGVhc2VzIHRoYXQgbWlnaHQgYWxyZWFkeSBleGlzdCwgc2luY2UgdGhleSBhcmUgbm90XG4gICAgICAvLyByZWxldmFudCBhdCB0aGlzIHBvaW50LlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKTtcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhIG5vbi1wcmVyZWxlYXNlIHZlcnNpb24sIHRoaXMgYWN0cyB0aGUgc2FtZSBhc1xuICAgIC8vIHByZXBhdGNoLlxuICAgIGNhc2UgJ3ByZXJlbGVhc2UnOlxuICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdtYWpvcic6XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1ham9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWFqb3IgdmVyc2lvbi5cbiAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAvLyAxLjAuMC01IGJ1bXBzIHRvIDEuMC4wXG4gICAgICAvLyAxLjEuMCBidW1wcyB0byAyLjAuMFxuICAgICAgaWYgKHRoaXMubWlub3IgIT09IDAgfHwgdGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLm1ham9yKys7XG4gICAgICB0aGlzLm1pbm9yID0gMDtcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtaW5vcic6XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWlub3IuXG4gICAgICAvLyAxLjIuMC01IGJ1bXBzIHRvIDEuMi4wXG4gICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5taW5vcisrO1xuICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiwgaXQgd2lsbCBpbmNyZW1lbnQgdGhlIHBhdGNoLlxuICAgICAgLy8gSWYgaXQgaXMgYSBwcmUtcmVsZWFzZSBpdCB3aWxsIGJ1bXAgdXAgdG8gdGhlIHNhbWUgcGF0Y2ggdmVyc2lvbi5cbiAgICAgIC8vIDEuMi4wLTUgcGF0Y2hlcyB0byAxLjIuMFxuICAgICAgLy8gMS4yLjAgcGF0Y2hlcyB0byAxLjIuMVxuICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMucGF0Y2grKztcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZCBwdWJsaWNseS5cbiAgICAvLyAxLjAuMCBcInByZVwiIHdvdWxkIGJlY29tZSAxLjAuMC0wIHdoaWNoIGlzIHRoZSB3cm9uZyBkaXJlY3Rpb24uXG4gICAgY2FzZSAncHJlJzpcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbMF07XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnByZXJlbGVhc2UubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlcmVsZWFzZVtpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZVtpXSsrO1xuICAgICAgICAgICAgaSA9IC0yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gLTEpIC8vIGRpZG4ndCBpbmNyZW1lbnQgYW55dGhpbmdcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaCgwKTtcbiAgICAgIH1cbiAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2VbMF0gPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSlcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogJyArIHJlbGVhc2UpO1xuICB9XG4gIHRoaXMuZm9ybWF0KCk7XG4gIHRoaXMucmF3ID0gdGhpcy52ZXJzaW9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmV4cG9ydHMuaW5jID0gaW5jO1xuZnVuY3Rpb24gaW5jKHZlcnNpb24sIHJlbGVhc2UsIGxvb3NlLCBpZGVudGlmaWVyKSB7XG4gIGlmICh0eXBlb2YobG9vc2UpID09PSAnc3RyaW5nJykge1xuICAgIGlkZW50aWZpZXIgPSBsb29zZTtcbiAgICBsb29zZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpLmluYyhyZWxlYXNlLCBpZGVudGlmaWVyKS52ZXJzaW9uO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydHMuZGlmZiA9IGRpZmY7XG5mdW5jdGlvbiBkaWZmKHZlcnNpb24xLCB2ZXJzaW9uMikge1xuICBpZiAoZXEodmVyc2lvbjEsIHZlcnNpb24yKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHZhciB2MSA9IHBhcnNlKHZlcnNpb24xKTtcbiAgICB2YXIgdjIgPSBwYXJzZSh2ZXJzaW9uMik7XG4gICAgaWYgKHYxLnByZXJlbGVhc2UubGVuZ3RoIHx8IHYyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdjEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ21ham9yJyB8fCBrZXkgPT09ICdtaW5vcicgfHwga2V5ID09PSAncGF0Y2gnKSB7XG4gICAgICAgICAgaWYgKHYxW2tleV0gIT09IHYyW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiAncHJlJytrZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJ3ByZXJlbGVhc2UnO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gdjEpIHtcbiAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICBpZiAodjFba2V5XSAhPT0gdjJba2V5XSkge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5jb21wYXJlSWRlbnRpZmllcnMgPSBjb21wYXJlSWRlbnRpZmllcnM7XG5cbnZhciBudW1lcmljID0gL15bMC05XSskLztcbmZ1bmN0aW9uIGNvbXBhcmVJZGVudGlmaWVycyhhLCBiKSB7XG4gIHZhciBhbnVtID0gbnVtZXJpYy50ZXN0KGEpO1xuICB2YXIgYm51bSA9IG51bWVyaWMudGVzdChiKTtcblxuICBpZiAoYW51bSAmJiBibnVtKSB7XG4gICAgYSA9ICthO1xuICAgIGIgPSArYjtcbiAgfVxuXG4gIHJldHVybiAoYW51bSAmJiAhYm51bSkgPyAtMSA6XG4gICAgICAgICAoYm51bSAmJiAhYW51bSkgPyAxIDpcbiAgICAgICAgIGEgPCBiID8gLTEgOlxuICAgICAgICAgYSA+IGIgPyAxIDpcbiAgICAgICAgIDA7XG59XG5cbmV4cG9ydHMucmNvbXBhcmVJZGVudGlmaWVycyA9IHJjb21wYXJlSWRlbnRpZmllcnM7XG5mdW5jdGlvbiByY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyhiLCBhKTtcbn1cblxuZXhwb3J0cy5tYWpvciA9IG1ham9yO1xuZnVuY3Rpb24gbWFqb3IoYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yO1xufVxuXG5leHBvcnRzLm1pbm9yID0gbWlub3I7XG5mdW5jdGlvbiBtaW5vcihhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkubWlub3I7XG59XG5cbmV4cG9ydHMucGF0Y2ggPSBwYXRjaDtcbmZ1bmN0aW9uIHBhdGNoKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaDtcbn1cblxuZXhwb3J0cy5jb21wYXJlID0gY29tcGFyZTtcbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpO1xufVxuXG5leHBvcnRzLmNvbXBhcmVMb29zZSA9IGNvbXBhcmVMb29zZTtcbmZ1bmN0aW9uIGNvbXBhcmVMb29zZShhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIHRydWUpO1xufVxuXG5leHBvcnRzLnJjb21wYXJlID0gcmNvbXBhcmU7XG5mdW5jdGlvbiByY29tcGFyZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShiLCBhLCBsb29zZSk7XG59XG5cbmV4cG9ydHMuc29ydCA9IHNvcnQ7XG5mdW5jdGlvbiBzb3J0KGxpc3QsIGxvb3NlKSB7XG4gIHJldHVybiBsaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBleHBvcnRzLmNvbXBhcmUoYSwgYiwgbG9vc2UpO1xuICB9KTtcbn1cblxuZXhwb3J0cy5yc29ydCA9IHJzb3J0O1xuZnVuY3Rpb24gcnNvcnQobGlzdCwgbG9vc2UpIHtcbiAgcmV0dXJuIGxpc3Quc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMucmNvbXBhcmUoYSwgYiwgbG9vc2UpO1xuICB9KTtcbn1cblxuZXhwb3J0cy5ndCA9IGd0O1xuZnVuY3Rpb24gZ3QoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMDtcbn1cblxuZXhwb3J0cy5sdCA9IGx0O1xuZnVuY3Rpb24gbHQoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpIDwgMDtcbn1cblxuZXhwb3J0cy5lcSA9IGVxO1xuZnVuY3Rpb24gZXEoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID09PSAwO1xufVxuXG5leHBvcnRzLm5lcSA9IG5lcTtcbmZ1bmN0aW9uIG5lcShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgIT09IDA7XG59XG5cbmV4cG9ydHMuZ3RlID0gZ3RlO1xuZnVuY3Rpb24gZ3RlKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+PSAwO1xufVxuXG5leHBvcnRzLmx0ZSA9IGx0ZTtcbmZ1bmN0aW9uIGx0ZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPD0gMDtcbn1cblxuZXhwb3J0cy5jbXAgPSBjbXA7XG5mdW5jdGlvbiBjbXAoYSwgb3AsIGIsIGxvb3NlKSB7XG4gIHZhciByZXQ7XG4gIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlICc9PT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JykgYSA9IGEudmVyc2lvbjtcbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIGIgPSBiLnZlcnNpb247XG4gICAgICByZXQgPSBhID09PSBiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnIT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIGEgPSBhLnZlcnNpb247XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKSBiID0gYi52ZXJzaW9uO1xuICAgICAgcmV0ID0gYSAhPT0gYjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyc6IGNhc2UgJz0nOiBjYXNlICc9PSc6IHJldCA9IGVxKGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnIT0nOiByZXQgPSBuZXEoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICc+JzogcmV0ID0gZ3QoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICc+PSc6IHJldCA9IGd0ZShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJzwnOiByZXQgPSBsdChhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJzw9JzogcmV0ID0gbHRlKGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvcGVyYXRvcjogJyArIG9wKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnRzLkNvbXBhcmF0b3IgPSBDb21wYXJhdG9yO1xuZnVuY3Rpb24gQ29tcGFyYXRvcihjb21wLCBsb29zZSkge1xuICBpZiAoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICBpZiAoY29tcC5sb29zZSA9PT0gbG9vc2UpXG4gICAgICByZXR1cm4gY29tcDtcbiAgICBlbHNlXG4gICAgICBjb21wID0gY29tcC52YWx1ZTtcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSlcbiAgICByZXR1cm4gbmV3IENvbXBhcmF0b3IoY29tcCwgbG9vc2UpO1xuXG4gIGRlYnVnKCdjb21wYXJhdG9yJywgY29tcCwgbG9vc2UpO1xuICB0aGlzLmxvb3NlID0gbG9vc2U7XG4gIHRoaXMucGFyc2UoY29tcCk7XG5cbiAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpXG4gICAgdGhpcy52YWx1ZSA9ICcnO1xuICBlbHNlXG4gICAgdGhpcy52YWx1ZSA9IHRoaXMub3BlcmF0b3IgKyB0aGlzLnNlbXZlci52ZXJzaW9uO1xuXG4gIGRlYnVnKCdjb21wJywgdGhpcyk7XG59XG5cbnZhciBBTlkgPSB7fTtcbkNvbXBhcmF0b3IucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oY29tcCkge1xuICB2YXIgciA9IHRoaXMubG9vc2UgPyByZVtDT01QQVJBVE9STE9PU0VdIDogcmVbQ09NUEFSQVRPUl07XG4gIHZhciBtID0gY29tcC5tYXRjaChyKTtcblxuICBpZiAoIW0pXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjb21wYXJhdG9yOiAnICsgY29tcCk7XG5cbiAgdGhpcy5vcGVyYXRvciA9IG1bMV07XG4gIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpXG4gICAgdGhpcy5vcGVyYXRvciA9ICcnO1xuXG4gIC8vIGlmIGl0IGxpdGVyYWxseSBpcyBqdXN0ICc+JyBvciAnJyB0aGVuIGFsbG93IGFueXRoaW5nLlxuICBpZiAoIW1bMl0pXG4gICAgdGhpcy5zZW12ZXIgPSBBTlk7XG4gIGVsc2VcbiAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5sb29zZSk7XG59O1xuXG5Db21wYXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbih2ZXJzaW9uKSB7XG4gIGRlYnVnKCdDb21wYXJhdG9yLnRlc3QnLCB2ZXJzaW9uLCB0aGlzLmxvb3NlKTtcblxuICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSlcbiAgICByZXR1cm4gdHJ1ZTtcblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKVxuICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMubG9vc2UpO1xuXG4gIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMubG9vc2UpO1xufTtcblxuQ29tcGFyYXRvci5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKGNvbXAsIGxvb3NlKSB7XG4gIGlmICghKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgQ29tcGFyYXRvciBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgdmFyIHJhbmdlVG1wO1xuXG4gIGlmICh0aGlzLm9wZXJhdG9yID09PSAnJykge1xuICAgIHJhbmdlVG1wID0gbmV3IFJhbmdlKGNvbXAudmFsdWUsIGxvb3NlKTtcbiAgICByZXR1cm4gc2F0aXNmaWVzKHRoaXMudmFsdWUsIHJhbmdlVG1wLCBsb29zZSk7XG4gIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHtcbiAgICByYW5nZVRtcCA9IG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBsb29zZSk7XG4gICAgcmV0dXJuIHNhdGlzZmllcyhjb21wLnNlbXZlciwgcmFuZ2VUbXAsIGxvb3NlKTtcbiAgfVxuXG4gIHZhciBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyA9XG4gICAgKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJz4nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+Jyk7XG4gIHZhciBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyA9XG4gICAgKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8Jyk7XG4gIHZhciBzYW1lU2VtVmVyID0gdGhpcy5zZW12ZXIudmVyc2lvbiA9PT0gY29tcC5zZW12ZXIudmVyc2lvbjtcbiAgdmFyIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8PScpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzw9Jyk7XG4gIHZhciBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiA9XG4gICAgY21wKHRoaXMuc2VtdmVyLCAnPCcsIGNvbXAuc2VtdmVyLCBsb29zZSkgJiZcbiAgICAoKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJz4nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8JykpO1xuICB2YXIgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW4gPVxuICAgIGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgbG9vc2UpICYmXG4gICAgKCh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpKTtcblxuICByZXR1cm4gc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgfHwgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgfHxcbiAgICAoc2FtZVNlbVZlciAmJiBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlKSB8fFxuICAgIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuIHx8IG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuO1xufTtcblxuXG5leHBvcnRzLlJhbmdlID0gUmFuZ2U7XG5mdW5jdGlvbiBSYW5nZShyYW5nZSwgbG9vc2UpIHtcbiAgaWYgKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICBpZiAocmFuZ2UubG9vc2UgPT09IGxvb3NlKSB7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UucmF3LCBsb29zZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJhbmdlIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UudmFsdWUsIGxvb3NlKTtcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5nZSkpXG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpO1xuXG4gIHRoaXMubG9vc2UgPSBsb29zZTtcblxuICAvLyBGaXJzdCwgc3BsaXQgYmFzZWQgb24gYm9vbGVhbiBvciB8fFxuICB0aGlzLnJhdyA9IHJhbmdlO1xuICB0aGlzLnNldCA9IHJhbmdlLnNwbGl0KC9cXHMqXFx8XFx8XFxzKi8pLm1hcChmdW5jdGlvbihyYW5nZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUmFuZ2UocmFuZ2UudHJpbSgpKTtcbiAgfSwgdGhpcykuZmlsdGVyKGZ1bmN0aW9uKGMpIHtcbiAgICAvLyB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCByZWxldmFudCBmb3Igd2hhdGV2ZXIgcmVhc29uXG4gICAgcmV0dXJuIGMubGVuZ3RoO1xuICB9KTtcblxuICBpZiAoIXRoaXMuc2V0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgU2VtVmVyIFJhbmdlOiAnICsgcmFuZ2UpO1xuICB9XG5cbiAgdGhpcy5mb3JtYXQoKTtcbn1cblxuUmFuZ2UucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJhbmdlID0gdGhpcy5zZXQubWFwKGZ1bmN0aW9uKGNvbXBzKSB7XG4gICAgcmV0dXJuIGNvbXBzLmpvaW4oJyAnKS50cmltKCk7XG4gIH0pLmpvaW4oJ3x8JykudHJpbSgpO1xuICByZXR1cm4gdGhpcy5yYW5nZTtcbn07XG5cblJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yYW5nZTtcbn07XG5cblJhbmdlLnByb3RvdHlwZS5wYXJzZVJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgdmFyIGxvb3NlID0gdGhpcy5sb29zZTtcbiAgcmFuZ2UgPSByYW5nZS50cmltKCk7XG4gIGRlYnVnKCdyYW5nZScsIHJhbmdlLCBsb29zZSk7XG4gIC8vIGAxLjIuMyAtIDEuMi40YCA9PiBgPj0xLjIuMyA8PTEuMi40YFxuICB2YXIgaHIgPSBsb29zZSA/IHJlW0hZUEhFTlJBTkdFTE9PU0VdIDogcmVbSFlQSEVOUkFOR0VdO1xuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UoaHIsIGh5cGhlblJlcGxhY2UpO1xuICBkZWJ1ZygnaHlwaGVuIHJlcGxhY2UnLCByYW5nZSk7XG4gIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbQ09NUEFSQVRPUlRSSU1dLCBjb21wYXJhdG9yVHJpbVJlcGxhY2UpO1xuICBkZWJ1ZygnY29tcGFyYXRvciB0cmltJywgcmFuZ2UsIHJlW0NPTVBBUkFUT1JUUklNXSk7XG5cbiAgLy8gYH4gMS4yLjNgID0+IGB+MS4yLjNgXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVtUSUxERVRSSU1dLCB0aWxkZVRyaW1SZXBsYWNlKTtcblxuICAvLyBgXiAxLjIuM2AgPT4gYF4xLjIuM2BcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW0NBUkVUVFJJTV0sIGNhcmV0VHJpbVJlcGxhY2UpO1xuXG4gIC8vIG5vcm1hbGl6ZSBzcGFjZXNcbiAgcmFuZ2UgPSByYW5nZS5zcGxpdCgvXFxzKy8pLmpvaW4oJyAnKTtcblxuICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSB0cmltbWVkIGFuZFxuICAvLyByZWFkeSB0byBiZSBzcGxpdCBpbnRvIGNvbXBhcmF0b3JzLlxuXG4gIHZhciBjb21wUmUgPSBsb29zZSA/IHJlW0NPTVBBUkFUT1JMT09TRV0gOiByZVtDT01QQVJBVE9SXTtcbiAgdmFyIHNldCA9IHJhbmdlLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gcGFyc2VDb21wYXJhdG9yKGNvbXAsIGxvb3NlKTtcbiAgfSkuam9pbignICcpLnNwbGl0KC9cXHMrLyk7XG4gIGlmICh0aGlzLmxvb3NlKSB7XG4gICAgLy8gaW4gbG9vc2UgbW9kZSwgdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgdmFsaWQgY29tcGFyYXRvcnNcbiAgICBzZXQgPSBzZXQuZmlsdGVyKGZ1bmN0aW9uKGNvbXApIHtcbiAgICAgIHJldHVybiAhIWNvbXAubWF0Y2goY29tcFJlKTtcbiAgICB9KTtcbiAgfVxuICBzZXQgPSBzZXQubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gbmV3IENvbXBhcmF0b3IoY29tcCwgbG9vc2UpO1xuICB9KTtcblxuICByZXR1cm4gc2V0O1xufTtcblxuUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbihyYW5nZSwgbG9vc2UpIHtcbiAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5zZXQuc29tZShmdW5jdGlvbih0aGlzQ29tcGFyYXRvcnMpIHtcbiAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KGZ1bmN0aW9uKHRoaXNDb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gcmFuZ2Uuc2V0LnNvbWUoZnVuY3Rpb24ocmFuZ2VDb21wYXJhdG9ycykge1xuICAgICAgICByZXR1cm4gcmFuZ2VDb21wYXJhdG9ycy5ldmVyeShmdW5jdGlvbihyYW5nZUNvbXBhcmF0b3IpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3IuaW50ZXJzZWN0cyhyYW5nZUNvbXBhcmF0b3IsIGxvb3NlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5leHBvcnRzLnRvQ29tcGFyYXRvcnMgPSB0b0NvbXBhcmF0b3JzO1xuZnVuY3Rpb24gdG9Db21wYXJhdG9ycyhyYW5nZSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpLnNldC5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiBjb21wLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICB9KS5qb2luKCcgJykudHJpbSgpLnNwbGl0KCcgJyk7XG4gIH0pO1xufVxuXG4vLyBjb21wcmlzZWQgb2YgeHJhbmdlcywgdGlsZGVzLCBzdGFycywgYW5kIGd0bHQncyBhdCB0aGlzIHBvaW50LlxuLy8gYWxyZWFkeSByZXBsYWNlZCB0aGUgaHlwaGVuIHJhbmdlc1xuLy8gdHVybiBpbnRvIGEgc2V0IG9mIEpVU1QgY29tcGFyYXRvcnMuXG5mdW5jdGlvbiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgbG9vc2UpIHtcbiAgZGVidWcoJ2NvbXAnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgbG9vc2UpO1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgbG9vc2UpO1xuICBkZWJ1ZygndGlsZGVzJywgY29tcCk7XG4gIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBsb29zZSk7XG4gIGRlYnVnKCd4cmFuZ2UnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBsb29zZSk7XG4gIGRlYnVnKCdzdGFycycsIGNvbXApO1xuICByZXR1cm4gY29tcDtcbn1cblxuZnVuY3Rpb24gaXNYKGlkKSB7XG4gIHJldHVybiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKic7XG59XG5cbi8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gfjIuMCwgfjIuMC54LCB+PjIuMCwgfj4yLjAueCAtLT4gPj0yLjAuMCA8Mi4xLjBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wXG4vLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wXG4vLyB+MS4yLjAsIH4+MS4yLjAgLS0+ID49MS4yLjAgPDEuMy4wXG5mdW5jdGlvbiByZXBsYWNlVGlsZGVzKGNvbXAsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VUaWxkZShjb21wLCBsb29zZSk7XG4gIH0pLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVRpbGRlKGNvbXAsIGxvb3NlKSB7XG4gIHZhciByID0gbG9vc2UgPyByZVtUSUxERUxPT1NFXSA6IHJlW1RJTERFXTtcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbihfLCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCd0aWxkZScsIGNvbXAsIF8sIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKGlzWChNKSlcbiAgICAgIHJldCA9ICcnO1xuICAgIGVsc2UgaWYgKGlzWChtKSlcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICBlbHNlIGlmIChpc1gocCkpXG4gICAgICAvLyB+MS4yID09ID49MS4yLjAgPDEuMy4wXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgIGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZVRpbGRlIHByJywgcHIpO1xuICAgICAgaWYgKHByLmNoYXJBdCgwKSAhPT0gJy0nKVxuICAgICAgICBwciA9ICctJyArIHByO1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgIH0gZWxzZVxuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuXG4gICAgZGVidWcoJ3RpbGRlIHJldHVybicsIHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG5cbi8vIF4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyBeMiwgXjIueCwgXjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gXjIuMCwgXjIuMC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gXjEuMiwgXjEuMi54IC0tPiA+PTEuMi4wIDwyLjAuMFxuLy8gXjEuMi4zIC0tPiA+PTEuMi4zIDwyLjAuMFxuLy8gXjEuMi4wIC0tPiA+PTEuMi4wIDwyLjAuMFxuZnVuY3Rpb24gcmVwbGFjZUNhcmV0cyhjb21wLCBsb29zZSkge1xuICByZXR1cm4gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlQ2FyZXQoY29tcCwgbG9vc2UpO1xuICB9KS5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VDYXJldChjb21wLCBsb29zZSkge1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBsb29zZSk7XG4gIHZhciByID0gbG9vc2UgPyByZVtDQVJFVExPT1NFXSA6IHJlW0NBUkVUXTtcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbihfLCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCdjYXJldCcsIGNvbXAsIF8sIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKGlzWChNKSlcbiAgICAgIHJldCA9ICcnO1xuICAgIGVsc2UgaWYgKGlzWChtKSlcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlQ2FyZXQgcHInLCBwcik7XG4gICAgICBpZiAocHIuY2hhckF0KDApICE9PSAnLScpXG4gICAgICAgIHByID0gJy0nICsgcHI7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpXG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArIG0gKyAnLicgKyAoK3AgKyAxKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICAgJyA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKTtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJylcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArIG0gKyAnLicgKyAoK3AgKyAxKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAnIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgfVxuXG4gICAgZGVidWcoJ2NhcmV0IHJldHVybicsIHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VYUmFuZ2VzKGNvbXAsIGxvb3NlKSB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIGxvb3NlKTtcbiAgcmV0dXJuIGNvbXAuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlWFJhbmdlKGNvbXAsIGxvb3NlKTtcbiAgfSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlWFJhbmdlKGNvbXAsIGxvb3NlKSB7XG4gIGNvbXAgPSBjb21wLnRyaW0oKTtcbiAgdmFyIHIgPSBsb29zZSA/IHJlW1hSQU5HRUxPT1NFXSA6IHJlW1hSQU5HRV07XG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24ocmV0LCBndGx0LCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCd4UmFuZ2UnLCBjb21wLCByZXQsIGd0bHQsIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgeE0gPSBpc1goTSk7XG4gICAgdmFyIHhtID0geE0gfHwgaXNYKG0pO1xuICAgIHZhciB4cCA9IHhtIHx8IGlzWChwKTtcbiAgICB2YXIgYW55WCA9IHhwO1xuXG4gICAgaWYgKGd0bHQgPT09ICc9JyAmJiBhbnlYKVxuICAgICAgZ3RsdCA9ICcnO1xuXG4gICAgaWYgKHhNKSB7XG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgcmV0ID0gJzwwLjAuMCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGZvcmJpZGRlblxuICAgICAgICByZXQgPSAnKic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSlcbiAgICAgICAgbSA9IDA7XG4gICAgICBpZiAoeHApXG4gICAgICAgIHAgPSAwO1xuXG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nKSB7XG4gICAgICAgIC8vID4xID0+ID49Mi4wLjBcbiAgICAgICAgLy8gPjEuMiA9PiA+PTEuMy4wXG4gICAgICAgIC8vID4xLjIuMyA9PiA+PSAxLjIuNFxuICAgICAgICBndGx0ID0gJz49JztcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMTtcbiAgICAgICAgICBtID0gMDtcbiAgICAgICAgICBwID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgICAgIG0gPSArbSArIDE7XG4gICAgICAgICAgcCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ3RsdCA9PT0gJzw9Jykge1xuICAgICAgICAvLyA8PTAuNy54IGlzIGFjdHVhbGx5IDwwLjguMCwgc2luY2UgYW55IDAuNy54IHNob3VsZFxuICAgICAgICAvLyBwYXNzLiAgU2ltaWxhcmx5LCA8PTcueCBpcyBhY3R1YWxseSA8OC4wLjAsIGV0Yy5cbiAgICAgICAgZ3RsdCA9ICc8JztcbiAgICAgICAgaWYgKHhtKVxuICAgICAgICAgIE0gPSArTSArIDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtID0gK20gKyAxO1xuICAgICAgfVxuXG4gICAgICByZXQgPSBndGx0ICsgTSArICcuJyArIG0gKyAnLicgKyBwO1xuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgIH1cblxuICAgIGRlYnVnKCd4UmFuZ2UgcmV0dXJuJywgcmV0KTtcblxuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuXG4vLyBCZWNhdXNlICogaXMgQU5ELWVkIHdpdGggZXZlcnl0aGluZyBlbHNlIGluIHRoZSBjb21wYXJhdG9yLFxuLy8gYW5kICcnIG1lYW5zIFwiYW55IHZlcnNpb25cIiwganVzdCByZW1vdmUgdGhlICpzIGVudGlyZWx5LlxuZnVuY3Rpb24gcmVwbGFjZVN0YXJzKGNvbXAsIGxvb3NlKSB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBsb29zZSk7XG4gIC8vIExvb3NlbmVzcyBpcyBpZ25vcmVkIGhlcmUuICBzdGFyIGlzIGFsd2F5cyBhcyBsb29zZSBhcyBpdCBnZXRzIVxuICByZXR1cm4gY29tcC50cmltKCkucmVwbGFjZShyZVtTVEFSXSwgJycpO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVtIWVBIRU5SQU5HRV0pXG4vLyBNLCBtLCBwYXRjaCwgcHJlcmVsZWFzZSwgYnVpbGRcbi8vIDEuMiAtIDMuNC41ID0+ID49MS4yLjAgPD0zLjQuNVxuLy8gMS4yLjMgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAgQW55IDMuNC54IHdpbGwgZG9cbi8vIDEuMiAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMFxuZnVuY3Rpb24gaHlwaGVuUmVwbGFjZSgkMCxcbiAgICAgICAgICAgICAgICAgICAgICAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgICAgICAgICAgICAgICAgICAgICAgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpIHtcblxuICBpZiAoaXNYKGZNKSlcbiAgICBmcm9tID0gJyc7XG4gIGVsc2UgaWYgKGlzWChmbSkpXG4gICAgZnJvbSA9ICc+PScgKyBmTSArICcuMC4wJztcbiAgZWxzZSBpZiAoaXNYKGZwKSlcbiAgICBmcm9tID0gJz49JyArIGZNICsgJy4nICsgZm0gKyAnLjAnO1xuICBlbHNlXG4gICAgZnJvbSA9ICc+PScgKyBmcm9tO1xuXG4gIGlmIChpc1godE0pKVxuICAgIHRvID0gJyc7XG4gIGVsc2UgaWYgKGlzWCh0bSkpXG4gICAgdG8gPSAnPCcgKyAoK3RNICsgMSkgKyAnLjAuMCc7XG4gIGVsc2UgaWYgKGlzWCh0cCkpXG4gICAgdG8gPSAnPCcgKyB0TSArICcuJyArICgrdG0gKyAxKSArICcuMCc7XG4gIGVsc2UgaWYgKHRwcilcbiAgICB0byA9ICc8PScgKyB0TSArICcuJyArIHRtICsgJy4nICsgdHAgKyAnLScgKyB0cHI7XG4gIGVsc2VcbiAgICB0byA9ICc8PScgKyB0bztcblxuICByZXR1cm4gKGZyb20gKyAnICcgKyB0bykudHJpbSgpO1xufVxuXG5cbi8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcblJhbmdlLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24odmVyc2lvbikge1xuICBpZiAoIXZlcnNpb24pXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpXG4gICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5sb29zZSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uKSlcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHRlc3RTZXQoc2V0LCB2ZXJzaW9uKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFzZXRbaV0udGVzdCh2ZXJzaW9uKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh2ZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgLy8gRmluZCB0aGUgc2V0IG9mIHZlcnNpb25zIHRoYXQgYXJlIGFsbG93ZWQgdG8gaGF2ZSBwcmVyZWxlYXNlc1xuICAgIC8vIEZvciBleGFtcGxlLCBeMS4yLjMtcHIuMSBkZXN1Z2FycyB0byA+PTEuMi4zLXByLjEgPDIuMC4wXG4gICAgLy8gVGhhdCBzaG91bGQgYWxsb3cgYDEuMi4zLXByLjJgIHRvIHBhc3MuXG4gICAgLy8gSG93ZXZlciwgYDEuMi40LWFscGhhLm5vdHJlYWR5YCBzaG91bGQgTk9UIGJlIGFsbG93ZWQsXG4gICAgLy8gZXZlbiB0aG91Z2ggaXQncyB3aXRoaW4gdGhlIHJhbmdlIHNldCBieSB0aGUgY29tcGFyYXRvcnMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYnVnKHNldFtpXS5zZW12ZXIpO1xuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IEFOWSlcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXI7XG4gICAgICAgIGlmIChhbGxvd2VkLm1ham9yID09PSB2ZXJzaW9uLm1ham9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLm1pbm9yID09PSB2ZXJzaW9uLm1pbm9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLnBhdGNoID09PSB2ZXJzaW9uLnBhdGNoKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZlcnNpb24gaGFzIGEgLXByZSwgYnV0IGl0J3Mgbm90IG9uZSBvZiB0aGUgb25lcyB3ZSBsaWtlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnRzLnNhdGlzZmllcyA9IHNhdGlzZmllcztcbmZ1bmN0aW9uIHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgbG9vc2UpIHtcbiAgdHJ5IHtcbiAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcmFuZ2UudGVzdCh2ZXJzaW9uKTtcbn1cblxuZXhwb3J0cy5tYXhTYXRpc2Z5aW5nID0gbWF4U2F0aXNmeWluZztcbmZ1bmN0aW9uIG1heFNhdGlzZnlpbmcodmVyc2lvbnMsIHJhbmdlLCBsb29zZSkge1xuICB2YXIgbWF4ID0gbnVsbDtcbiAgdmFyIG1heFNWID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB2YXIgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHsgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBsb29zZSlcbiAgICAgIGlmICghbWF4IHx8IG1heFNWLmNvbXBhcmUodikgPT09IC0xKSB7IC8vIGNvbXBhcmUobWF4LCB2LCB0cnVlKVxuICAgICAgICBtYXggPSB2O1xuICAgICAgICBtYXhTViA9IG5ldyBTZW1WZXIobWF4LCBsb29zZSk7XG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWF4O1xufVxuXG5leHBvcnRzLm1pblNhdGlzZnlpbmcgPSBtaW5TYXRpc2Z5aW5nO1xuZnVuY3Rpb24gbWluU2F0aXNmeWluZyh2ZXJzaW9ucywgcmFuZ2UsIGxvb3NlKSB7XG4gIHZhciBtaW4gPSBudWxsO1xuICB2YXIgbWluU1YgPSBudWxsO1xuICB0cnkge1xuICAgIHZhciByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkgeyAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIGxvb3NlKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkgeyAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdjtcbiAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgbG9vc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1pbjtcbn1cblxuZXhwb3J0cy52YWxpZFJhbmdlID0gdmFsaWRSYW5nZTtcbmZ1bmN0aW9uIHZhbGlkUmFuZ2UocmFuZ2UsIGxvb3NlKSB7XG4gIHRyeSB7XG4gICAgLy8gUmV0dXJuICcqJyBpbnN0ZWFkIG9mICcnIHNvIHRoYXQgdHJ1dGhpbmVzcyB3b3Jrcy5cbiAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgaXQncyBpbnZhbGlkIGFueXdheVxuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKS5yYW5nZSB8fCAnKic7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgbGVzcyB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlXG5leHBvcnRzLmx0ciA9IGx0cjtcbmZ1bmN0aW9uIGx0cih2ZXJzaW9uLCByYW5nZSwgbG9vc2UpIHtcbiAgcmV0dXJuIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc8JywgbG9vc2UpO1xufVxuXG4vLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5leHBvcnRzLmd0ciA9IGd0cjtcbmZ1bmN0aW9uIGd0cih2ZXJzaW9uLCByYW5nZSwgbG9vc2UpIHtcbiAgcmV0dXJuIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc+JywgbG9vc2UpO1xufVxuXG5leHBvcnRzLm91dHNpZGUgPSBvdXRzaWRlO1xuZnVuY3Rpb24gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgaGlsbywgbG9vc2UpIHtcbiAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpO1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpO1xuXG4gIHZhciBndGZuLCBsdGVmbiwgbHRmbiwgY29tcCwgZWNvbXA7XG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0O1xuICAgICAgbHRlZm4gPSBsdGU7XG4gICAgICBsdGZuID0gbHQ7XG4gICAgICBjb21wID0gJz4nO1xuICAgICAgZWNvbXAgPSAnPj0nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHQ7XG4gICAgICBsdGVmbiA9IGd0ZTtcbiAgICAgIGx0Zm4gPSBndDtcbiAgICAgIGNvbXAgPSAnPCc7XG4gICAgICBlY29tcCA9ICc8PSc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKTtcbiAgfVxuXG4gIC8vIElmIGl0IHNhdGlzaWZlcyB0aGUgcmFuZ2UgaXQgaXMgbm90IG91dHNpZGVcbiAgaWYgKHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgbG9vc2UpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXTtcblxuICAgIHZhciBoaWdoID0gbnVsbDtcbiAgICB2YXIgbG93ID0gbnVsbDtcblxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3I7XG4gICAgICBsb3cgPSBsb3cgfHwgY29tcGFyYXRvcjtcbiAgICAgIGlmIChndGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBoaWdoLnNlbXZlciwgbG9vc2UpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yO1xuICAgICAgfSBlbHNlIGlmIChsdGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBsb3cuc2VtdmVyLCBsb29zZSkpIHtcbiAgICAgICAgbG93ID0gY29tcGFyYXRvcjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIElmIHRoZSBlZGdlIHZlcnNpb24gY29tcGFyYXRvciBoYXMgYSBvcGVyYXRvciB0aGVuIG91ciB2ZXJzaW9uXG4gICAgLy8gaXNuJ3Qgb3V0c2lkZSBpdFxuICAgIGlmIChoaWdoLm9wZXJhdG9yID09PSBjb21wIHx8IGhpZ2gub3BlcmF0b3IgPT09IGVjb21wKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvd2VzdCB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGFuIG9wZXJhdG9yIGFuZCBvdXIgdmVyc2lvblxuICAgIC8vIGlzIGxlc3MgdGhhbiBpdCB0aGVuIGl0IGlzbid0IGhpZ2hlciB0aGFuIHRoZSByYW5nZVxuICAgIGlmICgoIWxvdy5vcGVyYXRvciB8fCBsb3cub3BlcmF0b3IgPT09IGNvbXApICYmXG4gICAgICAgIGx0ZWZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydHMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2U7XG5mdW5jdGlvbiBwcmVyZWxlYXNlKHZlcnNpb24sIGxvb3NlKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBsb29zZSk7XG4gIHJldHVybiAocGFyc2VkICYmIHBhcnNlZC5wcmVyZWxlYXNlLmxlbmd0aCkgPyBwYXJzZWQucHJlcmVsZWFzZSA6IG51bGw7XG59XG5cbmV4cG9ydHMuaW50ZXJzZWN0cyA9IGludGVyc2VjdHM7XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHIxLCByMiwgbG9vc2UpIHtcbiAgcjEgPSBuZXcgUmFuZ2UocjEsIGxvb3NlKVxuICByMiA9IG5ldyBSYW5nZShyMiwgbG9vc2UpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyKVxufVxuXG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmZ1bmN0aW9uIGNvZXJjZSh2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKVxuICAgIHJldHVybiB2ZXJzaW9uO1xuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIG1hdGNoID0gdmVyc2lvbi5tYXRjaChyZVtDT0VSQ0VdKTtcblxuICBpZiAobWF0Y2ggPT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICByZXR1cm4gcGFyc2UoKG1hdGNoWzFdIHx8ICcwJykgKyAnLicgKyAobWF0Y2hbMl0gfHwgJzAnKSArICcuJyArIChtYXRjaFszXSB8fCAnMCcpKTsgXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zZW12ZXIvc2VtdmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xudmFyIGRlYnVnID0gcmVxdWlyZSggJ2RlYnVnJyApKCAnaTE4bi13cC1wbHVnaW4nICksXG5cdEplZCA9IHJlcXVpcmUoICdqZWQnICksXG5cdHNoYTEgPSByZXF1aXJlKCAnaGFzaC5qcy9saWIvaGFzaC9zaGEvMScgKSxcblx0RXZlbnRFbWl0dGVyID0gcmVxdWlyZSggJ2V2ZW50cycgKS5FdmVudEVtaXR0ZXIsXG5cdGludGVycG9sYXRlQ29tcG9uZW50cyA9IHJlcXVpcmUoICdpbnRlcnBvbGF0ZS1jb21wb25lbnRzJyApLmRlZmF1bHQsXG5cdExSVSA9IHJlcXVpcmUoICdscnUnICksXG5cdGFzc2lnbiA9IHJlcXVpcmUoICdsb2Rhc2guYXNzaWduJyApO1xuXG4vKipcbiAqIEludGVybmFsIGRlcGVuZGVuY2llc1xuICovXG52YXIgbnVtYmVyRm9ybWF0UEhQSlMgPSByZXF1aXJlKCAnLi9udW1iZXItZm9ybWF0JyApO1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG52YXIgZGVjaW1hbF9wb2ludF90cmFuc2xhdGlvbl9rZXkgPSAnbnVtYmVyX2Zvcm1hdF9kZWNpbWFscycsXG5cdHRob3VzYW5kc19zZXBfdHJhbnNsYXRpb25fa2V5ID0gJ251bWJlcl9mb3JtYXRfdGhvdXNhbmRzX3NlcCc7XG5cbnZhciB0cmFuc2xhdGlvbkxvb2t1cCA9IFtcblx0Ly8gQnkgZGVmYXVsdCBkb24ndCBtb2RpZnkgdGhlIG9wdGlvbnMgd2hlbiBsb29raW5nIHVwIHRyYW5zbGF0aW9ucy5cblx0ZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH1cbl07XG5cbnZhciBoYXNoQ2FjaGUgPSB7fTtcblxuLy8gcmFpc2UgYSBjb25zb2xlIHdhcm5pbmdcbmZ1bmN0aW9uIHdhcm4oKSB7XG5cdGlmICggISBJMThOLnRocm93RXJyb3JzICkge1xuXHRcdHJldHVybjtcblx0fVxuXHRpZiAoICd1bmRlZmluZWQnICE9PSB0eXBlb2Ygd2luZG93ICYmIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2Fybi5hcHBseSggd2luZG93LmNvbnNvbGUsIGFyZ3VtZW50cyApO1xuXHR9XG59XG5cbi8vIHR1cm5zIEZ1bmN0aW9uLmFyZ3VtZW50cyBpbnRvIGFuIGFycmF5XG5mdW5jdGlvbiBzaW1wbGVBcmd1bWVudHMoIGFyZ3MgKSB7XG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJncyApO1xufVxuXG4vKipcbiAqIENvZXJjZSB0aGUgcG9zc2libGUgYXJndW1lbnRzIGFuZCBub3JtYWxpemUgdG8gYSBzaW5nbGUgb2JqZWN0XG4gKiBAcGFyYW0gIHthcmd1bWVudHN9IGFyZ3MgLSBhcmd1bWVudHMgcGFzc2VkIGluIGZyb20gYHRyYW5zbGF0ZSgpYFxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIC0gYSBzaW5nbGUgb2JqZWN0IGRlc2NyaWJpbmcgdHJhbnNsYXRpb24gbmVlZHNcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplVHJhbnNsYXRlQXJndW1lbnRzKCBhcmdzICkge1xuXHR2YXIgb3JpZ2luYWwgPSBhcmdzWyAwIF0sXG5cdFx0b3B0aW9ucyA9IHt9LFxuXHRcdGk7XG5cblx0Ly8gd2FybiBhYm91dCBvbGRlciBkZXByZWNhdGVkIHN5bnRheFxuXHRpZiAoIHR5cGVvZiBvcmlnaW5hbCAhPT0gJ3N0cmluZycgfHwgYXJncy5sZW5ndGggPiAzIHx8ICggYXJncy5sZW5ndGggPiAyICYmIHR5cGVvZiBhcmdzWyAxIF0gPT09ICdvYmplY3QnICYmIHR5cGVvZiBhcmdzWyAyIF0gPT09ICdvYmplY3QnICkgKSB7XG5cdFx0d2FybiggJ0RlcHJlY2F0ZWQgSW52b2NhdGlvbjogYHRyYW5zbGF0ZSgpYCBhY2NlcHRzICggc3RyaW5nLCBbc3RyaW5nXSwgW29iamVjdF0gKS4gVGhlc2UgYXJndW1lbnRzIHBhc3NlZDonLCBzaW1wbGVBcmd1bWVudHMoIGFyZ3MgKSwgJy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wZW50YXRvbmljZnVuay9pMThuLXdwLXBsdWdpbiN0cmFuc2xhdGUtbWV0aG9kJyApO1xuXHR9XG5cdGlmICggYXJncy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIG9yaWdpbmFsID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYXJnc1sgMSBdID09PSAnc3RyaW5nJyApIHtcblx0XHR3YXJuKCAnSW52YWxpZCBJbnZvY2F0aW9uOiBgdHJhbnNsYXRlKClgIHJlcXVpcmVzIGFuIG9wdGlvbnMgb2JqZWN0IGZvciBwbHVyYWwgdHJhbnNsYXRpb25zLCBidXQgcGFzc2VkOicsIHNpbXBsZUFyZ3VtZW50cyggYXJncyApICk7XG5cdH1cblxuXHQvLyBvcHRpb25zIGNvdWxkIGJlIGluIHBvc2l0aW9uIDAsIDEsIG9yIDJcblx0Ly8gc2VuZGluZyBvcHRpb25zIGFzIHRoZSBmaXJzdCBvYmplY3QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCByYWlzZSBhIHdhcm5pbmdcblx0Zm9yICggaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrICkge1xuXHRcdGlmICggdHlwZW9mIGFyZ3NbIGkgXSA9PT0gJ29iamVjdCcgKSB7XG5cdFx0XHRvcHRpb25zID0gYXJnc1sgaSBdO1xuXHRcdH1cblx0fVxuXG5cdC8vIGBvcmlnaW5hbGAgY2FuIGJlIHBhc3NlZCBhcyBmaXJzdCBwYXJhbWV0ZXIgb3IgYXMgcGFydCBvZiB0aGUgb3B0aW9ucyBvYmplY3Rcblx0Ly8gdGhvdWdoIHBhc3Npbmcgb3JpZ2luYWwgYXMgcGFydCBvZiB0aGUgb3B0aW9ucyBpcyBhIGRlcHJlY2F0ZWQgYXBwcm9hY2ggYW5kIHdpbGwgYmUgcmVtb3ZlZFxuXHRpZiAoIHR5cGVvZiBvcmlnaW5hbCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0b3B0aW9ucy5vcmlnaW5hbCA9IG9yaWdpbmFsO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2Ygb3B0aW9ucy5vcmlnaW5hbCA9PT0gJ29iamVjdCcgKSB7XG5cdFx0b3B0aW9ucy5wbHVyYWwgPSBvcHRpb25zLm9yaWdpbmFsLnBsdXJhbDtcblx0XHRvcHRpb25zLmNvdW50ID0gb3B0aW9ucy5vcmlnaW5hbC5jb3VudDtcblx0XHRvcHRpb25zLm9yaWdpbmFsID0gb3B0aW9ucy5vcmlnaW5hbC5zaW5nbGU7XG5cdH1cblx0aWYgKCB0eXBlb2YgYXJnc1sgMSBdID09PSAnc3RyaW5nJyApIHtcblx0XHRvcHRpb25zLnBsdXJhbCA9IGFyZ3NbIDEgXTtcblx0fVxuXG5cdGlmICggdHlwZW9mIG9wdGlvbnMub3JpZ2luYWwgPT09ICd1bmRlZmluZWQnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggJ1RyYW5zbGF0ZSBjYWxsZWQgd2l0aG91dCBhIGBzdHJpbmdgIHZhbHVlIGFzIGZpcnN0IGFyZ3VtZW50LicgKTtcblx0fVxuXG5cdHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIFB1bGwgdGhlIHJpZ2h0IHNldCBvZiBhcmd1bWVudHMgZm9yIHRoZSBKZWQgbWV0aG9kXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGplZE1ldGhvZCBOYW1lIG9mIGplZCBnZXR0ZXh0LXN0eWxlIG1ldGhvZC4gW1NlZSBkb2NzXShodHRwOi8vc2xleGF4dG9uLmdpdGh1Yi5pby9KZWQvKVxuICogQHBhcmFtICB7W29iamVjdF19IHByb3BzICAgICBwcm9wZXJ0aWVzIHBhc3NlZCBpbnRvIGB0cmFuc2xhdGUoKWAgbWV0aG9kXG4gKiBAcmV0dXJuIHtbYXJyYXldfSAgICAgICAgICAgYXJyYXkgb2YgcHJvcGVydGllcyB0byBwYXNzIGludG8gZ2V0dGV4dC1zdHlsZSBtZXRob2RcbiAqL1xuZnVuY3Rpb24gZ2V0SmVkQXJncyggamVkTWV0aG9kLCBwcm9wcyApIHtcblx0c3dpdGNoICggamVkTWV0aG9kICkge1xuXHRcdGNhc2UgJ2dldHRleHQnOlxuXHRcdFx0cmV0dXJuIFsgcHJvcHMub3JpZ2luYWwgXTtcblx0XHRjYXNlICduZ2V0dGV4dCc6XG5cdFx0XHRyZXR1cm4gWyBwcm9wcy5vcmlnaW5hbCwgcHJvcHMucGx1cmFsLCBwcm9wcy5jb3VudCBdO1xuXHRcdGNhc2UgJ25wZ2V0dGV4dCc6XG5cdFx0XHRyZXR1cm4gWyBwcm9wcy5jb250ZXh0LCBwcm9wcy5vcmlnaW5hbCwgcHJvcHMucGx1cmFsLCBwcm9wcy5jb3VudCBdO1xuXHRcdGNhc2UgJ3BnZXR0ZXh0Jzpcblx0XHRcdHJldHVybiBbIHByb3BzLmNvbnRleHQsIHByb3BzLm9yaWdpbmFsIF07XG5cdH1cblxuXHRyZXR1cm4gW107XG59XG5cbi8qKlxuICogVGFrZXMgdHJhbnNsYXRlIG9wdGlvbnMgb2JqZWN0IGFuZCBjb2VyY2VzIHRvIGEgSmVkIHJlcXVlc3QgdG8gcmV0cmlldmUgdHJhbnNsYXRpb25cbiAqIEBwYXJhbSAge29iamVjdH0gamVkICAgICAtIGplZCBkYXRhIG9iamVjdFxuICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIC0gb2JqZWN0IGRlc2NyaWJpbmcgdHJhbnNsYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAtIHRoZSByZXR1cm5lZCB0cmFuc2xhdGlvbiBmcm9tIEplZFxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGlvbkZyb21KZWQoIGplZCwgb3B0aW9ucyApIHtcblx0dmFyIGplZE1ldGhvZCA9ICdnZXR0ZXh0Jyxcblx0XHRqZWRBcmdzO1xuXG5cdGlmICggb3B0aW9ucy5jb250ZXh0ICkge1xuXHRcdGplZE1ldGhvZCA9ICdwJyArIGplZE1ldGhvZDtcblx0fVxuXG5cdGlmICggdHlwZW9mIG9wdGlvbnMub3JpZ2luYWwgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBvcHRpb25zLnBsdXJhbCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0amVkTWV0aG9kID0gJ24nICsgamVkTWV0aG9kO1xuXHR9XG5cblx0amVkQXJncyA9IGdldEplZEFyZ3MoIGplZE1ldGhvZCwgb3B0aW9ucyApO1xuXG5cdHJldHVybiBqZWRbIGplZE1ldGhvZCBdLmFwcGx5KCBqZWQsIGplZEFyZ3MgKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24oIGkxOG4sIG9wdGlvbnMgKSB7XG5cdHZhciBpLCBsb29rdXA7XG5cblx0Zm9yICggaSA9IHRyYW5zbGF0aW9uTG9va3VwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuXHRcdGxvb2t1cCA9IHRyYW5zbGF0aW9uTG9va3VwWyBpIF0oIGFzc2lnbigge30sIG9wdGlvbnMgKSApO1xuXHRcdC8vIE9ubHkgZ2V0IHRoZSB0cmFuc2xhdGlvbiBmcm9tIGplZCBpZiBpdCBleGlzdHMuXG5cdFx0aWYgKCBpMThuLnN0YXRlLmxvY2FsZVsgbG9va3VwLm9yaWdpbmFsIF0gKSB7XG5cdFx0XHRyZXR1cm4gZ2V0VHJhbnNsYXRpb25Gcm9tSmVkKCBpMThuLnN0YXRlLmplZCwgbG9va3VwICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG51bGw7XG59XG5cblxuZnVuY3Rpb24gSTE4TigpIHtcblx0aWYoICEgKCB0aGlzIGluc3RhbmNlb2YgSTE4TiApICkge1xuXHRcdHJldHVybiBuZXcgSTE4TigpO1xuXHR9XG5cdHRoaXMuZGVmYXVsdExvY2FsZVNsdWcgPSAnZW4nO1xuXHR0aGlzLnN0YXRlID0ge1xuXHRcdG51bWJlckZvcm1hdFNldHRpbmdzOiB7fSxcblx0XHRqZWQ6IHVuZGVmaW5lZCxcblx0XHRsb2NhbGU6IHVuZGVmaW5lZCxcblx0XHRsb2NhbGVTbHVnOiB1bmRlZmluZWQsXG5cdFx0dHJhbnNsYXRpb25zOiBMUlUoIHsgbWF4OiAxMDAgfSApXG5cdH07XG5cdHRoaXMuY29tcG9uZW50VXBkYXRlSG9va3MgPSBbXTtcblx0dGhpcy50cmFuc2xhdGVIb29rcyA9IFtdO1xuXHR0aGlzLnN0YXRlT2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cdC8vIEJlY2F1c2UgdGhlIGhpZ2hlci1vcmRlciBjb21wb25lbnQgY2FuIHdyYXAgYSB0b24gb2YgUmVhY3QgY29tcG9uZW50cyxcblx0Ly8gd2UgbmVlZCB0byBidW1wIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIHRvIGluZmluaXR5IGFuZCBiZXlvbmRcblx0Ly8gRklYTUU6IHN0aWxsIHZhbGlkP1xuXHR0aGlzLnN0YXRlT2JzZXJ2ZXIuc2V0TWF4TGlzdGVuZXJzKCAwICk7XG5cdC8vIGRlZmF1bHQgY29uZmlndXJhdGlvblxuXHR0aGlzLmNvbmZpZ3VyZSgpO1xufVxuXG5JMThOLnRocm93RXJyb3JzID0gZmFsc2U7XG5cbi8qKlxuICogRm9ybWF0cyBudW1iZXJzIHVzaW5nIGxvY2FsZSBzZXR0aW5ncyBhbmQvb3IgcGFzc2VkIG9wdGlvbnNcbiAqIEBwYXJhbSAge1N0cmluZ3xOdW1iZXJ8SW50fSAgbnVtYmVyIHRvIGZvcm1hdCAocmVxdWlyZWQpXG4gKiBAcGFyYW0gIHtJbnR8b2JqZWN0fSBvcHRpb25zICBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb3Igb3B0aW9ucyBvYmplY3QgKG9wdGlvbmFsKVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgIEZvcm1hdHRlZCBudW1iZXIgYXMgc3RyaW5nXG4gKi9cbkkxOE4ucHJvdG90eXBlLm51bWJlckZvcm1hdCA9IGZ1bmN0aW9uKCBudW1iZXIgKSB7XG5cdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAxIF0gfHwge30sXG5cdFx0ZGVjaW1hbHMgPSAoIHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJyApID8gb3B0aW9ucyA6IG9wdGlvbnMuZGVjaW1hbHMgfHwgMCxcblx0XHRkZWNQb2ludCA9IG9wdGlvbnMuZGVjUG9pbnQgfHwgdGhpcy5zdGF0ZS5udW1iZXJGb3JtYXRTZXR0aW5ncy5kZWNpbWFsX3BvaW50IHx8ICcuJyxcblx0XHR0aG91c2FuZHNTZXAgPSBvcHRpb25zLnRob3VzYW5kc1NlcCB8fCB0aGlzLnN0YXRlLm51bWJlckZvcm1hdFNldHRpbmdzLnRob3VzYW5kc19zZXAgfHwgJywnO1xuXG5cdHJldHVybiBudW1iZXJGb3JtYXRQSFBKUyggbnVtYmVyLCBkZWNpbWFscywgZGVjUG9pbnQsIHRob3VzYW5kc1NlcCApO1xufTtcblxuSTE4Ti5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdGFzc2lnbiggdGhpcywgb3B0aW9ucyB8fCB7fSApO1xuXHR0aGlzLnNldExvY2FsZSgpO1xufTtcblxuSTE4Ti5wcm90b3R5cGUuc2V0TG9jYWxlID0gZnVuY3Rpb24oIGxvY2FsZURhdGEgKSB7XG5cdGlmICggbG9jYWxlRGF0YSAmJiBsb2NhbGVEYXRhWyAnJyBdICYmIGxvY2FsZURhdGFbICcnIF1bICdrZXktaGFzaCcgXSApIHtcblx0XHR2YXIgaGFzaExlbmd0aCwgbWluSGFzaExlbmd0aCwgbWF4SGFzaExlbmd0aCwga2V5SGFzaCA9IGxvY2FsZURhdGFbICcnIF1bICdrZXktaGFzaCcgXTtcblxuXHRcdHZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbiggc3RyaW5nLCBoYXNoTGVuZ3RoICkge1xuXHRcdFx0Y29uc3QgbG9va3VwUHJlZml4ID0gaGFzaExlbmd0aCA9PT0gZmFsc2UgPyAnJyA6IFN0cmluZyggaGFzaExlbmd0aCApO1xuXHRcdFx0aWYgKCB0eXBlb2YgaGFzaENhY2hlWyBsb29rdXBQcmVmaXggKyBzdHJpbmcgXSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRcdHJldHVybiBoYXNoQ2FjaGVbIGxvb2t1cFByZWZpeCArIHN0cmluZyBdO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGhhc2ggPSBzaGExKCkudXBkYXRlKCBzdHJpbmcgKS5kaWdlc3QoJ2hleCcpO1xuXG5cdFx0XHRpZiAoIGhhc2hMZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiBoYXNoQ2FjaGVbIGxvb2t1cFByZWZpeCArIHN0cmluZyBdID0gaGFzaC5zdWJzdHIoIDAsIGhhc2hMZW5ndGggKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGhhc2hDYWNoZVsgbG9va3VwUHJlZml4ICsgc3RyaW5nIF0gPSBoYXNoO1xuXHRcdH07XG5cblx0XHR2YXIgZ2VuZXJhdGVMb29rdXAgPSBmdW5jdGlvbiggaGFzaExlbmd0aCApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmNvbnRleHQgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5vcmlnaW5hbCA9IHRyYW5zZm9ybSggb3B0aW9ucy5jb250ZXh0ICsgU3RyaW5nLmZyb21DaGFyQ29kZSggNCApICsgb3B0aW9ucy5vcmlnaW5hbCwgaGFzaExlbmd0aCApO1xuXHRcdFx0XHRcdGRlbGV0ZSBvcHRpb25zLmNvbnRleHQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5vcmlnaW5hbCA9IHRyYW5zZm9ybSggb3B0aW9ucy5vcmlnaW5hbCwgaGFzaExlbmd0aCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG9wdGlvbnM7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGlmICgga2V5SGFzaC5zdWJzdHIoIDAsIDQgKSA9PT0gJ3NoYTEnICkge1xuXHRcdFx0aWYgKCBrZXlIYXNoLmxlbmd0aCA9PT0gNCApIHtcblx0XHRcdFx0dHJhbnNsYXRpb25Mb29rdXAucHVzaCggZ2VuZXJhdGVMb29rdXAoIGZhbHNlICkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB2YXJpYWJsZUhhc2hMZW5ndGhQb3MgPSBrZXlIYXNoLnN1YnN0ciggNSApLmluZGV4T2YoICctJyApO1xuXHRcdFx0XHRpZiAoIHZhcmlhYmxlSGFzaExlbmd0aFBvcyA8IDAgKSB7XG5cdFx0XHRcdFx0aGFzaExlbmd0aCA9IE51bWJlcigga2V5SGFzaC5zdWJzdHIoIDUgKSApO1xuXHRcdFx0XHRcdHRyYW5zbGF0aW9uTG9va3VwLnB1c2goIGdlbmVyYXRlTG9va3VwKCBoYXNoTGVuZ3RoICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtaW5IYXNoTGVuZ3RoID0gTnVtYmVyKCBrZXlIYXNoLnN1YnN0ciggNSwgdmFyaWFibGVIYXNoTGVuZ3RoUG9zICkgKTtcblx0XHRcdFx0XHRtYXhIYXNoTGVuZ3RoID0gTnVtYmVyKCBrZXlIYXNoLnN1YnN0ciggNiArIHZhcmlhYmxlSGFzaExlbmd0aFBvcyApICk7XG5cblx0XHRcdFx0XHRmb3IgKCBoYXNoTGVuZ3RoID0gbWluSGFzaExlbmd0aDsgaGFzaExlbmd0aCA8PSBtYXhIYXNoTGVuZ3RoOyBoYXNoTGVuZ3RoKysgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc2xhdGlvbkxvb2t1cC5wdXNoKCBnZW5lcmF0ZUxvb2t1cCggaGFzaExlbmd0aCApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gaWYgbG9jYWxlRGF0YSBpcyBub3QgZ2l2ZW4sIGFzc3VtZXMgZGVmYXVsdCBsb2NhbGUgYW5kIHJlc2V0XG5cdGlmICggISBsb2NhbGVEYXRhIHx8ICEgbG9jYWxlRGF0YVsgJycgXS5sb2NhbGVTbHVnICkge1xuXHRcdHRoaXMuc3RhdGUubG9jYWxlID0geyAnJzogeyBsb2NhbGVTbHVnOiB0aGlzLmRlZmF1bHRMb2NhbGVTbHVnIH0gfTtcblx0fSBlbHNlIGlmICggbG9jYWxlRGF0YVsgJycgXS5sb2NhbGVTbHVnID09PSB0aGlzLnN0YXRlLmxvY2FsZVNsdWcgKSB7XG5cdFx0Ly8gRXhpdCBpZiBzYW1lIGRhdGEgYXMgY3VycmVudCAoY29tcGFyaW5nIHJlZmVyZW5jZXMgb25seSlcblx0XHRpZiAoIGxvY2FsZURhdGEgPT09IHRoaXMuc3RhdGUubG9jYWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIG1lcmdlIG5ldyBkYXRhIGludG8gZXhpc3Rpbmcgb25lXG5cdFx0YXNzaWduKCB0aGlzLnN0YXRlLmxvY2FsZSwgbG9jYWxlRGF0YSApO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuc3RhdGUubG9jYWxlID0gYXNzaWduKCB7fSwgbG9jYWxlRGF0YSApO1xuXHR9XG5cblx0dGhpcy5zdGF0ZS5sb2NhbGVTbHVnID0gdGhpcy5zdGF0ZS5sb2NhbGVbICcnIF0ubG9jYWxlU2x1ZztcblxuXHR0aGlzLnN0YXRlLmplZCA9IG5ldyBKZWQoIHtcblx0XHRsb2NhbGVfZGF0YToge1xuXHRcdFx0bWVzc2FnZXM6IHRoaXMuc3RhdGUubG9jYWxlXG5cdFx0fVxuXHR9ICk7XG5cblxuXHQvLyBVcGRhdGVzIG51bWJlckZvcm1hdCBwcmVmZXJlbmNlcyB3aXRoIHNldHRpbmdzIGZyb20gdHJhbnNsYXRpb25zXG5cdHRoaXMuc3RhdGUubnVtYmVyRm9ybWF0U2V0dGluZ3MuZGVjaW1hbF9wb2ludCA9IGdldFRyYW5zbGF0aW9uRnJvbUplZChcblx0XHR0aGlzLnN0YXRlLmplZCxcblx0XHRub3JtYWxpemVUcmFuc2xhdGVBcmd1bWVudHMoIFsgZGVjaW1hbF9wb2ludF90cmFuc2xhdGlvbl9rZXkgXSApXG5cdCk7XG5cdHRoaXMuc3RhdGUubnVtYmVyRm9ybWF0U2V0dGluZ3MudGhvdXNhbmRzX3NlcCA9IGdldFRyYW5zbGF0aW9uRnJvbUplZChcblx0XHR0aGlzLnN0YXRlLmplZCxcblx0XHRub3JtYWxpemVUcmFuc2xhdGVBcmd1bWVudHMoIFsgdGhvdXNhbmRzX3NlcF90cmFuc2xhdGlvbl9rZXkgXSApXG5cdCk7XG5cblx0Ly8gSWYgdHJhbnNsYXRpb24gaXNuJ3Qgc2V0LCBkZWZpbmUgZGVmYXVsdHMuXG5cdGlmICggdGhpcy5zdGF0ZS5udW1iZXJGb3JtYXRTZXR0aW5ncy5kZWNpbWFsX3BvaW50ID09PSBkZWNpbWFsX3BvaW50X3RyYW5zbGF0aW9uX2tleSApIHtcblx0XHR0aGlzLnN0YXRlLm51bWJlckZvcm1hdFNldHRpbmdzLmRlY2ltYWxfcG9pbnQgPSAnLic7XG5cdH1cblxuXHRpZiAoIHRoaXMuc3RhdGUubnVtYmVyRm9ybWF0U2V0dGluZ3MudGhvdXNhbmRzX3NlcCA9PT0gdGhvdXNhbmRzX3NlcF90cmFuc2xhdGlvbl9rZXkgKSB7XG5cdFx0dGhpcy5zdGF0ZS5udW1iZXJGb3JtYXRTZXR0aW5ncy50aG91c2FuZHNfc2VwID0gJywnO1xuXHR9XG5cblx0dGhpcy5zdGF0ZS50cmFuc2xhdGlvbnMuY2xlYXIoKTtcblx0dGhpcy5zdGF0ZU9ic2VydmVyLmVtaXQoICdjaGFuZ2UnICk7XG59O1xuXG5JMThOLnByb3RvdHlwZS5nZXRMb2NhbGUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc3RhdGUubG9jYWxlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgbG9jYWxlIHNsdWcuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudGx5IGxvYWRlZCBsb2NhbGVcbiAqKi9cbkkxOE4ucHJvdG90eXBlLmdldExvY2FsZVNsdWcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc3RhdGUubG9jYWxlU2x1Zztcbn07XG5cblxuLyoqXG4gKiBBZGRzIG5ldyB0cmFuc2xhdGlvbnMgdG8gdGhlIGxvY2FsZSBkYXRhLCBvdmVyd3JpdGluZyBhbnkgZXhpc3RpbmcgdHJhbnNsYXRpb25zIHdpdGggYSBtYXRjaGluZyBrZXlcbiAqKi9cbkkxOE4ucHJvdG90eXBlLmFkZFRyYW5zbGF0aW9ucyA9IGZ1bmN0aW9uKCBsb2NhbGVEYXRhICkge1xuXHRmb3IgKCB2YXIgcHJvcCBpbiBsb2NhbGVEYXRhICkge1xuXHRcdGlmICggcHJvcCAhPT0gJycgKSB7XG5cdFx0XHR0aGlzLnN0YXRlLmplZC5vcHRpb25zLmxvY2FsZV9kYXRhLm1lc3NhZ2VzW3Byb3BdID0gbG9jYWxlRGF0YVtwcm9wXTtcblx0XHR9XG5cdH1cblxuXHR0aGlzLnN0YXRlLnRyYW5zbGF0aW9ucy5jbGVhcigpO1xuXHR0aGlzLnN0YXRlT2JzZXJ2ZXIuZW1pdCggJ2NoYW5nZScgKTtcbn07XG5cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gb3JpZ2luYWwgaGFzIGEgdHJhbnNsYXRpb24uIFBhcmFtZXRlcnMgYXJlIHRoZSBzYW1lIGFzIGZvciB0cmFuc2xhdGUoKS5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG9yaWdpbmFsICB0aGUgc3RyaW5nIHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtICB7c3RyaW5nfSBwbHVyYWwgICAgdGhlIHBsdXJhbCBzdHJpbmcgdG8gdHJhbnNsYXRlIChpZiBhcHBsaWNhYmxlKSwgb3JpZ2luYWwgdXNlZCBhcyBzaW5ndWxhclxuICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zICAgcHJvcGVydGllcyBkZXNjcmliaW5nIHRyYW5zbGF0aW9uIHJlcXVpcmVtZW50cyBmb3IgZ2l2ZW4gdGV4dFxuICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciBhIHRyYW5zbGF0aW9uIGV4aXN0c1xuICovXG5JMThOLnByb3RvdHlwZS5oYXNUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gISEgZ2V0VHJhbnNsYXRpb24oIHRoaXMsIG5vcm1hbGl6ZVRyYW5zbGF0ZUFyZ3VtZW50cyggYXJndW1lbnRzICkgKTtcbn1cblxuLyoqXG4gKiBFeHBvc2VzIHNpbmdsZSB0cmFuc2xhdGlvbiBtZXRob2QsIHdoaWNoIGlzIGNvbnZlcnRlZCBpbnRvIGl0cyByZXNwZWN0aXZlIEplZCBtZXRob2QuXG4gKiBTZWUgc2libGluZyBSRUFETUVcbiAqIEBwYXJhbSAge3N0cmluZ30gb3JpZ2luYWwgIHRoZSBzdHJpbmcgdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBsdXJhbCAgICB0aGUgcGx1cmFsIHN0cmluZyB0byB0cmFuc2xhdGUgKGlmIGFwcGxpY2FibGUpLCBvcmlnaW5hbCB1c2VkIGFzIHNpbmd1bGFyXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgICBwcm9wZXJ0aWVzIGRlc2NyaWJpbmcgdHJhbnNsYXRpb24gcmVxdWlyZW1lbnRzIGZvciBnaXZlbiB0ZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd8UmVhY3QtY29tcG9uZW50c30gdHJhbnNsYXRlZCB0ZXh0IG9yIGFuIG9iamVjdCBjb250YWluaW5nIFJlYWN0IGNoaWxkcmVuIHRoYXQgY2FuIGJlIGluc2VydGVkIGludG8gYSBwYXJlbnQgY29tcG9uZW50XG4gKi9cbkkxOE4ucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgdHJhbnNsYXRpb24sIHNwcmludGZBcmdzLCBlcnJvck1ldGhvZCwgb3B0aW9uc1N0cmluZywgY2FjaGVhYmxlO1xuXG5cdG9wdGlvbnMgPSBub3JtYWxpemVUcmFuc2xhdGVBcmd1bWVudHMoIGFyZ3VtZW50cyApO1xuXG5cdGNhY2hlYWJsZSA9ICEgb3B0aW9ucy5jb21wb25lbnRzO1xuXHRpZiAoIGNhY2hlYWJsZSApIHtcblx0XHQvLyBTYWZlIEpTT04gc3RyaW5naWZpY2F0aW9uIGhlcmUgdG8gY2F0Y2ggQ2lyY3VsYXIgSlNPTiBlcnJvclxuXHRcdC8vIGNhdXNlZCBieSBwYXNzaW5nIGEgUmVhY3QgY29tcG9uZW50IGludG8gYXJncyB3aGVyZSBvbmx5IHNjYWxhcnMgYXJlIGFsbG93ZWRcblx0XHR0cnkge1xuXHRcdFx0b3B0aW9uc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KCBvcHRpb25zICk7XG5cdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRjYWNoZWFibGUgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnNTdHJpbmcgKSB7XG5cdFx0XHR0cmFuc2xhdGlvbiA9IHRoaXMuc3RhdGUudHJhbnNsYXRpb25zLmdldCggb3B0aW9uc1N0cmluZyApO1xuXHRcdFx0Ly8gUmV0dXJuIHRoZSBjYWNoZWQgdHJhbnNsYXRpb24uXG5cdFx0XHRpZiAoIHRyYW5zbGF0aW9uICkge1xuXHRcdFx0XHRyZXR1cm4gdHJhbnNsYXRpb247XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbiggdGhpcywgb3B0aW9ucyApO1xuXHRpZiAoICEgdHJhbnNsYXRpb24gKSB7XG5cdFx0Ly8gVGhpcyBwdXJwb3NlZnVsbHkgY2FsbHMgamVkIGZvciBhIGNhc2Ugd2hlcmUgdGhlcmUgaXMgbm8gdHJhbnNsYXRpb24sXG5cdFx0Ly8gc28gdGhhdCBqZWQgZ2l2ZXMgdXMgdGhlIGV4cGVjdGVkIG9iamVjdCB3aXRoIEVuZ2xpc2ggdGV4dC5cblx0XHR0cmFuc2xhdGlvbiA9IGdldFRyYW5zbGF0aW9uRnJvbUplZCggdGhpcy5zdGF0ZS5qZWQsIG9wdGlvbnMgKTtcblx0fVxuXG5cdC8vIGhhbmRsZSBhbnkgc3RyaW5nIHN1YnN0aXR1dGlvblxuXHRpZiAoIG9wdGlvbnMuYXJncyApIHtcblx0XHRzcHJpbnRmQXJncyA9ICggQXJyYXkuaXNBcnJheSggb3B0aW9ucy5hcmdzICkgKSA/IG9wdGlvbnMuYXJncy5zbGljZSggMCApIDogWyBvcHRpb25zLmFyZ3MgXTtcblx0XHRzcHJpbnRmQXJncy51bnNoaWZ0KCB0cmFuc2xhdGlvbiApO1xuXHRcdHRyeSB7XG5cdFx0XHR0cmFuc2xhdGlvbiA9IEplZC5zcHJpbnRmLmFwcGx5KCBKZWQsIHNwcmludGZBcmdzICk7XG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXHRcdFx0aWYgKCAhIHdpbmRvdyB8fCAhIHdpbmRvdy5jb25zb2xlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRlcnJvck1ldGhvZCA9IHRoaXMudGhyb3dFcnJvcnMgPyAnZXJyb3InIDogJ3dhcm4nO1xuXHRcdFx0aWYgKCB0eXBlb2YgZXJyb3IgIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHR3aW5kb3cuY29uc29sZVsgZXJyb3JNZXRob2QgXSggZXJyb3IgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvdy5jb25zb2xlWyBlcnJvck1ldGhvZCBdKCAnaTE4biBzcHJpbnRmIGVycm9yOicsIHNwcmludGZBcmdzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gaW50ZXJwb2xhdGUgYW55IGNvbXBvbmVudHNcblx0aWYgKCBvcHRpb25zLmNvbXBvbmVudHMgKSB7XG5cdFx0dHJhbnNsYXRpb24gPSBpbnRlcnBvbGF0ZUNvbXBvbmVudHMoIHtcblx0XHRcdG1peGVkU3RyaW5nOiB0cmFuc2xhdGlvbixcblx0XHRcdGNvbXBvbmVudHM6IG9wdGlvbnMuY29tcG9uZW50cyxcblx0XHRcdHRocm93RXJyb3JzOiB0aGlzLnRocm93RXJyb3JzXG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gcnVuIGFueSBuZWNlc3NhcnkgaG9va3Ncblx0dGhpcy50cmFuc2xhdGVIb29rcy5mb3JFYWNoKCBmdW5jdGlvbiggaG9vayApIHtcblx0XHR0cmFuc2xhdGlvbiA9IGhvb2soIHRyYW5zbGF0aW9uLCBvcHRpb25zICk7XG5cdH0gKTtcblxuXHRpZiAoIGNhY2hlYWJsZSApIHtcblx0XHR0aGlzLnN0YXRlLnRyYW5zbGF0aW9ucy5zZXQoIG9wdGlvbnNTdHJpbmcsIHRyYW5zbGF0aW9uICk7XG5cdH1cblxuXHRyZXR1cm4gdHJhbnNsYXRpb247XG59O1xuXG4vKipcbiAqIENhdXNlcyBpMThuIHRvIHJlLXJlbmRlciBhbGwgdHJhbnNsYXRpb25zLlxuICpcbiAqIFRoaXMgY2FuIGJlIG5lY2Vzc2FyeSBpZiBhbiBleHRlbnNpb24gbWFrZXMgY2hhbmdlcyB0aGF0IGkxOG4gaXMgdW5hd2FyZSBvZlxuICogYW5kIG5lZWRzIHRob3NlIGNoYW5nZXMgbWFuaWZlc3RlZCBpbW1lZGlhdGVseSAoZS5nLiBhZGRpbmcgYW4gaW1wb3J0YW50XG4gKiB0cmFuc2xhdGlvbiBob29rLCBvciBtb2RpZnlpbmcgdGhlIGJlaGF2aW91ciBvZiBhbiBleGlzdGluZyBob29rKS5cbiAqXG4gKiBJZiBhdCBhbGwgcG9zc2libGUsIHJlYWN0IGNvbXBvbmVudHMgc2hvdWxkIHRyeSB0byB1c2UgdGhlIG1vcmUgbG9jYWxcbiAqIHVwZGF0ZVRyYW5zbGF0aW9uKCkgZnVuY3Rpb24gaW5oZXJpdGVkIGZyb20gdGhlIG1peGluLlxuICovXG5JMThOLnByb3RvdHlwZS5yZVJlbmRlclRyYW5zbGF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXHRkZWJ1ZyggJ1JlLXJlbmRlcmluZyBhbGwgdHJhbnNsYXRpb25zIGR1ZSB0byBleHRlcm5hbCByZXF1ZXN0JyApO1xuXHR0aGlzLnN0YXRlLnRyYW5zbGF0aW9ucy5jbGVhcigpO1xuXHR0aGlzLnN0YXRlT2JzZXJ2ZXIuZW1pdCggJ2NoYW5nZScgKTtcbn07XG5cbkkxOE4ucHJvdG90eXBlLnJlZ2lzdGVyQ29tcG9uZW50VXBkYXRlSG9vayA9IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0dGhpcy5jb21wb25lbnRVcGRhdGVIb29rcy5wdXNoKCBjYWxsYmFjayApO1xufTtcblxuSTE4Ti5wcm90b3R5cGUucmVnaXN0ZXJUcmFuc2xhdGVIb29rID0gZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHR0aGlzLnRyYW5zbGF0ZUhvb2tzLnB1c2goIGNhbGxiYWNrICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEkxOE47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pMThuLXdwLXBsdWdpbi9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUiLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICcjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJyxcbiAgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLFxuICAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsXG4gICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJyxcbiAgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLFxuICAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsXG4gICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JyxcbiAgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLFxuICAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsXG4gICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJyxcbiAgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaTE4bi13cC1wbHVnaW4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICovXG5leHBvcnRzLmluc3RhbmNlcyA9IFtdO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICB2YXIgcHJldlRpbWU7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIGV4cG9ydHMuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIHZhciBpbmRleCA9IGV4cG9ydHMuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBpO1xuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBleHBvcnRzLmluc3RhbmNlc1tpXTtcbiAgICBpbnN0YW5jZS5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaTE4bi13cC1wbHVnaW4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiLyoqXG4gKiBAcHJlc2VydmUgamVkLmpzIHYwLjUuMGJldGEgaHR0cHM6Ly9naXRodWIuY29tL1NsZXhBeHRvbi9KZWRcbiAqL1xuLypcbi0tLS0tLS0tLS0tXG5BIGdldHRleHQgY29tcGF0aWJsZSBpMThuIGxpYnJhcnkgZm9yIG1vZGVybiBKYXZhU2NyaXB0IEFwcGxpY2F0aW9uc1xuXG5ieSBBbGV4IFNleHRvbiAtIEFsZXhTZXh0b24gW2F0XSBnbWFpbCAtIEBTbGV4QXh0b25cbldURlBMIGxpY2Vuc2UgZm9yIHVzZVxuRG9qbyBDTEEgZm9yIGNvbnRyaWJ1dGlvbnNcblxuSmVkIG9mZmVycyB0aGUgZW50aXJlIGFwcGxpY2FibGUgR05VIGdldHRleHQgc3BlYydkIHNldCBvZlxuZnVuY3Rpb25zLCBidXQgYWxzbyBvZmZlcnMgc29tZSBuaWNlciB3cmFwcGVycyBhcm91bmQgdGhlbS5cblRoZSBhcGkgZm9yIGdldHRleHQgd2FzIHdyaXR0ZW4gZm9yIGEgbGFuZ3VhZ2Ugd2l0aCBubyBmdW5jdGlvblxub3ZlcmxvYWRpbmcsIHNvIEplZCBhbGxvd3MgYSBsaXR0bGUgbW9yZSBvZiB0aGF0LlxuXG5NYW55IHRoYW5rcyB0byBKb3NodWEgSS4gTWlsbGVyIC0gdW5ydHN0QGNwYW4ub3JnIC0gd2hvIHdyb3RlXG5nZXR0ZXh0LmpzIGJhY2sgaW4gMjAwOC4gSSB3YXMgYWJsZSB0byB2ZXQgYSBsb3Qgb2YgbXkgaWRlYXNcbmFnYWluc3QgaGlzLiBJIGFsc28gbWFkZSBzdXJlIEplZCBwYXNzZWQgYWdhaW5zdCBoaXMgdGVzdHNcbmluIG9yZGVyIHRvIG9mZmVyIGVhc3kgdXBncmFkZXMgLS0ganNnZXR0ZXh0LmJlcmxpb3MuZGVcbiovXG4oZnVuY3Rpb24gKHJvb3QsIHVuZGVmKSB7XG5cbiAgLy8gU2V0IHVwIHNvbWUgdW5kZXJzY29yZS1zdHlsZSBmdW5jdGlvbnMsIGlmIHlvdSBhbHJlYWR5IGhhdmVcbiAgLy8gdW5kZXJzY29yZSwgZmVlbCBmcmVlIHRvIGRlbGV0ZSB0aGlzIHNlY3Rpb24sIGFuZCB1c2UgaXRcbiAgLy8gZGlyZWN0bHksIGhvd2V2ZXIsIHRoZSBhbW91bnQgb2YgZnVuY3Rpb25zIHVzZWQgZG9lc24ndFxuICAvLyB3YXJyYW50IGhhdmluZyB1bmRlcnNjb3JlIGFzIGEgZnVsbCBkZXBlbmRlbmN5LlxuICAvLyBVbmRlcnNjb3JlIDEuMy4wIHdhcyB1c2VkIHRvIHBvcnQgYW5kIGlzIGxpY2Vuc2VkXG4gIC8vIHVuZGVyIHRoZSBNSVQgTGljZW5zZSBieSBKZXJlbXkgQXNoa2VuYXMuXG4gIHZhciBBcnJheVByb3RvICAgID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgT2JqUHJvdG8gICAgICA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICBzbGljZSAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICAgIGhhc093blByb3AgICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIG5hdGl2ZUZvckVhY2ggPSBBcnJheVByb3RvLmZvckVhY2gsXG4gICAgICBicmVha2VyICAgICAgID0ge307XG5cbiAgLy8gV2UncmUgbm90IHVzaW5nIHRoZSBPT1Agc3R5bGUgXyBzbyB3ZSBkb24ndCBuZWVkIHRoZVxuICAvLyBleHRyYSBsZXZlbCBvZiBpbmRpcmVjdGlvbi4gVGhpcyBzdGlsbCBtZWFucyB0aGF0IHlvdVxuICAvLyBzdWIgb3V0IGZvciByZWFsIGBfYCB0aG91Z2guXG4gIHZhciBfID0ge1xuICAgIGZvckVhY2ggOiBmdW5jdGlvbiggb2JqLCBpdGVyYXRvciwgY29udGV4dCApIHtcbiAgICAgIHZhciBpLCBsLCBrZXk7XG4gICAgICBpZiAoIG9iaiA9PT0gbnVsbCApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIG5hdGl2ZUZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IG5hdGl2ZUZvckVhY2ggKSB7XG4gICAgICAgIG9iai5mb3JFYWNoKCBpdGVyYXRvciwgY29udGV4dCApO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoICkge1xuICAgICAgICBmb3IgKCBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG4gICAgICAgICAgaWYgKCBpIGluIG9iaiAmJiBpdGVyYXRvci5jYWxsKCBjb250ZXh0LCBvYmpbaV0sIGksIG9iaiApID09PSBicmVha2VyICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAoIGtleSBpbiBvYmopIHtcbiAgICAgICAgICBpZiAoIGhhc093blByb3AuY2FsbCggb2JqLCBrZXkgKSApIHtcbiAgICAgICAgICAgIGlmICggaXRlcmF0b3IuY2FsbCAoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqICkgPT09IGJyZWFrZXIgKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGV4dGVuZCA6IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICB0aGlzLmZvckVhY2goIHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApLCBmdW5jdGlvbiAoIHNvdXJjZSApIHtcbiAgICAgICAgZm9yICggdmFyIHByb3AgaW4gc291cmNlICkge1xuICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfTtcbiAgLy8gRU5EIE1pbmlhdHVyZSB1bmRlcnNjb3JlIGltcGxcblxuICAvLyBKZWQgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICB2YXIgSmVkID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xuICAgIC8vIFNvbWUgbWluaW1hbCBkZWZhdWx0c1xuICAgIHRoaXMuZGVmYXVsdHMgPSB7XG4gICAgICBcImxvY2FsZV9kYXRhXCIgOiB7XG4gICAgICAgIFwibWVzc2FnZXNcIiA6IHtcbiAgICAgICAgICBcIlwiIDoge1xuICAgICAgICAgICAgXCJkb21haW5cIiAgICAgICA6IFwibWVzc2FnZXNcIixcbiAgICAgICAgICAgIFwibGFuZ1wiICAgICAgICAgOiBcImVuXCIsXG4gICAgICAgICAgICBcInBsdXJhbF9mb3Jtc1wiIDogXCJucGx1cmFscz0yOyBwbHVyYWw9KG4gIT0gMSk7XCJcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVGhlcmUgYXJlIG5vIGRlZmF1bHQga2V5cywgdGhvdWdoXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBUaGUgZGVmYXVsdCBkb21haW4gaWYgb25lIGlzIG1pc3NpbmdcbiAgICAgIFwiZG9tYWluXCIgOiBcIm1lc3NhZ2VzXCIsXG4gICAgICAvLyBlbmFibGUgZGVidWcgbW9kZSB0byBsb2cgdW50cmFuc2xhdGVkIHN0cmluZ3MgdG8gdGhlIGNvbnNvbGVcbiAgICAgIFwiZGVidWdcIiA6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIE1peCBpbiB0aGUgc2VudCBvcHRpb25zIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKCB7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyApO1xuICAgIHRoaXMudGV4dGRvbWFpbiggdGhpcy5vcHRpb25zLmRvbWFpbiApO1xuXG4gICAgaWYgKCBvcHRpb25zLmRvbWFpbiAmJiAhIHRoaXMub3B0aW9ucy5sb2NhbGVfZGF0YVsgdGhpcy5vcHRpb25zLmRvbWFpbiBdICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0IGRvbWFpbiBzZXQgdG8gbm9uLWV4aXN0ZW50IGRvbWFpbjogYCcgKyBvcHRpb25zLmRvbWFpbiArICdgJyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoZSBnZXR0ZXh0IHNwZWMgc2V0cyB0aGlzIGNoYXJhY3RlciBhcyB0aGUgZGVmYXVsdFxuICAvLyBkZWxpbWl0ZXIgZm9yIGNvbnRleHQgbG9va3Vwcy5cbiAgLy8gZS5nLjogY29udGV4dFxcdTAwMDRrZXlcbiAgLy8gSWYgeW91ciB0cmFuc2xhdGlvbiBjb21wYW55IHVzZXMgc29tZXRoaW5nIGRpZmZlcmVudCxcbiAgLy8ganVzdCBjaGFuZ2UgdGhpcyBhdCBhbnkgdGltZSBhbmQgaXQgd2lsbCB1c2UgdGhhdCBpbnN0ZWFkLlxuICBKZWQuY29udGV4dF9kZWxpbWl0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCA0ICk7XG5cbiAgZnVuY3Rpb24gZ2V0UGx1cmFsRm9ybUZ1bmMgKCBwbHVyYWxfZm9ybV9zdHJpbmcgKSB7XG4gICAgcmV0dXJuIEplZC5QRi5jb21waWxlKCBwbHVyYWxfZm9ybV9zdHJpbmcgfHwgXCJucGx1cmFscz0yOyBwbHVyYWw9KG4gIT0gMSk7XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gQ2hhaW4oIGtleSwgaTE4biApe1xuICAgIHRoaXMuX2tleSA9IGtleTtcbiAgICB0aGlzLl9pMThuID0gaTE4bjtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIGNoYWluYWJsZSBhcGkgZm9yIGFkZGluZyBhcmdzIHByZXR0aWx5XG4gIF8uZXh0ZW5kKCBDaGFpbi5wcm90b3R5cGUsIHtcbiAgICBvbkRvbWFpbiA6IGZ1bmN0aW9uICggZG9tYWluICkge1xuICAgICAgdGhpcy5fZG9tYWluID0gZG9tYWluO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB3aXRoQ29udGV4dCA6IGZ1bmN0aW9uICggY29udGV4dCApIHtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBpZlBsdXJhbCA6IGZ1bmN0aW9uICggbnVtLCBwa2V5ICkge1xuICAgICAgdGhpcy5fdmFsID0gbnVtO1xuICAgICAgdGhpcy5fcGtleSA9IHBrZXk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGZldGNoIDogZnVuY3Rpb24gKCBzQXJyICkge1xuICAgICAgaWYgKCB7fS50b1N0cmluZy5jYWxsKCBzQXJyICkgIT0gJ1tvYmplY3QgQXJyYXldJyApIHtcbiAgICAgICAgc0FyciA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoIHNBcnIgJiYgc0Fyci5sZW5ndGggPyBKZWQuc3ByaW50ZiA6IGZ1bmN0aW9uKHgpeyByZXR1cm4geDsgfSApKFxuICAgICAgICB0aGlzLl9pMThuLmRjbnBnZXR0ZXh0KHRoaXMuX2RvbWFpbiwgdGhpcy5fY29udGV4dCwgdGhpcy5fa2V5LCB0aGlzLl9wa2V5LCB0aGlzLl92YWwpLFxuICAgICAgICBzQXJyXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQWRkIGZ1bmN0aW9ucyB0byB0aGUgSmVkIHByb3RvdHlwZS5cbiAgLy8gVGhlc2Ugd2lsbCBiZSB0aGUgZnVuY3Rpb25zIG9uIHRoZSBvYmplY3QgdGhhdCdzIHJldHVybmVkXG4gIC8vIGZyb20gY3JlYXRpbmcgYSBgbmV3IEplZCgpYFxuICAvLyBUaGVzZSBzZWVtIHJlZHVuZGFudCwgYnV0IHRoZXkgZ3ppcCBwcmV0dHkgd2VsbC5cbiAgXy5leHRlbmQoIEplZC5wcm90b3R5cGUsIHtcbiAgICAvLyBUaGUgc2V4aWVyIGFwaSBzdGFydCBwb2ludFxuICAgIHRyYW5zbGF0ZSA6IGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgcmV0dXJuIG5ldyBDaGFpbigga2V5LCB0aGlzICk7XG4gICAgfSxcblxuICAgIHRleHRkb21haW4gOiBmdW5jdGlvbiAoIGRvbWFpbiApIHtcbiAgICAgIGlmICggISBkb21haW4gKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0ZG9tYWluO1xuICAgICAgfVxuICAgICAgdGhpcy5fdGV4dGRvbWFpbiA9IGRvbWFpbjtcbiAgICB9LFxuXG4gICAgZ2V0dGV4dCA6IGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgcmV0dXJuIHRoaXMuZGNucGdldHRleHQuY2FsbCggdGhpcywgdW5kZWYsIHVuZGVmLCBrZXkgKTtcbiAgICB9LFxuXG4gICAgZGdldHRleHQgOiBmdW5jdGlvbiAoIGRvbWFpbiwga2V5ICkge1xuICAgICByZXR1cm4gdGhpcy5kY25wZ2V0dGV4dC5jYWxsKCB0aGlzLCBkb21haW4sIHVuZGVmLCBrZXkgKTtcbiAgICB9LFxuXG4gICAgZGNnZXR0ZXh0IDogZnVuY3Rpb24gKCBkb21haW4gLCBrZXkgLyosIGNhdGVnb3J5ICovICkge1xuICAgICAgLy8gSWdub3JlcyB0aGUgY2F0ZWdvcnkgYW55d2F5c1xuICAgICAgcmV0dXJuIHRoaXMuZGNucGdldHRleHQuY2FsbCggdGhpcywgZG9tYWluLCB1bmRlZiwga2V5ICk7XG4gICAgfSxcblxuICAgIG5nZXR0ZXh0IDogZnVuY3Rpb24gKCBza2V5LCBwa2V5LCB2YWwgKSB7XG4gICAgICByZXR1cm4gdGhpcy5kY25wZ2V0dGV4dC5jYWxsKCB0aGlzLCB1bmRlZiwgdW5kZWYsIHNrZXksIHBrZXksIHZhbCApO1xuICAgIH0sXG5cbiAgICBkbmdldHRleHQgOiBmdW5jdGlvbiAoIGRvbWFpbiwgc2tleSwgcGtleSwgdmFsICkge1xuICAgICAgcmV0dXJuIHRoaXMuZGNucGdldHRleHQuY2FsbCggdGhpcywgZG9tYWluLCB1bmRlZiwgc2tleSwgcGtleSwgdmFsICk7XG4gICAgfSxcblxuICAgIGRjbmdldHRleHQgOiBmdW5jdGlvbiAoIGRvbWFpbiwgc2tleSwgcGtleSwgdmFsLyosIGNhdGVnb3J5ICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5kY25wZ2V0dGV4dC5jYWxsKCB0aGlzLCBkb21haW4sIHVuZGVmLCBza2V5LCBwa2V5LCB2YWwgKTtcbiAgICB9LFxuXG4gICAgcGdldHRleHQgOiBmdW5jdGlvbiAoIGNvbnRleHQsIGtleSApIHtcbiAgICAgIHJldHVybiB0aGlzLmRjbnBnZXR0ZXh0LmNhbGwoIHRoaXMsIHVuZGVmLCBjb250ZXh0LCBrZXkgKTtcbiAgICB9LFxuXG4gICAgZHBnZXR0ZXh0IDogZnVuY3Rpb24gKCBkb21haW4sIGNvbnRleHQsIGtleSApIHtcbiAgICAgIHJldHVybiB0aGlzLmRjbnBnZXR0ZXh0LmNhbGwoIHRoaXMsIGRvbWFpbiwgY29udGV4dCwga2V5ICk7XG4gICAgfSxcblxuICAgIGRjcGdldHRleHQgOiBmdW5jdGlvbiAoIGRvbWFpbiwgY29udGV4dCwga2V5LyosIGNhdGVnb3J5ICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5kY25wZ2V0dGV4dC5jYWxsKCB0aGlzLCBkb21haW4sIGNvbnRleHQsIGtleSApO1xuICAgIH0sXG5cbiAgICBucGdldHRleHQgOiBmdW5jdGlvbiAoIGNvbnRleHQsIHNrZXksIHBrZXksIHZhbCApIHtcbiAgICAgIHJldHVybiB0aGlzLmRjbnBnZXR0ZXh0LmNhbGwoIHRoaXMsIHVuZGVmLCBjb250ZXh0LCBza2V5LCBwa2V5LCB2YWwgKTtcbiAgICB9LFxuXG4gICAgZG5wZ2V0dGV4dCA6IGZ1bmN0aW9uICggZG9tYWluLCBjb250ZXh0LCBza2V5LCBwa2V5LCB2YWwgKSB7XG4gICAgICByZXR1cm4gdGhpcy5kY25wZ2V0dGV4dC5jYWxsKCB0aGlzLCBkb21haW4sIGNvbnRleHQsIHNrZXksIHBrZXksIHZhbCApO1xuICAgIH0sXG5cbiAgICAvLyBUaGUgbW9zdCBmdWxseSBxdWFsaWZpZWQgZ2V0dGV4dCBmdW5jdGlvbi4gSXQgaGFzIGV2ZXJ5IG9wdGlvbi5cbiAgICAvLyBTaW5jZSBpdCBoYXMgZXZlcnkgb3B0aW9uLCB3ZSBjYW4gdXNlIGl0IGZyb20gZXZlcnkgb3RoZXIgbWV0aG9kLlxuICAgIC8vIFRoaXMgaXMgdGhlIGJyZWFkIGFuZCBidXR0ZXIuXG4gICAgLy8gVGVjaG5pY2FsbHkgdGhlcmUgc2hvdWxkIGJlIG9uZSBtb3JlIGFyZ3VtZW50IGluIHRoaXMgZnVuY3Rpb24gZm9yICdDYXRlZ29yeScsXG4gICAgLy8gYnV0IHNpbmNlIHdlIG5ldmVyIHVzZSBpdCwgd2UgbWlnaHQgYXMgd2VsbCBub3Qgd2FzdGUgdGhlIGJ5dGVzIHRvIGRlZmluZSBpdC5cbiAgICBkY25wZ2V0dGV4dCA6IGZ1bmN0aW9uICggZG9tYWluLCBjb250ZXh0LCBzaW5ndWxhcl9rZXksIHBsdXJhbF9rZXksIHZhbCApIHtcbiAgICAgIC8vIFNldCBzb21lIGRlZmF1bHRzXG5cbiAgICAgIHBsdXJhbF9rZXkgPSBwbHVyYWxfa2V5IHx8IHNpbmd1bGFyX2tleTtcblxuICAgICAgLy8gVXNlIHRoZSBnbG9iYWwgZG9tYWluIGRlZmF1bHQgaWYgb25lXG4gICAgICAvLyBpc24ndCBleHBsaWNpdGx5IHBhc3NlZCBpblxuICAgICAgZG9tYWluID0gZG9tYWluIHx8IHRoaXMuX3RleHRkb21haW47XG5cbiAgICAgIHZhciBmYWxsYmFjaztcblxuICAgICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZXNcblxuICAgICAgLy8gTm8gb3B0aW9ucyBmb3VuZFxuICAgICAgaWYgKCAhIHRoaXMub3B0aW9ucyApIHtcbiAgICAgICAgLy8gVGhlcmUncyBsaWtlbHkgc29tZXRoaW5nIHdyb25nLCBidXQgd2UnbGwgcmV0dXJuIHRoZSBjb3JyZWN0IGtleSBmb3IgZW5nbGlzaFxuICAgICAgICAvLyBXZSBkbyB0aGlzIGJ5IGluc3RhbnRpYXRpbmcgYSBicmFuZCBuZXcgSmVkIGluc3RhbmNlIHdpdGggdGhlIGRlZmF1bHQgc2V0XG4gICAgICAgIC8vIGZvciBldmVyeXRoaW5nIHRoYXQgY291bGQgYmUgYnJva2VuLlxuICAgICAgICBmYWxsYmFjayA9IG5ldyBKZWQoKTtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrLmRjbnBnZXR0ZXh0LmNhbGwoIGZhbGxiYWNrLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgc2luZ3VsYXJfa2V5LCBwbHVyYWxfa2V5LCB2YWwgKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm8gdHJhbnNsYXRpb24gZGF0YSBwcm92aWRlZFxuICAgICAgaWYgKCAhIHRoaXMub3B0aW9ucy5sb2NhbGVfZGF0YSApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBsb2NhbGUgZGF0YSBwcm92aWRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCAhIHRoaXMub3B0aW9ucy5sb2NhbGVfZGF0YVsgZG9tYWluIF0gKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRG9tYWluIGAnICsgZG9tYWluICsgJ2Agd2FzIG5vdCBmb3VuZC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCAhIHRoaXMub3B0aW9ucy5sb2NhbGVfZGF0YVsgZG9tYWluIF1bIFwiXCIgXSApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBsb2NhbGUgbWV0YSBpbmZvcm1hdGlvbiBwcm92aWRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSB0cnV0aHkga2V5LiBPdGhlcndpc2Ugd2UgbWlnaHQgc3RhcnQgbG9va2luZ1xuICAgICAgLy8gaW50byB0aGUgZW1wdHkgc3RyaW5nIGtleSwgd2hpY2ggaXMgdGhlIG9wdGlvbnMgZm9yIHRoZSBsb2NhbGVcbiAgICAgIC8vIGRhdGEuXG4gICAgICBpZiAoICEgc2luZ3VsYXJfa2V5ICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRyYW5zbGF0aW9uIGtleSBmb3VuZC4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleSAgPSBjb250ZXh0ID8gY29udGV4dCArIEplZC5jb250ZXh0X2RlbGltaXRlciArIHNpbmd1bGFyX2tleSA6IHNpbmd1bGFyX2tleSxcbiAgICAgICAgICBsb2NhbGVfZGF0YSA9IHRoaXMub3B0aW9ucy5sb2NhbGVfZGF0YSxcbiAgICAgICAgICBkaWN0ID0gbG9jYWxlX2RhdGFbIGRvbWFpbiBdLFxuICAgICAgICAgIGRlZmF1bHRDb25mID0gKGxvY2FsZV9kYXRhLm1lc3NhZ2VzIHx8IHRoaXMuZGVmYXVsdHMubG9jYWxlX2RhdGEubWVzc2FnZXMpW1wiXCJdLFxuICAgICAgICAgIHBsdXJhbEZvcm1zID0gZGljdFtcIlwiXS5wbHVyYWxfZm9ybXMgfHwgZGljdFtcIlwiXVtcIlBsdXJhbC1Gb3Jtc1wiXSB8fCBkaWN0W1wiXCJdW1wicGx1cmFsLWZvcm1zXCJdIHx8IGRlZmF1bHRDb25mLnBsdXJhbF9mb3JtcyB8fCBkZWZhdWx0Q29uZltcIlBsdXJhbC1Gb3Jtc1wiXSB8fCBkZWZhdWx0Q29uZltcInBsdXJhbC1mb3Jtc1wiXSxcbiAgICAgICAgICB2YWxfbGlzdCxcbiAgICAgICAgICByZXM7XG5cbiAgICAgIHZhciB2YWxfaWR4O1xuICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE5vIHZhbHVlIHBhc3NlZCBpbjsgYXNzdW1lIHNpbmd1bGFyIGtleSBsb29rdXAuXG4gICAgICAgIHZhbF9pZHggPSAxO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBWYWx1ZSBoYXMgYmVlbiBwYXNzZWQgaW47IHVzZSBwbHVyYWwtZm9ybXMgY2FsY3VsYXRpb25zLlxuXG4gICAgICAgIC8vIEhhbmRsZSBpbnZhbGlkIG51bWJlcnMsIGJ1dCB0cnkgY2FzdGluZyBzdHJpbmdzIGZvciBnb29kIG1lYXN1cmVcbiAgICAgICAgaWYgKCB0eXBlb2YgdmFsICE9ICdudW1iZXInICkge1xuICAgICAgICAgIHZhbCA9IHBhcnNlSW50KCB2YWwsIDEwICk7XG5cbiAgICAgICAgICBpZiAoIGlzTmFOKCB2YWwgKSApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIG51bWJlciB0aGF0IHdhcyBwYXNzZWQgaW4gaXMgbm90IGEgbnVtYmVyLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhbF9pZHggPSBnZXRQbHVyYWxGb3JtRnVuYyhwbHVyYWxGb3JtcykodmFsKSArIDE7XG4gICAgICB9XG5cbiAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIGEgZG9tYWluIGlzbid0IGZvdW5kXG4gICAgICBpZiAoICEgZGljdCApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkb21haW4gbmFtZWQgYCcgKyBkb21haW4gKyAnYCBjb3VsZCBiZSBmb3VuZC4nKTtcbiAgICAgIH1cblxuICAgICAgdmFsX2xpc3QgPSBkaWN0WyBrZXkgXTtcblxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbWF0Y2gsIHRoZW4gcmV2ZXJ0IGJhY2sgdG9cbiAgICAgIC8vIGVuZ2xpc2ggc3R5bGUgc2luZ3VsYXIvcGx1cmFsIHdpdGggdGhlIGtleXMgcGFzc2VkIGluLlxuICAgICAgaWYgKCAhIHZhbF9saXN0IHx8IHZhbF9pZHggPj0gdmFsX2xpc3QubGVuZ3RoICkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1pc3Npbmdfa2V5X2NhbGxiYWNrKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm1pc3Npbmdfa2V5X2NhbGxiYWNrKGtleSwgZG9tYWluKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBbIG51bGwsIHNpbmd1bGFyX2tleSwgcGx1cmFsX2tleSBdO1xuXG4gICAgICAgIC8vIGNvbGxlY3QgdW50cmFuc2xhdGVkIHN0cmluZ3NcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zz09PXRydWUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhyZXNbIGdldFBsdXJhbEZvcm1GdW5jKHBsdXJhbEZvcm1zKSggdmFsICkgKyAxIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNbIGdldFBsdXJhbEZvcm1GdW5jKCkoIHZhbCApICsgMSBdO1xuICAgICAgfVxuXG4gICAgICByZXMgPSB2YWxfbGlzdFsgdmFsX2lkeCBdO1xuXG4gICAgICAvLyBUaGlzIGluY2x1ZGVzIGVtcHR5IHN0cmluZ3Mgb24gcHVycG9zZVxuICAgICAgaWYgKCAhIHJlcyAgKSB7XG4gICAgICAgIHJlcyA9IFsgbnVsbCwgc2luZ3VsYXJfa2V5LCBwbHVyYWxfa2V5IF07XG4gICAgICAgIHJldHVybiByZXNbIGdldFBsdXJhbEZvcm1GdW5jKCkoIHZhbCApICsgMSBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH0pO1xuXG5cbiAgLy8gV2UgYWRkIGluIHNwcmludGYgY2FwYWJpbGl0aWVzIGZvciBwb3N0IHRyYW5zbGF0aW9uIHZhbHVlIGludGVyb2xhdGlvblxuICAvLyBUaGlzIGlzIG5vdCBpbnRlcm5hbGx5IHVzZWQsIHNvIHlvdSBjYW4gcmVtb3ZlIGl0IGlmIHlvdSBoYXZlIHRoaXNcbiAgLy8gYXZhaWxhYmxlIHNvbWV3aGVyZSBlbHNlLCBvciB3YW50IHRvIHVzZSBhIGRpZmZlcmVudCBzeXN0ZW0uXG5cbiAgLy8gV2UgX3NsaWdodGx5XyBtb2RpZnkgdGhlIG5vcm1hbCBzcHJpbnRmIGJlaGF2aW9yIHRvIG1vcmUgZ3JhY2VmdWxseSBoYW5kbGVcbiAgLy8gdW5kZWZpbmVkIHZhbHVlcy5cblxuICAvKipcbiAgIHNwcmludGYoKSBmb3IgSmF2YVNjcmlwdCAwLjctYmV0YTFcbiAgIGh0dHA6Ly93d3cuZGl2ZWludG9qYXZhc2NyaXB0LmNvbS9wcm9qZWN0cy9qYXZhc2NyaXB0LXNwcmludGZcblxuICAgQ29weXJpZ2h0IChjKSBBbGV4YW5kcnUgTWFyYXN0ZWFudSA8YWxleGFob2xpYyBbYXQpIGdtYWlsIChkb3RdIGNvbT5cbiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gICAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHNwcmludGYoKSBmb3IgSmF2YVNjcmlwdCBub3IgdGhlXG4gICAgICAgICBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuICAgICAgICAgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuICAgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAgIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEFsZXhhbmRydSBNYXJhc3RlYW51IEJFIExJQUJMRSBGT1IgQU5ZXG4gICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAgIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAqL1xuICB2YXIgc3ByaW50ZiA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBnZXRfdHlwZSh2YXJpYWJsZSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YXJpYWJsZSkuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cl9yZXBlYXQoaW5wdXQsIG11bHRpcGxpZXIpIHtcbiAgICAgIGZvciAodmFyIG91dHB1dCA9IFtdOyBtdWx0aXBsaWVyID4gMDsgb3V0cHV0Wy0tbXVsdGlwbGllcl0gPSBpbnB1dCkgey8qIGRvIG5vdGhpbmcgKi99XG4gICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuICAgIH1cblxuICAgIHZhciBzdHJfZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXN0cl9mb3JtYXQuY2FjaGUuaGFzT3duUHJvcGVydHkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICBzdHJfZm9ybWF0LmNhY2hlW2FyZ3VtZW50c1swXV0gPSBzdHJfZm9ybWF0LnBhcnNlKGFyZ3VtZW50c1swXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyX2Zvcm1hdC5mb3JtYXQuY2FsbChudWxsLCBzdHJfZm9ybWF0LmNhY2hlW2FyZ3VtZW50c1swXV0sIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHN0cl9mb3JtYXQuZm9ybWF0ID0gZnVuY3Rpb24ocGFyc2VfdHJlZSwgYXJndikge1xuICAgICAgdmFyIGN1cnNvciA9IDEsIHRyZWVfbGVuZ3RoID0gcGFyc2VfdHJlZS5sZW5ndGgsIG5vZGVfdHlwZSA9ICcnLCBhcmcsIG91dHB1dCA9IFtdLCBpLCBrLCBtYXRjaCwgcGFkLCBwYWRfY2hhcmFjdGVyLCBwYWRfbGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRyZWVfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZV90eXBlID0gZ2V0X3R5cGUocGFyc2VfdHJlZVtpXSk7XG4gICAgICAgIGlmIChub2RlX3R5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2gocGFyc2VfdHJlZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZV90eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgbWF0Y2ggPSBwYXJzZV90cmVlW2ldOyAvLyBjb252ZW5pZW5jZSBwdXJwb3NlcyBvbmx5XG4gICAgICAgICAgaWYgKG1hdGNoWzJdKSB7IC8vIGtleXdvcmQgYXJndW1lbnRcbiAgICAgICAgICAgIGFyZyA9IGFyZ3ZbY3Vyc29yXTtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBtYXRjaFsyXS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICBpZiAoIWFyZy5oYXNPd25Qcm9wZXJ0eShtYXRjaFsyXVtrXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyhzcHJpbnRmKCdbc3ByaW50Zl0gcHJvcGVydHkgXCIlc1wiIGRvZXMgbm90IGV4aXN0JywgbWF0Y2hbMl1ba10pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhcmcgPSBhcmdbbWF0Y2hbMl1ba11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChtYXRjaFsxXSkgeyAvLyBwb3NpdGlvbmFsIGFyZ3VtZW50IChleHBsaWNpdClcbiAgICAgICAgICAgIGFyZyA9IGFyZ3ZbbWF0Y2hbMV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHsgLy8gcG9zaXRpb25hbCBhcmd1bWVudCAoaW1wbGljaXQpXG4gICAgICAgICAgICBhcmcgPSBhcmd2W2N1cnNvcisrXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoL1tec10vLnRlc3QobWF0Y2hbOF0pICYmIChnZXRfdHlwZShhcmcpICE9ICdudW1iZXInKSkge1xuICAgICAgICAgICAgdGhyb3coc3ByaW50ZignW3NwcmludGZdIGV4cGVjdGluZyBudW1iZXIgYnV0IGZvdW5kICVzJywgZ2V0X3R5cGUoYXJnKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEplZCBFRElUXG4gICAgICAgICAgaWYgKCB0eXBlb2YgYXJnID09ICd1bmRlZmluZWQnIHx8IGFyZyA9PT0gbnVsbCApIHtcbiAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBKZWQgRURJVFxuXG4gICAgICAgICAgc3dpdGNoIChtYXRjaFs4XSkge1xuICAgICAgICAgICAgY2FzZSAnYic6IGFyZyA9IGFyZy50b1N0cmluZygyKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjJzogYXJnID0gU3RyaW5nLmZyb21DaGFyQ29kZShhcmcpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2QnOiBhcmcgPSBwYXJzZUludChhcmcsIDEwKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlJzogYXJnID0gbWF0Y2hbN10gPyBhcmcudG9FeHBvbmVudGlhbChtYXRjaFs3XSkgOiBhcmcudG9FeHBvbmVudGlhbCgpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2YnOiBhcmcgPSBtYXRjaFs3XSA/IHBhcnNlRmxvYXQoYXJnKS50b0ZpeGVkKG1hdGNoWzddKSA6IHBhcnNlRmxvYXQoYXJnKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvJzogYXJnID0gYXJnLnRvU3RyaW5nKDgpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3MnOiBhcmcgPSAoKGFyZyA9IFN0cmluZyhhcmcpKSAmJiBtYXRjaFs3XSA/IGFyZy5zdWJzdHJpbmcoMCwgbWF0Y2hbN10pIDogYXJnKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1JzogYXJnID0gTWF0aC5hYnMoYXJnKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd4JzogYXJnID0gYXJnLnRvU3RyaW5nKDE2KTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdYJzogYXJnID0gYXJnLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJnID0gKC9bZGVmXS8udGVzdChtYXRjaFs4XSkgJiYgbWF0Y2hbM10gJiYgYXJnID49IDAgPyAnKycrIGFyZyA6IGFyZyk7XG4gICAgICAgICAgcGFkX2NoYXJhY3RlciA9IG1hdGNoWzRdID8gbWF0Y2hbNF0gPT0gJzAnID8gJzAnIDogbWF0Y2hbNF0uY2hhckF0KDEpIDogJyAnO1xuICAgICAgICAgIHBhZF9sZW5ndGggPSBtYXRjaFs2XSAtIFN0cmluZyhhcmcpLmxlbmd0aDtcbiAgICAgICAgICBwYWQgPSBtYXRjaFs2XSA/IHN0cl9yZXBlYXQocGFkX2NoYXJhY3RlciwgcGFkX2xlbmd0aCkgOiAnJztcbiAgICAgICAgICBvdXRwdXQucHVzaChtYXRjaFs1XSA/IGFyZyArIHBhZCA6IHBhZCArIGFyZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gICAgfTtcblxuICAgIHN0cl9mb3JtYXQuY2FjaGUgPSB7fTtcblxuICAgIHN0cl9mb3JtYXQucGFyc2UgPSBmdW5jdGlvbihmbXQpIHtcbiAgICAgIHZhciBfZm10ID0gZm10LCBtYXRjaCA9IFtdLCBwYXJzZV90cmVlID0gW10sIGFyZ19uYW1lcyA9IDA7XG4gICAgICB3aGlsZSAoX2ZtdCkge1xuICAgICAgICBpZiAoKG1hdGNoID0gL15bXlxceDI1XSsvLmV4ZWMoX2ZtdCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgcGFyc2VfdHJlZS5wdXNoKG1hdGNoWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobWF0Y2ggPSAvXlxceDI1ezJ9Ly5leGVjKF9mbXQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIHBhcnNlX3RyZWUucHVzaCgnJScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtYXRjaCA9IC9eXFx4MjUoPzooWzEtOV1cXGQqKVxcJHxcXCgoW15cXCldKylcXCkpPyhcXCspPygwfCdbXiRdKT8oLSk/KFxcZCspPyg/OlxcLihcXGQrKSk/KFtiLWZvc3V4WF0pLy5leGVjKF9mbXQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAgICAgYXJnX25hbWVzIHw9IDE7XG4gICAgICAgICAgICB2YXIgZmllbGRfbGlzdCA9IFtdLCByZXBsYWNlbWVudF9maWVsZCA9IG1hdGNoWzJdLCBmaWVsZF9tYXRjaCA9IFtdO1xuICAgICAgICAgICAgaWYgKChmaWVsZF9tYXRjaCA9IC9eKFthLXpfXVthLXpfXFxkXSopL2kuZXhlYyhyZXBsYWNlbWVudF9maWVsZCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGZpZWxkX2xpc3QucHVzaChmaWVsZF9tYXRjaFsxXSk7XG4gICAgICAgICAgICAgIHdoaWxlICgocmVwbGFjZW1lbnRfZmllbGQgPSByZXBsYWNlbWVudF9maWVsZC5zdWJzdHJpbmcoZmllbGRfbWF0Y2hbMF0ubGVuZ3RoKSkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKChmaWVsZF9tYXRjaCA9IC9eXFwuKFthLXpfXVthLXpfXFxkXSopL2kuZXhlYyhyZXBsYWNlbWVudF9maWVsZCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBmaWVsZF9saXN0LnB1c2goZmllbGRfbWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoZmllbGRfbWF0Y2ggPSAvXlxcWyhcXGQrKVxcXS8uZXhlYyhyZXBsYWNlbWVudF9maWVsZCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBmaWVsZF9saXN0LnB1c2goZmllbGRfbWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRocm93KCdbc3ByaW50Zl0gaHVoPycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93KCdbc3ByaW50Zl0gaHVoPycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0Y2hbMl0gPSBmaWVsZF9saXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFyZ19uYW1lcyB8PSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXJnX25hbWVzID09PSAzKSB7XG4gICAgICAgICAgICB0aHJvdygnW3NwcmludGZdIG1peGluZyBwb3NpdGlvbmFsIGFuZCBuYW1lZCBwbGFjZWhvbGRlcnMgaXMgbm90ICh5ZXQpIHN1cHBvcnRlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJzZV90cmVlLnB1c2gobWF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRocm93KCdbc3ByaW50Zl0gaHVoPycpO1xuICAgICAgICB9XG4gICAgICAgIF9mbXQgPSBfZm10LnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlX3RyZWU7XG4gICAgfTtcblxuICAgIHJldHVybiBzdHJfZm9ybWF0O1xuICB9KSgpO1xuXG4gIHZhciB2c3ByaW50ZiA9IGZ1bmN0aW9uKGZtdCwgYXJndikge1xuICAgIGFyZ3YudW5zaGlmdChmbXQpO1xuICAgIHJldHVybiBzcHJpbnRmLmFwcGx5KG51bGwsIGFyZ3YpO1xuICB9O1xuXG4gIEplZC5wYXJzZV9wbHVyYWwgPSBmdW5jdGlvbiAoIHBsdXJhbF9mb3JtcywgbiApIHtcbiAgICBwbHVyYWxfZm9ybXMgPSBwbHVyYWxfZm9ybXMucmVwbGFjZSgvbi9nLCBuKTtcbiAgICByZXR1cm4gSmVkLnBhcnNlX2V4cHJlc3Npb24ocGx1cmFsX2Zvcm1zKTtcbiAgfTtcblxuICBKZWQuc3ByaW50ZiA9IGZ1bmN0aW9uICggZm10LCBhcmdzICkge1xuICAgIGlmICgge30udG9TdHJpbmcuY2FsbCggYXJncyApID09ICdbb2JqZWN0IEFycmF5XScgKSB7XG4gICAgICByZXR1cm4gdnNwcmludGYoIGZtdCwgW10uc2xpY2UuY2FsbChhcmdzKSApO1xuICAgIH1cbiAgICByZXR1cm4gc3ByaW50Zi5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykgKTtcbiAgfTtcblxuICBKZWQucHJvdG90eXBlLnNwcmludGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEplZC5zcHJpbnRmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIC8vIEVORCBzcHJpbnRmIEltcGxlbWVudGF0aW9uXG5cbiAgLy8gU3RhcnQgdGhlIFBsdXJhbCBmb3JtcyBzZWN0aW9uXG4gIC8vIFRoaXMgaXMgYSBmdWxsIHBsdXJhbCBmb3JtIGV4cHJlc3Npb24gcGFyc2VyLiBJdCBpcyB1c2VkIHRvIGF2b2lkXG4gIC8vIHJ1bm5pbmcgJ2V2YWwnIG9yICduZXcgRnVuY3Rpb24nIGRpcmVjdGx5IGFnYWluc3QgdGhlIHBsdXJhbFxuICAvLyBmb3Jtcy5cbiAgLy9cbiAgLy8gVGhpcyBjYW4gYmUgaW1wb3J0YW50IGlmIHlvdSBnZXQgdHJhbnNsYXRpb25zIGRvbmUgdGhyb3VnaCBhIDNyZFxuICAvLyBwYXJ0eSB2ZW5kb3IuIEkgZW5jb3VyYWdlIHlvdSB0byB1c2UgdGhpcyBpbnN0ZWFkLCBob3dldmVyLCBJXG4gIC8vIGFsc28gd2lsbCBwcm92aWRlIGEgJ3ByZWNvbXBpbGVyJyB0aGF0IHlvdSBjYW4gdXNlIGF0IGJ1aWxkIHRpbWVcbiAgLy8gdG8gb3V0cHV0IHZhbGlkL3NhZmUgZnVuY3Rpb24gcmVwcmVzZW50YXRpb25zIG9mIHRoZSBwbHVyYWwgZm9ybVxuICAvLyBleHByZXNzaW9ucy4gVGhpcyBtZWFucyB5b3UgY2FuIGJ1aWxkIHRoaXMgY29kZSBvdXQgZm9yIHRoZSBtb3N0XG4gIC8vIHBhcnQuXG4gIEplZC5QRiA9IHt9O1xuXG4gIEplZC5QRi5wYXJzZSA9IGZ1bmN0aW9uICggcCApIHtcbiAgICB2YXIgcGx1cmFsX3N0ciA9IEplZC5QRi5leHRyYWN0UGx1cmFsRXhwciggcCApO1xuICAgIHJldHVybiBKZWQuUEYucGFyc2VyLnBhcnNlLmNhbGwoSmVkLlBGLnBhcnNlciwgcGx1cmFsX3N0cik7XG4gIH07XG5cbiAgSmVkLlBGLmNvbXBpbGUgPSBmdW5jdGlvbiAoIHAgKSB7XG4gICAgLy8gSGFuZGxlIHRydWVzIGFuZCBmYWxzZXMgYXMgMCBhbmQgMVxuICAgIGZ1bmN0aW9uIGltcGx5KCB2YWwgKSB7XG4gICAgICByZXR1cm4gKHZhbCA9PT0gdHJ1ZSA/IDEgOiB2YWwgPyB2YWwgOiAwKTtcbiAgICB9XG5cbiAgICB2YXIgYXN0ID0gSmVkLlBGLnBhcnNlKCBwICk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICggbiApIHtcbiAgICAgIHJldHVybiBpbXBseSggSmVkLlBGLmludGVycHJldGVyKCBhc3QgKSggbiApICk7XG4gICAgfTtcbiAgfTtcblxuICBKZWQuUEYuaW50ZXJwcmV0ZXIgPSBmdW5jdGlvbiAoIGFzdCApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCBuICkge1xuICAgICAgdmFyIHJlcztcbiAgICAgIHN3aXRjaCAoIGFzdC50eXBlICkge1xuICAgICAgICBjYXNlICdHUk9VUCc6XG4gICAgICAgICAgcmV0dXJuIEplZC5QRi5pbnRlcnByZXRlciggYXN0LmV4cHIgKSggbiApO1xuICAgICAgICBjYXNlICdURVJOQVJZJzpcbiAgICAgICAgICBpZiAoIEplZC5QRi5pbnRlcnByZXRlciggYXN0LmV4cHIgKSggbiApICkge1xuICAgICAgICAgICAgcmV0dXJuIEplZC5QRi5pbnRlcnByZXRlciggYXN0LnRydXRoeSApKCBuICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBKZWQuUEYuaW50ZXJwcmV0ZXIoIGFzdC5mYWxzZXkgKSggbiApO1xuICAgICAgICBjYXNlICdPUic6XG4gICAgICAgICAgcmV0dXJuIEplZC5QRi5pbnRlcnByZXRlciggYXN0LmxlZnQgKSggbiApIHx8IEplZC5QRi5pbnRlcnByZXRlciggYXN0LnJpZ2h0ICkoIG4gKTtcbiAgICAgICAgY2FzZSAnQU5EJzpcbiAgICAgICAgICByZXR1cm4gSmVkLlBGLmludGVycHJldGVyKCBhc3QubGVmdCApKCBuICkgJiYgSmVkLlBGLmludGVycHJldGVyKCBhc3QucmlnaHQgKSggbiApO1xuICAgICAgICBjYXNlICdMVCc6XG4gICAgICAgICAgcmV0dXJuIEplZC5QRi5pbnRlcnByZXRlciggYXN0LmxlZnQgKSggbiApIDwgSmVkLlBGLmludGVycHJldGVyKCBhc3QucmlnaHQgKSggbiApO1xuICAgICAgICBjYXNlICdHVCc6XG4gICAgICAgICAgcmV0dXJuIEplZC5QRi5pbnRlcnByZXRlciggYXN0LmxlZnQgKSggbiApID4gSmVkLlBGLmludGVycHJldGVyKCBhc3QucmlnaHQgKSggbiApO1xuICAgICAgICBjYXNlICdMVEUnOlxuICAgICAgICAgIHJldHVybiBKZWQuUEYuaW50ZXJwcmV0ZXIoIGFzdC5sZWZ0ICkoIG4gKSA8PSBKZWQuUEYuaW50ZXJwcmV0ZXIoIGFzdC5yaWdodCApKCBuICk7XG4gICAgICAgIGNhc2UgJ0dURSc6XG4gICAgICAgICAgcmV0dXJuIEplZC5QRi5pbnRlcnByZXRlciggYXN0LmxlZnQgKSggbiApID49IEplZC5QRi5pbnRlcnByZXRlciggYXN0LnJpZ2h0ICkoIG4gKTtcbiAgICAgICAgY2FzZSAnRVEnOlxuICAgICAgICAgIHJldHVybiBKZWQuUEYuaW50ZXJwcmV0ZXIoIGFzdC5sZWZ0ICkoIG4gKSA9PSBKZWQuUEYuaW50ZXJwcmV0ZXIoIGFzdC5yaWdodCApKCBuICk7XG4gICAgICAgIGNhc2UgJ05FUSc6XG4gICAgICAgICAgcmV0dXJuIEplZC5QRi5pbnRlcnByZXRlciggYXN0LmxlZnQgKSggbiApICE9IEplZC5QRi5pbnRlcnByZXRlciggYXN0LnJpZ2h0ICkoIG4gKTtcbiAgICAgICAgY2FzZSAnTU9EJzpcbiAgICAgICAgICByZXR1cm4gSmVkLlBGLmludGVycHJldGVyKCBhc3QubGVmdCApKCBuICkgJSBKZWQuUEYuaW50ZXJwcmV0ZXIoIGFzdC5yaWdodCApKCBuICk7XG4gICAgICAgIGNhc2UgJ1ZBUic6XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIGNhc2UgJ05VTSc6XG4gICAgICAgICAgcmV0dXJuIGFzdC52YWw7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBUb2tlbiBmb3VuZC5cIik7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBKZWQuUEYuZXh0cmFjdFBsdXJhbEV4cHIgPSBmdW5jdGlvbiAoIHAgKSB7XG4gICAgLy8gdHJpbSBmaXJzdFxuICAgIHAgPSBwLnJlcGxhY2UoL15cXHNcXHMqLywgJycpLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xuXG4gICAgaWYgKCEgLztcXHMqJC8udGVzdChwKSkge1xuICAgICAgcCA9IHAuY29uY2F0KCc7Jyk7XG4gICAgfVxuXG4gICAgdmFyIG5wbHVyYWxzX3JlID0gL25wbHVyYWxzXFw9KFxcZCspOy8sXG4gICAgICAgIHBsdXJhbF9yZSA9IC9wbHVyYWxcXD0oLiopOy8sXG4gICAgICAgIG5wbHVyYWxzX21hdGNoZXMgPSBwLm1hdGNoKCBucGx1cmFsc19yZSApLFxuICAgICAgICByZXMgPSB7fSxcbiAgICAgICAgcGx1cmFsX21hdGNoZXM7XG5cbiAgICAvLyBGaW5kIHRoZSBucGx1cmFscyBudW1iZXJcbiAgICBpZiAoIG5wbHVyYWxzX21hdGNoZXMubGVuZ3RoID4gMSApIHtcbiAgICAgIHJlcy5ucGx1cmFscyA9IG5wbHVyYWxzX21hdGNoZXNbMV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCducGx1cmFscyBub3QgZm91bmQgaW4gcGx1cmFsX2Zvcm1zIHN0cmluZzogJyArIHAgKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdGhhdCBkYXRhIHRvIGdldCB0byB0aGUgZm9ybXVsYVxuICAgIHAgPSBwLnJlcGxhY2UoIG5wbHVyYWxzX3JlLCBcIlwiICk7XG4gICAgcGx1cmFsX21hdGNoZXMgPSBwLm1hdGNoKCBwbHVyYWxfcmUgKTtcblxuICAgIGlmICghKCBwbHVyYWxfbWF0Y2hlcyAmJiBwbHVyYWxfbWF0Y2hlcy5sZW5ndGggPiAxICkgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BwbHVyYWxgIGV4cHJlc3Npb24gbm90IGZvdW5kOiAnICsgcCk7XG4gICAgfVxuICAgIHJldHVybiBwbHVyYWxfbWF0Y2hlc1sgMSBdO1xuICB9O1xuXG4gIC8qIEppc29uIGdlbmVyYXRlZCBwYXJzZXIgKi9cbiAgSmVkLlBGLnBhcnNlciA9IChmdW5jdGlvbigpe1xuXG52YXIgcGFyc2VyID0ge3RyYWNlOiBmdW5jdGlvbiB0cmFjZSgpIHsgfSxcbnl5OiB7fSxcbnN5bWJvbHNfOiB7XCJlcnJvclwiOjIsXCJleHByZXNzaW9uc1wiOjMsXCJlXCI6NCxcIkVPRlwiOjUsXCI/XCI6NixcIjpcIjo3LFwifHxcIjo4LFwiJiZcIjo5LFwiPFwiOjEwLFwiPD1cIjoxMSxcIj5cIjoxMixcIj49XCI6MTMsXCIhPVwiOjE0LFwiPT1cIjoxNSxcIiVcIjoxNixcIihcIjoxNyxcIilcIjoxOCxcIm5cIjoxOSxcIk5VTUJFUlwiOjIwLFwiJGFjY2VwdFwiOjAsXCIkZW5kXCI6MX0sXG50ZXJtaW5hbHNfOiB7MjpcImVycm9yXCIsNTpcIkVPRlwiLDY6XCI/XCIsNzpcIjpcIiw4OlwifHxcIiw5OlwiJiZcIiwxMDpcIjxcIiwxMTpcIjw9XCIsMTI6XCI+XCIsMTM6XCI+PVwiLDE0OlwiIT1cIiwxNTpcIj09XCIsMTY6XCIlXCIsMTc6XCIoXCIsMTg6XCIpXCIsMTk6XCJuXCIsMjA6XCJOVU1CRVJcIn0sXG5wcm9kdWN0aW9uc186IFswLFszLDJdLFs0LDVdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDNdLFs0LDFdLFs0LDFdXSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eXRleHQseXlsZW5nLHl5bGluZW5vLHl5LHl5c3RhdGUsJCQsXyQpIHtcblxudmFyICQwID0gJCQubGVuZ3RoIC0gMTtcbnN3aXRjaCAoeXlzdGF0ZSkge1xuY2FzZSAxOiByZXR1cm4geyB0eXBlIDogJ0dST1VQJywgZXhwcjogJCRbJDAtMV0gfTtcbmJyZWFrO1xuY2FzZSAyOnRoaXMuJCA9IHsgdHlwZTogJ1RFUk5BUlknLCBleHByOiAkJFskMC00XSwgdHJ1dGh5IDogJCRbJDAtMl0sIGZhbHNleTogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgMzp0aGlzLiQgPSB7IHR5cGU6IFwiT1JcIiwgbGVmdDogJCRbJDAtMl0sIHJpZ2h0OiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSA0OnRoaXMuJCA9IHsgdHlwZTogXCJBTkRcIiwgbGVmdDogJCRbJDAtMl0sIHJpZ2h0OiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSA1OnRoaXMuJCA9IHsgdHlwZTogJ0xUJywgbGVmdDogJCRbJDAtMl0sIHJpZ2h0OiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSA2OnRoaXMuJCA9IHsgdHlwZTogJ0xURScsIGxlZnQ6ICQkWyQwLTJdLCByaWdodDogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgNzp0aGlzLiQgPSB7IHR5cGU6ICdHVCcsIGxlZnQ6ICQkWyQwLTJdLCByaWdodDogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgODp0aGlzLiQgPSB7IHR5cGU6ICdHVEUnLCBsZWZ0OiAkJFskMC0yXSwgcmlnaHQ6ICQkWyQwXSB9O1xuYnJlYWs7XG5jYXNlIDk6dGhpcy4kID0geyB0eXBlOiAnTkVRJywgbGVmdDogJCRbJDAtMl0sIHJpZ2h0OiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSAxMDp0aGlzLiQgPSB7IHR5cGU6ICdFUScsIGxlZnQ6ICQkWyQwLTJdLCByaWdodDogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgMTE6dGhpcy4kID0geyB0eXBlOiAnTU9EJywgbGVmdDogJCRbJDAtMl0sIHJpZ2h0OiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSAxMjp0aGlzLiQgPSB7IHR5cGU6ICdHUk9VUCcsIGV4cHI6ICQkWyQwLTFdIH07XG5icmVhaztcbmNhc2UgMTM6dGhpcy4kID0geyB0eXBlOiAnVkFSJyB9O1xuYnJlYWs7XG5jYXNlIDE0OnRoaXMuJCA9IHsgdHlwZTogJ05VTScsIHZhbDogTnVtYmVyKHl5dGV4dCkgfTtcbmJyZWFrO1xufVxufSxcbnRhYmxlOiBbezM6MSw0OjIsMTc6WzEsM10sMTk6WzEsNF0sMjA6WzEsNV19LHsxOlszXX0sezU6WzEsNl0sNjpbMSw3XSw4OlsxLDhdLDk6WzEsOV0sMTA6WzEsMTBdLDExOlsxLDExXSwxMjpbMSwxMl0sMTM6WzEsMTNdLDE0OlsxLDE0XSwxNTpbMSwxNV0sMTY6WzEsMTZdfSx7NDoxNywxNzpbMSwzXSwxOTpbMSw0XSwyMDpbMSw1XX0sezU6WzIsMTNdLDY6WzIsMTNdLDc6WzIsMTNdLDg6WzIsMTNdLDk6WzIsMTNdLDEwOlsyLDEzXSwxMTpbMiwxM10sMTI6WzIsMTNdLDEzOlsyLDEzXSwxNDpbMiwxM10sMTU6WzIsMTNdLDE2OlsyLDEzXSwxODpbMiwxM119LHs1OlsyLDE0XSw2OlsyLDE0XSw3OlsyLDE0XSw4OlsyLDE0XSw5OlsyLDE0XSwxMDpbMiwxNF0sMTE6WzIsMTRdLDEyOlsyLDE0XSwxMzpbMiwxNF0sMTQ6WzIsMTRdLDE1OlsyLDE0XSwxNjpbMiwxNF0sMTg6WzIsMTRdfSx7MTpbMiwxXX0sezQ6MTgsMTc6WzEsM10sMTk6WzEsNF0sMjA6WzEsNV19LHs0OjE5LDE3OlsxLDNdLDE5OlsxLDRdLDIwOlsxLDVdfSx7NDoyMCwxNzpbMSwzXSwxOTpbMSw0XSwyMDpbMSw1XX0sezQ6MjEsMTc6WzEsM10sMTk6WzEsNF0sMjA6WzEsNV19LHs0OjIyLDE3OlsxLDNdLDE5OlsxLDRdLDIwOlsxLDVdfSx7NDoyMywxNzpbMSwzXSwxOTpbMSw0XSwyMDpbMSw1XX0sezQ6MjQsMTc6WzEsM10sMTk6WzEsNF0sMjA6WzEsNV19LHs0OjI1LDE3OlsxLDNdLDE5OlsxLDRdLDIwOlsxLDVdfSx7NDoyNiwxNzpbMSwzXSwxOTpbMSw0XSwyMDpbMSw1XX0sezQ6MjcsMTc6WzEsM10sMTk6WzEsNF0sMjA6WzEsNV19LHs2OlsxLDddLDg6WzEsOF0sOTpbMSw5XSwxMDpbMSwxMF0sMTE6WzEsMTFdLDEyOlsxLDEyXSwxMzpbMSwxM10sMTQ6WzEsMTRdLDE1OlsxLDE1XSwxNjpbMSwxNl0sMTg6WzEsMjhdfSx7NjpbMSw3XSw3OlsxLDI5XSw4OlsxLDhdLDk6WzEsOV0sMTA6WzEsMTBdLDExOlsxLDExXSwxMjpbMSwxMl0sMTM6WzEsMTNdLDE0OlsxLDE0XSwxNTpbMSwxNV0sMTY6WzEsMTZdfSx7NTpbMiwzXSw2OlsyLDNdLDc6WzIsM10sODpbMiwzXSw5OlsxLDldLDEwOlsxLDEwXSwxMTpbMSwxMV0sMTI6WzEsMTJdLDEzOlsxLDEzXSwxNDpbMSwxNF0sMTU6WzEsMTVdLDE2OlsxLDE2XSwxODpbMiwzXX0sezU6WzIsNF0sNjpbMiw0XSw3OlsyLDRdLDg6WzIsNF0sOTpbMiw0XSwxMDpbMSwxMF0sMTE6WzEsMTFdLDEyOlsxLDEyXSwxMzpbMSwxM10sMTQ6WzEsMTRdLDE1OlsxLDE1XSwxNjpbMSwxNl0sMTg6WzIsNF19LHs1OlsyLDVdLDY6WzIsNV0sNzpbMiw1XSw4OlsyLDVdLDk6WzIsNV0sMTA6WzIsNV0sMTE6WzIsNV0sMTI6WzIsNV0sMTM6WzIsNV0sMTQ6WzIsNV0sMTU6WzIsNV0sMTY6WzEsMTZdLDE4OlsyLDVdfSx7NTpbMiw2XSw2OlsyLDZdLDc6WzIsNl0sODpbMiw2XSw5OlsyLDZdLDEwOlsyLDZdLDExOlsyLDZdLDEyOlsyLDZdLDEzOlsyLDZdLDE0OlsyLDZdLDE1OlsyLDZdLDE2OlsxLDE2XSwxODpbMiw2XX0sezU6WzIsN10sNjpbMiw3XSw3OlsyLDddLDg6WzIsN10sOTpbMiw3XSwxMDpbMiw3XSwxMTpbMiw3XSwxMjpbMiw3XSwxMzpbMiw3XSwxNDpbMiw3XSwxNTpbMiw3XSwxNjpbMSwxNl0sMTg6WzIsN119LHs1OlsyLDhdLDY6WzIsOF0sNzpbMiw4XSw4OlsyLDhdLDk6WzIsOF0sMTA6WzIsOF0sMTE6WzIsOF0sMTI6WzIsOF0sMTM6WzIsOF0sMTQ6WzIsOF0sMTU6WzIsOF0sMTY6WzEsMTZdLDE4OlsyLDhdfSx7NTpbMiw5XSw2OlsyLDldLDc6WzIsOV0sODpbMiw5XSw5OlsyLDldLDEwOlsyLDldLDExOlsyLDldLDEyOlsyLDldLDEzOlsyLDldLDE0OlsyLDldLDE1OlsyLDldLDE2OlsxLDE2XSwxODpbMiw5XX0sezU6WzIsMTBdLDY6WzIsMTBdLDc6WzIsMTBdLDg6WzIsMTBdLDk6WzIsMTBdLDEwOlsyLDEwXSwxMTpbMiwxMF0sMTI6WzIsMTBdLDEzOlsyLDEwXSwxNDpbMiwxMF0sMTU6WzIsMTBdLDE2OlsxLDE2XSwxODpbMiwxMF19LHs1OlsyLDExXSw2OlsyLDExXSw3OlsyLDExXSw4OlsyLDExXSw5OlsyLDExXSwxMDpbMiwxMV0sMTE6WzIsMTFdLDEyOlsyLDExXSwxMzpbMiwxMV0sMTQ6WzIsMTFdLDE1OlsyLDExXSwxNjpbMiwxMV0sMTg6WzIsMTFdfSx7NTpbMiwxMl0sNjpbMiwxMl0sNzpbMiwxMl0sODpbMiwxMl0sOTpbMiwxMl0sMTA6WzIsMTJdLDExOlsyLDEyXSwxMjpbMiwxMl0sMTM6WzIsMTJdLDE0OlsyLDEyXSwxNTpbMiwxMl0sMTY6WzIsMTJdLDE4OlsyLDEyXX0sezQ6MzAsMTc6WzEsM10sMTk6WzEsNF0sMjA6WzEsNV19LHs1OlsyLDJdLDY6WzEsN10sNzpbMiwyXSw4OlsxLDhdLDk6WzEsOV0sMTA6WzEsMTBdLDExOlsxLDExXSwxMjpbMSwxMl0sMTM6WzEsMTNdLDE0OlsxLDE0XSwxNTpbMSwxNV0sMTY6WzEsMTZdLDE4OlsyLDJdfV0sXG5kZWZhdWx0QWN0aW9uczogezY6WzIsMV19LFxucGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbn0sXG5wYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHN0YWNrID0gWzBdLFxuICAgICAgICB2c3RhY2sgPSBbbnVsbF0sIC8vIHNlbWFudGljIHZhbHVlIHN0YWNrXG4gICAgICAgIGxzdGFjayA9IFtdLCAvLyBsb2NhdGlvbiBzdGFja1xuICAgICAgICB0YWJsZSA9IHRoaXMudGFibGUsXG4gICAgICAgIHl5dGV4dCA9ICcnLFxuICAgICAgICB5eWxpbmVubyA9IDAsXG4gICAgICAgIHl5bGVuZyA9IDAsXG4gICAgICAgIHJlY292ZXJpbmcgPSAwLFxuICAgICAgICBURVJST1IgPSAyLFxuICAgICAgICBFT0YgPSAxO1xuXG4gICAgLy90aGlzLnJlZHVjdGlvbkNvdW50ID0gdGhpcy5zaGlmdENvdW50ID0gMDtcblxuICAgIHRoaXMubGV4ZXIuc2V0SW5wdXQoaW5wdXQpO1xuICAgIHRoaXMubGV4ZXIueXkgPSB0aGlzLnl5O1xuICAgIHRoaXMueXkubGV4ZXIgPSB0aGlzLmxleGVyO1xuICAgIGlmICh0eXBlb2YgdGhpcy5sZXhlci55eWxsb2MgPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRoaXMubGV4ZXIueXlsbG9jID0ge307XG4gICAgdmFyIHl5bG9jID0gdGhpcy5sZXhlci55eWxsb2M7XG4gICAgbHN0YWNrLnB1c2goeXlsb2MpO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLnl5LnBhcnNlRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHRoaXMueXkucGFyc2VFcnJvcjtcblxuICAgIGZ1bmN0aW9uIHBvcFN0YWNrIChuKSB7XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IHN0YWNrLmxlbmd0aCAtIDIqbjtcbiAgICAgICAgdnN0YWNrLmxlbmd0aCA9IHZzdGFjay5sZW5ndGggLSBuO1xuICAgICAgICBsc3RhY2subGVuZ3RoID0gbHN0YWNrLmxlbmd0aCAtIG47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHRva2VuID0gc2VsZi5sZXhlci5sZXgoKSB8fCAxOyAvLyAkZW5kID0gMVxuICAgICAgICAvLyBpZiB0b2tlbiBpc24ndCBpdHMgbnVtZXJpYyB2YWx1ZSwgY29udmVydFxuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgdmFyIHN5bWJvbCwgcHJlRXJyb3JTeW1ib2wsIHN0YXRlLCBhY3Rpb24sIGEsIHIsIHl5dmFsPXt9LHAsbGVuLG5ld1N0YXRlLCBleHBlY3RlZDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAvLyByZXRyZWl2ZSBzdGF0ZSBudW1iZXIgZnJvbSB0b3Agb2Ygc3RhY2tcbiAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGgtMV07XG5cbiAgICAgICAgLy8gdXNlIGRlZmF1bHQgYWN0aW9ucyBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSB0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzeW1ib2wgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTtcbiAgICAgICAgICAgIC8vIHJlYWQgYWN0aW9uIGZvciBjdXJyZW50IHN0YXRlIGFuZCBmaXJzdCBpbnB1dFxuICAgICAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtzeW1ib2xdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIHBhcnNlIGVycm9yXG4gICAgICAgIF9oYW5kbGVfZXJyb3I6XG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAndW5kZWZpbmVkJyB8fCAhYWN0aW9uLmxlbmd0aCB8fCAhYWN0aW9uWzBdKSB7XG5cbiAgICAgICAgICAgIGlmICghcmVjb3ZlcmluZykge1xuICAgICAgICAgICAgICAgIC8vIFJlcG9ydCBlcnJvclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChwIGluIHRhYmxlW3N0YXRlXSkgaWYgKHRoaXMudGVybWluYWxzX1twXSAmJiBwID4gMikge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZC5wdXNoKFwiJ1wiK3RoaXMudGVybWluYWxzX1twXStcIidcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlcnJTdHIgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZXhlci5zaG93UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJysoeXlsaW5lbm8rMSkrXCI6XFxuXCIrdGhpcy5sZXhlci5zaG93UG9zaXRpb24oKStcIlxcbkV4cGVjdGluZyBcIitleHBlY3RlZC5qb2luKCcsICcpICsgXCIsIGdvdCAnXCIgKyB0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSsgXCInXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJysoeXlsaW5lbm8rMSkrXCI6IFVuZXhwZWN0ZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzeW1ib2wgPT0gMSAvKkVPRiovID8gXCJlbmQgb2YgaW5wdXRcIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiJ1wiKyh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpK1wiJ1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VFcnJvcihlcnJTdHIsXG4gICAgICAgICAgICAgICAgICAgIHt0ZXh0OiB0aGlzLmxleGVyLm1hdGNoLCB0b2tlbjogdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sLCBsaW5lOiB0aGlzLmxleGVyLnl5bGluZW5vLCBsb2M6IHl5bG9jLCBleHBlY3RlZDogZXhwZWN0ZWR9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8ganVzdCByZWNvdmVyZWQgZnJvbSBhbm90aGVyIGVycm9yXG4gICAgICAgICAgICBpZiAocmVjb3ZlcmluZyA9PSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbCA9PSBFT0YpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyclN0ciB8fCAnUGFyc2luZyBoYWx0ZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZGlzY2FyZCBjdXJyZW50IGxvb2thaGVhZCBhbmQgZ3JhYiBhbm90aGVyXG4gICAgICAgICAgICAgICAgeXlsZW5nID0gdGhpcy5sZXhlci55eWxlbmc7XG4gICAgICAgICAgICAgICAgeXl0ZXh0ID0gdGhpcy5sZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgeXlsaW5lbm8gPSB0aGlzLmxleGVyLnl5bGluZW5vO1xuICAgICAgICAgICAgICAgIHl5bG9jID0gdGhpcy5sZXhlci55eWxsb2M7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbGV4KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRyeSB0byByZWNvdmVyIGZyb20gZXJyb3JcbiAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGVycm9yIHJlY292ZXJ5IHJ1bGUgaW4gdGhpcyBzdGF0ZVxuICAgICAgICAgICAgICAgIGlmICgoVEVSUk9SLnRvU3RyaW5nKCkpIGluIHRhYmxlW3N0YXRlXSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyclN0ciB8fCAnUGFyc2luZyBoYWx0ZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcFN0YWNrKDEpO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmVFcnJvclN5bWJvbCA9IHN5bWJvbDsgLy8gc2F2ZSB0aGUgbG9va2FoZWFkIHRva2VuXG4gICAgICAgICAgICBzeW1ib2wgPSBURVJST1I7ICAgICAgICAgLy8gaW5zZXJ0IGdlbmVyaWMgZXJyb3Igc3ltYm9sIGFzIG5ldyBsb29rYWhlYWRcbiAgICAgICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdO1xuICAgICAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtURVJST1JdO1xuICAgICAgICAgICAgcmVjb3ZlcmluZyA9IDM7IC8vIGFsbG93IDMgcmVhbCBzeW1ib2xzIHRvIGJlIHNoaWZ0ZWQgYmVmb3JlIHJlcG9ydGluZyBhIG5ldyBlcnJvclxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcyBzaG91bGRuJ3QgaGFwcGVuLCB1bmxlc3MgcmVzb2x2ZSBkZWZhdWx0cyBhcmUgb2ZmXG4gICAgICAgIGlmIChhY3Rpb25bMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBhY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZSBFcnJvcjogbXVsdGlwbGUgYWN0aW9ucyBwb3NzaWJsZSBhdCBzdGF0ZTogJytzdGF0ZSsnLCB0b2tlbjogJytzeW1ib2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChhY3Rpb25bMF0pIHtcblxuICAgICAgICAgICAgY2FzZSAxOiAvLyBzaGlmdFxuICAgICAgICAgICAgICAgIC8vdGhpcy5zaGlmdENvdW50Kys7XG5cbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgdnN0YWNrLnB1c2godGhpcy5sZXhlci55eXRleHQpO1xuICAgICAgICAgICAgICAgIGxzdGFjay5wdXNoKHRoaXMubGV4ZXIueXlsbG9jKTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGFjdGlvblsxXSk7IC8vIHB1c2ggc3RhdGVcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghcHJlRXJyb3JTeW1ib2wpIHsgLy8gbm9ybWFsIGV4ZWN1dGlvbi9ubyBlcnJvclxuICAgICAgICAgICAgICAgICAgICB5eWxlbmcgPSB0aGlzLmxleGVyLnl5bGVuZztcbiAgICAgICAgICAgICAgICAgICAgeXl0ZXh0ID0gdGhpcy5sZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHl5bGluZW5vID0gdGhpcy5sZXhlci55eWxpbmVubztcbiAgICAgICAgICAgICAgICAgICAgeXlsb2MgPSB0aGlzLmxleGVyLnl5bGxvYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY292ZXJpbmcgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcmluZy0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGVycm9yIGp1c3Qgb2NjdXJyZWQsIHJlc3VtZSBvbGQgbG9va2FoZWFkIGYvIGJlZm9yZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBwcmVFcnJvclN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgcHJlRXJyb3JTeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyOiAvLyByZWR1Y2VcbiAgICAgICAgICAgICAgICAvL3RoaXMucmVkdWN0aW9uQ291bnQrKztcblxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMV07XG5cbiAgICAgICAgICAgICAgICAvLyBwZXJmb3JtIHNlbWFudGljIGFjdGlvblxuICAgICAgICAgICAgICAgIHl5dmFsLiQgPSB2c3RhY2tbdnN0YWNrLmxlbmd0aC1sZW5dOyAvLyBkZWZhdWx0IHRvICQkID0gJDFcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGxvY2F0aW9uLCB1c2VzIGZpcnN0IHRva2VuIGZvciBmaXJzdHMsIGxhc3QgZm9yIGxhc3RzXG4gICAgICAgICAgICAgICAgeXl2YWwuXyQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoLShsZW58fDEpXS5maXJzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoLTFdLmxhc3RfbGluZSxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aC0obGVufHwxKV0uZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGgtMV0ubGFzdF9jb2x1bW5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbCh5eXZhbCwgeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB0aGlzLnl5LCBhY3Rpb25bMV0sIHZzdGFjaywgbHN0YWNrKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcG9wIG9mZiBzdGFja1xuICAgICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZSgwLC0xKmxlbioyKTtcbiAgICAgICAgICAgICAgICAgICAgdnN0YWNrID0gdnN0YWNrLnNsaWNlKDAsIC0xKmxlbik7XG4gICAgICAgICAgICAgICAgICAgIGxzdGFjayA9IGxzdGFjay5zbGljZSgwLCAtMSpsZW4pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVswXSk7ICAgIC8vIHB1c2ggbm9udGVybWluYWwgKHJlZHVjZSlcbiAgICAgICAgICAgICAgICB2c3RhY2sucHVzaCh5eXZhbC4kKTtcbiAgICAgICAgICAgICAgICBsc3RhY2sucHVzaCh5eXZhbC5fJCk7XG4gICAgICAgICAgICAgICAgLy8gZ290byBuZXcgc3RhdGUgPSB0YWJsZVtTVEFURV1bTk9OVEVSTUlOQUxdXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0YWJsZVtzdGFja1tzdGFjay5sZW5ndGgtMl1dW3N0YWNrW3N0YWNrLmxlbmd0aC0xXV07XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzogLy8gYWNjZXB0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufX07LyogSmlzb24gZ2VuZXJhdGVkIGxleGVyICovXG52YXIgbGV4ZXIgPSAoZnVuY3Rpb24oKXtcblxudmFyIGxleGVyID0gKHtFT0Y6MSxcbnBhcnNlRXJyb3I6ZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICAgICAgaWYgKHRoaXMueXkucGFyc2VFcnJvcikge1xuICAgICAgICAgICAgdGhpcy55eS5wYXJzZUVycm9yKHN0ciwgaGFzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbiAgICAgICAgfVxuICAgIH0sXG5zZXRJbnB1dDpmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRoaXMuX2xlc3MgPSB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsZW5nID0gMDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbJ0lOSVRJQUwnXTtcbiAgICAgICAgdGhpcy55eWxsb2MgPSB7Zmlyc3RfbGluZToxLGZpcnN0X2NvbHVtbjowLGxhc3RfbGluZToxLGxhc3RfY29sdW1uOjB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuaW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFswXTtcbiAgICAgICAgdGhpcy55eXRleHQrPWNoO1xuICAgICAgICB0aGlzLnl5bGVuZysrO1xuICAgICAgICB0aGlzLm1hdGNoKz1jaDtcbiAgICAgICAgdGhpcy5tYXRjaGVkKz1jaDtcbiAgICAgICAgdmFyIGxpbmVzID0gY2gubWF0Y2goL1xcbi8pO1xuICAgICAgICBpZiAobGluZXMpIHRoaXMueXlsaW5lbm8rKztcbiAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG51bnB1dDpmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBjaCArIHRoaXMuX2lucHV0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxubW9yZTpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21vcmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxucGFzdElucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiAocGFzdC5sZW5ndGggPiAyMCA/ICcuLi4nOicnKSArIHBhc3Quc3Vic3RyKC0yMCkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgIH0sXG51cGNvbWluZ0lucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm1hdGNoO1xuICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkge1xuICAgICAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5zdWJzdHIoMCwgMjAtbmV4dC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwyMCkrKG5leHQubGVuZ3RoID4gMjAgPyAnLi4uJzonJykpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICB9LFxuc2hvd1Bvc2l0aW9uOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KCk7XG4gICAgICAgIHZhciBjID0gbmV3IEFycmF5KHByZS5sZW5ndGggKyAxKS5qb2luKFwiLVwiKTtcbiAgICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dCgpICsgXCJcXG5cIiArIGMrXCJeXCI7XG4gICAgfSxcbm5leHQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbnB1dCkgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIGNvbCxcbiAgICAgICAgICAgIGxpbmVzO1xuICAgICAgICBpZiAoIXRoaXMuX21vcmUpIHtcbiAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XG4gICAgICAgICAgICB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XG4gICAgICAgIGZvciAodmFyIGk9MDtpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1hdGNoID0gdGhpcy5faW5wdXQubWF0Y2godGhpcy5ydWxlc1tydWxlc1tpXV0pO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbGluZXMgPSBtYXRjaFswXS5tYXRjaCgvXFxuLiovZyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzKSB0aGlzLnl5bGluZW5vICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYyA9IHtmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vKzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgPyBsaW5lc1tsaW5lcy5sZW5ndGgtMV0ubGVuZ3RoLTEgOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiArIG1hdGNoWzBdLmxlbmd0aH1cbiAgICAgICAgICAgICAgICB0aGlzLnl5dGV4dCArPSBtYXRjaFswXTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoICs9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcyA9IG1hdGNoO1xuICAgICAgICAgICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vcmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVkICs9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwodGhpcywgdGhpcy55eSwgdGhpcywgcnVsZXNbaV0sdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aC0xXSk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuKSByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgZWxzZSByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lucHV0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlRXJyb3IoJ0xleGljYWwgZXJyb3Igb24gbGluZSAnKyh0aGlzLnl5bGluZW5vKzEpKycuIFVucmVjb2duaXplZCB0ZXh0LlxcbicrdGhpcy5zaG93UG9zaXRpb24oKSxcbiAgICAgICAgICAgICAgICAgICAge3RleHQ6IFwiXCIsIHRva2VuOiBudWxsLCBsaW5lOiB0aGlzLnl5bGluZW5vfSk7XG4gICAgICAgIH1cbiAgICB9LFxubGV4OmZ1bmN0aW9uIGxleCgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZXgoKTtcbiAgICAgICAgfVxuICAgIH0sXG5iZWdpbjpmdW5jdGlvbiBiZWdpbihjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjay5wdXNoKGNvbmRpdGlvbik7XG4gICAgfSxcbnBvcFN0YXRlOmZ1bmN0aW9uIHBvcFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTtcbiAgICB9LFxuX2N1cnJlbnRSdWxlczpmdW5jdGlvbiBfY3VycmVudFJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW3RoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGgtMV1dLnJ1bGVzO1xuICAgIH0sXG50b3BTdGF0ZTpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoLTJdO1xuICAgIH0sXG5wdXNoU3RhdGU6ZnVuY3Rpb24gYmVnaW4oY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuYmVnaW4oY29uZGl0aW9uKTtcbiAgICB9fSk7XG5sZXhlci5wZXJmb3JtQWN0aW9uID0gZnVuY3Rpb24gYW5vbnltb3VzKHl5LHl5XywkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zLFlZX1NUQVJUKSB7XG5cbnZhciBZWVNUQVRFPVlZX1NUQVJUO1xuc3dpdGNoKCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMpIHtcbmNhc2UgMDovKiBza2lwIHdoaXRlc3BhY2UgKi9cbmJyZWFrO1xuY2FzZSAxOnJldHVybiAyMFxuYnJlYWs7XG5jYXNlIDI6cmV0dXJuIDE5XG5icmVhaztcbmNhc2UgMzpyZXR1cm4gOFxuYnJlYWs7XG5jYXNlIDQ6cmV0dXJuIDlcbmJyZWFrO1xuY2FzZSA1OnJldHVybiA2XG5icmVhaztcbmNhc2UgNjpyZXR1cm4gN1xuYnJlYWs7XG5jYXNlIDc6cmV0dXJuIDExXG5icmVhaztcbmNhc2UgODpyZXR1cm4gMTNcbmJyZWFrO1xuY2FzZSA5OnJldHVybiAxMFxuYnJlYWs7XG5jYXNlIDEwOnJldHVybiAxMlxuYnJlYWs7XG5jYXNlIDExOnJldHVybiAxNFxuYnJlYWs7XG5jYXNlIDEyOnJldHVybiAxNVxuYnJlYWs7XG5jYXNlIDEzOnJldHVybiAxNlxuYnJlYWs7XG5jYXNlIDE0OnJldHVybiAxN1xuYnJlYWs7XG5jYXNlIDE1OnJldHVybiAxOFxuYnJlYWs7XG5jYXNlIDE2OnJldHVybiA1XG5icmVhaztcbmNhc2UgMTc6cmV0dXJuICdJTlZBTElEJ1xuYnJlYWs7XG59XG59O1xubGV4ZXIucnVsZXMgPSBbL15cXHMrLywvXlswLTldKyhcXC5bMC05XSspP1xcYi8sL15uXFxiLywvXlxcfFxcfC8sL14mJi8sL15cXD8vLC9eOi8sL148PS8sL14+PS8sL148LywvXj4vLC9eIT0vLC9ePT0vLC9eJS8sL15cXCgvLC9eXFwpLywvXiQvLC9eLi9dO1xubGV4ZXIuY29uZGl0aW9ucyA9IHtcIklOSVRJQUxcIjp7XCJydWxlc1wiOlswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3XSxcImluY2x1c2l2ZVwiOnRydWV9fTtyZXR1cm4gbGV4ZXI7fSkoKVxucGFyc2VyLmxleGVyID0gbGV4ZXI7XG5yZXR1cm4gcGFyc2VyO1xufSkoKTtcbi8vIEVuZCBwYXJzZXJcblxuICAvLyBIYW5kbGUgbm9kZSwgYW1kLCBhbmQgZ2xvYmFsIHN5c3RlbXNcbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gSmVkO1xuICAgIH1cbiAgICBleHBvcnRzLkplZCA9IEplZDtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoJ2plZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSmVkO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIExlYWsgYSBnbG9iYWwgcmVnYXJkbGVzcyBvZiBtb2R1bGUgc3lzdGVtXG4gICAgcm9vdFsnSmVkJ10gPSBKZWQ7XG4gIH1cblxufSkodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qZWQvamVkLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIHNoYUNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbnZhciByb3RsMzIgPSB1dGlscy5yb3RsMzI7XG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl81ID0gdXRpbHMuc3VtMzJfNTtcbnZhciBmdF8xID0gc2hhQ29tbW9uLmZ0XzE7XG52YXIgQmxvY2tIYXNoID0gY29tbW9uLkJsb2NrSGFzaDtcblxudmFyIHNoYTFfSyA9IFtcbiAgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSxcbiAgMHg4RjFCQkNEQywgMHhDQTYyQzFENlxuXTtcblxuZnVuY3Rpb24gU0hBMSgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTEpKVxuICAgIHJldHVybiBuZXcgU0hBMSgpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSxcbiAgICAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG4gIHRoaXMuVyA9IG5ldyBBcnJheSg4MCk7XG59XG5cbnV0aWxzLmluaGVyaXRzKFNIQTEsIEJsb2NrSGFzaCk7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTE7XG5cblNIQTEuYmxvY2tTaXplID0gNTEyO1xuU0hBMS5vdXRTaXplID0gMTYwO1xuU0hBMS5obWFjU3RyZW5ndGggPSA4MDtcblNIQTEucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcblxuICBmb3IoOyBpIDwgVy5sZW5ndGg7IGkrKylcbiAgICBXW2ldID0gcm90bDMyKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0sIDEpO1xuXG4gIHZhciBhID0gdGhpcy5oWzBdO1xuICB2YXIgYiA9IHRoaXMuaFsxXTtcbiAgdmFyIGMgPSB0aGlzLmhbMl07XG4gIHZhciBkID0gdGhpcy5oWzNdO1xuICB2YXIgZSA9IHRoaXMuaFs0XTtcblxuICBmb3IgKGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzID0gfn4oaSAvIDIwKTtcbiAgICB2YXIgdCA9IHN1bTMyXzUocm90bDMyKGEsIDUpLCBmdF8xKHMsIGIsIGMsIGQpLCBlLCBXW2ldLCBzaGExX0tbc10pO1xuICAgIGUgPSBkO1xuICAgIGQgPSBjO1xuICAgIGMgPSByb3RsMzIoYiwgMzApO1xuICAgIGIgPSBhO1xuICAgIGEgPSB0O1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbn07XG5cblNIQTEucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMS5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuZnVuY3Rpb24gQmxvY2tIYXNoKCkge1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdUb3RhbCA9IDA7XG4gIHRoaXMuYmxvY2tTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5ibG9ja1NpemU7XG4gIHRoaXMub3V0U2l6ZSA9IHRoaXMuY29uc3RydWN0b3Iub3V0U2l6ZTtcbiAgdGhpcy5obWFjU3RyZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLmhtYWNTdHJlbmd0aDtcbiAgdGhpcy5wYWRMZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLnBhZExlbmd0aCAvIDg7XG4gIHRoaXMuZW5kaWFuID0gJ2JpZyc7XG5cbiAgdGhpcy5fZGVsdGE4ID0gdGhpcy5ibG9ja1NpemUgLyA4O1xuICB0aGlzLl9kZWx0YTMyID0gdGhpcy5ibG9ja1NpemUgLyAzMjtcbn1cbmV4cG9ydHMuQmxvY2tIYXNoID0gQmxvY2tIYXNoO1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuICAvLyBDb252ZXJ0IG1lc3NhZ2UgdG8gYXJyYXksIHBhZCBpdCwgYW5kIGpvaW4gaW50byAzMmJpdCBibG9ja3NcbiAgbXNnID0gdXRpbHMudG9BcnJheShtc2csIGVuYyk7XG4gIGlmICghdGhpcy5wZW5kaW5nKVxuICAgIHRoaXMucGVuZGluZyA9IG1zZztcbiAgZWxzZVxuICAgIHRoaXMucGVuZGluZyA9IHRoaXMucGVuZGluZy5jb25jYXQobXNnKTtcbiAgdGhpcy5wZW5kaW5nVG90YWwgKz0gbXNnLmxlbmd0aDtcblxuICAvLyBFbm91Z2ggZGF0YSwgdHJ5IHVwZGF0aW5nXG4gIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID49IHRoaXMuX2RlbHRhOCkge1xuICAgIG1zZyA9IHRoaXMucGVuZGluZztcblxuICAgIC8vIFByb2Nlc3MgcGVuZGluZyBkYXRhIGluIGJsb2Nrc1xuICAgIHZhciByID0gbXNnLmxlbmd0aCAlIHRoaXMuX2RlbHRhODtcbiAgICB0aGlzLnBlbmRpbmcgPSBtc2cuc2xpY2UobXNnLmxlbmd0aCAtIHIsIG1zZy5sZW5ndGgpO1xuICAgIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcblxuICAgIG1zZyA9IHV0aWxzLmpvaW4zMihtc2csIDAsIG1zZy5sZW5ndGggLSByLCB0aGlzLmVuZGlhbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IHRoaXMuX2RlbHRhMzIpXG4gICAgICB0aGlzLl91cGRhdGUobXNnLCBpLCBpICsgdGhpcy5fZGVsdGEzMik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICB0aGlzLnVwZGF0ZSh0aGlzLl9wYWQoKSk7XG4gIGFzc2VydCh0aGlzLnBlbmRpbmcgPT09IG51bGwpO1xuXG4gIHJldHVybiB0aGlzLl9kaWdlc3QoZW5jKTtcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIHBhZCgpIHtcbiAgdmFyIGxlbiA9IHRoaXMucGVuZGluZ1RvdGFsO1xuICB2YXIgYnl0ZXMgPSB0aGlzLl9kZWx0YTg7XG4gIHZhciBrID0gYnl0ZXMgLSAoKGxlbiArIHRoaXMucGFkTGVuZ3RoKSAlIGJ5dGVzKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShrICsgdGhpcy5wYWRMZW5ndGgpO1xuICByZXNbMF0gPSAweDgwO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGs7IGkrKylcbiAgICByZXNbaV0gPSAwO1xuXG4gIC8vIEFwcGVuZCBsZW5ndGhcbiAgbGVuIDw8PSAzO1xuICBpZiAodGhpcy5lbmRpYW4gPT09ICdiaWcnKSB7XG4gICAgZm9yICh2YXIgdCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgcmVzW2krK10gPSAwO1xuXG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiA4KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuICB9IGVsc2Uge1xuICAgIHJlc1tpKytdID0gbGVuICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAyNCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcblxuICAgIGZvciAodCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgcmVzW2krK10gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL2NvbW1vbi5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciByb3RyMzIgPSB1dGlscy5yb3RyMzI7XG5cbmZ1bmN0aW9uIGZ0XzEocywgeCwgeSwgeikge1xuICBpZiAocyA9PT0gMClcbiAgICByZXR1cm4gY2gzMih4LCB5LCB6KTtcbiAgaWYgKHMgPT09IDEgfHwgcyA9PT0gMylcbiAgICByZXR1cm4gcDMyKHgsIHksIHopO1xuICBpZiAocyA9PT0gMilcbiAgICByZXR1cm4gbWFqMzIoeCwgeSwgeik7XG59XG5leHBvcnRzLmZ0XzEgPSBmdF8xO1xuXG5mdW5jdGlvbiBjaDMyKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgXiAoKH54KSAmIHopO1xufVxuZXhwb3J0cy5jaDMyID0gY2gzMjtcblxuZnVuY3Rpb24gbWFqMzIoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSBeICh4ICYgeikgXiAoeSAmIHopO1xufVxuZXhwb3J0cy5tYWozMiA9IG1hajMyO1xuXG5mdW5jdGlvbiBwMzIoeCwgeSwgeikge1xuICByZXR1cm4geCBeIHkgXiB6O1xufVxuZXhwb3J0cy5wMzIgPSBwMzI7XG5cbmZ1bmN0aW9uIHMwXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgMikgXiByb3RyMzIoeCwgMTMpIF4gcm90cjMyKHgsIDIyKTtcbn1cbmV4cG9ydHMuczBfMjU2ID0gczBfMjU2O1xuXG5mdW5jdGlvbiBzMV8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDYpIF4gcm90cjMyKHgsIDExKSBeIHJvdHIzMih4LCAyNSk7XG59XG5leHBvcnRzLnMxXzI1NiA9IHMxXzI1NjtcblxuZnVuY3Rpb24gZzBfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCA3KSBeIHJvdHIzMih4LCAxOCkgXiAoeCA+Pj4gMyk7XG59XG5leHBvcnRzLmcwXzI1NiA9IGcwXzI1NjtcblxuZnVuY3Rpb24gZzFfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCAxNykgXiByb3RyMzIoeCwgMTkpIF4gKHggPj4+IDEwKTtcbn1cbmV4cG9ydHMuZzFfMjU2ID0gZzFfMjU2O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvY29tbW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRXh0ZXJuYWwgRGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuXG4vKipcbiAqIEludGVybmFsIERlcGVuZGVuY2llc1xuICovXG5cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0QWRkb25zQ3JlYXRlRnJhZ21lbnQgPSByZXF1aXJlKCdyZWFjdC1hZGRvbnMtY3JlYXRlLWZyYWdtZW50Jyk7XG5cbnZhciBfcmVhY3RBZGRvbnNDcmVhdGVGcmFnbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdEFkZG9uc0NyZWF0ZUZyYWdtZW50KTtcblxudmFyIF90b2tlbml6ZSA9IHJlcXVpcmUoJy4vdG9rZW5pemUnKTtcblxudmFyIF90b2tlbml6ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b2tlbml6ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjdXJyZW50TWl4ZWRTdHJpbmcgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIGdldENsb3NlSW5kZXgob3BlbkluZGV4LCB0b2tlbnMpIHtcblx0dmFyIG9wZW5Ub2tlbiA9IHRva2Vuc1tvcGVuSW5kZXhdLFxuXHQgICAgbmVzdExldmVsID0gMCxcblx0ICAgIHRva2VuLFxuXHQgICAgaTtcblx0Zm9yIChpID0gb3BlbkluZGV4ICsgMTsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuXHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXHRcdGlmICh0b2tlbi52YWx1ZSA9PT0gb3BlblRva2VuLnZhbHVlKSB7XG5cdFx0XHRpZiAodG9rZW4udHlwZSA9PT0gJ2NvbXBvbmVudE9wZW4nKSB7XG5cdFx0XHRcdG5lc3RMZXZlbCsrO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmICh0b2tlbi50eXBlID09PSAnY29tcG9uZW50Q2xvc2UnKSB7XG5cdFx0XHRcdGlmIChuZXN0TGV2ZWwgPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXN0TGV2ZWwtLTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly8gaWYgd2UgZ2V0IHRoaXMgZmFyLCB0aGVyZSB3YXMgbm8gbWF0Y2hpbmcgY2xvc2UgdG9rZW5cblx0dGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNsb3NpbmcgY29tcG9uZW50IHRva2VuIGAnICsgb3BlblRva2VuLnZhbHVlICsgJ2AnKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRDaGlsZHJlbih0b2tlbnMsIGNvbXBvbmVudHMpIHtcblx0dmFyIGNoaWxkcmVuID0gW10sXG5cdCAgICBjaGlsZHJlbk9iamVjdCA9IHt9LFxuXHQgICAgb3BlbkNvbXBvbmVudCxcblx0ICAgIGNsb25lZE9wZW5Db21wb25lbnQsXG5cdCAgICBvcGVuSW5kZXgsXG5cdCAgICBjbG9zZUluZGV4LFxuXHQgICAgdG9rZW4sXG5cdCAgICBpLFxuXHQgICAgZ3JhbmRDaGlsZFRva2Vucyxcblx0ICAgIGdyYW5kQ2hpbGRyZW4sXG5cdCAgICBzaWJsaW5nVG9rZW5zLFxuXHQgICAgc2libGluZ3M7XG5cblx0Zm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuXHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXHRcdGlmICh0b2tlbi50eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0Y2hpbGRyZW4ucHVzaCh0b2tlbi52YWx1ZSk7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0Ly8gY29tcG9uZW50IG5vZGUgc2hvdWxkIGF0IGxlYXN0IGJlIHNldFxuXHRcdGlmICghY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eSh0b2tlbi52YWx1ZSkgfHwgdHlwZW9mIGNvbXBvbmVudHNbdG9rZW4udmFsdWVdID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVycG9sYXRpb24sIG1pc3NpbmcgY29tcG9uZW50IG5vZGU6IGAnICsgdG9rZW4udmFsdWUgKyAnYCcpO1xuXHRcdH1cblx0XHQvLyBzaG91bGQgYmUgZWl0aGVyIFJlYWN0RWxlbWVudCBvciBudWxsIChib3RoIHR5cGUgXCJvYmplY3RcIiksIGFsbCBvdGhlciB0eXBlcyBkZXByZWNhdGVkXG5cdFx0aWYgKF90eXBlb2YoY29tcG9uZW50c1t0b2tlbi52YWx1ZV0pICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVycG9sYXRpb24sIGNvbXBvbmVudCBub2RlIG11c3QgYmUgYSBSZWFjdEVsZW1lbnQgb3IgbnVsbDogYCcgKyB0b2tlbi52YWx1ZSArICdgJywgJ1xcbj4gJyArIGN1cnJlbnRNaXhlZFN0cmluZyk7XG5cdFx0fVxuXHRcdC8vIHdlIHNob3VsZCBuZXZlciBzZWUgYSBjb21wb25lbnRDbG9zZSB0b2tlbiBpbiB0aGlzIGxvb3Bcblx0XHRpZiAodG9rZW4udHlwZSA9PT0gJ2NvbXBvbmVudENsb3NlJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIG9wZW5pbmcgY29tcG9uZW50IHRva2VuOiBgJyArIHRva2VuLnZhbHVlICsgJ2AnKTtcblx0XHR9XG5cdFx0aWYgKHRva2VuLnR5cGUgPT09ICdjb21wb25lbnRPcGVuJykge1xuXHRcdFx0b3BlbkNvbXBvbmVudCA9IGNvbXBvbmVudHNbdG9rZW4udmFsdWVdO1xuXHRcdFx0b3BlbkluZGV4ID0gaTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHQvLyBjb21wb25lbnRTZWxmQ2xvc2luZyB0b2tlblxuXHRcdGNoaWxkcmVuLnB1c2goY29tcG9uZW50c1t0b2tlbi52YWx1ZV0pO1xuXHRcdGNvbnRpbnVlO1xuXHR9XG5cblx0aWYgKG9wZW5Db21wb25lbnQpIHtcblx0XHRjbG9zZUluZGV4ID0gZ2V0Q2xvc2VJbmRleChvcGVuSW5kZXgsIHRva2Vucyk7XG5cdFx0Z3JhbmRDaGlsZFRva2VucyA9IHRva2Vucy5zbGljZShvcGVuSW5kZXggKyAxLCBjbG9zZUluZGV4KTtcblx0XHRncmFuZENoaWxkcmVuID0gYnVpbGRDaGlsZHJlbihncmFuZENoaWxkVG9rZW5zLCBjb21wb25lbnRzKTtcblx0XHRjbG9uZWRPcGVuQ29tcG9uZW50ID0gX3JlYWN0Mi5kZWZhdWx0LmNsb25lRWxlbWVudChvcGVuQ29tcG9uZW50LCB7fSwgZ3JhbmRDaGlsZHJlbik7XG5cdFx0Y2hpbGRyZW4ucHVzaChjbG9uZWRPcGVuQ29tcG9uZW50KTtcblxuXHRcdGlmIChjbG9zZUluZGV4IDwgdG9rZW5zLmxlbmd0aCAtIDEpIHtcblx0XHRcdHNpYmxpbmdUb2tlbnMgPSB0b2tlbnMuc2xpY2UoY2xvc2VJbmRleCArIDEpO1xuXHRcdFx0c2libGluZ3MgPSBidWlsZENoaWxkcmVuKHNpYmxpbmdUb2tlbnMsIGNvbXBvbmVudHMpO1xuXHRcdFx0Y2hpbGRyZW4gPSBjaGlsZHJlbi5jb25jYXQoc2libGluZ3MpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcblx0XHRyZXR1cm4gY2hpbGRyZW5bMF07XG5cdH1cblxuXHRjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcblx0XHRpZiAoY2hpbGQpIHtcblx0XHRcdGNoaWxkcmVuT2JqZWN0WydpbnRlcnBvbGF0aW9uLWNoaWxkLScgKyBpbmRleF0gPSBjaGlsZDtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiAoMCwgX3JlYWN0QWRkb25zQ3JlYXRlRnJhZ21lbnQyLmRlZmF1bHQpKGNoaWxkcmVuT2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUob3B0aW9ucykge1xuXHR2YXIgbWl4ZWRTdHJpbmcgPSBvcHRpb25zLm1peGVkU3RyaW5nLFxuXHQgICAgY29tcG9uZW50cyA9IG9wdGlvbnMuY29tcG9uZW50cyxcblx0ICAgIHRocm93RXJyb3JzID0gb3B0aW9ucy50aHJvd0Vycm9ycztcblxuXG5cdGN1cnJlbnRNaXhlZFN0cmluZyA9IG1peGVkU3RyaW5nO1xuXG5cdGlmICghY29tcG9uZW50cykge1xuXHRcdHJldHVybiBtaXhlZFN0cmluZztcblx0fVxuXG5cdGlmICgodHlwZW9mIGNvbXBvbmVudHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbXBvbmVudHMpKSAhPT0gJ29iamVjdCcpIHtcblx0XHRpZiAodGhyb3dFcnJvcnMpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW50ZXJwb2xhdGlvbiBFcnJvcjogdW5hYmxlIHRvIHByb2Nlc3MgYCcgKyBtaXhlZFN0cmluZyArICdgIGJlY2F1c2UgY29tcG9uZW50cyBpcyBub3QgYW4gb2JqZWN0Jyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1peGVkU3RyaW5nO1xuXHR9XG5cblx0dmFyIHRva2VucyA9ICgwLCBfdG9rZW5pemUyLmRlZmF1bHQpKG1peGVkU3RyaW5nKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiBidWlsZENoaWxkcmVuKHRva2VucywgY29tcG9uZW50cyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0aWYgKHRocm93RXJyb3JzKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludGVycG9sYXRpb24gRXJyb3I6IHVuYWJsZSB0byBwcm9jZXNzIGAnICsgbWl4ZWRTdHJpbmcgKyAnYCBiZWNhdXNlIG9mIGVycm9yIGAnICsgZXJyb3IubWVzc2FnZSArICdgJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1peGVkU3RyaW5nO1xuXHR9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBpbnRlcnBvbGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ludGVycG9sYXRlLWNvbXBvbmVudHMvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvciAmJiBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gIDB4ZWFjNztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgdmFyIGl0ZXJhdG9yRm4gPVxuICAgIG1heWJlSXRlcmFibGUgJiZcbiAgICAoKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKFxuICBjaGlsZHJlbixcbiAgbmFtZVNvRmFyLFxuICBjYWxsYmFjayxcbiAgdHJhdmVyc2VDb250ZXh0XG4pIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGlmIChcbiAgICBjaGlsZHJlbiA9PT0gbnVsbCB8fFxuICAgIHR5cGUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQuIFRoaXMgbWVhbnMgd2UgY2FuIG9wdGltaXplXG4gICAgLy8gc29tZSBjaGVja3MuIFJlYWN0IEZpYmVyIGFsc28gaW5saW5lcyB0aGlzIGxvZ2ljIGZvciBzaW1pbGFyIHB1cnBvc2VzLlxuICAgICh0eXBlID09PSAnb2JqZWN0JyAmJiBjaGlsZHJlbi4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKVxuICApIHtcbiAgICBjYWxsYmFjayhcbiAgICAgIHRyYXZlcnNlQ29udGV4dCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0ZhclxuICAgICk7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgbmV4dE5hbWUsXG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICB0cmF2ZXJzZUNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzLFxuICAgICAgICAgICAgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgK1xuICAgICAgICAgICAgICAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArXG4gICAgICAgICAgICAgICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIG5leHROYW1lLFxuICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgIHRyYXZlcnNlQ29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYWRkZW5kdW0gPVxuICAgICAgICAgICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICtcbiAgICAgICAgICAnUmVhY3QgYWRkLW9ucy4nO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gJycgKyBjaGlsZHJlbjtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsXG4gICAgICAgIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJ1xuICAgICAgICAgID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9J1xuICAgICAgICAgIDogY2hpbGRyZW5TdHJpbmcsXG4gICAgICAgIGFkZGVuZHVtXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KFxuICAgIG9sZEVsZW1lbnQsXG4gICAge2tleTogbmV3S2V5fSxcbiAgICBvbGRFbGVtZW50LnByb3BzICE9PSB1bmRlZmluZWQgPyBvbGRFbGVtZW50LnByb3BzLmNoaWxkcmVuIDogdW5kZWZpbmVkXG4gICk7XG59XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uKGNvcHlGaWVsZHNGcm9tKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGNvcHlGaWVsZHNGcm9tKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhjb3B5RmllbGRzRnJvbSk7XG4gIH1cbn07XG5cbnZhciBhZGRQb29saW5nVG8gPSBmdW5jdGlvbiBhZGRQb29saW5nVG8oQ29weUNvbnN0cnVjdG9yLCBwb29sZXIpIHtcbiAgLy8gQ2FzdGluZyBhcyBhbnkgc28gdGhhdCBmbG93IGlnbm9yZXMgdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiBhbmQgdHJ1c3RzXG4gIC8vIGl0IHRvIG1hdGNoIHRoZSB0eXBlIHdlIGRlY2xhcmVkXG4gIHZhciBOZXdLbGFzcyA9IENvcHlDb25zdHJ1Y3RvcjtcbiAgTmV3S2xhc3MuaW5zdGFuY2VQb29sID0gW107XG4gIE5ld0tsYXNzLmdldFBvb2xlZCA9IHBvb2xlciB8fCBERUZBVUxUX1BPT0xFUjtcbiAgaWYgKCFOZXdLbGFzcy5wb29sU2l6ZSkge1xuICAgIE5ld0tsYXNzLnBvb2xTaXplID0gREVGQVVMVF9QT09MX1NJWkU7XG4gIH1cbiAgTmV3S2xhc3MucmVsZWFzZSA9IHN0YW5kYXJkUmVsZWFzZXI7XG4gIHJldHVybiBOZXdLbGFzcztcbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gc3RhbmRhcmRSZWxlYXNlcihpbnN0YW5jZSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpbnZhcmlhbnQoXG4gICAgaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcyxcbiAgICAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nXG4gICk7XG4gIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGggPCBLbGFzcy5wb29sU2l6ZSkge1xuICAgIEtsYXNzLmluc3RhbmNlUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIGZvdXJBcmd1bWVudFBvb2xlcihhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBNYXBCb29rS2VlcGluZyhtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgdGhpcy5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICB0aGlzLmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5NYXBCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gIHRoaXMua2V5UHJlZml4ID0gbnVsbDtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuYWRkUG9vbGluZ1RvKE1hcEJvb2tLZWVwaW5nLCBmb3VyQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdDtcbiAgdmFyIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeDtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jO1xuICB2YXIgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChcbiAgICAgIG1hcHBlZENoaWxkLFxuICAgICAgcmVzdWx0LFxuICAgICAgY2hpbGRLZXksXG4gICAgICBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnRcbiAgICApO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShcbiAgICAgICAgbWFwcGVkQ2hpbGQsXG4gICAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICBrZXlQcmVmaXggK1xuICAgICAgICAgIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSlcbiAgICAgICAgICAgID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLydcbiAgICAgICAgICAgIDogJycpICtcbiAgICAgICAgICBjaGlsZEtleVxuICAgICAgKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBNYXBCb29rS2VlcGluZy5nZXRQb29sZWQoXG4gICAgYXJyYXksXG4gICAgZXNjYXBlZFByZWZpeCxcbiAgICBmdW5jLFxuICAgIGNvbnRleHRcbiAgKTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgTWFwQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG52YXIgbnVtZXJpY1Byb3BlcnR5UmVnZXggPSAvXlxcZCskLztcblxudmFyIHdhcm5lZEFib3V0TnVtZXJpYyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjcmVhdGVSZWFjdEZyYWdtZW50KG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcgfHwgIW9iamVjdCB8fCBBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICAnUmVhY3QuYWRkb25zLmNyZWF0ZUZyYWdtZW50IG9ubHkgYWNjZXB0cyBhIHNpbmdsZSBvYmplY3QuIEdvdDogJXMnLFxuICAgICAgb2JqZWN0XG4gICAgKTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChvYmplY3QpKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgJ1JlYWN0LmFkZG9ucy5jcmVhdGVGcmFnbWVudCBkb2VzIG5vdCBhY2NlcHQgYSBSZWFjdEVsZW1lbnQgJyArXG4gICAgICAgICd3aXRob3V0IGEgd3JhcHBlciBvYmplY3QuJ1xuICAgICk7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIGludmFyaWFudChcbiAgICBvYmplY3Qubm9kZVR5cGUgIT09IDEsXG4gICAgJ1JlYWN0LmFkZG9ucy5jcmVhdGVGcmFnbWVudCguLi4pOiBFbmNvdW50ZXJlZCBhbiBpbnZhbGlkIGNoaWxkOyBET00gJyArXG4gICAgICAnZWxlbWVudHMgYXJlIG5vdCB2YWxpZCBjaGlsZHJlbiBvZiBSZWFjdCBjb21wb25lbnRzLidcbiAgKTtcblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIXdhcm5lZEFib3V0TnVtZXJpYyAmJiBudW1lcmljUHJvcGVydHlSZWdleC50ZXN0KGtleSkpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnUmVhY3QuYWRkb25zLmNyZWF0ZUZyYWdtZW50KC4uLik6IENoaWxkIG9iamVjdHMgc2hvdWxkIGhhdmUgJyArXG4gICAgICAgICAgICAnbm9uLW51bWVyaWMga2V5cyBzbyBvcmRlcmluZyBpcyBwcmVzZXJ2ZWQuJ1xuICAgICAgICApO1xuICAgICAgICB3YXJuZWRBYm91dE51bWVyaWMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKFxuICAgICAgb2JqZWN0W2tleV0sXG4gICAgICByZXN1bHQsXG4gICAgICBrZXksXG4gICAgICBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnRcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZWFjdEZyYWdtZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtYWRkb25zLWNyZWF0ZS1mcmFnbWVudC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGlkZW50aWZ5VG9rZW4oaXRlbSkge1xuXHQvLyB7ey9leGFtcGxlfX1cblx0aWYgKGl0ZW0ubWF0Y2goL15cXHtcXHtcXC8vKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiAnY29tcG9uZW50Q2xvc2UnLFxuXHRcdFx0dmFsdWU6IGl0ZW0ucmVwbGFjZSgvXFxXL2csICcnKVxuXHRcdH07XG5cdH1cblx0Ly8ge3tleGFtcGxlIC99fVxuXHRpZiAoaXRlbS5tYXRjaCgvXFwvXFx9XFx9JC8pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6ICdjb21wb25lbnRTZWxmQ2xvc2luZycsXG5cdFx0XHR2YWx1ZTogaXRlbS5yZXBsYWNlKC9cXFcvZywgJycpXG5cdFx0fTtcblx0fVxuXHQvLyB7e2V4YW1wbGV9fVxuXHRpZiAoaXRlbS5tYXRjaCgvXlxce1xcey8pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6ICdjb21wb25lbnRPcGVuJyxcblx0XHRcdHZhbHVlOiBpdGVtLnJlcGxhY2UoL1xcVy9nLCAnJylcblx0XHR9O1xuXHR9XG5cdHJldHVybiB7XG5cdFx0dHlwZTogJ3N0cmluZycsXG5cdFx0dmFsdWU6IGl0ZW1cblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWl4ZWRTdHJpbmcpIHtcblx0dmFyIHRva2VuU3RyaW5ncyA9IG1peGVkU3RyaW5nLnNwbGl0KC8oXFx7XFx7XFwvP1xccypcXHcrXFxzKlxcLz9cXH1cXH0pL2cpOyAvLyBzcGxpdCB0byBjb21wb25lbnRzIGFuZCBzdHJpbmdzXG5cdHJldHVybiB0b2tlblN0cmluZ3MubWFwKGlkZW50aWZ5VG9rZW4pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRva2VuaXplLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ludGVycG9sYXRlLWNvbXBvbmVudHMvbGliL3Rva2VuaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsInZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IExSVVxuXG5mdW5jdGlvbiBMUlUgKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExSVSkpIHJldHVybiBuZXcgTFJVKG9wdHMpXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ251bWJlcicpIG9wdHMgPSB7bWF4OiBvcHRzfVxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICBldmVudHMuRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcbiAgdGhpcy5jYWNoZSA9IHt9XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGxcbiAgdGhpcy5sZW5ndGggPSAwXG4gIHRoaXMubWF4ID0gb3B0cy5tYXggfHwgMTAwMFxuICB0aGlzLm1heEFnZSA9IG9wdHMubWF4QWdlIHx8IDBcbn1cblxuaW5oZXJpdHMoTFJVLCBldmVudHMuRXZlbnRFbWl0dGVyKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVLnByb3RvdHlwZSwgJ2tleXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jYWNoZSkgfVxufSlcblxuTFJVLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jYWNoZSA9IHt9XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGxcbiAgdGhpcy5sZW5ndGggPSAwXG59XG5cbkxSVS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIGtleSA9ICcnICsga2V5XG4gIGlmICghdGhpcy5jYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm5cblxuICB2YXIgZWxlbWVudCA9IHRoaXMuY2FjaGVba2V5XVxuICBkZWxldGUgdGhpcy5jYWNoZVtrZXldXG4gIHRoaXMuX3VubGluayhrZXksIGVsZW1lbnQucHJldiwgZWxlbWVudC5uZXh0KVxuICByZXR1cm4gZWxlbWVudC52YWx1ZVxufVxuXG5MUlUucHJvdG90eXBlLl91bmxpbmsgPSBmdW5jdGlvbiAoa2V5LCBwcmV2LCBuZXh0KSB7XG4gIHRoaXMubGVuZ3RoLS1cblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuaGVhZCA9PT0ga2V5KSB7XG4gICAgICB0aGlzLmhlYWQgPSBwcmV2XG4gICAgICB0aGlzLmNhY2hlW3RoaXMuaGVhZF0ubmV4dCA9IG51bGxcbiAgICB9IGVsc2UgaWYgKHRoaXMudGFpbCA9PT0ga2V5KSB7XG4gICAgICB0aGlzLnRhaWwgPSBuZXh0XG4gICAgICB0aGlzLmNhY2hlW3RoaXMudGFpbF0ucHJldiA9IG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYWNoZVtwcmV2XS5uZXh0ID0gbmV4dFxuICAgICAgdGhpcy5jYWNoZVtuZXh0XS5wcmV2ID0gcHJldlxuICAgIH1cbiAgfVxufVxuXG5MUlUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICghdGhpcy5jYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm5cblxuICB2YXIgZWxlbWVudCA9IHRoaXMuY2FjaGVba2V5XVxuXG4gIGlmICghdGhpcy5fY2hlY2tBZ2Uoa2V5LCBlbGVtZW50KSkgcmV0dXJuXG4gIHJldHVybiBlbGVtZW50LnZhbHVlXG59XG5cbkxSVS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSBrZXkgPSAnJyArIGtleVxuXG4gIHZhciBlbGVtZW50XG5cbiAgaWYgKHRoaXMuY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIGVsZW1lbnQgPSB0aGlzLmNhY2hlW2tleV1cbiAgICBlbGVtZW50LnZhbHVlID0gdmFsdWVcbiAgICBpZiAodGhpcy5tYXhBZ2UpIGVsZW1lbnQubW9kaWZpZWQgPSBEYXRlLm5vdygpXG5cbiAgICAvLyBJZiBpdCdzIGFscmVhZHkgdGhlIGhlYWQsIHRoZXJlJ3Mgbm90aGluZyBtb3JlIHRvIGRvOlxuICAgIGlmIChrZXkgPT09IHRoaXMuaGVhZCkgcmV0dXJuIHZhbHVlXG4gICAgdGhpcy5fdW5saW5rKGtleSwgZWxlbWVudC5wcmV2LCBlbGVtZW50Lm5leHQpXG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudCA9IHt2YWx1ZTogdmFsdWUsIG1vZGlmaWVkOiAwLCBuZXh0OiBudWxsLCBwcmV2OiBudWxsfVxuICAgIGlmICh0aGlzLm1heEFnZSkgZWxlbWVudC5tb2RpZmllZCA9IERhdGUubm93KClcbiAgICB0aGlzLmNhY2hlW2tleV0gPSBlbGVtZW50XG5cbiAgICAvLyBFdmljdGlvbiBpcyBvbmx5IHBvc3NpYmxlIGlmIHRoZSBrZXkgZGlkbid0IGFscmVhZHkgZXhpc3Q6XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSB0aGlzLm1heCkgdGhpcy5ldmljdCgpXG4gIH1cblxuICB0aGlzLmxlbmd0aCsrXG4gIGVsZW1lbnQubmV4dCA9IG51bGxcbiAgZWxlbWVudC5wcmV2ID0gdGhpcy5oZWFkXG5cbiAgaWYgKHRoaXMuaGVhZCkgdGhpcy5jYWNoZVt0aGlzLmhlYWRdLm5leHQgPSBrZXlcbiAgdGhpcy5oZWFkID0ga2V5XG5cbiAgaWYgKCF0aGlzLnRhaWwpIHRoaXMudGFpbCA9IGtleVxuICByZXR1cm4gdmFsdWVcbn1cblxuTFJVLnByb3RvdHlwZS5fY2hlY2tBZ2UgPSBmdW5jdGlvbiAoa2V5LCBlbGVtZW50KSB7XG4gIGlmICh0aGlzLm1heEFnZSAmJiAoRGF0ZS5ub3coKSAtIGVsZW1lbnQubW9kaWZpZWQpID4gdGhpcy5tYXhBZ2UpIHtcbiAgICB0aGlzLnJlbW92ZShrZXkpXG4gICAgdGhpcy5lbWl0KCdldmljdCcsIHtrZXk6IGtleSwgdmFsdWU6IGVsZW1lbnQudmFsdWV9KVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbkxSVS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIGtleSA9ICcnICsga2V5XG4gIGlmICghdGhpcy5jYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm5cblxuICB2YXIgZWxlbWVudCA9IHRoaXMuY2FjaGVba2V5XVxuXG4gIGlmICghdGhpcy5fY2hlY2tBZ2Uoa2V5LCBlbGVtZW50KSkgcmV0dXJuXG5cbiAgaWYgKHRoaXMuaGVhZCAhPT0ga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gdGhpcy50YWlsKSB7XG4gICAgICB0aGlzLnRhaWwgPSBlbGVtZW50Lm5leHRcbiAgICAgIHRoaXMuY2FjaGVbdGhpcy50YWlsXS5wcmV2ID0gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXQgcHJldi5uZXh0IC0+IGVsZW1lbnQubmV4dDpcbiAgICAgIHRoaXMuY2FjaGVbZWxlbWVudC5wcmV2XS5uZXh0ID0gZWxlbWVudC5uZXh0XG4gICAgfVxuXG4gICAgLy8gU2V0IGVsZW1lbnQubmV4dC5wcmV2IC0+IGVsZW1lbnQucHJldjpcbiAgICB0aGlzLmNhY2hlW2VsZW1lbnQubmV4dF0ucHJldiA9IGVsZW1lbnQucHJldlxuXG4gICAgLy8gRWxlbWVudCBpcyB0aGUgbmV3IGhlYWRcbiAgICB0aGlzLmNhY2hlW3RoaXMuaGVhZF0ubmV4dCA9IGtleVxuICAgIGVsZW1lbnQucHJldiA9IHRoaXMuaGVhZFxuICAgIGVsZW1lbnQubmV4dCA9IG51bGxcbiAgICB0aGlzLmhlYWQgPSBrZXlcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50LnZhbHVlXG59XG5cbkxSVS5wcm90b3R5cGUuZXZpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy50YWlsKSByZXR1cm5cbiAgdmFyIGtleSA9IHRoaXMudGFpbFxuICB2YXIgdmFsdWUgPSB0aGlzLnJlbW92ZSh0aGlzLnRhaWwpXG4gIHRoaXMuZW1pdCgnZXZpY3QnLCB7a2V5OiBrZXksIHZhbHVlOiB2YWx1ZX0pXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9scnUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiLyoqXG4gKiBFeHBvc2VzIG51bWJlciBmb3JtYXQgY2FwYWJpbGl0eVxuICpcbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDEzIEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rdnouaW8pIGFuZCBDb250cmlidXRvcnMgKGh0dHA6Ly9waHBqcy5vcmcvYXV0aG9ycykuXG4gKiBAbGljZW5zZSBTZWUgQ1JFRElUUy5tZFxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20va3Z6L3BocGpzL2Jsb2IvZmZlMTM1NmFmMjNhNmYyNTEyYzg0Yzk1NGRkNGU4MjhlOTI1NzlmYS9mdW5jdGlvbnMvc3RyaW5ncy9udW1iZXJfZm9ybWF0LmpzXG4gKi9cbmZ1bmN0aW9uIG51bWJlcl9mb3JtYXQoIG51bWJlciwgZGVjaW1hbHMsIGRlY19wb2ludCwgdGhvdXNhbmRzX3NlcCApIHtcbiAgbnVtYmVyID0gKCBudW1iZXIgKyAnJyApXG4gICAgLnJlcGxhY2UoIC9bXjAtOStcXC1FZS5dL2csICcnICk7XG4gIHZhciBuID0gISBpc0Zpbml0ZSggK251bWJlciApID8gMCA6ICtudW1iZXIsXG4gICAgcHJlYyA9ICEgaXNGaW5pdGUoICtkZWNpbWFscyApID8gMCA6IE1hdGguYWJzKCBkZWNpbWFscyApLFxuICAgIHNlcCA9ICggdHlwZW9mIHRob3VzYW5kc19zZXAgPT09ICd1bmRlZmluZWQnICkgPyAnLCcgOiB0aG91c2FuZHNfc2VwLFxuICAgIGRlYyA9ICggdHlwZW9mIGRlY19wb2ludCA9PT0gJ3VuZGVmaW5lZCcgKSA/ICcuJyA6IGRlY19wb2ludCxcbiAgICBzID0gJycsXG4gICAgdG9GaXhlZEZpeCA9IGZ1bmN0aW9uKCBuLCBwcmVjICkge1xuICAgICAgdmFyIGsgPSBNYXRoLnBvdyggMTAsIHByZWMgKTtcbiAgICAgIHJldHVybiAnJyArICggTWF0aC5yb3VuZCggbiAqIGsgKSAvIGsgKVxuICAgICAgICAgIC50b0ZpeGVkKCBwcmVjICk7XG4gICAgfTtcbiAgLy8gRml4IGZvciBJRSBwYXJzZUZsb2F0KDAuNTUpLnRvRml4ZWQoMCkgPSAwO1xuICBzID0gKCBwcmVjID8gdG9GaXhlZEZpeCggbiwgcHJlYyApIDogJycgKyBNYXRoLnJvdW5kKCBuICkgKVxuICAgIC5zcGxpdCggJy4nICk7XG4gIGlmICggc1sgMCBdLmxlbmd0aCA+IDMgKSB7XG4gICAgc1sgMCBdID0gc1sgMCBdLnJlcGxhY2UoIC9cXEIoPz0oPzpcXGR7M30pKyg/IVxcZCkpL2csIHNlcCApO1xuICB9XG4gIGlmICggKCBzWyAxIF0gfHwgJycgKVxuICAgICAgICAubGVuZ3RoIDwgcHJlYyApIHtcbiAgICBzWyAxIF0gPSBzWyAxIF0gfHwgJyc7XG4gICAgc1sgMSBdICs9IG5ldyBBcnJheSggcHJlYyAtIHNbIDEgXS5sZW5ndGggKyAxIClcbiAgICAgIC5qb2luKCAnMCcgKTtcbiAgfVxuICByZXR1cm4gcy5qb2luKCBkZWMgKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBudW1iZXJfZm9ybWF0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaTE4bi13cC1wbHVnaW4vbGliL251bWJlci1mb3JtYXQuanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwidmFyIFJlYWN0ID0gcmVxdWlyZSggJ3JlYWN0JyApLFxuXHRhc3NpZ24gPSByZXF1aXJlKCAnbG9kYXNoLmFzc2lnbicgKSxcblx0Y3JlYXRlQ2xhc3MgPSByZXF1aXJlKCAnY3JlYXRlLXJlYWN0LWNsYXNzJyApO1xuXG4vKipcbiAqIExvY2FsaXplIGEgUmVhY3QgY29tcG9uZW50XG4gKiBAcGFyYW0gQ29tcG9zZWRDb21wb25lbnRcbiAqIEByZXR1cm5zIEEgbmV3IExvY2FsaXplZCBSZWFjdCBDb21wb25lbnRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggaTE4biApIHtcblx0dmFyIGkxOG5Qcm9wcyA9IHtcblx0XHRudW1iZXJGb3JtYXQ6IGkxOG4ubnVtYmVyRm9ybWF0LmJpbmQoIGkxOG4gKSxcblx0XHR0cmFuc2xhdGU6IGkxOG4udHJhbnNsYXRlLmJpbmQoIGkxOG4gKVxuXHR9O1xuXG5cdHJldHVybiBmdW5jdGlvbiggQ29tcG9zZWRDb21wb25lbnQgKSB7XG5cdFx0dmFyIGNvbXBvbmVudE5hbWUgPSBDb21wb3NlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb3NlZENvbXBvbmVudC5uYW1lIHx8ICcnO1xuXG5cdFx0dmFyIGNvbXBvbmVudCA9IGNyZWF0ZUNsYXNzKHtcblx0XHRcdGRpc3BsYXlOYW1lOiAnTG9jYWxpemVkKCcgKyBjb21wb25lbnROYW1lICsgJyknLFxuXG5cdFx0XHRjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuYm91bmRGb3JjZVVwZGF0ZSA9IHRoaXMuZm9yY2VVcGRhdGUuYmluZCggdGhpcyApO1xuXHRcdFx0XHRpMThuLnN0YXRlT2JzZXJ2ZXIuYWRkTGlzdGVuZXIoICdjaGFuZ2UnLCB0aGlzLmJvdW5kRm9yY2VVcGRhdGUgKTtcblx0XHRcdH0sXG5cblx0XHRcdGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gaW4gc29tZSBjYXNlcywgY29tcG9uZW50V2lsbFVubW91bnQgaXMgY2FsbGVkIGJlZm9yZSBjb21wb25lbnREaWRNb3VudFxuXHRcdFx0XHQvLyBTdXBwb3NlZGx5IGZpeGVkIGluIFJlYWN0IDE1LjEuMDogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yNDEwXG5cdFx0XHRcdGlmICggdGhpcy5ib3VuZEZvcmNlVXBkYXRlICkge1xuXHRcdFx0XHRcdGkxOG4uc3RhdGVPYnNlcnZlci5yZW1vdmVMaXN0ZW5lciggJ2NoYW5nZScsIHRoaXMuYm91bmRGb3JjZVVwZGF0ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcHJvcHMgPSBhc3NpZ24oIHt9LCB0aGlzLnByb3BzLCBpMThuUHJvcHMgKTtcblx0XHRcdFx0cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoIENvbXBvc2VkQ29tcG9uZW50LCBwcm9wcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRjb21wb25lbnQuX2NvbXBvc2VkQ29tcG9uZW50ID0gQ29tcG9zZWRDb21wb25lbnQ7XG5cdFx0cmV0dXJuIGNvbXBvbmVudDtcblx0fTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pMThuLXdwLXBsdWdpbi9saWIvbG9jYWxpemUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGZhY3RvcnkgPSByZXF1aXJlKCcuL2ZhY3RvcnknKTtcblxuaWYgKHR5cGVvZiBSZWFjdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdGhyb3cgRXJyb3IoXG4gICAgJ2NyZWF0ZS1yZWFjdC1jbGFzcyBjb3VsZCBub3QgZmluZCB0aGUgUmVhY3Qgb2JqZWN0LiBJZiB5b3UgYXJlIHVzaW5nIHNjcmlwdCB0YWdzLCAnICtcbiAgICAgICdtYWtlIHN1cmUgdGhhdCBSZWFjdCBpcyBiZWluZyBsb2FkZWQgYmVmb3JlIGNyZWF0ZS1yZWFjdC1jbGFzcy4nXG4gICk7XG59XG5cbi8vIEhhY2sgdG8gZ3JhYiBOb29wVXBkYXRlUXVldWUgZnJvbSBpc29tb3JwaGljIFJlYWN0XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSBuZXcgUmVhY3QuQ29tcG9uZW50KCkudXBkYXRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICBSZWFjdC5Db21wb25lbnQsXG4gIFJlYWN0LmlzVmFsaWRFbGVtZW50LFxuICBSZWFjdE5vb3BVcGRhdGVRdWV1ZVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1yZWFjdC1jbGFzcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG59XG5cbnZhciBNSVhJTlNfS0VZID0gJ21peGlucyc7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBhbGxvdyB0aGUgY3JlYXRpb24gb2YgYW5vbnltb3VzIGZ1bmN0aW9ucyB3aGljaCBkbyBub3Rcbi8vIGhhdmUgLm5hbWUgc2V0IHRvIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSBiZWluZyBhc3NpZ25lZCB0by5cbmZ1bmN0aW9uIGlkZW50aXR5KGZuKSB7XG4gIHJldHVybiBmbjtcbn1cblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7XG4gICAgcHJvcDogJ3Byb3AnLFxuICAgIGNvbnRleHQ6ICdjb250ZXh0JyxcbiAgICBjaGlsZENvbnRleHQ6ICdjaGlsZCBjb250ZXh0J1xuICB9O1xufSBlbHNlIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7fTtcbn1cblxuZnVuY3Rpb24gZmFjdG9yeShSZWFjdENvbXBvbmVudCwgaXNWYWxpZEVsZW1lbnQsIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlKSB7XG4gIC8qKlxuICAgKiBQb2xpY2llcyB0aGF0IGRlc2NyaWJlIG1ldGhvZHMgaW4gYFJlYWN0Q2xhc3NJbnRlcmZhY2VgLlxuICAgKi9cblxuICB2YXIgaW5qZWN0ZWRNaXhpbnMgPSBbXTtcblxuICAvKipcbiAgICogQ29tcG9zaXRlIGNvbXBvbmVudHMgYXJlIGhpZ2hlci1sZXZlbCBjb21wb25lbnRzIHRoYXQgY29tcG9zZSBvdGhlciBjb21wb3NpdGVcbiAgICogb3IgaG9zdCBjb21wb25lbnRzLlxuICAgKlxuICAgKiBUbyBjcmVhdGUgYSBuZXcgdHlwZSBvZiBgUmVhY3RDbGFzc2AsIHBhc3MgYSBzcGVjaWZpY2F0aW9uIG9mXG4gICAqIHlvdXIgbmV3IGNsYXNzIHRvIGBSZWFjdC5jcmVhdGVDbGFzc2AuIFRoZSBvbmx5IHJlcXVpcmVtZW50IG9mIHlvdXIgY2xhc3NcbiAgICogc3BlY2lmaWNhdGlvbiBpcyB0aGF0IHlvdSBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuXG4gICAqXG4gICAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICogICAgICAgcmV0dXJuIDxkaXY+SGVsbG8gV29ybGQ8L2Rpdj47XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIFRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIHN1cHBvcnRzIGEgc3BlY2lmaWMgcHJvdG9jb2wgb2YgbWV0aG9kcyB0aGF0IGhhdmVcbiAgICogc3BlY2lhbCBtZWFuaW5nIChlLmcuIGByZW5kZXJgKS4gU2VlIGBSZWFjdENsYXNzSW50ZXJmYWNlYCBmb3JcbiAgICogbW9yZSB0aGUgY29tcHJlaGVuc2l2ZSBwcm90b2NvbC4gQW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlXG4gICAqIGNsYXNzIHNwZWNpZmljYXRpb24gd2lsbCBiZSBhdmFpbGFibGUgb24gdGhlIHByb3RvdHlwZS5cbiAgICpcbiAgICogQGludGVyZmFjZSBSZWFjdENsYXNzSW50ZXJmYWNlXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdmFyIFJlYWN0Q2xhc3NJbnRlcmZhY2UgPSB7XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgTWl4aW4gb2JqZWN0cyB0byBpbmNsdWRlIHdoZW4gZGVmaW5pbmcgeW91ciBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7YXJyYXl9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgbWl4aW5zOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0aGF0IHNob3VsZCBiZSBkZWZpbmVkIG9uXG4gICAgICogdGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgaXRzIHByb3RvdHlwZSAoc3RhdGljIG1ldGhvZHMpLlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBzdGF0aWNzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5pdGlvbiBvZiBwcm9wIHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgcHJvcFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29udGV4dFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIHRoaXMgY29tcG9uZW50IHNldHMgZm9yIGl0cyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY2hpbGRDb250ZXh0VHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvLyA9PT09IERlZmluaXRpb24gbWV0aG9kcyA9PT09XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBWYWx1ZXMgaW4gdGhlIG1hcHBpbmcgd2lsbCBiZSBzZXQgb25cbiAgICAgKiBgdGhpcy5wcm9wc2AgaWYgdGhhdCBwcm9wIGlzIG5vdCBzcGVjaWZpZWQgKGkuZS4gdXNpbmcgYW4gYGluYCBjaGVjaykuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGJlZm9yZSBgZ2V0SW5pdGlhbFN0YXRlYCBhbmQgdGhlcmVmb3JlIGNhbm5vdCByZWx5XG4gICAgICogb24gYHRoaXMuc3RhdGVgIG9yIHVzZSBgdGhpcy5zZXRTdGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFByb3BzOiAnREVGSU5FX01BTllfTUVSR0VEJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgICAqIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIGB0aGlzLnN0YXRlYC5cbiAgICAgKlxuICAgICAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgcmV0dXJuIHtcbiAgICAgKiAgICAgICBpc09uOiBmYWxzZSxcbiAgICAgKiAgICAgICBmb29CYXo6IG5ldyBCYXpGb28oKVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiAnREVGSU5FX01BTllfTUVSR0VEJyxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBnZXRDaGlsZENvbnRleHQ6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gICAgLyoqXG4gICAgICogVXNlcyBwcm9wcyBmcm9tIGB0aGlzLnByb3BzYCBhbmQgc3RhdGUgZnJvbSBgdGhpcy5zdGF0ZWAgdG8gcmVuZGVyIHRoZVxuICAgICAqIHN0cnVjdHVyZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogTm8gZ3VhcmFudGVlcyBhcmUgbWFkZSBhYm91dCB3aGVuIG9yIGhvdyBvZnRlbiB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLCBzb1xuICAgICAqIGl0IG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLlxuICAgICAqXG4gICAgICogICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICAgKiAgICAgcmV0dXJuIDxkaXY+SGVsbG8sIHtuYW1lfSE8L2Rpdj47XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAgICAgKiBAcmVxdWlyZWRcbiAgICAgKi9cbiAgICByZW5kZXI6ICdERUZJTkVfT05DRScsXG5cbiAgICAvLyA9PT09IERlbGVnYXRlIG1ldGhvZHMgPT09PVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGx5IGNyZWF0ZWQgYW5kIGFib3V0IHRvIGJlIG1vdW50ZWQuXG4gICAgICogVGhpcyBtYXkgaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBhbnkgZXh0ZXJuYWwgc3Vic2NyaXB0aW9ucyBvciBkYXRhIGNyZWF0ZWRcbiAgICAgKiBieSB0aGlzIG1ldGhvZCBtdXN0IGJlIGNsZWFuZWQgdXAgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YC5cbiAgICAgKlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgYW5kIGhhcyBhIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBIb3dldmVyLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgRE9NIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICAgKiBiZWVuIG1vdW50ZWQgKGluaXRpYWxpemVkIGFuZCByZW5kZXJlZCkgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVhY3QgdG8gYSBwcm9wIHRyYW5zaXRpb24gYnkgdXBkYXRpbmcgdGhlXG4gICAgICogc3RhdGUgdXNpbmcgYHRoaXMuc2V0U3RhdGVgLiBDdXJyZW50IHByb3BzIGFyZSBhY2Nlc3NlZCB2aWEgYHRoaXMucHJvcHNgLlxuICAgICAqXG4gICAgICogICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAgICogICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAqICAgICAgIGxpa2VzSW5jcmVhc2luZzogbmV4dFByb3BzLmxpa2VDb3VudCA+IHRoaXMucHJvcHMubGlrZUNvdW50XG4gICAgICogICAgIH0pO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogTk9URTogVGhlcmUgaXMgbm8gZXF1aXZhbGVudCBgY29tcG9uZW50V2lsbFJlY2VpdmVTdGF0ZWAuIEFuIGluY29taW5nIHByb3BcbiAgICAgKiB0cmFuc2l0aW9uIG1heSBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgYnV0IHRoZSBvcHBvc2l0ZSBpcyBub3QgdHJ1ZS4gSWYgeW91XG4gICAgICogbmVlZCBpdCwgeW91IGFyZSBwcm9iYWJseSBsb29raW5nIGZvciBgY29tcG9uZW50V2lsbFVwZGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hpbGUgZGVjaWRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZlxuICAgICAqIHJlY2VpdmluZyBuZXcgcHJvcHMsIHN0YXRlIGFuZC9vciBjb250ZXh0LlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gYHJldHVybiBmYWxzZWAgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHRoZVxuICAgICAqIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcy9zdGF0ZS9jb250ZXh0IHdpbGwgbm90IHJlcXVpcmUgYSBjb21wb25lbnRcbiAgICAgKiB1cGRhdGUuXG4gICAgICpcbiAgICAgKiAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAgICogICAgIHJldHVybiAhZXF1YWwobmV4dFByb3BzLCB0aGlzLnByb3BzKSB8fFxuICAgICAqICAgICAgICFlcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpIHx8XG4gICAgICogICAgICAgIWVxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgdXBkYXRlLlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogJ0RFRklORV9PTkNFJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIHVwZGF0ZSBkdWUgdG8gYSB0cmFuc2l0aW9uIGZyb21cbiAgICAgKiBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAgdG8gYG5leHRQcm9wc2AsIGBuZXh0U3RhdGVgXG4gICAgICogYW5kIGBuZXh0Q29udGV4dGAuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBwZXJmb3JtIHByZXBhcmF0aW9uIGJlZm9yZSBhbiB1cGRhdGUgb2NjdXJzLlxuICAgICAqXG4gICAgICogTk9URTogWW91ICoqY2Fubm90KiogdXNlIGB0aGlzLnNldFN0YXRlKClgIGluIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQncyBET00gcmVwcmVzZW50YXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAgICogYmVlbiB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByZXZQcm9wc1xuICAgICAqIEBwYXJhbSB7P29iamVjdH0gcHJldlN0YXRlXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q29udGV4dFxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50RGlkVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgYW5kIGhhdmVcbiAgICAgKiBpdHMgRE9NIHJlcHJlc2VudGF0aW9uIGRlc3Ryb3llZC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGRlYWxsb2NhdGUgYW55IGV4dGVybmFsIHJlc291cmNlcy5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoZXJlIGlzIG5vIGBjb21wb25lbnREaWRVbm1vdW50YCBzaW5jZSB5b3VyIGNvbXBvbmVudCB3aWxsIGhhdmUgYmVlblxuICAgICAqIGRlc3Ryb3llZCBieSB0aGF0IHBvaW50LlxuICAgICAqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlbWVudCBmb3IgKGRlcHJlY2F0ZWQpIGBjb21wb25lbnRXaWxsTW91bnRgLlxuICAgICAqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VtZW50IGZvciAoZGVwcmVjYXRlZCkgYGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNgLlxuICAgICAqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlbWVudCBmb3IgKGRlcHJlY2F0ZWQpIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gICAgLy8gPT09PSBBZHZhbmNlZCBtZXRob2RzID09PT1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGN1cnJlbnRseSBtb3VudGVkIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBvdmVycmlkYWJsZVxuICAgICAqL1xuICAgIHVwZGF0ZUNvbXBvbmVudDogJ09WRVJSSURFX0JBU0UnXG4gIH07XG5cbiAgLyoqXG4gICAqIFNpbWlsYXIgdG8gUmVhY3RDbGFzc0ludGVyZmFjZSBidXQgZm9yIHN0YXRpYyBtZXRob2RzLlxuICAgKi9cbiAgdmFyIFJlYWN0Q2xhc3NTdGF0aWNJbnRlcmZhY2UgPSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBhZnRlciBhIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgYW5kIHdoZW4gaXRcbiAgICAgKiByZWNlaXZlcyBuZXcgcHJvcHMuIFJldHVybiBhbiBvYmplY3QgdG8gdXBkYXRlIHN0YXRlIGluIHJlc3BvbnNlIHRvXG4gICAgICogcHJvcCBjaGFuZ2VzLiBSZXR1cm4gbnVsbCB0byBpbmRpY2F0ZSBubyBjaGFuZ2UgdG8gc3RhdGUuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcmV0dXJuZWQsIGl0cyBrZXlzIHdpbGwgYmUgbWVyZ2VkIGludG8gdGhlIGV4aXN0aW5nIHN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7b2JqZWN0IHx8IG51bGx9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiAnREVGSU5FX01BTllfTUVSR0VEJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gICAqXG4gICAqIEFsdGhvdWdoIHRoZXNlIGFyZSBkZWNsYXJlZCBsaWtlIGluc3RhbmNlIHByb3BlcnRpZXMgaW4gdGhlIHNwZWNpZmljYXRpb25cbiAgICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICAgKiBhbmQgYXJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZS4gRGVzcGl0ZVxuICAgKiBiZWluZyBzdGF0aWMsIHRoZXkgbXVzdCBiZSBkZWZpbmVkIG91dHNpZGUgb2YgdGhlIFwic3RhdGljc1wiIGtleSB1bmRlclxuICAgKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gICAqL1xuICB2YXIgUkVTRVJWRURfU1BFQ19LRVlTID0ge1xuICAgIGRpc3BsYXlOYW1lOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgfSxcbiAgICBtaXhpbnM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBtaXhpbnMpIHtcbiAgICAgIGlmIChtaXhpbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgbWl4aW5zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcywgJ2NoaWxkQ29udGV4dCcpO1xuICAgICAgfVxuICAgICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBfYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsXG4gICAgICAgIGNoaWxkQ29udGV4dFR5cGVzXG4gICAgICApO1xuICAgIH0sXG4gICAgY29udGV4dFR5cGVzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcywgJ2NvbnRleHQnKTtcbiAgICAgIH1cbiAgICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IF9hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMsXG4gICAgICAgIGNvbnRleHRUeXBlc1xuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgICAqIGF1dG9tYXRpYyBtZXJnaW5nLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGdldERlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihcbiAgICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsXG4gICAgICAgICAgZ2V0RGVmYXVsdFByb3BzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHM7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wVHlwZXM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzLCAncHJvcCcpO1xuICAgICAgfVxuICAgICAgQ29uc3RydWN0b3IucHJvcFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IucHJvcFR5cGVzLCBwcm9wVHlwZXMpO1xuICAgIH0sXG4gICAgc3RhdGljczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICAgIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKTtcbiAgICB9LFxuICAgIGF1dG9iaW5kOiBmdW5jdGlvbigpIHt9XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHR5cGVEZWYpIHtcbiAgICAgIGlmICh0eXBlRGVmLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gX2ludmFyaWFudCBzbyBjb21wb25lbnRzXG4gICAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgb25seSBpbiBfX0RFVl9fXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgIHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgK1xuICAgICAgICAgICAgICAnUmVhY3QuUHJvcFR5cGVzLicsXG4gICAgICAgICAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsXG4gICAgICAgICAgICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sXG4gICAgICAgICAgICBwcm9wTmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpIHtcbiAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgID8gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXVxuICAgICAgOiBudWxsO1xuXG4gICAgLy8gRGlzYWxsb3cgb3ZlcnJpZGluZyBvZiBiYXNlIGNsYXNzIG1ldGhvZHMgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgICBpZiAoUmVhY3RDbGFzc01peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBfaW52YXJpYW50KFxuICAgICAgICBzcGVjUG9saWN5ID09PSAnT1ZFUlJJREVfQkFTRScsXG4gICAgICAgICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgJyArXG4gICAgICAgICAgJ2Alc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzICcgK1xuICAgICAgICAgICdkbyBub3Qgb3ZlcmxhcCB3aXRoIFJlYWN0IG1ldGhvZHMuJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEaXNhbGxvdyBkZWZpbmluZyBtZXRob2RzIG1vcmUgdGhhbiBvbmNlIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgIHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScgfHwgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcsXG4gICAgICAgICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgK1xuICAgICAgICAgICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgJyArXG4gICAgICAgICAgJ3RvIGEgbWl4aW4uJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWl4aW4gaGVscGVyIHdoaWNoIGhhbmRsZXMgcG9saWN5IHZhbGlkYXRpb24gYW5kIHJlc2VydmVkXG4gICAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzZXMuXG4gICAqL1xuICBmdW5jdGlvbiBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYykge1xuICAgIGlmICghc3BlYykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHR5cGVvZlNwZWMgPSB0eXBlb2Ygc3BlYztcbiAgICAgICAgdmFyIGlzTWl4aW5WYWxpZCA9IHR5cGVvZlNwZWMgPT09ICdvYmplY3QnICYmIHNwZWMgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgaXNNaXhpblZhbGlkLFxuICAgICAgICAgICAgXCIlczogWW91J3JlIGF0dGVtcHRpbmcgdG8gaW5jbHVkZSBhIG1peGluIHRoYXQgaXMgZWl0aGVyIG51bGwgXCIgK1xuICAgICAgICAgICAgICAnb3Igbm90IGFuIG9iamVjdC4gQ2hlY2sgdGhlIG1peGlucyBpbmNsdWRlZCBieSB0aGUgY29tcG9uZW50LCAnICtcbiAgICAgICAgICAgICAgJ2FzIHdlbGwgYXMgYW55IG1peGlucyB0aGV5IGluY2x1ZGUgdGhlbXNlbHZlcy4gJyArXG4gICAgICAgICAgICAgICdFeHBlY3RlZCBvYmplY3QgYnV0IGdvdCAlcy4nLFxuICAgICAgICAgICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLFxuICAgICAgICAgICAgc3BlYyA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2ZTcGVjXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX2ludmFyaWFudChcbiAgICAgIHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nLFxuICAgICAgXCJSZWFjdENsYXNzOiBZb3UncmUgYXR0ZW1wdGluZyB0byBcIiArXG4gICAgICAgICd1c2UgYSBjb21wb25lbnQgY2xhc3Mgb3IgZnVuY3Rpb24gYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSAnICtcbiAgICAgICAgJ3JlZ3VsYXIgb2JqZWN0LidcbiAgICApO1xuICAgIF9pbnZhcmlhbnQoXG4gICAgICAhaXNWYWxpZEVsZW1lbnQoc3BlYyksXG4gICAgICBcIlJlYWN0Q2xhc3M6IFlvdSdyZSBhdHRlbXB0aW5nIHRvIFwiICtcbiAgICAgICAgJ3VzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LidcbiAgICApO1xuXG4gICAgdmFyIHByb3RvID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHZhciBhdXRvQmluZFBhaXJzID0gcHJvdG8uX19yZWFjdEF1dG9CaW5kUGFpcnM7XG5cbiAgICAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcbiAgICAvLyBjaGFpbmluZyBvcmRlciBpcyBhcHBsaWVkIHRvIG1ldGhvZHMgd2l0aCBERUZJTkVfTUFOWSBwb2xpY3ksIHdoZXRoZXJcbiAgICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cbiAgICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShNSVhJTlNfS0VZKSkge1xuICAgICAgUkVTRVJWRURfU1BFQ19LRVlTLm1peGlucyhDb25zdHJ1Y3Rvciwgc3BlYy5taXhpbnMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgICAgaWYgKCFzcGVjLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gTUlYSU5TX0tFWSkge1xuICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBtaXhpbnMgaW4gYSBzcGVjaWFsIGNhc2UgYWJvdmUuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xuICAgICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSk7XG5cbiAgICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgUkVTRVJWRURfU1BFQ19LRVlTW25hbWVdKENvbnN0cnVjdG9yLCBwcm9wZXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBtZW1iZXIgbWV0aG9kcyBzaG91bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgYm91bmQ6XG4gICAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q2xhc3MgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxuICAgICAgICAvLyAyLiBPdmVycmlkZGVuIG1ldGhvZHMgKHRoYXQgd2VyZSBtaXhlZCBpbikuXG4gICAgICAgIHZhciBpc1JlYWN0Q2xhc3NNZXRob2QgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID1cbiAgICAgICAgICBpc0Z1bmN0aW9uICYmXG4gICAgICAgICAgIWlzUmVhY3RDbGFzc01ldGhvZCAmJlxuICAgICAgICAgICFpc0FscmVhZHlEZWZpbmVkICYmXG4gICAgICAgICAgc3BlYy5hdXRvYmluZCAhPT0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNob3VsZEF1dG9CaW5kKSB7XG4gICAgICAgICAgYXV0b0JpbmRQYWlycy5wdXNoKG5hbWUsIHByb3BlcnR5KTtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07XG5cbiAgICAgICAgICAgIC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlLlxuICAgICAgICAgICAgX2ludmFyaWFudChcbiAgICAgICAgICAgICAgaXNSZWFjdENsYXNzTWV0aG9kICYmXG4gICAgICAgICAgICAgICAgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnIHx8XG4gICAgICAgICAgICAgICAgICBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknKSxcbiAgICAgICAgICAgICAgJ1JlYWN0Q2xhc3M6IFVuZXhwZWN0ZWQgc3BlYyBwb2xpY3kgJXMgZm9yIGtleSAlcyAnICtcbiAgICAgICAgICAgICAgICAnd2hlbiBtaXhpbmcgaW4gY29tcG9uZW50IHNwZWNzLicsXG4gICAgICAgICAgICAgIHNwZWNQb2xpY3ksXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEZvciBtZXRob2RzIHdoaWNoIGFyZSBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLCBjYWxsIHRoZSBleGlzdGluZ1xuICAgICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJykge1xuICAgICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gQWRkIHZlcmJvc2UgZGlzcGxheU5hbWUgdG8gdGhlIGZ1bmN0aW9uLCB3aGljaCBoZWxwcyB3aGVuIGxvb2tpbmdcbiAgICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgICBwcm90b1tuYW1lXS5kaXNwbGF5TmFtZSA9IHNwZWMuZGlzcGxheU5hbWUgKyAnXycgKyBuYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICBpZiAoIXN0YXRpY3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICAgIHZhciBwcm9wZXJ0eSA9IHN0YXRpY3NbbmFtZV07XG4gICAgICBpZiAoIXN0YXRpY3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc1Jlc2VydmVkID0gbmFtZSBpbiBSRVNFUlZFRF9TUEVDX0tFWVM7XG4gICAgICBfaW52YXJpYW50KFxuICAgICAgICAhaXNSZXNlcnZlZCxcbiAgICAgICAgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYSByZXNlcnZlZCAnICtcbiAgICAgICAgICAncHJvcGVydHksIGAlc2AsIHRoYXQgc2hvdWxkblxcJ3QgYmUgb24gdGhlIFwic3RhdGljc1wiIGtleS4gRGVmaW5lIGl0ICcgK1xuICAgICAgICAgICdhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBpbnN0ZWFkOyBpdCB3aWxsIHN0aWxsIGJlIGFjY2Vzc2libGUgb24gdGhlICcgK1xuICAgICAgICAgICdjb25zdHJ1Y3Rvci4nLFxuICAgICAgICBuYW1lXG4gICAgICApO1xuXG4gICAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IG5hbWUgaW4gQ29uc3RydWN0b3I7XG4gICAgICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NTdGF0aWNJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICA/IFJlYWN0Q2xhc3NTdGF0aWNJbnRlcmZhY2VbbmFtZV1cbiAgICAgICAgICA6IG51bGw7XG5cbiAgICAgICAgX2ludmFyaWFudChcbiAgICAgICAgICBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJyxcbiAgICAgICAgICAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSAnICtcbiAgICAgICAgICAgICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSAnICtcbiAgICAgICAgICAgICdkdWUgdG8gYSBtaXhpbi4nLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgKTtcblxuICAgICAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKENvbnN0cnVjdG9yW25hbWVdLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IHByb3BlcnR5O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSB0d28gb2JqZWN0cywgYnV0IHRocm93IGlmIGJvdGggY29udGFpbiB0aGUgc2FtZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvbmUgVGhlIGZpcnN0IG9iamVjdCwgd2hpY2ggaXMgbXV0YXRlZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHR3byBUaGUgc2Vjb25kIG9iamVjdFxuICAgKiBAcmV0dXJuIHtvYmplY3R9IG9uZSBhZnRlciBpdCBoYXMgYmVlbiBtdXRhdGVkIHRvIGNvbnRhaW4gZXZlcnl0aGluZyBpbiB0d28uXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKG9uZSwgdHdvKSB7XG4gICAgX2ludmFyaWFudChcbiAgICAgIG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcsXG4gICAgICAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBDYW5ub3QgbWVyZ2Ugbm9uLW9iamVjdHMuJ1xuICAgICk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdHdvKSB7XG4gICAgICBpZiAodHdvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgX2ludmFyaWFudChcbiAgICAgICAgICBvbmVba2V5XSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6ICcgK1xuICAgICAgICAgICAgJ1RyaWVkIHRvIG1lcmdlIHR3byBvYmplY3RzIHdpdGggdGhlIHNhbWUga2V5OiBgJXNgLiBUaGlzIGNvbmZsaWN0ICcgK1xuICAgICAgICAgICAgJ21heSBiZSBkdWUgdG8gYSBtaXhpbjsgaW4gcGFydGljdWxhciwgdGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHR3byAnICtcbiAgICAgICAgICAgICdnZXRJbml0aWFsU3RhdGUoKSBvciBnZXREZWZhdWx0UHJvcHMoKSBtZXRob2RzIHJldHVybmluZyBvYmplY3RzICcgK1xuICAgICAgICAgICAgJ3dpdGggY2xhc2hpbmcga2V5cy4nLFxuICAgICAgICAgIGtleVxuICAgICAgICApO1xuICAgICAgICBvbmVba2V5XSA9IHR3b1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb25lO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgbWVyZ2VzIHRoZWlyIHJldHVybiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ob25lLCB0d28pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkUmVzdWx0KCkge1xuICAgICAgdmFyIGEgPSBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHZhciBiID0gdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG4gICAgICB2YXIgYyA9IHt9O1xuICAgICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBhKTtcbiAgICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYik7XG4gICAgICByZXR1cm4gYztcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgaWdub3JlcyB0aGVpciByZXR1cm4gdmFsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICAgIG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgYm91bmQgbWV0aG9kLlxuICAgKi9cbiAgZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XG4gICAgdmFyIGJvdW5kTWV0aG9kID0gbWV0aG9kLmJpbmQoY29tcG9uZW50KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IG51bGw7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICAgIHZhciBfYmluZCA9IGJvdW5kTWV0aG9kLmJpbmQ7XG4gICAgICBib3VuZE1ldGhvZC5iaW5kID0gZnVuY3Rpb24obmV3VGhpcykge1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksXG4gICAgICAgICAgICBfa2V5ID0gMTtcbiAgICAgICAgICBfa2V5IDwgX2xlbjtcbiAgICAgICAgICBfa2V5KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxuICAgICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgICAgLy8gbGV0J3Mgd2Fybi5cbiAgICAgICAgaWYgKG5ld1RoaXMgIT09IGNvbXBvbmVudCAmJiBuZXdUaGlzICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAnYmluZCgpOiBSZWFjdCBjb21wb25lbnQgbWV0aG9kcyBtYXkgb25seSBiZSBib3VuZCB0byB0aGUgJyArXG4gICAgICAgICAgICAgICAgJ2NvbXBvbmVudCBpbnN0YW5jZS4gU2VlICVzJyxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAnYmluZCgpOiBZb3UgYXJlIGJpbmRpbmcgYSBjb21wb25lbnQgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuICcgK1xuICAgICAgICAgICAgICAgICdSZWFjdCBkb2VzIHRoaXMgZm9yIHlvdSBhdXRvbWF0aWNhbGx5IGluIGEgaGlnaC1wZXJmb3JtYW5jZSAnICtcbiAgICAgICAgICAgICAgICAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuICAgICAgICByZXR1cm4gcmVib3VuZE1ldGhvZDtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBhbGwgYXV0by1ib3VuZCBtZXRob2RzIGluIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gICAqL1xuICBmdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2RzKGNvbXBvbmVudCkge1xuICAgIHZhciBwYWlycyA9IGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2YXIgYXV0b0JpbmRLZXkgPSBwYWlyc1tpXTtcbiAgICAgIHZhciBtZXRob2QgPSBwYWlyc1tpICsgMV07XG4gICAgICBjb21wb25lbnRbYXV0b0JpbmRLZXldID0gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKTtcbiAgICB9XG4gIH1cblxuICB2YXIgSXNNb3VudGVkUHJlTWl4aW4gPSB7XG4gICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fX2lzTW91bnRlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIHZhciBJc01vdW50ZWRQb3N0TWl4aW4gPSB7XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIG1vcmUgdG8gdGhlIFJlYWN0Q2xhc3MgYmFzZSBjbGFzcy4gVGhlc2UgYXJlIGFsbCBsZWdhY3kgZmVhdHVyZXMgYW5kXG4gICAqIHRoZXJlZm9yZSBub3QgYWxyZWFkeSBwYXJ0IG9mIHRoZSBtb2Rlcm4gUmVhY3RDb21wb25lbnQuXG4gICAqL1xuICB2YXIgUmVhY3RDbGFzc01peGluID0ge1xuICAgIC8qKlxuICAgICAqIFRPRE86IFRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGJlY2F1c2Ugc3RhdGUgc2hvdWxkIGFsd2F5cyBrZWVwIGEgY29uc2lzdGVudFxuICAgICAqIHR5cGUgc2lnbmF0dXJlIGFuZCB0aGUgb25seSB1c2UgY2FzZSBmb3IgdGhpcywgaXMgdG8gYXZvaWQgdGhhdC5cbiAgICAgKi9cbiAgICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uKG5ld1N0YXRlLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUodGhpcywgbmV3U3RhdGUsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAZmluYWxcbiAgICAgKi9cbiAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICB0aGlzLl9fZGlkV2FybklzTW91bnRlZCxcbiAgICAgICAgICAnJXM6IGlzTW91bnRlZCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgJyArXG4gICAgICAgICAgICAnc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiBjb21wb25lbnRXaWxsVW5tb3VudCB0byAnICtcbiAgICAgICAgICAgICdwcmV2ZW50IG1lbW9yeSBsZWFrcy4nLFxuICAgICAgICAgICh0aGlzLmNvbnN0cnVjdG9yICYmIHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWUpIHx8XG4gICAgICAgICAgICB0aGlzLm5hbWUgfHxcbiAgICAgICAgICAgICdDb21wb25lbnQnXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX19kaWRXYXJuSXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIXRoaXMuX19pc01vdW50ZWQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBSZWFjdENsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24oKSB7fTtcbiAgX2Fzc2lnbihcbiAgICBSZWFjdENsYXNzQ29tcG9uZW50LnByb3RvdHlwZSxcbiAgICBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsXG4gICAgUmVhY3RDbGFzc01peGluXG4gICk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgY29tcG9uZW50IGNsYXNzIGdpdmVuIGEgY2xhc3Mgc3BlY2lmaWNhdGlvbi5cbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzcGVjIENsYXNzIHNwZWNpZmljYXRpb24gKHdoaWNoIG11c3QgZGVmaW5lIGByZW5kZXJgKS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IENvbXBvbmVudCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2xhc3Moc3BlYykge1xuICAgIC8vIFRvIGtlZXAgb3VyIHdhcm5pbmdzIG1vcmUgdW5kZXJzdGFuZGFibGUsIHdlJ2xsIHVzZSBhIGxpdHRsZSBoYWNrIGhlcmUgdG9cbiAgICAvLyBlbnN1cmUgdGhhdCBDb25zdHJ1Y3Rvci5uYW1lICE9PSAnQ29uc3RydWN0b3InLiBUaGlzIG1ha2VzIHN1cmUgd2UgZG9uJ3RcbiAgICAvLyB1bm5lY2Vzc2FyaWx5IGlkZW50aWZ5IGEgY2xhc3Mgd2l0aG91dCBkaXNwbGF5TmFtZSBhcyAnQ29uc3RydWN0b3InLlxuICAgIHZhciBDb25zdHJ1Y3RvciA9IGlkZW50aXR5KGZ1bmN0aW9uKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICAvLyBUaGlzIGNvbnN0cnVjdG9yIGdldHMgb3ZlcnJpZGRlbiBieSBtb2Nrcy4gVGhlIGFyZ3VtZW50IGlzIHVzZWRcbiAgICAgIC8vIGJ5IG1vY2tzIHRvIGFzc2VydCBvbiB3aGF0IGdldHMgbW91bnRlZC5cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICB0aGlzIGluc3RhbmNlb2YgQ29uc3RydWN0b3IsXG4gICAgICAgICAgJ1NvbWV0aGluZyBpcyBjYWxsaW5nIGEgUmVhY3QgY29tcG9uZW50IGRpcmVjdGx5LiBVc2UgYSBmYWN0b3J5IG9yICcgK1xuICAgICAgICAgICAgJ0pTWCBpbnN0ZWFkLiBTZWU6IGh0dHBzOi8vZmIubWUvcmVhY3QtbGVnYWN5ZmFjdG9yeSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2lyZSB1cCBhdXRvLWJpbmRpbmdcbiAgICAgIGlmICh0aGlzLl9fcmVhY3RBdXRvQmluZFBhaXJzLmxlbmd0aCkge1xuICAgICAgICBiaW5kQXV0b0JpbmRNZXRob2RzKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG4gICAgICB0aGlzLnN0YXRlID0gbnVsbDtcblxuICAgICAgLy8gUmVhY3RDbGFzc2VzIGRvZXNuJ3QgaGF2ZSBjb25zdHJ1Y3RvcnMuIEluc3RlYWQsIHRoZXkgdXNlIHRoZVxuICAgICAgLy8gZ2V0SW5pdGlhbFN0YXRlIGFuZCBjb21wb25lbnRXaWxsTW91bnQgbWV0aG9kcyBmb3IgaW5pdGlhbGl6YXRpb24uXG5cbiAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSA/IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkgOiBudWxsO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIHRoaXMuZ2V0SW5pdGlhbFN0YXRlLl9pc01vY2tGdW5jdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX2ludmFyaWFudChcbiAgICAgICAgdHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSxcbiAgICAgICAgJyVzLmdldEluaXRpYWxTdGF0ZSgpOiBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgbnVsbCcsXG4gICAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgfSk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3IFJlYWN0Q2xhc3NDb21wb25lbnQoKTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX19yZWFjdEF1dG9CaW5kUGFpcnMgPSBbXTtcblxuICAgIGluamVjdGVkTWl4aW5zLmZvckVhY2gobWl4U3BlY0ludG9Db21wb25lbnQuYmluZChudWxsLCBDb25zdHJ1Y3RvcikpO1xuXG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIElzTW91bnRlZFByZU1peGluKTtcbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYyk7XG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIElzTW91bnRlZFBvc3RNaXhpbik7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0UHJvcHMgcHJvcGVydHkgYWZ0ZXIgYWxsIG1peGlucyBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcyA9IENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcygpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZSBvZiB0aGVzZSBtZXRob2QgbmFtZXMgaXMgb2ssXG4gICAgICAvLyBzaW5jZSBpdCdzIHVzZWQgd2l0aCBjcmVhdGVDbGFzcy4gSWYgaXQncyBub3QsIHRoZW4gaXQncyBsaWtlbHkgYVxuICAgICAgLy8gbWlzdGFrZSBzbyB3ZSdsbCB3YXJuIHlvdSB0byB1c2UgdGhlIHN0YXRpYyBwcm9wZXJ0eSwgcHJvcGVydHlcbiAgICAgIC8vIGluaXRpYWxpemVyIG9yIGNvbnN0cnVjdG9yIHJlc3BlY3RpdmVseS5cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2ludmFyaWFudChcbiAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIsXG4gICAgICAnY3JlYXRlQ2xhc3MoLi4uKTogQ2xhc3Mgc3BlY2lmaWNhdGlvbiBtdXN0IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC4nXG4gICAgKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSxcbiAgICAgICAgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArXG4gICAgICAgICAgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgK1xuICAgICAgICAgICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArXG4gICAgICAgICAgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsXG4gICAgICAgIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50J1xuICAgICAgKTtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgICFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyxcbiAgICAgICAgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArXG4gICAgICAgICAgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLFxuICAgICAgICBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCdcbiAgICAgICk7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLFxuICAgICAgICAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiAnICtcbiAgICAgICAgICAnRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JyxcbiAgICAgICAgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlQ2xhc3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1yZWFjdC1jbGFzcy9mYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSIsImV4cG9ydCBjb25zdCB1cGRhdGVTZXR0aW5nID0gKCBzZXR0aW5nLCB2YWx1ZSApID0+IGRpc3BhdGNoID0+IHtcblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZSB3aXRoIENoYW5nZXNcblx0d2luZG93LmZvcm1pbmF0b3JDaGFuZ2VzLnNldHRpbmdzID0gdHJ1ZTtcblxuXHRkaXNwYXRjaCgge1xuXHRcdHR5cGU6ICdVUERBVEVfU0VUVElORycsXG5cdFx0c2V0dGluZzogc2V0dGluZyxcblx0XHR2YWx1ZTogdmFsdWVcblx0fSApO1xufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZVNldHRpbmdzID0gKCBzZXR0aW5ncyApID0+IGRpc3BhdGNoID0+IHtcblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZSB3aXRoIENoYW5nZXNcblx0d2luZG93LmZvcm1pbmF0b3JDaGFuZ2VzLnNldHRpbmdzID0gdHJ1ZTtcblxuXHRkaXNwYXRjaCgge1xuXHRcdHR5cGU6ICdVUERBVEVfU0VUVElOR1MnLFxuXHRcdHNldHRpbmdzOiBzZXR0aW5ncyxcblx0fSApO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlc2V0U2V0dGluZ3MgPSAoIHNldHRpbmdzICkgPT4gZGlzcGF0Y2ggPT4ge1xuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlIHdpdGggQ2hhbmdlc1xuXHR3aW5kb3cuZm9ybWluYXRvckNoYW5nZXMuc2V0dGluZ3MgPSB0cnVlO1xuXG5cdGRpc3BhdGNoKCB7XG5cdFx0dHlwZTogJ1JFU0VUX1NFVFRJTkdTJyxcblx0XHRzZXR0aW5nczogc2V0dGluZ3MsXG5cdH0gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzYXZlQnVpbGRlciA9ICggc2V0dGluZywgdmFsdWUgKSA9PiBkaXNwYXRjaCA9PiB7XG5cdC8vIEVtcHR5IGdsb2JhbCBjaGFuZ2VkIHZhcmlhYmxlXG5cdHdpbmRvdy5mb3JtaW5hdG9yQ2hhbmdlcyA9IHtcblx0XHRmaWVsZHM6IFtdLFxuXHRcdHNldHRpbmdzOiBmYWxzZSxcblx0XHRzYXZlZDogdHJ1ZSxcblx0fTtcblxuXHRkaXNwYXRjaCgge1xuXHRcdHR5cGU6ICdVUERBVEVfU0VUVElORycsXG5cdFx0c2V0dGluZzogc2V0dGluZyxcblx0XHR2YWx1ZTogdmFsdWVcblx0fSApO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2FjdGlvbnMvc2V0dGluZ3MuanMiLCJmdW5jdGlvbiBjcmVhdGVUaHVua01pZGRsZXdhcmUoZXh0cmFBcmd1bWVudCkge1xuICByZXR1cm4gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZGlzcGF0Y2ggPSBfcmVmLmRpc3BhdGNoLFxuICAgICAgICBnZXRTdGF0ZSA9IF9yZWYuZ2V0U3RhdGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBhY3Rpb24oZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYUFyZ3VtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59XG5cbnZhciB0aHVuayA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZSgpO1xudGh1bmsud2l0aEV4dHJhQXJndW1lbnQgPSBjcmVhdGVUaHVua01pZGRsZXdhcmU7XG5cbmV4cG9ydCBkZWZhdWx0IHRodW5rO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlZHV4LXRodW5rL2VzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB7IENvbXBvbmVudCwgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgc3RvcmVTaGFwZSwgc3Vic2NyaXB0aW9uU2hhcGUgfSBmcm9tICcuLi91dGlscy9Qcm9wVHlwZXMnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi4vdXRpbHMvd2FybmluZyc7XG5cbnZhciBkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSA9IGZhbHNlO1xuZnVuY3Rpb24gd2FybkFib3V0UmVjZWl2aW5nU3RvcmUoKSB7XG4gIGlmIChkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSA9IHRydWU7XG5cbiAgd2FybmluZygnPFByb3ZpZGVyPiBkb2VzIG5vdCBzdXBwb3J0IGNoYW5naW5nIGBzdG9yZWAgb24gdGhlIGZseS4gJyArICdJdCBpcyBtb3N0IGxpa2VseSB0aGF0IHlvdSBzZWUgdGhpcyBlcnJvciBiZWNhdXNlIHlvdSB1cGRhdGVkIHRvICcgKyAnUmVkdXggMi54IGFuZCBSZWFjdCBSZWR1eCAyLnggd2hpY2ggbm8gbG9uZ2VyIGhvdCByZWxvYWQgcmVkdWNlcnMgJyArICdhdXRvbWF0aWNhbGx5LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtcmVkdXgvcmVsZWFzZXMvJyArICd0YWcvdjIuMC4wIGZvciB0aGUgbWlncmF0aW9uIGluc3RydWN0aW9ucy4nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVByb3ZpZGVyKCkge1xuICB2YXIgX1Byb3ZpZGVyJGNoaWxkQ29udGV4O1xuXG4gIHZhciBzdG9yZUtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3N0b3JlJztcbiAgdmFyIHN1YktleSA9IGFyZ3VtZW50c1sxXTtcblxuICB2YXIgc3Vic2NyaXB0aW9uS2V5ID0gc3ViS2V5IHx8IHN0b3JlS2V5ICsgJ1N1YnNjcmlwdGlvbic7XG5cbiAgdmFyIFByb3ZpZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoUHJvdmlkZXIsIF9Db21wb25lbnQpO1xuXG4gICAgUHJvdmlkZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW3N0b3JlS2V5XSA9IHRoaXNbc3RvcmVLZXldLCBfcmVmW3N1YnNjcmlwdGlvbktleV0gPSBudWxsLCBfcmVmO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBQcm92aWRlcihwcm9wcywgY29udGV4dCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb3ZpZGVyKTtcblxuICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSk7XG5cbiAgICAgIF90aGlzW3N0b3JlS2V5XSA9IHByb3BzLnN0b3JlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFByb3ZpZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFByb3ZpZGVyO1xuICB9KENvbXBvbmVudCk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBQcm92aWRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcbiAgICAgIGlmICh0aGlzW3N0b3JlS2V5XSAhPT0gbmV4dFByb3BzLnN0b3JlKSB7XG4gICAgICAgIHdhcm5BYm91dFJlY2VpdmluZ1N0b3JlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIFByb3ZpZGVyLnByb3BUeXBlcyA9IHtcbiAgICBzdG9yZTogc3RvcmVTaGFwZS5pc1JlcXVpcmVkLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuZWxlbWVudC5pc1JlcXVpcmVkXG4gIH07XG4gIFByb3ZpZGVyLmNoaWxkQ29udGV4dFR5cGVzID0gKF9Qcm92aWRlciRjaGlsZENvbnRleCA9IHt9LCBfUHJvdmlkZXIkY2hpbGRDb250ZXhbc3RvcmVLZXldID0gc3RvcmVTaGFwZS5pc1JlcXVpcmVkLCBfUHJvdmlkZXIkY2hpbGRDb250ZXhbc3Vic2NyaXB0aW9uS2V5XSA9IHN1YnNjcmlwdGlvblNoYXBlLCBfUHJvdmlkZXIkY2hpbGRDb250ZXgpO1xuXG4gIHJldHVybiBQcm92aWRlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUHJvdmlkZXIoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL1Byb3ZpZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgcHJvcCBvbiBgJyArIGNvbXBvbmVudE5hbWUgICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAnICtcbiAgICAgICAgICAgIGxvY2F0aW9uICsgJyBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJyArIHR5cGVvZiBlcnJvciArICcuICcgK1xuICAgICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArXG4gICAgICAgICAgICAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLidcbiAgICAgICAgICApXG5cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge31cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIHRocm93IGVycjtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW0sXG4gICAgZXhhY3Q6IGdldFNoaW1cbiAgfTtcblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGVtcHR5RnVuY3Rpb247XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLy8gZW5jYXBzdWxhdGVzIHRoZSBzdWJzY3JpcHRpb24gbG9naWMgZm9yIGNvbm5lY3RpbmcgYSBjb21wb25lbnQgdG8gdGhlIHJlZHV4IHN0b3JlLCBhc1xuLy8gd2VsbCBhcyBuZXN0aW5nIHN1YnNjcmlwdGlvbnMgb2YgZGVzY2VuZGFudCBjb21wb25lbnRzLCBzbyB0aGF0IHdlIGNhbiBlbnN1cmUgdGhlXG4vLyBhbmNlc3RvciBjb21wb25lbnRzIHJlLXJlbmRlciBiZWZvcmUgZGVzY2VuZGFudHNcblxudmFyIENMRUFSRUQgPSBudWxsO1xudmFyIG51bGxMaXN0ZW5lcnMgPSB7XG4gIG5vdGlmeTogZnVuY3Rpb24gbm90aWZ5KCkge31cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpIHtcbiAgLy8gdGhlIGN1cnJlbnQvbmV4dCBwYXR0ZXJuIGlzIGNvcGllZCBmcm9tIHJlZHV4J3MgY3JlYXRlU3RvcmUgY29kZS5cbiAgLy8gVE9ETzogcmVmYWN0b3IrZXhwb3NlIHRoYXQgY29kZSB0byBiZSByZXVzYWJsZSBoZXJlP1xuICB2YXIgY3VycmVudCA9IFtdO1xuICB2YXIgbmV4dCA9IFtdO1xuXG4gIHJldHVybiB7XG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgbmV4dCA9IENMRUFSRUQ7XG4gICAgICBjdXJyZW50ID0gQ0xFQVJFRDtcbiAgICB9LFxuICAgIG5vdGlmeTogZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnQgPSBuZXh0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGlzdGVuZXJzW2ldKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0sXG4gICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgaWYgKG5leHQgPT09IGN1cnJlbnQpIG5leHQgPSBjdXJyZW50LnNsaWNlKCk7XG4gICAgICBuZXh0LnB1c2gobGlzdGVuZXIpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICghaXNTdWJzY3JpYmVkIHx8IGN1cnJlbnQgPT09IENMRUFSRUQpIHJldHVybjtcbiAgICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG5leHQgPT09IGN1cnJlbnQpIG5leHQgPSBjdXJyZW50LnNsaWNlKCk7XG4gICAgICAgIG5leHQuc3BsaWNlKG5leHQuaW5kZXhPZihsaXN0ZW5lciksIDEpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbihzdG9yZSwgcGFyZW50U3ViLCBvblN0YXRlQ2hhbmdlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnNjcmlwdGlvbik7XG5cbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5wYXJlbnRTdWIgPSBwYXJlbnRTdWI7XG4gICAgdGhpcy5vblN0YXRlQ2hhbmdlID0gb25TdGF0ZUNoYW5nZTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gbnVsbDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gIH1cblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFkZE5lc3RlZFN1YiA9IGZ1bmN0aW9uIGFkZE5lc3RlZFN1YihsaXN0ZW5lcikge1xuICAgIHRoaXMudHJ5U3Vic2NyaWJlKCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLnN1YnNjcmliZShsaXN0ZW5lcik7XG4gIH07XG5cbiAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5ub3RpZnlOZXN0ZWRTdWJzID0gZnVuY3Rpb24gbm90aWZ5TmVzdGVkU3VicygpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5ub3RpZnkoKTtcbiAgfTtcblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmlzU3Vic2NyaWJlZCA9IGZ1bmN0aW9uIGlzU3Vic2NyaWJlZCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLnVuc3Vic2NyaWJlKTtcbiAgfTtcblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnRyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIHRyeVN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSB0aGlzLnBhcmVudFN1YiA/IHRoaXMucGFyZW50U3ViLmFkZE5lc3RlZFN1Yih0aGlzLm9uU3RhdGVDaGFuZ2UpIDogdGhpcy5zdG9yZS5zdWJzY3JpYmUodGhpcy5vblN0YXRlQ2hhbmdlKTtcblxuICAgICAgdGhpcy5saXN0ZW5lcnMgPSBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKTtcbiAgICB9XG4gIH07XG5cbiAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS50cnlVbnN1YnNjcmliZSA9IGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xuICAgIGlmICh0aGlzLnVuc3Vic2NyaWJlKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlID0gbnVsbDtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICB0aGlzLmxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTdWJzY3JpcHRpb247XG59KCk7XG5cbmV4cG9ydCB7IFN1YnNjcmlwdGlvbiBhcyBkZWZhdWx0IH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvU3Vic2NyaXB0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmltcG9ydCBjb25uZWN0QWR2YW5jZWQgZnJvbSAnLi4vY29tcG9uZW50cy9jb25uZWN0QWR2YW5jZWQnO1xuaW1wb3J0IHNoYWxsb3dFcXVhbCBmcm9tICcuLi91dGlscy9zaGFsbG93RXF1YWwnO1xuaW1wb3J0IGRlZmF1bHRNYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMgZnJvbSAnLi9tYXBEaXNwYXRjaFRvUHJvcHMnO1xuaW1wb3J0IGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMgZnJvbSAnLi9tYXBTdGF0ZVRvUHJvcHMnO1xuaW1wb3J0IGRlZmF1bHRNZXJnZVByb3BzRmFjdG9yaWVzIGZyb20gJy4vbWVyZ2VQcm9wcyc7XG5pbXBvcnQgZGVmYXVsdFNlbGVjdG9yRmFjdG9yeSBmcm9tICcuL3NlbGVjdG9yRmFjdG9yeSc7XG5cbi8qXG4gIGNvbm5lY3QgaXMgYSBmYWNhZGUgb3ZlciBjb25uZWN0QWR2YW5jZWQuIEl0IHR1cm5zIGl0cyBhcmdzIGludG8gYSBjb21wYXRpYmxlXG4gIHNlbGVjdG9yRmFjdG9yeSwgd2hpY2ggaGFzIHRoZSBzaWduYXR1cmU6XG5cbiAgICAoZGlzcGF0Y2gsIG9wdGlvbnMpID0+IChuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykgPT4gbmV4dEZpbmFsUHJvcHNcbiAgXG4gIGNvbm5lY3QgcGFzc2VzIGl0cyBhcmdzIHRvIGNvbm5lY3RBZHZhbmNlZCBhcyBvcHRpb25zLCB3aGljaCB3aWxsIGluIHR1cm4gcGFzcyB0aGVtIHRvXG4gIHNlbGVjdG9yRmFjdG9yeSBlYWNoIHRpbWUgYSBDb25uZWN0IGNvbXBvbmVudCBpbnN0YW5jZSBpcyBpbnN0YW50aWF0ZWQgb3IgaG90IHJlbG9hZGVkLlxuXG4gIHNlbGVjdG9yRmFjdG9yeSByZXR1cm5zIGEgZmluYWwgcHJvcHMgc2VsZWN0b3IgZnJvbSBpdHMgbWFwU3RhdGVUb1Byb3BzLFxuICBtYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzLCBtZXJnZVByb3BzLFxuICBtZXJnZVByb3BzRmFjdG9yaWVzLCBhbmQgcHVyZSBhcmdzLlxuXG4gIFRoZSByZXN1bHRpbmcgZmluYWwgcHJvcHMgc2VsZWN0b3IgaXMgY2FsbGVkIGJ5IHRoZSBDb25uZWN0IGNvbXBvbmVudCBpbnN0YW5jZSB3aGVuZXZlclxuICBpdCByZWNlaXZlcyBuZXcgcHJvcHMgb3Igc3RvcmUgc3RhdGUuXG4gKi9cblxuZnVuY3Rpb24gbWF0Y2goYXJnLCBmYWN0b3JpZXMsIG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IGZhY3Rvcmllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciByZXN1bHQgPSBmYWN0b3JpZXNbaV0oYXJnKTtcbiAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgb3B0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBvZiB0eXBlICcgKyB0eXBlb2YgYXJnICsgJyBmb3IgJyArIG5hbWUgKyAnIGFyZ3VtZW50IHdoZW4gY29ubmVjdGluZyBjb21wb25lbnQgJyArIG9wdGlvbnMud3JhcHBlZENvbXBvbmVudE5hbWUgKyAnLicpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHJpY3RFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuXG4vLyBjcmVhdGVDb25uZWN0IHdpdGggZGVmYXVsdCBhcmdzIGJ1aWxkcyB0aGUgJ29mZmljaWFsJyBjb25uZWN0IGJlaGF2aW9yLiBDYWxsaW5nIGl0IHdpdGhcbi8vIGRpZmZlcmVudCBvcHRpb25zIG9wZW5zIHVwIHNvbWUgdGVzdGluZyBhbmQgZXh0ZW5zaWJpbGl0eSBzY2VuYXJpb3NcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb25uZWN0KCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBfcmVmJGNvbm5lY3RIT0MgPSBfcmVmLmNvbm5lY3RIT0MsXG4gICAgICBjb25uZWN0SE9DID0gX3JlZiRjb25uZWN0SE9DID09PSB1bmRlZmluZWQgPyBjb25uZWN0QWR2YW5jZWQgOiBfcmVmJGNvbm5lY3RIT0MsXG4gICAgICBfcmVmJG1hcFN0YXRlVG9Qcm9wc0YgPSBfcmVmLm1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyxcbiAgICAgIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyA9IF9yZWYkbWFwU3RhdGVUb1Byb3BzRiA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyA6IF9yZWYkbWFwU3RhdGVUb1Byb3BzRixcbiAgICAgIF9yZWYkbWFwRGlzcGF0Y2hUb1BybyA9IF9yZWYubWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzLFxuICAgICAgbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzID0gX3JlZiRtYXBEaXNwYXRjaFRvUHJvID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzIDogX3JlZiRtYXBEaXNwYXRjaFRvUHJvLFxuICAgICAgX3JlZiRtZXJnZVByb3BzRmFjdG9yID0gX3JlZi5tZXJnZVByb3BzRmFjdG9yaWVzLFxuICAgICAgbWVyZ2VQcm9wc0ZhY3RvcmllcyA9IF9yZWYkbWVyZ2VQcm9wc0ZhY3RvciA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1lcmdlUHJvcHNGYWN0b3JpZXMgOiBfcmVmJG1lcmdlUHJvcHNGYWN0b3IsXG4gICAgICBfcmVmJHNlbGVjdG9yRmFjdG9yeSA9IF9yZWYuc2VsZWN0b3JGYWN0b3J5LFxuICAgICAgc2VsZWN0b3JGYWN0b3J5ID0gX3JlZiRzZWxlY3RvckZhY3RvcnkgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRTZWxlY3RvckZhY3RvcnkgOiBfcmVmJHNlbGVjdG9yRmFjdG9yeTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcykge1xuICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge30sXG4gICAgICAgIF9yZWYyJHB1cmUgPSBfcmVmMi5wdXJlLFxuICAgICAgICBwdXJlID0gX3JlZjIkcHVyZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYyJHB1cmUsXG4gICAgICAgIF9yZWYyJGFyZVN0YXRlc0VxdWFsID0gX3JlZjIuYXJlU3RhdGVzRXF1YWwsXG4gICAgICAgIGFyZVN0YXRlc0VxdWFsID0gX3JlZjIkYXJlU3RhdGVzRXF1YWwgPT09IHVuZGVmaW5lZCA/IHN0cmljdEVxdWFsIDogX3JlZjIkYXJlU3RhdGVzRXF1YWwsXG4gICAgICAgIF9yZWYyJGFyZU93blByb3BzRXF1YSA9IF9yZWYyLmFyZU93blByb3BzRXF1YWwsXG4gICAgICAgIGFyZU93blByb3BzRXF1YWwgPSBfcmVmMiRhcmVPd25Qcm9wc0VxdWEgPT09IHVuZGVmaW5lZCA/IHNoYWxsb3dFcXVhbCA6IF9yZWYyJGFyZU93blByb3BzRXF1YSxcbiAgICAgICAgX3JlZjIkYXJlU3RhdGVQcm9wc0VxID0gX3JlZjIuYXJlU3RhdGVQcm9wc0VxdWFsLFxuICAgICAgICBhcmVTdGF0ZVByb3BzRXF1YWwgPSBfcmVmMiRhcmVTdGF0ZVByb3BzRXEgPT09IHVuZGVmaW5lZCA/IHNoYWxsb3dFcXVhbCA6IF9yZWYyJGFyZVN0YXRlUHJvcHNFcSxcbiAgICAgICAgX3JlZjIkYXJlTWVyZ2VkUHJvcHNFID0gX3JlZjIuYXJlTWVyZ2VkUHJvcHNFcXVhbCxcbiAgICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbCA9IF9yZWYyJGFyZU1lcmdlZFByb3BzRSA9PT0gdW5kZWZpbmVkID8gc2hhbGxvd0VxdWFsIDogX3JlZjIkYXJlTWVyZ2VkUHJvcHNFLFxuICAgICAgICBleHRyYU9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsncHVyZScsICdhcmVTdGF0ZXNFcXVhbCcsICdhcmVPd25Qcm9wc0VxdWFsJywgJ2FyZVN0YXRlUHJvcHNFcXVhbCcsICdhcmVNZXJnZWRQcm9wc0VxdWFsJ10pO1xuXG4gICAgdmFyIGluaXRNYXBTdGF0ZVRvUHJvcHMgPSBtYXRjaChtYXBTdGF0ZVRvUHJvcHMsIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcywgJ21hcFN0YXRlVG9Qcm9wcycpO1xuICAgIHZhciBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzID0gbWF0Y2gobWFwRGlzcGF0Y2hUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMsICdtYXBEaXNwYXRjaFRvUHJvcHMnKTtcbiAgICB2YXIgaW5pdE1lcmdlUHJvcHMgPSBtYXRjaChtZXJnZVByb3BzLCBtZXJnZVByb3BzRmFjdG9yaWVzLCAnbWVyZ2VQcm9wcycpO1xuXG4gICAgcmV0dXJuIGNvbm5lY3RIT0Moc2VsZWN0b3JGYWN0b3J5LCBfZXh0ZW5kcyh7XG4gICAgICAvLyB1c2VkIGluIGVycm9yIG1lc3NhZ2VzXG4gICAgICBtZXRob2ROYW1lOiAnY29ubmVjdCcsXG5cbiAgICAgIC8vIHVzZWQgdG8gY29tcHV0ZSBDb25uZWN0J3MgZGlzcGxheU5hbWUgZnJvbSB0aGUgd3JhcHBlZCBjb21wb25lbnQncyBkaXNwbGF5TmFtZS5cbiAgICAgIGdldERpc3BsYXlOYW1lOiBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiAnQ29ubmVjdCgnICsgbmFtZSArICcpJztcbiAgICAgIH0sXG5cbiAgICAgIC8vIGlmIG1hcFN0YXRlVG9Qcm9wcyBpcyBmYWxzeSwgdGhlIENvbm5lY3QgY29tcG9uZW50IGRvZXNuJ3Qgc3Vic2NyaWJlIHRvIHN0b3JlIHN0YXRlIGNoYW5nZXNcbiAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlczogQm9vbGVhbihtYXBTdGF0ZVRvUHJvcHMpLFxuXG4gICAgICAvLyBwYXNzZWQgdGhyb3VnaCB0byBzZWxlY3RvckZhY3RvcnlcbiAgICAgIGluaXRNYXBTdGF0ZVRvUHJvcHM6IGluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gICAgICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzOiBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHM6IGluaXRNZXJnZVByb3BzLFxuICAgICAgcHVyZTogcHVyZSxcbiAgICAgIGFyZVN0YXRlc0VxdWFsOiBhcmVTdGF0ZXNFcXVhbCxcbiAgICAgIGFyZU93blByb3BzRXF1YWw6IGFyZU93blByb3BzRXF1YWwsXG4gICAgICBhcmVTdGF0ZVByb3BzRXF1YWw6IGFyZVN0YXRlUHJvcHNFcXVhbCxcbiAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWw6IGFyZU1lcmdlZFByb3BzRXF1YWxcblxuICAgIH0sIGV4dHJhT3B0aW9ucykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVDb25uZWN0KCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9jb25uZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gaXMoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duLmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvc2hhbGxvd0VxdWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJpbXBvcnQgeyBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50LCB3cmFwTWFwVG9Qcm9wc0Z1bmMgfSBmcm9tICcuL3dyYXBNYXBUb1Byb3BzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc0Z1bmN0aW9uKG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gdHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBEaXNwYXRjaFRvUHJvcHMsICdtYXBEaXNwYXRjaFRvUHJvcHMnKSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc01pc3NpbmcobWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gIHJldHVybiAhbWFwRGlzcGF0Y2hUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4geyBkaXNwYXRjaDogZGlzcGF0Y2ggfTtcbiAgfSkgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNPYmplY3QobWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBEaXNwYXRjaFRvUHJvcHMgJiYgdHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gJ29iamVjdCcgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGZ1bmN0aW9uIChkaXNwYXRjaCkge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcnMobWFwRGlzcGF0Y2hUb1Byb3BzLCBkaXNwYXRjaCk7XG4gIH0pIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBbd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzRnVuY3Rpb24sIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc01pc3NpbmcsIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc09iamVjdF07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tYXBEaXNwYXRjaFRvUHJvcHMuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCBwb255ZmlsbCBmcm9tICcuL3BvbnlmaWxsLmpzJztcblxudmFyIHJvb3Q7XG5cbmlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBtb2R1bGU7XG59IGVsc2Uge1xuICByb290ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbn1cblxudmFyIHJlc3VsdCA9IHBvbnlmaWxsKHJvb3QpO1xuZXhwb3J0IGRlZmF1bHQgcmVzdWx0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWxNb2R1bGUpIHtcclxuXHRpZighb3JpZ2luYWxNb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHR2YXIgbW9kdWxlID0gT2JqZWN0LmNyZWF0ZShvcmlnaW5hbE1vZHVsZSk7XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJleHBvcnRzXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwocm9vdCkge1xuXHR2YXIgcmVzdWx0O1xuXHR2YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cblx0aWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcblx0XHRpZiAoU3ltYm9sLm9ic2VydmFibGUpIHtcblx0XHRcdHJlc3VsdCA9IFN5bWJvbC5vYnNlcnZhYmxlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2woJ29ic2VydmFibGUnKTtcblx0XHRcdFN5bWJvbC5vYnNlcnZhYmxlID0gcmVzdWx0O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXN1bHQgPSAnQEBvYnNlcnZhYmxlJztcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvZXMvcG9ueWZpbGwuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQbGFpbk9iamVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcm9vdC5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuZXhwb3J0IGRlZmF1bHQgZnJlZUdsb2JhbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZnJlZUdsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0VG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IGdldFByb3RvdHlwZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UHJvdG90eXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsImltcG9ydCB7IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQsIHdyYXBNYXBUb1Byb3BzRnVuYyB9IGZyb20gJy4vd3JhcE1hcFRvUHJvcHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb24obWFwU3RhdGVUb1Byb3BzKSB7XG4gIHJldHVybiB0eXBlb2YgbWFwU3RhdGVUb1Byb3BzID09PSAnZnVuY3Rpb24nID8gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFN0YXRlVG9Qcm9wcywgJ21hcFN0YXRlVG9Qcm9wcycpIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcFN0YXRlVG9Qcm9wc0lzTWlzc2luZyhtYXBTdGF0ZVRvUHJvcHMpIHtcbiAgcmV0dXJuICFtYXBTdGF0ZVRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge307XG4gIH0pIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBbd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb24sIHdoZW5NYXBTdGF0ZVRvUHJvcHNJc01pc3NpbmddO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWFwU3RhdGVUb1Byb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgdmVyaWZ5UGxhaW5PYmplY3QgZnJvbSAnLi4vdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBvd25Qcm9wcywgc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdE1lcmdlUHJvcHNQcm94eShkaXNwYXRjaCwgX3JlZikge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IF9yZWYuZGlzcGxheU5hbWUsXG4gICAgICAgIHB1cmUgPSBfcmVmLnB1cmUsXG4gICAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBfcmVmLmFyZU1lcmdlZFByb3BzRXF1YWw7XG5cbiAgICB2YXIgaGFzUnVuT25jZSA9IGZhbHNlO1xuICAgIHZhciBtZXJnZWRQcm9wcyA9IHZvaWQgMDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZVByb3BzUHJveHkoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgICAgIHZhciBuZXh0TWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcblxuICAgICAgaWYgKGhhc1J1bk9uY2UpIHtcbiAgICAgICAgaWYgKCFwdXJlIHx8ICFhcmVNZXJnZWRQcm9wc0VxdWFsKG5leHRNZXJnZWRQcm9wcywgbWVyZ2VkUHJvcHMpKSBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1J1bk9uY2UgPSB0cnVlO1xuICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgdmVyaWZ5UGxhaW5PYmplY3QobWVyZ2VkUHJvcHMsIGRpc3BsYXlOYW1lLCAnbWVyZ2VQcm9wcycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NZXJnZVByb3BzSXNGdW5jdGlvbihtZXJnZVByb3BzKSB7XG4gIHJldHVybiB0eXBlb2YgbWVyZ2VQcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NZXJnZVByb3BzSXNPbWl0dGVkKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuICFtZXJnZVByb3BzID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWVyZ2VQcm9wcztcbiAgfSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgW3doZW5NZXJnZVByb3BzSXNGdW5jdGlvbiwgd2hlbk1lcmdlUHJvcHNJc09taXR0ZWRdO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWVyZ2VQcm9wcy5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgdmVyaWZ5U3Vic2VsZWN0b3JzIGZyb20gJy4vdmVyaWZ5U3Vic2VsZWN0b3JzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGltcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbXB1cmVGaW5hbFByb3BzU2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB7XG4gICAgcmV0dXJuIG1lcmdlUHJvcHMobWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyksIG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpLCBvd25Qcm9wcyk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIF9yZWYpIHtcbiAgdmFyIGFyZVN0YXRlc0VxdWFsID0gX3JlZi5hcmVTdGF0ZXNFcXVhbCxcbiAgICAgIGFyZU93blByb3BzRXF1YWwgPSBfcmVmLmFyZU93blByb3BzRXF1YWwsXG4gICAgICBhcmVTdGF0ZVByb3BzRXF1YWwgPSBfcmVmLmFyZVN0YXRlUHJvcHNFcXVhbDtcblxuICB2YXIgaGFzUnVuQXRMZWFzdE9uY2UgPSBmYWxzZTtcbiAgdmFyIHN0YXRlID0gdm9pZCAwO1xuICB2YXIgb3duUHJvcHMgPSB2b2lkIDA7XG4gIHZhciBzdGF0ZVByb3BzID0gdm9pZCAwO1xuICB2YXIgZGlzcGF0Y2hQcm9wcyA9IHZvaWQgMDtcbiAgdmFyIG1lcmdlZFByb3BzID0gdm9pZCAwO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUZpcnN0Q2FsbChmaXJzdFN0YXRlLCBmaXJzdE93blByb3BzKSB7XG4gICAgc3RhdGUgPSBmaXJzdFN0YXRlO1xuICAgIG93blByb3BzID0gZmlyc3RPd25Qcm9wcztcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgaGFzUnVuQXRMZWFzdE9uY2UgPSB0cnVlO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKSB7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuXG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuXG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wcygpIHtcbiAgICBpZiAobWFwU3RhdGVUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG5cbiAgICBpZiAobWFwRGlzcGF0Y2hUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG5cbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1N0YXRlKCkge1xuICAgIHZhciBuZXh0U3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIHZhciBzdGF0ZVByb3BzQ2hhbmdlZCA9ICFhcmVTdGF0ZVByb3BzRXF1YWwobmV4dFN0YXRlUHJvcHMsIHN0YXRlUHJvcHMpO1xuICAgIHN0YXRlUHJvcHMgPSBuZXh0U3RhdGVQcm9wcztcblxuICAgIGlmIChzdGF0ZVByb3BzQ2hhbmdlZCkgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcblxuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIHZhciBwcm9wc0NoYW5nZWQgPSAhYXJlT3duUHJvcHNFcXVhbChuZXh0T3duUHJvcHMsIG93blByb3BzKTtcbiAgICB2YXIgc3RhdGVDaGFuZ2VkID0gIWFyZVN0YXRlc0VxdWFsKG5leHRTdGF0ZSwgc3RhdGUpO1xuICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuICAgIG93blByb3BzID0gbmV4dE93blByb3BzO1xuXG4gICAgaWYgKHByb3BzQ2hhbmdlZCAmJiBzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCk7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1Byb3BzKCk7XG4gICAgaWYgKHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1N0YXRlKCk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3IobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICByZXR1cm4gaGFzUnVuQXRMZWFzdE9uY2UgPyBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIDogaGFuZGxlRmlyc3RDYWxsKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogQWRkIG1vcmUgY29tbWVudHNcblxuLy8gSWYgcHVyZSBpcyB0cnVlLCB0aGUgc2VsZWN0b3IgcmV0dXJuZWQgYnkgc2VsZWN0b3JGYWN0b3J5IHdpbGwgbWVtb2l6ZSBpdHMgcmVzdWx0cyxcbi8vIGFsbG93aW5nIGNvbm5lY3RBZHZhbmNlZCdzIHNob3VsZENvbXBvbmVudFVwZGF0ZSB0byByZXR1cm4gZmFsc2UgaWYgZmluYWxcbi8vIHByb3BzIGhhdmUgbm90IGNoYW5nZWQuIElmIGZhbHNlLCB0aGUgc2VsZWN0b3Igd2lsbCBhbHdheXMgcmV0dXJuIGEgbmV3XG4vLyBvYmplY3QgYW5kIHNob3VsZENvbXBvbmVudFVwZGF0ZSB3aWxsIGFsd2F5cyByZXR1cm4gdHJ1ZS5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShkaXNwYXRjaCwgX3JlZjIpIHtcbiAgdmFyIGluaXRNYXBTdGF0ZVRvUHJvcHMgPSBfcmVmMi5pbml0TWFwU3RhdGVUb1Byb3BzLFxuICAgICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyA9IF9yZWYyLmluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgICBpbml0TWVyZ2VQcm9wcyA9IF9yZWYyLmluaXRNZXJnZVByb3BzLFxuICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydpbml0TWFwU3RhdGVUb1Byb3BzJywgJ2luaXRNYXBEaXNwYXRjaFRvUHJvcHMnLCAnaW5pdE1lcmdlUHJvcHMnXSk7XG5cbiAgdmFyIG1hcFN0YXRlVG9Qcm9wcyA9IGluaXRNYXBTdGF0ZVRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICB2YXIgbWFwRGlzcGF0Y2hUb1Byb3BzID0gaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIHZhciBtZXJnZVByb3BzID0gaW5pdE1lcmdlUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBvcHRpb25zLmRpc3BsYXlOYW1lKTtcbiAgfVxuXG4gIHZhciBzZWxlY3RvckZhY3RvcnkgPSBvcHRpb25zLnB1cmUgPyBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSA6IGltcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnk7XG5cbiAgcmV0dXJuIHNlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIG9wdGlvbnMpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJpbXBvcnQgd2FybmluZyBmcm9tICcuLi91dGlscy93YXJuaW5nJztcblxuZnVuY3Rpb24gdmVyaWZ5KHNlbGVjdG9yLCBtZXRob2ROYW1lLCBkaXNwbGF5TmFtZSkge1xuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHZhbHVlIGZvciAnICsgbWV0aG9kTmFtZSArICcgaW4gJyArIGRpc3BsYXlOYW1lICsgJy4nKTtcbiAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAnbWFwU3RhdGVUb1Byb3BzJyB8fCBtZXRob2ROYW1lID09PSAnbWFwRGlzcGF0Y2hUb1Byb3BzJykge1xuICAgIGlmICghc2VsZWN0b3IuaGFzT3duUHJvcGVydHkoJ2RlcGVuZHNPbk93blByb3BzJykpIHtcbiAgICAgIHdhcm5pbmcoJ1RoZSBzZWxlY3RvciBmb3IgJyArIG1ldGhvZE5hbWUgKyAnIG9mICcgKyBkaXNwbGF5TmFtZSArICcgZGlkIG5vdCBzcGVjaWZ5IGEgdmFsdWUgZm9yIGRlcGVuZHNPbk93blByb3BzLicpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZlcmlmeShtYXBTdGF0ZVRvUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnLCBkaXNwbGF5TmFtZSk7XG4gIHZlcmlmeShtYXBEaXNwYXRjaFRvUHJvcHMsICdtYXBEaXNwYXRjaFRvUHJvcHMnLCBkaXNwbGF5TmFtZSk7XG4gIHZlcmlmeShtZXJnZVByb3BzLCAnbWVyZ2VQcm9wcycsIGRpc3BsYXlOYW1lKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gMTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tIFwid2FybmluZ1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IHsgY3JlYXRlQnJvd3Nlckhpc3RvcnkgYXMgY3JlYXRlSGlzdG9yeSB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQgUm91dGVyIGZyb20gXCIuL1JvdXRlclwiO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgdXNlcyBIVE1MNSBoaXN0b3J5LlxuICovXG5cbnZhciBCcm93c2VyUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEJyb3dzZXJSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCcm93c2VyUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShfdGhpcy5wcm9wcyksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgQnJvd3NlclJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgXCI8QnJvd3NlclJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgXCIgKyBcInVzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IEJyb3dzZXJSb3V0ZXIgYXMgUm91dGVyIH1gLlwiKTtcbiAgfTtcblxuICBCcm93c2VyUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSwgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfSk7XG4gIH07XG5cbiAgcmV0dXJuIEJyb3dzZXJSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkJyb3dzZXJSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZm9yY2VSZWZyZXNoOiBQcm9wVHlwZXMuYm9vbCxcbiAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGtleUxlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IEJyb3dzZXJSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Ccm93c2VyUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24gfSBmcm9tICcuL0xvY2F0aW9uVXRpbHMnO1xuaW1wb3J0IHsgYWRkTGVhZGluZ1NsYXNoLCBzdHJpcFRyYWlsaW5nU2xhc2gsIGhhc0Jhc2VuYW1lLCBzdHJpcEJhc2VuYW1lLCBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgY2FuVXNlRE9NLCBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBnZXRDb25maXJtYXRpb24sIHN1cHBvcnRzSGlzdG9yeSwgc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSwgaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCB9IGZyb20gJy4vRE9NVXRpbHMnO1xuXG52YXIgUG9wU3RhdGVFdmVudCA9ICdwb3BzdGF0ZSc7XG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgZ2V0SGlzdG9yeVN0YXRlID0gZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElFIDExIHNvbWV0aW1lcyB0aHJvd3Mgd2hlbiBhY2Nlc3Npbmcgd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0VHJhaW5pbmcvaGlzdG9yeS9wdWxsLzI4OVxuICAgIHJldHVybiB7fTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpbmNsdWRpbmdcbiAqIHB1c2hTdGF0ZSwgcmVwbGFjZVN0YXRlLCBhbmQgdGhlIHBvcHN0YXRlIGV2ZW50LlxuICovXG52YXIgY3JlYXRlQnJvd3Nlckhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICBpbnZhcmlhbnQoY2FuVXNlRE9NLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhblVzZUhpc3RvcnkgPSBzdXBwb3J0c0hpc3RvcnkoKTtcbiAgdmFyIG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyID0gIXN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UoKTtcblxuICB2YXIgX3Byb3BzJGZvcmNlUmVmcmVzaCA9IHByb3BzLmZvcmNlUmVmcmVzaCxcbiAgICAgIGZvcmNlUmVmcmVzaCA9IF9wcm9wcyRmb3JjZVJlZnJlc2ggPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3Byb3BzJGZvcmNlUmVmcmVzaCxcbiAgICAgIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBnZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyBzdHJpcFRyYWlsaW5nU2xhc2goYWRkTGVhZGluZ1NsYXNoKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgICB2YXIgX3JlZiA9IGhpc3RvcnlTdGF0ZSB8fCB7fSxcbiAgICAgICAga2V5ID0gX3JlZi5rZXksXG4gICAgICAgIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICAgIHZhciBfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxuICAgICAgICBwYXRobmFtZSA9IF93aW5kb3ckbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCA9IF93aW5kb3ckbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNoID0gX3dpbmRvdyRsb2NhdGlvbi5oYXNoO1xuXG5cbiAgICB2YXIgcGF0aCA9IHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcblxuICAgIHdhcm5pbmcoIWJhc2VuYW1lIHx8IGhhc0Jhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSBzdHJpcEJhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKTtcblxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5KTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wU3RhdGUgPSBmdW5jdGlvbiBoYW5kbGVQb3BTdGF0ZShldmVudCkge1xuICAgIC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXQuXG4gICAgaWYgKGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpKSByZXR1cm47XG5cbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKSk7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuXG4gIHZhciBoYW5kbGVQb3AgPSBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcblxuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmV2ZXJ0UG9wID0gZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgIC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2Yga2V5cyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBrZXlzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbEtleXMuaW5kZXhPZih0b0xvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuXG4gICAgdmFyIGZyb21JbmRleCA9IGFsbEtleXMuaW5kZXhPZihmcm9tTG9jYXRpb24ua2V5KTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKTtcbiAgdmFyIGFsbEtleXMgPSBbaW5pdGlhbExvY2F0aW9uLmtleV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiBiYXNlbmFtZSArIGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoeyBrZXk6IGtleSwgc3RhdGU6IHN0YXRlIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgdmFyIG5leHRLZXlzID0gYWxsS2V5cy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgICAgbmV4dEtleXMucHVzaChsb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIGFsbEtleXMgPSBuZXh0S2V5cztcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG5cbiAgICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsS2V5c1twcmV2SW5kZXhdID0gbG9jYXRpb24ua2V5O1xuXG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5Jyk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgcmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCcm93c2VySGlzdG9yeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJmdW5jdGlvbiBpc0Fic29sdXRlKHBhdGhuYW1lKSB7XG4gIHJldHVybiBwYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJztcbn1cblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKSB7XG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIH1cblxuICBsaXN0LnBvcCgpO1xufVxuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIGhlYXZpbHkgb24gbm9kZSdzIHVybC5wYXJzZVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGhuYW1lKHRvKSB7XG4gIHZhciBmcm9tID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcblxuICB2YXIgdG9QYXJ0cyA9IHRvICYmIHRvLnNwbGl0KCcvJykgfHwgW107XG4gIHZhciBmcm9tUGFydHMgPSBmcm9tICYmIGZyb20uc3BsaXQoJy8nKSB8fCBbXTtcblxuICB2YXIgaXNUb0FicyA9IHRvICYmIGlzQWJzb2x1dGUodG8pO1xuICB2YXIgaXNGcm9tQWJzID0gZnJvbSAmJiBpc0Fic29sdXRlKGZyb20pO1xuICB2YXIgbXVzdEVuZEFicyA9IGlzVG9BYnMgfHwgaXNGcm9tQWJzO1xuXG4gIGlmICh0byAmJiBpc0Fic29sdXRlKHRvKSkge1xuICAgIC8vIHRvIGlzIGFic29sdXRlXG4gICAgZnJvbVBhcnRzID0gdG9QYXJ0cztcbiAgfSBlbHNlIGlmICh0b1BhcnRzLmxlbmd0aCkge1xuICAgIC8vIHRvIGlzIHJlbGF0aXZlLCBkcm9wIHRoZSBmaWxlbmFtZVxuICAgIGZyb21QYXJ0cy5wb3AoKTtcbiAgICBmcm9tUGFydHMgPSBmcm9tUGFydHMuY29uY2F0KHRvUGFydHMpO1xuICB9XG5cbiAgaWYgKCFmcm9tUGFydHMubGVuZ3RoKSByZXR1cm4gJy8nO1xuXG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gdm9pZCAwO1xuICBpZiAoZnJvbVBhcnRzLmxlbmd0aCkge1xuICAgIHZhciBsYXN0ID0gZnJvbVBhcnRzW2Zyb21QYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBoYXNUcmFpbGluZ1NsYXNoID0gbGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicgfHwgbGFzdCA9PT0gJyc7XG4gIH0gZWxzZSB7XG4gICAgaGFzVHJhaWxpbmdTbGFzaCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IGZyb21QYXJ0cy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHBhcnQgPSBmcm9tUGFydHNbaV07XG5cbiAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKCFtdXN0RW5kQWJzKSBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICBmcm9tUGFydHMudW5zaGlmdCgnLi4nKTtcbiAgfWlmIChtdXN0RW5kQWJzICYmIGZyb21QYXJ0c1swXSAhPT0gJycgJiYgKCFmcm9tUGFydHNbMF0gfHwgIWlzQWJzb2x1dGUoZnJvbVBhcnRzWzBdKSkpIGZyb21QYXJ0cy51bnNoaWZ0KCcnKTtcblxuICB2YXIgcmVzdWx0ID0gZnJvbVBhcnRzLmpvaW4oJy8nKTtcblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiByZXN1bHQuc3Vic3RyKC0xKSAhPT0gJy8nKSByZXN1bHQgKz0gJy8nO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlc29sdmVQYXRobmFtZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZXNvbHZlLXBhdGhuYW1lL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIHZhbHVlRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHZhbHVlRXF1YWwoaXRlbSwgYltpbmRleF0pO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGFUeXBlID0gdHlwZW9mIGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGEpO1xuICB2YXIgYlR5cGUgPSB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYik7XG5cbiAgaWYgKGFUeXBlICE9PSBiVHlwZSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChhVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgYVZhbHVlID0gYS52YWx1ZU9mKCk7XG4gICAgdmFyIGJWYWx1ZSA9IGIudmFsdWVPZigpO1xuXG4gICAgaWYgKGFWYWx1ZSAhPT0gYSB8fCBiVmFsdWUgIT09IGIpIHJldHVybiB2YWx1ZUVxdWFsKGFWYWx1ZSwgYlZhbHVlKTtcblxuICAgIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuXG4gICAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHZhbHVlRXF1YWwoYVtrZXldLCBiW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWx1ZUVxdWFsO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3ZhbHVlLWVxdWFsL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5pbXBvcnQgeyBhZGRMZWFkaW5nU2xhc2gsIHN0cmlwTGVhZGluZ1NsYXNoLCBzdHJpcFRyYWlsaW5nU2xhc2gsIGhhc0Jhc2VuYW1lLCBzdHJpcEJhc2VuYW1lLCBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgY2FuVXNlRE9NLCBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBnZXRDb25maXJtYXRpb24sIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoIH0gZnJvbSAnLi9ET01VdGlscyc7XG5cbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBIYXNoUGF0aENvZGVycyA9IHtcbiAgaGFzaGJhbmc6IHtcbiAgICBlbmNvZGVQYXRoOiBmdW5jdGlvbiBlbmNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aCA6ICchLycgKyBzdHJpcExlYWRpbmdTbGFzaChwYXRoKTtcbiAgICB9LFxuICAgIGRlY29kZVBhdGg6IGZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG4gICAgfVxuICB9LFxuICBub3NsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogc3RyaXBMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoXG4gIH0sXG4gIHNsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaFxuICB9XG59O1xuXG52YXIgZ2V0SGFzaFBhdGggPSBmdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaGFzaEluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gJycgOiBocmVmLnN1YnN0cmluZyhoYXNoSW5kZXggKyAxKTtcbn07XG5cbnZhciBwdXNoSGFzaFBhdGggPSBmdW5jdGlvbiBwdXNoSGFzaFBhdGgocGF0aCkge1xuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufTtcblxudmFyIHJlcGxhY2VIYXNoUGF0aCA9IGZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHZhciBoYXNoSW5kZXggPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJyk7XG5cbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc2xpY2UoMCwgaGFzaEluZGV4ID49IDAgPyBoYXNoSW5kZXggOiAwKSArICcjJyArIHBhdGgpO1xufTtcblxudmFyIGNyZWF0ZUhhc2hIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgaW52YXJpYW50KGNhblVzZURPTSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Hb1dpdGhvdXRSZWxvYWQgPSBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpO1xuXG4gIHZhciBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGhhc2hUeXBlID0gcHJvcHMuaGFzaFR5cGUsXG4gICAgICBoYXNoVHlwZSA9IF9wcm9wcyRoYXNoVHlwZSA9PT0gdW5kZWZpbmVkID8gJ3NsYXNoJyA6IF9wcm9wcyRoYXNoVHlwZTtcblxuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/IHN0cmlwVHJhaWxpbmdTbGFzaChhZGRMZWFkaW5nU2xhc2gocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuXG4gIHZhciBfSGFzaFBhdGhDb2RlcnMkaGFzaFQgPSBIYXNoUGF0aENvZGVyc1toYXNoVHlwZV0sXG4gICAgICBlbmNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmVuY29kZVBhdGgsXG4gICAgICBkZWNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmRlY29kZVBhdGg7XG5cblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IGRlY29kZVBhdGgoZ2V0SGFzaFBhdGgoKSk7XG5cbiAgICB3YXJuaW5nKCFiYXNlbmFtZSB8fCBoYXNCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gc3RyaXBCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24ocGF0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICB2YXIgaWdub3JlUGF0aCA9IG51bGw7XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuXG4gICAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSB7XG4gICAgICAvLyBFbnN1cmUgd2UgYWx3YXlzIGhhdmUgYSBwcm9wZXJseS1lbmNvZGVkIGhhc2guXG4gICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICAgICAgdmFyIHByZXZMb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAgIGlmICghZm9yY2VOZXh0UG9wICYmIGxvY2F0aW9uc0FyZUVxdWFsKHByZXZMb2NhdGlvbiwgbG9jYXRpb24pKSByZXR1cm47IC8vIEEgaGFzaGNoYW5nZSBkb2Vzbid0IGFsd2F5cyA9PSBsb2NhdGlvbiBjaGFuZ2UuXG5cbiAgICAgIGlmIChpZ25vcmVQYXRoID09PSBjcmVhdGVQYXRoKGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBJZ25vcmUgdGhpcyBjaGFuZ2U7IHdlIGFscmVhZHkgc2V0U3RhdGUgaW4gcHVzaC9yZXBsYWNlLlxuXG4gICAgICBpZ25vcmVQYXRoID0gbnVsbDtcblxuICAgICAgaGFuZGxlUG9wKGxvY2F0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcCA9IGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuXG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZXZlcnRQb3AgPSBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBwYXRocyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBwYXRocyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKHRvTG9jYXRpb24pKTtcblxuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG5cbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aChmcm9tTG9jYXRpb24pKTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRW5zdXJlIHRoZSBoYXNoIGlzIGVuY29kZWQgcHJvcGVybHkgYmVmb3JlIGRvaW5nIGFueXRoaW5nIGVsc2UuXG4gIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gIHZhciBhbGxQYXRocyA9IFtjcmVhdGVQYXRoKGluaXRpYWxMb2NhdGlvbildO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gJyMnICsgZW5jb2RlUGF0aChiYXNlbmFtZSArIGNyZWF0ZVBhdGgobG9jYXRpb24pKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHBhdGggPSBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBQVVNILCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICBwdXNoSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKGhpc3RvcnkubG9jYXRpb24pKTtcbiAgICAgICAgdmFyIG5leHRQYXRocyA9IGFsbFBhdGhzLnNsaWNlKDAsIHByZXZJbmRleCA9PT0gLTEgPyAwIDogcHJldkluZGV4ICsgMSk7XG5cbiAgICAgICAgbmV4dFBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIGFsbFBhdGhzID0gbmV4dFBhdGhzO1xuXG4gICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdIYXNoIGhpc3RvcnkgY2Fubm90IFBVU0ggdGhlIHNhbWUgcGF0aDsgYSBuZXcgZW50cnkgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2snKTtcblxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFJFUExBQ0UsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5pbmRleE9mKGNyZWF0ZVBhdGgoaGlzdG9yeS5sb2NhdGlvbikpO1xuXG4gICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsUGF0aHNbcHJldkluZGV4XSA9IHBhdGg7XG5cbiAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgd2FybmluZyhjYW5Hb1dpdGhvdXRSZWxvYWQsICdIYXNoIGhpc3RvcnkgZ28obikgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZCBpbiB0aGlzIGJyb3dzZXInKTtcblxuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUhhc2hIaXN0b3J5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlSGFzaEhpc3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgeyBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24gfSBmcm9tICcuL0xvY2F0aW9uVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuXG52YXIgY2xhbXAgPSBmdW5jdGlvbiBjbGFtcChuLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHN0b3JlcyBsb2NhdGlvbnMgaW4gbWVtb3J5LlxuICovXG52YXIgY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIF9wcm9wcyRpbml0aWFsRW50cmllcyA9IHByb3BzLmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEVudHJpZXMgPSBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPT09IHVuZGVmaW5lZCA/IFsnLyddIDogX3Byb3BzJGluaXRpYWxFbnRyaWVzLFxuICAgICAgX3Byb3BzJGluaXRpYWxJbmRleCA9IHByb3BzLmluaXRpYWxJbmRleCxcbiAgICAgIGluaXRpYWxJbmRleCA9IF9wcm9wcyRpbml0aWFsSW5kZXggPT09IHVuZGVmaW5lZCA/IDAgOiBfcHJvcHMkaW5pdGlhbEluZGV4LFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgaW5kZXggPSBjbGFtcChpbml0aWFsSW5kZXgsIDAsIGluaXRpYWxFbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB2YXIgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyA/IGNyZWF0ZUxvY2F0aW9uKGVudHJ5LCB1bmRlZmluZWQsIGNyZWF0ZUtleSgpKSA6IGNyZWF0ZUxvY2F0aW9uKGVudHJ5LCB1bmRlZmluZWQsIGVudHJ5LmtleSB8fCBjcmVhdGVLZXkoKSk7XG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGNyZWF0ZVBhdGg7XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHByZXZJbmRleCA9IGhpc3RvcnkuaW5kZXg7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gcHJldkluZGV4ICsgMTtcblxuICAgICAgdmFyIG5leHRFbnRyaWVzID0gaGlzdG9yeS5lbnRyaWVzLnNsaWNlKDApO1xuICAgICAgaWYgKG5leHRFbnRyaWVzLmxlbmd0aCA+IG5leHRJbmRleCkge1xuICAgICAgICBuZXh0RW50cmllcy5zcGxpY2UobmV4dEluZGV4LCBuZXh0RW50cmllcy5sZW5ndGggLSBuZXh0SW5kZXgsIGxvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRFbnRyaWVzLnB1c2gobG9jYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgIGVudHJpZXM6IG5leHRFbnRyaWVzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICBoaXN0b3J5LmVudHJpZXNbaGlzdG9yeS5pbmRleF0gPSBsb2NhdGlvbjtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gY2xhbXAoaGlzdG9yeS5pbmRleCArIG4sIDAsIGhpc3RvcnkuZW50cmllcy5sZW5ndGggLSAxKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICB2YXIgbG9jYXRpb24gPSBoaXN0b3J5LmVudHJpZXNbbmV4dEluZGV4XTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAob2spIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBpbmRleDogbmV4dEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWltaWMgdGhlIGJlaGF2aW9yIG9mIERPTSBoaXN0b3JpZXMgYnlcbiAgICAgICAgLy8gY2F1c2luZyBhIHJlbmRlciBhZnRlciBhIGNhbmNlbGxlZCBQT1AuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBjYW5HbyA9IGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gaGlzdG9yeS5pbmRleCArIG47XG4gICAgcmV0dXJuIG5leHRJbmRleCA+PSAwICYmIG5leHRJbmRleCA8IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZW50cmllcy5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogZW50cmllc1tpbmRleF0sXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNhbkdvOiBjYW5HbyxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gXCJ3YXJuaW5nXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gXCJwcm9wLXR5cGVzXCI7XG5pbXBvcnQgeyBjcmVhdGVIYXNoSGlzdG9yeSBhcyBjcmVhdGVIaXN0b3J5IH0gZnJvbSBcImhpc3RvcnlcIjtcbmltcG9ydCBSb3V0ZXIgZnJvbSBcIi4vUm91dGVyXCI7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCB1c2VzIHdpbmRvdy5sb2NhdGlvbi5oYXNoLlxuICovXG5cbnZhciBIYXNoUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEhhc2hSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEhhc2hSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIYXNoUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShfdGhpcy5wcm9wcyksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgSGFzaFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgXCI8SGFzaFJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgXCIgKyBcInVzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IEhhc2hSb3V0ZXIgYXMgUm91dGVyIH1gLlwiKTtcbiAgfTtcblxuICBIYXNoUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSwgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfSk7XG4gIH07XG5cbiAgcmV0dXJuIEhhc2hSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkhhc2hSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGhhc2hUeXBlOiBQcm9wVHlwZXMub25lT2YoW1wiaGFzaGJhbmdcIiwgXCJub3NsYXNoXCIsIFwic2xhc2hcIl0pLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgSGFzaFJvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0hhc2hSb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgTWVtb3J5Um91dGVyIGZyb20gXCJyZWFjdC1yb3V0ZXIvZXMvTWVtb3J5Um91dGVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IE1lbW9yeVJvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL01lbW9yeVJvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tIFwid2FybmluZ1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IHsgY3JlYXRlTWVtb3J5SGlzdG9yeSBhcyBjcmVhdGVIaXN0b3J5IH0gZnJvbSBcImhpc3RvcnlcIjtcbmltcG9ydCBSb3V0ZXIgZnJvbSBcIi4vUm91dGVyXCI7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCBzdG9yZXMgbG9jYXRpb24gaW4gbWVtb3J5LlxuICovXG5cbnZhciBNZW1vcnlSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTWVtb3J5Um91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNZW1vcnlSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZW1vcnlSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KF90aGlzLnByb3BzKSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBNZW1vcnlSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksIFwiPE1lbW9yeVJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgXCIgKyBcInVzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IE1lbW9yeVJvdXRlciBhcyBSb3V0ZXIgfWAuXCIpO1xuICB9O1xuXG4gIE1lbW9yeVJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBNZW1vcnlSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbk1lbW9yeVJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGluaXRpYWxFbnRyaWVzOiBQcm9wVHlwZXMuYXJyYXksXG4gIGluaXRpYWxJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGtleUxlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IE1lbW9yeVJvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvTWVtb3J5Um91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IFJvdXRlIGZyb20gXCIuL1JvdXRlXCI7XG5pbXBvcnQgTGluayBmcm9tIFwiLi9MaW5rXCI7XG5cbi8qKlxuICogQSA8TGluaz4gd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cbnZhciBOYXZMaW5rID0gZnVuY3Rpb24gTmF2TGluayhfcmVmKSB7XG4gIHZhciB0byA9IF9yZWYudG8sXG4gICAgICBleGFjdCA9IF9yZWYuZXhhY3QsXG4gICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbixcbiAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF9yZWYuYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBhY3RpdmVTdHlsZSA9IF9yZWYuYWN0aXZlU3R5bGUsXG4gICAgICBzdHlsZSA9IF9yZWYuc3R5bGUsXG4gICAgICBnZXRJc0FjdGl2ZSA9IF9yZWYuaXNBY3RpdmUsXG4gICAgICBhcmlhQ3VycmVudCA9IF9yZWZbXCJhcmlhLWN1cnJlbnRcIl0sXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcInRvXCIsIFwiZXhhY3RcIiwgXCJzdHJpY3RcIiwgXCJsb2NhdGlvblwiLCBcImFjdGl2ZUNsYXNzTmFtZVwiLCBcImNsYXNzTmFtZVwiLCBcImFjdGl2ZVN0eWxlXCIsIFwic3R5bGVcIiwgXCJpc0FjdGl2ZVwiLCBcImFyaWEtY3VycmVudFwiXSk7XG5cbiAgdmFyIHBhdGggPSAodHlwZW9mIHRvID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YodG8pKSA9PT0gXCJvYmplY3RcIiA/IHRvLnBhdGhuYW1lIDogdG87XG5cbiAgLy8gUmVnZXggdGFrZW4gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL3BpbGxhcmpzL3BhdGgtdG8tcmVnZXhwL2Jsb2IvbWFzdGVyL2luZGV4LmpzI0wyMDJcbiAgdmFyIGVzY2FwZWRQYXRoID0gcGF0aCAmJiBwYXRoLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18L1xcXFxdKS9nLCBcIlxcXFwkMVwiKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZSwge1xuICAgIHBhdGg6IGVzY2FwZWRQYXRoLFxuICAgIGV4YWN0OiBleGFjdCxcbiAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgY2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKF9yZWYyKSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBfcmVmMi5sb2NhdGlvbixcbiAgICAgICAgICBtYXRjaCA9IF9yZWYyLm1hdGNoO1xuXG4gICAgICB2YXIgaXNBY3RpdmUgPSAhIShnZXRJc0FjdGl2ZSA/IGdldElzQWN0aXZlKG1hdGNoLCBsb2NhdGlvbikgOiBtYXRjaCk7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KExpbmssIF9leHRlbmRzKHtcbiAgICAgICAgdG86IHRvLFxuICAgICAgICBjbGFzc05hbWU6IGlzQWN0aXZlID8gW2NsYXNzTmFtZSwgYWN0aXZlQ2xhc3NOYW1lXS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSkuam9pbihcIiBcIikgOiBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiBpc0FjdGl2ZSA/IF9leHRlbmRzKHt9LCBzdHlsZSwgYWN0aXZlU3R5bGUpIDogc3R5bGUsXG4gICAgICAgIFwiYXJpYS1jdXJyZW50XCI6IGlzQWN0aXZlICYmIGFyaWFDdXJyZW50IHx8IG51bGxcbiAgICAgIH0sIHJlc3QpKTtcbiAgICB9XG4gIH0pO1xufTtcblxuTmF2TGluay5wcm9wVHlwZXMgPSB7XG4gIHRvOiBMaW5rLnByb3BUeXBlcy50byxcbiAgZXhhY3Q6IFByb3BUeXBlcy5ib29sLFxuICBzdHJpY3Q6IFByb3BUeXBlcy5ib29sLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdCxcbiAgYWN0aXZlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGFjdGl2ZVN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgaXNBY3RpdmU6IFByb3BUeXBlcy5mdW5jLFxuICBcImFyaWEtY3VycmVudFwiOiBQcm9wVHlwZXMub25lT2YoW1wicGFnZVwiLCBcInN0ZXBcIiwgXCJsb2NhdGlvblwiLCBcImRhdGVcIiwgXCJ0aW1lXCIsIFwidHJ1ZVwiXSlcbn07XG5cbk5hdkxpbmsuZGVmYXVsdFByb3BzID0ge1xuICBhY3RpdmVDbGFzc05hbWU6IFwiYWN0aXZlXCIsXG4gIFwiYXJpYS1jdXJyZW50XCI6IFwicGFnZVwiXG59O1xuXG5leHBvcnQgZGVmYXVsdCBOYXZMaW5rO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTmF2TGluay5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBQcm9tcHQgZnJvbSBcInJlYWN0LXJvdXRlci9lcy9Qcm9tcHRcIjtcblxuZXhwb3J0IGRlZmF1bHQgUHJvbXB0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUHJvbXB0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSBcImludmFyaWFudFwiO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBwcm9tcHRpbmcgdGhlIHVzZXIgYmVmb3JlIG5hdmlnYXRpbmcgYXdheVxuICogZnJvbSBhIHNjcmVlbiB3aXRoIGEgY29tcG9uZW50LlxuICovXG5cbnZhciBQcm9tcHQgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUHJvbXB0LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQcm9tcHQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb21wdCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFByb21wdC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy51bmJsb2NrKSB0aGlzLnVuYmxvY2soKTtcblxuICAgIHRoaXMudW5ibG9jayA9IHRoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeS5ibG9jayhtZXNzYWdlKTtcbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLnVuYmxvY2spIHtcbiAgICAgIHRoaXMudW5ibG9jaygpO1xuICAgICAgdGhpcy51bmJsb2NrID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgaW52YXJpYW50KHRoaXMuY29udGV4dC5yb3V0ZXIsIFwiWW91IHNob3VsZCBub3QgdXNlIDxQcm9tcHQ+IG91dHNpZGUgYSA8Um91dGVyPlwiKTtcblxuICAgIGlmICh0aGlzLnByb3BzLndoZW4pIHRoaXMuZW5hYmxlKHRoaXMucHJvcHMubWVzc2FnZSk7XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLndoZW4pIHtcbiAgICAgIGlmICghdGhpcy5wcm9wcy53aGVuIHx8IHRoaXMucHJvcHMubWVzc2FnZSAhPT0gbmV4dFByb3BzLm1lc3NhZ2UpIHRoaXMuZW5hYmxlKG5leHRQcm9wcy5tZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfVxuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmRpc2FibGUoKTtcbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUHJvbXB0O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Qcm9tcHQucHJvcFR5cGVzID0ge1xuICB3aGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgbWVzc2FnZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5zdHJpbmddKS5pc1JlcXVpcmVkXG59O1xuUHJvbXB0LmRlZmF1bHRQcm9wcyA9IHtcbiAgd2hlbjogdHJ1ZVxufTtcblByb21wdC5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgYmxvY2s6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KS5pc1JlcXVpcmVkXG4gIH0pLmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUHJvbXB0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Qcm9tcHQuanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgUmVkaXJlY3QgZnJvbSBcInJlYWN0LXJvdXRlci9lcy9SZWRpcmVjdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBSZWRpcmVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JlZGlyZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCB3YXJuaW5nIGZyb20gXCJ3YXJuaW5nXCI7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gXCJpbnZhcmlhbnRcIjtcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQgZ2VuZXJhdGVQYXRoIGZyb20gXCIuL2dlbmVyYXRlUGF0aFwiO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciB1cGRhdGluZyB0aGUgbG9jYXRpb24gcHJvZ3JhbW1hdGljYWxseVxuICogd2l0aCBhIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgUmVkaXJlY3QgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUmVkaXJlY3QsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJlZGlyZWN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWRpcmVjdCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5pc1N0YXRpYyA9IGZ1bmN0aW9uIGlzU3RhdGljKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQucm91dGVyICYmIHRoaXMuY29udGV4dC5yb3V0ZXIuc3RhdGljQ29udGV4dDtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCBcIllvdSBzaG91bGQgbm90IHVzZSA8UmVkaXJlY3Q+IG91dHNpZGUgYSA8Um91dGVyPlwiKTtcblxuICAgIGlmICh0aGlzLmlzU3RhdGljKCkpIHRoaXMucGVyZm9ybSgpO1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICghdGhpcy5pc1N0YXRpYygpKSB0aGlzLnBlcmZvcm0oKTtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIHZhciBwcmV2VG8gPSBjcmVhdGVMb2NhdGlvbihwcmV2UHJvcHMudG8pO1xuICAgIHZhciBuZXh0VG8gPSBjcmVhdGVMb2NhdGlvbih0aGlzLnByb3BzLnRvKTtcblxuICAgIGlmIChsb2NhdGlvbnNBcmVFcXVhbChwcmV2VG8sIG5leHRUbykpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiWW91IHRyaWVkIHRvIHJlZGlyZWN0IHRvIHRoZSBzYW1lIHJvdXRlIHlvdSdyZSBjdXJyZW50bHkgb246IFwiICsgKFwiXFxcIlwiICsgbmV4dFRvLnBhdGhuYW1lICsgbmV4dFRvLnNlYXJjaCArIFwiXFxcIlwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wZXJmb3JtKCk7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmNvbXB1dGVUbyA9IGZ1bmN0aW9uIGNvbXB1dGVUbyhfcmVmKSB7XG4gICAgdmFyIGNvbXB1dGVkTWF0Y2ggPSBfcmVmLmNvbXB1dGVkTWF0Y2gsXG4gICAgICAgIHRvID0gX3JlZi50bztcblxuICAgIGlmIChjb21wdXRlZE1hdGNoKSB7XG4gICAgICBpZiAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVBhdGgodG8sIGNvbXB1dGVkTWF0Y2gucGFyYW1zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgdG8sIHtcbiAgICAgICAgICBwYXRobmFtZTogZ2VuZXJhdGVQYXRoKHRvLnBhdGhuYW1lLCBjb21wdXRlZE1hdGNoLnBhcmFtcylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvO1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gcGVyZm9ybSgpIHtcbiAgICB2YXIgaGlzdG9yeSA9IHRoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeTtcbiAgICB2YXIgcHVzaCA9IHRoaXMucHJvcHMucHVzaDtcblxuICAgIHZhciB0byA9IHRoaXMuY29tcHV0ZVRvKHRoaXMucHJvcHMpO1xuXG4gICAgaWYgKHB1c2gpIHtcbiAgICAgIGhpc3RvcnkucHVzaCh0byk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZSh0byk7XG4gICAgfVxuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFJlZGlyZWN0O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5SZWRpcmVjdC5wcm9wVHlwZXMgPSB7XG4gIGNvbXB1dGVkTWF0Y2g6IFByb3BUeXBlcy5vYmplY3QsIC8vIHByaXZhdGUsIGZyb20gPFN3aXRjaD5cbiAgcHVzaDogUHJvcFR5cGVzLmJvb2wsXG4gIGZyb206IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSkuaXNSZXF1aXJlZFxufTtcblJlZGlyZWN0LmRlZmF1bHRQcm9wcyA9IHtcbiAgcHVzaDogZmFsc2Vcbn07XG5SZWRpcmVjdC5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgcHVzaDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgIHJlcGxhY2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KS5pc1JlcXVpcmVkLFxuICAgIHN0YXRpY0NvbnRleHQ6IFByb3BUeXBlcy5vYmplY3RcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSZWRpcmVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUmVkaXJlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgU3RhdGljUm91dGVyIGZyb20gXCJyZWFjdC1yb3V0ZXIvZXMvU3RhdGljUm91dGVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IFN0YXRpY1JvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N0YXRpY1JvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gXCJ3YXJuaW5nXCI7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gXCJpbnZhcmlhbnRcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBjcmVhdGVQYXRoIH0gZnJvbSBcImhpc3RvcnlcIjtcbmltcG9ydCBSb3V0ZXIgZnJvbSBcIi4vUm91dGVyXCI7XG5cbnZhciBhZGRMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBhZGRMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09IFwiL1wiID8gcGF0aCA6IFwiL1wiICsgcGF0aDtcbn07XG5cbnZhciBhZGRCYXNlbmFtZSA9IGZ1bmN0aW9uIGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBsb2NhdGlvbikge1xuICBpZiAoIWJhc2VuYW1lKSByZXR1cm4gbG9jYXRpb247XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgIHBhdGhuYW1lOiBhZGRMZWFkaW5nU2xhc2goYmFzZW5hbWUpICsgbG9jYXRpb24ucGF0aG5hbWVcbiAgfSk7XG59O1xuXG52YXIgc3RyaXBCYXNlbmFtZSA9IGZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUoYmFzZW5hbWUsIGxvY2F0aW9uKSB7XG4gIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcblxuICB2YXIgYmFzZSA9IGFkZExlYWRpbmdTbGFzaChiYXNlbmFtZSk7XG5cbiAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmluZGV4T2YoYmFzZSkgIT09IDApIHJldHVybiBsb2NhdGlvbjtcblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cihiYXNlLmxlbmd0aClcbiAgfSk7XG59O1xuXG52YXIgY3JlYXRlVVJMID0gZnVuY3Rpb24gY3JlYXRlVVJMKGxvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgbG9jYXRpb24gPT09IFwic3RyaW5nXCIgPyBsb2NhdGlvbiA6IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xufTtcblxudmFyIHN0YXRpY0hhbmRsZXIgPSBmdW5jdGlvbiBzdGF0aWNIYW5kbGVyKG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IGNhbm5vdCAlcyB3aXRoIDxTdGF0aWNSb3V0ZXI+XCIsIG1ldGhvZE5hbWUpO1xuICB9O1xufTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbi8qKlxuICogVGhlIHB1YmxpYyB0b3AtbGV2ZWwgQVBJIGZvciBhIFwic3RhdGljXCIgPFJvdXRlcj4sIHNvLWNhbGxlZCBiZWNhdXNlIGl0XG4gKiBjYW4ndCBhY3R1YWxseSBjaGFuZ2UgdGhlIGN1cnJlbnQgbG9jYXRpb24uIEluc3RlYWQsIGl0IGp1c3QgcmVjb3Jkc1xuICogbG9jYXRpb24gY2hhbmdlcyBpbiBhIGNvbnRleHQgb2JqZWN0LiBVc2VmdWwgbWFpbmx5IGluIHRlc3RpbmcgYW5kXG4gKiBzZXJ2ZXItcmVuZGVyaW5nIHNjZW5hcmlvcy5cbiAqL1xuXG52YXIgU3RhdGljUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFN0YXRpY1JvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3RhdGljUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RhdGljUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5jcmVhdGVIcmVmID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHJldHVybiBhZGRMZWFkaW5nU2xhc2goX3RoaXMucHJvcHMuYmFzZW5hbWUgKyBjcmVhdGVVUkwocGF0aCkpO1xuICAgIH0sIF90aGlzLmhhbmRsZVB1c2ggPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGJhc2VuYW1lID0gX3RoaXMkcHJvcHMuYmFzZW5hbWUsXG4gICAgICAgICAgY29udGV4dCA9IF90aGlzJHByb3BzLmNvbnRleHQ7XG5cbiAgICAgIGNvbnRleHQuYWN0aW9uID0gXCJQVVNIXCI7XG4gICAgICBjb250ZXh0LmxvY2F0aW9uID0gYWRkQmFzZW5hbWUoYmFzZW5hbWUsIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSk7XG4gICAgICBjb250ZXh0LnVybCA9IGNyZWF0ZVVSTChjb250ZXh0LmxvY2F0aW9uKTtcbiAgICB9LCBfdGhpcy5oYW5kbGVSZXBsYWNlID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgYmFzZW5hbWUgPSBfdGhpcyRwcm9wczIuYmFzZW5hbWUsXG4gICAgICAgICAgY29udGV4dCA9IF90aGlzJHByb3BzMi5jb250ZXh0O1xuXG4gICAgICBjb250ZXh0LmFjdGlvbiA9IFwiUkVQTEFDRVwiO1xuICAgICAgY29udGV4dC5sb2NhdGlvbiA9IGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpO1xuICAgICAgY29udGV4dC51cmwgPSBjcmVhdGVVUkwoY29udGV4dC5sb2NhdGlvbik7XG4gICAgfSwgX3RoaXMuaGFuZGxlTGlzdGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfSwgX3RoaXMuaGFuZGxlQmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFN0YXRpY1JvdXRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IHtcbiAgICAgICAgc3RhdGljQ29udGV4dDogdGhpcy5wcm9wcy5jb250ZXh0XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBTdGF0aWNSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksIFwiPFN0YXRpY1JvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgXCIgKyBcInVzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IFN0YXRpY1JvdXRlciBhcyBSb3V0ZXIgfWAuXCIpO1xuICB9O1xuXG4gIFN0YXRpY1JvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBiYXNlbmFtZSA9IF9wcm9wcy5iYXNlbmFtZSxcbiAgICAgICAgY29udGV4dCA9IF9wcm9wcy5jb250ZXh0LFxuICAgICAgICBsb2NhdGlvbiA9IF9wcm9wcy5sb2NhdGlvbixcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbXCJiYXNlbmFtZVwiLCBcImNvbnRleHRcIiwgXCJsb2NhdGlvblwiXSk7XG5cbiAgICB2YXIgaGlzdG9yeSA9IHtcbiAgICAgIGNyZWF0ZUhyZWY6IHRoaXMuY3JlYXRlSHJlZixcbiAgICAgIGFjdGlvbjogXCJQT1BcIixcbiAgICAgIGxvY2F0aW9uOiBzdHJpcEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpLFxuICAgICAgcHVzaDogdGhpcy5oYW5kbGVQdXNoLFxuICAgICAgcmVwbGFjZTogdGhpcy5oYW5kbGVSZXBsYWNlLFxuICAgICAgZ286IHN0YXRpY0hhbmRsZXIoXCJnb1wiKSxcbiAgICAgIGdvQmFjazogc3RhdGljSGFuZGxlcihcImdvQmFja1wiKSxcbiAgICAgIGdvRm9yd2FyZDogc3RhdGljSGFuZGxlcihcImdvRm9yd2FyZFwiKSxcbiAgICAgIGxpc3RlbjogdGhpcy5oYW5kbGVMaXN0ZW4sXG4gICAgICBibG9jazogdGhpcy5oYW5kbGVCbG9ja1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBoaXN0b3J5OiBoaXN0b3J5IH0pKTtcbiAgfTtcblxuICByZXR1cm4gU3RhdGljUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5TdGF0aWNSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgY29udGV4dDogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pXG59O1xuU3RhdGljUm91dGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgYmFzZW5hbWU6IFwiXCIsXG4gIGxvY2F0aW9uOiBcIi9cIlxufTtcblN0YXRpY1JvdXRlci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgU3RhdGljUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9TdGF0aWNSb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgU3dpdGNoIGZyb20gXCJyZWFjdC1yb3V0ZXIvZXMvU3dpdGNoXCI7XG5cbmV4cG9ydCBkZWZhdWx0IFN3aXRjaDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N3aXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gXCJwcm9wLXR5cGVzXCI7XG5pbXBvcnQgd2FybmluZyBmcm9tIFwid2FybmluZ1wiO1xuaW1wb3J0IGludmFyaWFudCBmcm9tIFwiaW52YXJpYW50XCI7XG5pbXBvcnQgbWF0Y2hQYXRoIGZyb20gXCIuL21hdGNoUGF0aFwiO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgdGhlIGZpcnN0IDxSb3V0ZT4gdGhhdCBtYXRjaGVzLlxuICovXG5cbnZhciBTd2l0Y2ggPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU3dpdGNoLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTd2l0Y2goKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN3aXRjaCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFN3aXRjaC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCBcIllvdSBzaG91bGQgbm90IHVzZSA8U3dpdGNoPiBvdXRzaWRlIGEgPFJvdXRlcj5cIik7XG4gIH07XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB3YXJuaW5nKCEobmV4dFByb3BzLmxvY2F0aW9uICYmICF0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxTd2l0Y2g+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgaW5pdGlhbGx5IHVzZWQgbm8gXCJsb2NhdGlvblwiIHByb3AgYW5kIHRoZW4gcHJvdmlkZWQgb25lIG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG5cbiAgICB3YXJuaW5nKCEoIW5leHRQcm9wcy5sb2NhdGlvbiAmJiB0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxTd2l0Y2g+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgcHJvdmlkZWQgYSBcImxvY2F0aW9uXCIgcHJvcCBpbml0aWFsbHkgYnV0IG9taXR0ZWQgaXQgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKTtcbiAgfTtcblxuICBTd2l0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcm91dGUgPSB0aGlzLmNvbnRleHQucm91dGVyLnJvdXRlO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG5cbiAgICB2YXIgbG9jYXRpb24gPSB0aGlzLnByb3BzLmxvY2F0aW9uIHx8IHJvdXRlLmxvY2F0aW9uO1xuXG4gICAgdmFyIG1hdGNoID0gdm9pZCAwLFxuICAgICAgICBjaGlsZCA9IHZvaWQgMDtcbiAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgaWYgKG1hdGNoID09IG51bGwgJiYgUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgdmFyIF9lbGVtZW50JHByb3BzID0gZWxlbWVudC5wcm9wcyxcbiAgICAgICAgICAgIHBhdGhQcm9wID0gX2VsZW1lbnQkcHJvcHMucGF0aCxcbiAgICAgICAgICAgIGV4YWN0ID0gX2VsZW1lbnQkcHJvcHMuZXhhY3QsXG4gICAgICAgICAgICBzdHJpY3QgPSBfZWxlbWVudCRwcm9wcy5zdHJpY3QsXG4gICAgICAgICAgICBzZW5zaXRpdmUgPSBfZWxlbWVudCRwcm9wcy5zZW5zaXRpdmUsXG4gICAgICAgICAgICBmcm9tID0gX2VsZW1lbnQkcHJvcHMuZnJvbTtcblxuICAgICAgICB2YXIgcGF0aCA9IHBhdGhQcm9wIHx8IGZyb207XG5cbiAgICAgICAgY2hpbGQgPSBlbGVtZW50O1xuICAgICAgICBtYXRjaCA9IG1hdGNoUGF0aChsb2NhdGlvbi5wYXRobmFtZSwgeyBwYXRoOiBwYXRoLCBleGFjdDogZXhhY3QsIHN0cmljdDogc3RyaWN0LCBzZW5zaXRpdmU6IHNlbnNpdGl2ZSB9LCByb3V0ZS5tYXRjaCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWF0Y2ggPyBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHsgbG9jYXRpb246IGxvY2F0aW9uLCBjb21wdXRlZE1hdGNoOiBtYXRjaCB9KSA6IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFN3aXRjaDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuU3dpdGNoLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHJvdXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblN3aXRjaC5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3Rcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgU3dpdGNoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Td2l0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDE1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgZ2VuZXJhdGVQYXRoIGZyb20gXCJyZWFjdC1yb3V0ZXIvZXMvZ2VuZXJhdGVQYXRoXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGdlbmVyYXRlUGF0aDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL2dlbmVyYXRlUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBtYXRjaFBhdGggZnJvbSBcInJlYWN0LXJvdXRlci9lcy9tYXRjaFBhdGhcIjtcblxuZXhwb3J0IGRlZmF1bHQgbWF0Y2hQYXRoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvbWF0Y2hQYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IHdpdGhSb3V0ZXIgZnJvbSBcInJlYWN0LXJvdXRlci9lcy93aXRoUm91dGVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy93aXRoUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCBob2lzdFN0YXRpY3MgZnJvbSBcImhvaXN0LW5vbi1yZWFjdC1zdGF0aWNzXCI7XG5pbXBvcnQgUm91dGUgZnJvbSBcIi4vUm91dGVcIjtcblxuLyoqXG4gKiBBIHB1YmxpYyBoaWdoZXItb3JkZXIgY29tcG9uZW50IHRvIGFjY2VzcyB0aGUgaW1wZXJhdGl2ZSBBUElcbiAqL1xudmFyIHdpdGhSb3V0ZXIgPSBmdW5jdGlvbiB3aXRoUm91dGVyKENvbXBvbmVudCkge1xuICB2YXIgQyA9IGZ1bmN0aW9uIEMocHJvcHMpIHtcbiAgICB2YXIgd3JhcHBlZENvbXBvbmVudFJlZiA9IHByb3BzLndyYXBwZWRDb21wb25lbnRSZWYsXG4gICAgICAgIHJlbWFpbmluZ1Byb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJ3cmFwcGVkQ29tcG9uZW50UmVmXCJdKTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlLCB7XG4gICAgICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4ocm91dGVDb21wb25lbnRQcm9wcykge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHt9LCByZW1haW5pbmdQcm9wcywgcm91dGVDb21wb25lbnRQcm9wcywge1xuICAgICAgICAgIHJlZjogd3JhcHBlZENvbXBvbmVudFJlZlxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgQy5kaXNwbGF5TmFtZSA9IFwid2l0aFJvdXRlcihcIiArIChDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUpICsgXCIpXCI7XG4gIEMuV3JhcHBlZENvbXBvbmVudCA9IENvbXBvbmVudDtcbiAgQy5wcm9wVHlwZXMgPSB7XG4gICAgd3JhcHBlZENvbXBvbmVudFJlZjogUHJvcFR5cGVzLmZ1bmNcbiAgfTtcblxuICByZXR1cm4gaG9pc3RTdGF0aWNzKEMsIENvbXBvbmVudCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy93aXRoUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZSh1dGlscy5tZXJnZShkZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLy4uL2RlZmF1bHRzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gdXRpbHMubWVyZ2Uoe1xuICAgICAgdXJsOiBhcmd1bWVudHNbMF1cbiAgICB9LCBhcmd1bWVudHNbMV0pO1xuICB9XG5cbiAgY29uZmlnID0gdXRpbHMubWVyZ2UoZGVmYXVsdHMsIHttZXRob2Q6ICdnZXQnfSwgdGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCBub3JtYWxpemVkTmFtZSkge1xuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAhPT0gbm9ybWFsaXplZE5hbWUgJiYgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XG4gICAgfVxuICB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIC8vIE5vdGU6IHN0YXR1cyBpcyBub3QgZXhwb3NlZCBieSBYRG9tYWluUmVxdWVzdFxuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIHJldHVybiBlcnJvcjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qc1xuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3RcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB2YXIgb3JpZ2luVVJMO1xuXG4gICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgIH1cblxuICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgfTtcbiAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfSkoKVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBidG9hIHBvbHlmaWxsIGZvciBJRTwxMCBjb3VydGVzeSBodHRwczovL2dpdGh1Yi5jb20vZGF2aWRjaGFtYmVycy9CYXNlNjQuanNcblxudmFyIGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcblxuZnVuY3Rpb24gRSgpIHtcbiAgdGhpcy5tZXNzYWdlID0gJ1N0cmluZyBjb250YWlucyBhbiBpbnZhbGlkIGNoYXJhY3Rlcic7XG59XG5FLnByb3RvdHlwZSA9IG5ldyBFcnJvcjtcbkUucHJvdG90eXBlLmNvZGUgPSA1O1xuRS5wcm90b3R5cGUubmFtZSA9ICdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InO1xuXG5mdW5jdGlvbiBidG9hKGlucHV0KSB7XG4gIHZhciBzdHIgPSBTdHJpbmcoaW5wdXQpO1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIGZvciAoXG4gICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJcbiAgICB2YXIgYmxvY2ssIGNoYXJDb2RlLCBpZHggPSAwLCBtYXAgPSBjaGFycztcbiAgICAvLyBpZiB0aGUgbmV4dCBzdHIgaW5kZXggZG9lcyBub3QgZXhpc3Q6XG4gICAgLy8gICBjaGFuZ2UgdGhlIG1hcHBpbmcgdGFibGUgdG8gXCI9XCJcbiAgICAvLyAgIGNoZWNrIGlmIGQgaGFzIG5vIGZyYWN0aW9uYWwgZGlnaXRzXG4gICAgc3RyLmNoYXJBdChpZHggfCAwKSB8fCAobWFwID0gJz0nLCBpZHggJSAxKTtcbiAgICAvLyBcIjggLSBpZHggJSAxICogOFwiIGdlbmVyYXRlcyB0aGUgc2VxdWVuY2UgMiwgNCwgNiwgOFxuICAgIG91dHB1dCArPSBtYXAuY2hhckF0KDYzICYgYmxvY2sgPj4gOCAtIGlkeCAlIDEgKiA4KVxuICApIHtcbiAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGlkeCArPSAzIC8gNCk7XG4gICAgaWYgKGNoYXJDb2RlID4gMHhGRikge1xuICAgICAgdGhyb3cgbmV3IEUoKTtcbiAgICB9XG4gICAgYmxvY2sgPSBibG9jayA8PCA4IHwgY2hhckNvZGU7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBidG9hO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qc1xuLy8gbW9kdWxlIGlkID0gMTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICB9LFxuXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfSkoKVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWRcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwnKTtcbnZhciBjb21iaW5lVVJMcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIFN1cHBvcnQgYmFzZVVSTCBjb25maWdcbiAgaWYgKGNvbmZpZy5iYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKGNvbmZpZy51cmwpKSB7XG4gICAgY29uZmlnLnVybCA9IGNvbWJpbmVVUkxzKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgfVxuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnMgfHwge31cbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanNcbi8vIG1vZHVsZSBpZCA9IDE3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qc1xuLy8gbW9kdWxlIGlkID0gMTc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbnZhciBhcnJheVByZWZpeEdlbmVyYXRvcnMgPSB7XG4gICAgYnJhY2tldHM6IGZ1bmN0aW9uIGJyYWNrZXRzKHByZWZpeCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJ1tdJztcbiAgICB9LFxuICAgIGluZGljZXM6IGZ1bmN0aW9uIGluZGljZXMocHJlZml4LCBrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbJyArIGtleSArICddJztcbiAgICB9LFxuICAgIHJlcGVhdDogZnVuY3Rpb24gcmVwZWF0KHByZWZpeCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgIH1cbn07XG5cbnZhciB0b0lTTyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZW5jb2RlOiB0cnVlLFxuICAgIGVuY29kZXI6IHV0aWxzLmVuY29kZSxcbiAgICBlbmNvZGVWYWx1ZXNPbmx5OiBmYWxzZSxcbiAgICBzZXJpYWxpemVEYXRlOiBmdW5jdGlvbiBzZXJpYWxpemVEYXRlKGRhdGUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIHRvSVNPLmNhbGwoZGF0ZSk7XG4gICAgfSxcbiAgICBza2lwTnVsbHM6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2Vcbn07XG5cbnZhciBzdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gICAgb2JqZWN0LFxuICAgIHByZWZpeCxcbiAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICBza2lwTnVsbHMsXG4gICAgZW5jb2RlcixcbiAgICBmaWx0ZXIsXG4gICAgc29ydCxcbiAgICBhbGxvd0RvdHMsXG4gICAgc2VyaWFsaXplRGF0ZSxcbiAgICBmb3JtYXR0ZXIsXG4gICAgZW5jb2RlVmFsdWVzT25seVxuKSB7XG4gICAgdmFyIG9iaiA9IG9iamVjdDtcbiAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmogPSBmaWx0ZXIocHJlZml4LCBvYmopO1xuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBvYmogPSBzZXJpYWxpemVEYXRlKG9iaik7XG4gICAgfSBlbHNlIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0cmljdE51bGxIYW5kbGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZXIgJiYgIWVuY29kZVZhbHVlc09ubHkgPyBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2RlcikgOiBwcmVmaXg7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSAnJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG9iaiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nIHx8IHV0aWxzLmlzQnVmZmVyKG9iaikpIHtcbiAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IGVuY29kZVZhbHVlc09ubHkgPyBwcmVmaXggOiBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2Rlcik7XG4gICAgICAgICAgICByZXR1cm4gW2Zvcm1hdHRlcihrZXlWYWx1ZSkgKyAnPScgKyBmb3JtYXR0ZXIoZW5jb2RlcihvYmosIGRlZmF1bHRzLmVuY29kZXIpKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIocHJlZml4KSArICc9JyArIGZvcm1hdHRlcihTdHJpbmcob2JqKSldO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIHZhciBvYmpLZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcikpIHtcbiAgICAgICAgb2JqS2V5cyA9IGZpbHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIG9iaktleXMgPSBzb3J0ID8ga2V5cy5zb3J0KHNvcnQpIDoga2V5cztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbaV07XG5cbiAgICAgICAgaWYgKHNraXBOdWxscyAmJiBvYmpba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4KHByZWZpeCwga2V5KSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgICAgICAgICAgZW5jb2RlcixcbiAgICAgICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgICAgICBhbGxvd0RvdHMsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICAgICAgZW5jb2RlVmFsdWVzT25seVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgICAgICBwcmVmaXggKyAoYWxsb3dEb3RzID8gJy4nICsga2V5IDogJ1snICsga2V5ICsgJ10nKSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgICAgICAgICAgZW5jb2RlcixcbiAgICAgICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgICAgICBhbGxvd0RvdHMsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICAgICAgZW5jb2RlVmFsdWVzT25seVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBvcHRzKSB7XG4gICAgdmFyIG9iaiA9IG9iamVjdDtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgPyB1dGlscy5hc3NpZ24oe30sIG9wdHMpIDoge307XG5cbiAgICBpZiAob3B0aW9ucy5lbmNvZGVyICE9PSBudWxsICYmIG9wdGlvbnMuZW5jb2RlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLmVuY29kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5jb2RlciBoYXMgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgZGVsaW1pdGVyID0gdHlwZW9mIG9wdGlvbnMuZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmRlbGltaXRlciA6IG9wdGlvbnMuZGVsaW1pdGVyO1xuICAgIHZhciBzdHJpY3ROdWxsSGFuZGxpbmcgPSB0eXBlb2Ygb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nIDogZGVmYXVsdHMuc3RyaWN0TnVsbEhhbmRsaW5nO1xuICAgIHZhciBza2lwTnVsbHMgPSB0eXBlb2Ygb3B0aW9ucy5za2lwTnVsbHMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2tpcE51bGxzIDogZGVmYXVsdHMuc2tpcE51bGxzO1xuICAgIHZhciBlbmNvZGUgPSB0eXBlb2Ygb3B0aW9ucy5lbmNvZGUgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuZW5jb2RlIDogZGVmYXVsdHMuZW5jb2RlO1xuICAgIHZhciBlbmNvZGVyID0gdHlwZW9mIG9wdGlvbnMuZW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZW5jb2RlciA6IGRlZmF1bHRzLmVuY29kZXI7XG4gICAgdmFyIHNvcnQgPSB0eXBlb2Ygb3B0aW9ucy5zb3J0ID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5zb3J0IDogbnVsbDtcbiAgICB2YXIgYWxsb3dEb3RzID0gdHlwZW9mIG9wdGlvbnMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IGZhbHNlIDogb3B0aW9ucy5hbGxvd0RvdHM7XG4gICAgdmFyIHNlcmlhbGl6ZURhdGUgPSB0eXBlb2Ygb3B0aW9ucy5zZXJpYWxpemVEYXRlID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5zZXJpYWxpemVEYXRlIDogZGVmYXVsdHMuc2VyaWFsaXplRGF0ZTtcbiAgICB2YXIgZW5jb2RlVmFsdWVzT25seSA9IHR5cGVvZiBvcHRpb25zLmVuY29kZVZhbHVlc09ubHkgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuZW5jb2RlVmFsdWVzT25seSA6IGRlZmF1bHRzLmVuY29kZVZhbHVlc09ubHk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZvcm1hdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0aW9ucy5mb3JtYXQgPSBmb3JtYXRzWydkZWZhdWx0J107XG4gICAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvcm1hdHMuZm9ybWF0dGVycywgb3B0aW9ucy5mb3JtYXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZm9ybWF0IG9wdGlvbiBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgdmFyIGZvcm1hdHRlciA9IGZvcm1hdHMuZm9ybWF0dGVyc1tvcHRpb25zLmZvcm1hdF07XG4gICAgdmFyIG9iaktleXM7XG4gICAgdmFyIGZpbHRlcjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIG9iaiA9IGZpbHRlcignJywgb2JqKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlGb3JtYXQ7XG4gICAgaWYgKG9wdGlvbnMuYXJyYXlGb3JtYXQgaW4gYXJyYXlQcmVmaXhHZW5lcmF0b3JzKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0aW9ucy5hcnJheUZvcm1hdDtcbiAgICB9IGVsc2UgaWYgKCdpbmRpY2VzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0aW9ucy5pbmRpY2VzID8gJ2luZGljZXMnIDogJ3JlcGVhdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSAnaW5kaWNlcyc7XG4gICAgfVxuXG4gICAgdmFyIGdlbmVyYXRlQXJyYXlQcmVmaXggPSBhcnJheVByZWZpeEdlbmVyYXRvcnNbYXJyYXlGb3JtYXRdO1xuXG4gICAgaWYgKCFvYmpLZXlzKSB7XG4gICAgICAgIG9iaktleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIH1cblxuICAgIGlmIChzb3J0KSB7XG4gICAgICAgIG9iaktleXMuc29ydChzb3J0KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbaV07XG5cbiAgICAgICAgaWYgKHNraXBOdWxscyAmJiBvYmpba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoc3RyaW5naWZ5KFxuICAgICAgICAgICAgb2JqW2tleV0sXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICAgICAgZW5jb2RlID8gZW5jb2RlciA6IG51bGwsXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICBzb3J0LFxuICAgICAgICAgICAgYWxsb3dEb3RzLFxuICAgICAgICAgICAgc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgIGZvcm1hdHRlcixcbiAgICAgICAgICAgIGVuY29kZVZhbHVlc09ubHlcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgdmFyIGpvaW5lZCA9IGtleXMuam9pbihkZWxpbWl0ZXIpO1xuICAgIHZhciBwcmVmaXggPSBvcHRpb25zLmFkZFF1ZXJ5UHJlZml4ID09PSB0cnVlID8gJz8nIDogJyc7XG5cbiAgICByZXR1cm4gam9pbmVkLmxlbmd0aCA+IDAgPyBwcmVmaXggKyBqb2luZWQgOiAnJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9xcy9saWIvc3RyaW5naWZ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgICBhbGxvd0RvdHM6IGZhbHNlLFxuICAgIGFsbG93UHJvdG90eXBlczogZmFsc2UsXG4gICAgYXJyYXlMaW1pdDogMjAsXG4gICAgZGVjb2RlcjogdXRpbHMuZGVjb2RlLFxuICAgIGRlbGltaXRlcjogJyYnLFxuICAgIGRlcHRoOiA1LFxuICAgIHBhcmFtZXRlckxpbWl0OiAxMDAwLFxuICAgIHBsYWluT2JqZWN0czogZmFsc2UsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nOiBmYWxzZVxufTtcblxudmFyIHBhcnNlVmFsdWVzID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZ1ZhbHVlcyhzdHIsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgdmFyIGNsZWFuU3RyID0gb3B0aW9ucy5pZ25vcmVRdWVyeVByZWZpeCA/IHN0ci5yZXBsYWNlKC9eXFw/LywgJycpIDogc3RyO1xuICAgIHZhciBsaW1pdCA9IG9wdGlvbnMucGFyYW1ldGVyTGltaXQgPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdDtcbiAgICB2YXIgcGFydHMgPSBjbGVhblN0ci5zcGxpdChvcHRpb25zLmRlbGltaXRlciwgbGltaXQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuXG4gICAgICAgIHZhciBicmFja2V0RXF1YWxzUG9zID0gcGFydC5pbmRleE9mKCddPScpO1xuICAgICAgICB2YXIgcG9zID0gYnJhY2tldEVxdWFsc1BvcyA9PT0gLTEgPyBwYXJ0LmluZGV4T2YoJz0nKSA6IGJyYWNrZXRFcXVhbHNQb3MgKyAxO1xuXG4gICAgICAgIHZhciBrZXksIHZhbDtcbiAgICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgIGtleSA9IG9wdGlvbnMuZGVjb2RlcihwYXJ0LCBkZWZhdWx0cy5kZWNvZGVyKTtcbiAgICAgICAgICAgIHZhbCA9IG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID8gbnVsbCA6ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQuc2xpY2UoMCwgcG9zKSwgZGVmYXVsdHMuZGVjb2Rlcik7XG4gICAgICAgICAgICB2YWwgPSBvcHRpb25zLmRlY29kZXIocGFydC5zbGljZShwb3MgKyAxKSwgZGVmYXVsdHMuZGVjb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSBbXS5jb25jYXQob2JqW2tleV0pLmNvbmNhdCh2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIHBhcnNlT2JqZWN0ID0gZnVuY3Rpb24gKGNoYWluLCB2YWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgbGVhZiA9IHZhbDtcblxuICAgIGZvciAodmFyIGkgPSBjaGFpbi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgb2JqO1xuICAgICAgICB2YXIgcm9vdCA9IGNoYWluW2ldO1xuXG4gICAgICAgIGlmIChyb290ID09PSAnW10nKSB7XG4gICAgICAgICAgICBvYmogPSBbXTtcbiAgICAgICAgICAgIG9iaiA9IG9iai5jb25jYXQobGVhZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgICAgICAgIHZhciBjbGVhblJvb3QgPSByb290LmNoYXJBdCgwKSA9PT0gJ1snICYmIHJvb3QuY2hhckF0KHJvb3QubGVuZ3RoIC0gMSkgPT09ICddJyA/IHJvb3Quc2xpY2UoMSwgLTEpIDogcm9vdDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGNsZWFuUm9vdCwgMTApO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFpc05hTihpbmRleClcbiAgICAgICAgICAgICAgICAmJiByb290ICE9PSBjbGVhblJvb3RcbiAgICAgICAgICAgICAgICAmJiBTdHJpbmcoaW5kZXgpID09PSBjbGVhblJvb3RcbiAgICAgICAgICAgICAgICAmJiBpbmRleCA+PSAwXG4gICAgICAgICAgICAgICAgJiYgKG9wdGlvbnMucGFyc2VBcnJheXMgJiYgaW5kZXggPD0gb3B0aW9ucy5hcnJheUxpbWl0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gW107XG4gICAgICAgICAgICAgICAgb2JqW2luZGV4XSA9IGxlYWY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ialtjbGVhblJvb3RdID0gbGVhZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxlYWYgPSBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlYWY7XG59O1xuXG52YXIgcGFyc2VLZXlzID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZ0tleXMoZ2l2ZW5LZXksIHZhbCwgb3B0aW9ucykge1xuICAgIGlmICghZ2l2ZW5LZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRyYW5zZm9ybSBkb3Qgbm90YXRpb24gdG8gYnJhY2tldCBub3RhdGlvblxuICAgIHZhciBrZXkgPSBvcHRpb25zLmFsbG93RG90cyA/IGdpdmVuS2V5LnJlcGxhY2UoL1xcLihbXi5bXSspL2csICdbJDFdJykgOiBnaXZlbktleTtcblxuICAgIC8vIFRoZSByZWdleCBjaHVua3NcblxuICAgIHZhciBicmFja2V0cyA9IC8oXFxbW15bXFxdXSpdKS87XG4gICAgdmFyIGNoaWxkID0gLyhcXFtbXltcXF1dKl0pL2c7XG5cbiAgICAvLyBHZXQgdGhlIHBhcmVudFxuXG4gICAgdmFyIHNlZ21lbnQgPSBicmFja2V0cy5leGVjKGtleSk7XG4gICAgdmFyIHBhcmVudCA9IHNlZ21lbnQgPyBrZXkuc2xpY2UoMCwgc2VnbWVudC5pbmRleCkgOiBrZXk7XG5cbiAgICAvLyBTdGFzaCB0aGUgcGFyZW50IGlmIGl0IGV4aXN0c1xuXG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCB1c2luZyBwbGFpbiBvYmplY3RzLCBvcHRpb25hbGx5IHByZWZpeCBrZXlzXG4gICAgICAgIC8vIHRoYXQgd291bGQgb3ZlcndyaXRlIG9iamVjdCBwcm90b3R5cGUgcHJvcGVydGllc1xuICAgICAgICBpZiAoIW9wdGlvbnMucGxhaW5PYmplY3RzICYmIGhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHBhcmVudCkpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBrZXlzLnB1c2gocGFyZW50KTtcbiAgICB9XG5cbiAgICAvLyBMb29wIHRocm91Z2ggY2hpbGRyZW4gYXBwZW5kaW5nIHRvIHRoZSBhcnJheSB1bnRpbCB3ZSBoaXQgZGVwdGhcblxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoKHNlZ21lbnQgPSBjaGlsZC5leGVjKGtleSkpICE9PSBudWxsICYmIGkgPCBvcHRpb25zLmRlcHRoKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnBsYWluT2JqZWN0cyAmJiBoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBzZWdtZW50WzFdLnNsaWNlKDEsIC0xKSkpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5wdXNoKHNlZ21lbnRbMV0pO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlJ3MgYSByZW1haW5kZXIsIGp1c3QgYWRkIHdoYXRldmVyIGlzIGxlZnRcblxuICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIGtleXMucHVzaCgnWycgKyBrZXkuc2xpY2Uoc2VnbWVudC5pbmRleCkgKyAnXScpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZU9iamVjdChrZXlzLCB2YWwsIG9wdGlvbnMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzID8gdXRpbHMuYXNzaWduKHt9LCBvcHRzKSA6IHt9O1xuXG4gICAgaWYgKG9wdGlvbnMuZGVjb2RlciAhPT0gbnVsbCAmJiBvcHRpb25zLmRlY29kZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5kZWNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RlY29kZXIgaGFzIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5pZ25vcmVRdWVyeVByZWZpeCA9IG9wdGlvbnMuaWdub3JlUXVlcnlQcmVmaXggPT09IHRydWU7XG4gICAgb3B0aW9ucy5kZWxpbWl0ZXIgPSB0eXBlb2Ygb3B0aW9ucy5kZWxpbWl0ZXIgPT09ICdzdHJpbmcnIHx8IHV0aWxzLmlzUmVnRXhwKG9wdGlvbnMuZGVsaW1pdGVyKSA/IG9wdGlvbnMuZGVsaW1pdGVyIDogZGVmYXVsdHMuZGVsaW1pdGVyO1xuICAgIG9wdGlvbnMuZGVwdGggPSB0eXBlb2Ygb3B0aW9ucy5kZXB0aCA9PT0gJ251bWJlcicgPyBvcHRpb25zLmRlcHRoIDogZGVmYXVsdHMuZGVwdGg7XG4gICAgb3B0aW9ucy5hcnJheUxpbWl0ID0gdHlwZW9mIG9wdGlvbnMuYXJyYXlMaW1pdCA9PT0gJ251bWJlcicgPyBvcHRpb25zLmFycmF5TGltaXQgOiBkZWZhdWx0cy5hcnJheUxpbWl0O1xuICAgIG9wdGlvbnMucGFyc2VBcnJheXMgPSBvcHRpb25zLnBhcnNlQXJyYXlzICE9PSBmYWxzZTtcbiAgICBvcHRpb25zLmRlY29kZXIgPSB0eXBlb2Ygb3B0aW9ucy5kZWNvZGVyID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5kZWNvZGVyIDogZGVmYXVsdHMuZGVjb2RlcjtcbiAgICBvcHRpb25zLmFsbG93RG90cyA9IHR5cGVvZiBvcHRpb25zLmFsbG93RG90cyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5hbGxvd0RvdHMgOiBkZWZhdWx0cy5hbGxvd0RvdHM7XG4gICAgb3B0aW9ucy5wbGFpbk9iamVjdHMgPSB0eXBlb2Ygb3B0aW9ucy5wbGFpbk9iamVjdHMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMucGxhaW5PYmplY3RzIDogZGVmYXVsdHMucGxhaW5PYmplY3RzO1xuICAgIG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzID0gdHlwZW9mIG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmFsbG93UHJvdG90eXBlcyA6IGRlZmF1bHRzLmFsbG93UHJvdG90eXBlcztcbiAgICBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID0gdHlwZW9mIG9wdGlvbnMucGFyYW1ldGVyTGltaXQgPT09ICdudW1iZXInID8gb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA6IGRlZmF1bHRzLnBhcmFtZXRlckxpbWl0O1xuICAgIG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID0gdHlwZW9mIG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZztcblxuICAgIGlmIChzdHIgPT09ICcnIHx8IHN0ciA9PT0gbnVsbCB8fCB0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgfVxuXG4gICAgdmFyIHRlbXBPYmogPSB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHBhcnNlVmFsdWVzKHN0ciwgb3B0aW9ucykgOiBzdHI7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBrZXlzIGFuZCBzZXR1cCB0aGUgbmV3IG9iamVjdFxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0ZW1wT2JqKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciBuZXdPYmogPSBwYXJzZUtleXMoa2V5LCB0ZW1wT2JqW2tleV0sIG9wdGlvbnMpO1xuICAgICAgICBvYmogPSB1dGlscy5tZXJnZShvYmosIG5ld09iaiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLmNvbXBhY3Qob2JqKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9xcy9saWIvcGFyc2UuanNcbi8vIG1vZHVsZSBpZCA9IDE4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbi8vIFJlYWN0IDE2KyBzdXBwb3J0cyBQb3J0YWxzLlxudmFyIGNhblVzZVBvcnRhbHMgPSAhIVJlYWN0RE9NLmNyZWF0ZVBvcnRhbDtcblxuZnVuY3Rpb24gZGlzcGxhY2UoV3JhcHBlZENvbXBvbmVudCwgb3B0aW9ucykge1xuICBpZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgICAgX2luaGVyaXRzKEVtcHR5RGlzcGxhY2UsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgICBmdW5jdGlvbiBFbXB0eURpc3BsYWNlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW1wdHlEaXNwbGFjZSk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChFbXB0eURpc3BsYWNlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRW1wdHlEaXNwbGFjZSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfVxuXG4gICAgICBfY3JlYXRlQ2xhc3MoRW1wdHlEaXNwbGFjZSwgW3tcbiAgICAgICAga2V5OiAncmVuZGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEVtcHR5RGlzcGxhY2U7XG4gICAgfShSZWFjdC5Db21wb25lbnQpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIERpc3BsYWNlZCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50Mikge1xuICAgIF9pbmhlcml0cyhEaXNwbGFjZWQsIF9SZWFjdCRDb21wb25lbnQyKTtcblxuICAgIGZ1bmN0aW9uIERpc3BsYWNlZCgpIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICB2YXIgX3RlbXAsIF90aGlzMiwgX3JldDtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpc3BsYWNlZCk7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChfcmVmID0gRGlzcGxhY2VkLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRGlzcGxhY2VkKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzMiksIF90aGlzMi5yZW5kZXJEaXNwbGFjZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFJlYWN0RE9NLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKF90aGlzMiwgUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCBfdGhpczIucHJvcHMsIF90aGlzMi5wcm9wcy5jaGlsZHJlbiksIF90aGlzMi5jb250YWluZXIpO1xuICAgICAgfSwgX3RoaXMyLnJlbW92ZURpc3BsYWNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZShfdGhpczIuY29udGFpbmVyKTtcbiAgICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMyLCBfcmV0KTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRGlzcGxhY2VkLCBbe1xuICAgICAga2V5OiAnY29tcG9uZW50V2lsbE1vdW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5yZW5kZXJUbykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnJlbmRlclRvID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3B0aW9ucy5yZW5kZXJUbyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlbmRlclRvO1xuICAgICAgICAgIH1cbiAgICAgICAgfSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NvbXBvbmVudERpZE1vdW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKGNhblVzZVBvcnRhbHMpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMubW91bnRlZCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyRGlzcGxhY2VkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKGNhblVzZVBvcnRhbHMpIHJldHVybjtcbiAgICAgICAgaWYgKHByZXZQcm9wcy5tb3VudGVkICYmICF0aGlzLnByb3BzLm1vdW50ZWQpIHtcbiAgICAgICAgICBSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLm1vdW50ZWQpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlckRpc3BsYWNlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnY29tcG9uZW50V2lsbFVubW91bnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAoIWNhblVzZVBvcnRhbHMpIHtcbiAgICAgICAgICBSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMucmVuZGVyVG8pIHtcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlbmRlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICBpZiAoIWNhblVzZVBvcnRhbHMgfHwgdGhpcy5wcm9wcy5tb3VudGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwoUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCB0aGlzLnByb3BzLCB0aGlzLnByb3BzLmNoaWxkcmVuKSwgdGhpcy5jb250YWluZXIpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBEaXNwbGFjZWQ7XG4gIH0oUmVhY3QuQ29tcG9uZW50KTtcblxuICBEaXNwbGFjZWQuZGVmYXVsdFByb3BzID0ge1xuICAgIG1vdW50ZWQ6IHRydWVcbiAgfTtcbiAgRGlzcGxhY2VkLldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuXG5cbiAgcmV0dXJuIERpc3BsYWNlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkaXNwbGFjZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kaXNwbGFjZS9kaXN0L2Rpc3BsYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBY2VFZGl0b3IgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cblx0XHR0aGlzLnVwZGF0ZVZhbHVlID0gdGhpcy51cGRhdGVWYWx1ZS5iaW5kKCB0aGlzICk7XG5cdFx0dGhpcy5pbnNlcnRTZWxlY3RvciA9IHRoaXMuaW5zZXJ0U2VsZWN0b3IuYmluZCggdGhpcyApO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdFx0dGhpcy5lZGl0b3IgPSBhY2UuZWRpdCggYGZvcm1pbmF0b3ItZmllbGQtJHsgdGhpcy5wcm9wcy5wcm9wZXJ0eSB9YCApO1xuXG5cdFx0dGhpcy5zZXNzaW9uID0gdGhpcy5lZGl0b3IuZ2V0U2Vzc2lvbigpO1xuXHRcdHRoaXMuc2Vzc2lvbi5zZXRVc2VXb3JrZXIoIGZhbHNlICk7XG5cdFx0dGhpcy5lZGl0b3Iuc2V0U2hvd1ByaW50TWFyZ2luKCBmYWxzZSApO1xuXG5cdFx0dGhpcy5zZXNzaW9uLnNldE1vZGUoICdhY2UvbW9kZS9jc3MnICk7XG5cdFx0dGhpcy5lZGl0b3Iuc2V0VGhlbWUoICdhY2UvdGhlbWUvc3VpJyApO1xuXHRcdHRoaXMuZWRpdG9yLnJlbmRlcmVyLnNldFNob3dHdXR0ZXIoIHRydWUgKTtcblx0XHR0aGlzLmVkaXRvci5zZXRIaWdobGlnaHRBY3RpdmVMaW5lKCB0cnVlICk7XG5cdFx0dGhpcy5lZGl0b3IuZm9jdXMoKTtcblxuXHRcdHRoaXMuZWRpdG9yLm9uKCAnY2hhbmdlJywgdGhpcy51cGRhdGVWYWx1ZSApO1xuXHR9XG5cblx0Y29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0dGhpcy5lZGl0b3IuZGVzdHJveSgpO1xuXHRcdHRoaXMuZWRpdG9yID0gbnVsbDtcblx0fVxuXG5cdGluc2VydFNlbGVjdG9yKCBzZWxlY3RvciApIHtcblx0XHRjb25zdCBzZWxlY3RDbGFzcyA9IHNlbGVjdG9yICsgJ3t9JztcblxuXHRcdHRoaXMuZWRpdG9yLm5hdmlnYXRlRmlsZUVuZCgpO1xuXHRcdHRoaXMuZWRpdG9yLmluc2VydCggc2VsZWN0Q2xhc3MgKTtcblx0XHR0aGlzLmVkaXRvci5uYXZpZ2F0ZUxlZnQoIDEgKTtcblx0XHR0aGlzLmVkaXRvci5mb2N1cygpO1xuXHR9XG5cblx0c2hvdWxkQ29tcG9uZW50VXBkYXRlKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHVwZGF0ZVZhbHVlKCkge1xuXHRcdHRoaXMucHJvcHMuYWN0aW9ucy5zZXR0aW5nc0FjdGlvbnMudXBkYXRlU2V0dGluZyhcblx0XHRcdHRoaXMucHJvcHMucHJvcGVydHksXG5cdFx0XHR0aGlzLmVkaXRvci5nZXRWYWx1ZSgpXG5cdFx0KTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCB2YWx1ZSA9IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXSApXG5cdFx0XHQ/ICcnXG5cdFx0XHQ6IHRoaXMucHJvcHMuc2V0dGluZ3NbIHRoaXMucHJvcHMucHJvcGVydHkgXTtcblxuXHRcdGxldCB0eXBlID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnR5cGUgKSA/IHRoaXMucHJvcHMudHlwZSA6ICdmb3JtJztcblxuXHRcdGlmICggJ3BkZi1mb3JtJyA9PT0gdGhpcy5wcm9wcy5mb3JtVHlwZSApIHtcblx0XHRcdHR5cGUgPSB0aGlzLnByb3BzLmZvcm1UeXBlO1xuXHRcdH1cblxuXHRcdGNvbnN0IGJhc2ljU2VsZWN0b3JzID0gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHQ8bGFiZWwgY2xhc3NOYW1lPVwic3VpLWxhYmVsXCI+eyB0cmFuc2xhdGUoICdCYXNpYyBzZWxlY3RvcnMnICkgfTwvbGFiZWw+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWFjZS1zZWxlY3RvcnNcIj5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3RvciggJyAnICkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnRm9ybScgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKFxuXHRcdFx0XHRcdFx0XHQnIC5mb3JtaW5hdG9yLXRpdGxlICdcblx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnU2VjdGlvbiBUaXRsZScgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKFxuXHRcdFx0XHRcdFx0XHQnIC5mb3JtaW5hdG9yLXN1YnRpdGxlICdcblx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnU2VjdGlvbiBTdWJ0aXRsZScgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKFxuXHRcdFx0XHRcdFx0XHQnIC5mb3JtaW5hdG9yLWxhYmVsICdcblx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnRmllbGQgTGFiZWwnICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3Rvcihcblx0XHRcdFx0XHRcdFx0JyAuZm9ybWluYXRvci1kZXNjcmlwdGlvbiAnXG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0ZpZWxkIERlc2NyaXB0aW9uJyApIH1cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0PGEgY2xhc3NOYW1lPVwic3VpLXNlbGVjdG9yIHN1aS1pbnNlcnQtc2VsZWN0b3JcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMuaW5zZXJ0U2VsZWN0b3IoXG5cdFx0XHRcdFx0XHRcdCcgLmZvcm1pbmF0b3ItaW5wdXQgJ1xuXHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdJbnB1dCcgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKFxuXHRcdFx0XHRcdFx0XHQnIC5mb3JtaW5hdG9yLXRleHRhcmVhICdcblx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnVGV4dGFyZWEnICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdCk7XG5cblx0XHRjb25zdCBwb2xsU2VsZWN0b3JzID0gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHQ8bGFiZWwgY2xhc3NOYW1lPVwic3VpLWxhYmVsXCI+eyB0cmFuc2xhdGUoICdCYXNpYyBzZWxlY3RvcnMnICkgfTwvbGFiZWw+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWFjZS1zZWxlY3RvcnNcIj5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3RvciggJyAnICkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnUG9sbCcgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKCAnIC5mb3JtaW5hdG9yLXBvbGwtLXF1ZXN0aW9uICcgKSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdRdWVzdGlvbicgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKCAnIC5mb3JtaW5hdG9yLXJhZGlvIC5mb3JtaW5hdG9yLXJhZGlvLWJ1bGxldCAnICkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnQW5zd2VyIElucHV0JyApIH1cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0PGEgY2xhc3NOYW1lPVwic3VpLXNlbGVjdG9yIHN1aS1pbnNlcnQtc2VsZWN0b3JcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMuaW5zZXJ0U2VsZWN0b3IoICcuZm9ybWluYXRvci1yYWRpbyAuZm9ybWluYXRvci1yYWRpby1sYWJlbCAnICkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnQW5zd2VyIExhYmVsJyApIH1cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0PGEgY2xhc3NOYW1lPVwic3VpLXNlbGVjdG9yIHN1aS1pbnNlcnQtc2VsZWN0b3JcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMuaW5zZXJ0U2VsZWN0b3IoICcgLmZvcm1pbmF0b3ItYnV0dG9uICcgKSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdTdWJtaXQgQnV0dG9uJyApIH1cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0PGEgY2xhc3NOYW1lPVwic3VpLXNlbGVjdG9yIHN1aS1pbnNlcnQtc2VsZWN0b3JcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMuaW5zZXJ0U2VsZWN0b3IoXG5cdFx0XHRcdFx0XHRcdCcgLmZvcm1pbmF0b3ItcG9sbC1mb290ZXIgYS5mb3JtaW5hdG9yLWxpbmssICcgK1xuXHRcdFx0XHRcdFx0XHQnLmZvcm1pbmF0b3ItcG9sbC1mb290ZXIgYS5mb3JtaW5hdG9yLWxpbms6dmlzaXRlZCAnXG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1ZpZXcgUmVzdWx0cyBMaW5rJyApIH1cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHQpO1xuXG5cdFx0Y29uc3QgcXVpelNlbGVjdG9ycyA9IChcblx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0PGxhYmVsIGNsYXNzTmFtZT1cInN1aS1sYWJlbFwiPnsgdHJhbnNsYXRlKCAnQmFzaWMgc2VsZWN0b3JzJyApIH08L2xhYmVsPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1hY2Utc2VsZWN0b3JzXCI+XG5cdFx0XHRcdFx0PGEgY2xhc3NOYW1lPVwic3VpLXNlbGVjdG9yIHN1aS1pbnNlcnQtc2VsZWN0b3JcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMuaW5zZXJ0U2VsZWN0b3IoICcgJyApIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1F1aXonICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3RvciggJy5mb3JtaW5hdG9yLXF1aXotLXRpdGxlICcgKSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdUaXRsZScgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKCAnLmZvcm1pbmF0b3ItcXVpei0tZGVzY3JpcHRpb24gcCAnICkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnRGVzY3JpcHRpb24nICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3RvciggJy5mb3JtaW5hdG9yLXF1ZXN0aW9uIC5mb3JtaW5hdG9yLWxlZ2VuZCAnICkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnUXVlc3Rpb24nICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3RvciggJy5mb3JtaW5hdG9yLWFuc3dlciAuZm9ybWluYXRvci1hbnN3ZXItLWRlc2lnbiAnICkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnQW5zd2VyIENvbnRhaW5lcicgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKFxuXHRcdFx0XHRcdFx0XHQnLmZvcm1pbmF0b3ItYW5zd2VyIC5mb3JtaW5hdG9yLWFuc3dlci0tbmFtZSAnXG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0Fuc3dlciBUZXh0JyApIH1cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHQpO1xuXG5cdFx0Y29uc3QgcGRmU2VsZWN0b3JzID0gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHQ8bGFiZWwgY2xhc3NOYW1lPVwic3VpLWxhYmVsXCI+eyB0cmFuc2xhdGUoICdQREYgc2VsZWN0b3JzJyApIH08L2xhYmVsPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1hY2Utc2VsZWN0b3JzXCI+XG5cdFx0XHRcdFx0PGEgY2xhc3NOYW1lPVwic3VpLXNlbGVjdG9yIHN1aS1pbnNlcnQtc2VsZWN0b3JcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMuaW5zZXJ0U2VsZWN0b3IoICdib2R5JyApIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0JvZHknICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3Rvcihcblx0XHRcdFx0XHRcdFx0Jy5mb3JtaW5hdG9yLXBkZi1oZWFkZXInXG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1BERiBIZWFkZXInICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3Rvcihcblx0XHRcdFx0XHRcdFx0Jy5wZGYtbG9nbydcblx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnTG9nbycgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKFxuXHRcdFx0XHRcdFx0XHQnLnBkZi10aXRsZSdcblx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnVGl0bGUnICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0XHQ8YSBjbGFzc05hbWU9XCJzdWktc2VsZWN0b3Igc3VpLWluc2VydC1zZWxlY3RvclwiXG5cdFx0XHRcdFx0XHRvbkNsaWNrPXsgKCkgPT4gdGhpcy5pbnNlcnRTZWxlY3Rvcihcblx0XHRcdFx0XHRcdFx0Jy5mb3JtaW5hdG9yLXJvdy1oZWFkaW5nIHRkJ1xuXHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdGaWVsZCBMYWJlbCcgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKFxuXHRcdFx0XHRcdFx0XHQnLmZvcm1pbmF0b3Itcm93LWNvbnRlbnQgdGQnXG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0ZpZWxkIFZhbHVlJyApIH1cblx0XHRcdFx0XHQ8L2E+XG5cdFx0XHRcdFx0PGEgY2xhc3NOYW1lPVwic3VpLXNlbGVjdG9yIHN1aS1pbnNlcnQtc2VsZWN0b3JcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17ICgpID0+IHRoaXMuaW5zZXJ0U2VsZWN0b3IoXG5cdFx0XHRcdFx0XHRcdCcuZm9ybWluYXRvci1wZGYtZm9vdGVyLXRleHQgdGQnXG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0Zvb3RlcicgKSB9XG5cdFx0XHRcdFx0PC9hPlxuXHRcdFx0XHRcdDxhIGNsYXNzTmFtZT1cInN1aS1zZWxlY3RvciBzdWktaW5zZXJ0LXNlbGVjdG9yXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyAoKSA9PiB0aGlzLmluc2VydFNlbGVjdG9yKFxuXHRcdFx0XHRcdFx0XHQnLmZvcm1pbmF0b3ItcGRmLXBhZ2luYXRpb24gdGQnXG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1BhZ2luYXRpb24nICkgfVxuXHRcdFx0XHRcdDwvYT5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdCk7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHR7IHR5cGUgPT09ICdmb3JtJyAmJiBiYXNpY1NlbGVjdG9ycyB9XG5cdFx0XHRcdHsgdHlwZSA9PT0gJ3BvbGwnICYmIHBvbGxTZWxlY3RvcnMgfVxuXHRcdFx0XHR7IHR5cGUgPT09ICdxdWl6JyAmJiBxdWl6U2VsZWN0b3JzIH1cblx0XHRcdFx0eyB0eXBlID09PSAncGRmLWZvcm0nICYmIHBkZlNlbGVjdG9ycyB9XG5cdFx0XHRcdDxkaXYgaWQ9eyBgZm9ybWluYXRvci1maWVsZC0keyB0aGlzLnByb3BzLnByb3BlcnR5IH1gIH1cblx0XHRcdFx0XHRkYXRhLXZhbHVlPXsgdmFsdWUgfVxuXHRcdFx0XHRcdHN0eWxlPXsgeyBoZWlnaHQ6ICcyMTBweCcgfSB9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7IHZhbHVlIH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9pbnB1dHMvYWNlLWVkaXRvci5qcyIsImltcG9ydCB7IGNyZWF0ZVN0b3JlLCBjb21wb3NlLCBhcHBseU1pZGRsZXdhcmUgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgdGh1bmsgZnJvbSAncmVkdXgtdGh1bmsnO1xuaW1wb3J0IGFwcFJlZHVjZXJzIGZyb20gJy4uL3JlZHVjZXJzJztcblxuY29uc3QgbmV3Q3JlYXRlU3RvcmUgPSBjb21wb3NlKCBhcHBseU1pZGRsZXdhcmUoIHRodW5rICkgKSggY3JlYXRlU3RvcmUgKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29uZmlndXJlU3RvcmUoIGluaXRpYWxTdGF0ZSApIHtcblx0cmV0dXJuIG5ld0NyZWF0ZVN0b3JlKCBhcHBSZWR1Y2VycywgaW5pdGlhbFN0YXRlICk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9zdG9yZS9jb25maWd1cmVTdG9yZS5qcyIsImltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gJ3JlZHV4JztcblxuLy8gSW1wb3J0IHJlZHVjZXJzXG5pbXBvcnQgd3JhcHBlcnMgZnJvbSAnLi93cmFwcGVycyc7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQgbW9kYWwgZnJvbSAnLi9tb2RhbCc7XG5pbXBvcnQgaW50ZWdyYXRpb25Db25kaXRpb25zIGZyb20gJy4uLy4uL2dsb2JhbC9yZWR1Y2Vycy9pbnRlZ3JhdGlvbnMnO1xuaW1wb3J0IGJlaGF2aW9yQXJyYXkgZnJvbSAnLi4vLi4vZ2xvYmFsL3JlZHVjZXJzL2JlaGF2aW9ycyc7XG5pbXBvcnQgbm90aWZpY2F0aW9ucyBmcm9tICcuL25vdGlmaWNhdGlvbnMnO1xuaW1wb3J0IHBkZnMgZnJvbSAnLi9wZGZzJztcblxuY29uc3QgYXBwUmVkdWNlcnMgPSBjb21iaW5lUmVkdWNlcnMoIHtcblx0Ly8gTGlzdCByZWR1Y2Vyc1xuXHR3cmFwcGVycyxcblx0c2V0dGluZ3MsXG5cdG1vZGFsLFxuXHRpbnRlZ3JhdGlvbkNvbmRpdGlvbnMsXG5cdGJlaGF2aW9yQXJyYXksXG5cdG5vdGlmaWNhdGlvbnMsXG5cdHBkZnNcbn0gKTtcblxuZXhwb3J0IGRlZmF1bHQgYXBwUmVkdWNlcnM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9yZWR1Y2Vycy9pbmRleC5qcyIsImltcG9ydCB7IHJlcGxhY2VJblBvc2l0aW9uIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5mdW5jdGlvbiB1cGRhdGVGaWVsZCggc3RhdGUsIGFjdGlvbiApIHtcblx0Y29uc3QgeyB3cmFwcGVyIH0gPSBhY3Rpb247XG5cdGNvbnN0IHdyYXBwZXJJbmRleCA9IHN0YXRlLmZpbmRJbmRleCggd3JhcCA9PiB3cmFwLndyYXBwZXJfaWQgPT09IHdyYXBwZXIud3JhcHBlcl9pZCApO1xuXG5cdHN0YXRlID0gcmVwbGFjZUluUG9zaXRpb24oIHN0YXRlLCB3cmFwcGVySW5kZXgsIHdyYXBwZXIgKTtcblxuXHRyZXR1cm4gc3RhdGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdyYXBwZXJzKCBzdGF0ZSA9IFtdLCBhY3Rpb24gKSB7XG5cdHN3aXRjaCAoIGFjdGlvbi50eXBlICkge1xuXHRcdGNhc2UgJ1VQREFURV9GSUVMRFMnOlxuXHRcdFx0cmV0dXJuIGFjdGlvbi53cmFwcGVycztcblx0XHRjYXNlICdVUERBVEVfRklFTEQnOlxuXHRcdFx0cmV0dXJuIHVwZGF0ZUZpZWxkKCBbIC4uLnN0YXRlIF0sIGFjdGlvbiApO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL3JlZHVjZXJzL3dyYXBwZXJzLmpzIiwiZnVuY3Rpb24gdXBkYXRlU2V0dGluZyggc3RhdGUsIGFjdGlvbiApIHtcblx0Y29uc3QgeyBzZXR0aW5nLCB2YWx1ZSB9ID0gYWN0aW9uO1xuXG5cdC8vIFVwZGF0ZSB2YWx1ZVxuXHRzdGF0ZVsgc2V0dGluZyBdID0gdmFsdWU7XG5cblx0cmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTZXR0aW5ncyggc3RhdGUsIGFjdGlvbiApIHtcblx0Y29uc3QgeyBzZXR0aW5ncyB9ID0gYWN0aW9uO1xuXG5cdHJldHVybiB7XG5cdFx0Li4uc3RhdGUsXG5cdFx0Li4uc2V0dGluZ3Ncblx0fVxufVxuXG5mdW5jdGlvbiByZXNldFNldHRpbmdzKCBzdGF0ZSwgYWN0aW9uICkge1xuXHRjb25zdCB7IHNldHRpbmdzIH0gPSBhY3Rpb247XG5cdHJldHVybiB7XG5cdFx0Li4uc2V0dGluZ3Ncblx0fTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVGl0bGUoIHN0YXRlLCBhY3Rpb24gKSB7XG5cdGNvbnN0IHsgdGl0bGUgfSA9IGFjdGlvbjtcblxuXHQvLyBVcGRhdGUgdmFsdWVcblx0c3RhdGUuZm9ybU5hbWUgPSB0aXRsZTtcblxuXHRyZXR1cm4gc3RhdGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHRpbmdzKCBzdGF0ZSA9IFtdLCBhY3Rpb24gKSB7XG5cdGNvbnN0IG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbigge30sIHN0YXRlICk7XG5cblx0c3dpdGNoICggYWN0aW9uLnR5cGUgKSB7XG5cdFx0Y2FzZSAnVVBEQVRFX1NFVFRJTkdTJzpcblx0XHRcdHJldHVybiB1cGRhdGVTZXR0aW5ncyggbmV3U3RhdGUsIGFjdGlvbiApO1xuXHRcdGNhc2UgJ1JFU0VUX1NFVFRJTkdTJzpcblx0XHRcdHJldHVybiByZXNldFNldHRpbmdzKCBuZXdTdGF0ZSwgYWN0aW9uICk7XG5cdFx0Y2FzZSAnVVBEQVRFX1NFVFRJTkcnOlxuXHRcdFx0cmV0dXJuIHVwZGF0ZVNldHRpbmcoIG5ld1N0YXRlLCBhY3Rpb24gKTtcblx0XHRjYXNlICdVUERBVEVfVElUTEUnOlxuXHRcdFx0cmV0dXJuIHVwZGF0ZVRpdGxlKCBuZXdTdGF0ZSwgYWN0aW9uICk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBzdGF0ZTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Zvcm0vcmVkdWNlcnMvc2V0dGluZ3MuanMiLCJjb25zdCBpbml0aWFsU3RhdGUgPSB7XG5cdG1vZGFsVHlwZTogbnVsbCxcblx0bW9kYWxQcm9wczoge30sXG59O1xuXG5leHBvcnQgZGVmYXVsdCAoIHN0YXRlID0gaW5pdGlhbFN0YXRlLCBhY3Rpb24gKSA9PiB7XG5cdHN3aXRjaCAoIGFjdGlvbi50eXBlICkge1xuXHRcdGNhc2UgJ1NIT1dfTU9EQUwnOlxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bW9kYWxQcm9wczogYWN0aW9uLm1vZGFsUHJvcHMsXG5cdFx0XHRcdG1vZGFsVHlwZTogYWN0aW9uLm1vZGFsVHlwZSxcblx0XHRcdFx0dHlwZTogYWN0aW9uLnR5cGUsXG5cdFx0XHR9O1xuXHRcdGNhc2UgJ0hJREVfTU9EQUwnOlxuXHRcdFx0cmV0dXJuIGluaXRpYWxTdGF0ZTtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIHN0YXRlO1xuXHR9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Zvcm0vcmVkdWNlcnMvbW9kYWwuanMiLCJpbXBvcnQgeyByZXBsYWNlSW5Qb3NpdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW50ZWdyYXRpb25Db25kaXRpb25zKCBzdGF0ZSA9IFtdLCBhY3Rpb24gKSB7XG5cdHN3aXRjaCAoIGFjdGlvbi50eXBlICkge1xuXHRcdGNhc2UgJ1VQREFURV9JTlRFR1JBVElPTl9DT05ESVRJT05TJzpcblx0XHRcdHJldHVybiBhY3Rpb24uY29uZGl0aW9ucztcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIHN0YXRlO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZ2xvYmFsL3JlZHVjZXJzL2ludGVncmF0aW9ucy5qcyIsImltcG9ydCB7IHJlcGxhY2VJblBvc2l0aW9uIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5mdW5jdGlvbiB1cGRhdGVCZWhhdmlvckFycmF5KCBzdGF0ZSwgYWN0aW9uICkge1xuXHRjb25zdCB7IGJlaGF2aW9yIH0gPSBhY3Rpb247XG5cdGNvbnN0IGJlaGF2aW9ySW5kZXggPSBzdGF0ZS5maW5kSW5kZXgoIG5vdGlmeSA9PiBub3RpZnkuc2x1ZyA9PT0gYmVoYXZpb3Iuc2x1ZyApO1xuXG5cdHN0YXRlID0gcmVwbGFjZUluUG9zaXRpb24oIHN0YXRlLCBiZWhhdmlvckluZGV4LCBiZWhhdmlvciApO1xuXG5cdHJldHVybiBzdGF0ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmVoYXZpb3JzKCBzdGF0ZSA9IFtdLCBhY3Rpb24gKSB7XG5cdHN3aXRjaCAoIGFjdGlvbi50eXBlICkge1xuXHRcdGNhc2UgJ1VQREFURV9CRUhBVklPUlMnOlxuXHRcdFx0cmV0dXJuIGFjdGlvbi5iZWhhdmlvcnM7XG5cdFx0Y2FzZSAnVVBEQVRFX0JFSEFWSU9SJzpcblx0XHRcdHJldHVybiB1cGRhdGVCZWhhdmlvckFycmF5KCBbIC4uLnN0YXRlIF0sIGFjdGlvbiApO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9nbG9iYWwvcmVkdWNlcnMvYmVoYXZpb3JzLmpzIiwiaW1wb3J0IHsgcmVwbGFjZUluUG9zaXRpb24gfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmZ1bmN0aW9uIHVwZGF0ZU5vdGlmaWNhdGlvbiggc3RhdGUsIGFjdGlvbiApIHtcblx0Y29uc3QgeyBub3RpZmljYXRpb24gfSA9IGFjdGlvbjtcblx0Y29uc3Qgbm90aWZpY2F0aW9uSW5kZXggPSBzdGF0ZS5maW5kSW5kZXgoIG5vdGlmeSA9PiBub3RpZnkuc2x1ZyA9PT0gbm90aWZpY2F0aW9uLnNsdWcgKTtcblxuXHRzdGF0ZSA9IHJlcGxhY2VJblBvc2l0aW9uKCBzdGF0ZSwgbm90aWZpY2F0aW9uSW5kZXgsIG5vdGlmaWNhdGlvbiApO1xuXG5cdHJldHVybiBzdGF0ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm90aWZpY2F0aW9ucyggc3RhdGUgPSBbXSwgYWN0aW9uICkge1xuXHRzd2l0Y2ggKCBhY3Rpb24udHlwZSApIHtcblx0XHRjYXNlICdVUERBVEVfTk9USUZJQ0FUSU9OUyc6XG5cdFx0XHRyZXR1cm4gYWN0aW9uLm5vdGlmaWNhdGlvbnM7XG5cdFx0Y2FzZSAnVVBEQVRFX05PVElGSUNBVElPTic6XG5cdFx0XHRyZXR1cm4gdXBkYXRlTm90aWZpY2F0aW9uKCBbIC4uLnN0YXRlIF0sIGFjdGlvbiApO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL3JlZHVjZXJzL25vdGlmaWNhdGlvbnMuanMiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwZGZzKCBzdGF0ZSA9IFtdLCBhY3Rpb24gKSB7XG5cdHN3aXRjaCAoIGFjdGlvbi50eXBlICkge1xuXHRcdGNhc2UgJ1VQREFURV9QREZTJzpcblx0XHRcdHJldHVybiBhY3Rpb24ucGRmcztcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIHN0YXRlO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9yZWR1Y2Vycy9wZGZzLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kYWxJbWFnZSBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBpbWFnZSA9IHRoaXMucHJvcHMuZmlsZW5hbWUgPyB0aGlzLnByb3BzLmZpbGVuYW1lIDogJyc7XG5cblx0XHRsZXQgZ2V0Y2xhc3MgPSAnc3VpLWJveC1iYW5uZXInO1xuXHRcdGxldCBnZXRhbHQgPSB0cmFuc2xhdGUoICdGb3JtaW5hdG9yIGltYWdlJyApO1xuXG5cdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMubG9nbyApICYmIHRydWUgPT09IHRoaXMucHJvcHMubG9nbyApIHtcblx0XHRcdGdldGNsYXNzID0gJ3N1aS1ib3gtbG9nbyc7XG5cdFx0fVxuXG5cdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuYWx0ICkgJiYgJycgIT09IHRoaXMucHJvcHMuYWx0ICkge1xuXHRcdFx0Z2V0YWx0ID0gdGhpcy5wcm9wcy5hbHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxmaWd1cmUgY2xhc3NOYW1lPXsgZ2V0Y2xhc3MgfSBhcmlhLWhpZGRlbj1cInRydWVcIj5cblxuXHRcdFx0XHQ8aW1nXG5cdFx0XHRcdFx0c3JjPXsgZm9ybWluYXRvckRhdGEuaW1hZ2VzVXJsICsgJy8nICsgaW1hZ2UgKyAnLnBuZycgfVxuXHRcdFx0XHRcdHNyY1NldD17IGAkeyBmb3JtaW5hdG9yRGF0YS5pbWFnZXNVcmwgfS8keyBpbWFnZSB9LnBuZyAxeCxcblx0XHRcdFx0XHQkeyBmb3JtaW5hdG9yRGF0YS5pbWFnZXNVcmwgfS8keyBpbWFnZSB9QDJ4LnBuZyAyeGAgfVxuXHRcdFx0XHRcdGFsdD17IGdldGFsdCB9XG5cdFx0XHRcdC8+XG5cblx0XHRcdDwvZmlndXJlPlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvbW9kYWxzL3BhcnRpYWxzL2ltYWdlLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJvdXRlLCBSZWRpcmVjdCwgTmF2TGluayB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgRGVzaWduRGVmYXVsdCBmcm9tICcuL2Rlc2lnbi9kZWZhdWx0JztcbmltcG9ydCBEZXNpZ25GbGF0IGZyb20gJy4vZGVzaWduL2ZsYXQnO1xuaW1wb3J0IERlc2lnbkJvbGQgZnJvbSAnLi9kZXNpZ24vYm9sZCc7XG5pbXBvcnQgRGVzaWduTWF0ZXJpYWwgZnJvbSAnLi9kZXNpZ24vbWF0ZXJpYWwnO1xuaW1wb3J0IERlc2lnbkJhc2ljIGZyb20gJy4vZGVzaWduL2Jhc2ljJztcbmltcG9ydCBEZXNpZ25Ob25lIGZyb20gJy4vZGVzaWduL25vbmUnO1xuaW1wb3J0IFJhZGlvVGFicyBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvcmFkaW8tdGFicyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlc2lnblN0eWxlIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3Mtcm93XCI+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMVwiPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1zZXR0aW5ncy1sYWJlbFwiPnt0cmFuc2xhdGUoICdEZXNpZ24gU3R5bGUnICl9PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPlxuXHRcdFx0XHRcdFx0e3RyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0XCJDaG9vc2UgYSBwcmUtbWFkZSBzdHlsZSBmb3IgeW91ciBmb3JtIGFuZCBmdXJ0aGVyIGN1c3RvbWl6ZSBpdCdzIGFwcGVhcmFuY2UgYmVsb3cuXCJcblx0XHRcdFx0XHRcdCl9XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0yXCI+XG5cdFx0XHRcdFx0PFJhZGlvVGFic1xuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PVwiZm9ybS1zdHlsZVwiXG5cdFx0XHRcdFx0XHRkZWZhdWx0PVwiZGVmYXVsdFwiXG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0PERlc2lnbkRlZmF1bHQgdmFsdWU9XCJkZWZhdWx0XCIgYm94Q2xhc3M9XCJzdWktdGFiLWNvbnRlbnQgc3VpLXRhYi1ib3hlZFwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0RlZmF1bHQnICkgfVxuXHRcdFx0XHRcdFx0PC9EZXNpZ25EZWZhdWx0PlxuXHRcdFx0XHRcdFx0PERlc2lnbkZsYXQgdmFsdWU9XCJmbGF0XCIgYm94Q2xhc3M9XCJzdWktdGFiLWNvbnRlbnQgc3VpLXRhYi1ib3hlZFwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0ZsYXQnICkgfVxuXHRcdFx0XHRcdFx0PC9EZXNpZ25GbGF0PlxuXHRcdFx0XHRcdFx0PERlc2lnbkJvbGQgdmFsdWU9XCJib2xkXCIgYm94Q2xhc3M9XCJzdWktdGFiLWNvbnRlbnQgc3VpLXRhYi1ib3hlZFwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0JvbGQnICkgfVxuXHRcdFx0XHRcdFx0PC9EZXNpZ25Cb2xkPlxuXHRcdFx0XHRcdFx0PERlc2lnbk1hdGVyaWFsIHZhbHVlPVwibWF0ZXJpYWxcIiBib3hDbGFzcz1cInN1aS10YWItY29udGVudCBzdWktdGFiLWJveGVkXCI+XG5cdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnTWF0ZXJpYWwnICkgfVxuXHRcdFx0XHRcdFx0PC9EZXNpZ25NYXRlcmlhbD5cblx0XHRcdFx0XHRcdHsvKiA8RGVzaWduQmFzaWMgdmFsdWU9XCJiYXNpY1wiIGJveENsYXNzPVwic3VpLXRhYi1jb250ZW50IHN1aS10YWItYm94ZWRcIj5cblx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdUaGVtZSBzdHlsZScgKSB9XG5cdFx0XHRcdFx0XHQ8L0Rlc2lnbkJhc2ljPiAqL31cblx0XHRcdFx0XHRcdDxEZXNpZ25Ob25lIHZhbHVlPVwibm9uZVwiIGJveENsYXNzPVwic3VpLXRhYi1jb250ZW50XCI+XG5cdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnTm9uZScgKSB9XG5cdFx0XHRcdFx0XHQ8L0Rlc2lnbk5vbmU+XG5cdFx0XHRcdFx0PC9SYWRpb1RhYnM+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2Rlc2lnbi5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGRlc2lnbkRlZmF1bHQgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZnVpLWRlbW8gZnVpLWRlbW8tLWN1c3RvbS1mb3JtIGZ1aS1kZW1vLS1kZWZhdWx0XCI+XG5cdFx0XHRcdDxsYWJlbD57IHRyYW5zbGF0ZSggJ0ZpZWxkIExhYmVsJyApIH08L2xhYmVsPlxuXHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0cGxhY2Vob2xkZXI9eyB0cmFuc2xhdGUoICdQbGFjZWhvbGRlcicgKSB9XG5cdFx0XHRcdFx0cmVhZE9ubHk9XCJyZWFkb25seVwiXG5cdFx0XHRcdC8+XG5cblx0XHRcdFx0PGxhYmVsPnsgdHJhbnNsYXRlKCAnRmllbGQgTGFiZWwnICkgfTwvbGFiZWw+XG5cdFx0XHRcdDxpbnB1dCB0eXBlPVwidGV4dFwiIHZhbHVlPXsgdHJhbnNsYXRlKCAnVGV4dCcgKSB9IHJlYWRPbmx5PVwicmVhZG9ubHlcIiAvPlxuXG5cdFx0XHRcdDxidXR0b24+eyB0cmFuc2xhdGUoICdCdXR0b24nICkgfTwvYnV0dG9uPlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2Rlc2lnbi9kZWZhdWx0LmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZGVzaWduRmxhdCBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmdWktZGVtbyBmdWktZGVtby0tY3VzdG9tLWZvcm0gZnVpLWRlbW8tLWZsYXRcIj5cblx0XHRcdFx0PGxhYmVsPnsgdHJhbnNsYXRlKCAnRmllbGQgTGFiZWwnICkgfTwvbGFiZWw+XG5cdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdHR5cGU9XCJ0ZXh0XCJcblx0XHRcdFx0XHRwbGFjZWhvbGRlcj17IHRyYW5zbGF0ZSggJ1BsYWNlaG9sZGVyJyApIH1cblx0XHRcdFx0XHRyZWFkT25seT1cInJlYWRvbmx5XCJcblx0XHRcdFx0Lz5cblxuXHRcdFx0XHQ8bGFiZWw+eyB0cmFuc2xhdGUoICdGaWVsZCBMYWJlbCcgKSB9PC9sYWJlbD5cblx0XHRcdFx0PGlucHV0IHR5cGU9XCJ0ZXh0XCIgdmFsdWU9eyB0cmFuc2xhdGUoICdUZXh0JyApIH0gcmVhZE9ubHk9XCJyZWFkb25seVwiIC8+XG5cblx0XHRcdFx0PGJ1dHRvbj57IHRyYW5zbGF0ZSggJ0J1dHRvbicgKSB9PC9idXR0b24+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvZGVzaWduL2ZsYXQuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBkZXNpZ25Cb2xkIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZ1aS1kZW1vIGZ1aS1kZW1vLS1jdXN0b20tZm9ybSBmdWktZGVtby0tYm9sZFwiPlxuXHRcdFx0XHQ8bGFiZWw+eyB0cmFuc2xhdGUoICdGaWVsZCBMYWJlbCcgKSB9PC9sYWJlbD5cblx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0dHlwZT1cInRleHRcIlxuXHRcdFx0XHRcdHBsYWNlaG9sZGVyPXsgdHJhbnNsYXRlKCAnUGxhY2Vob2xkZXInICkgfVxuXHRcdFx0XHRcdHJlYWRPbmx5PVwicmVhZG9ubHlcIlxuXHRcdFx0XHQvPlxuXG5cdFx0XHRcdDxsYWJlbD57IHRyYW5zbGF0ZSggJ0ZpZWxkIExhYmVsJyApIH08L2xhYmVsPlxuXHRcdFx0XHQ8aW5wdXQgdHlwZT1cInRleHRcIiB2YWx1ZT17IHRyYW5zbGF0ZSggJ1RleHQnICkgfSByZWFkT25seT1cInJlYWRvbmx5XCIgLz5cblxuXHRcdFx0XHQ8YnV0dG9uPnsgdHJhbnNsYXRlKCAnQnV0dG9uJyApIH08L2J1dHRvbj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9kZXNpZ24vYm9sZC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGRlc2lnbk1hdGVyaWFsIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZ1aS1kZW1vIGZ1aS1kZW1vLS1jdXN0b20tZm9ybSBmdWktZGVtby0tbWF0ZXJpYWxcIj5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmdWktaXNfZW1wdHlcIj5cblx0XHRcdFx0XHQ8bGFiZWw+eyB0cmFuc2xhdGUoICdGaWVsZCBMYWJlbCcgKSB9PC9sYWJlbD5cblx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdHR5cGU9XCJ0ZXh0XCJcblx0XHRcdFx0XHRcdHJlYWRPbmx5PVwicmVhZG9ubHlcIlxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZnVpLWlzX2ZpbGxlZFwiPlxuXHRcdFx0XHRcdDxsYWJlbD57IHRyYW5zbGF0ZSggJ0ZpZWxkIExhYmVsJyApIH08L2xhYmVsPlxuXHRcdFx0XHRcdDxpbnB1dCB0eXBlPVwidGV4dFwiIHZhbHVlPXsgdHJhbnNsYXRlKCAnVGV4dCcgKSB9IHJlYWRPbmx5PVwicmVhZG9ubHlcIiAvPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8YnV0dG9uPnsgdHJhbnNsYXRlKCAnQnV0dG9uJyApIH08L2J1dHRvbj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9kZXNpZ24vbWF0ZXJpYWwuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZXNpZ25CYXNpYyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmdWktZGVtbyBmdWktZGVtby0tY3VzdG9tLWZvcm0gZnVpLWRlbW8tLWJhc2ljXCI+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZnVpLWlzX2VtcHR5XCI+XG5cdFx0XHRcdFx0PGxhYmVsPnsgdHJhbnNsYXRlKCAnRmllbGQgTGFiZWwnICkgfTwvbGFiZWw+XG5cdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0XHRyZWFkT25seT1cInJlYWRvbmx5XCJcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZ1aS1pc19maWxsZWRcIj5cblx0XHRcdFx0XHQ8bGFiZWw+eyB0cmFuc2xhdGUoICdGaWVsZCBMYWJlbCcgKSB9PC9sYWJlbD5cblx0XHRcdFx0XHQ8aW5wdXQgdHlwZT1cInRleHRcIiB2YWx1ZT17IHRyYW5zbGF0ZSggJ1RleHQnICkgfSByZWFkT25seT1cInJlYWRvbmx5XCIgLz5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGJ1dHRvbj57IHRyYW5zbGF0ZSggJ0J1dHRvbicgKSB9PC9idXR0b24+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvZGVzaWduL2Jhc2ljLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZGVzaWduTm9uZSBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdlxuXHRcdFx0XHRyb2xlPVwiYWxlcnRcIlxuXHRcdFx0XHRjbGFzc05hbWU9XCJzdWktbm90aWNlIHN1aS1hY3RpdmVcIlxuXHRcdFx0XHRzdHlsZT17IHsgZGlzcGxheTogJ2Jsb2NrJyB9IH1cblx0XHRcdFx0YXJpYS1saXZlPVwiYXNzZXJ0aXZlXCJcblx0XHRcdD5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ub3RpY2UtY29udGVudFwiPlxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktbm90aWNlLW1lc3NhZ2VcIj5cblxuXHRcdFx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwic3VpLW5vdGljZS1pY29uIHN1aS1pY29uLWluZm9cIlxuXHRcdFx0XHRcdFx0XHRhcmlhLWhpZGRlbj1cInRydWVcIlxuXHRcdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdFx0PHA+XG5cdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHRcdCdZb3UgaGF2ZSBvcHRlZCBmb3Igbm8gc3R5bGVzaGVldCB0byBiZSBlbnF1ZXVlZC4gJyArXG5cdFx0XHRcdFx0XHRcdFx0XCJUaGUgZm9ybSB3aWxsIGluaGVyaXQgc3R5bGVzIGZyb20geW91ciB0aGVtZSdzIENTUy5cIlxuXHRcdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHRcdDwvcD5cblxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvZGVzaWduL25vbmUuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHFzIGZyb20gJ3FzJztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5cbmltcG9ydCB7IHRyYW5zbGF0ZSwgaGFzRmllbGRUeXBlLCBoYXNGaWVsZFdpdGhBdHRyaWJ1dGUsIGhhc1Bvc3RkYXRhRmllbGRXaXRoTXVsdGlzZWxlY3QgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBBY2NvcmRpb24gZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9hY2NvcmRpb24nO1xuaW1wb3J0IEZvcm1Db250YWluZXIgZnJvbSAnLi9jb2xvcnMvZm9ybS1jb250YWluZXInO1xuaW1wb3J0IEZpZWxkc0Jhc2ljcyBmcm9tICcuL2NvbG9ycy9maWVsZHMtYmFzaWNzJztcbmltcG9ydCBSZXNwb25zZUxvYWRpbmdDb2xvcnMgZnJvbSAnLi9jb2xvcnMvcmVzcG9uc2UtbG9hZGluZyc7XG5pbXBvcnQgUmVzcG9uc2VFcnJvckNvbG9ycyBmcm9tICcuL2NvbG9ycy9yZXNwb25zZS1lcnJvcic7XG5pbXBvcnQgUmVzcG9uc2VTdWNjZXNzQ29sb3JzIGZyb20gJy4vY29sb3JzL3Jlc3BvbnNlLXN1Y2Nlc3MnO1xuaW1wb3J0IFNlY3Rpb25Db2xvcnMgZnJvbSAnLi9jb2xvcnMvc2VjdGlvbic7XG5pbXBvcnQgSW5wdXRzQ29sb3JzIGZyb20gJy4vY29sb3JzL2lucHV0cyc7XG5pbXBvcnQgSW5wdXRzRXh0cmFDb2xvcnMgZnJvbSAnLi9jb2xvcnMvaW5wdXRzLWV4dHJhJztcbmltcG9ydCBSYWRpb0NvbG9ycyBmcm9tICcuL2NvbG9ycy9yYWRpbyc7XG5pbXBvcnQgQ29uc2VudENvbG9ycyBmcm9tICcuL2NvbG9ycy9jb25zZW50JztcbmltcG9ydCBTZWxlY3RDb2xvcnMgZnJvbSAnLi9jb2xvcnMvc2VsZWN0JztcbmltcG9ydCBEcm9wZG93bkNvbG9ycyBmcm9tICcuL2NvbG9ycy9kcm9wZG93bic7XG5pbXBvcnQgU2VhcmNoQ29sb3JzIGZyb20gJy4vY29sb3JzL2Ryb3Bkb3duLXNlYXJjaCc7XG5pbXBvcnQgTXVsdGlTZWxlY3RDb2xvcnMgZnJvbSAnLi9jb2xvcnMvbXVsdGktc2VsZWN0JztcbmltcG9ydCBDYWxlbmRhckJhc2ljQ29sb3JzIGZyb20gJy4vY29sb3JzL2NhbGVuZGFyLWJhc2ljcyc7XG5pbXBvcnQgU2lnbmF0dXJlIGZyb20gJy4vY29sb3JzL3NpZ25hdHVyZSc7XG5pbXBvcnQgR3JvdXBDb2xvcnMgZnJvbSAnLi9jb2xvcnMvZ3JvdXAnO1xuaW1wb3J0IFJlcGVhdGVyQ29sb3JzIGZyb20gJy4vY29sb3JzL3JlcGVhdGVyJztcbmltcG9ydCBDYWxlbmRhclRhYmxlQ29sb3JzIGZyb20gJy4vY29sb3JzL2NhbGVuZGFyLXRhYmxlJztcbi8vaW1wb3J0IFBhZ2luYXRpb25Db2xvcnMgZnJvbSAnLi9jb2xvcnMvcGFnaW5hdGlvbic7XG5pbXBvcnQgU3RlcHNDb2xvcnMgZnJvbSAnLi9jb2xvcnMvcGFnaW5hdGlvbi1zdGVwcyc7XG5pbXBvcnQgUHJvZ3Jlc3NDb2xvcnMgZnJvbSAnLi9jb2xvcnMvcGFnaW5hdGlvbi1wcm9ncmVzcyc7XG5pbXBvcnQgQmFja0NvbG9ycyBmcm9tICcuL2NvbG9ycy9wYWdpbmF0aW9uLWJhY2snO1xuaW1wb3J0IE5leHRDb2xvcnMgZnJvbSAnLi9jb2xvcnMvcGFnaW5hdGlvbi1uZXh0JztcbmltcG9ydCBTdWJtaXRDb2xvcnMgZnJvbSAnLi9jb2xvcnMvc3VibWl0JztcbmltcG9ydCBFbXB0eSBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2VtcHR5JztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9jb250YWluZXInO1xuaW1wb3J0IFJhZGlvVGFicyBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvcmFkaW8tdGFicyc7XG5pbXBvcnQgVXBsb2FkZWRGaWxlc0NvbG9ycyBmcm9tICcuL2NvbG9ycy91cGxvYWRlZC1maWxlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9ycyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdHRoaXMubG9hZEZvbnRzKCk7XG5cdH1cblxuXHRjb21wb25lbnREaWRVcGRhdGUoKSB7XG5cdFx0dGhpcy5sb2FkRm9udHMoKTtcblx0fVxuXG5cdGxvYWRGb250cygpIHtcblx0XHRpZiAoICEgXy5pc1VuZGVmaW5lZCggd2luZG93LmZvcm1pbmF0b3JGb250cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IG9wdGlvbnMgPSB7XG5cdFx0XHRpc09iamVjdDogdHJ1ZVxuXHRcdH07XG5cblx0XHRjb25zdCBkYXRhID0ge1xuXHRcdFx0YWN0aW9uOiAnZm9ybWluYXRvcl9sb2FkX2dvb2dsZV9mb250cycsXG5cdFx0XHRkYXRhOiBvcHRpb25zLFxuXHRcdFx0X3dwbm9uY2U6IGZvcm1pbmF0b3JEYXRhLmdGb250Tm9uY2UsXG5cdFx0fTtcblxuXHRcdGF4aW9zLnBvc3QoIGZvcm1pbmF0b3JEYXRhLmFqYXhVcmwsXG5cdFx0XHRxcy5zdHJpbmdpZnkoIGRhdGEgKVxuXHRcdClcblx0XHRcdC50aGVuKCAoIHJlc3BvbnNlICkgPT4ge1xuXHRcdFx0XHR3aW5kb3cuZm9ybWluYXRvckZvbnRzID0gcmVzcG9uc2UuZGF0YS5kYXRhO1xuXHRcdFx0fSApXG5cdFx0XHQuY2F0Y2goICggZXJyICkgPT4ge1xuXHRcdFx0XHRjb25zb2xlLmxvZyggZXJyICk7XG5cdFx0XHR9ICk7XG5cdH1cblxuXHRoYXNJbmRpY2F0b3JFbmFibGVkKCBzZXR0aW5ncyApIHtcblx0XHRpZiAoIHR5cGVvZiBzZXR0aW5nc1sgJ3N1Ym1pc3Npb24taW5kaWNhdG9yJyBdICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0c2V0dGluZ3NbICdzdWJtaXNzaW9uLWluZGljYXRvcicgXSA9PT0gJ3Nob3cnICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGhhc1BhZ2luYXRpb24gPSBoYXNGaWVsZFR5cGUoXG5cdFx0XHQncGFnZS1icmVhaycsXG5cdFx0XHR0aGlzLnByb3BzLndyYXBwZXJzXG5cdFx0KTtcblxuXHRcdGNvbnN0IGhhc1NlY3Rpb24gPSBoYXNGaWVsZFR5cGUoXG5cdFx0XHQnc2VjdGlvbicsXG5cdFx0XHR0aGlzLnByb3BzLndyYXBwZXJzXG5cdFx0KTtcblxuXHRcdGNvbnN0IGhhc1NpbmdsZVJhZGlvID0gaGFzRmllbGRXaXRoQXR0cmlidXRlKFxuXHRcdFx0dGhpcy5wcm9wcy53cmFwcGVycyxcblx0XHRcdCdyYWRpbycsXG5cdFx0XHQndmFsdWVfdHlwZScsXG5cdFx0XHQncmFkaW8nXG5cdFx0KTtcblxuXHRcdGNvbnN0IGhhc1NpbmdsZURyb3Bkb3duID0gaGFzRmllbGRXaXRoQXR0cmlidXRlKFxuXHRcdFx0dGhpcy5wcm9wcy53cmFwcGVycyxcblx0XHRcdCdzZWxlY3QnLFxuXHRcdFx0J3ZhbHVlX3R5cGUnLFxuXHRcdFx0J3NpbmdsZSdcblx0XHQpO1xuXG5cdFx0Y29uc3QgaGFzTXVsdGlDaGVja2JveCA9IGhhc0ZpZWxkV2l0aEF0dHJpYnV0ZShcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnMsXG5cdFx0XHQnY2hlY2tib3gnLFxuXHRcdFx0J3ZhbHVlX3R5cGUnLFxuXHRcdFx0J2NoZWNrYm94J1xuXHRcdCk7XG5cblx0XHRjb25zdCBoYXNNdWx0aVNlbGVjdCA9IGhhc0ZpZWxkV2l0aEF0dHJpYnV0ZShcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnMsXG5cdFx0XHQnc2VsZWN0Jyxcblx0XHRcdCd2YWx1ZV90eXBlJyxcblx0XHRcdCdtdWx0aXNlbGVjdCdcblx0XHQpO1xuXG5cdFx0Y29uc3QgaGFzRGF0ZVBpY2tlciA9IGhhc0ZpZWxkV2l0aEF0dHJpYnV0ZShcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnMsXG5cdFx0XHQnZGF0ZScsXG5cdFx0XHQnZmllbGRfdHlwZScsXG5cdFx0XHQncGlja2VyJ1xuXHRcdCk7XG5cblx0XHRjb25zdCBoYXNFU2lnbiA9IGhhc0ZpZWxkVHlwZShcblx0XHRcdCdzaWduYXR1cmUnLFxuXHRcdFx0dGhpcy5wcm9wcy53cmFwcGVyc1xuXHRcdCk7XG5cblx0XHRjb25zdCBoYXNHcm91cCA9IGhhc0ZpZWxkVHlwZShcblx0XHRcdCdncm91cCcsXG5cdFx0XHR0aGlzLnByb3BzLndyYXBwZXJzXG5cdFx0KTtcblxuXHRcdGNvbnN0IGhhc0RhdGVEcm9wZG93biA9IGhhc0ZpZWxkV2l0aEF0dHJpYnV0ZShcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnMsXG5cdFx0XHQnZGF0ZScsXG5cdFx0XHQnZmllbGRfdHlwZScsXG5cdFx0XHQnc2VsZWN0J1xuXHRcdCk7XG5cblx0XHRjb25zdCBoYXNUaW1lRHJvcGRvd24gPSBoYXNGaWVsZFdpdGhBdHRyaWJ1dGUoXG5cdFx0XHR0aGlzLnByb3BzLndyYXBwZXJzLFxuXHRcdFx0J3RpbWUnLFxuXHRcdFx0J2ZpZWxkX3R5cGUnLFxuXHRcdFx0J3NlbGVjdCdcblx0XHQpIHx8IGhhc0ZpZWxkV2l0aEF0dHJpYnV0ZShcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnMsXG5cdFx0XHQndGltZScsXG5cdFx0XHQndGltZV90eXBlJyxcblx0XHRcdCd0d2VsdmUnXG5cdFx0KTtcblxuXHRcdGNvbnN0IGhhc0FkZHJlc0NvdW50cnkgPSBoYXNGaWVsZFdpdGhBdHRyaWJ1dGUoXG5cdFx0XHR0aGlzLnByb3BzLndyYXBwZXJzLFxuXHRcdFx0J2FkZHJlc3MnLFxuXHRcdFx0J2FkZHJlc3NfY291bnRyeScsXG5cdFx0XHQndHJ1ZSdcblx0XHQpO1xuXG5cdFx0Y29uc3QgaGFzTmFtZVByZWZpeCA9IGhhc0ZpZWxkV2l0aEF0dHJpYnV0ZShcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnMsXG5cdFx0XHQnbmFtZScsXG5cdFx0XHQncHJlZml4Jyxcblx0XHRcdCd0cnVlJ1xuXHRcdCk7XG5cblx0XHRjb25zdCBoYXNHRFBSID0gaGFzRmllbGRUeXBlKFxuXHRcdFx0J2dkcHJjaGVja2JveCcsXG5cdFx0XHR0aGlzLnByb3BzLndyYXBwZXJzXG5cdFx0KTtcblxuXHRcdGNvbnN0IGhhc0ZpbGVVcGxvYWQgPSBoYXNGaWVsZFR5cGUoXG5cdFx0XHQndXBsb2FkJyxcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnNcblx0XHQpO1xuXG5cdFx0Y29uc3QgaGFzQ3VycmVuY3kgPSBoYXNGaWVsZFR5cGUoXG5cdFx0XHQnY3VycmVuY3knLFxuXHRcdFx0dGhpcy5wcm9wcy53cmFwcGVyc1xuXHRcdCk7XG5cblx0XHRjb25zdCBoYXNTdHJpcGUgPSBoYXNGaWVsZFR5cGUoXG5cdFx0XHQnc3RyaXBlJyxcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnNcblx0XHQpO1xuXG5cdFx0Y29uc3QgaGFzQ2FsY3VsYXRpb24gPSBoYXNGaWVsZFR5cGUoXG5cdFx0XHQnY2FsY3VsYXRpb24nLFxuXHRcdFx0dGhpcy5wcm9wcy53cmFwcGVyc1xuXHRcdCk7XG5cblx0XHRjb25zdCBoYXNDb25zZW50ID0gaGFzRmllbGRUeXBlKFxuXHRcdFx0J2NvbnNlbnQnLFxuXHRcdFx0dGhpcy5wcm9wcy53cmFwcGVyc1xuXHRcdCk7XG5cblx0XHRjb25zdCBwb3N0ZGF0YV9tdWx0aXBsZSA9IGhhc1Bvc3RkYXRhRmllbGRXaXRoTXVsdGlzZWxlY3QoXG5cdFx0XHR0aGlzLnByb3BzLndyYXBwZXJzXG5cdFx0KTtcblxuXHRcdGNvbnN0IGlzUHJlc2V0ID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnByZXNldCApO1xuXG5cdFx0Y29uc3QgaGFzSW5kaWNhdG9yID0gaXNQcmVzZXQgfHwgdGhpcy5oYXNJbmRpY2F0b3JFbmFibGVkKCB0aGlzLnByb3BzLnNldHRpbmdzICk7XG5cblx0XHRjb25zdCBoYXNQYWdpbmF0aW9uSGVhZGVyID0gXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5ncy5wYWdpbmF0aW9uRGF0YSApIHx8IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3MucGFnaW5hdGlvbkRhdGFbICdwYWdpbmF0aW9uLWhlYWRlci1kZXNpZ24nIF0gKVxuXHRcdFx0PyAnJ1xuXHRcdFx0OiB0aGlzLnByb3BzLnNldHRpbmdzLnBhZ2luYXRpb25EYXRhWyAncGFnaW5hdGlvbi1oZWFkZXItZGVzaWduJyBdO1xuXG5cdFx0Y29uc3QgcGFnaW5hdGlvbkhlYWRlciA9IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3MucGFnaW5hdGlvbkRhdGEgKSB8fF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3MucGFnaW5hdGlvbkRhdGFbICdwYWdpbmF0aW9uLWhlYWRlcicgXSApXG5cdFx0XHQ/ICcnXG5cdFx0XHQ6IHRoaXMucHJvcHMuc2V0dGluZ3MucGFnaW5hdGlvbkRhdGFbICdwYWdpbmF0aW9uLWhlYWRlcicgXTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3Mtcm93XCI+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0xXCI+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXNldHRpbmdzLWxhYmVsXCI+eyB0cmFuc2xhdGUoICdDb2xvcnMnICkgfTwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdCdBZGp1c3QgdGhlIGRlZmF1bHQgY29sb3IgY29tYmluYXRpb25zIHRvIG1hdGNoIHlvdXIgdGhlbWUgc3R5bGluZy4nXG5cdFx0XHRcdFx0KSB9PC9zcGFuPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3MtY29sLTJcIj5cblxuXHRcdFx0XHRcdDxSYWRpb1RhYnNcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT1cImNmb3JtLWNvbG9yLXNldHRpbmdzXCJcblx0XHRcdFx0XHRcdGRlZmF1bHQ9XCJcIlxuXHRcdFx0XHRcdD5cblxuXHRcdFx0XHRcdFx0PEVtcHR5IHZhbHVlPVwiXCIgYm94Q2xhc3M9XCJcIj5cblx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdVc2UgRGVmYXVsdCBDb2xvcnMnICkgfVxuXHRcdFx0XHRcdFx0PC9FbXB0eT5cblxuXHRcdFx0XHRcdFx0PENvbnRhaW5lciB2YWx1ZT1cInRydWVcIiBsYWJlbD17IHRyYW5zbGF0ZSggJ0N1c3RvbScgKSB9PlxuXG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWFjY29yZGlvblwiPlxuXG5cdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYWNjb3JkaW9uLWhlYWRlclwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0PGRpdj57IHRyYW5zbGF0ZSggJ0VsZW1lbnQnICkgfTwvZGl2PlxuXHRcdFx0XHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRm9ybSBDb250YWluZXInICkgfVxuXHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdDxGb3JtQ29udGFpbmVyIHsgLi4udGhpcy5wcm9wcyB9IC8+XG5cdFx0XHRcdFx0XHRcdFx0PC9BY2NvcmRpb24+XG5cblx0XHRcdFx0XHRcdFx0XHR7IGhhc0luZGljYXRvciAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1N1Ym1pc3Npb24gSW5kaWNhdG9yJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PFJlc3BvbnNlTG9hZGluZ0NvbG9ycyB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdFx0XHRcdFx0PC9BY2NvcmRpb24+XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUmVzcG9uc2UgU3VjY2VzcycgKSB9XG5cdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0PHAgY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCI+eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCdTdWNjZXNzZnVsIHJlc3BvbnNlIG1lc3NhZ2Ugd2lsbCBiZSBkaXNwbGF5ZWQgYWZ0ZXIgJyArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCdmb3JtIHN1Ym1pc3Npb24gc3VjY2VlZHMuJ1xuXHRcdFx0XHRcdFx0XHRcdFx0KSB9PC9wPlxuXHRcdFx0XHRcdFx0XHRcdFx0PFJlc3BvbnNlU3VjY2Vzc0NvbG9ycyB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUmVzcG9uc2UgRXJyb3InICkgfVxuXHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdDxwIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPnsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnRXJyb3IgcmVzcG9uc2UgbWVzc2FnZSB3aWxsIGJlIGRpc3BsYXllZCBhZnRlciAnICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0J2Zvcm0gc3VibWlzc2lvbiBmYWlscy4nXG5cdFx0XHRcdFx0XHRcdFx0XHQpIH08L3A+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8UmVzcG9uc2VFcnJvckNvbG9ycyB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHRcdFx0eyAoIGlzUHJlc2V0IHx8IGhhc1BhZ2luYXRpb24gJiYgaGFzUGFnaW5hdGlvbkhlYWRlciA9PT0gJ3Nob3cnICYmIHBhZ2luYXRpb25IZWFkZXIgPT09ICduYXYnICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0ey4uLnRoaXMucHJvcHN9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXt0cmFuc2xhdGUoJ1BhZ2luYXRpb24gU3RlcHMnKX1cblx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PFN0ZXBzQ29sb3JzIHsuLi50aGlzLnByb3BzfSAvPlxuXHRcdFx0XHRcdFx0XHRcdFx0PC9BY2NvcmRpb24+XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHsgKCBpc1ByZXNldCB8fCBoYXNQYWdpbmF0aW9uICYmIGhhc1BhZ2luYXRpb25IZWFkZXIgPT09ICdzaG93JyAmJiBwYWdpbmF0aW9uSGVhZGVyID09PSAnYmFyJyApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsuLi50aGlzLnByb3BzfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17dHJhbnNsYXRlKCdQYWdpbmF0aW9uIFByb2dyZXNzIEJhcicpfVxuXHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8UHJvZ3Jlc3NDb2xvcnMgey4uLnRoaXMucHJvcHN9IC8+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdGaWVsZHMgQmFzaWNzJyApIH1cblx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8RmllbGRzQmFzaWNzIHsgLi4udGhpcy5wcm9wcyB9IC8+XG5cdFx0XHRcdFx0XHRcdFx0PC9BY2NvcmRpb24+XG5cblx0XHRcdFx0XHRcdFx0XHR7IGhhc1NlY3Rpb24gJiZcblx0XHRcdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdTZWN0aW9uJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PFNlY3Rpb25Db2xvcnMgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0lucHV0IGFuZCBUZXh0YXJlYScgKSB9XG5cdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0PElucHV0c0NvbG9ycyB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHRcdFx0eyAoXG5cdFx0XHRcdFx0XHRcdFx0XHRoYXNEYXRlUGlja2VyIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRoYXNDdXJyZW5jeSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0aGFzU3RyaXBlIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRoYXNDYWxjdWxhdGlvblxuXHRcdFx0XHRcdFx0XHRcdCkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdJbnB1dCBFeHRyYXMnICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8SW5wdXRzRXh0cmFDb2xvcnMgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHsgKFxuXHRcdFx0XHRcdFx0XHRcdFx0aGFzTXVsdGlDaGVja2JveCB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0aGFzU2luZ2xlUmFkaW8gfHxcblx0XHRcdFx0XHRcdFx0XHRcdGhhc0dEUFJcblx0XHRcdFx0XHRcdFx0XHQpICYmXG5cdFx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUmFkaW8gYW5kIENoZWNrYm94JyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PFJhZGlvQ29sb3JzIHsgLi4udGhpcy5wcm9wcyB9IC8+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR7IChcblx0XHRcdFx0XHRcdFx0XHRcdGhhc1NpbmdsZURyb3Bkb3duIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRoYXNEYXRlRHJvcGRvd24gfHxcblx0XHRcdFx0XHRcdFx0XHRcdGhhc1RpbWVEcm9wZG93biB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0aGFzQWRkcmVzQ291bnRyeSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0aGFzTmFtZVByZWZpeFxuXHRcdFx0XHRcdFx0XHRcdCkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdTZWxlY3QnICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PFNlbGVjdENvbG9ycyB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdEcm9wZG93biBMaXN0JyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxEcm9wZG93bkNvbG9ycyB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblx0XHRcdFx0XHRcdFx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0eyBoYXNBZGRyZXNDb3VudHJ5ICYmXG5cdFx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRHJvcGRvd24gU2VhcmNoJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PFNlYXJjaENvbG9ycyB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdFx0XHRcdFx0PC9BY2NvcmRpb24+XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0eyAoXG5cdFx0XHRcdFx0XHRcdFx0XHRoYXNNdWx0aVNlbGVjdCB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0cG9zdGRhdGFfbXVsdGlwbGVcblx0XHRcdFx0XHRcdFx0XHQpICYmXG5cdFx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnTXVsdGkgU2VsZWN0JyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PE11bHRpU2VsZWN0Q29sb3JzIHsgLi4udGhpcy5wcm9wcyB9IC8+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR7IGhhc0RhdGVQaWNrZXIgJiZcblx0XHRcdFx0XHRcdFx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0NhbGVuZGFyIEJhc2ljcycgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8Q2FsZW5kYXJCYXNpY0NvbG9ycyB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0NhbGVuZGFyIFRhYmxlJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxDYWxlbmRhclRhYmxlQ29sb3JzIHsgLi4udGhpcy5wcm9wcyB9IC8+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHRcdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHsgaGFzRmlsZVVwbG9hZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRmlsZSBVcGxvYWQnICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRib3hlZENvbnRlbnQ9eyBmYWxzZSB9XG5cdFx0XHRcdFx0XHRcdFx0XHQ+XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PFVwbG9hZGVkRmlsZXNDb2xvcnMgeyAuLi50aGlzLnByb3BzIH0gLz5cblxuXHRcdFx0XHRcdFx0XHRcdFx0PC9BY2NvcmRpb24+XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0eyBoYXNFU2lnbiAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRS1TaWduYXR1cmUnICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PFNpZ25hdHVyZSB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblxuXHRcdFx0XHRcdFx0XHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR7IGhhc0dyb3VwICYmXG5cdFx0XHRcdFx0XHRcdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdGaWVsZCBHcm91cCcgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8R3JvdXBDb2xvcnMgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PC9BY2NvcmRpb24+XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdSZXBlYXRlciBCdXR0b24nICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJveGVkQ29udGVudD17IGZhbHNlIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxSZXBlYXRlckNvbG9ycyB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblxuXHRcdFx0XHRcdFx0XHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR7IGhhc1BhZ2luYXRpb24gJiZcblx0XHRcdFx0XHRcdFx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IC8qKlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1BhZ2luYXRpb24nICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PFBhZ2luYXRpb25Db2xvcnMgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PC9BY2NvcmRpb24+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCovIH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0J1dHRvbiBCYWNrJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxCYWNrQ29sb3JzIHsgLi4udGhpcy5wcm9wcyB9IC8+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQnV0dG9uIE5leHQnICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PE5leHRDb2xvcnMgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PC9BY2NvcmRpb24+XG5cblx0XHRcdFx0XHRcdFx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0eyAoIGhhc0NvbnNlbnQgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0NvbnNlbnQnICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8Q29uc2VudENvbG9ycyB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdFx0XHRcdFx0PC9BY2NvcmRpb24+XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnU3VibWl0IEJ1dHRvbicgKSB9XG5cdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0PFN1Ym1pdENvbG9ycyB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0XHRcdDwvUmFkaW9UYWJzPlxuXG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSwgZ2V0VGhlbWVQcmVmaXgsIGdldERlZmF1bHRWYWx1ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IENvbG9yUGlja2VyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9jb2xvci1waWNrZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY0NvbG9ycyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMwMDAwMDAwMFwiKSB9YH1cblx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1jZm9ybS1mb3JtLWJvcmRlcmB9XG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXIgY29sb3InICkgfVxuXHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0Lz5cblx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMDAwMDAwMDBcIikgfWB9XG5cdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Y2Zvcm0tZm9ybS1iYWNrZ3JvdW5kYH1cblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0Lz5cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9mb3JtLWNvbnRhaW5lci5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGdldFRoZW1lUHJlZml4LCBnZXREZWZhdWx0VmFsdWUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY29sb3ItcGlja2VyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2xvYmFsQ29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzc3Nzc3MVwiKSB9YH1cblx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1jZm9ybS1sYWJlbC1jb2xvcmB9XG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdMYWJlbCcgKSB9XG5cdFx0XHRcdC8+XG5cdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0UwNDU2MlwiKSB9YH1cblx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1jZm9ybS1hc3Rlcmlzay1jb2xvcmB9XG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdSZXF1aXJlZCBhc3RlcmlzaycgKSB9XG5cdFx0XHRcdC8+XG5cdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzc3Nzc3MVwiKSB9YH1cblx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1sYWJlbC1oZWxwZXItY29sb3JgfVxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRGVzY3JpcHRpb24nICkgfVxuXHRcdFx0XHQvPlxuXHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNGOUU0RThcIikgfWB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1sYWJlbC12YWxpZGF0aW9uLWJhY2tncm91bmRgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdFcnJvciBtZXNzYWdlIEJHJyApIH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHR9XG5cdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0UwNDU2MlwiKSB9YH1cblx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1sYWJlbC12YWxpZGF0aW9uLWNvbG9yYH1cblx0XHRcdFx0XHRsYWJlbD17IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJ1xuXHRcdFx0XHRcdFx0PyB0cmFuc2xhdGUoICdFcnJvciBtZXNzYWdlIGNvbG9yJyApXG5cdFx0XHRcdFx0XHQ6IHRyYW5zbGF0ZSggJ0dsb2JhbCBlcnJvciBjb2xvcicgKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZXNjcmlwdGlvbj17IHRoaXMucHJvcHMuZm9ybURlc2lnbiA9PT0gJ21hdGVyaWFsJ1xuXHRcdFx0XHRcdFx0PyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdCdUaGlzIGNvbG9yIHdpbGwgYmUgdXNlZCB3aGVuIGZpZWxkcyB0aHJvdyBhbiAnICtcblx0XHRcdFx0XHRcdFx0J2Vycm9yIGFzIHRleHQgY29sb3IsIGJvcmRlciBjb2xvciwgZXRjLidcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdDogJydcblx0XHRcdFx0XHR9XG5cdFx0XHRcdC8+XG5cdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvZmllbGRzLWJhc2ljcy5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGdldFRoZW1lUHJlZml4LCBnZXREZWZhdWx0VmFsdWUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY29sb3ItcGlja2VyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzcG9uc2VMb2FkaW5nQ29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnbWF0ZXJpYWwnICYmXG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0Y4RjhGOFwiKSB9YH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXJlc3BvbnNlLWxvYWRpbmctYmFja2dyb3VuZGB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdH1cblx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjNjY2NjY2XCIpIH1gfVxuXHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXJlc3BvbnNlLWxvYWRpbmctY29sb3JgfVxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGV4dCBjb2xvcicgKSB9XG5cdFx0XHRcdC8+XG5cdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvcmVzcG9uc2UtbG9hZGluZy5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGdldFRoZW1lUHJlZml4LCBnZXREZWZhdWx0VmFsdWUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY29sb3ItcGlja2VyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzcG9uc2VFcnJvckNvbG9ycyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ2ZsYXQnICYmXG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0UwNDU2MlwiKSB9YH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXJlc3BvbnNlLWVycm9yLWJvcmRlcmB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0fVxuXHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNGOUU0RThcIikgfWB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1yZXNwb25zZS1lcnJvci1iYWNrZ3JvdW5kYH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQmFja2dyb3VuZCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0fVxuXHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMzMzMzMzNcIikgfWB9XG5cdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9cmVzcG9uc2UtZXJyb3ItY29sb3JgfVxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGV4dCBjb2xvcicgKSB9XG5cdFx0XHRcdC8+XG5cdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvcmVzcG9uc2UtZXJyb3IuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlLCBnZXRUaGVtZVByZWZpeCwgZ2V0RGVmYXVsdFZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgQ29sb3JQaWNrZXIgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2NvbG9yLXBpY2tlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc3BvbnNlU3VjY2Vzc0NvbG9ycyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ2ZsYXQnICYmXG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzFBQkNBMVwiKSB9YH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXJlc3BvbnNlLXN1Y2Nlc3MtYm9yZGVyYH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQm9yZGVyIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHR9XG5cdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnbWF0ZXJpYWwnICYmXG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0JDRUVFNlwiKSB9YH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXJlc3BvbnNlLXN1Y2Nlc3MtYmFja2dyb3VuZGB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdH1cblx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMzMzMzMzXCIpIH1gfVxuXHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXJlc3BvbnNlLXN1Y2Nlc3MtY29sb3JgfVxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGV4dCBjb2xvcicgKSB9XG5cdFx0XHRcdC8+XG5cdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvcmVzcG9uc2Utc3VjY2Vzcy5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGdldFRoZW1lUHJlZml4LCBnZXREZWZhdWx0VmFsdWUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY29sb3ItcGlja2VyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VjdGlvbkNvbG9ycyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHQ8Q29sb3JQaWNrZXIgeyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RpdGxlIGNvbG9yJyApIH1cblx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1jZm9ybS10aXRsZS1jb2xvcmB9XG5cdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzMzMzMzM1wiKSB9YH0gLz5cblx0XHRcdFx0PENvbG9yUGlja2VyIHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdTdWJ0aXRsZSBjb2xvcicgKSB9XG5cdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Y2Zvcm0tc3VidGl0bGUtY29sb3JgfVxuXHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMzMzMzMzNcIikgfWB9IC8+XG5cdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvc2VjdGlvbi5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGdldFRoZW1lUHJlZml4LCBnZXREZWZhdWx0VmFsdWUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY29sb3ItcGlja2VyJztcbmltcG9ydCBUYWJzIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvdGFicyc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvY29udGFpbmVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXRzQ29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8VGFic1xuXHRcdFx0XHRkZWZhdWx0PVwiZGVmYXVsdFwiXG5cdFx0XHRcdHR5cGU9XCJ0YWJzXCJcblx0XHRcdFx0ZXh0cmFDbGFzcz1cInN1aS10YWJzLWZsdXNoZWRcIlxuXHRcdFx0PlxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdEZWZhdWx0JyApIH1cblx0XHRcdFx0XHR2YWx1ZT1cImRlZmF1bHRcIlxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdmbGF0JyAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQm9yZGVyIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9aW5wdXQtYm9yZGVyYH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzc3Nzc3MVwiKSB9YH1cblx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdtYXRlcmlhbCcgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1pbnB1dC1iZ2B9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFREVERURcIikgfWB9XG5cdFx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUGxhY2Vob2xkZXInICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9aW5wdXQtcGxhY2Vob2xkZXJgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzg4ODg4OFwiKSB9YH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGV4dCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1pbnB1dC1jb2xvcmB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMDAwMDAwXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdIb3ZlcicgKSB9XG5cdFx0XHRcdFx0dmFsdWU9XCJob3ZlclwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ2ZsYXQnICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXIgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1pbnB1dC1ib3JkZXItaG92ZXJgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQmFja2dyb3VuZCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWlucHV0LWhvdmVyLWJnYH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0U2RTZFNlwiKSB9YH1cblx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdUZXh0IGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWlucHV0LWhvdmVyLWNvbG9yYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMwMDAwMDBcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ZvY3VzJyApIH1cblx0XHRcdFx0XHR2YWx1ZT1cImZvY3VzXCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnZmxhdCcgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWlucHV0LWJvcmRlci1hY3RpdmVgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQmFja2dyb3VuZCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWlucHV0LWFjdGl2ZS1iZ2B9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFNkU2RTZcIikgfWB9XG5cdFx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGV4dCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1pbnB1dC1hY3RpdmUtY29sb3JgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzAwMDAwMFwiKSB9YH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdtYXRlcmlhbCcgJiZcblx0XHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0Vycm9yJyApIH1cblx0XHRcdFx0XHRcdHZhbHVlPVwiZXJyb3JcIlxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjRTA0NTYyXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1pbnB1dC1ib3JkZXItZXJyb3JgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9Db250YWluZXI+XG5cdFx0XHRcdH1cblx0XHRcdDwvVGFicz5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2lucHV0cy5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGhhc0ZpZWxkVHlwZSwgaGFzRmllbGRXaXRoQXR0cmlidXRlLCBnZXRUaGVtZVByZWZpeCwgZ2V0RGVmYXVsdFZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgQ29sb3JQaWNrZXIgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2NvbG9yLXBpY2tlcic7XG5pbXBvcnQgVGFicyBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL3RhYnMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbnRhaW5lcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0RXh0cmFDb2xvcnMgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgaGFzRGF0ZVBpY2tlciA9IGhhc0ZpZWxkV2l0aEF0dHJpYnV0ZShcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnMsXG5cdFx0XHQnZGF0ZScsXG5cdFx0XHQnZmllbGRfdHlwZScsXG5cdFx0XHQncGlja2VyJ1xuXHRcdCk7XG5cblx0XHRjb25zdCBoYXNDYWxjdWxhdGlvbiA9IGhhc0ZpZWxkVHlwZShcblx0XHRcdCdjYWxjdWxhdGlvbicsXG5cdFx0XHR0aGlzLnByb3BzLndyYXBwZXJzXG5cdFx0KTtcblxuXHRcdGNvbnN0IGhhc0N1cnJlbmN5ID0gaGFzRmllbGRUeXBlKFxuXHRcdFx0J2N1cnJlbmN5Jyxcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnNcblx0XHQpO1xuXG5cdFx0Y29uc3QgaGFzU3RyaXBlID0gaGFzRmllbGRUeXBlKFxuXHRcdFx0J3N0cmlwZScsXG5cdFx0XHR0aGlzLnByb3BzLndyYXBwZXJzXG5cdFx0KTtcblxuXHRcdGxldCBjb250ZW50ID0gPFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0eyAoXG5cdFx0XHRcdGhhc0RhdGVQaWNrZXIgfHxcblx0XHRcdFx0aGFzU3RyaXBlXG5cdFx0XHQpICYmXG5cdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9aW5wdXQtaWNvbmB9XG5cdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzc3Nzc3MVwiKSB9YH1cblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ljb24gY29sb3InICkgfVxuXHRcdFx0XHQvPlxuXHRcdFx0fVxuXHRcdFx0eyBoYXNDYWxjdWxhdGlvbiAmJlxuXHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXByZWZpeC1jb2xvcmB9XG5cdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzAwMDAwMFwiKSB9YH1cblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1ByZWZpeCBjb2xvcicgKSB9XG5cdFx0XHRcdC8+XG5cdFx0XHR9XG5cdFx0XHR7ICggaGFzQ3VycmVuY3kgfHxcblx0XHRcdFx0aGFzQ2FsY3VsYXRpb25cblx0XHRcdCkgJiZcblx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1zdWZmaXgtY29sb3JgfVxuXHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMwMDAwMDBcIikgfWB9XG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdTdWZmaXggY29sb3InICkgfVxuXHRcdFx0XHQvPlxuXHRcdFx0fVxuXHRcdDwvUmVhY3QuRnJhZ21lbnQ+O1xuXG5cdFx0aWYgKCBoYXNTdHJpcGUgKSB7XG5cdFx0XHRjb250ZW50ID0gPFRhYnNcblx0XHRcdFx0ZGVmYXVsdD1cImRlZmF1bHRcIlxuXHRcdFx0XHR0eXBlPVwidGFic1wiXG5cdFx0XHRcdGV4dHJhQ2xhc3M9XCJzdWktdGFicy1mbHVzaGVkXCJcblx0XHRcdD5cblxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdEZWZhdWx0JyApIH1cblx0XHRcdFx0XHR2YWx1ZT1cImRlZmF1bHRcIlxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0eyAoXG5cdFx0XHRcdFx0XHRoYXNEYXRlUGlja2VyIHx8XG5cdFx0XHRcdFx0XHRoYXNTdHJpcGVcblx0XHRcdFx0XHQpICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9aW5wdXQtaWNvbmB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM3Nzc3NzFcIikgfWB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnSWNvbiBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR7IGhhc0NhbGN1bGF0aW9uICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9cHJlZml4LWNvbG9yYH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzAwMDAwMFwiKSB9YH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdQcmVmaXggY29sb3InICkgfVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0eyAoIGhhc0N1cnJlbmN5IHx8XG5cdFx0XHRcdFx0XHRoYXNDYWxjdWxhdGlvblxuXHRcdFx0XHRcdCkgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1zdWZmaXgtY29sb3JgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMDAwMDAwXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1N1ZmZpeCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnSG92ZXInICkgfVxuXHRcdFx0XHRcdHZhbHVlPVwiaG92ZXJcIlxuXHRcdFx0XHQ+XG5cblx0XHRcdFx0XHR7IGhhc1N0cmlwZSAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWlucHV0LWljb24taG92ZXJgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ljb24gY29sb3InICkgfVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRm9jdXMnICkgfVxuXHRcdFx0XHRcdHZhbHVlPVwiZm9jdXNcIlxuXHRcdFx0XHQ+XG5cblx0XHRcdFx0XHR7IGhhc1N0cmlwZSAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWlucHV0LWljb24tZm9jdXNgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ljb24gY29sb3InICkgfVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdDwvVGFicz47XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvaW5wdXRzLWV4dHJhLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSwgZ2V0VGhlbWVQcmVmaXgsIGdldERlZmF1bHRWYWx1ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IENvbG9yUGlja2VyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9jb2xvci1waWNrZXInO1xuaW1wb3J0IFRhYnMgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy90YWJzJztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9jb250YWluZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRpb0NvbG9ycyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PFRhYnNcblx0XHRcdFx0ZGVmYXVsdD1cImRlZmF1bHRcIlxuXHRcdFx0XHR0eXBlPVwidGFic1wiXG5cdFx0XHRcdGV4dHJhQ2xhc3M9XCJzdWktdGFicy1mbHVzaGVkXCJcblx0XHRcdD5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRGVmYXVsdCcgKSB9XG5cdFx0XHRcdFx0dmFsdWU9XCJkZWZhdWx0XCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnZmxhdCcgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjNzc3NzcxXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1yYWRpby1ib3JkZXItc3RhdGljYH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXIgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9cmFkaW8tYmFja2dyb3VuZC1zdGF0aWNgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0VERURFRFwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGV4dCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1yYWRpby1sYWJlbGB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMDAwMDAwXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdmbGF0JyB8fCB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdtYXRlcmlhbCcgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ltYWdlIGJvcmRlcicgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXJhZGlvLWltYWdlLWJvcmRlci1zdGF0aWNgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjNzc3NzcxXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnSW1hZ2UgYmFja2dyb3VuZCcgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXJhZGlvLWltYWdlLWJhY2tncm91bmRgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjRURFREVEXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0PC9Db250YWluZXI+XG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0NoZWNrZWQnICkgfVxuXHRcdFx0XHRcdHZhbHVlPVwiY2hlY2tlZFwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ2ZsYXQnICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXIgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1yYWRpby1ib3JkZXItYWN0aXZlYH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzE3QThFM1wiKSB9YH1cblx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCYWNrZ3JvdW5kIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXJhZGlvLWJhY2tncm91bmQtYWN0aXZlYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFREVERURcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ljb24gY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9cmFkaW8taWNvbmB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdmbGF0JyB8fCB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdtYXRlcmlhbCcgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ltYWdlIGJvcmRlcicgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXJhZGlvLWltYWdlLWJvcmRlci1hY3RpdmVgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnSW1hZ2UgYmFja2dyb3VuZCcgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXJhZGlvLWltYWdlLWJhY2tncm91bmQtYWN0aXZlYH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0UxRjZGRlwiKSB9YH1cblx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRXJyb3InICkgfVxuXHRcdFx0XHRcdFx0dmFsdWU9XCJlcnJvclwiXG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdmbGF0JyAmJlxuXHRcdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFMDQ1NjJcIikgfWB9XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9cmFkaW8tYm9yZGVyLWVycm9yYH1cblx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gPT09ICdmbGF0JyAmJlxuXHRcdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQmFja2dyb3VuZCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9cmFkaW8tYmFja2dyb3VuZC1lcnJvcmB9XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0Y5RTRFOFwiKSB9YH1cblx0XHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0PC9Db250YWluZXI+XG5cdFx0XHRcdH1cblx0XHRcdDwvVGFicz5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL3JhZGlvLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSwgZ2V0VGhlbWVQcmVmaXgsIGdldERlZmF1bHRWYWx1ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IENvbG9yUGlja2VyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9jb2xvci1waWNrZXInO1xuaW1wb3J0IFRhYnMgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy90YWJzJztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9jb250YWluZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25zZW50Q29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8VGFic1xuXHRcdFx0XHRkZWZhdWx0PVwiZGVmYXVsdFwiXG5cdFx0XHRcdHR5cGU9XCJ0YWJzXCJcblx0XHRcdFx0ZXh0cmFDbGFzcz1cInN1aS10YWJzLWZsdXNoZWRcIlxuXHRcdFx0PlxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdEZWZhdWx0JyApIH1cblx0XHRcdFx0XHR2YWx1ZT1cImRlZmF1bHRcIlxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdmbGF0JyAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM3Nzc3NzFcIikgfWB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWNvbnNlbnQtY2JveC1ib3JkZXItc3RhdGljYH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXIgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Y29uc2VudC1jYm94LWJhY2tncm91bmQtc3RhdGljYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFREVERURcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RleHQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Y29uc2VudC1jYm94LWxhYmVsYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMwMDAwMDBcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0NoZWNrZWQnICkgfVxuXHRcdFx0XHRcdHZhbHVlPVwiY2hlY2tlZFwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ2ZsYXQnICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXIgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1jb25zZW50LWNib3gtYm9yZGVyLWFjdGl2ZWB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMxN0E4RTNcIikgfWB9XG5cdFx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQmFja2dyb3VuZCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1jb25zZW50LWNib3gtYmFja2dyb3VuZC1hY3RpdmVgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0VERURFRFwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnSWNvbiBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1jb25zZW50LWNib3gtaWNvbmB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRXJyb3InICkgfVxuXHRcdFx0XHRcdFx0dmFsdWU9XCJlcnJvclwiXG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdmbGF0JyAmJlxuXHRcdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFMDQ1NjJcIikgfWB9XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Y29uc2VudC1jYm94LWJvcmRlci1lcnJvcmB9XG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXIgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduID09PSAnZmxhdCcgJiZcblx0XHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWNvbnNlbnQtY2JveC1iYWNrZ3JvdW5kLWVycm9yYH1cblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjRjlFNEU4XCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQ8L0NvbnRhaW5lcj5cblx0XHRcdFx0fVxuXHRcdFx0PC9UYWJzPlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvY29uc2VudC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGdldFRoZW1lUHJlZml4LCBnZXREZWZhdWx0VmFsdWUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY29sb3ItcGlja2VyJztcbmltcG9ydCBUYWJzIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvdGFicyc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvY29udGFpbmVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VsZWN0Q29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8VGFic1xuXHRcdFx0XHRkZWZhdWx0PVwiZGVmYXVsdFwiXG5cdFx0XHRcdHR5cGU9XCJ0YWJzXCJcblx0XHRcdFx0ZXh0cmFDbGFzcz1cInN1aS10YWJzLWZsdXNoZWRcIlxuXHRcdFx0PlxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdEZWZhdWx0JyApIH1cblx0XHRcdFx0XHR2YWx1ZT1cImRlZmF1bHRcIlxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdmbGF0JyAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQm9yZGVyIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9c2VsZWN0LWJvcmRlci1zdGF0aWNgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjNzc3NzcxXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9c2VsZWN0LWJhY2tncm91bmQtc3RhdGljYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFREVERURcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ljb24gY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9c2VsZWN0LWljb24tc3RhdGljYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM3Nzc3NzFcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RleHQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9c2VsZWN0LXZhbHVlLXN0YXRpY2B9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMDAwMDAwXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdIb3ZlcicgKSB9XG5cdFx0XHRcdFx0dmFsdWU9XCJob3ZlclwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ2ZsYXQnICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXIgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1zZWxlY3QtYm9yZGVyLWhvdmVyYH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzE3QThFM1wiKSB9YH1cblx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdtYXRlcmlhbCcgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1zZWxlY3QtYmFja2dyb3VuZC1ob3ZlcmB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFNkU2RTZcIikgfWB9XG5cdFx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnSWNvbiBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1zZWxlY3QtaWNvbi1ob3ZlcmB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdUZXh0IGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXNlbGVjdC12YWx1ZS1ob3ZlcmB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMDAwMDAwXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdGb2N1cycgKSB9XG5cdFx0XHRcdFx0dmFsdWU9XCJmb2N1c1wiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ2ZsYXQnICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXIgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1zZWxlY3QtYm9yZGVyLWFjdGl2ZWB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMxN0E4RTNcIikgfWB9XG5cdFx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnbWF0ZXJpYWwnICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCYWNrZ3JvdW5kIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9c2VsZWN0LWJhY2tncm91bmQtYWN0aXZlYH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0U2RTZFNlwiKSB9YH1cblx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdJY29uIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXNlbGVjdC1pY29uLWFjdGl2ZWB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdUZXh0IGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXNlbGVjdC12YWx1ZS1hY3RpdmVgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzAwMDAwMFwiKSB9YH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdtYXRlcmlhbCcgJiZcblx0XHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0Vycm9yJyApIH1cblx0XHRcdFx0XHRcdHZhbHVlPVwiZXJyb3JcIlxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXNlbGVjdC1ib3JkZXItZXJyb3JgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjRTA0NTYyXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0XHR9XG5cdFx0XHQ8L1RhYnM+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9zZWxlY3QuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlLCBnZXRUaGVtZVByZWZpeCwgZ2V0RGVmYXVsdFZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgQ29sb3JQaWNrZXIgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2NvbG9yLXBpY2tlcic7XG5pbXBvcnQgVGFicyBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL3RhYnMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbnRhaW5lcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERyb3Bkb3duQ29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8VGFic1xuXHRcdFx0XHRkZWZhdWx0PVwiZGVmYXVsdFwiXG5cdFx0XHRcdHR5cGU9XCJ0YWJzXCJcblx0XHRcdFx0ZXh0cmFDbGFzcz1cInN1aS10YWJzLWZsdXNoZWRcIlxuXHRcdFx0PlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0RlZmF1bHQnICkgfVxuXHRcdFx0XHRcdHZhbHVlPVwiZGVmYXVsdFwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7IChcblx0XHRcdFx0XHRcdHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ2ZsYXQnICYmXG5cdFx0XHRcdFx0XHR0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdtYXRlcmlhbCdcblx0XHRcdFx0XHQpICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzE3QThFM1wiKSB9YH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9ZHJvcGRvd24tYm9yZGVyYH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdDb250YWluZXIgYm9yZGVyJyApIH1cblx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0U2RTZFNlwiKSB9YH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWRyb3Bkb3duLWJhY2tncm91bmRgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdDb250YWluZXIgQkcnICkgfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzc3Nzc3MVwiKSB9YH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWRyb3Bkb3duLW9wdGlvbi1jb2xvci1zdGF0aWNgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdPcHRpb24gY29sb3InICkgfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0hvdmVyJyApIH1cblx0XHRcdFx0XHR2YWx1ZT1cImhvdmVyXCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNERERERERcIikgfWB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1kcm9wZG93bi1vcHRpb24tYmFja2dyb3VuZC1ob3ZlcmB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ09wdGlvbiBiYWNrZ3JvdW5kJyApIH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMwMDAwMDBcIikgfWB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1kcm9wZG93bi1vcHRpb24tY29sb3ItaG92ZXJgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdPcHRpb24gY29sb3InICkgfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1NlbGVjdGVkJyApIH1cblx0XHRcdFx0XHR2YWx1ZT1cInNlbGVjdGVkXCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMxN0E4RTNcIikgfWB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1kcm9wZG93bi1vcHRpb24tYmFja2dyb3VuZC1hY3RpdmVgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdPcHRpb24gYmFja2dyb3VuZCcgKSB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjRkZGRkZGXCIpIH1gfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9ZHJvcGRvd24tb3B0aW9uLWNvbG9yLWFjdGl2ZWB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ09wdGlvbiBjb2xvcicgKSB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdDwvVGFicz5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2Ryb3Bkb3duLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSwgZ2V0VGhlbWVQcmVmaXgsIGdldERlZmF1bHRWYWx1ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IENvbG9yUGlja2VyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9jb2xvci1waWNrZXInO1xuaW1wb3J0IFRhYnMgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy90YWJzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoQ29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdHsgKFxuXHRcdFx0XHRcdHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ2ZsYXQnICYmXG5cdFx0XHRcdFx0dGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnbWF0ZXJpYWwnXG5cdFx0XHRcdCkgJiZcblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9ZHJvcGRvd24tc2VhcmNoLWJvcmRlcmB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0fVxuXHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNGRkZGRkZcIikgfWB9XG5cdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9ZHJvcGRvd24tc2VhcmNoLWJhY2tncm91bmRgfVxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQmFja2dyb3VuZCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHQvPlxuXHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMwMDAwMDBcIikgfWB9XG5cdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9ZHJvcGRvd24tc2VhcmNoLWNvbG9yYH1cblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RleHQgY29sb3InICkgfVxuXHRcdFx0XHQvPlxuXHRcdFx0XHR7LyogQVZBSUxBQkxFIE9OIDEuNy4xXG5cdFx0XHRcdDxDb2xvclBpY2tlciB7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnTm8gcmVzdWx0IHRleHQgY29sb3InICkgfVxuXHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWRyb3Bkb3duLXRleHQtbm9yZXN1bHRgfVxuXHRcdFx0XHRcdGRlZmF1bHQ9XCJcIiAvPlxuXHRcdFx0XHQqL31cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9kcm9wZG93bi1zZWFyY2guanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlLCBnZXRUaGVtZVByZWZpeCwgZ2V0RGVmYXVsdFZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgQ29sb3JQaWNrZXIgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2NvbG9yLXBpY2tlcic7XG5pbXBvcnQgVGFicyBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL3RhYnMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbnRhaW5lcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE11bHRpU2VsZWN0Q29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8VGFic1xuXHRcdFx0XHRkZWZhdWx0PVwiZGVmYXVsdFwiXG5cdFx0XHRcdHR5cGU9XCJ0YWJzXCJcblx0XHRcdFx0ZXh0cmFDbGFzcz1cInN1aS10YWJzLWZsdXNoZWRcIlxuXHRcdFx0PlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0RlZmF1bHQnICkgfVxuXHRcdFx0XHRcdHZhbHVlPVwiZGVmYXVsdFwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ2ZsYXQnICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzc3Nzc3MVwiKSB9YH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9bXVsdGlzZWxlY3QtYm9yZGVyYH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdtYXRlcmlhbCdcblx0XHRcdFx0XHRcdFx0XHQ/IHRyYW5zbGF0ZSggJ0NvbnRhaW5lciBib3JkZXInIClcblx0XHRcdFx0XHRcdFx0XHQ6IHRyYW5zbGF0ZSggJ09wdGlvbiBib3JkZXInIClcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFNkU2RTZcIikgfWB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfW11bHRpc2VsZWN0LWJhY2tncm91bmRgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0NvbnRhaW5lciBCRycgKSB9XG5cdFx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM3Nzc3NzFcIikgfWB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1tdWx0aXNlbGVjdC1pdGVtLWNvbG9yLXN0YXRpY2B9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ09wdGlvbiBjb2xvcicgKSB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnSG92ZXInICkgfVxuXHRcdFx0XHRcdHZhbHVlPVwiaG92ZXJcIlxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gPT09ICdtYXRlcmlhbCcgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMDAwMDAwXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1tdWx0aXNlbGVjdC1ib3JkZXItaG92ZXJgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ09wdGlvbiBib3JkZXInICkgfVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNERERERERcIikgfWB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfW11bHRpc2VsZWN0LWl0ZW0tYmctaG92ZXJgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ09wdGlvbiBiYWNrZ3JvdW5kJyApIH1cblx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzAwMDAwMFwiKSB9YH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfW11bHRpc2VsZWN0LWl0ZW0tY29sb3ItaG92ZXJgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdPcHRpb24gY29sb3InICkgfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdTZWxlY3RlZCcgKSB9XG5cdFx0XHRcdFx0dmFsdWU9XCJzZWxlY3RlZFwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiA9PT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMxN0E4RTNcIikgfWB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfW11bHRpc2VsZWN0LWJvcmRlci1hY3RpdmVgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ09wdGlvbiBib3JkZXInICkgfVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMxN0E4RTNcIikgfWB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfW11bHRpc2VsZWN0LWl0ZW0tYmctYWN0aXZlYH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdPcHRpb24gYmFja2dyb3VuZCcgKSB9XG5cdFx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJ1xuXHRcdFx0XHRcdFx0XHQ/ICcjRkZGRkZGJ1xuXHRcdFx0XHRcdFx0XHQ6ICcjMTdBOEUzJ1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9bXVsdGlzZWxlY3QtaXRlbS1jb2xvci1hY3RpdmVgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdPcHRpb24gY29sb3InICkgfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRXJyb3InICkgfVxuXHRcdFx0XHRcdFx0dmFsdWU9XCJlcnJvclwiXG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFMDQ1NjJcIikgfWB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfW11bHRpc2VsZWN0LWJvcmRlci1lcnJvcmB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQ29udGFpbmVyIGJvcmRlcicgKSB9XG5cdFx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9Db250YWluZXI+XG5cdFx0XHRcdH1cblx0XHRcdDwvVGFicz5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL211bHRpLXNlbGVjdC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGdldFRoZW1lUHJlZml4LCBnZXREZWZhdWx0VmFsdWUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY29sb3ItcGlja2VyJztcbmltcG9ydCBUYWJzIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvdGFicyc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvY29udGFpbmVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FsZW5kYXJDb2xvcnMgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxUYWJzXG5cdFx0XHRcdGRlZmF1bHQ9XCJjb250YWluZXJcIlxuXHRcdFx0XHR0eXBlPVwidGFic1wiXG5cdFx0XHRcdGV4dHJhQ2xhc3M9XCJzdWktdGFicy1mbHVzaGVkXCJcblx0XHRcdD5cblxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdDb250YWluZXInICkgfVxuXHRcdFx0XHRcdHZhbHVlPVwiY29udGFpbmVyXCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnZmxhdCcgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlciB7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJydcblx0XHRcdFx0XHRcdFx0XHQ/IHRyYW5zbGF0ZSggJ0JvcmRlcicgKVxuXHRcdFx0XHRcdFx0XHRcdDogdHJhbnNsYXRlKCAnSGVhZGVyIGJhY2tncm91bmQnIClcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1jYWxlbmRhci1ib3JkZXJgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXIgeyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnJ1xuXHRcdFx0XHRcdFx0XHQ/IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQnIClcblx0XHRcdFx0XHRcdFx0OiB0cmFuc2xhdGUoICdNYWluIGJhY2tncm91bmQnIClcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWNhbGVuZGFyLWJhY2tncm91bmRgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0U2RTZFNlwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdOYXZpZ2F0aW9uJyApIH1cblx0XHRcdFx0XHR2YWx1ZT1cIm5hdmlnYXRpb25cIlxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdtYXRlcmlhbCcgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlciB7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0Fycm93cyBiYWNrZ3JvdW5kJyApIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Y2FsZW5kYXItYXJyb3dzLWJnYH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzE3QThFM1wiKSB9YH1cblx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyIHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0Fycm93cyBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1jYWxlbmRhci1hcnJvd3Mtc3RhdGljYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNGRkZGRkZcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnU2VsZWN0JyApIH1cblx0XHRcdFx0XHR2YWx1ZT1cInNlbGVjdFwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ2ZsYXQnICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXIgeyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXInICkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1jYWxlbmRhci1zZWxlY3QtYm9yZGVyYH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0JCQkJCQlwiKSB9YH1cblx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyIHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQnICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Y2FsZW5kYXItc2VsZWN0LWJnYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNGRkZGRkZcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXIgeyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQ29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Y2FsZW5kYXItc2VsZWN0LWNvbG9yYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM3Nzc3NzFcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdDwvVGFicz5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2NhbGVuZGFyLWJhc2ljcy5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGdldFRoZW1lUHJlZml4LCBnZXREZWZhdWx0VmFsdWUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY29sb3ItcGlja2VyJztcbmltcG9ydCBUYWJzIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvdGFicyc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvY29udGFpbmVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2lnbmF0dXJlIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8VGFic1xuXHRcdFx0XHRkZWZhdWx0PVwiZGVmYXVsdFwiXG5cdFx0XHRcdHR5cGU9XCJ0YWJzXCJcblx0XHRcdFx0ZXh0cmFDbGFzcz1cInN1aS10YWJzLWZsdXNoZWRcIlxuXHRcdFx0PlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHR2YWx1ZT1cImRlZmF1bHRcIlxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRGVmYXVsdCcgKSB9XG5cdFx0XHRcdD5cblxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnZmxhdCcgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXNpZ25hdHVyZS1ib3JkZXItZGVmYXVsdGB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM3Nzc3NzFcIikgfWB9XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnbWF0ZXJpYWwnICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCYWNrZ3JvdW5kIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9c2lnbmF0dXJlLWJhY2tncm91bmQtZGVmYXVsdGB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFREVERURcIikgfWB9XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUGxhY2Vob2xkZXInICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9c2lnbmF0dXJlLXBsYWNlaG9sZGVyYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM4ODg4ODhcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdDxDb2xvclBpY2tlciB7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdTaWduYXR1cmUgQ29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9c2lnbmF0dXJlLWNvbG9yYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMwMDAwMDBcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUmVzZXQgaWNvbiBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1zaWduYXR1cmUtcmVzZXQtaWNvbi1kZWZhdWx0YH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM4ODg4ODhcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0dmFsdWU9XCJob3ZlclwiXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdIb3ZlcicgKSB9XG5cdFx0XHRcdD5cblxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnZmxhdCcgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXNpZ25hdHVyZS1ib3JkZXItaG92ZXJgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQmFja2dyb3VuZCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXNpZ25hdHVyZS1iYWNrZ3JvdW5kLWhvdmVyYH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0U2RTZFNlwiKSB9YH1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdSZXNldCBpY29uIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXNpZ25hdHVyZS1yZXNldC1pY29uLWhvdmVyYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMxN0E4RTNcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0dmFsdWU9XCJlcnJvclwiXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdFcnJvcicgKSB9XG5cdFx0XHRcdD5cblxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQm9yZGVyIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXNpZ25hdHVyZS1ib3JkZXItZXJyb3JgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0UwNDU2MlwiKSB9YH1cblx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHQ8L1RhYnM+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9zaWduYXR1cmUuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlLCBnZXRUaGVtZVByZWZpeCwgZ2V0RGVmYXVsdFZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgQ29sb3JQaWNrZXIgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2NvbG9yLXBpY2tlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyb3VwQ29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwicmdiYSgyNDgsMjQ4LDI0OCwuNSlcIikgfWB9XG5cdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Z3JvdXAtYmFja2dyb3VuZGB9XG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCYWNrZ3JvdW5kIGNvbG9yJyApIH1cblx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdC8+XG5cdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwicmdiYSgyMjEsMjIxLDIyMSwuNSlcIikgfWB9XG5cdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Z3JvdXAtYm9yZGVyYH1cblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHQvPlxuXHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcInJnYmEoMTcwLDE3MCwxNzAsLjUpXCIpIH1gfVxuXHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWdyb3VwLWRpdmlkZXJgfVxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRGl2aWRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHQvPlxuXHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2dyb3VwLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSwgZ2V0VGhlbWVQcmVmaXgsIGdldERlZmF1bHRWYWx1ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IENvbG9yUGlja2VyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9jb2xvci1waWNrZXInO1xuaW1wb3J0IFRhYnMgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy90YWJzJztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9jb250YWluZXInO1xuaW1wb3J0IEFjY29yZGlvbiBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2FjY29yZGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlcGVhdGVyQ29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveFwiPlxuXG5cdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQnV0dG9uJyApIH1cblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxUYWJzXG5cdFx0XHRcdFx0XHRkZWZhdWx0PVwiZGVmYXVsdFwiXG5cdFx0XHRcdFx0XHRleHRyYUNsYXNzPVwic3VpLXRhYnMtZmx1c2hlZFwiXG5cdFx0XHRcdFx0XHR0eXBlPVwidGFic1wiXG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdFx0XHR2YWx1ZT1cImRlZmF1bHRcIlxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0RlZmF1bHQnICkgfVxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQmFja2dyb3VuZCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9cmVwZWF0ZXItYnV0dG9uLWJhY2tncm91bmRgfVxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNGOEY4RjhcIikgfWB9XG5cdFx0XHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RleHQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXJlcGVhdGVyLWJ1dHRvbmB9XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzY2NjY2NlwiKSB9YH1cblx0XHRcdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQm9yZGVyIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1yZXBlYXRlci1ib3JkZXJgfVxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNBQUFBQUFcIikgfWB9XG5cdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdFx0XHR2YWx1ZT1cImhvdmVyXCJcblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdIb3ZlcicgKSB9XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCYWNrZ3JvdW5kIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1yZXBlYXRlci1idXR0b24tYmFja2dyb3VuZC1ob3ZlcmB9XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0YxRjFGMVwiKSB9YH1cblx0XHRcdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGV4dCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9cmVwZWF0ZXItYnV0dG9uLWhvdmVyYH1cblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjNjY2NjY2XCIpIH1gfVxuXHRcdFx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXIgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXJlcGVhdGVyLWJvcmRlci1ob3ZlcmB9XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0FBQUFBQVwiKSB9YH1cblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0XHRcdHZhbHVlPVwiZm9jdXNcIlxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ZvY3VzJyApIH1cblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXJlcGVhdGVyLWJ1dHRvbi1iYWNrZ3JvdW5kLWZvY3VzYH1cblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjRjFGMUYxXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdUZXh0IGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1yZXBlYXRlci1idXR0b24tZm9jdXNgfVxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM2NjY2NjZcIikgfWB9XG5cdFx0XHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9cmVwZWF0ZXItYm9yZGVyLWZvY3VzYH1cblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjQUFBQUFBXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0PC9Db250YWluZXI+XG5cdFx0XHRcdFx0PC9UYWJzPlxuXHRcdFx0XHQ8L0FjY29yZGlvbj5cblxuXHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ljb24nICkgfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0PFRhYnNcblx0XHRcdFx0XHRcdGRlZmF1bHQ9XCJkZWZhdWx0XCJcblx0XHRcdFx0XHRcdGV4dHJhQ2xhc3M9XCJzdWktdGFicy1mbHVzaGVkXCJcblx0XHRcdFx0XHRcdHR5cGU9XCJ0YWJzXCJcblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0XHRcdHZhbHVlPVwiZGVmYXVsdFwiXG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRGVmYXVsdCcgKSB9XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdDb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9cmVwZWF0ZXItaWNvbmB9XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzg4ODg4OFwiKSB9YH1cblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0XHRcdHZhbHVlPVwiaG92ZXJcIlxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0hvdmVyJyApIH1cblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0NvbG9yJyApIH1cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1yZXBlYXRlci1pY29uLWhvdmVyYH1cblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjODg4ODg4XCIpIH1gfVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRcdFx0dmFsdWU9XCJmb2N1c1wiXG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRm9jdXMnICkgfVxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQ29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXJlcGVhdGVyLWljb24tZm9jdXNgfVxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM4ODg4ODhcIikgfWB9XG5cdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHQ8L0NvbnRhaW5lcj5cblx0XHRcdFx0XHQ8L1RhYnM+XG5cdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnTGluaycgKSB9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8VGFic1xuXHRcdFx0XHRcdFx0ZGVmYXVsdD1cImRlZmF1bHRcIlxuXHRcdFx0XHRcdFx0ZXh0cmFDbGFzcz1cInN1aS10YWJzLWZsdXNoZWRcIlxuXHRcdFx0XHRcdFx0dHlwZT1cInRhYnNcIlxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRcdFx0dmFsdWU9XCJkZWZhdWx0XCJcblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdEZWZhdWx0JyApIH1cblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RleHQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXJlcGVhdGVyLWxpbmtgfVxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMxN0E4RTNcIikgfWB9XG5cdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdFx0XHR2YWx1ZT1cImhvdmVyXCJcblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdIb3ZlcicgKSB9XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdUZXh0IGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1yZXBlYXRlci1saW5rLWhvdmVyYH1cblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRcdFx0dmFsdWU9XCJmb2N1c1wiXG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRm9jdXMnICkgfVxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGV4dCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9cmVwZWF0ZXItbGluay1mb2N1c2B9XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzE3QThFM1wiKSB9YH1cblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0XHRcdDwvVGFicz5cblx0XHRcdFx0PC9BY2NvcmRpb24+XG5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvcmVwZWF0ZXIuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlLCBnZXRUaGVtZVByZWZpeCwgZ2V0RGVmYXVsdFZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgQ29sb3JQaWNrZXIgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2NvbG9yLXBpY2tlcic7XG5pbXBvcnQgVGFicyBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL3RhYnMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbnRhaW5lcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbGVuZGFyQ29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8VGFic1xuXHRcdFx0XHRkZWZhdWx0PVwiZGVmYXVsdFwiXG5cdFx0XHRcdHR5cGU9XCJ0YWJzXCJcblx0XHRcdFx0ZXh0cmFDbGFzcz1cInN1aS10YWJzLWZsdXNoZWRcIlxuXHRcdFx0PlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0RlZmF1bHQnICkgfVxuXHRcdFx0XHRcdHZhbHVlPVwiZGVmYXVsdFwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RhYmxlIGhlYWQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Y2FsZW5kYXItZHdlZWtgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzMzMzMzM1wiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnZmxhdCcgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RhYmxlIGNlbGwgYm9yZGVyJyApIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Y2FsZW5kYXItZGF5cy1ib3JkZXItc3RhdGljYH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0U2RTZFNlwiKSB9YH1cblx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdUYWJsZSBjZWxsIEJHJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWNhbGVuZGFyLWRheXMtYmFja2dyb3VuZC1zdGF0aWNgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0U2RTZFNlwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGFibGUgY2VsbCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1jYWxlbmRhci1kYXlzLWNvbG9yLXN0YXRpY2B9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjNzc3NzcxXCIpIH1gfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0hvdmVyJyApIH1cblx0XHRcdFx0XHR2YWx1ZT1cImhvdmVyXCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnZmxhdCcgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RhYmxlIGNlbGwgYm9yZGVyJyApIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Y2FsZW5kYXItZGF5cy1ib3JkZXItaG92ZXJgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjREREREREXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RhYmxlIGNlbGwgQkcnICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Y2FsZW5kYXItZGF5cy1iYWNrZ3JvdW5kLWhvdmVyYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNERERERERcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RhYmxlIGNlbGwgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Y2FsZW5kYXItZGF5cy1jb2xvci1ob3ZlcmB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjNzc3NzcxXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0FjdGl2ZScgKSB9XG5cdFx0XHRcdFx0dmFsdWU9XCJhY3RpdmVcIlxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdmbGF0JyAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGFibGUgY2VsbCBib3JkZXInICkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1jYWxlbmRhci1kYXlzLWJvcmRlci1hY3RpdmVgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RhYmxlIGNlbGwgQkcnICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Y2FsZW5kYXItZGF5cy1iYWNrZ3JvdW5kLWFjdGl2ZWB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdUYWJsZSBjZWxsIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWNhbGVuZGFyLWRheXMtY29sb3ItYWN0aXZlYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNGRkZGRkZcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQ3VycmVudCcgKSB9XG5cdFx0XHRcdFx0dmFsdWU9XCJjdXJyZW50XCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnZmxhdCcgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RhYmxlIGNlbGwgYm9yZGVyJyApIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9Y2FsZW5kYXItZGF5cy1ib3JkZXItY3VycmVudGB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMxN0E4RTNcIikgfWB9XG5cdFx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGFibGUgY2VsbCBCRycgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1jYWxlbmRhci1kYXlzLWJhY2tncm91bmQtY3VycmVudGB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjQzhERUU3XCIpIH1gfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdUYWJsZSBjZWxsIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWNhbGVuZGFyLWRheXMtY29sb3ItY3VycmVudGB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHQ8L1RhYnM+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9jYWxlbmRhci10YWJsZS5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGdldFRoZW1lUHJlZml4LCBnZXREZWZhdWx0VmFsdWUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY29sb3ItcGlja2VyJztcbmltcG9ydCBUYWJzIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvdGFicyc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvY29udGFpbmVyJztcbmltcG9ydCBTZXR0aW5nc1JvdyBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL3NldHRpbmdzLXJvdyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0ZXBzQ29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8VGFic1xuXHRcdFx0XHRkZWZhdWx0PVwiYm9yZGVyXCJcblx0XHRcdFx0dHlwZT1cInRhYnNcIlxuXHRcdFx0XHRleHRyYUNsYXNzPVwic3VpLXRhYnMtZmx1c2hlZFwiXG5cdFx0XHQ+XG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlcicgKSB9XG5cdFx0XHRcdFx0dmFsdWU9XCJib3JkZXJcIlxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdEZWZhdWx0JyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXRpbWVsaW5lLWJvcmRlcmB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjNzc3NzcxXCIpIH1gfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0eyAoXG5cdFx0XHRcdFx0XHR0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdib2xkJyAmJlxuXHRcdFx0XHRcdFx0dGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnbWF0ZXJpYWwnXG5cdFx0XHRcdFx0KSAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQ3VycmVudCcgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXRpbWVsaW5lLWJvcmRlci1jdXJyZW50YH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzE3QThFM1wiKSB9YH1cblx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdMYWJlbCcgKSB9XG5cdFx0XHRcdFx0dmFsdWU9XCJsYWJlbFwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0RlZmF1bHQnICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9dGltZWxpbmUtdGV4dGB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjNzc3NzcxXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdDdXJyZW50JyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXRpbWVsaW5lLXRleHQtY3VycmVudGB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdEb3QnICkgfVxuXHRcdFx0XHRcdHZhbHVlPVwiZG90XCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxTZXR0aW5nc1Jvdz5cblxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktZm9ybS1maWVsZFwiPlxuXHRcdFx0XHRcdFx0XHQ8bGFiZWwgY2xhc3NOYW1lPVwic3VpLXNldHRpbmdzLWxhYmVsIHN1aS1kYXJrXCI+eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdFx0J0RlZmF1bHQgc3RhdGUgY29sb3JzJ1xuXHRcdFx0XHRcdFx0XHQpIH08L2xhYmVsPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnbWF0ZXJpYWwnICYmXG5cdFx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXInICkgfVxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXRpbWVsaW5lLWRvdC1ib3JkZXJgfVxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM3Nzc3NzFcIikgfWB9XG5cdFx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCYWNrZ3JvdW5kJyApIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9dGltZWxpbmUtZG90LWJhY2tncm91bmRgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjNzc3NzcxXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiA9PT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUGFnZSBudW1iZXIgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXRpbWVsaW5lLWRvdC1jb2xvcmB9XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0ZGRkZGRlwiKSB9YH1cblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdDwvU2V0dGluZ3NSb3c+XG5cblx0XHRcdFx0XHQ8U2V0dGluZ3NSb3c+XG5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGRcIj5cblx0XHRcdFx0XHRcdFx0PGxhYmVsIGNsYXNzTmFtZT1cInN1aS1zZXR0aW5ncy1sYWJlbCBzdWktZGFya1wiPnsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHRcdCdDdXJyZW50IHN0YXRlIGNvbG9ycydcblx0XHRcdFx0XHRcdFx0KSB9PC9sYWJlbD5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQm9yZGVyJyApIH1cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH10aW1lbGluZS1kb3QtYm9yZGVyLWN1cnJlbnRgfVxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM3Nzc3NzFcIikgfWB9XG5cdFx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCYWNrZ3JvdW5kJyApIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9dGltZWxpbmUtZG90LWJhY2tncm91bmQtY3VycmVudGB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMxN0E4RTNcIikgfWB9XG5cdFx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduID09PSAnbWF0ZXJpYWwnICYmXG5cdFx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdQYWdlIG51bWJlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9dGltZWxpbmUtZG90LWNvbG9yLWN1cnJlbnRgfVxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNGRkZGRkZcIikgfWB9XG5cdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQ8L1NldHRpbmdzUm93PlxuXG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0PC9UYWJzPlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvcGFnaW5hdGlvbi1zdGVwcy5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGdldFRoZW1lUHJlZml4LCBnZXREZWZhdWx0VmFsdWUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY29sb3ItcGlja2VyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZ3Jlc3NDb2xvcnMgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblxuXHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnTGFiZWwnICkgfVxuXHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXByb2dyZXNzLWxhYmVsYH1cblx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjNzc3NzcxXCIpIH1gfVxuXHRcdFx0XHQvPlxuXG5cdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdQcm9ncmVzcyBiYXIgQkcnICkgfVxuXHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXByb2dyZXNzLWJhY2tncm91bmRgfVxuXHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFNkU2RTZcIikgfWB9XG5cdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHQvPlxuXG5cdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdQcm9ncmVzcyBzdGF0dXMgQkcnICkgfVxuXHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXByb2dyZXNzLWJhY2tncm91bmQtc3RhdHVzYH1cblx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTdBOEUzXCIpIH1gfVxuXHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0Lz5cblxuXHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL3BhZ2luYXRpb24tcHJvZ3Jlc3MuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlLCBnZXRUaGVtZVByZWZpeCwgZ2V0RGVmYXVsdFZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgQ29sb3JQaWNrZXIgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2NvbG9yLXBpY2tlcic7XG5pbXBvcnQgVGFicyBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL3RhYnMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbnRhaW5lcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhY2tDb2xvcnMgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxUYWJzXG5cdFx0XHRcdGRlZmF1bHQ9XCJkZWZhdWx0XCJcblx0XHRcdFx0dHlwZT1cInRhYnNcIlxuXHRcdFx0XHRleHRyYUNsYXNzPVwic3VpLXRhYnMtZmx1c2hlZFwiXG5cdFx0XHQ+XG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0RlZmF1bHQnICkgfVxuXHRcdFx0XHRcdHZhbHVlPVwiZGVmYXVsdFwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9cHJldi1iYWNrZ3JvdW5kLXN0YXRpY2B9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMUFCQ0ExXCIpIH1gfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdMYWJlbCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1wcmV2LWNvbG9yLXN0YXRpY2B9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjRkZGRkZGXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdIb3ZlcicgKSB9XG5cdFx0XHRcdFx0dmFsdWU9XCJob3ZlclwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9cHJldi1iYWNrZ3JvdW5kLWhvdmVyYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMxNTlDODVcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0xhYmVsIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXByZXYtY29sb3ItaG92ZXJgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0ZGRkZGRlwiKSB9YH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRm9jdXMnICkgfVxuXHRcdFx0XHRcdHZhbHVlPVwiZm9jdXNcIlxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCYWNrZ3JvdW5kIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfXByZXYtYmFja2dyb3VuZC1hY3RpdmVgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzE1OUM4NVwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnTGFiZWwgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9cHJldi1jb2xvci1hY3RpdmVgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0ZGRkZGRlwiKSB9YH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblx0XHRcdDwvVGFicz5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL3BhZ2luYXRpb24tYmFjay5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGdldFRoZW1lUHJlZml4LCBnZXREZWZhdWx0VmFsdWUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY29sb3ItcGlja2VyJztcbmltcG9ydCBUYWJzIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvdGFicyc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvY29udGFpbmVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmV4dENvbG9ycyBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PFRhYnNcblx0XHRcdFx0ZGVmYXVsdD1cImRlZmF1bHRcIlxuXHRcdFx0XHR0eXBlPVwidGFic1wiXG5cdFx0XHRcdGV4dHJhQ2xhc3M9XCJzdWktdGFicy1mbHVzaGVkXCJcblx0XHRcdD5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRGVmYXVsdCcgKSB9XG5cdFx0XHRcdFx0dmFsdWU9XCJkZWZhdWx0XCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQmFja2dyb3VuZCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1uZXh0LWJhY2tncm91bmQtc3RhdGljYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMxQUJDQTFcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0xhYmVsIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfW5leHQtY29sb3Itc3RhdGljYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNGRkZGRkZcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0hvdmVyJyApIH1cblx0XHRcdFx0XHR2YWx1ZT1cImhvdmVyXCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQmFja2dyb3VuZCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1uZXh0LWJhY2tncm91bmQtaG92ZXJgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzE1OUM4NVwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnTGFiZWwgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9bmV4dC1jb2xvci1ob3ZlcmB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjRkZGRkZGXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdGb2N1cycgKSB9XG5cdFx0XHRcdFx0dmFsdWU9XCJmb2N1c1wiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9bmV4dC1iYWNrZ3JvdW5kLWFjdGl2ZWB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMTU5Qzg1XCIpIH1gfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdMYWJlbCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1uZXh0LWNvbG9yLWFjdGl2ZWB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjRkZGRkZGXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0PC9UYWJzPlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvcGFnaW5hdGlvbi1uZXh0LmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSwgZ2V0VGhlbWVQcmVmaXgsIGdldERlZmF1bHRWYWx1ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IENvbG9yUGlja2VyIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9jb2xvci1waWNrZXInO1xuaW1wb3J0IFRhYnMgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy90YWJzJztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9jb250YWluZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWJtaXRDb2xvcnMgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxUYWJzXG5cdFx0XHRcdGRlZmF1bHQ9XCJkZWZhdWx0XCJcblx0XHRcdFx0dHlwZT1cInRhYnNcIlxuXHRcdFx0XHRleHRyYUNsYXNzPVwic3VpLXRhYnMtZmx1c2hlZFwiXG5cdFx0XHQ+XG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0RlZmF1bHQnICkgfVxuXHRcdFx0XHRcdHZhbHVlPVwiZGVmYXVsdFwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9YnV0dG9uLXN1Ym1pdC1iYWNrZ3JvdW5kLXN0YXRpY2AgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzE3QThFM1wiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGV4dCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1idXR0b24tc3VibWl0LWNvbG9yLXN0YXRpY2B9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjRkZGRkZGXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdIb3ZlcicgKSB9XG5cdFx0XHRcdFx0dmFsdWU9XCJob3ZlclwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9YnV0dG9uLXN1Ym1pdC1iYWNrZ3JvdW5kLWhvdmVyYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMwMDhGQ0FcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RleHQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9YnV0dG9uLXN1Ym1pdC1jb2xvci1ob3ZlcmB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjRkZGRkZGXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdGb2N1cycgKSB9XG5cdFx0XHRcdFx0dmFsdWU9XCJmb2N1c1wiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9YnV0dG9uLXN1Ym1pdC1iYWNrZ3JvdW5kLWFjdGl2ZWB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMDA4RkNBXCIpIH1gfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdUZXh0IGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWJ1dHRvbi1zdWJtaXQtY29sb3ItYWN0aXZlYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNGRkZGRkZcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cdFx0XHQ8L1RhYnM+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9zdWJtaXQuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlLCBoYXNGaWVsZFdpdGhBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBBY2NvcmRpb24gZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9hY2NvcmRpb24nO1xuaW1wb3J0IFNpbmdsZVVwbG9hZFBhbmVsQ29sb3JzIGZyb20gJy4vZmlsZS11cGxvYWQvdXBsb2FkLXBhbmVsLXNpbmdsZSc7XG5pbXBvcnQgTXVsdGlVcGxvYWRQYW5lbENvbG9ycyBmcm9tICcuL2ZpbGUtdXBsb2FkL3VwbG9hZC1wYW5lbC1tdWx0aXBsZSc7XG5pbXBvcnQgTXVsdGlVcGxvYWRGaWxlQ29sb3JzIGZyb20gJy4vZmlsZS11cGxvYWQvdXBsb2FkLWZpbGUtbXVsdGlwbGUnO1xuaW1wb3J0IEZpbGVEZWxldGVCdXR0b25Db2xvcnMgZnJvbSAnLi9maWxlLXVwbG9hZC91cGxvYWQtZmlsZS1kZWxldGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVcGxvYWRlZEZpbGVzQ29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGhhc1NpbmdsZVVwbG9hZCA9IGhhc0ZpZWxkV2l0aEF0dHJpYnV0ZShcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnMsXG5cdFx0XHQndXBsb2FkJyxcblx0XHRcdCdmaWxlLXR5cGUnLFxuXHRcdFx0J3NpbmdsZSdcblx0XHQpIHx8IGhhc0ZpZWxkV2l0aEF0dHJpYnV0ZShcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnMsXG5cdFx0XHQncG9zdGRhdGEnLFxuXHRcdFx0J3Bvc3RfaW1hZ2UnLFxuXHRcdFx0J2ZhbHNlJ1xuXHRcdCk7XG5cblx0XHRjb25zdCBoYXNNdWx0aVVwbG9hZCA9IGhhc0ZpZWxkV2l0aEF0dHJpYnV0ZShcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnMsXG5cdFx0XHQndXBsb2FkJyxcblx0XHRcdCdmaWxlLXR5cGUnLFxuXHRcdFx0J211bHRpcGxlJ1xuXHRcdCk7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94XCI+XG5cblx0XHRcdFx0eyBoYXNTaW5nbGVVcGxvYWQgJiZcblx0XHRcdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cblx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdTaW5nbGUgRmlsZSBVcGxvYWRlcicgKSB9XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdDxTaW5nbGVVcGxvYWRQYW5lbENvbG9ycyB7IC4uLnRoaXMucHJvcHMgfSAvPlxuXHRcdFx0XHRcdFx0PC9BY2NvcmRpb24+XG5cblx0XHRcdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHR9XG5cblx0XHRcdFx0eyBoYXNNdWx0aVVwbG9hZCAmJlxuXHRcdFx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblxuXHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ011bHRpcGxlIEZpbGVzIFVwbG9hZGVyJyApIH1cblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0PE11bHRpVXBsb2FkUGFuZWxDb2xvcnMgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVXBsb2FkZWQgRmlsZScgKSB9XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdDxNdWx0aVVwbG9hZEZpbGVDb2xvcnMgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVXBsb2FkZWQgRmlsZSBEZWxldGUgQnV0dG9uJyApIH1cblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxGaWxlRGVsZXRlQnV0dG9uQ29sb3JzIHsgLi4udGhpcy5wcm9wcyB9IC8+XG5cdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL3VwbG9hZGVkLWZpbGVzLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSAsIGdldFRoZW1lUHJlZml4LCBnZXREZWZhdWx0VmFsdWUgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb2xvclBpY2tlciBmcm9tICcuLi8uLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvY29sb3ItcGlja2VyJztcbmltcG9ydCBUYWJzIGZyb20gJy4uLy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvdGFicyc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uLy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvY29udGFpbmVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2luZ2xlVXBsb2FkUGFuZWxDb2xvcnMgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxUYWJzXG5cdFx0XHRcdGRlZmF1bHQ9XCJkZWZhdWx0XCJcblx0XHRcdFx0dHlwZT1cInRhYnNcIlxuXHRcdFx0XHRleHRyYUNsYXNzPVwic3VpLXRhYnMtZmx1c2hlZFwiXG5cdFx0XHQ+XG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0RlZmF1bHQnICkgfVxuXHRcdFx0XHRcdHZhbHVlPVwiZGVmYXVsdFwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9YnV0dG9uLXVwbG9hZC1iYWNrZ3JvdW5kLXN0YXRpY2B9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjMUFCQzlDXCIpIH1gfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdUZXh0IGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWJ1dHRvbi11cGxvYWQtY29sb3Itc3RhdGljYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNGRkZGRkZcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0hvdmVyJyApIH1cblx0XHRcdFx0XHR2YWx1ZT1cImhvdmVyXCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQmFja2dyb3VuZCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1idXR0b24tdXBsb2FkLWJhY2tncm91bmQtaG92ZXJgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzAxQTM4M1wiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVGV4dCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1idXR0b24tdXBsb2FkLWNvbG9yLWhvdmVyYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNGRkZGRkZcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ZvY3VzJyApIH1cblx0XHRcdFx0XHR2YWx1ZT1cImZvY3VzXCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQmFja2dyb3VuZCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1idXR0b24tdXBsb2FkLWJhY2tncm91bmQtYWN0aXZlYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMwMUEzODNcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RleHQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9YnV0dG9uLXVwbG9hZC1jb2xvci1hY3RpdmVgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0ZGRkZGRlwiKSB9YH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblx0XHRcdDwvVGFicz5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvY29sb3JzL2ZpbGUtdXBsb2FkL3VwbG9hZC1wYW5lbC1zaW5nbGUuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlICwgZ2V0VGhlbWVQcmVmaXgsIGdldERlZmF1bHRWYWx1ZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IFRhYnMgZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy90YWJzJztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9jb250YWluZXInO1xuaW1wb3J0IENvbG9yUGlja2VyIGZyb20gJy4uLy4uLy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9jb2xvci1waWNrZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNdWx0aVVwbG9hZFBhbmVsQ29sb3JzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8VGFic1xuXHRcdFx0XHRkZWZhdWx0PVwiZGVmYXVsdFwiXG5cdFx0XHRcdHR5cGU9XCJ0YWJzXCJcblx0XHRcdFx0ZXh0cmFDbGFzcz1cInN1aS10YWJzLWZsdXNoZWRcIlxuXHRcdFx0PlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHR2YWx1ZT1cImRlZmF1bHRcIlxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRGVmYXVsdCcgKSB9XG5cdFx0XHRcdD5cblxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnbWF0ZXJpYWwnICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCYWNrZ3JvdW5kIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9bXVsdGl1cGxvYWQtcGFuZWwtYmFja2dyb3VuZC1kZWZhdWx0YH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0VERURFRFwiKSB9YH1cblx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ2ZsYXQnICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXIgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1tdWx0aXVwbG9hZC1wYW5lbC1ib3JkZXItZGVmYXVsdGB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM3Nzc3NzFcIikgfWB9XG5cdFx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdDbG91ZCBpY29uIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfW11bHRpdXBsb2FkLXBhbmVsLWljb24tZGVmYXVsdGB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjNzc3NzcxXCIpIH1gfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ01lc3NhZ2UgdGV4dCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1tdWx0aXVwbG9hZC1wYW5lbC10ZXh0LWRlZmF1bHRgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzY2NjY2NlwiKSB9YH1cblx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdNZXNzYWdlIGxpbmsgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9bXVsdGl1cGxvYWQtcGFuZWwtbGluay1kZWZhdWx0YH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMxN0E4RTNcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0dmFsdWU9XCJob3ZlclwiXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdIb3ZlcicgKSB9XG5cdFx0XHRcdD5cblxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnbWF0ZXJpYWwnICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCYWNrZ3JvdW5kIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9bXVsdGl1cGxvYWQtcGFuZWwtYmFja2dyb3VuZC1ob3ZlcmB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFNkU2RTZcIikgfWB9XG5cdFx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdmbGF0JyAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQm9yZGVyIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9bXVsdGl1cGxvYWQtcGFuZWwtYm9yZGVyLWhvdmVyYH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzE3QThFM1wiKSB9YH1cblx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0Nsb3VkIGljb24gY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9bXVsdGl1cGxvYWQtcGFuZWwtaWNvbi1ob3ZlcmB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjNzc3NzcxXCIpIH1gfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdHZhbHVlPVwiZHJvcFwiXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdEcm9wJyApIH1cblx0XHRcdFx0PlxuXG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdtYXRlcmlhbCcgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1tdWx0aXVwbG9hZC1wYW5lbC1iYWNrZ3JvdW5kLWRyb3BgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjRTFGNkZGXCIpIH1gfVxuXHRcdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnZmxhdCcgJiZcblx0XHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfW11bHRpdXBsb2FkLXBhbmVsLWJvcmRlci1kcm9wYH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzE3QThFM1wiKSB9YH1cblx0XHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0Nsb3VkIGljb24gY29sb3InICkgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9bXVsdGl1cGxvYWQtcGFuZWwtaWNvbi1kcm9wYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMxN0E4RTNcIikgfWB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0dmFsdWU9XCJlcnJvclwiXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdFcnJvcicgKSB9XG5cdFx0XHRcdD5cblxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnbWF0ZXJpYWwnICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCYWNrZ3JvdW5kIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9bXVsdGl1cGxvYWQtcGFuZWwtYmFja2dyb3VuZC1lcnJvcmB9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFREVERURcIikgfWB9XG5cdFx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gPT09ICdmbGF0J1xuXHRcdFx0XHRcdFx0XHQ/IHRyYW5zbGF0ZSggJ0xlZnQgYm9yZGVyIGNvbG9yJyApXG5cdFx0XHRcdFx0XHRcdDogdHJhbnNsYXRlKCAnQm9yZGVyIGNvbG9yJyApXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1tdWx0aXVwbG9hZC1wYW5lbC1ib3JkZXItZXJyb3JgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0UwNDU2MlwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdDbG91ZCBpY29uIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfW11bHRpdXBsb2FkLXBhbmVsLWljb24tZXJyb3JgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiIzc3Nzc3MVwiKSB9YH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHQ8L1RhYnM+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9maWxlLXVwbG9hZC91cGxvYWQtcGFuZWwtbXVsdGlwbGUuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlICwgZ2V0VGhlbWVQcmVmaXgsIGdldERlZmF1bHRWYWx1ZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IFRhYnMgZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy90YWJzJztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9jb250YWluZXInO1xuaW1wb3J0IENvbG9yUGlja2VyIGZyb20gJy4uLy4uLy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9jb2xvci1waWNrZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNdWx0aVVwbG9hZEZpbGVDb2xvcnMgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxUYWJzXG5cdFx0XHRcdGRlZmF1bHQ9XCJkZWZhdWx0XCJcblx0XHRcdFx0dHlwZT1cInRhYnNcIlxuXHRcdFx0XHRleHRyYUNsYXNzPVwic3VpLXRhYnMtZmx1c2hlZFwiXG5cdFx0XHQ+XG5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdHZhbHVlPVwiZGVmYXVsdFwiXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdEZWZhdWx0JyApIH1cblx0XHRcdFx0PlxuXG5cdFx0XHRcdFx0eyB0aGlzLnByb3BzLmZvcm1EZXNpZ24gIT09ICdmbGF0JyAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRmlsZSBwcmV2aWV3IGJvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdGRlc2NyaXB0aW9uPXsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHRcdCdEZWZhdWx0IHN0YXRlIGJvcmRlciB3aWxsIG5vdCBhcHBlYXIgd2hlbiBmaWxlICcgK1xuXHRcdFx0XHRcdFx0XHRcdCd1cGxvYWRlZCBpcyBhbiBpbWFnZS4nXG5cdFx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1tdWx0aXVwbG9hZC1maWxlLXByZXZpZXctYm9yZGVyLWRlZmF1bHRgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjNzc3NzcxXCIpIH1gfVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR7IHRoaXMucHJvcHMuZm9ybURlc2lnbiAhPT0gJ21hdGVyaWFsJyAmJlxuXHRcdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRmlsZSBwcmV2aWV3IGJhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1tdWx0aXVwbG9hZC1maWxlLXByZXZpZXctYmFja2dyb3VuZC1kZWZhdWx0YH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXsgdGhpcy5wcm9wcy5mb3JtRGVzaWduID09PSAnZmxhdCdcblx0XHRcdFx0XHRcdFx0XHQ/ICcjRURFREVEJ1xuXHRcdFx0XHRcdFx0XHRcdDogJyNGRkZGRkYnXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdGaWxlIHByZXZpZXcgaWNvbiBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1tdWx0aXVwbG9hZC1maWxlLXByZXZpZXctaWNvbi1kZWZhdWx0YH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM3Nzc3NzFcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRmlsZSBuYW1lIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfW11bHRpdXBsb2FkLWZpbGUtbmFtZS1kZWZhdWx0YH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMzMzMzMzNcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRmlsZSBzaXplIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfW11bHRpdXBsb2FkLWZpbGUtc2l6ZS1kZWZhdWx0YH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM4ODg4ODhcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnTG9hZGluZyBpY29uIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfW11bHRpdXBsb2FkLWZpbGUtbG9hZGVyLWNvbG9yYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiM4ODg4ODhcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0dmFsdWU9XCJlcnJvclwiXG5cdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdFcnJvcicgKSB9XG5cdFx0XHRcdD5cblxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRmlsZSBwcmV2aWV3IGJvcmRlciBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1tdWx0aXVwbG9hZC1maWxlLXByZXZpZXctYm9yZGVyLWVycm9yYH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFMDQ1NjJcIikgfWB9XG5cdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdHsgdGhpcy5wcm9wcy5mb3JtRGVzaWduICE9PSAnbWF0ZXJpYWwnICYmXG5cdFx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdGaWxlIHByZXZpZXcgYmFja2dyb3VuZCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfW11bHRpdXBsb2FkLWZpbGUtcHJldmlldy1iYWNrZ3JvdW5kLWVycm9yYH1cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXsgdGhpcy5wcm9wcy5mb3JtRGVzaWduID09PSAnZmxhdCdcblx0XHRcdFx0XHRcdFx0XHQ/ICcjRURFREVEJ1xuXHRcdFx0XHRcdFx0XHRcdDogJyNGRkZGRkYnXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdGaWxlIHByZXZpZXcgaWNvbiBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1tdWx0aXVwbG9hZC1maWxlLXByZXZpZXctaWNvbi1lcnJvcmB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjNzc3NzcxXCIpIH1gfVxuXHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ZpbGUgc2l6ZSBpY29uIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfW11bHRpdXBsb2FkLWZpbGUtZXJyb3ItY29sb3JgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0UwNDU2MlwiKSB9YH1cblx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHQ8L1RhYnM+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycy9maWxlLXVwbG9hZC91cGxvYWQtZmlsZS1tdWx0aXBsZS5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgLCBnZXRUaGVtZVByZWZpeCwgZ2V0RGVmYXVsdFZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgQ29sb3JQaWNrZXIgZnJvbSAnLi4vLi4vLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2NvbG9yLXBpY2tlcic7XG5pbXBvcnQgVGFicyBmcm9tICcuLi8uLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL3RhYnMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi8uLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbnRhaW5lcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbGVEZWxldGVCdXR0b25Db2xvcnMgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxUYWJzXG5cdFx0XHRcdGRlZmF1bHQ9XCJkZWZhdWx0XCJcblx0XHRcdFx0dHlwZT1cInRhYnNcIlxuXHRcdFx0XHRleHRyYUNsYXNzPVwic3VpLXRhYnMtZmx1c2hlZFwiXG5cdFx0XHQ+XG5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRGVmYXVsdCcgKSB9XG5cdFx0XHRcdFx0dmFsdWU9XCJkZWZhdWx0XCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiMwMDAwMDAwMFwiKSB9YH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWJ1dHRvbi11cGxvYWQtZGVsZXRlLWJhY2tncm91bmQtc3RhdGljYH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQmFja2dyb3VuZCBjb2xvcicgKSB9XG5cdFx0XHRcdFx0XHRpc0FscGhhXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8Q29sb3JQaWNrZXJcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgXCIjRTA0NTYyXCIpIH1gfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9YnV0dG9uLXVwbG9hZC1kZWxldGUtY29sb3Itc3RhdGljYH1cblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnSWNvbiBjb2xvcicgKSB9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnSG92ZXInICkgfVxuXHRcdFx0XHRcdHZhbHVlPVwiaG92ZXJcIlxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0Y5RTRFOFwiKSB9YH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWJ1dHRvbi11cGxvYWQtZGVsZXRlLWJhY2tncm91bmQtaG92ZXJgfVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdCYWNrZ3JvdW5kIGNvbG9yJyApIH1cblx0XHRcdFx0XHRcdGlzQWxwaGFcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNFMDQ1NjJcIikgfWB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1idXR0b24tdXBsb2FkLWRlbGV0ZS1jb2xvci1ob3ZlcmB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ljb24gY29sb3InICkgfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXG5cdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ZvY3VzJyApIH1cblx0XHRcdFx0XHR2YWx1ZT1cImZvY3VzXCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxDb2xvclBpY2tlclxuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17YCR7IGdldERlZmF1bHRWYWx1ZSh0aGlzLnByb3BzLCBcIiNGOUU0RThcIikgfWB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IGdldFRoZW1lUHJlZml4KHRoaXMucHJvcHMpIH1idXR0b24tdXBsb2FkLWRlbGV0ZS1iYWNrZ3JvdW5kLWFjdGl2ZWB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0JhY2tncm91bmQgY29sb3InICkgfVxuXHRcdFx0XHRcdFx0aXNBbHBoYVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PENvbG9yUGlja2VyXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIFwiI0UwNDU2MlwiKSB9YH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcykgfWJ1dHRvbi11cGxvYWQtZGVsZXRlLWNvbG9yLWFjdGl2ZWB9XG5cdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ljb24gY29sb3InICkgfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvQ29udGFpbmVyPlxuXHRcdFx0PC9UYWJzPlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jb2xvcnMvZmlsZS11cGxvYWQvdXBsb2FkLWZpbGUtZGVsZXRlLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSwgaGFzRmllbGRUeXBlLCBoYXNGaWVsZFdpdGhBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9jb250YWluZXInO1xuaW1wb3J0IFJhZGlvVGFicyBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvcmFkaW8tdGFicyc7XG5pbXBvcnQgQWNjb3JkaW9uIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvYWNjb3JkaW9uJztcbmltcG9ydCBFbXB0eSBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2VtcHR5JztcbmltcG9ydCBGb250U2V0dGluZ3MgZnJvbSAnLi4vc2V0dGluZ3MvZm9udHMnO1xuaW1wb3J0IFNldHRpbmdzUm93IGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvc2V0dGluZ3Mtcm93JztcbmltcG9ydCBUYWJzIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvdGFicyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvbnRzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGhhc1BhZ2luYXRpb24gPSBoYXNGaWVsZFR5cGUoXG5cdFx0XHQncGFnZS1icmVhaycsXG5cdFx0XHR0aGlzLnByb3BzLndyYXBwZXJzXG5cdFx0KTtcblxuXHRcdGNvbnN0IGhhc1NlY3Rpb24gPSBoYXNGaWVsZFR5cGUoXG5cdFx0XHQnc2VjdGlvbicsXG5cdFx0XHR0aGlzLnByb3BzLndyYXBwZXJzXG5cdFx0KTtcblxuXHRcdGNvbnN0IGhhc1NpbmdsZVJhZGlvID0gaGFzRmllbGRXaXRoQXR0cmlidXRlKFxuXHRcdFx0dGhpcy5wcm9wcy53cmFwcGVycyxcblx0XHRcdCdyYWRpbycsXG5cdFx0XHQndmFsdWVfdHlwZScsXG5cdFx0XHQncmFkaW8nXG5cdFx0KTtcblxuXHRcdGNvbnN0IGhhc1NpbmdsZURyb3Bkb3duID0gaGFzRmllbGRXaXRoQXR0cmlidXRlKFxuXHRcdFx0dGhpcy5wcm9wcy53cmFwcGVycyxcblx0XHRcdCdzZWxlY3QnLFxuXHRcdFx0J3ZhbHVlX3R5cGUnLFxuXHRcdFx0J3NpbmdsZSdcblx0XHQpO1xuXG5cdFx0Y29uc3QgaGFzTXVsdGlDaGVja2JveCA9IGhhc0ZpZWxkV2l0aEF0dHJpYnV0ZShcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnMsXG5cdFx0XHQnY2hlY2tib3gnLFxuXHRcdFx0J3ZhbHVlX3R5cGUnLFxuXHRcdFx0J2NoZWNrYm94J1xuXHRcdCk7XG5cblx0XHRjb25zdCBoYXNNdWx0aVNlbGVjdCA9IGhhc0ZpZWxkV2l0aEF0dHJpYnV0ZShcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnMsXG5cdFx0XHQnc2VsZWN0Jyxcblx0XHRcdCd2YWx1ZV90eXBlJyxcblx0XHRcdCdtdWx0aXNlbGVjdCdcblx0XHQpO1xuXG5cdFx0Y29uc3QgaGFzRGF0ZVBpY2tlciA9IGhhc0ZpZWxkV2l0aEF0dHJpYnV0ZShcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnMsXG5cdFx0XHQnZGF0ZScsXG5cdFx0XHQnZmllbGRfdHlwZScsXG5cdFx0XHQncGlja2VyJ1xuXHRcdCk7XG5cblx0XHRjb25zdCBoYXNEYXRlRHJvcGRvd24gPSBoYXNGaWVsZFdpdGhBdHRyaWJ1dGUoXG5cdFx0XHR0aGlzLnByb3BzLndyYXBwZXJzLFxuXHRcdFx0J2RhdGUnLFxuXHRcdFx0J2ZpZWxkX3R5cGUnLFxuXHRcdFx0J3NlbGVjdCdcblx0XHQpO1xuXG5cdFx0Y29uc3QgaGFzVGltZURyb3Bkb3duID0gaGFzRmllbGRXaXRoQXR0cmlidXRlKFxuXHRcdFx0dGhpcy5wcm9wcy53cmFwcGVycyxcblx0XHRcdCd0aW1lJyxcblx0XHRcdCdmaWVsZF90eXBlJyxcblx0XHRcdCdzZWxlY3QnXG5cdFx0KSB8fCBoYXNGaWVsZFdpdGhBdHRyaWJ1dGUoXG5cdFx0XHR0aGlzLnByb3BzLndyYXBwZXJzLFxuXHRcdFx0J3RpbWUnLFxuXHRcdFx0J3RpbWVfdHlwZScsXG5cdFx0XHQndHdlbHZlJ1xuXHRcdCk7XG5cblx0XHRjb25zdCBoYXNBZGRyZXNDb3VudHJ5ID0gaGFzRmllbGRXaXRoQXR0cmlidXRlKFxuXHRcdFx0dGhpcy5wcm9wcy53cmFwcGVycyxcblx0XHRcdCdhZGRyZXNzJyxcblx0XHRcdCdhZGRyZXNzX2NvdW50cnknLFxuXHRcdFx0J3RydWUnXG5cdFx0KTtcblxuXHRcdGNvbnN0IGhhc05hbWVQcmVmaXggPSBoYXNGaWVsZFdpdGhBdHRyaWJ1dGUoXG5cdFx0XHR0aGlzLnByb3BzLndyYXBwZXJzLFxuXHRcdFx0J25hbWUnLFxuXHRcdFx0J3ByZWZpeCcsXG5cdFx0XHQndHJ1ZSdcblx0XHQpO1xuXG5cdFx0Y29uc3QgaGFzR0RQUiA9IGhhc0ZpZWxkVHlwZShcblx0XHRcdCdnZHByY2hlY2tib3gnLFxuXHRcdFx0dGhpcy5wcm9wcy53cmFwcGVyc1xuXHRcdCk7XG5cblx0XHRjb25zdCBoYXNDdXJyZW5jeSA9IGhhc0ZpZWxkVHlwZShcblx0XHRcdCdjdXJyZW5jeScsXG5cdFx0XHR0aGlzLnByb3BzLndyYXBwZXJzXG5cdFx0KTtcblxuXHRcdGNvbnN0IGhhc1NpbmdsZVVwbG9hZCA9IGhhc0ZpZWxkV2l0aEF0dHJpYnV0ZShcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnMsXG5cdFx0XHQndXBsb2FkJyxcblx0XHRcdCdmaWxlLXR5cGUnLFxuXHRcdFx0J3NpbmdsZSdcblx0XHQpIHx8IGhhc0ZpZWxkV2l0aEF0dHJpYnV0ZShcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnMsXG5cdFx0XHQncG9zdGRhdGEnLFxuXHRcdFx0J3Bvc3RfaW1hZ2UnLFxuXHRcdFx0J2ZhbHNlJ1xuXHRcdCk7XG5cblx0XHRjb25zdCBoYXNNdWx0aVVwbG9hZCA9IGhhc0ZpZWxkV2l0aEF0dHJpYnV0ZShcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnMsXG5cdFx0XHQndXBsb2FkJyxcblx0XHRcdCdmaWxlLXR5cGUnLFxuXHRcdFx0J211bHRpcGxlJ1xuXHRcdCk7XG5cblx0XHRjb25zdCBoYXNFU2lnbiA9IGhhc0ZpZWxkVHlwZShcblx0XHRcdCdzaWduYXR1cmUnLFxuXHRcdFx0dGhpcy5wcm9wcy53cmFwcGVyc1xuXHRcdCk7XG5cblx0XHRjb25zdCBoYXNDYWxjdWxhdGlvbiA9IGhhc0ZpZWxkVHlwZShcblx0XHRcdCdjYWxjdWxhdGlvbicsXG5cdFx0XHR0aGlzLnByb3BzLndyYXBwZXJzXG5cdFx0KTtcblxuXHRcdGNvbnN0IGhhc0dyb3VwID0gaGFzRmllbGRUeXBlKFxuXHRcdFx0J2dyb3VwJyxcblx0XHRcdHRoaXMucHJvcHMud3JhcHBlcnNcblx0XHQpO1xuXG5cdFx0Y29uc3QgaXNQcmVzZXQgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMucHJlc2V0ICk7XG5cblx0XHRjb25zdCBoYXNQYWdpbmF0aW9uSGVhZGVyID0gXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5ncy5wYWdpbmF0aW9uRGF0YSApIHx8IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3MucGFnaW5hdGlvbkRhdGFbICdwYWdpbmF0aW9uLWhlYWRlci1kZXNpZ24nIF0gKVxuXHRcdFx0PyAnJ1xuXHRcdFx0OiB0aGlzLnByb3BzLnNldHRpbmdzLnBhZ2luYXRpb25EYXRhWyAncGFnaW5hdGlvbi1oZWFkZXItZGVzaWduJyBdO1xuXG5cdFx0Y29uc3QgcGFnaW5hdGlvbkhlYWRlciA9IF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3MucGFnaW5hdGlvbkRhdGEgKSB8fCBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzLnBhZ2luYXRpb25EYXRhWyAncGFnaW5hdGlvbi1oZWFkZXInIF0gKVxuXHRcdFx0PyAnJ1xuXHRcdFx0OiB0aGlzLnByb3BzLnNldHRpbmdzLnBhZ2luYXRpb25EYXRhWyAncGFnaW5hdGlvbi1oZWFkZXInIF07XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PFNldHRpbmdzUm93XG5cdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRm9udHMnICkgfVxuXHRcdFx0XHRkZXNjcmlwdGlvbj17IHRyYW5zbGF0ZShcblx0XHRcdFx0XHQnQnkgZGVmYXVsdCB0aGlzIGZvcm0gd2lsbCBpbmhlcml0IHRoZSBmb250cyB5b3VyIHRoZW1lIHVzZXMuICcgK1xuXHRcdFx0XHRcdCdZb3UgY2FuIG92ZXJ3cml0ZSB0aGVzZSBmb250cyB3aXRoIGN1c3RvbSBvbmVzIGZyb20gJyArXG5cdFx0XHRcdFx0J3t7bGlua319QnVubnkgRm9udHN7ey9saW5rfX0uJyxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb21wb25lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdGxpbms6IDxhIGhyZWY9XCJodHRwczovL2ZvbnRzLmJ1bm55Lm5ldC9hYm91dFwiIHRhcmdldD1cIl9ibGFua1wiIC8+LFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCkgfVxuXHRcdFx0PlxuXG5cdFx0XHRcdDxSYWRpb1RhYnNcblx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdHByb3BlcnR5PVwiZm9ybS1mb250LWZhbWlseVwiXG5cdFx0XHRcdFx0ZGVmYXVsdD1cIlwiXG5cdFx0XHRcdD5cblxuXHRcdFx0XHRcdDxFbXB0eVxuXHRcdFx0XHRcdFx0dmFsdWU9XCJcIlxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnVXNlIFRoZW1lIEZvbnRzJyApIH1cblx0XHRcdFx0XHQ8L0VtcHR5PlxuXG5cdFx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdFx0dmFsdWU9XCJjdXN0b21cIlxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdDdXN0b20nICkgfVxuXHRcdFx0XHRcdD5cblxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYWNjb3JkaW9uXCI+XG5cblx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdSZXNwb25zZSBNZXNzYWdlJyApIH1cblx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdDxGb250U2V0dGluZ3Ncblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRwcmVmaXg9XCJjZm9ybS1yZXNwb25zZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0U2l6ZT1cIjE1XCJcblx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRGb250PVwiY3VzdG9tXCJcblx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRDdXN0b209XCJpbmhlcml0XCJcblx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRXZWlnaHQ9XCI0MDBcIlxuXHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHRcdHsgKCBpc1ByZXNldCB8fCBoYXNQYWdpbmF0aW9uICYmIGhhc1BhZ2luYXRpb25IZWFkZXIgPT09ICdzaG93JyAmJiBwYWdpbmF0aW9uSGVhZGVyID09PSAnbmF2JyApICYmXG5cdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUGFnaW5hdGlvbiBTdGVwcycgKSB9XG5cdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0PEZvbnRTZXR0aW5nc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwcmVmaXg9XCJjZm9ybS10aW1lbGluZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRTaXplPVwiMTJcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Rm9udD1cImN1c3RvbVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRDdXN0b209XCJpbmhlcml0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFdlaWdodD1cIjUwMFwiXG5cdFx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHsgKCBpc1ByZXNldCB8fCBoYXNQYWdpbmF0aW9uICYmIGhhc1BhZ2luYXRpb25IZWFkZXIgPT09ICdzaG93JyAmJiBwYWdpbmF0aW9uSGVhZGVyID09PSAnYmFyJyApICYmXG5cdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUGFnaW5hdGlvbiBQcm9ncmVzcyBCYXInICkgfVxuXHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdDxGb250U2V0dGluZ3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJlZml4PVwiY2Zvcm0tcHJvZ3Jlc3NcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0U2l6ZT1cIjEyXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdEZvbnQ9XCJjdXN0b21cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Q3VzdG9tPVwiaW5oZXJpdFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRXZWlnaHQ9XCI1MDBcIlxuXHRcdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRmllbGRzIExhYmVsJyApIH1cblx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdDxGb250U2V0dGluZ3Ncblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRwcmVmaXg9XCJjZm9ybS1sYWJlbFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0U2l6ZT1cIjEzXCJcblx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRGb250PVwiY3VzdG9tXCJcblx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRDdXN0b209XCJpbmhlcml0XCJcblx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRXZWlnaHQ9XCI3MDBcIlxuXHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRmllbGRzIERlc2NyaXB0aW9uJyApIH1cblx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdDxGb250U2V0dGluZ3Ncblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRwcmVmaXg9XCJjZm9ybS1kZXNjcmlwdGlvblwiXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0U2l6ZT1cIjEyXCJcblx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRGb250PVwiY3VzdG9tXCJcblx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRDdXN0b209XCJpbmhlcml0XCJcblx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRXZWlnaHQ9XCI0MDBcIlxuXHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRmllbGRzIEVycm9yIE1lc3NhZ2UnICkgfVxuXHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0PEZvbnRTZXR0aW5nc1xuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdHByZWZpeD1cImNmb3JtLXZhbGlkYXRpb25cIlxuXHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFNpemU9XCIxMlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Rm9udD1cImN1c3RvbVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Q3VzdG9tPVwiaW5oZXJpdFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0V2VpZ2h0PVwiNTAwXCJcblx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblxuXHRcdFx0XHRcdFx0XHR7IGhhc1NlY3Rpb24gJiZcblx0XHRcdFx0XHRcdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cblx0XHRcdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdTZWN0aW9uIFRpdGxlJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PEZvbnRTZXR0aW5nc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJlZml4PVwiY2Zvcm0tdGl0bGVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRTaXplPVwiNDVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRGb250PVwiY3VzdG9tXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Q3VzdG9tPVwiaW5oZXJpdFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFdlaWdodD1cIjQwMFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblxuXHRcdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1NlY3Rpb24gU3VidGl0bGUnICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8Rm9udFNldHRpbmdzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcmVmaXg9XCJjZm9ybS1zdWJ0aXRsZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFNpemU9XCIxOFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdEZvbnQ9XCJjdXN0b21cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRDdXN0b209XCJpbmhlcml0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0V2VpZ2h0PVwiNDAwXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnSW5wdXQgYW5kIFRleHRhcmVhJyApIH1cblx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdDxGb250U2V0dGluZ3Ncblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRwcmVmaXg9XCJjZm9ybS1pbnB1dFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0U2l6ZT1cIjE2XCJcblx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRGb250PVwiUm9ib3RvXCJcblx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRXZWlnaHQ9XCI0MDBcIlxuXHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHRcdHsgKCBoYXNDYWxjdWxhdGlvbiApICYmXG5cdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnSW5wdXQgUHJlZml4JyApIH1cblx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8Rm9udFNldHRpbmdzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByZWZpeD1cImNmb3JtLWlucHV0LXByZWZpeFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRTaXplPVwiMTZcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Rm9udD1cImN1c3RvbVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRDdXN0b209XCJpbmhlcml0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFdlaWdodD1cIjUwMFwiXG5cdFx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHsgKCBoYXNDdXJyZW5jeSB8fFxuXHRcdFx0XHRcdFx0XHRcdGhhc0NhbGN1bGF0aW9uXG5cdFx0XHRcdFx0XHRcdCkgJiZcblx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdJbnB1dCBTdWZmaXgnICkgfVxuXHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdDxGb250U2V0dGluZ3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJlZml4PVwiY2Zvcm0taW5wdXQtc3VmZml4XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFNpemU9XCIxNlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRGb250PVwiY3VzdG9tXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdEN1c3RvbT1cImluaGVyaXRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0V2VpZ2h0PVwiNTAwXCJcblx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdFx0PC9BY2NvcmRpb24+XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR7IChcblx0XHRcdFx0XHRcdFx0XHRoYXNNdWx0aUNoZWNrYm94IHx8XG5cdFx0XHRcdFx0XHRcdFx0aGFzU2luZ2xlUmFkaW8gfHxcblx0XHRcdFx0XHRcdFx0XHRoYXNHRFBSXG5cdFx0XHRcdFx0XHRcdCkgJiZcblx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdSYWRpbyBhbmQgQ2hlY2tib3gnICkgfVxuXHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdDxGb250U2V0dGluZ3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJlZml4PVwiY2Zvcm0tcmFkaW9cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0U2l6ZT1cIjE0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdEZvbnQ9XCJjdXN0b21cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Q3VzdG9tPVwiaW5oZXJpdFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRXZWlnaHQ9XCI0MDBcIlxuXHRcdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHsgKFxuXHRcdFx0XHRcdFx0XHRcdGhhc1NpbmdsZURyb3Bkb3duIHx8XG5cdFx0XHRcdFx0XHRcdFx0aGFzRGF0ZURyb3Bkb3duIHx8XG5cdFx0XHRcdFx0XHRcdFx0aGFzVGltZURyb3Bkb3duIHx8XG5cdFx0XHRcdFx0XHRcdFx0aGFzQWRkcmVzQ291bnRyeSB8fFxuXHRcdFx0XHRcdFx0XHRcdGhhc05hbWVQcmVmaXhcblx0XHRcdFx0XHRcdFx0KSAmJlxuXHRcdFx0XHRcdFx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblxuXHRcdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1NlbGVjdCcgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxGb250U2V0dGluZ3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByZWZpeD1cImNmb3JtLXNlbGVjdFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFNpemU9XCIxNlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdEZvbnQ9XCJjdXN0b21cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRDdXN0b209XCJpbmhlcml0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0V2VpZ2h0PVwiNDAwXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRHJvcGRvd24nICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8Rm9udFNldHRpbmdzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcmVmaXg9XCJjZm9ybS1kcm9wZG93blwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFNpemU9XCIxNlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdEZvbnQ9XCJjdXN0b21cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRDdXN0b209XCJpbmhlcml0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0V2VpZ2h0PVwiNDAwXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXG5cdFx0XHRcdFx0XHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHsgaGFzRGF0ZVBpY2tlciAmJlxuXHRcdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0NhbGVuZGFyJyApIH1cblx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8Rm9udFNldHRpbmdzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByZWZpeD1cImNmb3JtLWNhbGVuZGFyXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdEZvbnQ9XCJjdXN0b21cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Q3VzdG9tPVwiaW5oZXJpdFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZhbWlseU9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdFx0PC9BY2NvcmRpb24+XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR7IGhhc011bHRpU2VsZWN0ICYmXG5cdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnTXVsdGkgU2VsZWN0JyApIH1cblx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8Rm9udFNldHRpbmdzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByZWZpeD1cImNmb3JtLW11bHRpc2VsZWN0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFNpemU9XCIxNlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRGb250PVwiY3VzdG9tXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdEN1c3RvbT1cImluaGVyaXRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0V2VpZ2h0PVwiNDAwXCJcblx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdFx0PC9BY2NvcmRpb24+XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR7IGhhc1NpbmdsZVVwbG9hZCAmJlxuXHRcdFx0XHRcdFx0XHRcdDxBY2NvcmRpb25cblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1NpbmdsZSBGaWxlIFVwbG9hZCcgKSB9XG5cdFx0XHRcdFx0XHRcdFx0PlxuXG5cdFx0XHRcdFx0XHRcdFx0XHQ8VGFic1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlPVwidGFic1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ9XCJ1cGxvYWQtc2luZ2xlLWJ1dHRvblwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGV4dHJhQ2xhc3M9XCJzdWktdGFicy1mbHVzaGVkXCJcblx0XHRcdFx0XHRcdFx0XHRcdD5cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8Rm9udFNldHRpbmdzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZT1cInVwbG9hZC1zaW5nbGUtYnV0dG9uXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1VwbG9hZCBCdXR0b24nICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByZWZpeD1cInVwbG9hZC1zaW5nbGUtYnV0dG9uXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0U2l6ZT1cIjE0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Rm9udD1cImN1c3RvbVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdEN1c3RvbT1cImluaGVyaXRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRXZWlnaHQ9XCI3MDBcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxGb250U2V0dGluZ3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlPVwidXBsb2FkLXNpbmdsZS10ZXh0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ZpbGUgTmFtZScgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJlZml4PVwidXBsb2FkLXNpbmdsZS10ZXh0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0U2l6ZT1cIjEyXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Rm9udD1cImN1c3RvbVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdEN1c3RvbT1cImluaGVyaXRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRXZWlnaHQ9XCI3MDBcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0XHRcdFx0XHQ8L1RhYnM+XG5cblx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHsgaGFzTXVsdGlVcGxvYWQgJiZcblx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdNdWx0aXBsZSBGaWxlcyBVcGxvYWQnICkgfVxuXHRcdFx0XHRcdFx0XHRcdD5cblxuXHRcdFx0XHRcdFx0XHRcdFx0PFRhYnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZT1cInRhYnNcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0PVwidXBsb2FkLW11bHRpcGxlLXBhbmVsXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZXh0cmFDbGFzcz1cInN1aS10YWJzLWZsdXNoZWRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0PlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxGb250U2V0dGluZ3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlPVwidXBsb2FkLW11bHRpcGxlLXBhbmVsXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1VwbG9hZCBQYW5lbCcgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJlZml4PVwidXBsb2FkLW11bHRpcGxlLXBhbmVsXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0U2l6ZT1cIjEzXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Rm9udD1cImN1c3RvbVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdEN1c3RvbT1cImluaGVyaXRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRXZWlnaHQ9XCI0MDBcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxGb250U2V0dGluZ3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlPVwidXBsb2FkLW11bHRpcGxlLWZpbGUtbmFtZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdGaWxlIE5hbWUnICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByZWZpeD1cInVwbG9hZC1tdWx0aXBsZS1maWxlLW5hbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRTaXplPVwiMTNcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRGb250PVwiY3VzdG9tXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Q3VzdG9tPVwiaW5oZXJpdFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFdlaWdodD1cIjUwMFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PEZvbnRTZXR0aW5nc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWU9XCJ1cGxvYWQtbXVsdGlwbGUtZmlsZS1zaXplXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0ZpbGUgU2l6ZScgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJlZml4PVwidXBsb2FkLW11bHRpcGxlLWZpbGUtc2l6ZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFNpemU9XCIxMlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdEZvbnQ9XCJjdXN0b21cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRDdXN0b209XCJpbmhlcml0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0V2VpZ2h0PVwiNTAwXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdFx0XHRcdFx0PC9UYWJzPlxuXG5cdFx0XHRcdFx0XHRcdFx0PC9BY2NvcmRpb24+XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR7IGhhc0VTaWduICYmXG5cdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRS1TaWduYXR1cmUgUGxhY2Vob2xkZXInICkgfVxuXHRcdFx0XHRcdFx0XHRcdD5cblxuXHRcdFx0XHRcdFx0XHRcdFx0PEZvbnRTZXR0aW5nc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwcmVmaXg9XCJjZm9ybS1lc2lnbi1wbGFjZWhvbGRlclwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRTaXplPVwiMTZcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Rm9udD1cImN1c3RvbVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRDdXN0b209XCJpbmhlcml0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFdlaWdodD1cIjQwMFwiXG5cdFx0XHRcdFx0XHRcdFx0XHQ+PC9Gb250U2V0dGluZ3M+XG5cblx0XHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHsgaGFzR3JvdXAgJiZcblx0XHRcdFx0XHRcdFx0XHQ8QWNjb3JkaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdSZXBlYXRlciBCdXR0b24nICkgfVxuXHRcdFx0XHRcdFx0XHRcdD5cblxuXHRcdFx0XHRcdFx0XHRcdFx0PEZvbnRTZXR0aW5nc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwcmVmaXg9XCJjZm9ybS1yZXBlYXRlci1idXR0b25cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0U2l6ZT1cIjEyXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdEZvbnQ9XCJSb2JvdG9cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0V2VpZ2h0PVwiNTAwXCJcblx0XHRcdFx0XHRcdFx0XHRcdD48L0ZvbnRTZXR0aW5ncz5cblxuXHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0eyBoYXNQYWdpbmF0aW9uICYmXG5cdFx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUGFnaW5hdGlvbiBCdXR0b25zJyApIH1cblx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8Rm9udFNldHRpbmdzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByZWZpeD1cImNmb3JtLXBhZ2luYXRpb24tYnV0dG9uc1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRTaXplPVwiMTRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Rm9udD1cImN1c3RvbVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRDdXN0b209XCJpbmhlcml0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFdlaWdodD1cIjUwMFwiXG5cdFx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHRcdDwvQWNjb3JkaW9uPlxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0PEFjY29yZGlvblxuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdTdWJtaXQgQnV0dG9uJyApIH1cblx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdDxGb250U2V0dGluZ3Ncblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRwcmVmaXg9XCJjZm9ybS1idXR0b25cIlxuXHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFNpemU9XCIxNFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Rm9udD1cImN1c3RvbVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0Q3VzdG9tPVwiaW5oZXJpdFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0V2VpZ2h0PVwiNTAwXCJcblx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHQ8L0FjY29yZGlvbj5cblxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHQ8L0NvbnRhaW5lcj5cblxuXHRcdFx0XHQ8L1JhZGlvVGFicz5cblxuXHRcdFx0PC9TZXR0aW5nc1Jvdz5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvZm9udHMuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZ2V0Rm9udFZhcmlhbnRzLCB0cmFuc2xhdGUsIGdldFRoZW1lUHJlZml4LCBnZXREZWZhdWx0VmFsdWUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBSb3cgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9yb3cnO1xuaW1wb3J0IENvbCBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbCc7XG5pbXBvcnQgSW5wdXQgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2lucHV0JztcbmltcG9ydCBTdWlTZWxlY3QyIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9zdWktc2VsZWN0Mic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1Rm9udFNldHRpbmdzaVNlbGVjdCBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdGJhY2t3YXJkc0NvbXBhdCggdmFyaWFudCwgdmFyaWFudHMgKSB7XG5cdFx0aWYgKCAhIF8uY29udGFpbnMoIHZhcmlhbnRzLCB2YXJpYW50ICkgKSB7XG5cdFx0XHR2YXJpYW50cy5wdXNoKCB2YXJpYW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhcmlhbnRzO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IHByZWZpeFRoZW1lID0gZ2V0VGhlbWVQcmVmaXgodGhpcy5wcm9wcyk7XG5cdFx0Y29uc3QgcHJlZml4ID0gcHJlZml4VGhlbWUgKyB0aGlzLnByb3BzLnByZWZpeDtcblxuXHRcdGNvbnN0IGRlZmF1bHRGb250ID0gJ2Jhc2ljLScgPT09IHByZWZpeFRoZW1lID8gJycgOiB0aGlzLnByb3BzLmRlZmF1bHRGb250O1xuXHRcdGNvbnN0IGZvbnQgPSAhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3NbIHByZWZpeCArICctZm9udC1mYW1pbHknIF0gKVxuXHRcdFx0PyB0aGlzLnByb3BzLnNldHRpbmdzWyBwcmVmaXggKyAnLWZvbnQtZmFtaWx5JyBdXG5cdFx0XHQ6IGRlZmF1bHRGb250XG5cdFx0XHQ7XG5cblx0XHRjb25zdCBmY3VzID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzWyBwcmVmaXggKyAnLWN1c3RvbS1mYW1pbHknIF0gKVxuXHRcdFx0PyB0aGlzLnByb3BzLnNldHRpbmdzWyBwcmVmaXggKyAnLWN1c3RvbS1mYW1pbHknIF1cblx0XHRcdDogdGhpcy5wcm9wcy5kZWZhdWx0Q3VzdG9tXG5cdFx0XHQ7XG5cblx0XHRjb25zdCBkZWZhdWx0V2VpZ2h0ID0gJ2Jhc2ljLScgPT09IHByZWZpeFRoZW1lID8gJycgOiB0aGlzLnByb3BzLmRlZmF1bHRXZWlnaHQ7XG5cdFx0Y29uc3QgdmFyaWFudCA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5nc1sgcHJlZml4ICsgJy1mb250LXdlaWdodCcgXSApXG5cdFx0XHQ/IHRoaXMucHJvcHMuc2V0dGluZ3NbIHByZWZpeCArICctZm9udC13ZWlnaHQnIF1cblx0XHRcdDogZGVmYXVsdFdlaWdodFxuXHRcdFx0O1xuXG5cdFx0Y29uc3QgZGVmYXVsdFNpemUgPSAnYmFzaWMtJyA9PT0gcHJlZml4VGhlbWUgPyAnJyA6IHRoaXMucHJvcHMuZGVmYXVsdFNpemU7XG5cdFx0Y29uc3Qgc2l6ZSA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5nc1sgcHJlZml4ICsgJy1mb250LXNpemUnIF0gKVxuXHRcdFx0PyB0aGlzLnByb3BzLnNldHRpbmdzWyBwcmVmaXggKyAnLWZvbnQtc2l6ZScgXVxuXHRcdFx0OiBkZWZhdWx0U2l6ZVxuXHRcdFx0O1xuXG5cdFx0Y29uc3QgZm9udFZhcmlhbnRzID0gZ2V0Rm9udFZhcmlhbnRzKCBmb250LCB3aW5kb3cuZm9ybWluYXRvckZvbnRzICk7XG5cblx0XHRjb25zdCB2YXJpYW50cyA9IHRoaXMuYmFja3dhcmRzQ29tcGF0KCB2YXJpYW50LCBmb250VmFyaWFudHMgKTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdDxSb3c+XG5cdFx0XHRcdFx0PENvbCBjb2xzPVwiMTJcIj5cblx0XHRcdFx0XHRcdDxTdWlTZWxlY3QyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRm9udCBGYW1pbHknICkgfVxuXHRcdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj17IHRyYW5zbGF0ZSggJ1JvYm90bycgKSB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgcHJlZml4IH0tZm9udC1mYW1pbHlgfVxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgZm9udCkgfWB9XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdHsgXy5tYXAoIHdpbmRvdy5mb3JtaW5hdG9yRm9udHMsICggZm9udERhdGEgKSA9PiAoXG5cdFx0XHRcdFx0XHRcdFx0PG9wdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWU9eyBmb250RGF0YS5mYW1pbHkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0a2V5PXsgZm9udERhdGEuZmFtaWx5IH1cblx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHR7IGZvbnREYXRhLmZhbWlseSB9XG5cdFx0XHRcdFx0XHRcdFx0PC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdCkgKSB9XG5cdFx0XHRcdFx0XHRcdDxvcHRpb25cblx0XHRcdFx0XHRcdFx0XHR2YWx1ZT1cIlwiXG5cdFx0XHRcdFx0XHRcdFx0a2V5PVwiaW5oZXJpdFwiXG5cdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ2luaGVyaXQnICkgfVxuXHRcdFx0XHRcdFx0XHQ8L29wdGlvbj5cblx0XHRcdFx0XHRcdFx0PG9wdGlvblxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlPVwiY3VzdG9tXCJcblx0XHRcdFx0XHRcdFx0XHRrZXk9XCJjdXN0b21cIlxuXHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdDdXN0b20gdXNlciBmb250JyApIH1cblx0XHRcdFx0XHRcdFx0PC9vcHRpb24+XG5cdFx0XHRcdFx0XHQ8L1N1aVNlbGVjdDI+XG5cdFx0XHRcdFx0XHR7IGZvbnQgPT09ICdjdXN0b20nICYmXG5cdFx0XHRcdFx0XHRcdDxJbnB1dFxuXHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0dHlwZT1cInRleHRcIlxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PXtgJHsgcHJlZml4IH0tY3VzdG9tLWZhbWlseWB9XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIGZjdXMpIH1gfVxuXHRcdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPXsgdHJhbnNsYXRlKCAnRS5nLiwgQXJpYWwsIHNhbnMtc2VyaWYnICkgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQ3VzdG9tIGZvbnQgZmFtaWx5JyApIH1cblx0XHRcdFx0XHRcdFx0XHRwcmVmaXg9XCJcIlxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdDwvQ29sPlxuXHRcdFx0XHQ8L1Jvdz5cblxuXHRcdFx0XHR7ICEgdGhpcy5wcm9wcy5mYW1pbHlPbmx5ICYmXG5cdFx0XHRcdFx0PFJvdz5cblx0XHRcdFx0XHRcdDxDb2wgY29scz1cIjZcIj5cblx0XHRcdFx0XHRcdFx0PElucHV0XG5cdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHR0eXBlPVwibnVtYmVyXCJcblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IHByZWZpeCB9LWZvbnQtc2l6ZWB9XG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdFZhbHVlPXtgJHsgZ2V0RGVmYXVsdFZhbHVlKHRoaXMucHJvcHMsIHNpemUpIH1gfVxuXHRcdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPXsgdHJhbnNsYXRlKCAnRS5nLiwgMTYnICkgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRm9udCBTaXplJyApIH1cblx0XHRcdFx0XHRcdFx0XHRub3RlPVwiaW4gcHhcIlxuXHRcdFx0XHRcdFx0XHRcdHByZWZpeD1cIlwiXG5cdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHQ8L0NvbD5cblx0XHRcdFx0XHRcdDxDb2wgY29scz1cIjZcIj5cblx0XHRcdFx0XHRcdFx0PFN1aVNlbGVjdDJcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRm9udCBXZWlnaHQnICkgfVxuXHRcdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPXsgdHJhbnNsYXRlKCAnU2VsZWN0IGZvbnQgd2VpZ2h0JyApIH1cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT17YCR7IHByZWZpeCB9LWZvbnQtd2VpZ2h0YH1cblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9e2AkeyBnZXREZWZhdWx0VmFsdWUodGhpcy5wcm9wcywgdmFyaWFudCkgfWB9XG5cdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHQ8b3B0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZT1cIlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRrZXk9XCJpbmhlcml0XCJcblx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ2luaGVyaXQnICkgfVxuXHRcdFx0XHRcdFx0XHRcdDwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0XHRcdHsgXy5tYXAoIHZhcmlhbnRzLCAoIGZvbnRWYXJpYW50ICkgPT4gKFxuXHRcdFx0XHRcdFx0XHRcdFx0PG9wdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZT17IGZvbnRWYXJpYW50IH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5PXsgZm9udFZhcmlhbnQgfVxuXHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGZvbnRWYXJpYW50IH1cblx0XHRcdFx0XHRcdFx0XHRcdDwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0XHRcdCkgKSB9XG5cdFx0XHRcdFx0XHRcdDwvU3VpU2VsZWN0Mj5cblx0XHRcdFx0XHRcdDwvQ29sPlxuXHRcdFx0XHRcdDwvUm93PlxuXHRcdFx0XHR9XG5cdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvc2V0dGluZ3MvZm9udHMuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgRW1wdHkgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9lbXB0eSc7XG5pbXBvcnQgUGFkZGluZ0N1c3RvbSBmcm9tICcuL2Zvcm0tY29udGFpbmVyL3BhZGRpbmctY3VzdG9tJztcbmltcG9ydCBCb3JkZXJDdXN0b20gZnJvbSAnLi9mb3JtLWNvbnRhaW5lci9ib3JkZXItY3VzdG9tJztcbmltcG9ydCBTcGFjaW5nQ3VzdG9tIGZyb20gJy4vZm9ybS1jb250YWluZXIvc3BhY2luZy1jdXN0b20nO1xuaW1wb3J0IFJhZGlvVGFicyBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvcmFkaW8tdGFicyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvcm1Db250YWluZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1yb3dcIj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3MtY29sLTFcIj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktc2V0dGluZ3MtbGFiZWxcIj57IHRyYW5zbGF0ZSggJ0Zvcm0gQ29udGFpbmVyJyApIH08L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCI+XG5cdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggXCJDdXN0b21pemUgdGhlIGZvcm0gY29udGFpbmVyJ3MgcGFkZGluZyBhbmQgYm9yZGVyLlwiICkgfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0yXCI+XG5cblx0XHRcdFx0XHQ8UmFkaW9UYWJzXG5cdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0cHJvcGVydHk9XCJmb3JtLXBhZGRpbmdcIlxuXHRcdFx0XHRcdFx0c2V0dGluZ3NMYWJlbD17IHRyYW5zbGF0ZSggJ1BhZGRpbmcnICkgfVxuXHRcdFx0XHRcdFx0ZGVzY3JpcHRpb249eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdCdCeSBkZWZhdWx0IHRoZSBmb3JtIHdpbGwgZmlsbCB0aGUgYXZhaWxhYmxlICcgK1xuXHRcdFx0XHRcdFx0XHQnc3BhY2Ugd2hlcmUgeW91IGluc2VydCBpdC4gWW91IGNhbiBhZGQgc29tZSAnICtcblx0XHRcdFx0XHRcdFx0J3BhZGRpbmcgaGVyZSB0byBiZXR0ZXIgc3VpdCB5b3VyIHRoZW1lLidcblx0XHRcdFx0XHRcdCkgfT5cblx0XHRcdFx0XHRcdDxFbXB0eSB2YWx1ZT1cIlwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ05vbmUnICkgfVxuXHRcdFx0XHRcdFx0PC9FbXB0eT5cblx0XHRcdFx0XHRcdDxQYWRkaW5nQ3VzdG9tIHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdHZhbHVlPVwiY3VzdG9tXCJcblx0XHRcdFx0XHRcdFx0Ym94Q2xhc3M9XCJzdWktdGFiLWJveGVkXCI+XG5cdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnQ3VzdG9tJyApIH1cblx0XHRcdFx0XHRcdDwvUGFkZGluZ0N1c3RvbT5cblx0XHRcdFx0XHQ8L1JhZGlvVGFicz5cblxuXHRcdFx0XHRcdDxSYWRpb1RhYnNcblx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eT1cImZvcm0tYm9yZGVyXCJcblx0XHRcdFx0XHRcdHNldHRpbmdzTGFiZWw9eyB0cmFuc2xhdGUoICdCb3JkZXInICkgfVxuXHRcdFx0XHRcdFx0ZGVzY3JpcHRpb249eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdCdBZGQgYW4gb3B0aW9uYWwgYm9yZGVyIGFyb3VuZCB0aGUgZm9ybS4nXG5cdFx0XHRcdFx0XHQpIH0+XG5cdFx0XHRcdFx0XHQ8RW1wdHkgdmFsdWU9XCJcIj5cblx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdOb25lJyApIH1cblx0XHRcdFx0XHRcdDwvRW1wdHk+XG5cdFx0XHRcdFx0XHQ8Qm9yZGVyQ3VzdG9tIHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdHZhbHVlPVwiY3VzdG9tXCJcblx0XHRcdFx0XHRcdFx0Ym94Q2xhc3M9XCJzdWktdGFiLWJveGVkXCI+XG5cdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnQ3VzdG9tJyApIH1cblx0XHRcdFx0XHRcdDwvQm9yZGVyQ3VzdG9tPlxuXHRcdFx0XHRcdDwvUmFkaW9UYWJzPlxuXG5cdFx0XHRcdFx0PFJhZGlvVGFic1xuXHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdHByb3BlcnR5PVwiZmllbGRzLXN0eWxlXCJcblx0XHRcdFx0XHRcdHNldHRpbmdzTGFiZWw9eyB0cmFuc2xhdGUoICdTcGFjaW5nJyApIH1cblx0XHRcdFx0XHRcdGRlZmF1bHQ9XCJvcGVuXCJcblx0XHRcdFx0XHRcdGRlc2NyaXB0aW9uPXsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHQnQ2hvb3NlIGhvdyBtdWNoIHNwYWNpbmcgeW91IHdhbnQgYmV0d2VlbiBlYWNoIGZvcm0gZmllbGQuJ1xuXHRcdFx0XHRcdFx0KSB9PlxuXHRcdFx0XHRcdFx0PEVtcHR5IHZhbHVlPVwib3BlblwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0NvbWZvcnRhYmxlJyApIH1cblx0XHRcdFx0XHRcdDwvRW1wdHk+XG5cdFx0XHRcdFx0XHQ8RW1wdHkgdmFsdWU9XCJlbmNsb3NlZFwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0NvbXBhY3QnICkgfVxuXHRcdFx0XHRcdFx0PC9FbXB0eT5cblx0XHRcdFx0XHRcdDxTcGFjaW5nQ3VzdG9tXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdHZhbHVlPVwiY3VzdG9tXCJcblx0XHRcdFx0XHRcdFx0Ym94Q2xhc3M9XCJzdWktdGFiLWJveGVkXCJcblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdDdXN0b20nICkgfVxuXHRcdFx0XHRcdFx0PC9TcGFjaW5nQ3VzdG9tPlxuXHRcdFx0XHRcdDwvUmFkaW9UYWJzPlxuXG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvZm9ybS1jb250YWluZXIuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdHJhbnNsYXRlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMnO1xuXG5pbXBvcnQgQ29sIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvY29sJztcbmltcG9ydCBJbnB1dCBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvaW5wdXQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBwYWRkaW5nQ3VzdG9tIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLXJvd1wiXG5cdFx0XHRcdFx0c3R5bGU9eyB7IG1hcmdpbkJvdHRvbTogJzEwcHgnIH0gfT5cblx0XHRcdFx0XHQ8Q29sIGNvbHM9XCIzXCI+XG5cdFx0XHRcdFx0XHQ8SW5wdXRcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdUb3AnICkgfVxuXHRcdFx0XHRcdFx0XHR0eXBlPVwibnVtYmVyXCJcblx0XHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9XCIwXCJcblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJmb3JtLXBhZGRpbmctdG9wXCJcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9Db2w+XG5cdFx0XHRcdFx0PENvbCBjb2xzPVwiM1wiPlxuXHRcdFx0XHRcdFx0PElucHV0XG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQm90dG9tJyApIH1cblx0XHRcdFx0XHRcdFx0dHlwZT1cIm51bWJlclwiXG5cdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPVwiMFwiXG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwiZm9ybS1wYWRkaW5nLWJvdHRvbVwiXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDwvQ29sPlxuXHRcdFx0XHRcdDxDb2wgY29scz1cIjNcIj5cblx0XHRcdFx0XHRcdDxJbnB1dFxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0xlZnQnICkgfVxuXHRcdFx0XHRcdFx0XHR0eXBlPVwibnVtYmVyXCJcblx0XHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9XCIwXCJcblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJmb3JtLXBhZGRpbmctbGVmdFwiXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDwvQ29sPlxuXHRcdFx0XHRcdDxDb2wgY29scz1cIjNcIj5cblx0XHRcdFx0XHRcdDxJbnB1dFxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1JpZ2h0JyApIH1cblx0XHRcdFx0XHRcdFx0dHlwZT1cIm51bWJlclwiXG5cdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPVwiMFwiXG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwiZm9ybS1wYWRkaW5nLXJpZ2h0XCJcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9Db2w+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPlxuXHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnU2V0IHlvdXIgY3VzdG9tIHBhZGRpbmcgaW4gcGl4ZWxzLicgKSB9XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2Zvcm0tY29udGFpbmVyL3BhZGRpbmctY3VzdG9tLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IFJvdyBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL3Jvdyc7XG5pbXBvcnQgQ29sIGZyb20gJy4uLy4uLy4uLy4uL3NldHRpbmdzL2NvbnRhaW5lcnMvY29sJztcbmltcG9ydCBJbnB1dCBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvaW5wdXQnO1xuaW1wb3J0IFN1aVNlbGVjdDIgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL3N1aS1zZWxlY3QyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgYm9yZGVyQ3VzdG9tIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLXJvd1wiXG5cdFx0XHRcdFx0c3R5bGU9eyB7IG1hcmdpbkJvdHRvbTogJzEwcHgnIH0gfT5cblx0XHRcdFx0XHQ8Q29sIGNvbHM9XCI0XCI+XG5cdFx0XHRcdFx0XHQ8SW5wdXRcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdSYWRpdXMnICkgfVxuXHRcdFx0XHRcdFx0XHRub3RlPXsgdHJhbnNsYXRlKCAnaW4gcHgnICkgfVxuXHRcdFx0XHRcdFx0XHR0eXBlPVwibnVtYmVyXCJcblx0XHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9XCIwXCJcblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJmb3JtLWJvcmRlci1yYWRpdXNcIlxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8L0NvbD5cblx0XHRcdFx0XHQ8Q29sIGNvbHM9XCI0XCI+XG5cdFx0XHRcdFx0XHQ8SW5wdXRcblx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdUaGlja25lc3MnICkgfVxuXHRcdFx0XHRcdFx0XHRub3RlPXsgdHJhbnNsYXRlKCAnaW4gcHgnICkgfVxuXHRcdFx0XHRcdFx0XHR0eXBlPVwibnVtYmVyXCJcblx0XHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9XCIwXCJcblx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJmb3JtLWJvcmRlci13aWR0aFwiXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdDwvQ29sPlxuXHRcdFx0XHRcdDxDb2wgY29scz1cIjRcIj5cblx0XHRcdFx0XHRcdDxTdWlTZWxlY3QyXG5cdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwiZm9ybS1ib3JkZXItc3R5bGVcIlxuXHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1N0eWxlJyApIH1cblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cInNvbGlkXCI+XG5cdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdTb2xpZCcgKSB9XG5cdFx0XHRcdFx0XHRcdDwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiZGFzaGVkXCI+XG5cdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdEYXNoZWQnICkgfVxuXHRcdFx0XHRcdFx0XHQ8L29wdGlvbj5cblx0XHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cImRvdHRlZFwiPlxuXHRcdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnRG90dGVkJyApIH1cblx0XHRcdFx0XHRcdFx0PC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJub25lXCI+XG5cdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdOb25lJyApIH1cblx0XHRcdFx0XHRcdFx0PC9vcHRpb24+XG5cdFx0XHRcdFx0XHQ8L1N1aVNlbGVjdDI+XG5cdFx0XHRcdFx0PC9Db2w+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHQnTm90ZTogU2V0IHRoZSBjb2xvciBvZiB0aGUgYm9yZGVyIGluIHRoZSBDb2xvcnMgc2V0dGluZ3MgYXJlYSBhYm92ZS4nXG5cdFx0XHRcdCkgfTwvc3Bhbj5cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2Zvcm0tY29udGFpbmVyL2JvcmRlci1jdXN0b20uanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgSW5wdXQgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2lucHV0JztcblxuaW1wb3J0IHsgdHJhbnNsYXRlLCBnZXRUaGVtZVByZWZpeCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mgc3BhY2luZ0N1c3RvbSBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PElucHV0XG5cdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnU3BhY2luZycgKSB9XG5cdFx0XHRcdG5vdGU9eyB0cmFuc2xhdGUoICdpbiBwaXhlbHMnICkgfVxuXHRcdFx0XHR0eXBlPVwibnVtYmVyXCJcblx0XHRcdFx0cGxhY2Vob2xkZXI9eyB0cmFuc2xhdGUoICcwJyApIH1cblx0XHRcdFx0cHJvcGVydHk9e2AkeyBnZXRUaGVtZVByZWZpeCh0aGlzLnByb3BzKSB9c3BhY2luZ2B9XG5cdFx0XHQvPlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9mb3JtLWNvbnRhaW5lci9zcGFjaW5nLWN1c3RvbS5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBUb2dnbGUgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL3RvZ2dsZSc7XG5pbXBvcnQgQWNlRWRpdG9yIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9hY2UtZWRpdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3VzdG9tQ3NzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3Mtcm93XCI+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMVwiPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1zZXR0aW5ncy1sYWJlbFwiPnsgdHJhbnNsYXRlKCAnQ3VzdG9tIENTUycgKSB9PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPlxuXHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdGb3IgbW9yZSBhZHZhbmNlZCBjdXN0b21pemF0aW9uIG9wdGlvbnMgdXNlIGN1c3RvbSBDU1MuJyApIH1cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMlwiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGRcIj5cblx0XHRcdFx0XHRcdDxkaXYgc3R5bGU9eyB7IG1hcmdpbkJvdHRvbTogJzEwcHgnIH0gfT5cblx0XHRcdFx0XHRcdFx0PFRvZ2dsZSB7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRW5hYmxlIGN1c3RvbSBDU1MnICkgfVxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwidXNlLWN1c3RvbS1jc3NcIlxuXHRcdFx0XHRcdFx0XHRcdHVuV3JhcFxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHR7ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5nc1sgJ3VzZS1jdXN0b20tY3NzJyBdICkgJiYgdGhpcy5wcm9wcy5zZXR0aW5nc1sgJ3VzZS1jdXN0b20tY3NzJyBdICYmXG5cdFx0XHRcdFx0XHRcdDxBY2VFZGl0b3Jcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwiY3VzdG9tX2Nzc1wiXG5cdFx0XHRcdFx0XHRcdFx0dHlwZT1cImZvcm1cIlxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jdXN0b20tY3NzLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzJztcbmltcG9ydCBTdWlTZWxlY3QyIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9zdWktc2VsZWN0Mic7XG5pbXBvcnQgVG9nZ2xlIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy90b2dnbGUnO1xuaW1wb3J0IENvbCBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbCc7XG5pbXBvcnQgSW5wdXQgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2lucHV0JztcbmltcG9ydCBQYWdlTWFyZ2luIGZyb20gJy4vcGRmL3BhZ2UtbWFyZ2luJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFnZVNldHRpbmdzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRyb2xlPVwiYWxlcnRcIlxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1ub3RpY2Ugc3VpLW5vdGljZS1ibHVlIHN1aS1hY3RpdmVcIlxuXHRcdFx0XHRcdGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiXG5cdFx0XHRcdFx0c3R5bGU9eyB7IGRpc3BsYXk6ICdibG9jaycgfSB9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ub3RpY2UtY29udGVudFwiPlxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktbm90aWNlLW1lc3NhZ2VcIj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLW5vdGljZS1pY29uIHN1aS1pY29uLWluZm9cIiBhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuXHRcdFx0XHRcdFx0XHQ8cD57IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0XHQnT3VyIFBERiBidWlsZGVyIGlzIGNvbnN0YW50bHkgaW1wcm92aW5nIGFuZCB3ZeKAmWxsIGJlIGFkZGluZyBtb3JlIGZlYXR1cmVzIG92ZXIgdGltZS4gJyArXG5cdFx0XHRcdFx0XHRcdFx0J1doaWxlIHRoZSBjdXJyZW50IHJlbGVhc2UgaGFzIGxpbWl0ZWQgY3VzdG9taXphdGlvbiBvcHRpb25zLCAnICtcblx0XHRcdFx0XHRcdFx0XHQnd2UgYXBwcmVjaWF0ZSB5b3VyIHBhdGllbmNlIGFzIHdlIHdvcmsgdG8gYnJpbmcgeW91IHRoZSBiZXN0IGV4cGVyaWVuY2UgcG9zc2libGUuICcgK1xuXHRcdFx0XHRcdFx0XHRcdCdLZWVwIGFuIGV5ZSBvdXQgZm9yIHVwZGF0ZXMuIFRvIG1hbnVhbGx5IGFkanVzdCB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgZmllbGRzLCAnICtcblx0XHRcdFx0XHRcdFx0XHQneW91IGNhbiBlbmFibGUgdGhlIEN1c3RvbSBDU1Mgb3B0aW9uIGJlbG93Lidcblx0XHRcdFx0XHRcdFx0KSB9PC9wPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtc2V0dGluZ3Mtcm93XCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktYm94LXNldHRpbmdzLWNvbC0xXCI+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktc2V0dGluZ3MtbGFiZWxcIj57IHRyYW5zbGF0ZSggJ1BhZ2Ugc2V0dGluZ3MnICkgfTwvc3Bhbj5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvblwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0NvbmZpZ3VyZSB0aGUgUERGIGZpbGUgc2V0dGluZ3MnICkgfVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMlwiPlxuXHRcdFx0XHRcdFx0PGxhYmVsIGNsYXNzTmFtZT1cInN1aS1zZXR0aW5ncy1sYWJlbFwiPlxuXHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ1BhZ2Ugc2l6ZScgKSB9XG5cdFx0XHRcdFx0XHQ8L2xhYmVsPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCIgc3R5bGU9eyB7IG1hcmdpbkJvdHRvbTogJzEwcHgnIH0gfT5cblx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdFx0J0Nob29zZSB0aGUgc3RhbmRhcmQgcGFwZXIgc2l6ZSBmb3IgeW91ciBQREYgZG9jdW1lbnQuICcgK1xuXHRcdFx0XHRcdFx0XHRcdCdUaGUgZGVmYXVsdCByZXNvbHV0aW9uIGZvciBlYWNoIHBhZ2UgaXMgc2V0IGF0IDk2ZHBpLidcblx0XHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8U3VpU2VsZWN0MlxuXHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cInBhcGVyX3NpemVcIlxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9XCJBNFwiXG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdHsgXy5tYXAoIGZvcm1pbmF0b3JEYXRhLnBkZl9wYWdlX3NpemVzLCAoIHNpemUsIGtleSApID0+IChcblx0XHRcdFx0XHRcdFx0XHRcdDxvcHRpb24ga2V5PXsga2V5IH0gdmFsdWU9eyBrZXkgfT57IHNpemUgfTwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0XHQpICkgfVxuXHRcdFx0XHRcdFx0PC9TdWlTZWxlY3QyPlxuXG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1mb3JtLWZpZWxkXCI+XG5cdFx0XHRcdFx0XHRcdDxUb2dnbGUgeyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0VuYWJsZSBSVEwgKHJpZ2h0LXRvLWxlZnQpJyApIH1cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cImVuYWJsZV9ydGxcIlxuXHRcdFx0XHRcdFx0XHRcdHVuV3JhcFxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHRcdDxoci8+XG5cblx0XHRcdFx0XHRcdDxQYWdlTWFyZ2luIHsgLi4udGhpcy5wcm9wcyB9IC8+XG5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9wYWdlLXNldHRpbmdzLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IENvbCBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbCc7XG5pbXBvcnQgSW5wdXQgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL2lucHV0JztcbmltcG9ydCBSYWRpb1RhYnMgZnJvbSAnLi4vLi4vLi4vLi4vc2V0dGluZ3MvaW5wdXRzL3JhZGlvLXRhYnMnO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9jb250YWluZXJzL2NvbnRhaW5lcic7XG5pbXBvcnQgU3VpU2VsZWN0MiBmcm9tICcuLi8uLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvc3VpLXNlbGVjdDInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBwYWdlTWFyZ2luIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8UmFkaW9UYWJzXG5cdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdHByb3BlcnR5PVwicGRmX21hcmdpblwiXG5cdFx0XHRcdGRpdkNsYXNzPVwicGRmLXBhZ2UtbWFyZ2luXCJcblx0XHRcdFx0c2V0dGluZ3NMYWJlbD17IHRyYW5zbGF0ZSggJ1BhZ2UgTWFyZ2luJyApIH1cblx0XHRcdFx0ZGVmYXVsdD1cImRlZmF1bHRcIlxuXHRcdFx0XHRkZXNjcmlwdGlvbj17IHRyYW5zbGF0ZShcblx0XHRcdFx0XHQnRGVmYXVsdCBtYXJnaW4gZm9yIGFsbCBwYXBlciBzaXplcyBpcyAzMHB4LiAnICtcblx0XHRcdFx0XHQnVXNlIHRoZSBjdXN0b20gdGFiIHRvIHNldCBhIGRpZmZlcmVudCB2YWx1ZS4nXG5cdFx0XHRcdCkgfVxuXHRcdFx0PlxuXHRcdFx0XHQ8Q29udGFpbmVyIHZhbHVlPVwiZGVmYXVsdFwiIGxhYmVsPXsgdHJhbnNsYXRlKCAnRGVmYXVsdCcpIH0vPlxuXHRcdFx0XHQ8Q29udGFpbmVyXG5cdFx0XHRcdFx0dmFsdWU9XCJjdXN0b21cIlxuXHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQ3VzdG9tJyl9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3JkZXItZnJhbWVcIj5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLXJvd1wiXG5cdFx0XHRcdFx0XHRcdHN0eWxlPXsgeyBtYXJnaW5Cb3R0b206ICcxMHB4JyB9IH0+XG5cdFx0XHRcdFx0XHRcdDxDb2wgY29scz1cIjEyXCI+XG5cdFx0XHRcdFx0XHRcdFx0PFN1aVNlbGVjdDJcblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ01hcmdpbicgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cInBkZl9tYXJnaW5fdW5pdFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZENsYXNzPVwiZnVpLXNlbGVjdC1pbmxpbmVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzaXplPVwiMTAwXCJcblx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwicHRcIj5wdDwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT1cInB4XCI+cHg8L29wdGlvbj5cblx0XHRcdFx0XHRcdFx0XHRcdDxvcHRpb24gdmFsdWU9XCJtbVwiPm1tPC9vcHRpb24+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPVwiaW5cIj5pbjwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0XHRcdDwvU3VpU2VsZWN0Mj5cblx0XHRcdFx0XHRcdFx0PC9Db2w+XG5cdFx0XHRcdFx0XHRcdDxDb2wgY29scz1cIjNcIj5cblx0XHRcdFx0XHRcdFx0XHQ8SW5wdXRcblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1RvcCcgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlPVwibnVtYmVyXCJcblx0XHRcdFx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPVwiMFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cInBkZl9tYXJnaW5fdG9wXCJcblx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHQ8L0NvbD5cblx0XHRcdFx0XHRcdFx0PENvbCBjb2xzPVwiM1wiPlxuXHRcdFx0XHRcdFx0XHRcdDxJbnB1dFxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQm90dG9tJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdHR5cGU9XCJudW1iZXJcIlxuXHRcdFx0XHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9XCIwXCJcblx0XHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwicGRmX21hcmdpbl9ib3R0b21cIlxuXHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdDwvQ29sPlxuXHRcdFx0XHRcdFx0XHQ8Q29sIGNvbHM9XCIzXCI+XG5cdFx0XHRcdFx0XHRcdFx0PElucHV0XG5cdFx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdMZWZ0JyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdHR5cGU9XCJudW1iZXJcIlxuXHRcdFx0XHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9XCIwXCJcblx0XHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwicGRmX21hcmdpbl9sZWZ0XCJcblx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHQ8L0NvbD5cblx0XHRcdFx0XHRcdFx0PENvbCBjb2xzPVwiM1wiPlxuXHRcdFx0XHRcdFx0XHRcdDxJbnB1dFxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUmlnaHQnICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZT1cIm51bWJlclwiXG5cdFx0XHRcdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj1cIjBcIlxuXHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJwZGZfbWFyZ2luX3JpZ2h0XCJcblx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHQ8L0NvbD5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L0NvbnRhaW5lcj5cblx0XHRcdDwvUmFkaW9UYWJzPlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9wZGYvcGFnZS1tYXJnaW4uanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWlUYWdzIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHRcdHRoaXMuaGFuZGxlQ2hhbmdlID0gdGhpcy5oYW5kbGVDaGFuZ2UuYmluZCggdGhpcyApO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0Y29uc3QgdmFsdWUgPSBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF0gKVxuXHRcdFx0PyBbXVxuXHRcdFx0OiB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF07XG5cblx0XHR0aGlzLiRlbCA9IGpRdWVyeSggdGhpcy5lbCApO1xuXHRcdGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKFxuXHRcdFx0eyBhbGxvd0NsZWFyOiB0cnVlLCBkcm9wZG93bkNzc0NsYXNzOiAnc3VpLXNlbGVjdC1kcm9wZG93bicgfSxcblx0XHRcdHRoaXMucHJvcHMub3B0aW9uc1xuXHRcdCk7XG5cblx0XHRpZiAoIHR5cGVvZiB0aGlzLiRlbC5TVUlzZWxlY3QyID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0dGhpcy4kZWwuU1VJc2VsZWN0Miggb3B0aW9ucyApO1xuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB0aGlzLiRlbC5GVUlzZWxlY3QyID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0dGhpcy4kZWwuRlVJc2VsZWN0Miggb3B0aW9ucyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLmxvZyggJ3NlbGVjdDIgbm90IGludGlhdGVkJyApO1xuXHRcdH1cblxuXHRcdHRoaXMuJGVsLm9uKCAnY2hhbmdlLnNlbGVjdDInLCB0aGlzLmhhbmRsZUNoYW5nZSApO1xuXG5cdFx0aWYgKFxuXHRcdFx0ISBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzLnBlcm1pc3Npb25fdHlwZSApICYmXG5cdFx0XHQoXG5cdFx0XHRcdCdzcGVjaWZpYycgPT09IHRoaXMucHJvcHMuc2V0dGluZ3MucGVybWlzc2lvbl90eXBlIHx8XG5cdFx0XHRcdCEgXy5pc1VuZGVmaW5lZCggdGhpcy5wcm9wcy5zZXR0aW5ncy51c2VyX2luZm8gKVxuXHRcdFx0KVxuXHRcdCkge1xuXHRcdFx0Y29uc3QgdXNlckluZm9zID0gdGhpcy5wcm9wcy5zZXR0aW5ncy51c2VyX2luZm87XG5cblx0XHRcdC8vIGluaXRpYWwgdmFsdWVzIGFwcGVuZFxuXHRcdFx0Xy5lYWNoKCB2YWx1ZSwgZnVuY3Rpb24oIG9wdGlvbiApIHtcblx0XHRcdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIHVzZXJJbmZvc1sgb3B0aW9uIF0gKSApIHtcblx0XHRcdFx0XHRzZWxmLiRlbC5hcHBlbmQoIGpRdWVyeSggJzxvcHRpb24gdmFsdWU9XCInICsgb3B0aW9uICsgJ1wiPicgK1xuXHRcdFx0XHRcdHVzZXJJbmZvc1sgb3B0aW9uIF0uZW1haWwgK1xuXHRcdFx0XHRcdCc8L29wdGlvbj4nICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gaW5pdGlhbCB2YWx1ZXMgYXBwZW5kXG5cdFx0XHRfLmVhY2goIHZhbHVlLCBmdW5jdGlvbiggb3B0aW9uICkge1xuXHRcdFx0XHRzZWxmLiRlbC5hcHBlbmQoIGpRdWVyeSggJzxvcHRpb24gdmFsdWU9XCInICsgb3B0aW9uICsgJ1wiPicgKyBvcHRpb24gKyAnPC9vcHRpb24+JyApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gaW5pdGlhbCB2YWx1ZXMgb24gbW91bnRcblx0XHR0aGlzLiRlbC52YWwoIHZhbHVlICkudHJpZ2dlciggJ2NoYW5nZS5zZWxlY3QyJyApO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkVXBkYXRlKCBwcmV2UHJvcHMsIHByZXZTdGF0ZSApIHtcblx0XHRpZiAoXG5cdFx0XHQhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMuc2V0dGluZ3MudXNlcl9yb2xlICkgJiZcblx0XHRcdHByZXZQcm9wcy5zZXR0aW5ncy51c2VyX3JvbGUgIT09IHRoaXMucHJvcHMuc2V0dGluZ3MudXNlcl9yb2xlXG5cdFx0KSB7XG5cdFx0XHR0aGlzLiRlbC52YWwoIFtdICkudHJpZ2dlciggJ2NoYW5nZS5zZWxlY3QyJyApO1xuXHRcdH1cblx0fVxuXG5cdGhhbmRsZUNoYW5nZSggZSApIHtcblx0XHRjb25zdCB2YWx1ZSA9IGpRdWVyeSggZS50YXJnZXQgKS52YWwoKTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIG9uIGZpZWxkIHNldHRpbmdzXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5wcm9wcy51cGRhdGVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdC8vIFVwZGF0ZSBmaWVsZCBzdGF0ZVxuXHRcdFx0dGhpcy5wcm9wcy51cGRhdGVQcm9wZXJ0eSggdGhpcy5wcm9wcy5wcm9wZXJ0eSwgdmFsdWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVXBkYXRlIHN0b3JlXG5cdFx0XHR0aGlzLnByb3BzLmFjdGlvbnMuc2V0dGluZ3NBY3Rpb25zLnVwZGF0ZVNldHRpbmcoIHRoaXMucHJvcHMucHJvcGVydHksIHZhbHVlICk7XG5cdFx0fVxuXHR9XG5cblx0Y29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0dGhpcy4kZWwub2ZmKCAnY2hhbmdlJywgdGhpcy5oYW5kbGVDaGFuZ2UgKTtcblx0XHR0aGlzLiRlbC51bmJpbmQoKS5yZW1vdmVEYXRhKCk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF0gKVxuXHRcdFx0PyBbXVxuXHRcdFx0OiB0aGlzLnByb3BzLnNldHRpbmdzWyB0aGlzLnByb3BzLnByb3BlcnR5IF07XG5cblx0XHRsZXQgZmllbGRMYWJlbCA9ICcnO1xuXG5cdFx0aWYgKCB0aGlzLnByb3BzLmxhYmVsICkge1xuXHRcdFx0ZmllbGRMYWJlbCA9IChcblx0XHRcdFx0PGxhYmVsIGh0bWxGb3I9eyBgZm9ybWluYXRvci1maWVsZC0keyB0aGlzLnByb3BzLnByb3BlcnR5IH1gIH0gY2xhc3NOYW1lPVwic3VpLWxhYmVsXCI+XG5cdFx0XHRcdFx0e3RoaXMucHJvcHMubGFiZWx9XG5cdFx0XHRcdFx0e3RoaXMucHJvcHMubm90ZSAmJiA8c3BhbiBjbGFzc05hbWU9XCJzdWktbGFiZWwtbm90ZVwiPnt0aGlzLnByb3BzLm5vdGV9PC9zcGFuPn1cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWZvcm0tZmllbGRcIiBzdHlsZT17IHRoaXMucHJvcHMuc3R5bGUgfT5cblx0XHRcdFx0e2ZpZWxkTGFiZWx9XG5cblx0XHRcdFx0PHNlbGVjdFxuXHRcdFx0XHRcdHJlZj17IGVsID0+ICggdGhpcy5lbCA9IGVsICkgfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1zZWxlY3RcIlxuXHRcdFx0XHRcdGRlZmF1bHRWYWx1ZT17IHZhbHVlIH1cblx0XHRcdFx0XHRtdWx0aXBsZT1cIm11bHRpcGxlXCJcblx0XHRcdFx0PlxuXHRcdFx0XHRcdHt0aGlzLnByb3BzLmNoaWxkcmVufVxuXHRcdFx0XHQ8L3NlbGVjdD5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy9pbnB1dHMvc3VpLXRhZ3MuanMiLCJleHBvcnQgY29uc3Qgc2hvd01vZGFsID0gKCBtb2RhbFByb3BzLCBtb2RhbFR5cGUgKSA9PiBkaXNwYXRjaCA9PiB7XG5cdGRpc3BhdGNoKCB7XG5cdFx0dHlwZTogJ1NIT1dfTU9EQUwnLFxuXHRcdG1vZGFsUHJvcHMsXG5cdFx0bW9kYWxUeXBlLFxuXHR9ICk7XG59O1xuXG5leHBvcnQgY29uc3QgaGlkZU1vZGFsID0gKCkgPT4gZGlzcGF0Y2ggPT4ge1xuXHRkaXNwYXRjaCgge1xuXHRcdHR5cGU6ICdISURFX01PREFMJyxcblx0fSApO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy1wYWdlL2FjdGlvbnMvbW9kYWwuanMiLCJleHBvcnQgY29uc3QgdXBkYXRlUGVybWlzc2lvbnMgPSBwZXJtaXNzaW9ucyA9PiBkaXNwYXRjaCA9PiB7XG5cdGRpc3BhdGNoKCB7XG5cdFx0dHlwZTogJ1VQREFURV9QRVJNSVNTSU9OUycsXG5cdFx0cGVybWlzc2lvbnM6IHBlcm1pc3Npb25zLFxuXHR9ICk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy1wYWdlL2FjdGlvbnMvcGVybWlzc2lvbnMuanMiLCIvKiBqc2hpbnQgZXN2ZXJzaW9uOiA2ICovXG5pbXBvcnQgJy4vYXBwZWFyYW5jZS1wcmVzZXRzJztcbmltcG9ydCAnLi9wZXJtaXNzaW9ucyc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzLXBhZ2UvaW5kZXguanMiLCIvKiBqc2hpbnQgZXN2ZXJzaW9uOiA2ICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcmVuZGVyQmxvY2sgfSBmcm9tICcuLi9yZW5kZXJCbG9jayc7XG5pbXBvcnQgY29uZmlndXJlU3RvcmUgZnJvbSAnLi4vZm9ybS9zdG9yZS9jb25maWd1cmVTdG9yZSc7XG5pbXBvcnQgaTE4biBmcm9tICdpMThuLXdwLXBsdWdpbic7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHFzIGZyb20gJ3FzJztcbmltcG9ydCB7IGNvbm5lY3QsIFByb3ZpZGVyIH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0ICogYXMgc2V0dGluZ3NBY3Rpb25zIGZyb20gJy4uL2Zvcm0vYWN0aW9ucy9zZXR0aW5ncyc7XG5pbXBvcnQgeyB0cmFuc2xhdGUsIGdldFRoZW1lUHJlZml4IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IERlc2lnblN0eWxlIGZyb20gJy4uL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2Rlc2lnbic7XG5pbXBvcnQgQ29sb3JzIGZyb20gJy4uL2Zvcm0vY29tcG9uZW50cy9hcHBlYXJhbmNlL2NvbG9ycyc7XG5pbXBvcnQgRm9udHMgZnJvbSAnLi4vZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvZm9udHMnO1xuaW1wb3J0IEZvcm1Db250YWluZXIgZnJvbSAnLi4vZm9ybS9jb21wb25lbnRzL2FwcGVhcmFuY2UvZm9ybS1jb250YWluZXInO1xuaW1wb3J0IEN1c3RvbUNzcyBmcm9tICcuLi9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9jdXN0b20tY3NzJztcbmltcG9ydCBOb3RpZmljYXRpb24gZnJvbSAnLi4vbm90aWZpY2F0aW9ucyc7XG5pbXBvcnQgUGFnZVNldHRpbmdzIGZyb20gXCIuLi9mb3JtL2NvbXBvbmVudHMvYXBwZWFyYW5jZS9wYWdlLXNldHRpbmdzXCI7XG5cblxuY29uc3QgcHJlc2V0SWQgPSBqUXVlcnkoICdzZWxlY3RbbmFtZT1cImFwcGVhcmFuY2VfcHJlc2V0XCJdJyApLnZhbCgpO1xuY29uc3QgY3VycmVudFByZXNldCA9ICEgXy5pc1VuZGVmaW5lZCggZm9ybWluYXRvckRhdGEuY3VycmVudFByZXNldCApID8gZm9ybWluYXRvckRhdGEuY3VycmVudFByZXNldCA6IFtdO1xuY29uc3Qgc3RvcmUgPSBjb25maWd1cmVTdG9yZSggY3VycmVudFByZXNldCApO1xuXG5pMThuLnNldExvY2FsZSggZm9ybWluYXRvcmwxMG4ubG9jYWxlICk7XG5cbi8vIFdlIG5lZWQgb3VyIG93biB2ZXJzaW9uIG9mIGpRdWVyeSBpbiBjYXNlIHVzZXIgY2xpY2sgUHJldmlldyB3aXRoIFdQRWRpdG9yIGVuYWJsZWRcbi8vIFdQRWRpdG9yIGluc3RhbmNlIGJyZWFrcyB3aW5kb3cualF1ZXJ5IG9iamVjdCBhbmQgd2Ugc2hvdWxkIHJlc3RvcmUgb24gbW9kYWwgY2xvc2VcbndpbmRvdy5qUXVlcnlGb3JtaSA9IGpRdWVyeS5ub0NvbmZsaWN0KCk7XG5cblxuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzKCBzdGF0ZSApIHtcblx0cmV0dXJuIHtcblx0XHRzZXR0aW5nczogc3RhdGUuc2V0dGluZ3MsXG5cdFx0d3JhcHBlcnM6IHN0YXRlLndyYXBwZXJzLFxuXHRcdGZvcm1EZXNpZ246IHN0YXRlLnNldHRpbmdzWyAnZm9ybS1zdHlsZScgXSB8fCAnZGVmYXVsdCcsXG5cdH07XG59XG5cbmZ1bmN0aW9uIG1hcERpc3BhdGNoVG9Qcm9wcyggZGlzcGF0Y2ggKSB7XG5cdHJldHVybiB7XG5cdFx0YWN0aW9uczoge1xuXHRcdFx0c2V0dGluZ3NBY3Rpb25zOiBiaW5kQWN0aW9uQ3JlYXRvcnMoIHNldHRpbmdzQWN0aW9ucywgZGlzcGF0Y2ggKSxcblx0XHR9LFxuXHR9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVCZWZvcmV1bmxvYWQoIGUgKSB7XG5cdGlmICggd2luZG93LmZvcm1pbmF0b3JDaGFuZ2VzICYmIHdpbmRvdy5mb3JtaW5hdG9yQ2hhbmdlcy5zZXR0aW5ncyA9PT0gdHJ1ZSApIHtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZS5yZXR1cm5WYWx1ZSA9IHRyYW5zbGF0ZShcblx0XHRcdCdZb3UgaGF2ZSB1bnNhdmVkIGNoYW5nZXMsIGFyZSB5b3Ugc3VyZSB3YW50IHRvIGxlYXZlIHRoaXMgcGFnZSdcblx0XHQpO1xuXHRcdHJldHVybiB0cmFuc2xhdGUoICdZb3UgaGF2ZSB1bnNhdmVkIGNoYW5nZXMsIGFyZSB5b3Ugc3VyZSB3YW50IHRvIGxlYXZlIHRoaXMgcGFnZScgKTtcblx0fVxufVxuXG5mdW5jdGlvbiBzYXZlQXBwZWFyYW5jZVByZXNldCggcHJvcHMgKSB7XG5cdHZhciAkdGFyZ2V0ID0galF1ZXJ5KCcuZm9ybWluYXRvci11cGRhdGUtYXBwZWFyYW5jZS1wcmVzZXQnKTtcblx0JHRhcmdldC5hZGRDbGFzcygnc3VpLWJ1dHRvbi1vbmxvYWQnKTtcblxuXHRjb25zdCBvYmplY3QgPSB7XG5cdFx0YWN0aW9uOiAnZm9ybWluYXRvcl9zYXZlX2FwcGVhcmFuY2VfcHJlc2V0Jyxcblx0XHRfd3Bub25jZTogZm9ybWluYXRvckRhdGEucHJlc2V0Tm9uY2UsXG5cdFx0cHJlc2V0SWQsXG5cdFx0c2V0dGluZ3M6IEpTT04uc3RyaW5naWZ5KCBwcm9wcy5zZXR0aW5ncyApLFxuXHR9O1xuXG5cdGF4aW9zLnBvc3QoIGZvcm1pbmF0b3JEYXRhLmFqYXhVcmwsXG5cdFx0cXMuc3RyaW5naWZ5KCBvYmplY3QgKVxuXHQpXG5cdFx0LnRoZW4oICggZGF0YSApID0+IHtcblx0XHRcdGlmICggZGF0YS5kYXRhLnN1Y2Nlc3MgKSB7XG5cdFx0XHRcdC8vIFVwZGF0ZSBzdGF0dXNcblx0XHRcdFx0d2luZG93LmZvcm1pbmF0b3JDaGFuZ2VzLnNldHRpbmdzID0gZmFsc2U7XG5cdFx0XHRcdHByb3BzLnNldEhhc1VwZGF0ZWQoIGZhbHNlICk7XG5cblx0XHRcdFx0aWYgKCBkYXRhLmRhdGEuZGF0YSApIHtcblx0XHRcdFx0XHRjb25zdCBjdXN0b20gPSBuZXcgTm90aWZpY2F0aW9uKCB7XG5cdFx0XHRcdFx0XHR0eXBlOiAnc3VjY2VzcycsXG5cdFx0XHRcdFx0XHR0ZXh0OiBkYXRhLmRhdGEuZGF0YSxcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRjdXN0b20ub3BlbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IGN1c3RvbSA9IG5ldyBOb3RpZmljYXRpb24oIHtcblx0XHRcdFx0XHR0eXBlOiAnZXJyb3InLFxuXHRcdFx0XHRcdHRleHQ6IGRhdGEuZGF0YS5kYXRhLFxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Y3VzdG9tLm9wZW4oKTtcblx0XHRcdH1cblx0XHR9IClcblx0XHQuY2F0Y2goICggZXJyICkgPT4ge1xuXHRcdFx0Y29uc3QgY3VzdG9tID0gbmV3IE5vdGlmaWNhdGlvbigge1xuXHRcdFx0XHR0eXBlOiAnZXJyb3InLFxuXHRcdFx0XHR0ZXh0OiB0cmFuc2xhdGUoICdTb21ldGhpbmcgd2VudCB3cm9uZy4gUGxlYXNlIHRyeSBhZ2Fpbi4nICksXG5cdFx0XHR9ICk7XG5cblx0XHRcdGN1c3RvbS5vcGVuKCk7XG5cblx0XHRcdGNvbnNvbGUubG9nKCBlcnIgKTtcblx0XHR9IClcblx0XHQudGhlbiggKCkgPT4ge1xuXHRcdFx0JHRhcmdldC5yZW1vdmVDbGFzcygnc3VpLWJ1dHRvbi1vbmxvYWQnKTtcblx0XHR9ICk7XG59XG5cbmZ1bmN0aW9uIGNoYW5nZVByZXNldCggZSApIHtcblx0dmFyIHByZXNldElkID0gZS5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuXHRcdGRpdl9wcmVsb2FkZXIgPVxuXHRcdFx0JzxkaXYgY2xhc3M9XCJzdWktYm94LWJvZHkgc3VpLWJsb2NrLWNvbnRlbnQtY2VudGVyXCIgc3R5bGU9XCJoZWlnaHQ6IDQyMHB4O2Rpc3BsYXk6IGZsZXg7IGp1c3RpZnktY29udGVudDogY2VudGVyOyBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1wiPjxwIGNsYXNzPVwiXCIgYXJpYS1sYWJlbD1cIkxvYWRpbmcgY29udGVudFwiPicgK1xuXHRcdFx0XHQnPGkgY2xhc3M9XCJzdWktaWNvbi1sb2FkZXIgc3VpLWxvYWRpbmdcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+JyArXG5cdFx0XHRcdCc8YnI+JyArIHRyYW5zbGF0ZSggJ0xvYWRpbmcgUHJlc2V0IGRhdGEuLi4nICkgK1xuXHRcdFx0JzwvcD48L2Rpdj4nO1xuXG5cdGpRdWVyeSgnI2Zvcm1pbmF0b3ItYXBwZWFyYW5jZS1wcmVzZXQnKS5odG1sKCBkaXZfcHJlbG9hZGVyICk7XG5cblx0Rm9ybWluYXRvci5vcGVuUHJlc2V0KCBwcmVzZXRJZCApO1xufVxuXG5mdW5jdGlvbiBkZWxldGVQcmVzZXQoKSB7XG5cdHZhciAkdGFyZ2V0ID0galF1ZXJ5KCcucG9wdXAtY29uZmlybWF0aW9uLWNvbmZpcm0nKTtcblx0JHRhcmdldC5hZGRDbGFzcygnc3VpLWJ1dHRvbi1vbmxvYWQnKTtcblxuXHR2YXIgcHJlc2V0SWQgPSBqUXVlcnkoJ3NlbGVjdFtuYW1lPVwiYXBwZWFyYW5jZV9wcmVzZXRcIl0nKS52YWwoKTtcblxuXHR2YXIgZGF0YSA9IHtcblx0XHRhY3Rpb246ICdmb3JtaW5hdG9yX2RlbGV0ZV9hcHBlYXJhbmNlX3ByZXNldCcsXG5cdFx0X3dwbm9uY2U6IGZvcm1pbmF0b3JEYXRhLnByZXNldE5vbmNlLFxuXHRcdHByZXNldF9pZDogcHJlc2V0SWQsXG5cdH07XG5cblx0alF1ZXJ5LmFqYXgoe1xuXHRcdHVybDogRm9ybWluYXRvci5EYXRhLmFqYXhVcmwsXG5cdFx0dHlwZTogXCJQT1NUXCIsXG5cdFx0ZGF0YTogZGF0YSxcblx0XHRzdWNjZXNzOiBmdW5jdGlvbiggcmVzdWx0ICkge1xuXHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQuc3VjY2Vzcykge1xuXHRcdFx0XHRGb3JtaW5hdG9yLm9wZW5QcmVzZXQoICdkZWZhdWx0JywgJ3ByZXNldF9kZWxldGVkJyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Rm9ybWluYXRvci5Ob3RpZmljYXRpb24ub3BlbiggJ2Vycm9yJywgcmVzdWx0LmRhdGEsIDQwMDAgKTtcblx0XHRcdFx0JHRhcmdldC5yZW1vdmVDbGFzcygnc3VpLWJ1dHRvbi1vbmxvYWQnKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGVycm9yOiBmdW5jdGlvbiAoIGVycm9yICkge1xuXHRcdFx0Rm9ybWluYXRvci5Ob3RpZmljYXRpb24ub3BlbiggJ2Vycm9yJywgZXJyb3IuZGF0YSwgNDAwMCApO1xuXHRcdFx0JHRhcmdldC5yZW1vdmVDbGFzcygnc3VpLWJ1dHRvbi1vbmxvYWQnKTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gQXBwZWFyYW5jZShwcm9wcykge1xuXHRjb25zdCBbaGFzVXBkYXRlZCwgc2V0SGFzVXBkYXRlZF0gPSBSZWFjdC51c2VTdGF0ZSggISEgd2luZG93LmZvcm1pbmF0b3JDaGFuZ2VzLnNldHRpbmdzICk7XG5cblx0ZnVuY3Rpb24gc2F2ZSgpIHtcblx0XHRzYXZlQXBwZWFyYW5jZVByZXNldCggeyAuLi5wcm9wcywgc2V0SGFzVXBkYXRlZCB9ICk7XG5cdH1cblxuXHRSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuXHRcdHNldEhhc1VwZGF0ZWQoICEhIHdpbmRvdy5mb3JtaW5hdG9yQ2hhbmdlcy5zZXR0aW5ncyApO1xuXHR9LCBbd2luZG93LmZvcm1pbmF0b3JDaGFuZ2VzLnNldHRpbmdzXSApO1xuXG5cdFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdkZWxldGVQcmVzZXQnLCBkZWxldGVQcmVzZXQgKTtcblx0XHR3aW5kb3cualF1ZXJ5KCAnc2VsZWN0W25hbWU9XCJhcHBlYXJhbmNlX3ByZXNldFwiXScgKS5vZmYoJ2NoYW5nZScpLm9uKCAnY2hhbmdlJywgY2hhbmdlUHJlc2V0ICk7XG5cdFx0d2luZG93LmpRdWVyeSggJy5mb3JtaW5hdG9yLXVwZGF0ZS1hcHBlYXJhbmNlLXByZXNldCcgKS5vZmYoJ2NsaWNrJykub24oICdjbGljaycsIHNhdmUgKTtcblx0fSwgW3Byb3BzXSApO1xuXG5cdGNvbnN0IGZvbnRTdHlsZSA9ICEgXy5pc1VuZGVmaW5lZCggcHJvcHMuc2V0dGluZ3NbICdmb3JtLXN0eWxlJyBdIClcblx0XHRcdD8gcHJvcHMuc2V0dGluZ3NbICdmb3JtLXN0eWxlJyBdXG5cdFx0XHQ6ICdkZWZhdWx0Jyxcblx0XHR0aXRsZSA9IGpRdWVyeSgnc2VsZWN0W25hbWU9XCJhcHBlYXJhbmNlX3ByZXNldFwiXSBvcHRpb246c2VsZWN0ZWQnKS5maXJzdCgpLnRleHQoKTtcblxuXHRyZXR1cm4gKCA8UmVhY3QuRnJhZ21lbnQ+XG5cblx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtaGVhZGVyXCI+XG5cdFx0XHQ8aDIgY2xhc3NOYW1lPVwic3VpLWJveC10aXRsZVwiPnsgdGl0bGUgfTwvaDI+XG5cblx0XHRcdHsgaGFzVXBkYXRlZCAmJlxuXHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktdGFnXCI+XG5cdFx0XHRcdFx0eyB0cmFuc2xhdGUoICdVbnNhdmVkIENoYW5nZXMnICkgfVxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHR9XG5cdFx0PC9kaXY+XG5cblx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtYm9keVwiPlxuXHRcdFx0PERlc2lnblN0eWxlIHsgLi4ucHJvcHMgfSAvPlxuXG5cdFx0XHR7IGZvbnRTdHlsZSAhPT0gJ25vbmUnICYmXG5cdFx0XHRcdDxSZWFjdC5GcmFnbWVudCBrZXk9e2AkeyBnZXRUaGVtZVByZWZpeChwcm9wcykgfXRoZW1lS2V5YH0+XG5cdFx0XHRcdFx0PENvbG9ycyB7IC4uLnByb3BzIH0gcHJlc2V0PVwidHJ1ZVwiIC8+XG5cdFx0XHRcdFx0PEZvbnRzIHsgLi4ucHJvcHMgfSBwcmVzZXQ9XCJ0cnVlXCIgLz5cblx0XHRcdFx0XHQ8Rm9ybUNvbnRhaW5lciB7IC4uLnByb3BzIH0gLz5cblx0XHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHRcdH1cblxuXHRcdFx0PEN1c3RvbUNzcyB7IC4uLnByb3BzIH0gLz5cblx0XHQ8L2Rpdj5cblx0PC9SZWFjdC5GcmFnbWVudD4gKTtcbn1cblxuY29uc3QgQXBwZWFyYW5jZUNvbnRhaW5lciA9IGNvbm5lY3QoXG5cdG1hcFN0YXRlVG9Qcm9wcyxcblx0bWFwRGlzcGF0Y2hUb1Byb3BzXG4pKCBBcHBlYXJhbmNlICk7XG5cbndpbmRvdy5mb3JtaW5hdG9yQ2hhbmdlcyA9IHsgc2V0dGluZ3M6IGZhbHNlIH07XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2JlZm9yZXVubG9hZCcsIGhhbmRsZUJlZm9yZXVubG9hZCApO1xuXG5yZW5kZXJCbG9jayhcblx0J2Zvcm1pbmF0b3ItYXBwZWFyYW5jZS1wcmVzZXQnLFxuXHQ8UHJvdmlkZXIgc3RvcmU9eyBzdG9yZSB9PlxuXHRcdDxBcHBlYXJhbmNlQ29udGFpbmVyLz5cblx0PC9Qcm92aWRlcj5cbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MtcGFnZS9hcHBlYXJhbmNlLXByZXNldHMuanMiLCIvKiBqc2hpbnQgZXN2ZXJzaW9uOiA2ICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcmVuZGVyQmxvY2sgfSBmcm9tICcuLi9yZW5kZXJCbG9jayc7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gJ3JlYWN0LXJlZHV4Jztcbi8vIGltcG9ydCB7IE1lbW9yeVJvdXRlciwgUm91dGUgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcbmltcG9ydCBjb25maWd1cmVTdG9yZSBmcm9tICcuL3N0b3JlL2NvbmZpZ3VyZVN0b3JlJztcbmltcG9ydCBpMThuIGZyb20gJ2kxOG4td3AtcGx1Z2luJztcblxuaW1wb3J0IE1haW4gZnJvbSAnLi9jb250YWluZXJzL21haW4nO1xuXG5jb25zdCBzdG9yZSA9IGNvbmZpZ3VyZVN0b3JlKCBmb3JtaW5hdG9yRGF0YS5tYWluU2V0dGluZ3MgKTtcblxuaTE4bi5zZXRMb2NhbGUoIGZvcm1pbmF0b3JsMTBuLmxvY2FsZSApO1xuXG53aW5kb3cuZm9ybWluYXRvckNoYW5nZXMgPSB7XG5cdHBlcm1pc3Npb25zOiB7fSxcbn07XG5cbi8vIFdlIG5lZWQgb3VyIG93biB2ZXJzaW9uIG9mIGpRdWVyeSBpbiBjYXNlIHVzZXIgY2xpY2sgUHJldmlldyB3aXRoIFdQRWRpdG9yIGVuYWJsZWRcbi8vIFdQRWRpdG9yIGluc3RhbmNlIGJyZWFrcyB3aW5kb3cualF1ZXJ5IG9iamVjdCBhbmQgd2Ugc2hvdWxkIHJlc3RvcmUgb24gbW9kYWwgY2xvc2VcbndpbmRvdy5qUXVlcnlGb3JtaSA9IGpRdWVyeS5ub0NvbmZsaWN0KCk7XG5cbi8vIE1haW4uXG5yZW5kZXJCbG9jayhcblx0J2Zvcm1pbmF0b3ItcGVybWlzc2lvbnMnLFxuXHQ8UHJvdmlkZXIgc3RvcmU9eyBzdG9yZSB9PlxuXHRcdDxNYWluLz5cblx0PC9Qcm92aWRlcj5cbik7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzLXBhZ2UvcGVybWlzc2lvbnMuanMiLCJpbXBvcnQgeyBjcmVhdGVTdG9yZSwgY29tcG9zZSwgYXBwbHlNaWRkbGV3YXJlIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHRodW5rIGZyb20gJ3JlZHV4LXRodW5rJztcbmltcG9ydCBhcHBSZWR1Y2VycyBmcm9tICcuLi9yZWR1Y2Vycy9pbmRleCc7XG5cbmNvbnN0IG5ld0NyZWF0ZVN0b3JlID0gY29tcG9zZSggYXBwbHlNaWRkbGV3YXJlKCB0aHVuayApICkoIGNyZWF0ZVN0b3JlICk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbmZpZ3VyZVN0b3JlKCBpbml0aWFsU3RhdGUgKSB7XG5cdHJldHVybiBuZXdDcmVhdGVTdG9yZSggYXBwUmVkdWNlcnMsIGluaXRpYWxTdGF0ZSApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzLXBhZ2Uvc3RvcmUvY29uZmlndXJlU3RvcmUuanMiLCJpbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tICdyZWR1eCc7XG5cbi8vIEltcG9ydCByZWR1Y2Vyc1xuaW1wb3J0IHBlcm1pc3Npb25zIGZyb20gJy4vcGVybWlzc2lvbnMnO1xuaW1wb3J0IG1vZGFsIGZyb20gJy4vbW9kYWwnO1xuXG5jb25zdCBhcHBSZWR1Y2VycyA9IGNvbWJpbmVSZWR1Y2Vycygge1xuXHQvLyBMaXN0IHJlZHVjZXJzXG5cdHBlcm1pc3Npb25zLFxuXHRtb2RhbCxcbn0gKTtcblxuZXhwb3J0IGRlZmF1bHQgYXBwUmVkdWNlcnM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MtcGFnZS9yZWR1Y2Vycy9pbmRleC5qcyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBlcm1pc3Npb25zKCBzdGF0ZSA9IFtdLCBhY3Rpb24gKSB7XG5cdHN3aXRjaCAoIGFjdGlvbi50eXBlICkge1xuXHRcdGNhc2UgJ1VQREFURV9QRVJNSVNTSU9OUyc6XG5cdFx0XHRyZXR1cm4gYWN0aW9uLnBlcm1pc3Npb25zO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy1wYWdlL3JlZHVjZXJzL3Blcm1pc3Npb25zLmpzIiwiY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuXHRtb2RhbFR5cGU6IG51bGwsXG5cdG1vZGFsUHJvcHM6IHt9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgKCBzdGF0ZSA9IGluaXRpYWxTdGF0ZSwgYWN0aW9uICkgPT4ge1xuXHRzd2l0Y2ggKCBhY3Rpb24udHlwZSApIHtcblx0XHRjYXNlICdTSE9XX01PREFMJzpcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG1vZGFsUHJvcHM6IGFjdGlvbi5tb2RhbFByb3BzLFxuXHRcdFx0XHRtb2RhbFR5cGU6IGFjdGlvbi5tb2RhbFR5cGUsXG5cdFx0XHRcdHR5cGU6IGFjdGlvbi50eXBlLFxuXHRcdFx0fTtcblx0XHRjYXNlICdISURFX01PREFMJzpcblx0XHRcdHJldHVybiBpbml0aWFsU3RhdGU7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBzdGF0ZTtcblx0fVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy1wYWdlL3JlZHVjZXJzL21vZGFsLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSwgcGFyc2VRdWVyeVN0cmluZyB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IFBlcm1pc3Npb25zIGZyb20gJy4vcGVybWlzc2lvbnMnO1xuaW1wb3J0IE1vZGFsIGZyb20gJy4vbW9kYWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWluIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0dGhpcy5nb1RvU2VjdGlvbkZyb21VcmwoKTtcblxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnYmVmb3JldW5sb2FkJywgdGhpcy5oYW5kbGVCZWZvcmV1bmxvYWQgKTtcblx0fVxuXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAnYmVmb3JldW5sb2FkJywgdGhpcy5oYW5kbGVCZWZvcmV1bmxvYWQgKTtcblx0fVxuXG5cdC8qXG5cdCAqIElmIFVSTCBoYXMgcGFyYW0gZ290b3NlY3Rpb24sIHVwb24gcGFnZSBsb2FkLFxuXHQgKiB0aGUgcGFnZSB3aWxsIGdvIHRvIHRoZSBzcGVjaWZpZWQgdGFiIG9uIHRoZSBnb3Rvc2VjdGlvbiBwYXJhbS5cblx0ICogVXNlZnVsIHdoZW4gcmVkaXJlY3RpbmcgZnJvbSBhbm90aGVyIHBhZ2UgdGhhdCBpcyBub3QgcGFydCBvZiBmb3JtIGVkaXRvci5cblx0Ki9cblx0Z29Ub1NlY3Rpb25Gcm9tVXJsKCkge1xuXHRcdGNvbnN0IGdvVG9TZWN0aW9uID0gcGFyc2VRdWVyeVN0cmluZygpLmdvdG9zZWN0aW9uO1xuXG5cdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIGdvVG9TZWN0aW9uICkgKSB7XG5cdFx0XHRjb25zdCB0aGVVcmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcblxuXHRcdFx0dGhpcy5wcm9wcy5oaXN0b3J5LnB1c2goICcvJyArIHBhcnNlUXVlcnlTdHJpbmcoKS5nb3Rvc2VjdGlvbiApO1xuXHRcdFx0d2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKCB7fSwgZG9jdW1lbnQudGl0bGUsIHRoZVVybC5zbGljZSggMCwgdGhlVXJsLmluZGV4T2YoICcmZ290b3NlY3Rpb24nICkgKSApO1xuXHRcdH1cblx0fVxuXG5cdGhhbmRsZUJlZm9yZXVubG9hZCggZSApIHtcblx0XHRpZiAoIHdpbmRvdy5mb3JtaW5hdG9yQ2hhbmdlcy5sZW5ndGggPiAwIHx8IHdpbmRvdy5mb3JtaW5hdG9yQ2hhbmdlcy5zZXR0aW5ncyA9PT0gdHJ1ZSApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGUucmV0dXJuVmFsdWUgPSB0cmFuc2xhdGUoXG5cdFx0XHRcdCdZb3UgaGF2ZSB1bnNhdmVkIGNoYW5nZXMsIGFyZSB5b3Ugc3VyZSB3YW50IHRvIGxlYXZlIHRoaXMgcGFnZSdcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnWW91IGhhdmUgdW5zYXZlZCBjaGFuZ2VzLCBhcmUgeW91IHN1cmUgd2FudCB0byBsZWF2ZSB0aGlzIHBhZ2UnICk7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyKCkge1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblxuXHRcdFx0XHQ8UGVybWlzc2lvbnMgeyAuLi50aGlzLnByb3BzIH0gLz5cblxuXHRcdFx0XHQ8TW9kYWwgeyAuLi50aGlzLnByb3BzIH0gLz5cblxuXHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MtcGFnZS9jb250YWluZXJzL21haW4uanMiLCJpbXBvcnQgeyBQcm92aWRlciwgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcblxuaW1wb3J0ICogYXMgbW9kYWxBY3Rpb25zIGZyb20gJy4uL2FjdGlvbnMvbW9kYWwnO1xuaW1wb3J0ICogYXMgcGVybWlzc2lvbkFjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucy9wZXJtaXNzaW9ucyc7XG5cbmltcG9ydCBQZXJtaXNzaW9ucyBmcm9tICcuLi9jb21wb25lbnRzL3Blcm1pc3Npb25zJztcblxuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzKCBzdGF0ZSApIHtcblx0cmV0dXJuIHtcblx0XHRwZXJtaXNzaW9uczogc3RhdGUucGVybWlzc2lvbnMgfHwge30sXG5cdFx0bW9kYWw6IHN0YXRlLm1vZGFsLFxuXHR9O1xufVxuXG5mdW5jdGlvbiBtYXBEaXNwYXRjaFRvUHJvcHMoIGRpc3BhdGNoICkge1xuXHRyZXR1cm4ge1xuXHRcdGFjdGlvbnM6IHtcblx0XHRcdG1vZGFsQWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKCBtb2RhbEFjdGlvbnMsIGRpc3BhdGNoICksXG5cdFx0XHRwZXJtaXNzaW9uQWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKCBwZXJtaXNzaW9uQWN0aW9ucywgZGlzcGF0Y2ggKSxcblx0XHR9LFxuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KFxuXHRtYXBTdGF0ZVRvUHJvcHMsXG5cdG1hcERpc3BhdGNoVG9Qcm9wc1xuKSggUGVybWlzc2lvbnMgKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MtcGFnZS9jb250YWluZXJzL3Blcm1pc3Npb25zLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IEhlYWRlciBmcm9tICcuLi9nbG9iYWwvaGVhZGVyJztcbmltcG9ydCBGb290ZXIgZnJvbSAnLi4vZ2xvYmFsL2Zvb3Rlcic7XG5pbXBvcnQgUGVybWlzc2lvbnNUYWJsZSBmcm9tICcuL3Blcm1pc3Npb25zL3Blcm1pc3Npb25zLXRhYmxlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGVybWlzc2lvbnMgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cdH1cblxuXHRyZW5kZXIgKCkge1xuXHRcdGNvbnN0IHRvb2x0aXBXaWR0aCA9IHsgXCItLXRvb2x0aXAtd2lkdGhcIjogXCIyMjBweFwiIH07XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXG5cdFx0XHRcdDxIZWFkZXIgeyAuLi50aGlzLnByb3BzIH0gdGl0bGU9eyB0cmFuc2xhdGUoICdQZXJtaXNzaW9ucycgKSB9IC8+XG5cblx0XHRcdFx0PFBlcm1pc3Npb25zVGFibGUgeyAuLi50aGlzLnByb3BzIH0gLz5cblxuXHRcdFx0XHQ8Rm9vdGVyIHsgLi4udGhpcy5wcm9wcyB9Lz5cblxuXHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MtcGFnZS9jb21wb25lbnRzL3Blcm1pc3Npb25zLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVhZGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1oZWFkZXJcIj5cbiAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJzdWktYm94LXRpdGxlXCI+eyBwcm9wLnRpdGxlIH08L2gyPlxuXG4gICAgICAgICAgICB7IHByb3AuaGFzVXBkYXRlZCAmJlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInN1aS10YWdcIj5cbiAgICAgICAgICAgICAgICAgICAgeyB0cmFuc2xhdGUoICdVbnNhdmVkIENoYW5nZXMnICkgfVxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MtcGFnZS9nbG9iYWwvaGVhZGVyLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9vdGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy5zaG93TW9kYWwgPSB0aGlzLnNob3dNb2RhbC5iaW5kKCB0aGlzICk7XG5cdFx0dGhpcy5jbG9zZU1vZGFsID0gdGhpcy5jbG9zZU1vZGFsLmJpbmQoIHRoaXMgKTtcblx0fVxuXG5cdHNob3dNb2RhbCgpIHtcblx0XHR0aGlzLnByb3BzLmFjdGlvbnMubW9kYWxBY3Rpb25zLnNob3dNb2RhbChcblx0XHRcdHtcblx0XHRcdFx0b3BlbjogdHJ1ZSxcblx0XHRcdFx0bmV3OiB0cnVlLFxuXHRcdFx0XHRjbG9zZU1vZGFsOiB0aGlzLmNsb3NlTW9kYWwsXG5cdFx0XHR9LFxuXHRcdFx0J3Blcm1pc3Npb25zJ1xuXHRcdCk7XG5cdH1cblxuXHRjbG9zZU1vZGFsKCkge1xuXHRcdHRoaXMucHJvcHMuYWN0aW9ucy5tb2RhbEFjdGlvbnMuc2hvd01vZGFsKFxuXHRcdFx0e1xuXHRcdFx0XHRvcGVuOiBmYWxzZSxcblx0XHRcdH0sXG5cdFx0XHQncGVybWlzc2lvbnMnXG5cdFx0KTtcblx0fVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBwcm9wID0gdGhpcy5wcm9wcztcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzdWktYm94LWZvb3RlclwiPlxuXHRcdFx0XHQ8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInN1aS1idXR0b24gc3VpLWJ1dHRvbi1ncmF5XCJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17IHRoaXMuc2hvd01vZGFsIH1cbiAgICAgICAgICAgICAgICA+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWljb24tcGx1cyBzdWktXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuXHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnQWRkIHBlcm1pc3Npb25zJyApIH1cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQ8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzLXBhZ2UvZ2xvYmFsL2Zvb3Rlci5qcyIsIi8qIGpzaGludCBlc3ZlcnNpb246IDYgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBQZXJtaXNzaW9uIGZyb20gJy4vcGVybWlzc2lvbi1pdGVtJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGVybWlzc2lvbnNUYWJsZSBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCBwcm9wcyApIHtcblx0XHRzdXBlciggcHJvcHMgKTtcblx0fVxuXG5cdGFwcGx5U3RpY2t5KCkge1xuXHRcdGNvbnN0IG5vZGUgPSB0aGlzLnJlZnMuU3RpY2t5SGVhZGVyO1xuXHRcdGNvbnN0IGN1cnJlbnRPZmZzZXQgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcblx0XHRjb25zdCBzdGlja3lPZmZzZXQgPSBwYXJzZUludCggd2luZG93LmdldENvbXB1dGVkU3R5bGUoIG5vZGUgKS50b3AucmVwbGFjZSggJ3B4JywgJycgKSApO1xuXHRcdGNvbnN0IGlzU3R1Y2sgPSBjdXJyZW50T2Zmc2V0IDw9IHN0aWNreU9mZnNldDtcblxuXHRcdGlmICggaXNTdHVjayApIHtcblx0XHRcdG5vZGUuY2xhc3NMaXN0LmFkZCggJ3N1aS1pcy1zdGlja3knICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5vZGUuY2xhc3NMaXN0LnJlbW92ZSggJ3N1aS1pcy1zdGlja3knICk7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1ib2R5XCI+XG5cdFx0XHRcdFx0PHA+eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHQnQnkgZGVmYXVsdCwgYWxsIGFkbWluaXN0cmF0b3JzIGhhdmUgY29tcGxldGUgYWNjZXNzIHRvIEZvcm1pbmF0b3IuICcgK1xuXHRcdFx0XHRcdFx0J1lvdSBjYW4gcHJvdmlkZSBhbmQgbWFuYWdlIGFjY2VzcyB0byBvdGhlciB1c2VyIHJvbGVzIG9yIHRvIGluZGl2aWR1YWwgdXNlcihzKSBiZWxvdy4nXG5cdFx0XHRcdFx0KSB9PC9wPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZvcm1pbmF0b3ItcGVybWlzc2lvbnMtdGFibGVcIj5cblx0XHRcdFx0XHQ8dGFibGUgY2xhc3NOYW1lPVwic3VpLXRhYmxlIHN1aS10YWJsZS1mbHVzaGVkXCI+XG5cblx0XHRcdFx0XHRcdDx0aGVhZD5cblx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdDx0aCBjb2xTcGFuPXsgNCB9ID57IHRyYW5zbGF0ZSggJ1VzZXIgUm9sZS9Vc2VyJyApIH08L3RoPlxuXHRcdFx0XHRcdFx0XHRcdDx0aCBjb2xTcGFuPXsgMiB9IGNsYXNzTmFtZT1cImZwLWl0ZW0tY29sXCI+eyB0cmFuc2xhdGUoICdNb2R1bGVzJyApIH08L3RoPlxuXHRcdFx0XHRcdFx0XHRcdDx0aCBjb2xTcGFuPXsgMiB9IGNsYXNzTmFtZT1cImZwLWl0ZW0tY29sXCI+eyB0cmFuc2xhdGUoICdTdWJtaXNzaW9ucycgKSB9PC90aD5cblx0XHRcdFx0XHRcdFx0XHQ8dGggY29sU3Bhbj17IDIgfSBjbGFzc05hbWU9XCJmcC1pdGVtLWNvbFwiPnsgdHJhbnNsYXRlKCAnQWRkLW9ucycgKSB9PC90aD5cblx0XHRcdFx0XHRcdFx0XHQ8dGggY29sU3Bhbj17IDIgfSBjbGFzc05hbWU9XCJmcC1pdGVtLWNvbFwiPnsgdHJhbnNsYXRlKCAnSW50ZWdyYXRpb25zJyApIH08L3RoPlxuXHRcdFx0XHRcdFx0XHRcdDx0aCBjb2xTcGFuPXsgMiB9IGNsYXNzTmFtZT1cImZwLWl0ZW0tY29sXCI+eyB0cmFuc2xhdGUoICdSZXBvcnRzJyApIH08L3RoPlxuXHRcdFx0XHRcdFx0XHRcdDx0aCBjb2xTcGFuPXsgMiB9IGNsYXNzTmFtZT1cImZwLWl0ZW0tY29sXCI+eyB0cmFuc2xhdGUoICdTZXR0aW5ncycgKSB9PC90aD5cblx0XHRcdFx0XHRcdFx0XHQ8dGggY29sU3Bhbj17IDEgfT48L3RoPlxuXHRcdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdFx0PC90aGVhZD5cblxuXHRcdFx0XHRcdFx0PHRib2R5PlxuXHRcdFx0XHRcdFx0XHQ8UGVybWlzc2lvbiB7IC4uLnRoaXMucHJvcHMgfSBpc0FkbWluPXsgdHJ1ZSB9IC8+XG5cblx0XHRcdFx0XHRcdFx0eyBfLm1hcCggdGhpcy5wcm9wcy5wZXJtaXNzaW9ucywgKCBwZXJtaXNzaW9uLCBpbmRleCApID0+IChcblx0XHRcdFx0XHRcdFx0XHQ8UGVybWlzc2lvblxuXHRcdFx0XHRcdFx0XHRcdFx0a2V5PXsgaW5kZXggfVxuXHRcdFx0XHRcdFx0XHRcdFx0YWN0aW9ucz17IHRoaXMucHJvcHMuYWN0aW9ucyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRpc0FkbWluPXsgZmFsc2UgfVxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi5wZXJtaXNzaW9uIH1cblx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHQpICkgfVxuXHRcdFx0XHRcdFx0PC90Ym9keT5cblxuXHRcdFx0XHRcdDwvdGFibGU+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MtcGFnZS9jb21wb25lbnRzL3Blcm1pc3Npb25zL3Blcm1pc3Npb25zLXRhYmxlLmpzIiwiLyoganNoaW50IGVzdmVyc2lvbjogNiAqL1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzJztcbmltcG9ydCBQZXJtaXNzaW9uSWNvbiBmcm9tICcuL3Blcm1pc3Npb24taWNvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBlcm1pc3Npb25JdGVtIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy5wZXJtaXNzaW9uTWVudSA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXHRcdHRoaXMuc2hvd01vZGFsID0gdGhpcy5zaG93TW9kYWwuYmluZCggdGhpcyApO1xuXHRcdHRoaXMuZGVsZXRlTW9kYWwgPSB0aGlzLmRlbGV0ZU1vZGFsLmJpbmQoIHRoaXMgKTtcblx0fVxuXG5cdGNvbXBvbmVudERpZE1vdW50ICgpIHtcblx0XHR0aGlzLiRwZXJtaXNzaW9uID0galF1ZXJ5KCB0aGlzLnBlcm1pc3Npb25NZW51LmN1cnJlbnQgKTtcblxuXHRcdHRoaXMuJHBlcm1pc3Npb24ub24oICdjbGljaycsIGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdFx0alF1ZXJ5KCAnLmZwLXBlcm1pc3Npb24tYWN0aW9ucyAucGVybWlzc2lvbi1tZW51JyApXG5cdFx0XHRcdC5ub3QoIHRoaXMgKVxuXHRcdFx0XHQucGFyZW50KCAnLnN1aS1kcm9wZG93bi5vcGVuJyApXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggJ29wZW4nICk7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5wYXJlbnQoKS50b2dnbGVDbGFzcyggJ29wZW4nICk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLiRwZXJtaXNzaW9uLm9uKCAnbW91c2VvdXQnLCBmdW5jdGlvbiggZSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnRyaWdnZXIoICdibHVyJyApO1xuXHRcdH0pO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoaXMgd2hlbiBtb3JlIEZvcm1pbmF0b3IgbWVudSBpdGVtcyBhcmUgYWRkZWQgaW4gdGhlIGZ1dHVyZSB0byBlbmFibGUgYWNjb3JkaW9uLlxuXHRcdGxldCBjb3VudCA9IDA7XG5cdFx0dGhpcy5hY2NvcmRpb25UaW1lb3V0KCBjb3VudCApO1xuXHR9XG5cblx0Y29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuXHRcdHRoaXMuJHBlcm1pc3Npb24ub2ZmKCk7XG5cdH1cblxuXHQvKlxuXHQgKiBSZW1vdmVzIHRoZSBjbGljayBldmVudCBvbiBzdWktYWNjb3JkaW9uIHVudGlsIFNVSSBoYXMgaW5pdGlhbGl6ZWQuXG5cdCAqIFRoaXMgd2FzIGFkZGVkIGJlY2F1c2UgU1VJIGhhcyBubyB0cmlnZ2VyIGV2ZW50XG5cdCAqIHdoZW4gaXQgaGFzIGZpbmlzaGVkIGluaXRpYWxpemluZyB0aGF0IHdlIGNvdWxkIGhhdmUgdXNlZC5cblx0Ki9cblx0YWNjb3JkaW9uVGltZW91dCAoIGNvdW50ICkge1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdFx0c2V0VGltZW91dChcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkoICcuZm9ybWluYXRvci1wZXJtaXNzaW9ucy10YWJsZS5zdWktYWNjb3JkaW9uJyApLm9mZiggJ2NsaWNrJyApO1xuXG5cdFx0XHRcdGlmICggY291bnQgPCAxMCApIHtcblx0XHRcdFx0XHRzZWxmLmFjY29yZGlvblRpbWVvdXQoIGNvdW50ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y291bnQrKztcblx0XHRcdH0sXG5cdFx0XHQyMDBcblx0XHQpO1xuXHR9XG5cblx0c2hvd01vZGFsKCkge1xuXHRcdGNvbnN0IG1vZGFsQWN0aW9ucyA9IHRoaXMucHJvcHMuYWN0aW9ucy5tb2RhbEFjdGlvbnM7XG5cdFx0Y29uc3QgdXNlcklkcyA9IHRoaXMucHJvcHMuc3BlY2lmaWNfdXNlcjtcblxuXHRcdG1vZGFsQWN0aW9ucy5zaG93TW9kYWwoXG5cdFx0XHR7XG5cdFx0XHRcdC4uLnRoaXMucHJvcHMsXG5cdFx0XHRcdC4uLih1c2VySWRzICYmIHsgY3VycmVudFVzZXI6IHRoaXMucHJvcHMudXNlcl9pbmZvWyB1c2VySWRzWzBdIF0gfSksXG5cdFx0XHRcdG9wZW46IHRydWUsXG5cdFx0XHRcdGNsb3NlTW9kYWw6ICgpID0+IHtcblx0XHRcdFx0XHRtb2RhbEFjdGlvbnMuc2hvd01vZGFsKFxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRvcGVuOiBmYWxzZSxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHQncGVybWlzc2lvbnMnXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSxcblx0XHRcdH0sXG5cdFx0XHQncGVybWlzc2lvbnMnXG5cdFx0KTtcblx0fVxuXG5cdGRlbGV0ZU1vZGFsKCkge1xuXHRcdGNvbnN0IG1vZGFsQWN0aW9ucyA9IHRoaXMucHJvcHMuYWN0aW9ucy5tb2RhbEFjdGlvbnM7XG5cblx0XHRtb2RhbEFjdGlvbnMuc2hvd01vZGFsKFxuXHRcdFx0e1xuXHRcdFx0XHQuLi50aGlzLnByb3BzLFxuXHRcdFx0XHRvcGVuOiB0cnVlLFxuXHRcdFx0XHRjbG9zZU1vZGFsOiAoKSA9PiB7XG5cdFx0XHRcdFx0bW9kYWxBY3Rpb25zLnNob3dNb2RhbChcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0b3BlbjogZmFsc2UsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0J3Blcm1pc3Npb25EZWxldGUnXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSxcblx0XHRcdH0sXG5cdFx0XHQncGVybWlzc2lvbkRlbGV0ZSdcblx0XHQpO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IHByb3AgPSB0aGlzLnByb3BzO1xuXHRcdGNvbnN0IGlzQWRtaW4gPSBwcm9wLmlzQWRtaW47XG5cdFx0Y29uc3QgdG9vbHRpcFdpZHRoID0geyBcIi0tdG9vbHRpcC13aWR0aFwiOiBcIjIyMHB4XCIgfTtcblx0XHRjb25zdCBhY2Nlc3NMaXN0ID0gW1xuXHRcdFx0J21hbmFnZV9mb3JtaW5hdG9yX21vZHVsZXMnLFxuXHRcdFx0J21hbmFnZV9mb3JtaW5hdG9yX3N1Ym1pc3Npb25zJyxcblx0XHRcdCdtYW5hZ2VfZm9ybWluYXRvcl9hZGRvbnMnLFxuXHRcdFx0J21hbmFnZV9mb3JtaW5hdG9yX2ludGVncmF0aW9ucycsXG5cdFx0XHQnbWFuYWdlX2Zvcm1pbmF0b3JfcmVwb3J0cycsXG5cdFx0XHQnbWFuYWdlX2Zvcm1pbmF0b3Jfc2V0dGluZ3MnLFxuXHRcdF07XG5cblx0XHRsZXQgcm9sZUltYWdlID0gPHNwYW4gY2xhc3NOYW1lPVwic3VpLWljb24tY29tbXVuaXR5LXBlb3BsZSBzdWktbWRcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+O1xuXHRcdGxldCByb2xlTmFtZSAgPSB0cmFuc2xhdGUoICdBZG1pbmlzdHJhdG9yJyApO1xuXHRcdGxldCByb2xlRGVzYyAgPSB0cmFuc2xhdGUoICdBbGwnICk7XG5cdFx0bGV0IGl0ZW1OYW1lICA9ICcnO1xuXG5cdFx0Ly8gU2V0IHRoZSByb2xlL3VzZXIgaW5mby5cblx0XHRpZiAoICEgaXNBZG1pbiApIHtcblx0XHRcdGlmICggJ3JvbGUnID09PSBwcm9wLnBlcm1pc3Npb25fdHlwZSApIHtcblx0XHRcdFx0Y29uc3QgY291bnRFeGNsdWRlZCA9IHByb3AuZXhjbHVkZV91c2Vycy5sZW5ndGg7XG5cblx0XHRcdFx0cm9sZU5hbWUgPSBmb3JtaW5hdG9yRGF0YS51c2VyUm9sZXNbcHJvcC51c2VyX3JvbGVdLm5hbWU7XG5cdFx0XHRcdHJvbGVEZXNjICs9IDAgIT09IGNvdW50RXhjbHVkZWQgP1xuXHRcdFx0XHRcdHRyYW5zbGF0ZSggJyBleGNlcHQgJyApICsgY291bnRFeGNsdWRlZCA6XG5cdFx0XHRcdFx0Jyc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCB1c2VycyA9IHByb3Auc3BlY2lmaWNfdXNlcjtcblx0XHRcdFx0bGV0IHRvb2x0aXBUZXh0ID0gJyc7XG5cdFx0XHRcdHJvbGVJbWFnZSA9IDxpbWcgc3JjPXsgcHJvcC5hdmF0YXIgfSB3aWR0aD1cIjMwXCIgaGVpZ2h0PVwiMzBcIiAvPjtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBhcmUgbW9yZSB0aGFuIDEgY2hvc2VuLlxuXHRcdFx0XHRpZiAoIHVzZXJzLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdFx0cm9sZU5hbWUgPSBwcm9wLnVzZXJfaW5mb1sgdXNlcnNbMF0gXS5uYW1lO1xuXHRcdFx0XHRcdHJvbGVOYW1lICs9ICcgKycgKyAoIHVzZXJzLmxlbmd0aCAtIDEgKSArICcgJztcblx0XHRcdFx0XHRyb2xlTmFtZSArPSB0cmFuc2xhdGUoICdtb3JlJyApO1xuXG5cdFx0XHRcdFx0cm9sZURlc2MgPSB1c2Vycy5sZW5ndGggKyB0cmFuc2xhdGUoICcgdXNlcnMnICk7XG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgdG9vbHRpcCB0ZXh0LlxuXHRcdFx0XHRcdGxldCBjb3VudGVyID0gMDtcblx0XHRcdFx0XHRfLm1hcCggcHJvcC51c2VyX2luZm8sICggaW5mbywgdXNlcklkICkgPT4ge1xuXHRcdFx0XHRcdFx0Y291bnRlcisrO1xuXHRcdFx0XHRcdFx0dG9vbHRpcFRleHQgKz0gaW5mby5uYW1lICsgJyAtICcgKyAnKCcgKyBpbmZvLmVtYWlsICsgJyknO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNvdW50ZXIgPCB1c2Vycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdHRvb2x0aXBUZXh0ICs9ICcsIFxcbic7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRpdGVtTmFtZSA9IDxzcGFuXG5cdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktdG9vbHRpcCBzdWktdG9vbHRpcC1jb25zdHJhaW5lZCBzdWktdG9vbHRpcC1yaWdodFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHlsZT17IHRvb2x0aXBXaWR0aCB9XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhLXRvb2x0aXA9eyB0b29sdGlwVGV4dCB9XG5cdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwiZnAtaXRlbS1uYW1lXCI+eyByb2xlTmFtZSB9PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj47XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBwcm9wLnVzZXJfaW5mbyApIHtcblx0XHRcdFx0XHRcdHJvbGVOYW1lID0gcHJvcC51c2VyX2luZm9bIHVzZXJzWzBdIF0ubmFtZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cm9sZURlc2MgPSBwcm9wLnVzZXJfaW5mb1sgdXNlcnNbMF0gXS5lbWFpbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCBpdGVtIG5hbWUgaGVyZSBmb3Igbm8gdG9vbHRpcHMuXG5cdFx0aWYgKCAnJyA9PT0gaXRlbU5hbWUgKSB7XG5cdFx0XHRpdGVtTmFtZSA9IDxzcGFuIGNsYXNzTmFtZT1cImZwLWl0ZW0tbmFtZVwiPnsgcm9sZU5hbWUgfTwvc3Bhbj47XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDx0cj5cblx0XHRcdFx0PHRkIGNvbFNwYW49eyA0IH0gY2xhc3NOYW1lPVwiIGZwLXJvbGUtaGVhZFwiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZnAtcm9sZS1ib3hcIj5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZnAtcm9sZS1pbWdcIj5cblx0XHRcdFx0XHRcdFx0eyByb2xlSW1hZ2UgfVxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZwLXJvbGUtaW5mb1wiPlxuXHRcdFx0XHRcdFx0XHR7IGl0ZW1OYW1lIH1cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwiZnAtaXRlbS1zdWJ0aXRsZVwiPnsgcm9sZURlc2MgfTwvc3Bhbj5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L3RkPlxuXG5cdFx0XHRcdHsgXy5tYXAoIGFjY2Vzc0xpc3QsICggYWNjZXNzLCB4ICkgPT4gKFxuXHRcdFx0XHRcdDxQZXJtaXNzaW9uSWNvbiBrZXk9eyB4IH0geyAuLi5wcm9wIH0gYWNjZXNzPXsgYWNjZXNzIH0gLz5cblx0XHRcdFx0KSApIH1cblxuXHRcdFx0XHQ8dGQgY29sU3Bhbj17IDEgfSBjbGFzc05hbWU9XCJmcC1wZXJtaXNzaW9uLWFjdGlvbnNcIj5cblx0XHRcdFx0XHR7ICEgaXNBZG1pbiAmJlxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmdWktZmllbGQtLWFjdGlvbnNcIj5cblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzdWktZHJvcGRvd25cIj5cblx0XHRcdFx0XHRcdFx0XHQ8YnV0dG9uIHJlZj17IHRoaXMucGVybWlzc2lvbk1lbnUgfSBjbGFzc05hbWU9XCJwZXJtaXNzaW9uLW1lbnUgc3VpLWJ1dHRvbi1pY29uIHN1aS1kcm9wZG93bi1hbmNob3JcIj5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1pY29uLXdpZGdldC1zZXR0aW5ncy1jb25maWdcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktc2NyZWVuLXJlYWRlci10ZXh0XCI+eyB0cmFuc2xhdGUoICdQZXJtaXNzaW9uIG9wdGlvbnMnICkgfTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHRcdFx0XHQ8dWw+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8bGk+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJmb3JtaW5hdG9yLWZpZWxkLWVkaXRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLnNob3dNb2RhbCB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktaWNvbi13aWRnZXQtc2V0dGluZ3MtY29uZmlnXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnRWRpdCcgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHRcdFx0XHRcdDxsaT5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cImZvcm1pbmF0b3ItZmllbGQtcmVtb3ZlIHN1aS1vcHRpb24tcmVkXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbkNsaWNrPXsgdGhpcy5kZWxldGVNb2RhbCB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktaWNvbi10cmFzaFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZSggJ0RlbGV0ZScgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHRcdFx0XHQ8L3VsPlxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0PC90ZD5cblx0XHRcdDwvdHI+XG5cdFx0KTtcblx0fVxuXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzLXBhZ2UvY29tcG9uZW50cy9wZXJtaXNzaW9ucy9wZXJtaXNzaW9uLWl0ZW0uanMiLCIvKiBqc2hpbnQgZXN2ZXJzaW9uOiA2ICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNUcnVlLCB0cmFuc2xhdGUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBlcm1pc3Npb25JY29uIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IHByb3AgPSB0aGlzLnByb3BzO1xuXHRcdGNvbnN0IGlzQWRtaW4gPSBwcm9wLmlzQWRtaW47XG5cdFx0Y29uc3QgdG9vbHRpcFdpZHRoID0geyBcIi0tdG9vbHRpcC13aWR0aFwiOiBcIjIyMHB4XCIgfTtcblxuXHRcdGxldCBpY29uLCB0b29sdGlwVGV4dDtcblx0XHRpZiAoIGlzQWRtaW4gfHwgaXNUcnVlKCBwcm9wWyBwcm9wLmFjY2VzcyBdICkgKSB7XG5cdFx0XHRpY29uID0gJ3N1aS1pY29uLWNoZWNrJztcblx0XHRcdHRvb2x0aXBUZXh0ID0gdHJhbnNsYXRlKCAnQ2FuJyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpY29uID0gJ3N1aS1pY29uLWxvY2snO1xuXHRcdFx0dG9vbHRpcFRleHQgPSB0cmFuc2xhdGUoIFwiQ2FuJ3RcIiApO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBzcGFjZS5cblx0XHR0b29sdGlwVGV4dCArPSAnICc7XG5cblx0XHQvLyBTZXQgdGhlIHRvb2x0aXAgdGV4dCBmb3IgZWFjaCBhY2Nlc3MuXG5cdFx0c3dpdGNoICggcHJvcC5hY2Nlc3MgKSB7XG5cdFx0XHRjYXNlICdtYW5hZ2VfZm9ybWluYXRvcl9tb2R1bGVzJzpcblx0XHRcdFx0dG9vbHRpcFRleHQgKz0gdHJhbnNsYXRlKCAnY3JlYXRlLCBlZGl0LCBhbmQgZGVsZXRlIG1vZHVsZXMgKEZvcm1zLCBQb2xscywgYW5kIFF1aXp6ZXMpLicgKTtcblxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ21hbmFnZV9mb3JtaW5hdG9yX3N1Ym1pc3Npb25zJzpcblx0XHRcdFx0dG9vbHRpcFRleHQgKz0gdHJhbnNsYXRlKCAndmlldyBhbmQgZGVsZXRlIHN1Ym1pc3Npb25zLicgKTtcblxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ21hbmFnZV9mb3JtaW5hdG9yX2FkZG9ucyc6XG5cdFx0XHRcdHRvb2x0aXBUZXh0ICs9IHRyYW5zbGF0ZSggJ2NvbmZpZ3VyZSBhZGQtb25zLicgKTtcblxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ21hbmFnZV9mb3JtaW5hdG9yX2ludGVncmF0aW9ucyc6XG5cdFx0XHRcdHRvb2x0aXBUZXh0ICs9IHRyYW5zbGF0ZSggJ2NvbmZpZ3VyZSBpbnRlZ3JhdGlvbnMuJyApO1xuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbWFuYWdlX2Zvcm1pbmF0b3JfcmVwb3J0cyc6XG5cdFx0XHRcdHRvb2x0aXBUZXh0ICs9IHRyYW5zbGF0ZSggJ2NvbmZpZ3VyZSByZXBvcnRzLicgKTtcblxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ21hbmFnZV9mb3JtaW5hdG9yX3NldHRpbmdzJzpcblx0XHRcdFx0aWYgKCBpc0FkbWluICkge1xuXHRcdFx0XHRcdHRvb2x0aXBUZXh0ICs9IHRyYW5zbGF0ZSggJ2NvbmZpZ3VyZSBhbGwgc2V0dGluZ3MuJyApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCAhIGlzVHJ1ZSggcHJvcFsgcHJvcC5hY2Nlc3MgXSApICkge1xuXHRcdFx0XHRcdHRvb2x0aXBUZXh0ICs9IHRyYW5zbGF0ZSggJ2NvbmZpZ3VyZSBzZXR0aW5ncy4nICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG9vbHRpcFRleHQgKz0gdHJhbnNsYXRlKCAnY29uZmlndXJlIHNldHRpbmdzIGV4Y2VwdCBwZXJtaXNzaW9ucy4nICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PHRkIGNvbFNwYW49eyAyIH0gY2xhc3NOYW1lPVwiZnAtaXRlbS1jb2xcIj5cblx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktdG9vbHRpcCBzdWktdG9vbHRpcC1jb25zdHJhaW5lZFwiXG5cdFx0XHRcdFx0c3R5bGU9eyB0b29sdGlwV2lkdGggfVxuXHRcdFx0XHRcdGRhdGEtdG9vbHRpcD17IHRvb2x0aXBUZXh0IH1cblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT17IGljb24gKyAnIHN1aS1zbScgfSBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdDwvdGQ+XG5cdFx0KTtcblx0fVxuXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzLXBhZ2UvY29tcG9uZW50cy9wZXJtaXNzaW9ucy9wZXJtaXNzaW9uLWljb24uanMiLCJpbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnO1xuXG5pbXBvcnQgTW9kYWwgZnJvbSAnLi4vY29tcG9uZW50cy9tb2RhbCc7XG5pbXBvcnQgKiBhcyBtb2RhbEFjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucy9tb2RhbCc7XG5pbXBvcnQgKiBhcyBwZXJtaXNzaW9uQWN0aW9ucyBmcm9tICcuLi9hY3Rpb25zL3Blcm1pc3Npb25zJztcblxuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzKCBzdGF0ZSApIHtcblx0cmV0dXJuIHtcblx0XHRwZXJtaXNzaW9uczogc3RhdGUucGVybWlzc2lvbnMgfHwge30sXG5cdFx0bW9kYWw6IHN0YXRlLm1vZGFsLFxuXHR9O1xufVxuXG5mdW5jdGlvbiBtYXBEaXNwYXRjaFRvUHJvcHMoIGRpc3BhdGNoICkge1xuXHRyZXR1cm4ge1xuXHRcdGFjdGlvbnM6IHtcblx0XHRcdHBlcm1pc3Npb25BY3Rpb25zOiBiaW5kQWN0aW9uQ3JlYXRvcnMoIHBlcm1pc3Npb25BY3Rpb25zLCBkaXNwYXRjaCApLFxuXHRcdFx0bW9kYWxBY3Rpb25zOiBiaW5kQWN0aW9uQ3JlYXRvcnMoIG1vZGFsQWN0aW9ucywgZGlzcGF0Y2ggKSxcblx0XHR9LFxuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KFxuXHRtYXBTdGF0ZVRvUHJvcHMsXG5cdG1hcERpc3BhdGNoVG9Qcm9wc1xuKSggTW9kYWwgKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy1wYWdlL2NvbnRhaW5lcnMvbW9kYWwuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbmltcG9ydCB7IGRlZmF1bHQgYXMgbW9kYWxUeXBlcyB9IGZyb20gJy4vbW9kYWxzL2luZGV4Jztcbi8vIGltcG9ydCBGb2N1c1RyYXAgZnJvbSAnLi9tb2RhbHMvcGFydGlhbHMvZm9jdXMtdHJhcCc7XG5pbXBvcnQgZGlzcGxhY2UgZnJvbSAncmVhY3QtZGlzcGxhY2UnO1xuXG5jb25zdCBNT0RBTF9UWVBFUyA9IHtcblx0cGVybWlzc2lvbnM6IG1vZGFsVHlwZXMucGVybWlzc2lvbnNNb2RhbCxcblx0cGVybWlzc2lvbkRlbGV0ZTogbW9kYWxUeXBlcy5wZXJtaXNzaW9uRGVsZXRlTW9kYWwsXG59O1xuXG4vKiBnbG9iYWwgc2V0VGltZW91dCxjbGVhclRpbWVvdXQgKi9cbmNsYXNzIE1vZGFsIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXHR9XG5cblx0Y29tcG9uZW50RGlkVXBkYXRlKCBwcmV2UHJvcHMgKSB7XG5cdFx0dGhpcy4kZWwgPSBqUXVlcnkoIHRoaXMuZWwgKTtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblxuXHRcdGlmICggISBfLmlzRW1wdHkoIHByZXZQcm9wcy5tb2RhbCApIC8qICYmICEgXy5pc051bGwoIHRoaXMucHJvcHMubW9kYWwubW9kYWxUeXBlICkgKi8gKSB7XG5cdFx0XHRpZiAoIHByZXZQcm9wcy5tb2RhbC5tb2RhbFByb3BzLm9wZW4gIT09IHRoaXMucHJvcHMubW9kYWwubW9kYWxQcm9wcy5vcGVuICkge1xuXHRcdFx0XHRjb25zdCBtb2RhbEVsZW1lbnQgPSBSZWFjdERPTS5maW5kRE9NTm9kZSggdGhpcyApO1xuXG5cdFx0XHRcdGlmICggdGhpcy5wcm9wcy5tb2RhbC5tb2RhbFByb3BzLm9wZW4gKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1c0FmdGVyQ2xvc2VkID0gdGhpcy5wcm9wcy5tb2RhbC5tb2RhbFByb3BzLmFjdGl2ZUVsZW1lbnQ7XG5cblx0XHRcdFx0XHRjb25zdCBmb2N1c0ZpcnN0ID0gdGhpcy5wcm9wcy5tb2RhbC5tb2RhbFByb3BzLmZvY3VzRmlyc3Q7XG5cblx0XHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggJ3N0cmluZycgPT09IHR5cGVvZiBmb2N1c0ZpcnN0ICkge1xuXHRcdFx0XHRcdFx0XHRzZWxmLmZvY3VzRmlyc3QgPSBzZWxmLiRlbC5maW5kKCBmb2N1c0ZpcnN0ICk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAnb2JqZWN0JyA9PT0gdHlwZW9mIGZvY3VzRmlyc3QgKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYuZm9jdXNGaXJzdCA9IGZvY3VzRmlyc3Q7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzZWxmLmZvY3VzRmlyc3QgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIHNlbGYuZm9jdXNGaXJzdCAmJiBzZWxmLmZvY3VzRmlyc3QubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRzZWxmLnNldEZvY3VzKCBzZWxmLmZvY3VzRmlyc3QuZmlyc3QoKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIDMyMCApO1xuXG5cdFx0XHRcdFx0alF1ZXJ5KCAnI3dwd3JhcCcgKS5hdHRyKCAnYXJpYS1oaWRkZW4nLCAndHJ1ZScgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggISB0aGlzLnByb3BzLm1vZGFsLm1vZGFsUHJvcHMub3BlbiApIHtcblx0XHRcdFx0XHRqUXVlcnkoICcjd3B3cmFwJyApLmF0dHIoICdhcmlhLWhpZGRlbicsICdmYWxzZScgKTtcblxuXHRcdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c2VsZi5zZXRGb2N1cyggc2VsZi5mb2N1c0FmdGVyQ2xvc2VkICk7XG5cdFx0XHRcdFx0fSwgMzIwICk7XG5cblx0XHRcdFx0XHR0aGlzLmhpZGVNb2RhbFRpbWVvdXQgPSBzZXRUaW1lb3V0KCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRtb2RhbEVsZW1lbnQuc2V0QXR0cmlidXRlKCAnYXJpYS1oaWRkZW4nLCAndHJ1ZScgKTtcblx0XHRcdFx0XHRcdC8vIGNsZWFudXBcblx0XHRcdFx0XHRcdHRoaXMucHJvcHMubW9kYWwubW9kYWxUeXBlID0gbnVsbDtcblx0XHRcdFx0XHRcdHRoaXMuZm9yY2VVcGRhdGUoKTtcblx0XHRcdFx0XHR9LCAzMDAgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtb2RhbEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCAnYXJpYS1oaWRkZW4nICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRzZXRGb2N1cyggZWxlbWVudCApIHtcblx0XHRjb25zdCBmb2N1c0ludGVydmFsID0gMTA7IC8vIG1zLCB0aW1lIGJldHdlZW4gZnVuY3Rpb24gY2FsbHNcblx0XHRjb25zdCBmb2N1c1RvdGFsUmVwZXRpdGlvbnMgPSAxMDsgLy8gbnVtYmVyIG9mIHJlcGV0aXRpb25zXG5cblx0XHRpZiAoIHR5cGVvZiBlbGVtZW50ID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRlbGVtZW50LmF0dHIoICd0YWJpbmRleCcsICcwJyApO1xuXHRcdGVsZW1lbnQuYmx1cigpO1xuXG5cdFx0bGV0IGZvY3VzUmVwZXRpdGlvbnMgPSAwO1xuXHRcdGNvbnN0IGludGVydmFsID0gd2luZG93LnNldEludGVydmFsKCBmdW5jdGlvbigpIHtcblx0XHRcdGVsZW1lbnQuZm9jdXMoKTtcblx0XHRcdGZvY3VzUmVwZXRpdGlvbnMrKztcblxuXHRcdFx0aWYgKCBmb2N1c1JlcGV0aXRpb25zID49IGZvY3VzVG90YWxSZXBldGl0aW9ucyApIHtcblx0XHRcdFx0d2luZG93LmNsZWFySW50ZXJ2YWwoIGludGVydmFsICk7XG5cdFx0XHR9XG5cdFx0fSwgZm9jdXNJbnRlcnZhbCApO1xuXHR9XG5cblx0Y29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLmhpZGVNb2RhbFRpbWVvdXQgKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRpZiAoXG5cdFx0XHRfLmlzVW5kZWZpbmVkKCB0aGlzLnByb3BzLm1vZGFsICkgfHxcblx0XHRcdF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMubW9kYWwubW9kYWxQcm9wcyApIHx8XG5cdFx0XHRfLmlzTnVsbCggdGhpcy5wcm9wcy5tb2RhbC5tb2RhbFR5cGUgKVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0bGV0IG1vZGFsQ2xhc3MgPSAnc3VpLW1vZGFsLWxnJztcblx0XHRsZXQgb3ZlcmxheUNsYXNzID0gWyAnc3VpLW1vZGFsLWNvbnRlbnQnLCAnc3VpLWNvbnRlbnQtZmFkZS1pbicgXTtcblx0XHRpZiAoICEgdGhpcy5wcm9wcy5tb2RhbC5tb2RhbFByb3BzLm9wZW4gKSB7XG5cdFx0XHRvdmVybGF5Q2xhc3MgPSBbICdzdWktbW9kYWwtY29udGVudCcsICdzdWktY29udGVudC1mYWRlLW91dCcgXTtcblx0XHR9XG5cblx0XHRjb25zdCBtb2RhbFR5cGUgXHQgPSB0aGlzLnByb3BzLm1vZGFsLm1vZGFsVHlwZTtcblx0XHRjb25zdCBTcGVjaWZpZWRNb2RhbCA9IE1PREFMX1RZUEVTWyBtb2RhbFR5cGUgXTtcblxuXHRcdGlmICggJ3B1Ymxpc2gnID09PSBtb2RhbFR5cGUgKSB7XG5cdFx0XHRtb2RhbENsYXNzID0gJ3N1aS1tb2RhbC1zbSBmdWktZGlhbG9nLXB1Ymxpc2gnO1xuXHRcdH1cblxuXHRcdGlmICggJ3Nob3J0Y29kZScgPT09IG1vZGFsVHlwZSApIHtcblx0XHRcdG1vZGFsQ2xhc3MgPSAnc3VpLW1vZGFsLXNtIGZ1aS1kaWFsb2ctcHVibGlzaCc7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc21Nb2RhbFR5cGUgPSBbJ3Blcm1pc3Npb25EZWxldGUnXTtcblx0XHRpZiAoIHNtTW9kYWxUeXBlLmluY2x1ZGVzKCBtb2RhbFR5cGUgKSApIHtcblx0XHRcdG1vZGFsQ2xhc3MgPSAnc3VpLW1vZGFsLXNtJztcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHQhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMubW9kYWwubW9kYWxQcm9wcyApICYmXG5cdFx0XHQhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMubW9kYWwubW9kYWxQcm9wcy5maWVsZCApICYmXG5cdFx0XHQhIF8uaXNVbmRlZmluZWQoIHRoaXMucHJvcHMubW9kYWwubW9kYWxQcm9wcy5maWVsZC50eXBlIClcblx0XHQpIHtcblx0XHRcdGNvbnN0IGZpZWxkVHlwZSA9IHRoaXMucHJvcHMubW9kYWwubW9kYWxQcm9wcy5maWVsZC50eXBlO1xuXG5cdFx0XHRpZiAoIGZpZWxkVHlwZSA9PT0gJ3JhZGlvJyB8fCBmaWVsZFR5cGUgPT09ICdjaGVja2JveCcgfHwgZmllbGRUeXBlID09PSAnc2VsZWN0JyApIHtcblx0XHRcdFx0bW9kYWxDbGFzcyArPSAnIG11bHRpdmFsdWUtbW9kYWwnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bW9kYWxDbGFzcyArPSAnICcgKyB0aGlzLnByb3BzLm1vZGFsLm1vZGFsUHJvcHMuZmllbGQudHlwZSArICctbW9kYWwnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IGNsYXNzZXMgPSBqUXVlcnkoICcuc3VpLWNvbG9yLWFjY2Vzc2libGUnICkubGVuZ3RoID8gJ3N1aS13cmFwIHN1aS1jb2xvci1hY2Nlc3NpYmxlJyA6ICdzdWktd3JhcCc7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9eyBjbGFzc2VzIH0+XG5cblx0XHRcdFx0PGRpdiBpZD1cImZvcm1pbmF0b3ItbW9kYWxcIiBjbGFzc05hbWU9eyBgc3VpLW1vZGFsIHN1aS1hY3RpdmUgJHsgbW9kYWxDbGFzcyB9ICR7IG1vZGFsVHlwZSB9YCB9PlxuXG5cdFx0XHRcdFx0ey8qIDxGb2N1c1RyYXA+ICovfVxuXG5cdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0cm9sZT1cImRpYWxvZ1wiXG5cdFx0XHRcdFx0XHRpZD17IGBtb2RhbC0keyB0aGlzLnByb3BzLm1vZGFsLm1vZGFsUHJvcHMuaWQgfWAgfVxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXsgYCR7IG92ZXJsYXlDbGFzcy5qb2luKCAnICcgKSB9YCB9XG5cdFx0XHRcdFx0XHRhcmlhLW1vZGFsPVwidHJ1ZVwiXG5cdFx0XHRcdFx0XHRhcmlhLWxpdmU9XCJwb2xpdGVcIlxuXHRcdFx0XHRcdFx0eyAuLi4oIHRoaXMucHJvcHMubW9kYWwubW9kYWxQcm9wcy5sYWJlbGxlZEJ5ICYmXG5cdFx0XHRcdFx0XHRcdFx0eyAnYXJpYS1sYWJlbGxlZGJ5JzogdGhpcy5wcm9wcy5tb2RhbC5tb2RhbFByb3BzLmxhYmVsbGVkQnkgfVxuXHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0XHR7IC4uLiggdGhpcy5wcm9wcy5tb2RhbC5tb2RhbFByb3BzLmRlc2NyaWJlZEJ5ICYmXG5cdFx0XHRcdFx0XHRcdFx0eyAnYXJpYS1kZXNjcmliZWRieSc6IHRoaXMucHJvcHMubW9kYWwubW9kYWxQcm9wcy5kZXNjcmliZWRCeSB9XG5cdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHRcdHJlZj17IGVsID0+ICggdGhpcy5lbCA9IGVsICkgfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveFwiIHN0eWxlPXsgeyBtYXJnaW5Cb3R0b206IDAgfSB9PlxuXHRcdFx0XHRcdFx0XHQ8U3BlY2lmaWVkTW9kYWwgeyAuLi50aGlzLnByb3BzIH0gLz5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0ey8qIDwvRm9jdXNUcmFwPiAqL31cblxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxufVxuXG5jb25zdCBEaXNwbGFjZWRNb2RhbCA9IGRpc3BsYWNlKCBNb2RhbCApO1xuXG5EaXNwbGFjZWRNb2RhbC5yZW5kZXJUbyA9IGZ1bmN0aW9uKCBpbnB1dCApIHtcblx0cmV0dXJuIGRpc3BsYWNlKCBNb2RhbCwgeyByZW5kZXJUbzogaW5wdXQgfSApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaXNwbGFjZWRNb2RhbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zZXR0aW5ncy1wYWdlL2NvbXBvbmVudHMvbW9kYWwuanMiLCJpbXBvcnQgcGVybWlzc2lvbnNNb2RhbCBmcm9tICcuL3Blcm1pc3Npb25zJztcbmltcG9ydCBwZXJtaXNzaW9uRGVsZXRlTW9kYWwgZnJvbSAnLi9wZXJtaXNzaW9uLWRlbGV0ZSc7XG5cbmNvbnN0IG1vZGFsVHlwZXMgPSB7XG5cdHBlcm1pc3Npb25zTW9kYWwsXG5cdHBlcm1pc3Npb25EZWxldGVNb2RhbCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1vZGFsVHlwZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MtcGFnZS9jb21wb25lbnRzL21vZGFscy9pbmRleC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHFzIGZyb20gJ3FzJztcbmltcG9ydCB7IHJhbmROdW1iZXIsIGlzRW1haWxXcCwgdHJhbnNsYXRlLCBpc1RydWUgfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5cbmltcG9ydCBOb3RpZmljYXRpb24gZnJvbSAnLi4vLi4vLi4vbm90aWZpY2F0aW9ucyc7XG5pbXBvcnQgTW9kYWxIZWFkZXIgZnJvbSAnLi4vLi4vLi4vZm9ybS9jb21wb25lbnRzL21vZGFscy9wYXJ0aWFscy9oZWFkZXInO1xuaW1wb3J0IE1vZGFsVGl0bGUgZnJvbSAnLi4vLi4vLi4vZm9ybS9jb21wb25lbnRzL21vZGFscy9wYXJ0aWFscy90aXRsZSc7XG5pbXBvcnQgTW9kYWxGb290ZXIgZnJvbSAnLi4vLi4vLi4vZm9ybS9jb21wb25lbnRzL21vZGFscy9wYXJ0aWFscy9mb290ZXInO1xuaW1wb3J0IE1vZGFsQ2xvc2UgZnJvbSAnLi4vLi4vLi4vZm9ybS9jb21wb25lbnRzL21vZGFscy9wYXJ0aWFscy9jbG9zZSc7XG5pbXBvcnQgUmFkaW9UYWJzIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9yYWRpby10YWJzJztcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MvY29udGFpbmVycy9jb250YWluZXInO1xuaW1wb3J0IFN1aVNlbGVjdCBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvc3VpLXNlbGVjdCc7XG5pbXBvcnQgU3VpVGFncyBmcm9tICcuLi8uLi8uLi9zZXR0aW5ncy9pbnB1dHMvc3VpLXRhZ3MnO1xuaW1wb3J0IENoZWNrYm94IGZyb20gJy4uLy4uLy4uL3NldHRpbmdzL2lucHV0cy9jaGVja2JveCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHBlcm1pc3Npb25zTW9kYWwgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvciggcHJvcHMgKSB7XG5cdFx0c3VwZXIoIHByb3BzICk7XG5cblx0XHR0aGlzLnNhdmVCdG4gPSBSZWFjdC5jcmVhdGVSZWYoKTtcblx0XHR0aGlzLmNsb3NlTW9kYWwgPSB0aGlzLnByb3BzLm1vZGFsLm1vZGFsUHJvcHMuY2xvc2VNb2RhbC5iaW5kKCB0aGlzICk7XG5cdFx0dGhpcy51cGRhdGVQcm9wZXJ0eSA9IHRoaXMudXBkYXRlUHJvcGVydHkuYmluZCggdGhpcyApO1xuXHRcdHRoaXMuc2F2ZVBlcm1pc3Npb24gPSB0aGlzLnNhdmVQZXJtaXNzaW9uLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLnZhbGlkYXRvciA9IHRoaXMudmFsaWRhdG9yLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLnNob3dOb3RpZmljYXRpb24gPSB0aGlzLnNob3dOb3RpZmljYXRpb24uYmluZCggdGhpcyApO1xuXG5cdFx0dGhpcy51cGRhdGVkID0gZmFsc2U7XG5cdFx0dGhpcy5tb2RhbERhdGEgPSBPYmplY3QuYXNzaWduKCB7fSwgdGhpcy5wcm9wcy5tb2RhbC5tb2RhbFByb3BzICk7XG5cdFx0dGhpcy51c2VyUm9sZXMgPSB0aGlzLmdldFVzZXJSb2xlcyggT2JqZWN0LmFzc2lnbigge30sIGZvcm1pbmF0b3JEYXRhLnVzZXJSb2xlcyApICk7XG5cdFx0dGhpcy5kZWZhdWx0Um9sZSA9IE9iamVjdC5rZXlzKCB0aGlzLnVzZXJSb2xlcyApWzBdO1xuXG5cdFx0Y29uc3QgZGVmYXVsdFR5cGUgPSBfLmlzRW1wdHkoIHRoaXMudXNlclJvbGVzICkgPyAnc3BlY2lmaWMnIDogJ3JvbGUnO1xuXG5cdFx0Ly8gRm9yIGFsbCBhZGRpdGlvbmFsIGFjY2VzcyBpbiB0aGUgZnV0dXJlLFxuXHRcdC8vIG1ha2Ugc3VyZSB0byBhZGQgaXQgYWxzbyBpbiB0aGUgdmFsaWRhdG9yIGluIHJlbmRlci5cblx0XHR0aGlzLnN0YXRlID0ge1xuXHRcdFx0cGlkOiAgICAgICAgICAgICB0aGlzLm1vZGFsRGF0YS5waWQgfHwgJycsXG5cdFx0XHRwZXJtaXNzaW9uX3R5cGU6IHRoaXMubW9kYWxEYXRhLnBlcm1pc3Npb25fdHlwZSB8fCBkZWZhdWx0VHlwZSxcblx0XHRcdHVzZXJfcm9sZTogICAgICAgdGhpcy5tb2RhbERhdGEudXNlcl9yb2xlIHx8IHRoaXMuZGVmYXVsdFJvbGUsXG5cdFx0XHRleGNsdWRlX3VzZXJzOiAgIHRoaXMubW9kYWxEYXRhLmV4Y2x1ZGVfdXNlcnMgfHwgW10sXG5cdFx0XHRzcGVjaWZpY191c2VyOiAgIHRoaXMubW9kYWxEYXRhLnNwZWNpZmljX3VzZXIgfHwgW10sXG5cdFx0XHRhdmF0YXI6ICAgICAgICAgIHRoaXMubW9kYWxEYXRhLmF2YXRhciB8fCAnJyxcblx0XHRcdHVzZXJfaW5mbzogICB0aGlzLm1vZGFsRGF0YS51c2VyX2luZm8gfHwgW10sXG5cdFx0XHRtYW5hZ2VfZm9ybWluYXRvcl9tb2R1bGVzOiAgICAgIHRoaXMubW9kYWxEYXRhLm1hbmFnZV9mb3JtaW5hdG9yX21vZHVsZXMgfHwgZmFsc2UsXG5cdFx0XHRtYW5hZ2VfZm9ybWluYXRvcl9zdWJtaXNzaW9uczogIHRoaXMubW9kYWxEYXRhLm1hbmFnZV9mb3JtaW5hdG9yX3N1Ym1pc3Npb25zIHx8IGZhbHNlLFxuXHRcdFx0bWFuYWdlX2Zvcm1pbmF0b3JfYWRkb25zOiAgICAgICB0aGlzLm1vZGFsRGF0YS5tYW5hZ2VfZm9ybWluYXRvcl9hZGRvbnMgfHwgZmFsc2UsXG5cdFx0XHRtYW5hZ2VfZm9ybWluYXRvcl9pbnRlZ3JhdGlvbnM6IHRoaXMubW9kYWxEYXRhLm1hbmFnZV9mb3JtaW5hdG9yX2ludGVncmF0aW9ucyB8fCBmYWxzZSxcblx0XHRcdG1hbmFnZV9mb3JtaW5hdG9yX3JlcG9ydHM6ICAgICAgdGhpcy5tb2RhbERhdGEubWFuYWdlX2Zvcm1pbmF0b3JfcmVwb3J0cyB8fCBmYWxzZSxcblx0XHRcdG1hbmFnZV9mb3JtaW5hdG9yX3NldHRpbmdzOiAgICAgdGhpcy5tb2RhbERhdGEubWFuYWdlX2Zvcm1pbmF0b3Jfc2V0dGluZ3MgfHwgZmFsc2UsXG5cdFx0XHRjdXJyZW50X3VzZXI6IHRoaXMubW9kYWxEYXRhLmN1cnJlbnRVc2VyIHx8IFtdXG5cdFx0fVxuXHR9XG5cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0dGhpcy4kc2F2ZUJ0biA9IGpRdWVyeSggdGhpcy5zYXZlQnRuLmN1cnJlbnQgKTtcblx0fVxuXG5cdGNvbXBvbmVudERpZFVwZGF0ZSggcHJldlByb3BzLCBwcmV2U3RhdGUgKSB7XG5cdFx0aWYgKCBKU09OLnN0cmluZ2lmeSggdGhpcy5zdGF0ZSApICE9PSBKU09OLnN0cmluZ2lmeSggcHJldlN0YXRlICkgKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZWQgPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnVwZGF0ZWQgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0XHR0aGlzLiRzYXZlQnRuLm9mZjtcblx0fVxuXG5cdC8vIFJlbW92ZSB1c2VyIHJvbGVzIHRoYXQgd2VyZSBhbHJlYWR5IHNldC5cblx0Z2V0VXNlclJvbGVzKCB1c2VyUm9sZXMgKSB7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0XHQvLyBSZW1vdmUgYWRtaW4gZmlyc3QuXG5cdFx0ZGVsZXRlIHVzZXJSb2xlc1snYWRtaW5pc3RyYXRvciddO1xuXG5cdFx0Xy5mb3JFYWNoKCB1c2VyUm9sZXMsIGZ1bmN0aW9uKCB2YWwsIHJvbGUgKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCEgXy5pc1VuZGVmaW5lZChcblx0XHRcdFx0XHRfLmZpbmQoIHNlbGYucHJvcHMucGVybWlzc2lvbnMsIGZ1bmN0aW9uKCBwICkgeyByZXR1cm4gcC51c2VyX3JvbGUgPT09IHJvbGU7IH0gKVxuXHRcdFx0XHQpXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCggISBzZWxmLm1vZGFsRGF0YS5uZXcgJiYgcm9sZSAhPT0gc2VsZi5tb2RhbERhdGEudXNlcl9yb2xlICkgfHxcblx0XHRcdFx0XHRzZWxmLm1vZGFsRGF0YS5uZXdcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHVzZXJSb2xlc1sgcm9sZSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIHVzZXJSb2xlcztcblx0fVxuXG5cdC8vIE1ha2UgaXQgcG9zc2libGUgdG8gdXBkYXRlIHN0YXRlIGZyb20gY2hpbGQgY29tcG9uZW50c1xuXHR1cGRhdGVQcm9wZXJ0eSggc2x1ZywgdmFsdWUgKSB7XG5cdFx0dGhpcy5zZXRTdGF0ZSggeyBbIHNsdWcgXTogdmFsdWUgfSApO1xuXHR9XG5cblx0Z2V0VXNlclRhZ3NPcHRpb25zKCAkcHJvcGVydHkgKSB7XG5cdFx0Y29uc3Qgc2VhcmNoRGF0YSA9ICggcGFyYW1zICkgPT4ge1xuXHRcdFx0bGV0IGFyZ3MgPSB7XG5cdFx0XHRcdGFjdGlvbjogJ2Zvcm1pbmF0b3JfYnVpbGRlcl9zZWFyY2hfZW1haWxzJyxcblx0XHRcdFx0X3dwbm9uY2U6IGZvcm1pbmF0b3JEYXRhLnNlYXJjaE5vbmNlLFxuXHRcdFx0XHRleGNsdWRlX2FkbWluczogdHJ1ZSxcblx0XHRcdFx0cTogcGFyYW1zLnRlcm0sXG5cdFx0XHRcdHBlcm1pc3Npb246ICdmb3JtaW5hdG9yLXNldHRpbmdzJyxcblx0XHRcdFx0cGlkOiB0aGlzLnN0YXRlLnBpZCxcblx0XHRcdFx0cHJvcGVydHk6ICRwcm9wZXJ0eSxcblx0XHRcdFx0aXNfcGVybWlzc2lvbjogdHJ1ZVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gU2VhcmNoIHVzZXJzIGZyb20gY2hvc2VuIHJvbGUuXG5cdFx0XHRpZiAoICdyb2xlJyA9PT0gdGhpcy5zdGF0ZS5wZXJtaXNzaW9uX3R5cGUgKSB7XG5cdFx0XHRcdGFyZ3Mucm9sZSA9IHRoaXMuc3RhdGUudXNlcl9yb2xlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJncztcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRhZ3M6IGZhbHNlLFxuXHRcdFx0bWluaW11bUlucHV0TGVuZ3RoOiAxLFxuXHRcdFx0dG9rZW5TZXBhcmF0b3JzOiBbICcsJywgJyAnIF0sXG5cdFx0XHRwbGFjZWhvbGRlcjogdHJhbnNsYXRlKCAnQ2xpY2sgdG8gc2VhcmNoIGEgdXNlcuKApicgKSxcblx0XHRcdGxhbmd1YWdlOiB7XG5cdFx0XHRcdHNlYXJjaGluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRyYW5zbGF0ZSggJ1NlYXJjaGluZycgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0bm9SZXN1bHRzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJhbnNsYXRlKCAnVXNlciBub3QgZm91bmQnICk7XG5cdFx0XHRcdH0sXG5cdFx0XHR9LFxuXHRcdFx0YWpheDoge1xuXHRcdFx0XHR1cmw6IGZvcm1pbmF0b3JEYXRhLmFqYXhVcmwsXG5cdFx0XHRcdHR5cGU6ICdQT1NUJyxcblx0XHRcdFx0ZGVsYXk6IDE1MCxcblx0XHRcdFx0ZGF0YTogZnVuY3Rpb24oIHBhcmFtcyApIHtcblx0XHRcdFx0XHRyZXR1cm4gc2VhcmNoRGF0YSggcGFyYW1zICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHByb2Nlc3NSZXN1bHRzOiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0cmVzdWx0czogZGF0YS5kYXRhLFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNhY2hlOiB0cnVlLFxuXHRcdFx0fSxcblx0XHRcdHRlbXBsYXRlUmVzdWx0OiBmdW5jdGlvbiggcmVzdWx0ICkge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ISBfLmlzVW5kZWZpbmVkKCByZXN1bHQuaWQgKSAmJlxuXHRcdFx0XHRcdCEgXy5pc1VuZGVmaW5lZCggcmVzdWx0LnRleHQgKSAmJlxuXHRcdFx0XHRcdCEgXy5pc1VuZGVmaW5lZCggcmVzdWx0LmRpc3BsYXlfbmFtZSApXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkoXG5cdFx0XHRcdFx0XHQnPHNwYW4+JyArXG5cdFx0XHRcdFx0XHRyZXN1bHQuZGlzcGxheV9uYW1lICtcblx0XHRcdFx0XHRcdCcgJyArXG5cdFx0XHRcdFx0XHQnKCcgK1xuXHRcdFx0XHRcdFx0cmVzdWx0LnRleHQgK1xuXHRcdFx0XHRcdFx0JyknICtcblx0XHRcdFx0XHRcdCc8L3NwYW4+J1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0LnRleHQ7XG5cdFx0XHR9LFxuXHRcdFx0Y3JlYXRlVGFnOiBmdW5jdGlvbiggcGFyYW1zICkge1xuXHRcdFx0XHRjb25zdCB0ZXJtID0gcGFyYW1zLnRlcm0udHJpbSgpO1xuXHRcdFx0XHRpZiAoICEgaXNFbWFpbFdwKCB0ZXJtICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpZDogdGVybSxcblx0XHRcdFx0XHR0ZXh0OiB0ZXJtLFxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHR9O1xuXHR9XG5cblx0c2hvd05vdGlmaWNhdGlvbiggdHlwZSwgbXNnICkge1xuXHRcdGNvbnN0IGN1c3RvbSA9IG5ldyBOb3RpZmljYXRpb24oIHtcblx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHR0ZXh0OiAnZXJyb3InID09PSB0eXBlID9cblx0XHRcdFx0dHJhbnNsYXRlKCAnU29tZXRoaW5nIHdlbnQgd3JvbmcuIFBsZWFzZSB0cnkgYWdhaW4uJyApIDpcblx0XHRcdFx0bXNnLFxuXHRcdH0gKTtcblxuXHRcdGN1c3RvbS5vcGVuKCk7XG5cblx0XHRpZiAoICdlcnJvcicgPT09IHR5cGUgKSB7XG5cdFx0XHRjb25zb2xlLmxvZyggbXNnICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jbG9zZU1vZGFsKCk7XG5cdH1cblxuXHRzYXZlUGVybWlzc2lvbigpIHtcblx0XHQvLyBJZiBubyB1cGRhdGVzIHdlcmUgbWFkZSwganVzdCBjbG9zZSB0aGUgbW9kYWwuXG5cdFx0aWYgKCAhIGlzVHJ1ZSggdGhpcy5tb2RhbERhdGEubmV3ICkgJiYgISB0aGlzLnVwZGF0ZWQgKSB7XG5cdFx0XHR0aGlzLmNsb3NlTW9kYWwoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBvbmxvYWQgY2xhc3MuXG5cdFx0dGhpcy4kc2F2ZUJ0bi5hZGRDbGFzcygnc3VpLWJ1dHRvbi1vbmxvYWQnKTtcblx0XHR0aGlzLiRzYXZlQnRuLnByb3AoICdkaXNhYmxlZCcsIHRydWUgKTtcblxuXHRcdGNvbnN0IHBlcm1pc3Npb24gPSBPYmplY3QuYXNzaWduKCB7fSwgdGhpcy5zdGF0ZSApO1xuXHRcdGxldCBuZXdTdGF0ZTtcblx0XHRsZXQgcGVybWlzc2lvbnNEYXRhID0ge1xuXHRcdFx0YWN0aW9uOiAnZm9ybWluYXRvcl9zYXZlX3Blcm1pc3Npb25zJyxcblx0XHRcdF93cG5vbmNlOiBmb3JtaW5hdG9yRGF0YS5wZXJtaXNzaW9uX25vbmNlLFxuXHRcdH07XG5cblx0XHQvLyBEZWxldGUgdW5uZWNlc3NhcnkgZGF0YS5cblx0XHRpZiAoICdyb2xlJyA9PT0gcGVybWlzc2lvbi5wZXJtaXNzaW9uX3R5cGUgKSB7XG5cdFx0XHRkZWxldGUgcGVybWlzc2lvbi5zcGVjaWZpY191c2VyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgcGVybWlzc2lvbi51c2VyX3JvbGU7XG5cdFx0XHRkZWxldGUgcGVybWlzc2lvbi5leGNsdWRlX3VzZXJzO1xuXHRcdH1cblxuXHRcdC8vIFdlIGhhdmUgYSBuZXcgcGVybWlzc2lvbiwgaW5zZXJ0IG5ldyBvbmUuXG5cdFx0aWYgKCB0aGlzLm1vZGFsRGF0YS5uZXcgKSB7XG5cdFx0XHRwZXJtaXNzaW9uc0RhdGEubW9kZSA9ICduZXcnO1xuXG5cdFx0XHQvLyBBZGQgcGVybWlzc2lvbiBJRC5cblx0XHRcdHBlcm1pc3Npb24ucGlkID0gJ3BpZC0nICsgcmFuZE51bWJlcigpICsgJy0nICsgcmFuZE51bWJlcigpO1xuXG5cdFx0XHRuZXdTdGF0ZSA9IFtcblx0XHRcdFx0Li4udGhpcy5wcm9wcy5wZXJtaXNzaW9ucyxcblx0XHRcdFx0cGVybWlzc2lvbixcblx0XHRcdF07XG5cblx0XHQvLyBSZXBsYWNlIGVkaXRlZCBwZXJtaXNzaW9uLlxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwZXJtaXNzaW9uc0RhdGEubW9kZSA9ICdlZGl0Jztcblx0XHRcdHBlcm1pc3Npb25zRGF0YS5waWQgPSBwZXJtaXNzaW9uLnBpZDtcblxuXHRcdFx0bmV3U3RhdGUgPSB0aGlzLnByb3BzLnBlcm1pc3Npb25zO1xuXHRcdFx0Y29uc3QgY3VycmVudFBlcm1pc3Npb24gPSBfLmZpbmRJbmRleCggbmV3U3RhdGUsIGZ1bmN0aW9uKCBwICkge1xuXHRcdFx0XHRyZXR1cm4gcC5waWQgPT09IHBlcm1pc3Npb24ucGlkO1xuXHRcdFx0fSApO1xuXG5cdFx0XHRuZXdTdGF0ZS5zcGxpY2UoXG5cdFx0XHRcdGN1cnJlbnRQZXJtaXNzaW9uLFxuXHRcdFx0XHQxLFxuXHRcdFx0XHRwZXJtaXNzaW9uXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHBlcm1pc3Npb25zRGF0YS5wZXJtaXNzaW9ucyA9IEpTT04uc3RyaW5naWZ5KCBuZXdTdGF0ZSApO1xuXG5cdFx0YXhpb3MucG9zdCggZm9ybWluYXRvckRhdGEuYWpheFVybCxcblx0XHRcdHFzLnN0cmluZ2lmeSggcGVybWlzc2lvbnNEYXRhIClcblx0XHQpXG5cdFx0XHQudGhlbiggKCBkYXRhICkgPT4ge1xuXHRcdFx0XHRsZXQgbm90aWZUeXBlLCBub3RpZk1lc3NhZ2U7XG5cblx0XHRcdFx0aWYgKCBkYXRhLmRhdGEuc3VjY2VzcyApIHtcblx0XHRcdFx0XHR0aGlzLnByb3BzLmFjdGlvbnMucGVybWlzc2lvbkFjdGlvbnMudXBkYXRlUGVybWlzc2lvbnMoIGRhdGEuZGF0YS5kYXRhICk7XG5cblx0XHRcdFx0XHRub3RpZlR5cGUgPSAnc3VjY2Vzcyc7XG5cdFx0XHRcdFx0bm90aWZNZXNzYWdlID0gdGhpcy5tb2RhbERhdGEubmV3ID9cblx0XHRcdFx0XHRcdHRyYW5zbGF0ZSggJ05ldyBwZXJtaXNzaW9uIGFkZGVkIHN1Y2Nlc3NmdWxseSEnICkgOlxuXHRcdFx0XHRcdFx0dHJhbnNsYXRlKCAnUGVybWlzc2lvbiB1cGRhdGVkIHN1Y2Nlc3NmdWxseSEnICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm90aWZUeXBlID0gJ2Vycm9yJztcblx0XHRcdFx0XHRub3RpZk1lc3NhZ2UgPSBkYXRhLmRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnNob3dOb3RpZmljYXRpb24oIG5vdGlmVHlwZSwgbm90aWZNZXNzYWdlICk7XG5cdFx0XHR9IClcblx0XHRcdC5jYXRjaCggKCBlcnIgKSA9PiB7XG5cdFx0XHRcdHRoaXMuc2hvd05vdGlmaWNhdGlvbiggJ2Vycm9yJywgZXJyICk7XG5cdFx0XHR9IClcblx0XHRcdC50aGVuKCAoKSA9PiB7XG5cdFx0XHRcdC8vIENsb3NlIG1vZGFsXG5cdFx0XHRcdHRoaXMuY2xvc2VNb2RhbCgpO1xuXHRcdFx0fSApO1xuXG5cdH1cblxuXHQvLyBWYWxpZGF0ZSBtb2RhbC5cblx0dmFsaWRhdG9yKCkge1xuXHRcdGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcblx0XHRsZXQgaXNWYWxpZCA9IGZhbHNlLFxuXHRcdFx0dmFsaWRhdGlvbkVycm9yID0gW10sXG5cdFx0XHRpc1R5cGVWYWxpZCA9IGZhbHNlLFxuXHRcdFx0aXNBY2Nlc3NWYWxpZCA9IGZhbHNlXG5cdFx0XHQ7XG5cblx0XHQvLyBDaGVjayBpZiByb2xlIG9yIHVzZXIgaXMgc2VsZWN0ZWQuXG5cdFx0aWYgKFxuXHRcdFx0J3NwZWNpZmljJyA9PT0gc3RhdGUucGVybWlzc2lvbl90eXBlICYmXG5cdFx0XHRfLmlzRW1wdHkoIHN0YXRlLnNwZWNpZmljX3VzZXIgKVxuXHRcdCkge1xuXG5cdFx0XHRpc1R5cGVWYWxpZCA9IGZhbHNlO1xuXHRcdFx0dmFsaWRhdGlvbkVycm9yLnB1c2goIHRyYW5zbGF0ZSggJ25vIHVzZXIgc2VsZWN0ZWQnICkgKTtcblxuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHQncm9sZScgPT09IHN0YXRlLnBlcm1pc3Npb25fdHlwZSAmJlxuXHRcdFx0Xy5pc0VtcHR5KCBzdGF0ZS51c2VyX3JvbGUgKVxuXHRcdCkge1xuXG5cdFx0XHRpc1R5cGVWYWxpZCA9IGZhbHNlO1xuXHRcdFx0dmFsaWRhdGlvbkVycm9yLnB1c2goIHRyYW5zbGF0ZSggJ25vIHJvbGUgc2VsZWN0ZWQnICkgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpc1R5cGVWYWxpZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgYWxsIGFjY2VzcyBhcmUgdW5jaGVja2VkLlxuXHRcdGlmIChcblx0XHRcdChcblx0XHRcdFx0ISBpc1RydWUoIHN0YXRlLm1hbmFnZV9mb3JtaW5hdG9yX21vZHVsZXMgKSAmJlxuXHRcdFx0XHQhIGlzVHJ1ZSggc3RhdGUubWFuYWdlX2Zvcm1pbmF0b3Jfc3VibWlzc2lvbnMgKSAmJlxuXHRcdFx0XHQhIGlzVHJ1ZSggc3RhdGUubWFuYWdlX2Zvcm1pbmF0b3JfYWRkb25zICkgJiZcblx0XHRcdFx0ISBpc1RydWUoIHN0YXRlLm1hbmFnZV9mb3JtaW5hdG9yX2ludGVncmF0aW9ucyApICYmXG5cdFx0XHRcdCEgaXNUcnVlKCBzdGF0ZS5tYW5hZ2VfZm9ybWluYXRvcl9yZXBvcnRzICkgJiZcblx0XHRcdFx0ISBpc1RydWUoIHN0YXRlLm1hbmFnZV9mb3JtaW5hdG9yX3NldHRpbmdzIClcblx0XHRcdClcblx0XHQpIHtcblx0XHRcdGlzQWNjZXNzVmFsaWQgPSBmYWxzZTtcblx0XHRcdHZhbGlkYXRpb25FcnJvci5wdXNoKCB0cmFuc2xhdGUoICdubyBwZXJtaXNzaW9ucyBjaGVja2VkJyApICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlzQWNjZXNzVmFsaWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggaXNUeXBlVmFsaWQgJiYgaXNBY2Nlc3NWYWxpZCApIHtcblx0XHRcdGlzVmFsaWQgPSB0cnVlO1xuXG5cdFx0XHRpZiAoICEgXy5pc1VuZGVmaW5lZCggdGhpcy4kc2F2ZUJ0biApICkge1xuXHRcdFx0XHR0aGlzLiRzYXZlQnRuLnBhcmVudCggJy5idG4tc2F2ZS13cmFwJyApLnJlbW92ZUNsYXNzKCAnc3VpLXRvb2x0aXAnICk7XG5cdFx0XHRcdHRoaXMuJHNhdmVCdG4ucHJvcCggJ2Rpc2FibGVkJywgZmFsc2UgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aXNWYWxpZCA9IGZhbHNlO1xuXHRcdFx0dmFsaWRhdGlvbkVycm9yID0gdmFsaWRhdGlvbkVycm9yLmpvaW4oICcsICcgKTtcblxuXHRcdFx0aWYgKCAhIF8uaXNVbmRlZmluZWQoIHRoaXMuJHNhdmVCdG4gKSApIHtcblx0XHRcdFx0dGhpcy4kc2F2ZUJ0bi5wYXJlbnQoICcuYnRuLXNhdmUtd3JhcCcgKS5hZGRDbGFzcyggJ3N1aS10b29sdGlwJyApO1xuXHRcdFx0XHR0aGlzLiRzYXZlQnRuLnByb3AoICdkaXNhYmxlZCcsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0aXNWYWxpZDogaXNWYWxpZCxcblx0XHRcdHZhbGlkYXRpb25FcnJvcjogdmFsaWRhdGlvbkVycm9yLFxuXHRcdH07XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IHRpdGxlVGFnID0gJycsXG5cdFx0XHRlZGl0Tm90aWNlID0gJycsXG5cdFx0XHRzYXZlQnRuID0gdHJhbnNsYXRlKCAnQWRkIFBlcm1pc3Npb25zJyApO1xuXG5cdFx0Y29uc3QgaXNOZXcgPSBpc1RydWUoIHRoaXMubW9kYWxEYXRhLm5ldyApO1xuXHRcdGNvbnN0IG1vZGFsVGl0bGUgPSB0cmFuc2xhdGUoIGlzTmV3ID8gJ0FkZCBQZXJtaXNzaW9ucycgOiAnRWRpdCBQZXJtaXNzaW9ucycgKTtcblx0XHRjb25zdCBwZXJtaXNzaW9uVHlwZSA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5tb2RhbERhdGEucGVybWlzc2lvbl90eXBlICkgP1xuXHRcdFx0dGhpcy5tb2RhbERhdGEucGVybWlzc2lvbl90eXBlIDpcblx0XHRcdCdyb2xlJztcblxuXHRcdC8vIFNldCB0aGUgdGV4dCBkZXBlbmRpbmcgb24gcGVybWlzc2lvblR5cGUuXG5cdFx0aWYgKCAhIGlzTmV3ICkge1xuXHRcdFx0c2F2ZUJ0biA9IHRyYW5zbGF0ZSggJ1VwZGF0ZSBQZXJtaXNzaW9ucycgKTtcblxuXHRcdFx0aWYgKCAncm9sZScgPT09IHBlcm1pc3Npb25UeXBlICkge1xuXHRcdFx0XHR0aXRsZVRhZyA9IHRyYW5zbGF0ZSggJ1VzZXIgUm9sZScgKTtcblx0XHRcdFx0ZWRpdE5vdGljZSA9IHRyYW5zbGF0ZShcblx0XHRcdFx0XHQnWW91IGFyZSBlZGl0aW5nIHBlcm1pc3Npb25zIGZvciB0aGUge3tifX0lKHJvbGUpc3t7L2J9fSB1c2VyIHJvbGUuJyxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdHJvbGU6IHRoaXMudXNlclJvbGVzWyB0aGlzLm1vZGFsRGF0YS51c2VyX3JvbGUgXS5uYW1lLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGNvbXBvbmVudHM6IHtcblx0XHRcdFx0XHRcdFx0YjogPGIvPixcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgdXNlcklkcyA9IHRoaXMuc3RhdGUuc3BlY2lmaWNfdXNlcjtcblx0XHRcdFx0Y29uc3QgbnVtVXNlcnMgPSB0aGlzLnN0YXRlLnNwZWNpZmljX3VzZXIubGVuZ3RoO1xuXHRcdFx0XHRjb25zdCB1c2VyTmFtZSA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5zdGF0ZS51c2VyX2luZm9bIHVzZXJJZHNbMF0gXSApID8gdGhpcy5zdGF0ZS51c2VyX2luZm9bIHVzZXJJZHNbMF0gXS5uYW1lIDogdGhpcy5zdGF0ZS5jdXJyZW50X3VzZXIubmFtZTtcblx0XHRcdFx0Y29uc3QgdXNlckVtYWlsID0gISBfLmlzVW5kZWZpbmVkKCB0aGlzLnN0YXRlLnVzZXJfaW5mb1sgdXNlcklkc1swXSBdICkgPyB0aGlzLnN0YXRlLnVzZXJfaW5mb1sgdXNlcklkc1swXSBdLmVtYWlsIDogdGhpcy5zdGF0ZS5jdXJyZW50X3VzZXIuZW1haWw7XG5cblx0XHRcdFx0dGl0bGVUYWcgPSB0cmFuc2xhdGUoICdTcGVjaWZpYyBVc2VyJyApO1xuXHRcdFx0XHRlZGl0Tm90aWNlID0gdHJhbnNsYXRlKFxuXHRcdFx0XHRcdCdZb3UgYXJlIGVkaXRpbmcgcGVybWlzc2lvbnMgZm9yIHt7Yn19JSh1c2VyTmFtZSlze3svYn19Jyxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdHVzZXJOYW1lOiB1c2VyTmFtZSxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRjb21wb25lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdGI6IDxiLz4sXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBFbmQgb2Ygc3RhdGVtZW50IGRlcGVuZHMgb24gdGhlIG51bWJlciBvZiB1c2Vycy5cblx0XHRcdFx0aWYgKCBudW1Vc2VycyA+IDEgKSB7XG5cdFx0XHRcdFx0ZWRpdE5vdGljZSA9IGVkaXROb3RpY2UuY29uY2F0KFxuXHRcdFx0XHRcdFx0JyAoJyArIHVzZXJFbWFpbCArICcpICsgJyArXG5cdFx0XHRcdFx0XHQoIG51bVVzZXJzIC0gMSApXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGlmICggbnVtVXNlcnMgPiAyICkge1xuXHRcdFx0XHRcdFx0ZWRpdE5vdGljZSA9IGVkaXROb3RpY2UuY29uY2F0KCB0cmFuc2xhdGUoICcgb3RoZXJzLicgKSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRlZGl0Tm90aWNlID0gZWRpdE5vdGljZS5jb25jYXQoIHRyYW5zbGF0ZSggJyBvdGhlci4nICkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlZGl0Tm90aWNlID0gZWRpdE5vdGljZS5jb25jYXQoICcgKCcgKyB1c2VyRW1haWwgKyAnKS4nICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXG5cdFx0XHRcdDxNb2RhbEhlYWRlclxuXHRcdFx0XHRcdGNsb3NlVHlwZT1cImljb25cIlxuXHRcdFx0XHRcdGNsb3NlTW9kYWw9eyB0aGlzLmNsb3NlTW9kYWwgfVxuXHRcdFx0XHQ+XG5cblx0XHRcdFx0XHQ8TW9kYWxUaXRsZVxuXHRcdFx0XHRcdFx0aWQ9XCJwZXJtaXNzaW9ucy1tb2RhbC10aXRsZVwiXG5cdFx0XHRcdFx0XHRsYWJlbD17IG1vZGFsVGl0bGUgfVxuXHRcdFx0XHRcdFx0dGFnPXsgdGl0bGVUYWcgfVxuXHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0PC9Nb2RhbEhlYWRlcj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ib3gtYm9keVwiPlxuXG5cdFx0XHRcdFx0eyBpc05ldyAmJlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1yb3dcIj5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2wtMTJcIj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXNldHRpbmdzLWxhYmVsIHN1aS1kYXJrXCI+eyB0cmFuc2xhdGUoICdVc2VyIFJvbGUvVXNlcnMnICkgfTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCI+XG5cdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdFx0XHQnQ2hvb3NlIHdoaWNoIHVzZXIgcm9sZSBvciBpbmRpdmlkdWFsIHVzZXIocykgc2hvdWxkIGhhdmUgYWNjZXNzICcgK1xuXHRcdFx0XHRcdFx0XHRcdFx0J3RvIHRoZSBGb3JtaW5hdG9yIGZlYXR1cmVzIHNlbGVjdGVkIGluIHRoZSBQZXJtaXNzaW9ucyBzZWN0aW9uIGJlbG93Lidcblx0XHRcdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXG5cdFx0XHRcdFx0XHRcdDxSYWRpb1RhYnNcblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdHNldHRpbmdzPXsgdGhpcy5zdGF0ZSB9XG5cdFx0XHRcdFx0XHRcdFx0dXBkYXRlUHJvcGVydHk9eyB0aGlzLnVwZGF0ZVByb3BlcnR5IH1cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cInBlcm1pc3Npb25fdHlwZVwiXG5cdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHR7ICEgXy5pc0VtcHR5KCB0aGlzLnVzZXJSb2xlcyApICYmXG5cdFx0XHRcdFx0XHRcdFx0PENvbnRhaW5lclxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnVXNlciBSb2xlJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlPVwicm9sZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRib3hDbGFzcz1cInN1aS10YWItYm94ZWRcIlxuXHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdDxTdWlTZWxlY3Rcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0c2V0dGluZ3M9eyB0aGlzLnN0YXRlIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlUHJvcGVydHk9eyB0aGlzLnVwZGF0ZVByb3BlcnR5IH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJ1c2VyX3JvbGVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ0Nob29zZSB1c2VyIHJvbGUnICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWU9eyB0aGlzLmRlZmF1bHRSb2xlIH1cblx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBfLm1hcCggdGhpcy51c2VyUm9sZXMsICggcm9sZSwgaWQgKSA9PiAoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT17IGlkIH0ga2V5PXsgaWQgfT5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsgcm9sZS5uYW1lIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L29wdGlvbj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0KSApIH1cblx0XHRcdFx0XHRcdFx0XHRcdDwvU3VpU2VsZWN0PlxuXHRcdFx0XHRcdFx0XHRcdFx0PFN1aVRhZ3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0c2V0dGluZ3M9eyB0aGlzLnN0YXRlIH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlUHJvcGVydHk9eyB0aGlzLnVwZGF0ZVByb3BlcnR5IH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJleGNsdWRlX3VzZXJzXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3R5bGU9e3sgbWFyZ2luQm90dG9tOicxMHB4JyB9fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zPXsgdGhpcy5nZXRVc2VyVGFnc09wdGlvbnMoKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnRXhjbHVkZSB1c2VycycgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCdVc2UgdGhpcyBvcHRpb24gdG8gZXhjbHVkZSBzcGVjaWZpYyAnICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQndXNlcnMgd2l0aCB0aGUgc2VsZWN0ZWQgcm9sZSBmcm9tIGFjY2Vzc2luZyBGb3JtaW5hdG9yLidcblx0XHRcdFx0XHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PC9Db250YWluZXI+XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdDxDb250YWluZXJcblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1NwZWNpZmljIFVzZXInICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWU9XCJzcGVjaWZpY1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRib3hDbGFzcz1cInN1aS10YWItYm94ZWRcIlxuXHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdDxTdWlUYWdzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNldHRpbmdzPXsgdGhpcy5zdGF0ZSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZVByb3BlcnR5PXsgdGhpcy51cGRhdGVQcm9wZXJ0eSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwic3BlY2lmaWNfdXNlclwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0eWxlPXt7IG1hcmdpbkJvdHRvbTonMTBweCcgfX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9ucz17IHRoaXMuZ2V0VXNlclRhZ3NPcHRpb25zKCAnc3BlY2lmaWNfdXNlcicgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQ2hvb3NlIHVzZXJzJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdFx0PC9Db250YWluZXI+XG5cblx0XHRcdFx0XHRcdFx0PC9SYWRpb1RhYnM+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR7ICEgaXNOZXcgJiZcblx0XHRcdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHRcdHJvbGU9XCJhbGVydFwiXG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1ub3RpY2Ugc3VpLWFjdGl2ZVwiXG5cdFx0XHRcdFx0XHRcdHN0eWxlPXsgeyBkaXNwbGF5OiAnYmxvY2snIH0gfVxuXHRcdFx0XHRcdFx0XHRhcmlhLWxpdmU9XCJhc3NlcnRpdmVcIlxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1ub3RpY2UtY29udGVudFwiPlxuXHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLW5vdGljZS1tZXNzYWdlXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktbm90aWNlLWljb24gc3VpLWljb24taW5mb1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHRcdFx0PHA+eyBlZGl0Tm90aWNlIH08L3A+XG5cdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHRcdHsgJ3JvbGUnID09PSBwZXJtaXNzaW9uVHlwZSAmJlxuXHRcdFx0XHRcdFx0PFJlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktc2V0dGluZ3MtbGFiZWwgc3VpLWRhcmtcIj57IHRyYW5zbGF0ZSggJ0V4Y2x1ZGUgdXNlcnMnICkgfTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCIgc3R5bGU9e3sgbWFyZ2luQm90dG9tOicxMHB4JyB9fT5cblx0XHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0XHRcdCdVc2UgdGhpcyBvcHRpb24gdG8gZXhjbHVkZSBzcGVjaWZpYyAnICtcblx0XHRcdFx0XHRcdFx0XHRcdCd1c2VycyB3aXRoIHRoZSBzZWxlY3RlZCByb2xlIGZyb20gYWNjZXNzaW5nIEZvcm1pbmF0b3IuJ1xuXHRcdFx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxTdWlUYWdzXG5cdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRzZXR0aW5ncz17IHRoaXMuc3RhdGUgfVxuXHRcdFx0XHRcdFx0XHRcdHVwZGF0ZVByb3BlcnR5PXsgdGhpcy51cGRhdGVQcm9wZXJ0eSB9XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJleGNsdWRlX3VzZXJzXCJcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zPXsgdGhpcy5nZXRVc2VyVGFnc09wdGlvbnMoKSB9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gbGFiZWw9eyB0cmFuc2xhdGUoICdFeGNsdWRlIHVzZXJzJyApIH1cblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHsgJ3NwZWNpZmljJyA9PT0gcGVybWlzc2lvblR5cGUgJiZcblx0XHRcdFx0XHRcdDxSZWFjdC5GcmFnbWVudD5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXNldHRpbmdzLWxhYmVsIHN1aS1kYXJrXCI+eyB0cmFuc2xhdGUoICdDaG9vc2UgdXNlcnMnICkgfTwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PFN1aVRhZ3Ncblx0XHRcdFx0XHRcdFx0XHR7IC4uLnRoaXMucHJvcHMgfVxuXHRcdFx0XHRcdFx0XHRcdHNldHRpbmdzPXsgdGhpcy5zdGF0ZSB9XG5cdFx0XHRcdFx0XHRcdFx0dXBkYXRlUHJvcGVydHk9eyB0aGlzLnVwZGF0ZVByb3BlcnR5IH1cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eT1cInNwZWNpZmljX3VzZXJcIlxuXHRcdFx0XHRcdFx0XHRcdHN0eWxlPXt7IG1hcmdpbkJvdHRvbTonMTBweCcgfX1cblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zPXsgdGhpcy5nZXRVc2VyVGFnc09wdGlvbnMoICdzcGVjaWZpY191c2VyJyApIH1cblx0XHRcdFx0XHRcdFx0XHQvLyBsYWJlbD17IHRyYW5zbGF0ZSggJ0Nob29zZSB1c2VycycgKSB9XG5cdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0PGhyLz5cblx0XHRcdFx0XHQ8L1JlYWN0LkZyYWdtZW50PlxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1yb3dcIj5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwic3VpLWJveC1zZXR0aW5ncy1jb2xcIj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLXNldHRpbmdzLWxhYmVsIHN1aS1kYXJrXCI+eyB0cmFuc2xhdGUoICdQZXJtaXNzaW9ucycgKSB9PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb25cIj5cblx0XHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0XHRcdCdDaG9vc2Ugd2hhdCBwZXJtaXNzaW9ucyB0aGUgc2VsZWN0ZWQgdXNlciByb2xlIG9yIHVzZXJzIHdpbGwgaGF2ZS4nXG5cdFx0XHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInN1aS1mb3JtLWZpZWxkIHBlcm1pc3Npb25zLWNoZWNrYm94ZXNcIj5cblx0XHRcdFx0XHRcdFx0XHQ8Q2hlY2tib3hcblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRzZXR0aW5ncz17IHRoaXMuc3RhdGUgfVxuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlUHJvcGVydHk9eyB0aGlzLnVwZGF0ZVByb3BlcnR5IH1cblx0XHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwibWFuYWdlX2Zvcm1pbmF0b3JfbW9kdWxlc1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ01vZHVsZXMnICkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0aXRlbUNsYXNzPVwic3VpLWNoZWNrYm94LXN0YWNrZWQgc3VpLWNoZWNrYm94LXNtXCJcblx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cInN1aS1kZXNjcmlwdGlvbiBwZXJtaXNzaW9uLWRlc2NyaXB0aW9uXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHR7IHRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0J0NyZWF0ZSwgZWRpdCwgYW5kIGRlbGV0ZSBtb2R1bGVzIChGb3JtcywgUG9sbHMsIFF1aXp6ZXMpLidcblx0XHRcdFx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHRcdFx0XHRcdDxDaGVja2JveFxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdHNldHRpbmdzPXsgdGhpcy5zdGF0ZSB9XG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVQcm9wZXJ0eT17IHRoaXMudXBkYXRlUHJvcGVydHkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJtYW5hZ2VfZm9ybWluYXRvcl9zdWJtaXNzaW9uc1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1N1Ym1pc3Npb25zJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdGl0ZW1DbGFzcz1cInN1aS1jaGVja2JveC1zdGFja2VkIHN1aS1jaGVja2JveC1zbVwiXG5cdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb24gcGVybWlzc2lvbi1kZXNjcmlwdGlvblwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCdBY2Nlc3MsIGV4cG9ydCwgYW5kIGRlbGV0ZSBzdWJtaXNzaW9ucy4nXG5cdFx0XHRcdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cblx0XHRcdFx0XHRcdFx0XHQ8Q2hlY2tib3hcblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRzZXR0aW5ncz17IHRoaXMuc3RhdGUgfVxuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlUHJvcGVydHk9eyB0aGlzLnVwZGF0ZVByb3BlcnR5IH1cblx0XHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwibWFuYWdlX2Zvcm1pbmF0b3JfYWRkb25zXCJcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQWRkLW9ucycgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRpdGVtQ2xhc3M9XCJzdWktY2hlY2tib3gtc3RhY2tlZCBzdWktY2hlY2tib3gtc21cIlxuXHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uIHBlcm1pc3Npb24tZGVzY3JpcHRpb25cIj5cblx0XHRcdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnVmlldywgaW5zdGFsbC91bmluc3RhbGwsIGFuZCBjb25maWd1cmUgQWRkLW9ucy4nXG5cdFx0XHRcdFx0XHRcdFx0XHQpIH1cblx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cblx0XHRcdFx0XHRcdFx0XHQ8Q2hlY2tib3hcblx0XHRcdFx0XHRcdFx0XHRcdHsgLi4udGhpcy5wcm9wcyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRzZXR0aW5ncz17IHRoaXMuc3RhdGUgfVxuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlUHJvcGVydHk9eyB0aGlzLnVwZGF0ZVByb3BlcnR5IH1cblx0XHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5PVwibWFuYWdlX2Zvcm1pbmF0b3JfaW50ZWdyYXRpb25zXCJcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnSW50ZWdyYXRpb25zJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdGl0ZW1DbGFzcz1cInN1aS1jaGVja2JveC1zdGFja2VkIHN1aS1jaGVja2JveC1zbVwiXG5cdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb24gcGVybWlzc2lvbi1kZXNjcmlwdGlvblwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCdBY2Nlc3MgYW5kIGNvbmZpZ3VyZSBnbG9iYWwgaW50ZWdyYXRpb25zLidcblx0XHRcdFx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHRcdFx0XHRcdDxDaGVja2JveFxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdHNldHRpbmdzPXsgdGhpcy5zdGF0ZSB9XG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVQcm9wZXJ0eT17IHRoaXMudXBkYXRlUHJvcGVydHkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJtYW5hZ2VfZm9ybWluYXRvcl9yZXBvcnRzXCJcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnUmVwb3J0cycgKSB9XG5cdFx0XHRcdFx0XHRcdFx0XHRpdGVtQ2xhc3M9XCJzdWktY2hlY2tib3gtc3RhY2tlZCBzdWktY2hlY2tib3gtc21cIlxuXHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uIHBlcm1pc3Npb24tZGVzY3JpcHRpb25cIj5cblx0XHRcdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQnVmlldyByZXBvcnRzIGFuZCBzY2hlZHVsZSBlbWFpbCBub3RpZmljYXRpb25zIGZvciBtb2R1bGVzLidcblx0XHRcdFx0XHRcdFx0XHRcdCkgfVxuXHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHRcdFx0XHRcdDxDaGVja2JveFxuXHRcdFx0XHRcdFx0XHRcdFx0eyAuLi50aGlzLnByb3BzIH1cblx0XHRcdFx0XHRcdFx0XHRcdHNldHRpbmdzPXsgdGhpcy5zdGF0ZSB9XG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVQcm9wZXJ0eT17IHRoaXMudXBkYXRlUHJvcGVydHkgfVxuXHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydHk9XCJtYW5hZ2VfZm9ybWluYXRvcl9zZXR0aW5nc1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRsYWJlbD17IHRyYW5zbGF0ZSggJ1NldHRpbmdzJyApIH1cblx0XHRcdFx0XHRcdFx0XHRcdGl0ZW1DbGFzcz1cInN1aS1jaGVja2JveC1zdGFja2VkIHN1aS1jaGVja2JveC1zbVwiXG5cdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktZGVzY3JpcHRpb24gcGVybWlzc2lvbi1kZXNjcmlwdGlvblwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0eyB0cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCdBY2Nlc3MgYW5kIGNvbmZpZ3VyZSBwbHVnaW4gc2V0dGluZ3MuJ1xuXHRcdFx0XHRcdFx0XHRcdFx0KSB9XG5cdFx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PE1vZGFsRm9vdGVyXG5cdFx0XHRcdFx0YWxpZ25tZW50PVwic2VwYXJhdGVkXCJcblx0XHRcdFx0PlxuXG5cdFx0XHRcdFx0PE1vZGFsQ2xvc2Vcblx0XHRcdFx0XHRcdGxhYmVsPXsgdHJhbnNsYXRlKCAnQ2FuY2VsJyApIH1cblx0XHRcdFx0XHRcdGNsb3NlTW9kYWw9eyB0aGlzLmNsb3NlTW9kYWwgfVxuXHRcdFx0XHRcdFx0Y29sb3I9XCJnaG9zdFwiXG5cdFx0XHRcdFx0Lz5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYnRuLXNhdmUtd3JhcFwiIGRhdGEtdG9vbHRpcD17IHRoaXMudmFsaWRhdG9yKCkudmFsaWRhdGlvbkVycm9yIH0+XG5cdFx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInN1aS1idXR0b24gc3VpLWJ1dHRvbi1ibHVlIGZvcm1pbmF0b3Itc2F2ZS1maWVsZC1zZXR0aW5nc1wiXG5cdFx0XHRcdFx0XHRcdGRhdGEtdG9vbHRpcD17IHRoaXMudmFsaWRhdG9yKCkudmFsaWRhdGlvbkVycm9yIH1cblx0XHRcdFx0XHRcdFx0b25DbGljaz17IHRoaXMuc2F2ZVBlcm1pc3Npb24gfVxuXHRcdFx0XHRcdFx0XHRyZWY9eyB0aGlzLnNhdmVCdG4gfVxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJzdWktbG9hZGluZy10ZXh0XCI+XG5cdFx0XHRcdFx0XHRcdFx0eyBzYXZlQnRuIH1cblx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8aSBjbGFzc05hbWU9XCJzdWktaWNvbi1sb2FkZXIgc3VpLWxvYWRpbmdcIiBhcmlhLWhpZGRlbj1cInRydWVcIiAvPlxuXHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PC9Nb2RhbEZvb3Rlcj5cblxuXHRcdFx0PC9SZWFjdC5GcmFnbWVudD5cblx0XHQpO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2V0dGluZ3MtcGFnZS9jb21wb25lbnRzL21vZGFscy9wZXJtaXNzaW9ucy5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHFzIGZyb20gJ3FzJztcbmltcG9ydCB7IHRyYW5zbGF0ZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzJztcblxuaW1wb3J0IE5vdGlmaWNhdGlvbiBmcm9tICcuLi8uLi8uLi9ub3RpZmljYXRpb25zJztcbmltcG9ydCBNb2RhbEhlYWRlciBmcm9tICcuLi8uLi8uLi9mb3JtL2NvbXBvbmVudHMvbW9kYWxzL3BhcnRpYWxzL2hlYWRlcic7XG5pbXBvcnQgTW9kYWxUaXRsZSBmcm9tICcuLi8uLi8uLi9mb3JtL2NvbXBvbmVudHMvbW9kYWxzL3BhcnRpYWxzL3RpdGxlJztcbmltcG9ydCBNb2RhbEZvb3RlciBmcm9tICcuLi8uLi8uLi9mb3JtL2NvbXBvbmVudHMvbW9kYWxzL3BhcnRpYWxzL2Zvb3Rlcic7XG5pbXBvcnQgTW9kYWxDbG9zZSBmcm9tICcuLi8uLi8uLi9mb3JtL2NvbXBvbmVudHMvbW9kYWxzL3BhcnRpYWxzL2Nsb3NlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgcGVybWlzc2lvbkRlbGV0ZU1vZGFsIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoIHByb3BzICkge1xuXHRcdHN1cGVyKCBwcm9wcyApO1xuXG5cdFx0dGhpcy5jbG9zZU1vZGFsID0gdGhpcy5wcm9wcy5tb2RhbC5tb2RhbFByb3BzLmNsb3NlTW9kYWwuYmluZCggdGhpcyApO1xuXHRcdHRoaXMuZGVsZXRlUGVybWlzc2lvbiA9IHRoaXMuZGVsZXRlUGVybWlzc2lvbi5iaW5kKCB0aGlzICk7XG5cdFx0dGhpcy5zaG93Tm90aWZpY2F0aW9uID0gdGhpcy5zaG93Tm90aWZpY2F0aW9uLmJpbmQoIHRoaXMgKTtcblxuXHRcdHRoaXMudXNlclJvbGVzID0gT2JqZWN0LmFzc2lnbigge30sIGZvcm1pbmF0b3JEYXRhLnVzZXJSb2xlcyApO1xuXHRcdHRoaXMubW9kYWxEYXRhID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMucHJvcHMubW9kYWwubW9kYWxQcm9wcyApO1xuXHR9XG5cblx0c2hvd05vdGlmaWNhdGlvbiggdHlwZSwgbXNnICkge1xuXHRcdGNvbnN0IGN1c3RvbSA9IG5ldyBOb3RpZmljYXRpb24oIHtcblx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHR0ZXh0OiAnZXJyb3InID09PSB0eXBlID9cblx0XHRcdFx0dHJhbnNsYXRlKCAnU29tZXRoaW5nIHdlbnQgd3JvbmcuIFBsZWFzZSB0cnkgYWdhaW4uJyApIDpcblx0XHRcdFx0bXNnLFxuXHRcdH0gKTtcblxuXHRcdGN1c3RvbS5vcGVuKCk7XG5cblx0XHRpZiAoICdlcnJvcicgPT09IHR5cGUgKSB7XG5cdFx0XHRjb25zb2xlLmxvZyggbXNnICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jbG9zZU1vZGFsKCk7XG5cdH1cblxuXHRkZWxldGVQZXJtaXNzaW9uKCkge1xuXHRcdGxldCBwZXJtaXNzaW9ucyA9IHRoaXMucHJvcHMucGVybWlzc2lvbnM7XG5cblx0XHRwZXJtaXNzaW9ucyA9IHBlcm1pc3Npb25zLmZpbHRlciggcGVybWlzc2lvbiA9PiB7XG5cdFx0XHRyZXR1cm4gcGVybWlzc2lvbi5waWQgIT09IHRoaXMubW9kYWxEYXRhLnBpZDtcblx0XHR9ICk7XG5cblx0XHRjb25zdCBwZXJtaXNzaW9uRGF0YSA9IHtcblx0XHRcdGFjdGlvbjogJ2Zvcm1pbmF0b3Jfc2F2ZV9wZXJtaXNzaW9ucycsXG5cdFx0XHRfd3Bub25jZTogZm9ybWluYXRvckRhdGEucGVybWlzc2lvbl9ub25jZSxcblx0XHRcdG1vZGU6ICdkZWxldGUnLFxuXHRcdFx0cGlkOiB0aGlzLm1vZGFsRGF0YS5waWQsXG5cdFx0XHRwZXJtaXNzaW9uczogSlNPTi5zdHJpbmdpZnkoIHBlcm1pc3Npb25zICksXG5cdFx0fTtcblxuXHRcdGF4aW9zLnBvc3QoIGZvcm1pbmF0b3JEYXRhLmFqYXhVcmwsXG5cdFx0XHRxcy5zdHJpbmdpZnkoIHBlcm1pc3Npb25EYXRhIClcblx0XHQpXG5cdFx0XHQudGhlbiggKCByZXMgKSA9PiB7XG5cdFx0XHRcdGlmICggcmVzLmRhdGEuc3VjY2VzcyApIHtcblxuXHRcdFx0XHRcdHRoaXMucHJvcHMuYWN0aW9ucy5wZXJtaXNzaW9uQWN0aW9ucy51cGRhdGVQZXJtaXNzaW9ucyggcGVybWlzc2lvbnMgKTtcblxuXHRcdFx0XHRcdHRoaXMuc2hvd05vdGlmaWNhdGlvbihcblx0XHRcdFx0XHRcdCdzdWNjZXNzJyxcblx0XHRcdFx0XHRcdHRyYW5zbGF0ZSggJ1Blcm1pc3Npb24gc3VjY2Vzc2Z1bGx5IGRlbGV0ZWQuJyApXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuc2hvd05vdGlmaWNhdGlvbiggJ2Vycm9yJywgcmVzLmRhdGEuZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IClcblx0XHRcdC5jYXRjaCggKCBlcnIgKSA9PiB7XG5cdFx0XHRcdHRoaXMuc2hvd05vdGlmaWNhdGlvbiggJ2Vycm9yJywgZXJyICk7XG5cdFx0XHR9ICk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IGRlc2NyaXB0aW9uID0gJyc7XG5cblx0XHRjb25zdCBwZXJtaXNzaW9uVHlwZSA9ICEgXy5pc1VuZGVmaW5lZCggdGhpcy5tb2RhbERhdGEucGVybWlzc2lvbl90eXBlICkgP1xuXHRcdFx0dGhpcy5tb2RhbERhdGEucGVybWlzc2lvbl90eXBlIDpcblx0XHRcdCdyb2xlJztcblxuXHRcdGlmICggJ3JvbGUnID09PSBwZXJtaXNzaW9uVHlwZSApIHtcblxuXHRcdFx0ZGVzY3JpcHRpb24gPSB0cmFuc2xhdGUoXG5cdFx0XHRcdCdBcmUgeW91IHN1cmUgeW91IHdpc2ggdG8gZGVsZXRlIHRoZSBwZXJtaXNzaW9ucyBydWxlIGZvciB0aGUge3tifX0lKHJvbGUpc3t7L2J9fSB1c2VyIHJvbGU/Jyxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdHJvbGU6IHRoaXMudXNlclJvbGVzWyB0aGlzLm1vZGFsRGF0YS51c2VyX3JvbGUgXS5uYW1lLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Y29tcG9uZW50czoge1xuXHRcdFx0XHRcdFx0YjogPGIvPixcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBkZXNjcmlwdGlvblByZXRleHQgPSB0cmFuc2xhdGUoXG5cdFx0XHRcdCdBcmUgeW91IHN1cmUgeW91IHdpc2ggdG8gZGVsZXRlIHRoZSBwZXJtaXNzaW9ucyBmb3Ige3tifX0lKGZpcnN0TmFtZSlze3svYn19ICcsXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRmaXJzdE5hbWU6IHRoaXMubW9kYWxEYXRhLnVzZXJfaW5mb1sgdGhpcy5tb2RhbERhdGEuc3BlY2lmaWNfdXNlclswXSBdLm5hbWUsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRjb21wb25lbnRzOiB7XG5cdFx0XHRcdFx0XHRiOiA8Yi8+LFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKCB0aGlzLm1vZGFsRGF0YS5zcGVjaWZpY191c2VyLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb25QcmV0ZXh0LmNvbmNhdCggdHJhbnNsYXRlKFxuXHRcdFx0XHRcdCdhbmQgJShleHRyYSlzIG90aGVyIHVzZXIocyk/Jyxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdGV4dHJhOiB0aGlzLm1vZGFsRGF0YS5zcGVjaWZpY191c2VyLmxlbmd0aCAtIDEsXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb25QcmV0ZXh0LmNvbmNhdChcblx0XHRcdFx0XHQnKCcgKyB0aGlzLm1vZGFsRGF0YS51c2VyX2luZm9bIHRoaXMubW9kYWxEYXRhLnNwZWNpZmljX3VzZXJbMF0gXS5lbWFpbCArICcpPydcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8UmVhY3QuRnJhZ21lbnQ+XG5cblx0XHRcdFx0PE1vZGFsSGVhZGVyXG5cdFx0XHRcdFx0ZmxhdHRlbj17IHRydWUgfVxuXHRcdFx0XHRcdGFsaWdubWVudD1cImNlbnRlclwiXG5cdFx0XHRcdFx0Y2xvc2VNb2RhbD17IHRoaXMuY2xvc2VNb2RhbCB9XG5cdFx0XHRcdFx0Y2xvc2VUeXBlPVwiaWNvblwiXG5cdFx0XHRcdFx0Y3VzdG9tQ2xhc3M9XCJzdWktc3BhY2luZy10b3AtLTYwXCJcblx0XHRcdFx0PlxuXG5cdFx0XHRcdFx0PE1vZGFsVGl0bGVcblx0XHRcdFx0XHRcdGlkPVwiZm9ybWluYXRvci1kZWxldGUtcGVybWlzc2lvbi1tb2RhbF9fdGl0bGVcIiAvLyBNaXNzaW5nIGlkLlxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdEZWxldGUgUGVybWlzc2lvbnMnICkgfVxuXHRcdFx0XHRcdFx0c2l6ZT1cImxnXCJcblx0XHRcdFx0XHQvPlxuXG5cdFx0XHRcdFx0PHAgY2xhc3NOYW1lPVwic3VpLWRlc2NyaXB0aW9uXCI+eyBkZXNjcmlwdGlvbiB9PC9wPlxuXG5cdFx0XHRcdDwvTW9kYWxIZWFkZXI+XG5cblx0XHRcdFx0PE1vZGFsRm9vdGVyXG5cdFx0XHRcdFx0Y3VzdG9tQ2xhc3M9XCJzdWktZmxhdHRlbiBzdWktY29udGVudC1jZW50ZXJcIlxuXHRcdFx0XHQ+XG5cblx0XHRcdFx0XHQ8TW9kYWxDbG9zZVxuXHRcdFx0XHRcdFx0bGFiZWw9eyB0cmFuc2xhdGUoICdDYW5jZWwnICkgfVxuXHRcdFx0XHRcdFx0Y2xvc2VNb2RhbD17IHRoaXMuY2xvc2VNb2RhbCB9XG5cdFx0XHRcdFx0XHRjdXN0b21DbGFzcz1cInN1aS1idXR0b24tZ2hvc3RcIlxuXHRcdFx0XHRcdC8+XG5cblx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJzdWktYnV0dG9uIHN1aS1idXR0b24tZ2hvc3Qgc3VpLWJ1dHRvbi1yZWQgcGVybWlzc2lvbi1kZWxldGUtYnV0dG9uXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9eyB0aGlzLmRlbGV0ZVBlcm1pc3Npb24gfVxuXHRcdFx0XHRcdD5cblxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwic3VpLWxvYWRpbmctdGV4dFwiPlxuXHRcdFx0XHRcdFx0XHQ8aSBjbGFzc05hbWU9XCJzdWktaWNvbi10cmFzaFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8+XG5cdFx0XHRcdFx0XHRcdHsgdHJhbnNsYXRlKCAnRGVsZXRlJyApIH1cblx0XHRcdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHRcdFx0PGkgY2xhc3NOYW1lPVwic3VpLWljb24tbG9hZGVyIHN1aS1sb2FkaW5nXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cblxuXHRcdFx0XHRcdDwvYnV0dG9uPlxuXG5cdFx0XHRcdDwvTW9kYWxGb290ZXI+XG5cblx0XHRcdDwvUmVhY3QuRnJhZ21lbnQ+XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NldHRpbmdzLXBhZ2UvY29tcG9uZW50cy9tb2RhbHMvcGVybWlzc2lvbi1kZWxldGUuanMiXSwic291cmNlUm9vdCI6IiJ9